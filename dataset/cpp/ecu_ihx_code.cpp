
//
// Warning: don't edit - generated by generate_ecu_code.pl processing ../dev/ihx_i1.json: IHX 78: Integrated automatic heating/aircon
// This generated code  makes it easier to process CANBUS messages from the IHX ecu in a BMW i3
//

  case I3_PID_IHX_EDH_VERRIEGELUNG: {                                             // 0xA11B
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_EDH_VERRIEGELUNG", 2);
        break;
    }

    unsigned char STAT_EDH_VERRIEGELUNG_AKTIV = (RXBUF_UCHAR(0));
        // Lock status (active = 1 / not active = 0. / Zustand der Verriegelung (aktiv = 1/nicht aktiv = 0.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "EDH_VERRIEGELUNG", "STAT_EDH_VERRIEGELUNG_AKTIV", STAT_EDH_VERRIEGELUNG_AKTIV, "\"0/1\"");

    unsigned char STAT_EDH_VERRIEGELUNG_ZAEHLER_WERT = (RXBUF_UCHAR(1));
        // Indicates the number of protective interlocks that have occurred so far. / Gibt die Anzahl der bisher
        // aufgetretenen Schutzverriegelungen an.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "EDH_VERRIEGELUNG", "STAT_EDH_VERRIEGELUNG_ZAEHLER_WERT", STAT_EDH_VERRIEGELUNG_ZAEHLER_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_WP_BEFUELLUNG: {                                                // 0xA11C
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_WP_BEFUELLUNG", 1);
        break;
    }

    unsigned char STAT_WP_BEFUELLUNG = (RXBUF_UCHAR(0));
        // 0x00 diagnostic job is not running; 0x01 Daignose job started / 0x00 Diagnosejob läuft nicht; 0x01 Daignosejob
        // gestartet
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "WP_BEFUELLUNG", "STAT_WP_BEFUELLUNG", STAT_WP_BEFUELLUNG, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_WP_EXP_VENTIL_KALIBRIEREN: {                                    // 0xA11D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_WP_EXP_VENTIL_KALIBRIEREN", 1);
        break;
    }

    unsigned char STAT_KALIBRIERUNG = (RXBUF_UCHAR(0));
        // Calibration status: 0x00 = calibration not active 0x01 = calibration active / Status der Kalibrierung: 0x00 =
        // Kalibrierung nicht aktiv 0x01 = Kalibrierung aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "WP_EXP_VENTIL_KALIBRIEREN", "STAT_KALIBRIERUNG", STAT_KALIBRIERUNG, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SITZHEIZUNG_VORNE_TASTER_LINKS: {                               // 0xD15D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SITZHEIZUNG_VORNE_TASTER_LINKS", 1);
        break;
    }

    unsigned char STAT_TASTER_SITZHEIZUNG_VORNE_LINKS_EIN = (RXBUF_UCHAR(0));
        // 0 = button not pressed, 1 = button pressed / 0 = Taste nicht betätigt, 1 = Taste betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_TASTER_LINKS", "STAT_TASTER_SITZHEIZUNG_VORNE_LINKS_EIN", STAT_TASTER_SITZHEIZUNG_VORNE_LINKS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SITZHEIZUNG_VORNE_TASTER_RECHTS: {                              // 0xD15E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SITZHEIZUNG_VORNE_TASTER_RECHTS", 1);
        break;
    }

    unsigned char STAT_TASTER_SITZHEIZUNG_VORNE_RECHTS_EIN = (RXBUF_UCHAR(0));
        // 0 = button not pressed, 1 = button pressed / 0 = Taste nicht betätigt, 1 = Taste betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_TASTER_RECHTS", "STAT_TASTER_SITZHEIZUNG_VORNE_RECHTS_EIN", STAT_TASTER_SITZHEIZUNG_VORNE_RECHTS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SITZHEIZUNG_VORNE_LED_RECHTS: {                                 // 0xD15F
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SITZHEIZUNG_VORNE_LED_RECHTS", 4);
        break;
    }

    unsigned char STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE1_EIN = (RXBUF_UCHAR(0));
        // LED: 0 = OFF, 1 = ON / LED: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_LED_RECHTS", "STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE1_EIN", STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE1_EIN, "\"0/1\"");

    unsigned char STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE2_EIN = (RXBUF_UCHAR(1));
        // LED: 0 = OFF, 1 = ON / LED: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_LED_RECHTS", "STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE2_EIN", STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE2_EIN, "\"0/1\"");

    unsigned char STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE3_EIN = (RXBUF_UCHAR(2));
        // LED: 0 = OFF, 1 = ON / LED: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_LED_RECHTS", "STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE3_EIN", STAT_LED_SITZHEIZUNG_VORNE_RECHTS_STUFE3_EIN, "\"0/1\"");

    unsigned char STAT_LED_SITZHEIZUNG_VORNE_RECHTS_NR = (RXBUF_UCHAR(3));
        // 0 = LEDs off, 1 = one LED on, 2 = two LEDs on, 3 = three LEDs on, 255 = LEDs not available / 0 = LEDs aus, 1 =
        // eine LED ein, 2 = zwei LEDs ein, 3 = drei LEDs ein, 255 = LEDs nicht vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_LED_RECHTS", "STAT_LED_SITZHEIZUNG_VORNE_RECHTS_NR", STAT_LED_SITZHEIZUNG_VORNE_RECHTS_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SITZHEIZUNG_VORNE_LED_LINKS: {                                  // 0xD160
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SITZHEIZUNG_VORNE_LED_LINKS", 4);
        break;
    }

    unsigned char STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE1_EIN = (RXBUF_UCHAR(0));
        // LED: 0 = OFF, 1 = ON / LED: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_LED_LINKS", "STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE1_EIN", STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE1_EIN, "\"0/1\"");

    unsigned char STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE2_EIN = (RXBUF_UCHAR(1));
        // LED: 0 = OFF, 1 = ON / LED: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_LED_LINKS", "STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE2_EIN", STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE2_EIN, "\"0/1\"");

    unsigned char STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE3_EIN = (RXBUF_UCHAR(2));
        // LED: 0 = OFF, 1 = ON / LED: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_LED_LINKS", "STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE3_EIN", STAT_LED_SITZHEIZUNG_VORNE_LINKS_STUFE3_EIN, "\"0/1\"");

    unsigned char STAT_LED_SITZHEIZUNG_VORNE_LINKS_NR = (RXBUF_UCHAR(3));
        // 0 = LEDs off, 1 = one LED on, 2 = two LEDs on, 3 = three LEDs on, 255 = LEDs not available / 0 = LEDs aus, 1 =
        // eine LED ein, 2 = zwei LEDs ein, 3 = drei LEDs ein, 255 = LEDs nicht vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_LED_LINKS", "STAT_LED_SITZHEIZUNG_VORNE_LINKS_NR", STAT_LED_SITZHEIZUNG_VORNE_LINKS_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_FBM_TASTEN_VORHANDEN_WERT: {                                    // 0xD599
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_FBM_TASTEN_VORHANDEN_WERT", 1);
        break;
    }

    unsigned char STAT_FBM_TASTEN_VORHANDEN_WERT = (RXBUF_UCHAR(0));
        // Indicates how many FBM buttons are installed: 0 = no FBM buttons installed, 1 = 1 button installed, 2 = 2
        // buttons installed, N = n buttons installed, 255 = number unknown / Gibt aus, wieviele FBM-Tasten verbaut sind:
        // 0 = keine FBM-Tasten verbaut, 1 = 1 Taste verbaut, 2 = 2 Tasten verbaut, N = n Tasten verbaut, 255 = Anzahl
        // unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "FBM_TASTEN_VORHANDEN_WERT", "STAT_FBM_TASTEN_VORHANDEN_WERT", STAT_FBM_TASTEN_VORHANDEN_WERT, "\"Tasten\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TEMP_FUSSRAUM_LINKS_WERT: {                                     // 0xD859
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TEMP_FUSSRAUM_LINKS_WERT", 1);
        break;
    }

    char STAT_TEMP_FUSSRAUM_LINKS_WERT = (RXBUF_SCHAR(0));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TEMP_FUSSRAUM_LINKS_WERT", "STAT_TEMP_FUSSRAUM_LINKS_WERT", STAT_TEMP_FUSSRAUM_LINKS_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TEMP_FUSSRAUM_RECHTS_WERT: {                                    // 0xD85A
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TEMP_FUSSRAUM_RECHTS_WERT", 1);
        break;
    }

    char STAT_TEMP_FUSSRAUM_RECHTS_WERT = (RXBUF_SCHAR(0));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TEMP_FUSSRAUM_RECHTS_WERT", "STAT_TEMP_FUSSRAUM_RECHTS_WERT", STAT_TEMP_FUSSRAUM_RECHTS_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TEMP_INNEN_UNBELUEFTET: {                                       // 0xD85C
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TEMP_INNEN_UNBELUEFTET", 1);
        break;
    }

    char STAT_TEMP_INNEN_WERT = (RXBUF_SCHAR(0));
        // Calculated internal temperature / Errechnete Innentemperatur
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TEMP_INNEN_UNBELUEFTET", "STAT_TEMP_INNEN_WERT", STAT_TEMP_INNEN_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_POTI_SCHICHTUNG_FOND_WERT: {                             // 0xD860
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_POTI_SCHICHTUNG_FOND_WERT", 1);
        break;
    }

    unsigned char STAT_BUS_IN_POTI_SCHICHTUNG_FOND_WERT = (RXBUF_UCHAR(0));
        // Potentiometer layering base: 0 ... 100% / Potentiometer Schichtung Fond:  0 ... 100%
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_IN_POTI_SCHICHTUNG_FOND_WERT", "STAT_BUS_IN_POTI_SCHICHTUNG_FOND_WERT", STAT_BUS_IN_POTI_SCHICHTUNG_FOND_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KONFIGURATION_KLIMA_VORN: {                                     // 0xD866
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KONFIGURATION_KLIMA_VORN", 7);
        break;
    }

    unsigned char STAT_VORHANDEN_ZUSATZWASSERPUMPE = (RXBUF_UCHAR(0));
        // 0 = not available, 1 = available / 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KONFIGURATION_KLIMA_VORN", "STAT_VORHANDEN_ZUSATZWASSERPUMPE", STAT_VORHANDEN_ZUSATZWASSERPUMPE, "\"0/1\"");

    unsigned char STAT_KLIMA_DISPLAY_EINHEIT_NR = (RXBUF_UCHAR(1));
        // 0 = Celsius, 1 = Fahrenheit / 0 = Celsius,  1 = Fahrenheit
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KONFIGURATION_KLIMA_VORN", "STAT_KLIMA_DISPLAY_EINHEIT_NR", STAT_KLIMA_DISPLAY_EINHEIT_NR, "\"0-n\"");

    unsigned char STAT_KLIMA_VARIANTE_NR = (RXBUF_UCHAR(2));
        // Climate variant: For values see table TAB_KLIMAVARIANTE / Klimavariante:  Werte siehe Tabelle
        // TAB_KLIMAVARIANTE
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KONFIGURATION_KLIMA_VORN", "STAT_KLIMA_VARIANTE_NR", STAT_KLIMA_VARIANTE_NR, "\"0-n\"");

    unsigned char STAT_VORHANDEN_EMOTORWASSERPUMPE = (RXBUF_UCHAR(3));
        // 0 = not available, 1 = available / 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KONFIGURATION_KLIMA_VORN", "STAT_VORHANDEN_EMOTORWASSERPUMPE", STAT_VORHANDEN_EMOTORWASSERPUMPE, "\"0/1\"");

    unsigned char STAT_VORHANDEN_KOMPRESSORKUPPLUNG = (RXBUF_UCHAR(4));
        // 0 = not available, 1 = available / 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KONFIGURATION_KLIMA_VORN", "STAT_VORHANDEN_KOMPRESSORKUPPLUNG", STAT_VORHANDEN_KOMPRESSORKUPPLUNG, "\"0/1\"");

    unsigned char STAT_VORHANDEN_PTC_VORN = (RXBUF_UCHAR(5));
        // PTC module: 0 = not available, 1 = available / PTC-Modul: 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KONFIGURATION_KLIMA_VORN", "STAT_VORHANDEN_PTC_VORN", STAT_VORHANDEN_PTC_VORN, "\"0/1\"");

    unsigned char STAT_VORHANDEN_UMWAELZPUMPE = (RXBUF_UCHAR(6));
        // 0 = not available, 1 = available / 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KONFIGURATION_KLIMA_VORN", "STAT_VORHANDEN_UMWAELZPUMPE", STAT_VORHANDEN_UMWAELZPUMPE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KAELTEMITTEL_MEDIUM: {                                          // 0xD868
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KAELTEMITTEL_MEDIUM", 1);
        break;
    }

    unsigned char STAT_KAELTEMITTEL_MEDIUM_NR = (RXBUF_UCHAR(0));
        // Cooling medium: 0 = R134a, 1 = CO2 / Kühlmedium: 0 = R134a, 1 = CO2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KAELTEMITTEL_MEDIUM", "STAT_KAELTEMITTEL_MEDIUM_NR", STAT_KAELTEMITTEL_MEDIUM_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_STEUERN_MOTOREN_KALIBRIERLAUF: {                                // 0xD88D
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SCHRITTMOTOR_FEHLER: {                                          // 0xD88E
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SCHRITTMOTOR_FEHLER", 8);
        break;
    }

    unsigned short STAT_SCHRITTMOTOR_BLOCKIERUNG_WERT = (RXBUF_UINT(0));
        // Output of the status of the stepper motor activated last: Error counter blocking stepper motor / Ausgabe des
        // Status des zuletzt angesteuerten Schrittmotors: Fehlerzähler Blockierung Schrittmotor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "SCHRITTMOTOR_FEHLER", "STAT_SCHRITTMOTOR_BLOCKIERUNG_WERT", STAT_SCHRITTMOTOR_BLOCKIERUNG_WERT, "\"Fehler\"");

    unsigned short STAT_SCHRITTMOTOR_ANTWORT_FEHLT_WERT = (RXBUF_UINT(2));
        // Output of the status of the last activated stepper motor: Error counter response stepper motor / Ausgabe des
        // Status des zuletzt angesteuerten Schrittmotors: Fehlerzähler Antwort Schrittmotor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "SCHRITTMOTOR_FEHLER", "STAT_SCHRITTMOTOR_ANTWORT_FEHLT_WERT", STAT_SCHRITTMOTOR_ANTWORT_FEHLT_WERT, "\"Fehler\"");

    unsigned short STAT_SCHRITTMOTOR_INTERNER_FEHLER_WERT = (RXBUF_UINT(4));
        // Output of the status of the stepper motor activated last: Error counter for internal motor errors / Ausgabe
        // des Status des zuletzt angesteuerten Schrittmotors: Fehlerzähler interner Motorfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "SCHRITTMOTOR_FEHLER", "STAT_SCHRITTMOTOR_INTERNER_FEHLER_WERT", STAT_SCHRITTMOTOR_INTERNER_FEHLER_WERT, "\"Fehler\"");

    unsigned short STAT_SCHRITTMOTOR_INITIALISIERUNG_FEHLER_WERT = (RXBUF_UINT(6));
        // Output of the status of the stepper motor activated last: Error counter initialization error / Ausgabe des
        // Status des zuletzt angesteuerten Schrittmotors: Fehlerzähler Initialisierungsfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "SCHRITTMOTOR_FEHLER", "STAT_SCHRITTMOTOR_INITIALISIERUNG_FEHLER_WERT", STAT_SCHRITTMOTOR_INITIALISIERUNG_FEHLER_WERT, "\"Fehler\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_STEUERN_SELBSTTEST_SCHRITTMOTOREN: {                            // 0xD88F
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VORHANDEN_FONDSCHICHTUNG: {                                     // 0xD8AA
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VORHANDEN_FONDSCHICHTUNG", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_FONDSCHICHTUNGSPOTI = (RXBUF_UCHAR(0));
        // 0 = rear stratification potentiometer not available 1 = rear stratification potentiometer available /
        // 0=Fondschichtungspotentiometer nicht vorhanden 1=Fondschichtungspotentiometer vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VORHANDEN_FONDSCHICHTUNG", "STAT_VORHANDEN_FONDSCHICHTUNGSPOTI", STAT_VORHANDEN_FONDSCHICHTUNGSPOTI, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SOLARSENSOR_VORHANDEN: {                                        // 0xD8AB
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SOLARSENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_SOLARSENSOR_EIN = (RXBUF_UCHAR(0));
        // Solar sensor: 0 = not available / coded; 1 = present / coded / Solarsensor: 0 = nicht vorhanden / codiert; 1 =
        // vorhanden / codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SOLARSENSOR_VORHANDEN", "STAT_VORHANDEN_SOLARSENSOR_EIN", STAT_VORHANDEN_SOLARSENSOR_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_AUC_SENSOR_VORHANDEN: {                                         // 0xD8AC
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_AUC_SENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_AUC_SENSOR = (RXBUF_UCHAR(0));
        // AUC sensor: 0 = not available; 1 = present / AUC-Sensor: 0 = nicht vorhanden; 1 = vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "AUC_SENSOR_VORHANDEN", "STAT_VORHANDEN_AUC_SENSOR", STAT_VORHANDEN_AUC_SENSOR, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_EKK_DREHZAHLERHOEHUNG: {                                        // 0xD8C2
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_EKK_DREHZAHLERHOEHUNG", 1);
        break;
    }

    unsigned char STAT_EKK_DREHZAHLERHOEHUNG_EIN = (RXBUF_UCHAR(0));
        // Speed increase EKK 0 = OFF, 1 = ON / Drehzahlerhöhung EKK 0=AUS, 1=EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "EKK_DREHZAHLERHOEHUNG", "STAT_EKK_DREHZAHLERHOEHUNG_EIN", STAT_EKK_DREHZAHLERHOEHUNG_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_EKMV_ANALOGWERTE_GEN20: {                                       // 0xD8C4
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_EKMV_ANALOGWERTE_GEN20", 6);
        break;
    }

    float STAT_DREHZAHL_WERT = (RXBUF_UCHAR(0)/2.0f);
        // Output of the actual speed / Ausgabe der Ist-Drehzahl
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "EKMV_ANALOGWERTE_GEN20", "STAT_DREHZAHL_WERT", STAT_DREHZAHL_WERT, "\"%\"");

    float STAT_LEISTUNG_WERT = (RXBUF_UCHAR(1)/25.0f);
        // Output of the power in KW to 2 decimal places. The SG delivers the value with a factor of 25 and divides it by
        // 25 in the SGBD. / Ausgabe der Leistung in KW auf 2 Nachkommastellen genau. Vom SG wird der Wert mit Faktor 25
        // geliefert und in der SGBD durch 25 dividiert.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "EKMV_ANALOGWERTE_GEN20", "STAT_LEISTUNG_WERT", STAT_LEISTUNG_WERT, "\"kW\"");

    float STAT_STROM_DC_WERT = (RXBUF_UCHAR(2)/4.0f);
        // Output of the current of high voltage. / Ausgabe des Stroms der Hochspannung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "EKMV_ANALOGWERTE_GEN20", "STAT_STROM_DC_WERT", STAT_STROM_DC_WERT, "\"A\"");

    float STAT_HOCHSPANNUNG_WERT = (RXBUF_UCHAR(3)*2.0f);
        // Output of the high voltage in volts. Invalid Value = 510 volts / Ausgabe der Hochspannung in Volt.
        // Ungültigkeitswert = 510 Volt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "EKMV_ANALOGWERTE_GEN20", "STAT_HOCHSPANNUNG_WERT", STAT_HOCHSPANNUNG_WERT, "\"V\"");

    unsigned char STAT_TEMPERATUR_WERT = (RXBUF_UCHAR(4)-50.0);
        // Output of the temperature in degrees Celsius. The control unit delivers the value with offset 50. SGBD
        // subtracts 50. / Ausgabe der Temperatur in Grad Celsius. Das Steuergerät liefert den Wert mit Offset 50. SGBD
        // subtrahiert 50.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "EKMV_ANALOGWERTE_GEN20", "STAT_TEMPERATUR_WERT", STAT_TEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_STROM_AC_WERT = (RXBUF_UCHAR(5));
        // Output of the stream. / Ausgabe des Stroms.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "EKMV_ANALOGWERTE_GEN20", "STAT_STROM_AC_WERT", STAT_STROM_AC_WERT, "\"A\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_EKMV_BETRIEBSZUSTAND_GEN20: {                                   // 0xD8C5
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_EKMV_BETRIEBSZUSTAND_GEN20", 1);
        break;
    }

    unsigned char RES_0xD8C5_D = (RXBUF_UCHAR(0));
        // Operating states of refrigerant compressor Gen. 2.0 / Betriebszustände von Kältemittelverdichter Gen. 2.0
            // RES_0xD8C5_D is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "IHX", "EKMV_BETRIEBSZUSTAND_GEN20", "RES_0xD8C5_D", (unsigned long)RES_0xD8C5_D, "\"Bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_EDH_STATUS: {                                                   // 0xD8CD
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_EDH_STATUS", 8);
        break;
    }

    unsigned short STAT_TEMPERATUR_WASSERAUSTRITT_WERT = (RXBUF_UINT(0)-40.0);
        // Temperature of the heating water at the water outlet of the electric instantaneous water heater. / Temperatur
        // des Heizwassers am Wasseraustritt des elektrischen Durchlauferhitzers.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "EDH_STATUS", "STAT_TEMPERATUR_WASSERAUSTRITT_WERT", STAT_TEMPERATUR_WASSERAUSTRITT_WERT, "\"°C\"");

    float STAT_STROM_WERT = (RXBUF_UINT(2)*0.2f);
        // Current consumption (high voltage side) of the electric instantaneous water heater. / Stromaufnahme
        // (hochvoltseitig) des elektrischen Durchlauferhitzers.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "EDH_STATUS", "STAT_STROM_WERT", STAT_STROM_WERT, "\"A\"");

    float STAT_HOCHVOLTSPANNUNG_WERT = (RXBUF_UINT(4)*2.0f);
        // High-voltage voltage measured on the electrical water heater. Invalid Value = 510 volts. / Hochvoltspannung
        // gemessen am elektrischen Durchlauferhitzers. Ungültigkeitswert = 510 Volt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "EDH_STATUS", "STAT_HOCHVOLTSPANNUNG_WERT", STAT_HOCHVOLTSPANNUNG_WERT, "\"V\"");

    unsigned short STAT_ZAEHLER_VERRIEGELUNG_WERT = (RXBUF_UINT(6));
        // Interlocking counter of the electric water heater. / Verriegelungszähler des elektrischen Durchlauferhitzers.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "EDH_STATUS", "STAT_ZAEHLER_VERRIEGELUNG_WERT", STAT_ZAEHLER_VERRIEGELUNG_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KONFIGURATION_KLIMA_PRODUKTLINIE: {                             // 0xD8CE
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KONFIGURATION_KLIMA_PRODUKTLINIE", 1);
        break;
    }

    unsigned char STAT_KLIMA_PRODUKTLINIE = (RXBUF_UCHAR(0));
        // Outputs the product line coded in the control unit. See table TAB_KLIMA_PRODUKTLINIE / Gibt die im Steuergerät
        // codierte Produktlinie aus. Siehe Tabelle TAB_KLIMA_PRODUKTLINIE
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KONFIGURATION_KLIMA_PRODUKTLINIE", "STAT_KLIMA_PRODUKTLINIE", STAT_KLIMA_PRODUKTLINIE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_HV_POWERMANAGEMENT: {                                    // 0xD8D2
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_HV_POWERMANAGEMENT", 3);
        break;
    }

    unsigned char STAT_FREIGABE_KLIMAKOMPRESSOR = (RXBUF_UCHAR(0));
        // HV release for eKMV: 0x00 = no release 0x01 = release / HV-Freigabe für eKMV: 0x00 = keine Freigabe 0x01 =
        // Freigabe
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_IN_HV_POWERMANAGEMENT", "STAT_FREIGABE_KLIMAKOMPRESSOR", STAT_FREIGABE_KLIMAKOMPRESSOR, "\"0/1\"");

    float STAT_LEISTUNG_KLIMAKOMPRESSOR_MAXIMAL_WERT = (RXBUF_UINT(1)/1000.0f);
        // Maximum power provided by the HV-PM for the eKMV. / Maximal vom HV-PM für den eKMV bereitgestellte Leistung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "BUS_IN_HV_POWERMANAGEMENT", "STAT_LEISTUNG_KLIMAKOMPRESSOR_MAXIMAL_WERT", STAT_LEISTUNG_KLIMAKOMPRESSOR_MAXIMAL_WERT, "\"kW\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_HV_PM_EDH: {                                             // 0xD8D3
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_HV_PM_EDH", 3);
        break;
    }

    unsigned char STAT_FREIGABE_EDH = (RXBUF_UCHAR(0));
        // HV release for EDH: 0x00 = no release 0x01 = release / HV-Freigabe für EDH: 0x00 = keine Freigabe 0x01 =
        // Freigabe
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_IN_HV_PM_EDH", "STAT_FREIGABE_EDH", STAT_FREIGABE_EDH, "\"0/1\"");

    float STAT_LEISTUNG_EDH_MAXIMAL_WERT = (RXBUF_UINT(1)/1000.0f);
        // Maximum power provided by the HV-PM for the EDH. / Maximal vom HV-PM für den EDH bereitgestellte Leistung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "BUS_IN_HV_PM_EDH", "STAT_LEISTUNG_EDH_MAXIMAL_WERT", STAT_LEISTUNG_EDH_MAXIMAL_WERT, "\"kW\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_KUEHLMITTELTEMPERATUR: {                                 // 0xD8D4
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_KUEHLMITTELTEMPERATUR", 2);
        break;
    }

    short STAT_BUS_IN_KUEHLMITTEL_MOTOR_TEMP_WERT = (RXBUF_SINT(0));
        // Engine coolant temperature / Kühlmitteltemperatur Motor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "BUS_IN_KUEHLMITTELTEMPERATUR", "STAT_BUS_IN_KUEHLMITTEL_MOTOR_TEMP_WERT", STAT_BUS_IN_KUEHLMITTEL_MOTOR_TEMP_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SOLLWERT_ELEKTRISCHER_ZUHEIZER_VORN: {                          // 0xD902
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SOLLWERT_ELEKTRISCHER_ZUHEIZER_VORN", 1);
        break;
    }

    unsigned char STAT_SOLLWERT_ELEKTRISCHER_ZUHEIZER_WERT = (RXBUF_UCHAR(0));
        // Electrical auxiliary heater (PTC or EDH) setpoint in percent 0 - 100% / Elektrischer Zuheizer (PTC oder EDH)
        // Sollwert in Prozent 0 - 100 %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SOLLWERT_ELEKTRISCHER_ZUHEIZER_VORN", "STAT_SOLLWERT_ELEKTRISCHER_ZUHEIZER_WERT", STAT_SOLLWERT_ELEKTRISCHER_ZUHEIZER_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_OUT_ZUSATZWASSERPUMPE_EIN: {                                // 0xD904
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_OUT_ZUSATZWASSERPUMPE_EIN", 1);
        break;
    }

    unsigned char STAT_BUS_OUT_ZUSATZWASSERPUMPE_EIN = (RXBUF_UCHAR(0));
        // Auxiliary water pump status: 0 = OFF, 1 = ON / Zusatzwasserpumpenstatus: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_OUT_ZUSATZWASSERPUMPE_EIN", "STAT_BUS_OUT_ZUSATZWASSERPUMPE_EIN", STAT_BUS_OUT_ZUSATZWASSERPUMPE_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TIMER_EINLAUFSCHUTZ: {                                          // 0xD905
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TIMER_EINLAUFSCHUTZ", 2);
        break;
    }

    unsigned char STAT_TIMER_EINLAUFSCHUTZ_WERT = (RXBUF_UCHAR(0));
        // Remaining time of the inlet protection in seconds / Restzeit des Einlaufschutzes in Sekunden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TIMER_EINLAUFSCHUTZ", "STAT_TIMER_EINLAUFSCHUTZ_WERT", STAT_TIMER_EINLAUFSCHUTZ_WERT, "\"s\"");

    unsigned char STAT_TIMER_START_WERT = (RXBUF_UCHAR(1));
        // Start value from the timer for inlet protection / Startwert vom Timer für Einlaufschutz
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TIMER_EINLAUFSCHUTZ", "STAT_TIMER_START_WERT", STAT_TIMER_START_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SITZHEIZUNG_VORNE_TASTER_VORHANDEN: {                           // 0xD90E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SITZHEIZUNG_VORNE_TASTER_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_SITZHEIZUNG_TASTER_VORNE = (RXBUF_UCHAR(0));
        // 0 = not available 1 = available / 0=nicht vorhanden 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SITZHEIZUNG_VORNE_TASTER_VORHANDEN", "STAT_VORHANDEN_SITZHEIZUNG_TASTER_VORNE", STAT_VORHANDEN_SITZHEIZUNG_TASTER_VORNE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VORHANDEN_KOMPRESSORKUPPLUNG: {                                 // 0xD916
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VORHANDEN_KOMPRESSORKUPPLUNG", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_KOMPRESSORKUPPLUNG_0XD916 = (RXBUF_UCHAR(0));
        // 0 = compressor clutch not available 1 = compressor clutch available / 0=Kompressorkupplung nicht vorhanden
        // 1=Kompressorkupplung vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VORHANDEN_KOMPRESSORKUPPLUNG", "STAT_VORHANDEN_KOMPRESSORKUPPLUNG_0XD916", STAT_VORHANDEN_KOMPRESSORKUPPLUNG_0XD916, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_LUFTVERTEILUNG_LI_RE: {                              // 0xD91A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_LUFTVERTEILUNG_LI_RE", 2);
        break;
    }

    unsigned char STAT_KLIMA_VORN_LUFTVERTEILUNG_LINKS_NR = (RXBUF_UCHAR(0));
        // 1 = DOWN; 2 = CENTER; 3 = CENTER_BOTTOM; 4 = UP; 5 = TOP_UNTEN (driver only); 6 = TOP_MITTE; 7 =
        // TOP_MITTE_BOTTOM; 8 = AUTO; 32 = INDIVIDUAL; 40 = SPECIAL PROGRAM; 255 = INVALID (BASE); / 1=UNTEN; 2=MITTE;
        // 3=MITTE_UNTEN; 4=OBEN; 5=OBEN_UNTEN (Nur Fahrer); 6=OBEN_MITTE; 7=OBEN_MITTE_UNTEN; 8=AUTO; 32=INDIVIDUAL;
        // 40=SONDERPROGRAMM; 255=UNGUELTIG (BASIS);
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_LUFTVERTEILUNG_LI_RE", "STAT_KLIMA_VORN_LUFTVERTEILUNG_LINKS_NR", STAT_KLIMA_VORN_LUFTVERTEILUNG_LINKS_NR, "\"0-n\"");

    unsigned char STAT_KLIMA_VORN_LUFTVERTEILUNG_RECHTS_NR = (RXBUF_UCHAR(1));
        // 1 = DOWN; 2 = CENTER; 3 = CENTER_BOTTOM; 4 = UP; 5 = TOP_UNTEN (driver only); 6 = TOP_MITTE; 7 =
        // TOP_MITTE_BOTTOM; 8 = AUTO; 32 = INDIVIDUAL; 40 = SPECIAL PROGRAM; 255 = INVALID (BASE); / 1=UNTEN; 2=MITTE;
        // 3=MITTE_UNTEN; 4=OBEN; 5=OBEN_UNTEN (Nur Fahrer); 6=OBEN_MITTE; 7=OBEN_MITTE_UNTEN; 8=AUTO; 32=INDIVIDUAL;
        // 40=SONDERPROGRAMM; 255=UNGUELTIG (BASIS);
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_LUFTVERTEILUNG_LI_RE", "STAT_KLIMA_VORN_LUFTVERTEILUNG_RECHTS_NR", STAT_KLIMA_VORN_LUFTVERTEILUNG_RECHTS_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_OUT_KLIMAKOMPRESSOR_PWM_WERT: {                             // 0xD91D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_OUT_KLIMAKOMPRESSOR_PWM_WERT", 1);
        break;
    }

    unsigned char STAT_BUS_OUT_KLIMAKOMPRESSOR_PWM_WERT = (RXBUF_UCHAR(0));
        // Signal for requesting the compressor power in PWM / Signal für die Anforderung der Kompressorleistung in PWM
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_OUT_KLIMAKOMPRESSOR_PWM_WERT", "STAT_BUS_OUT_KLIMAKOMPRESSOR_PWM_WERT", STAT_BUS_OUT_KLIMAKOMPRESSOR_PWM_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_KLAPPEN_PRG_MITTE: {                                 // 0xD928
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_KLAPPEN_PRG_MITTE", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_KLAPPEN_PRG_MITTE = (RXBUF_UCHAR(0));
        // Automatic flap program: 0 = OFF = manual setting, 1 = ON = AUTO switched on / Automatik-Klappenprogramm: 0 =
        // AUS = Manuelle Einstellung, 1 = EIN = AUTO eingeschaltet
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_KLAPPEN_PRG_MITTE", "STAT_KLIMA_VORN_KLAPPEN_PRG_MITTE", STAT_KLIMA_VORN_KLAPPEN_PRG_MITTE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_GEBLAESESTUFE_ANZ: {                                 // 0xD92B
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_GEBLAESESTUFE_ANZ", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_GEBLAESESTUFE_ANZ_WERT = (RXBUF_UCHAR(0));
        // Outputs the display of the current fan speed. / Gibt die Anzeige der aktuellen Gebläsestufe aus.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_GEBLAESESTUFE_ANZ", "STAT_KLIMA_VORN_GEBLAESESTUFE_ANZ_WERT", STAT_KLIMA_VORN_GEBLAESESTUFE_ANZ_WERT, "\"Stufe\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_OFF_EIN: {                                           // 0xD92C
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_OFF_EIN", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_OFF_EIN = (RXBUF_UCHAR(0));
        // Function status air conditioning OFF: 0 = OFF = air conditioning is switched on, LED is off 1 = ON = air
        // conditioning is switched off, LED is on / Funktionsstatus Klima OFF: 0 = AUS = Klima ist eingeschaltet, LED
        // ist aus 1 = EIN = Klima ist ausgeschaltet, LED ist an
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_OFF_EIN", "STAT_KLIMA_VORN_OFF_EIN", STAT_KLIMA_VORN_OFF_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_DEFROST_EIN: {                                   // 0xD92D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_DEFROST_EIN", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_DEFROST_EIN = (RXBUF_UCHAR(0));
        // Defrost program: 0 = OFF, 1 = ON / Defrost-Programm: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_DEFROST_EIN", "STAT_KLIMA_VORN_PRG_DEFROST_EIN", STAT_KLIMA_VORN_PRG_DEFROST_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_MAX_AC_EIN: {                                    // 0xD92E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_MAX_AC_EIN", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_MAX_AC_EIN = (RXBUF_UCHAR(0));
        // Maximum cooling program: 0 = OFF, 1 = ON / Programm maximal Kühlen: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_MAX_AC_EIN", "STAT_KLIMA_VORN_PRG_MAX_AC_EIN", STAT_KLIMA_VORN_PRG_MAX_AC_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_AUC_EIN: {                                       // 0xD930
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_AUC_EIN", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_AUC_EIN = (RXBUF_UCHAR(0));
        // Automatic air circulation control: 0 = OFF, 1 = ON / Automatische Umluft Control: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_AUC_EIN", "STAT_KLIMA_VORN_PRG_AUC_EIN", STAT_KLIMA_VORN_PRG_AUC_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_UMLUFT_EIN: {                                    // 0xD931
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_UMLUFT_EIN", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_UMLUFT_EIN = (RXBUF_UCHAR(0));
        // Recirculation program: 0 = OFF, 1 = ON / Programm Umluft: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_UMLUFT_EIN", "STAT_KLIMA_VORN_PRG_UMLUFT_EIN", STAT_KLIMA_VORN_PRG_UMLUFT_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_HHS_EIN: {                                       // 0xD932
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_HHS_EIN", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_HHS_EIN = (RXBUF_UCHAR(0));
        // Rear window heating: 0 = OFF, 1 = ON / Heckscheibenheizung: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_HHS_EIN", "STAT_KLIMA_VORN_PRG_HHS_EIN", STAT_KLIMA_VORN_PRG_HHS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_AC_EIN: {                                        // 0xD934
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_AC_EIN", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_AC_EIN = (RXBUF_UCHAR(0));
        // Climate program: 0 = OFF, 1 = ON / Klimaprogramm: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_AC_EIN", "STAT_KLIMA_VORN_PRG_AC_EIN", STAT_KLIMA_VORN_PRG_AC_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_KLIMASTIL_MITTE: {                               // 0xD936
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_KLIMASTIL_MITTE", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_KLIMASTIL_MITTE_WERT = (RXBUF_UCHAR(0));
        // Output of the middle soft-intensity setting in steps: 1 - 7 / Ausgabe der Soft-Intense-Einstellung Mitte in
        // Stufen: 1 - 7
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_KLIMASTIL_MITTE", "STAT_KLIMA_VORN_PRG_KLIMASTIL_MITTE_WERT", STAT_KLIMA_VORN_PRG_KLIMASTIL_MITTE_WERT, "\"Stufe\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_STANDLUEFTEN_EIN: {                              // 0xD939
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_STANDLUEFTEN_EIN", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_STANDLUEFTEN_EIN = (RXBUF_UCHAR(0));
        // Independent ventilation program: 0 = OFF, 1 = ON / Programm Standlüften: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_STANDLUEFTEN_EIN", "STAT_KLIMA_VORN_PRG_STANDLUEFTEN_EIN", STAT_KLIMA_VORN_PRG_STANDLUEFTEN_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_GEBLAESELEISTUNG_WERT: {                             // 0xD93F
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_GEBLAESELEISTUNG_WERT", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_GEBLAESELEISTUNG_WERT = (RXBUF_UCHAR(0));
        // Fan output of the IHKA fan output stage in%. / Gebläseleistung der Gebläseendstufe IHKA in %.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_GEBLAESELEISTUNG_WERT", "STAT_KLIMA_VORN_GEBLAESELEISTUNG_WERT", STAT_KLIMA_VORN_GEBLAESELEISTUNG_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_DEFROST_WERT: {                                         // 0xD941
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_DEFROST_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_DEFROST_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) / Istwert
        // Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_DEFROST_WERT", "STAT_KLP_ISTPOS_DEFROST_WERT", STAT_KLP_ISTPOS_DEFROST_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_DEFROST_WERT = (RXBUF_UCHAR(1));
        // Setpoint of the damper position: 0 ... 100 / Sollwert der Klappenstellung: 0...100
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_DEFROST_WERT", "STAT_KLP_SOLLPOS_DEFROST_WERT", STAT_KLP_SOLLPOS_DEFROST_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_BELUEFTUNG_WERT: {                                      // 0xD942
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_BELUEFTUNG_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_BELUEFTUNG_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0..100% (127 = read value invalid, 255 = flap not available) / Istwert
        // Klappenöffnung; 0..100% (127 = gelesener Wert ungültig, 255=Klappe nicht vorhanden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_BELUEFTUNG_WERT", "STAT_KLP_ISTPOS_BELUEFTUNG_WERT", STAT_KLP_ISTPOS_BELUEFTUNG_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_BELUEFTUNG_WERT = (RXBUF_UCHAR(1));
        // Setpoint of the damper position: 0 ... 100% / Sollwert der Klappenstellung: 0 ... 100 %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_BELUEFTUNG_WERT", "STAT_KLP_SOLLPOS_BELUEFTUNG_WERT", STAT_KLP_SOLLPOS_BELUEFTUNG_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_FUSSRAUM_WERT: {                                        // 0xD947
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_FUSSRAUM_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_FUSSRAUM_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening: 0 ... 100 (127 = read value invalid, 255 = flap not available) / Istwert
        // Klappenöffnung: 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_FUSSRAUM_WERT", "STAT_KLP_ISTPOS_FUSSRAUM_WERT", STAT_KLP_ISTPOS_FUSSRAUM_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_FUSSRAUM_WERT = (RXBUF_UCHAR(1));
        // Setpoint damper position: 0 ... 100 / Sollwert Klappenstellung: 0...100
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_FUSSRAUM_WERT", "STAT_KLP_SOLLPOS_FUSSRAUM_WERT", STAT_KLP_SOLLPOS_FUSSRAUM_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_SCHICHTUNG_WERT: {                                      // 0xD949
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_SCHICHTUNG_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_SCHICHTUNG_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) / Istwert
        // Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_SCHICHTUNG_WERT", "STAT_KLP_ISTPOS_SCHICHTUNG_WERT", STAT_KLP_ISTPOS_SCHICHTUNG_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_SCHICHTUNG_WERT = (RXBUF_UCHAR(1));
        // Setpoint damper position: 0 ... 100 / Sollwert Klappenstellung: 0...100
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_SCHICHTUNG_WERT", "STAT_KLP_SOLLPOS_SCHICHTUNG_WERT", STAT_KLP_SOLLPOS_SCHICHTUNG_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_SCHICHTUNG_LI_WERT: {                                   // 0xD94A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_SCHICHTUNG_LI_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_SCHICHTUNG_LI_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) / Istwert
        // Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_SCHICHTUNG_LI_WERT", "STAT_KLP_ISTPOS_SCHICHTUNG_LI_WERT", STAT_KLP_ISTPOS_SCHICHTUNG_LI_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_SCHICHTUNG_LI_WERT = (RXBUF_UCHAR(1));
        // Setpoint damper position: 0 ... 100 / Sollwert Klappenstellung: 0...100
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_SCHICHTUNG_LI_WERT", "STAT_KLP_SOLLPOS_SCHICHTUNG_LI_WERT", STAT_KLP_SOLLPOS_SCHICHTUNG_LI_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_SCHICHTUNG_RE_WERT: {                                   // 0xD94B
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_SCHICHTUNG_RE_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_SCHICHTUNG_RE_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) / Istwert
        // Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_SCHICHTUNG_RE_WERT", "STAT_KLP_ISTPOS_SCHICHTUNG_RE_WERT", STAT_KLP_ISTPOS_SCHICHTUNG_RE_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_SCHICHTUNG_RE_WERT = (RXBUF_UCHAR(1));
        // Setpoint damper position: 0 ... 100 / Sollwert Klappenstellung: 0...100
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_SCHICHTUNG_RE_WERT", "STAT_KLP_SOLLPOS_SCHICHTUNG_RE_WERT", STAT_KLP_SOLLPOS_SCHICHTUNG_RE_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_UMLUFT_WERT: {                                          // 0xD94D
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_UMLUFT_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_UMLUFT_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) / Istwert
        // Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_UMLUFT_WERT", "STAT_KLP_ISTPOS_UMLUFT_WERT", STAT_KLP_ISTPOS_UMLUFT_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_UMLUFT_WERT = (RXBUF_UCHAR(1));
        // Setpoint damper position: 0 ... 100 / Sollwert Klappenstellung: 0...100
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_UMLUFT_WERT", "STAT_KLP_SOLLPOS_UMLUFT_WERT", STAT_KLP_SOLLPOS_UMLUFT_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_TEMP_LUFT_FOND_WERT: {                                  // 0xD950
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_TEMP_LUFT_FOND_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_TEMP_LUFT_FOND_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) / Istwert
        // Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_TEMP_LUFT_FOND_WERT", "STAT_KLP_ISTPOS_TEMP_LUFT_FOND_WERT", STAT_KLP_ISTPOS_TEMP_LUFT_FOND_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_TEMP_LUFT_FOND_WERT = (RXBUF_UCHAR(1));
        // Setpoint of the damper position: 0 ... 100 / Sollwert der Klappenstellung: 0...100
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_TEMP_LUFT_FOND_WERT", "STAT_KLP_SOLLPOS_TEMP_LUFT_FOND_WERT", STAT_KLP_SOLLPOS_TEMP_LUFT_FOND_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_MOTOR_KALIBRIERLAUF: {                                          // 0xD953
    if (datalen < 22) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_MOTOR_KALIBRIERLAUF", 22);
        break;
    }

    unsigned char STAT_KALIBRIERLAUF_NR = (RXBUF_UCHAR(0));
        // 0 = not yet started in this terminal cycle, 1 = calibration run is currently running, 2 = calibration run
        // completed / 0 = in diesem Klemmenzyklus noch nicht gestartet, 1 = Kalibrierlauf läuft gerade, 2 =
        // Kalibrierlauf abgeschlossen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_KALIBRIERLAUF_NR", STAT_KALIBRIERLAUF_NR, "\"0-n\"");

    unsigned char STAT_KALIBRIERLAUF_ERGEBNIS = (RXBUF_UCHAR(1));
        // 0 = calibration run completed NOK, 1 = calibration run completed OK and data saved; The result relates to the
        // last calibration run carried out. The result may only be saved after a completely completed calibration run. /
        // 0 = Kalibrierlauf abgeschlossen NIO, 1 = Kalibierlauf abgeschlossen IO und Daten gespeichert; Das Ergebnis
        // bezieht sich auf den zuletzt durchgeführten Kalibrierlauf. Das Ergebnis darf nur im Anschluss eines
        // vollständig durchlaufenen Kalibrierlaufs abgespeichert werden.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_KALIBRIERLAUF_ERGEBNIS", STAT_KALIBRIERLAUF_ERGEBNIS, "\"0/1\"");

    unsigned char STAT_MOTOR_1_NR = (RXBUF_UCHAR(2));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_1_NR", STAT_MOTOR_1_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_2_NR = (RXBUF_UCHAR(3));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_2_NR", STAT_MOTOR_2_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_3_NR = (RXBUF_UCHAR(4));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_3_NR", STAT_MOTOR_3_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_4_NR = (RXBUF_UCHAR(5));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_4_NR", STAT_MOTOR_4_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_5_NR = (RXBUF_UCHAR(6));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_5_NR", STAT_MOTOR_5_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_6_NR = (RXBUF_UCHAR(7));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_6_NR", STAT_MOTOR_6_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_7_NR = (RXBUF_UCHAR(8));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_7_NR", STAT_MOTOR_7_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_8_NR = (RXBUF_UCHAR(9));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_8_NR", STAT_MOTOR_8_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_9_NR = (RXBUF_UCHAR(10));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_9_NR", STAT_MOTOR_9_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_10_NR = (RXBUF_UCHAR(11));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_10_NR", STAT_MOTOR_10_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_11_NR = (RXBUF_UCHAR(12));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_11_NR", STAT_MOTOR_11_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_12_NR = (RXBUF_UCHAR(13));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_12_NR", STAT_MOTOR_12_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_13_NR = (RXBUF_UCHAR(14));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_13_NR", STAT_MOTOR_13_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_14_NR = (RXBUF_UCHAR(15));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_14_NR", STAT_MOTOR_14_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_15_NR = (RXBUF_UCHAR(16));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_15_NR", STAT_MOTOR_15_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_16_NR = (RXBUF_UCHAR(17));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_16_NR", STAT_MOTOR_16_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_17_NR = (RXBUF_UCHAR(18));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_17_NR", STAT_MOTOR_17_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_18_NR = (RXBUF_UCHAR(19));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_18_NR", STAT_MOTOR_18_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_19_NR = (RXBUF_UCHAR(20));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_19_NR", STAT_MOTOR_19_NR, "\"0-n\"");

    unsigned char STAT_MOTOR_20_NR = (RXBUF_UCHAR(21));
        // 0 = calibration NOK, 1 = calibration OK, 2 = flap not installed / 0 = Kalibrierung NIO, 1 = Kalibrierung IO, 2
        // = Klappe nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOTOR_KALIBRIERLAUF", "STAT_MOTOR_20_NR", STAT_MOTOR_20_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SELBSTTEST_SCHRITTMOTORE: {                                     // 0xD954
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SELBSTTEST_SCHRITTMOTORE", 1);
        break;
    }

    unsigned char STAT_SELBSTTEST_SCHRITTMOTORE_NR = (RXBUF_UCHAR(0));
        // Status of stepper motor self-tests: 0 = not started / not requested, 1 = test is currently running, 2 = test
        // successfully completed, 3 = test not completed successfully / Status Schrittmotorenselbsttests: 0 = nicht
        // gestartet/nicht angefordert, 1 = Test läuft gerade, 2 = Test erfolgreich abgeschlossen, 3 = Test nicht
        // erfolgreich abgeschlossen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "SELBSTTEST_SCHRITTMOTORE", "STAT_SELBSTTEST_SCHRITTMOTORE_NR", STAT_SELBSTTEST_SCHRITTMOTORE_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TEMP_BELUEFTUNG_LINKS_WERT: {                                   // 0xD957
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TEMP_BELUEFTUNG_LINKS_WERT", 1);
        break;
    }

    char STAT_TEMP_BELUEFTUNG_LINKS_WERT = (RXBUF_SCHAR(0));
        // Left ventilation flap temperature If the sensor is defective or unplugged, the value 127 is returned /
        // Temperatur Belüftungsklappe links Bei defektem oder abgesteckten Sensor wird der Wert 127 zurück geliefert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TEMP_BELUEFTUNG_LINKS_WERT", "STAT_TEMP_BELUEFTUNG_LINKS_WERT", STAT_TEMP_BELUEFTUNG_LINKS_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TEMP_BELUEFTUNG_RECHTS_WERT: {                                  // 0xD958
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TEMP_BELUEFTUNG_RECHTS_WERT", 1);
        break;
    }

    char STAT_TEMP_BELUEFTUNG_RECHTS_WERT = (RXBUF_SCHAR(0));
        // Right ventilation flap temperature If the sensor is defective or unplugged, the value 127 is returned /
        // Temperatur Belüftungsklappe rechts Bei defektem oder abgesteckten Sensor wird der Wert 127 zurück geliefert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TEMP_BELUEFTUNG_RECHTS_WERT", "STAT_TEMP_BELUEFTUNG_RECHTS_WERT", STAT_TEMP_BELUEFTUNG_RECHTS_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_DRUCKSENSOR_VORHANDEN: {                                        // 0xD959
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_DRUCKSENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_DRUCKSENSOR_VORHANDEN = (RXBUF_UCHAR(0));
        // Indicates whether a pressure sensor is installed for R134A: 0 = not available, 1 = available / Gibt aus, ob
        // ein Drucksensor für R134A verbaut ist: 0 = nicht vorhanden, 1 = vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "DRUCKSENSOR_VORHANDEN", "STAT_DRUCKSENSOR_VORHANDEN", STAT_DRUCKSENSOR_VORHANDEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VORHANDEN_WASSERVENTIL: {                                       // 0xD95A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VORHANDEN_WASSERVENTIL", 2);
        break;
    }

    unsigned char STAT_VORHANDEN_WASSERVENTIL_MONO = (RXBUF_UCHAR(0));
        // 0 = not available, 1 = available / 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VORHANDEN_WASSERVENTIL", "STAT_VORHANDEN_WASSERVENTIL_MONO", STAT_VORHANDEN_WASSERVENTIL_MONO, "\"0/1\"");

    unsigned char STAT_VORHANDEN_WASSERVENTIL_DUO = (RXBUF_UCHAR(1));
        // 0 = not available, 1 = available / 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VORHANDEN_WASSERVENTIL", "STAT_VORHANDEN_WASSERVENTIL_DUO", STAT_VORHANDEN_WASSERVENTIL_DUO, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TEMP_VERDAMPFER_WERT: {                                         // 0xD95C
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TEMP_VERDAMPFER_WERT", 1);
        break;
    }

    char STAT_TEMP_VERDAMPFER_WERT = (RXBUF_SCHAR(0));
        // Temperature sensor evaporator If the sensor is defective or unplugged, the value 127 is returned /
        // Temperaturfühler Verdampfer Bei defektem oder abgesteckten Sensor wird der Wert 127 zurück geliefert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TEMP_VERDAMPFER_WERT", "STAT_TEMP_VERDAMPFER_WERT", STAT_TEMP_VERDAMPFER_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_KOMPRESSORFREIGABE: {                                    // 0xD960
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_KOMPRESSORFREIGABE", 1);
        break;
    }

    unsigned char STAT_BUS_IN_KOMPRESSORFREIGABE_EIN = (RXBUF_UCHAR(0));
        // Air conditioning compressor release from the engine electronics: 0 = not released, 1 = released /
        // Klimakompressorfreigabe von der Motorelektronik: 0 = nicht freigegeben, 1 = Freigabe erteilt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_IN_KOMPRESSORFREIGABE", "STAT_BUS_IN_KOMPRESSORFREIGABE_EIN", STAT_BUS_IN_KOMPRESSORFREIGABE_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_SOLARSENSOR_WERT: {                                      // 0xD962
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_SOLARSENSOR_WERT", 4);
        break;
    }

    short STAT_BUS_IN_SOLARSENSOR_LINKS_WERT = (RXBUF_SINT(0));
        // Solar sensor / Solarsensor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "BUS_IN_SOLARSENSOR_WERT", "STAT_BUS_IN_SOLARSENSOR_LINKS_WERT", STAT_BUS_IN_SOLARSENSOR_LINKS_WERT, "\"W/m²\"");

    short STAT_BUS_IN_SOLARSENSOR_RECHTS_WERT = (RXBUF_SINT(2));
        // Solar sensor / Solarsensor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "BUS_IN_SOLARSENSOR_WERT", "STAT_BUS_IN_SOLARSENSOR_RECHTS_WERT", STAT_BUS_IN_SOLARSENSOR_RECHTS_WERT, "\"W/m²\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_AUC_SENSOR_WERT: {                                       // 0xD964
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_AUC_SENSOR_WERT", 1);
        break;
    }

    unsigned char STAT_BUS_IN_AUC_SENSOR_WERT = (RXBUF_UCHAR(0));
        // Load level from the AUC sensor / Belastungsstufe vom AUC-Sensor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_IN_AUC_SENSOR_WERT", "STAT_BUS_IN_AUC_SENSOR_WERT", STAT_BUS_IN_AUC_SENSOR_WERT, "\"Stufe\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_BESCHLAGSENSOR_WERT: {                                   // 0xD966
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_BESCHLAGSENSOR_WERT", 1);
        break;
    }

    unsigned char STAT_BUS_IN_BESCHLAGSENSOR_WERT = (RXBUF_UCHAR(0));
        // PMW signal condensation sensor / PMW-Signal Beschlagssensor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_IN_BESCHLAGSENSOR_WERT", "STAT_BUS_IN_BESCHLAGSENSOR_WERT", STAT_BUS_IN_BESCHLAGSENSOR_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_KAELTEMITTELDRUCK_WERT: {                                // 0xD968
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_KAELTEMITTELDRUCK_WERT", 1);
        break;
    }

    unsigned char STAT_BUS_IN_R134A_DRUCK_WERT = (RXBUF_UCHAR(0));
        // Refrigerant pressure for R134A / Kältemitteldruck für R134A
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_IN_KAELTEMITTELDRUCK_WERT", "STAT_BUS_IN_R134A_DRUCK_WERT", STAT_BUS_IN_R134A_DRUCK_WERT, "\"bar\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_IN_TEMP_AUSSEN_WERT: {                                      // 0xD96B
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_IN_TEMP_AUSSEN_WERT", 2);
        break;
    }

    float STAT_BUS_IN_TEMP_AUSSEN_WERT = (RXBUF_SINT(0)/2.0f-40.0);
        // Outside temperature / Außentemperatur
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "BUS_IN_TEMP_AUSSEN_WERT", "STAT_BUS_IN_TEMP_AUSSEN_WERT", STAT_BUS_IN_TEMP_AUSSEN_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BESCHLAGSENSOR_VORHANDEN: {                                     // 0xD96D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BESCHLAGSENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_BESCHLAGSENSOR = (RXBUF_UCHAR(0));
        // 0: Condensation sensor not available / coded 1: Condensation sensor available / coded / 0: Beschlagsensor
        // nicht vorhanden / codiert   1: Beschlagsensor vorhanden / codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BESCHLAGSENSOR_VORHANDEN", "STAT_VORHANDEN_BESCHLAGSENSOR", STAT_VORHANDEN_BESCHLAGSENSOR, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_TEMPERATUR_SOLLWERT: {                                    // 0xD977
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_TEMPERATUR_SOLLWERT", 2);
        break;
    }

    float STAT_KLIMA_VORNE_SOLLTEMP_LINKS_WERT = (RXBUF_UCHAR(0)/2.0f);
        // Output of the set target temperature on the left. / Ausgabe der eingestellten Sollwert-Temperatur links.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "KLIMA_TEMPERATUR_SOLLWERT", "STAT_KLIMA_VORNE_SOLLTEMP_LINKS_WERT", STAT_KLIMA_VORNE_SOLLTEMP_LINKS_WERT, "\"°C\"");

    float STAT_KLIMA_VORNE_SOLLTEMP_RECHTS_WERT = (RXBUF_UCHAR(1)/2.0f);
        // Output of the set target temperature on the right. / Ausgabe der eingestellten Sollwert-Temperatur rechts.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "KLIMA_TEMPERATUR_SOLLWERT", "STAT_KLIMA_VORNE_SOLLTEMP_RECHTS_WERT", STAT_KLIMA_VORNE_SOLLTEMP_RECHTS_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_LIN_1_ADRESSEN: {                                         // 0xD97B
    if (datalen < 36) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_LIN_1_ADRESSEN", 36);
        break;
    }

    short STAT_SLAVE1_ADR_WERT = (RXBUF_SINT(0));
        // Output address slave 1 / Ausgabe Adresse Slave 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE1_ADR_WERT", STAT_SLAVE1_ADR_WERT, "");

    short STAT_SLAVE2_ADR_WERT = (RXBUF_SINT(2));
        // Output address slave 2 / Ausgabe Adresse Slave 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE2_ADR_WERT", STAT_SLAVE2_ADR_WERT, "");

    short STAT_SLAVE3_ADR_WERT = (RXBUF_SINT(4));
        // Output address slave 3 / Ausgabe Adresse Slave 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE3_ADR_WERT", STAT_SLAVE3_ADR_WERT, "");

    short STAT_SLAVE4_ADR_WERT = (RXBUF_SINT(6));
        // Output address slave 4 / Ausgabe Adresse Slave 4
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE4_ADR_WERT", STAT_SLAVE4_ADR_WERT, "");

    short STAT_SLAVE5_ADR_WERT = (RXBUF_SINT(8));
        // Output address slave 5 / Ausgabe Adresse Slave 5
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE5_ADR_WERT", STAT_SLAVE5_ADR_WERT, "");

    short STAT_SLAVE6_ADR_WERT = (RXBUF_SINT(10));
        // Output address slave 6 / Ausgabe Adresse Slave 6
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE6_ADR_WERT", STAT_SLAVE6_ADR_WERT, "");

    short STAT_SLAVE7_ADR_WERT = (RXBUF_SINT(12));
        // Output address slave 7 / Ausgabe Adresse Slave 7
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE7_ADR_WERT", STAT_SLAVE7_ADR_WERT, "");

    short STAT_SLAVE8_ADR_WERT = (RXBUF_SINT(14));
        // Output address slave 8 / Ausgabe Adresse Slave 8
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE8_ADR_WERT", STAT_SLAVE8_ADR_WERT, "");

    short STAT_SLAVE9_ADR_WERT = (RXBUF_SINT(16));
        // Output address slave 9 / Ausgabe Adresse Slave 9
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE9_ADR_WERT", STAT_SLAVE9_ADR_WERT, "");

    short STAT_SLAVE10_ADR_WERT = (RXBUF_SINT(18));
        // Output address slave 10 / Ausgabe Adresse Slave 10
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE10_ADR_WERT", STAT_SLAVE10_ADR_WERT, "");

    short STAT_SLAVE11_ADR_WERT = (RXBUF_SINT(20));
        // Output address slave 11 / Ausgabe Adresse Slave 11
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE11_ADR_WERT", STAT_SLAVE11_ADR_WERT, "");

    short STAT_SLAVE12_ADR_WERT = (RXBUF_SINT(22));
        // Output address slave 12 / Ausgabe Adresse Slave 12
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE12_ADR_WERT", STAT_SLAVE12_ADR_WERT, "");

    short STAT_SLAVE13_ADR_WERT = (RXBUF_SINT(24));
        // Output address slave 13 / Ausgabe Adresse Slave 13
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE13_ADR_WERT", STAT_SLAVE13_ADR_WERT, "");

    short STAT_SLAVE14_ADR_WERT = (RXBUF_SINT(26));
        // Output address slave 14 / Ausgabe Adresse Slave 14
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE14_ADR_WERT", STAT_SLAVE14_ADR_WERT, "");

    short STAT_SLAVE15_ADR_WERT = (RXBUF_SINT(28));
        // Output address slave 15 / Ausgabe Adresse Slave 15
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE15_ADR_WERT", STAT_SLAVE15_ADR_WERT, "");

    short STAT_SLAVE16_ADR_WERT = (RXBUF_SINT(30));
        // Output address slave 16 / Ausgabe Adresse Slave 16
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_SLAVE16_ADR_WERT", STAT_SLAVE16_ADR_WERT, "");

    short STAT_MOT_0X3F_WERT = (RXBUF_SINT(32));
        // Availability of the slave with address 0x3F (63 dec): 0x00 = slave with address 0x3F installed, 0xFF = slave
        // with address 0x3F not installed / Verfügbarkeit des Slaves mit der Adresse 0x3F (63 dez): 0x00 = Slave mit
        // Adresse 0x3F verbaut, 0xFF = Slave mit Adresse 0x3F nicht verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_MOT_0X3F_WERT", STAT_MOT_0X3F_WERT, "");

    short STAT_FEHLERSTATUS_WERT = (RXBUF_SINT(34));
        // 0 = no error, 255 = unknown error / 0 = kein Fehler, 255 = unbekannter Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLIMA_LIN_1_ADRESSEN", "STAT_FEHLERSTATUS_WERT", STAT_FEHLERSTATUS_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_STEUERN_RESET_LIN: {                                            // 0xD97C
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLAPPEN_VERSTELLBEREICH: {                                      // 0xD980
    if (datalen < 40) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLAPPEN_VERSTELLBEREICH", 40);
        break;
    }

    short STAT_VERSTELLBEREICH_KLAPPE1_WERT = (RXBUF_SINT(0));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE1_WERT", STAT_VERSTELLBEREICH_KLAPPE1_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE2_WERT = (RXBUF_SINT(2));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE2_WERT", STAT_VERSTELLBEREICH_KLAPPE2_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE3_WERT = (RXBUF_SINT(4));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE3_WERT", STAT_VERSTELLBEREICH_KLAPPE3_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE4_WERT = (RXBUF_SINT(6));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE4_WERT", STAT_VERSTELLBEREICH_KLAPPE4_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE5_WERT = (RXBUF_SINT(8));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE5_WERT", STAT_VERSTELLBEREICH_KLAPPE5_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE6_WERT = (RXBUF_SINT(10));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE6_WERT", STAT_VERSTELLBEREICH_KLAPPE6_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE7_WERT = (RXBUF_SINT(12));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE7_WERT", STAT_VERSTELLBEREICH_KLAPPE7_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE8_WERT = (RXBUF_SINT(14));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE8_WERT", STAT_VERSTELLBEREICH_KLAPPE8_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE9_WERT = (RXBUF_SINT(16));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE9_WERT", STAT_VERSTELLBEREICH_KLAPPE9_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE10_WERT = (RXBUF_SINT(18));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE10_WERT", STAT_VERSTELLBEREICH_KLAPPE10_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE11_WERT = (RXBUF_SINT(20));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE11_WERT", STAT_VERSTELLBEREICH_KLAPPE11_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE12_WERT = (RXBUF_SINT(22));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE12_WERT", STAT_VERSTELLBEREICH_KLAPPE12_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE13_WERT = (RXBUF_SINT(24));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE13_WERT", STAT_VERSTELLBEREICH_KLAPPE13_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE14_WERT = (RXBUF_SINT(26));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE14_WERT", STAT_VERSTELLBEREICH_KLAPPE14_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE15_WERT = (RXBUF_SINT(28));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE15_WERT", STAT_VERSTELLBEREICH_KLAPPE15_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE16_WERT = (RXBUF_SINT(30));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE16_WERT", STAT_VERSTELLBEREICH_KLAPPE16_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE17_WERT = (RXBUF_SINT(32));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE17_WERT", STAT_VERSTELLBEREICH_KLAPPE17_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE18_WERT = (RXBUF_SINT(34));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE18_WERT", STAT_VERSTELLBEREICH_KLAPPE18_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE19_WERT = (RXBUF_SINT(36));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE19_WERT", STAT_VERSTELLBEREICH_KLAPPE19_WERT, "\"Inkremente\"");

    short STAT_VERSTELLBEREICH_KLAPPE20_WERT = (RXBUF_SINT(38));
        // Specification of the adjustment range in increments. / Angabe des Verstellbereiches in Inkrementen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "KLAPPEN_VERSTELLBEREICH", "STAT_VERSTELLBEREICH_KLAPPE20_WERT", STAT_VERSTELLBEREICH_KLAPPE20_WERT, "\"Inkremente\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_STEUERN_AUTOADR_KLAPPENMOTOREN: {                               // 0xD981
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_TEMPERATUR_MITTE_SOLLWERT: {                              // 0xD988
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_TEMPERATUR_MITTE_SOLLWERT", 1);
        break;
    }

    float STAT_KLIMA_SOLLTEMP_MITTE_WERT = (RXBUF_UCHAR(0)/2.0f);
        // Output of the set target temperature / Ausgabe der eingestellten Sollwert-Temperatur
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "KLIMA_TEMPERATUR_MITTE_SOLLWERT", "STAT_KLIMA_SOLLTEMP_MITTE_WERT", STAT_KLIMA_SOLLTEMP_MITTE_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_MISCHLUFT_WERT: {                                       // 0xD98A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_MISCHLUFT_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_MISCHLUFT_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) 0 = cold 100 = warm
        // / Istwert Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden) 0 = Kalt 100
        // = Warm
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_MISCHLUFT_WERT", "STAT_KLP_ISTPOS_MISCHLUFT_WERT", STAT_KLP_ISTPOS_MISCHLUFT_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_MISCHLUFT_WERT = (RXBUF_UCHAR(1));
        // Setpoint damper position: 0 ... 100: 0 = cold 100 = warm / Sollwert Klappenstellung: 0...100: 0 = Kalt 100 =
        // Warm
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_MISCHLUFT_WERT", "STAT_KLP_SOLLPOS_MISCHLUFT_WERT", STAT_KLP_SOLLPOS_MISCHLUFT_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_ZENTRALANTRIEB_WERT: {                                  // 0xD98B
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_ZENTRALANTRIEB_WERT", 4);
        break;
    }

    unsigned short STAT_MOT_ISTPOS_ZENTRALANTRIEB_WERT = (RXBUF_UINT(0));
        // Actual value of gate position: 0 ... 360 degrees IHKA: 0 = 100% defrost 120 = 100% ventilation 242 = 100%
        // footwell IHKA-VA02 IHKS: pos_ist = position according to stepper motor driver pos_function = position
        // according to board structure, KFL - if pos_ist is less than or equal to 100 : pos_function = 100 - pos_ist -
        // otherwise: pos_function = 460 - pos_ist / Istwert Kulissenstellung: 0...360 Grad IHKA: 0 = 100% Defrost 120 =
        // 100% Belüftung 242 = 100% Fussraum  IHKA-VA02 IHKS: pos_ist = Position laut Schrittmotortreiber pos_function =
        // Position laut Brettaufbau, KFL  - falls pos_ist kleiner oder gleich 100: pos_function = 100 - pos_ist - sonst:
        // pos_function = 460 - pos_ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "KLP_POS_ZENTRALANTRIEB_WERT", "STAT_MOT_ISTPOS_ZENTRALANTRIEB_WERT", STAT_MOT_ISTPOS_ZENTRALANTRIEB_WERT, "\"°\"");

    unsigned short STAT_MOT_SOLLPOS_ZENTRALANTRIEB_WERT = (RXBUF_UINT(2));
        // Setpoint gate position: 0 ... 360 degrees IHKA: 0 = 100% defrost 120 = 100% ventilation 242 = 100% footwell
        // IHKA-VA02 IHKS: pos_ist = position according to stepper motor driver pos_function = position according to
        // board structure, KFL - if pos_ist is less than or equal to 100 : pos_function = 100 - pos_ist - otherwise:
        // pos_function = 460 - pos_ist / Sollwert Kulissenstellung: 0...360 Grad IHKA: 0 = 100% Defrost 120 = 100%
        // Belüftung 242 = 100% Fussraum   IHKA-VA02 IHKS: pos_ist = Position laut Schrittmotortreiber pos_function =
        // Position laut Brettaufbau, KFL  - falls pos_ist kleiner oder gleich 100: pos_function = 100 - pos_ist - sonst:
        // pos_function = 460 - pos_ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "KLP_POS_ZENTRALANTRIEB_WERT", "STAT_MOT_SOLLPOS_ZENTRALANTRIEB_WERT", STAT_MOT_SOLLPOS_ZENTRALANTRIEB_WERT, "\"°\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_MISCHLUFT_LINKS_WERT: {                                 // 0xD98C
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_MISCHLUFT_LINKS_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_MISCHLUFT_LINKS_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) 0 = cold 100 = warm
        // / Istwert Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden) 0 = Kalt 100
        // = Warm
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_MISCHLUFT_LINKS_WERT", "STAT_KLP_ISTPOS_MISCHLUFT_LINKS_WERT", STAT_KLP_ISTPOS_MISCHLUFT_LINKS_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_MISCHLUFT_LINKS_WERT = (RXBUF_UCHAR(1));
        // Setpoint damper position: 0 ... 100 0 = cold 100 = warm / Sollwert Klappenstellung: 0...100 0 = Kalt 100 =
        // Warm
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_MISCHLUFT_LINKS_WERT", "STAT_KLP_SOLLPOS_MISCHLUFT_LINKS_WERT", STAT_KLP_SOLLPOS_MISCHLUFT_LINKS_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLP_POS_MISCHLUFT_RECHTS_WERT: {                                // 0xD98E
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLP_POS_MISCHLUFT_RECHTS_WERT", 2);
        break;
    }

    unsigned char STAT_KLP_ISTPOS_MISCHLUFT_RECHTS_WERT = (RXBUF_UCHAR(0));
        // Actual value flap opening; 0 ... 100 (127 = read value invalid, 255 = flap not available) 0 = cold 100 = warm
        // / Istwert Klappenöffnung; 0...100  (127 = gelesener Wert ungültig, 255 = Klappe nicht vorhanden) 0 = Kalt 100
        // = Warm
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_MISCHLUFT_RECHTS_WERT", "STAT_KLP_ISTPOS_MISCHLUFT_RECHTS_WERT", STAT_KLP_ISTPOS_MISCHLUFT_RECHTS_WERT, "\"%\"");

    unsigned char STAT_KLP_SOLLPOS_MISCHLUFT_RECHTS_WERT = (RXBUF_UCHAR(1));
        // Setpoint damper position: 0 ... 100 0 = cold 100 = warm / Sollwert Klappenstellung: 0...100 0 = Kalt 100 =
        // Warm
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLP_POS_MISCHLUFT_RECHTS_WERT", "STAT_KLP_SOLLPOS_MISCHLUFT_RECHTS_WERT", STAT_KLP_SOLLPOS_MISCHLUFT_RECHTS_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_MIKROSCHALTER_ZENTRALANTRIEB: {                                 // 0xD98F
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_MIKROSCHALTER_ZENTRALANTRIEB", 1);
        break;
    }

    unsigned char STAT_MIKROSCHALTER_ZENTRALANTRIEB_EIN = (RXBUF_UCHAR(0));
        // Output of the status of the microswitch on the central drive: 0 = OFF, 1 = ON / Ausgabe des Status des
        // Mikroschalters am Zentralantrieb:  0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MIKROSCHALTER_ZENTRALANTRIEB", "STAT_MIKROSCHALTER_ZENTRALANTRIEB_EIN", STAT_MIKROSCHALTER_ZENTRALANTRIEB_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TEMP_BELUEFTUNG_WERT: {                                         // 0xD990
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TEMP_BELUEFTUNG_WERT", 1);
        break;
    }

    char STAT_TEMP_BELUEFTUNG_WERT = (RXBUF_SCHAR(0));
        // Ventilation temperature sensor / Temperaturfühler Belüftung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TEMP_BELUEFTUNG_WERT", "STAT_TEMP_BELUEFTUNG_WERT", STAT_TEMP_BELUEFTUNG_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_TEMP_FUSSRAUM_WERT: {                                           // 0xD991
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_TEMP_FUSSRAUM_WERT", 1);
        break;
    }

    char STAT_TEMP_FUSSRAUM_WERT = (RXBUF_SCHAR(0));
        // Footwell temperature sensor / Temperaturfühler Fussraum
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "TEMP_FUSSRAUM_WERT", "STAT_TEMP_FUSSRAUM_WERT", STAT_TEMP_FUSSRAUM_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VORHANDEN_AUDIOBEDIENTEIL: {                                    // 0xD995
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VORHANDEN_AUDIOBEDIENTEIL", 2);
        break;
    }

    short STAT_VORHANDEN_AUDIOBEDIENTEIL = (RXBUF_SINT(0));
        // 0 = not available 1 = available / 0=nicht vorhanden 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "VORHANDEN_AUDIOBEDIENTEIL", "STAT_VORHANDEN_AUDIOBEDIENTEIL", STAT_VORHANDEN_AUDIOBEDIENTEIL, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_POTI_SCHICHTUNG_MITTE_WERT: {                                   // 0xD998
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_POTI_SCHICHTUNG_MITTE_WERT", 1);
        break;
    }

    unsigned char STAT_POTI_SCHICHTUNG_MITTE_WERT = (RXBUF_UCHAR(0));
        // Potentiometer stratification ventilation: 0 ... 100% / Potentiometer Schichtung Belüftung: 0 ... 100%
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "POTI_SCHICHTUNG_MITTE_WERT", "STAT_POTI_SCHICHTUNG_MITTE_WERT", STAT_POTI_SCHICHTUNG_MITTE_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_MOT_POS_BEL_FUSS_LI_RE_WERT: {                                  // 0xD99C
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_MOT_POS_BEL_FUSS_LI_RE_WERT", 4);
        break;
    }

    unsigned char STAT_MOT_ISTPOS_BEL_FUSS_LINKS_WERT = (RXBUF_UCHAR(0));
        // Actual value central drive ventilation footwell: 0 ... 100% / Istwert Zentralantrieb Belüftung Fussraum:
        // 0...100 %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOT_POS_BEL_FUSS_LI_RE_WERT", "STAT_MOT_ISTPOS_BEL_FUSS_LINKS_WERT", STAT_MOT_ISTPOS_BEL_FUSS_LINKS_WERT, "\"%\"");

    unsigned char STAT_MOT_ISTPOS_BEL_FUSS_RECHTS_WERT = (RXBUF_UCHAR(1));
        // Actual value central drive ventilation footwell: 0 ... 100% / Istwert Zentralantrieb Belüftung Fussraum:
        // 0...100 %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOT_POS_BEL_FUSS_LI_RE_WERT", "STAT_MOT_ISTPOS_BEL_FUSS_RECHTS_WERT", STAT_MOT_ISTPOS_BEL_FUSS_RECHTS_WERT, "\"%\"");

    unsigned char STAT_MOT_SOLLPOS_BEL_FUSS_LINKS_WERT = (RXBUF_UCHAR(2));
        // Setpoint central drive ventilation footwell: 0 ... 100% / Sollwert Zentralantrieb Belüftung Fussraum: 0...100
        // %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOT_POS_BEL_FUSS_LI_RE_WERT", "STAT_MOT_SOLLPOS_BEL_FUSS_LINKS_WERT", STAT_MOT_SOLLPOS_BEL_FUSS_LINKS_WERT, "\"%\"");

    unsigned char STAT_MOT_SOLLPOS_BEL_FUSS_RECHTS_WERT = (RXBUF_UCHAR(3));
        // Setpoint central drive ventilation footwell: 0 ... 100% / Sollwert Zentralantrieb Belüftung Fussraum: 0...100
        // %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "MOT_POS_BEL_FUSS_LI_RE_WERT", "STAT_MOT_SOLLPOS_BEL_FUSS_RECHTS_WERT", STAT_MOT_SOLLPOS_BEL_FUSS_RECHTS_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VARIANTE_AUDIOBEDIENTEIL: {                                     // 0xD9A0
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VARIANTE_AUDIOBEDIENTEIL", 1);
        break;
    }

    unsigned char STAT_VARIANTE_AUDIOBEDIENTEIL = (RXBUF_UCHAR(0));
        // For the audio control version, see table TAB_VARIANTE_AUDIOBEDIENTEIL / Variante Audiobedienteil siehe Tabelle
        // TAB_VARIANTE_AUDIOBEDIENTEIL
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VARIANTE_AUDIOBEDIENTEIL", "STAT_VARIANTE_AUDIOBEDIENTEIL", STAT_VARIANTE_AUDIOBEDIENTEIL, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_BUS_OUT_KOMPRESSORKUPPLUNG_EIN: {                               // 0xD9A1
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_BUS_OUT_KOMPRESSORKUPPLUNG_EIN", 1);
        break;
    }

    unsigned char STAT_BUS_OUT_KOMPRESSORKUPPLUNG_EIN = (RXBUF_UCHAR(0));
        // Signal for the request to the compressor clutch 0 = clutch open 1 = clutch closed / Signal für die Anforderung
        // an die Kompressorkupplung 0 = Kupplung offen 1 = Kupplung geschlossen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "BUS_OUT_KOMPRESSORKUPPLUNG_EIN", "STAT_BUS_OUT_KOMPRESSORKUPPLUNG_EIN", STAT_BUS_OUT_KOMPRESSORKUPPLUNG_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VORHANDEN_EKMV: {                                               // 0xD9A4
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VORHANDEN_EKMV", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_EKMV = (RXBUF_UCHAR(0));
        // Electric refrigerant compressor: see table TAB_KMV_HYBRID_GENERATION / Elektrischer Kältemittelverdichter:
        // siehe Tabelle TAB_KMV_HYBRID_GENERATION
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VORHANDEN_EKMV", "STAT_VORHANDEN_EKMV", STAT_VORHANDEN_EKMV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_KLIMA_VORN_PRG_HFS: {                                           // 0xD9A8
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_KLIMA_VORN_PRG_HFS", 1);
        break;
    }

    unsigned char STAT_KLIMA_VORN_PRG_HFS = (RXBUF_UCHAR(0));
        // Functional status of front window heating: 0 = OFF 1 = ON / Funktionszustand Frontscheibenheizung: 0 = AUS 1 =
        // EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "KLIMA_VORN_PRG_HFS", "STAT_KLIMA_VORN_PRG_HFS", STAT_KLIMA_VORN_PRG_HFS, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_WAERMEPUMPE_SENSOREN: {                                         // 0xD9AC
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_WAERMEPUMPE_SENSOREN", 14);
        break;
    }

    float STAT_WP_TEMPERATURFUEHLER_1_WERT = (RXBUF_UINT(0)*0.2f-20.0);
        // Heat pump temperature sensor 1 / Wärmepumpe Temperaturfühler 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "WAERMEPUMPE_SENSOREN", "STAT_WP_TEMPERATURFUEHLER_1_WERT", STAT_WP_TEMPERATURFUEHLER_1_WERT, "\"°C\"");

    float STAT_WP_TEMPERATURFUEHLER_2_WERT = (RXBUF_UINT(2)*0.2f-20.0);
        // Heat pump temperature sensor 2 / Wärmepumpe Temperaturfühler 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "WAERMEPUMPE_SENSOREN", "STAT_WP_TEMPERATURFUEHLER_2_WERT", STAT_WP_TEMPERATURFUEHLER_2_WERT, "\"°C\"");

    float STAT_WP_TEMPERATURFUEHLER_3_WERT = (RXBUF_UINT(4)*0.2f-20.0);
        // Heat pump temperature sensor 3 / Wärmepumpe Temperaturfühler 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "WAERMEPUMPE_SENSOREN", "STAT_WP_TEMPERATURFUEHLER_3_WERT", STAT_WP_TEMPERATURFUEHLER_3_WERT, "\"°C\"");

    float STAT_WP_PT_FUEHLER_1_DRUCK_WERT = (RXBUF_UINT(6)/10.0f);
        // Heat pump: pressure from pressure temperature sensor 1 / Wärmepumpe: Druck vom Druck-Temperaturfühler 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "WAERMEPUMPE_SENSOREN", "STAT_WP_PT_FUEHLER_1_DRUCK_WERT", STAT_WP_PT_FUEHLER_1_DRUCK_WERT, "\"bar\"");

    float STAT_WP_PT_FUEHLER_1_TEMP_WERT = (RXBUF_UINT(8)*0.2f-20.0);
        // Heat pump: temperature from pressure temperature sensor 1 / Wärmepumpe: Temperatur vom Druck-Temperaturfühler
        // 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "WAERMEPUMPE_SENSOREN", "STAT_WP_PT_FUEHLER_1_TEMP_WERT", STAT_WP_PT_FUEHLER_1_TEMP_WERT, "\"°C\"");

    float STAT_WP_PT_FUEHLER_2_DRUCK_WERT = (RXBUF_UINT(10)/10.0f);
        // Heat pump: pressure from pressure / temperature sensor 2 / Wärmepumpe: Druck vom Druck-Temperaturfühler 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "WAERMEPUMPE_SENSOREN", "STAT_WP_PT_FUEHLER_2_DRUCK_WERT", STAT_WP_PT_FUEHLER_2_DRUCK_WERT, "\"bar\"");

    float STAT_WP_PT_FUEHLER_2_TEMP_WERT = (RXBUF_UINT(12)*0.2f-20.0);
        // Heat pump: temperature from pressure temperature sensor 2 / Wärmepumpe: Temperatur vom Druck-Temperaturfühler
        // 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "WAERMEPUMPE_SENSOREN", "STAT_WP_PT_FUEHLER_2_TEMP_WERT", STAT_WP_PT_FUEHLER_2_TEMP_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VORHANDEN_EDH: {                                                // 0xD9AE
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VORHANDEN_EDH", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_EDH = (RXBUF_UCHAR(0));
        // 0x00 = eDH not available 0x01 = eDH available / 0x00 = eDH nicht vorhanden 0x01 = eDH vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VORHANDEN_EDH", "STAT_VORHANDEN_EDH", STAT_VORHANDEN_EDH, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VORHANDEN_WAERMEPUMPE: {                                        // 0xD9AF
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VORHANDEN_WAERMEPUMPE", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_WAERMEPUMPE = (RXBUF_UCHAR(0));
        // 0x00 = heat pump not available 0x01 = heat pump available / 0x00 = Wärmepumpe nicht vorhanden 0x01 =
        // Wärmepumpe vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VORHANDEN_WAERMEPUMPE", "STAT_VORHANDEN_WAERMEPUMPE", STAT_VORHANDEN_WAERMEPUMPE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_VORHANDEN_FSH: {                                                // 0xD9B1
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_VORHANDEN_FSH", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_FSH = (RXBUF_UCHAR(0));
        // 0x00 = front window heating not available 0x01 = front window heating available / 0x00 = Frontscheibenheizung
        // nicht vorhanden 0x01 = Frontscheibenheizung vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "VORHANDEN_FSH", "STAT_VORHANDEN_FSH", STAT_VORHANDEN_FSH, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_SPANNUNG_KLEMME_30_WERT: {                                      // 0xDAD8
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_SPANNUNG_KLEMME_30_WERT", 2);
        break;
    }

    float STAT_SPANNUNG_KLEMME_30_WERT = (RXBUF_SINT(0)/10.0f);
        // Voltage value on the control unit at terminal 30 (accurate to one decimal place) / Spannungswert am
        // Steuergerät an Klemme 30 (auf eine Nachkommastelle genau)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "IHX", "SPANNUNG_KLEMME_30_WERT", "STAT_SPANNUNG_KLEMME_30_WERT", STAT_SPANNUNG_KLEMME_30_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_STATUS_KLEMME_R_EIN: {                                          // 0xDAFD
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_STATUS_KLEMME_R_EIN", 2);
        break;
    }

    short STAT_STATUS_KLEMME_R_EIN = (RXBUF_SINT(0));
        // Status of terminal R in the control unit: 0 = OFF, 1 = ON / Status Klemme R im Steuergerät: 0=AUS, 1=EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "STATUS_KLEMME_R_EIN", "STAT_STATUS_KLEMME_R_EIN", STAT_STATUS_KLEMME_R_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_STATUS_KLEMME_15_EIN: {                                         // 0xDAFE
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_STATUS_KLEMME_15_EIN", 2);
        break;
    }

    short STAT_STATUS_KLEMME_15_EIN = (RXBUF_SINT(0));
        // Status of terminal 15 in the control unit: 0 = OFF; 1 = ON / Status Klemme 15 im Steuergerät: 0=AUS; 1=EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "STATUS_KLEMME_15_EIN", "STAT_STATUS_KLEMME_15_EIN", STAT_STATUS_KLEMME_15_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_STATUS_KLEMME_30B_EIN: {                                        // 0xDB06
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_STATUS_KLEMME_30B_EIN", 2);
        break;
    }

    short STAT_STATUS_KLEMME_30B_EIN = (RXBUF_SINT(0));
        // Status of terminal 30B in the control unit: 0 = OFF; 1 = ON / Status Klemme 30B im Steuergerät: 0=AUS; 1=EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "STATUS_KLEMME_30B_EIN", "STAT_STATUS_KLEMME_30B_EIN", STAT_STATUS_KLEMME_30B_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_STATUS_KLEMME_50_EIN: {                                         // 0xDB10
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_STATUS_KLEMME_50_EIN", 2);
        break;
    }

    short STAT_STATUS_KLEMME_50_EIN = (RXBUF_SINT(0));
        // Status of terminal 50 in the control unit: 0 = OFF; 1 = ON / Status Klemme 50 im Steuergerät: 0=AUS; 1=EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "IHX", "STATUS_KLEMME_50_EIN", "STAT_STATUS_KLEMME_50_EIN", STAT_STATUS_KLEMME_50_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_HV_EDH_STECKVERBINDUNG: {                                       // 0xDFC0
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_HV_EDH_STECKVERBINDUNG", 1);
        break;
    }

    unsigned char STAT_HV_STECKER_EDH = (RXBUF_UCHAR(0));
        // Status high-voltage plug connection: See table TAB_HV_STECKVERBINDUNG / Status Hochvolt-Steckverbindung: Siehe
        // Tabelle TAB_HV_STECKVERBINDUNG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "HV_EDH_STECKVERBINDUNG", "STAT_HV_STECKER_EDH", STAT_HV_STECKER_EDH, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_HV_EKMV_STECKVERBINDUNG: {                                      // 0xDFC1
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_HV_EKMV_STECKVERBINDUNG", 1);
        break;
    }

    unsigned char STAT_HV_STECKER_EKMV = (RXBUF_UCHAR(0));
        // Status high-voltage plug connection: See table TAB_HV_STECKVERBINDUNG / Status Hochvolt-Steckverbindung: Siehe
        // Tabelle TAB_HV_STECKVERBINDUNG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "HV_EKMV_STECKVERBINDUNG", "STAT_HV_STECKER_EKMV", STAT_HV_STECKER_EKMV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_UWB_CPD_DIAGINFO: {                                             // 0x4001
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX_UWB_HKLUSV_DIAGINFO: {                                          // 0x4002
    if (datalen < 10) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX_UWB_HKLUSV_DIAGINFO", 10);
        break;
    }

    unsigned char STAT_AUTOADR = (RXBUF_UCHAR(0));
        // real status auto addressing / real status autoadresierung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_AUTOADR", STAT_AUTOADR, "\"0-n\"");

    unsigned char STAT_AUTOADR_ERROR = (RXBUF_UCHAR(1));
        // Error: 0: no error 1: by preparing the network for autoaddressing 2: by resetting the network after an
        // autoaddressing 3: by setting the actuators in service mode 4: by setting the actuators in normal mode 5: by
        // addressing & programming the actuators. 6: unknown error occurred. / Error: 0:  no error  1:  by preparing the
        // network for autoaddressing  2: by resetting the network after an autoaddressing  3: by setting the actuators
        // in service mode  4: by setting the actuators in normal mode  5:  by addressing & programming the actuators. 
        // 6:  unknow error occured.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_AUTOADR_ERROR", STAT_AUTOADR_ERROR, "\"0-n\"");

    unsigned char STAT_AUTOADR_MOTOR_0_1_2_3 = (RXBUF_UCHAR(2));
        // Lin Motorr: Motor 0 to Motor 3. (11111111 11111111) / Lin Motorenr: Motor 0 to Motor 3. (11111111 11111111)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_AUTOADR_MOTOR_0_1_2_3", STAT_AUTOADR_MOTOR_0_1_2_3, "\"0-n\"");

    unsigned char STAT_AUTOADR_MOTOR_4_5_6_7 = (RXBUF_UCHAR(3));
        // Lin motor no .: Motor 4 to Motor 7. (01111111 11111111) / Lin Motorenr: Motor 4 to Motor 7. (01111111
        // 11111111)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_AUTOADR_MOTOR_4_5_6_7", STAT_AUTOADR_MOTOR_4_5_6_7, "\"0-n\"");

    unsigned char STAT_AUTOADR_MOTOR_8_9_10_11 = (RXBUF_UCHAR(4));
        // Lin Motorenr: Motor 8 to Motor 11. (01111111 11111111) / Lin Motorenr: Motor 8 to Motor 11. (01111111
        // 11111111)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_AUTOADR_MOTOR_8_9_10_11", STAT_AUTOADR_MOTOR_8_9_10_11, "\"0-n\"");

    unsigned char STAT_AUTOADR_MOTOR_12_13_14 = (RXBUF_UCHAR(5));
        // Lin Motorenr: Motor 8 to Motor 11. (01111111 11111111) / Lin Motorenr: Motor 8 to Motor 11. (01111111
        // 11111111)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_AUTOADR_MOTOR_12_13_14", STAT_AUTOADR_MOTOR_12_13_14, "\"0-n\"");

    unsigned char STAT_PROGRAMM_MOTOR_0_1_2_3 = (RXBUF_UCHAR(6));
        // Programming status: 1: programmed 0: not programmed Motor 15 to Motor 1. (01111111 11111111) / Programming
        // status: 1: programmed 0: not programmed  Motor 15 to Motor 1. (01111111 11111111)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_PROGRAMM_MOTOR_0_1_2_3", STAT_PROGRAMM_MOTOR_0_1_2_3, "\"0-n\"");

    unsigned char STAT_PROGRAMM_MOTOR_4_5_6_7 = (RXBUF_UCHAR(7));
        // Programming status: 1: programmed 0: not programmed Motor 15 to Motor 1. (01111111 11111111) / Programming
        // status: 1: programmed 0: not programmed  Motor 15 to Motor 1. (01111111 11111111)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_PROGRAMM_MOTOR_4_5_6_7", STAT_PROGRAMM_MOTOR_4_5_6_7, "\"0-n\"");

    unsigned char STAT_PROGRAMM_MOTOR_8_9_10_11 = (RXBUF_UCHAR(8));
        // Programming status: 1: programmed 0: not programmed Motor 15 to Motor 1. (01111111 11111111) / Programming
        // status: 1: programmed 0: not programmed  Motor 15 to Motor 1. (01111111 11111111)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_PROGRAMM_MOTOR_8_9_10_11", STAT_PROGRAMM_MOTOR_8_9_10_11, "\"0-n\"");

    unsigned char STAT_PROGRAMM_MOTOR_12_13_14 = (RXBUF_UCHAR(9));
        // Programming status: 1: programmed 0: not programmed Motor 15 to Motor 1. (01111111 11111111) / Programming
        // status: 1: programmed 0: not programmed  Motor 15 to Motor 1. (01111111 11111111)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "UWB_HKLUSV_DIAGINFO", "STAT_PROGRAMM_MOTOR_12_13_14", STAT_PROGRAMM_MOTOR_12_13_14, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX__ADC_EINGAENGE_WERT: {                                          // 0x4010
    if (datalen < 22) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX__ADC_EINGAENGE_WERT", 22);
        break;
    }

    unsigned short STAT_ADC_VERDAMPFER = (RXBUF_UINT(0));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_VERDAMPFER", STAT_ADC_VERDAMPFER, "\"0-n\"");

    unsigned short STAT_ADC_ZWEITE_VERDAMPFER = (RXBUF_UINT(2));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_ZWEITE_VERDAMPFER", STAT_ADC_ZWEITE_VERDAMPFER, "\"0-n\"");

    unsigned short STAT_ADC_BELUEFTUNG_LINKS = (RXBUF_UINT(4));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_BELUEFTUNG_LINKS", STAT_ADC_BELUEFTUNG_LINKS, "\"0-n\"");

    unsigned short STAT_ADC_BELEUFTUNG_RECHTS = (RXBUF_UINT(6));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_BELEUFTUNG_RECHTS", STAT_ADC_BELEUFTUNG_RECHTS, "\"0-n\"");

    unsigned short STAT_ADC_FUSSRAUM_LINKS = (RXBUF_UINT(8));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_FUSSRAUM_LINKS", STAT_ADC_FUSSRAUM_LINKS, "\"0-n\"");

    unsigned short STAT_ADC_FUSSRAUM_RECHTS = (RXBUF_UINT(10));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_FUSSRAUM_RECHTS", STAT_ADC_FUSSRAUM_RECHTS, "\"0-n\"");

    unsigned short STAT_ADC_SCHICHTUNG_POTI = (RXBUF_UINT(12));
        // Temperature sensor / Temperaturfühler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_SCHICHTUNG_POTI", STAT_ADC_SCHICHTUNG_POTI, "\"0-n\"");

    unsigned short STAT_ADC_KLEMME_30 = (RXBUF_UINT(14));
        // Voltage value on the control unit at terminal 30 / Spannungswert am Steuergerät an Klemme 30
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_KLEMME_30", STAT_ADC_KLEMME_30, "\"0-n\"");

    unsigned short STAT_EXT_SUPPLY_DIAG = (RXBUF_UINT(16));
        // Current value diagnosis / Stromswert  diagnose
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_EXT_SUPPLY_DIAG", STAT_EXT_SUPPLY_DIAG, "\"0-n\"");

    unsigned short STAT_ADC_LIN_DIAG_SPANNUNG = (RXBUF_UINT(18));
        // Voltage value diagnosis / Spannungswert  diagnose
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_LIN_DIAG_SPANNUNG", STAT_ADC_LIN_DIAG_SPANNUNG, "\"0-n\"");

    unsigned short STAT_ADC_LIN_DIAG_STROM = (RXBUF_UINT(20));
        // Current value diagnosis / Stromswert  diagnose
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "IHX", "_ADC_EINGAENGE_WERT", "STAT_ADC_LIN_DIAG_STROM", STAT_ADC_LIN_DIAG_STROM, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX__STAT_STANDHEIZUNG_WERT: {                                      // 0x4011
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX__STAT_STANDHEIZUNG_WERT", 1);
        break;
    }

    unsigned char STAT_STANDHEIZUNG_WERT = (RXBUF_UCHAR(0));
        // Return the value of the parking heater ECU input: WAKESH / Return the value of the parking-heater ECU input: 
        // WAKESH
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "_STAT_STANDHEIZUNG_WERT", "STAT_STANDHEIZUNG_WERT", STAT_STANDHEIZUNG_WERT, "\"HEX\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX__STANDHEIZUNG_AUSGANG: {                                        // 0x4012
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX__STANDHEIZUNG_AUSGANG", 3);
        break;
    }

    unsigned char STAT_STADHEIZING_AUSGANG = (RXBUF_UCHAR(0));
        // STADHEIZING_EXIT / STADHEIZING_AUSGANG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "_STANDHEIZUNG_AUSGANG", "STAT_STADHEIZING_AUSGANG", STAT_STADHEIZING_AUSGANG, "\"0-n\"");

    unsigned char STAT_AC_LIN_SPANNUNG_CMD_AUSGANG = (RXBUF_UCHAR(1));
        // AC_LIN_SPANNUNG_CMD_AUSGANG / AC_LIN_SPANNUNG_CMD_AUSGANG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "_STANDHEIZUNG_AUSGANG", "STAT_AC_LIN_SPANNUNG_CMD_AUSGANG", STAT_AC_LIN_SPANNUNG_CMD_AUSGANG, "\"0-n\"");

    unsigned char STAT_AC_LIN_SPANNUNG_DEN_AUSGANG = (RXBUF_UCHAR(2));
        // AC_LIN_SPANNUNG_DEN_AUSGANG / AC_LIN_SPANNUNG_DEN_AUSGANG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "_STANDHEIZUNG_AUSGANG", "STAT_AC_LIN_SPANNUNG_DEN_AUSGANG", STAT_AC_LIN_SPANNUNG_DEN_AUSGANG, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_IHX__VALEO_LESEN_SPEICHER: {                                        // 0x4020
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_IHX__VALEO_LESEN_SPEICHER", 1);
        break;
    }

    unsigned char STAT_SPEICHER_BLOCK = (RXBUF_UCHAR(0));
        // MEMORY BLOCK / SPEICHER BLOCK
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "IHX", "_VALEO_LESEN_SPEICHER", "STAT_SPEICHER_BLOCK", STAT_SPEICHER_BLOCK, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }
