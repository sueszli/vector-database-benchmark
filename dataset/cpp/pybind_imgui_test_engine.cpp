// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2023 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>

#include "imgui.h"
#include "imgui_internal.h"
#include "imgui_docking_internal_types.h"
#include "imgui_test_engine/imgui_te_context.h"
#include "imgui_test_engine/imgui_te_engine.h"
#include "imgui_test_engine/imgui_te_ui.h"
#include "imgui_test_engine/imgui_te_internal.h"
#include "imgui_test_engine/imgui_te_perftool.h"


namespace py = pybind11;



// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_imgui_test_engine(py::module& m)
{
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:imgui_te_engine.h>    ////////////////////
    py::enum_<ImGuiTestActiveFunc>(m, "TestActiveFunc", py::arithmetic(), "Stored in ImGuiTestContext: where we are currently running GuiFunc or TestFunc")
        .value("none", ImGuiTestActiveFunc_None, "")
        .value("gui_func", ImGuiTestActiveFunc_GuiFunc, "")
        .value("test_func", ImGuiTestActiveFunc_TestFunc, "");


    py::enum_<ImGuiTestRunSpeed>(m, "TestRunSpeed", py::arithmetic(), "")
        .value("fast", ImGuiTestRunSpeed_Fast, "Run tests as fast as possible (teleport mouse, skip delays, etc.)")
        .value("normal", ImGuiTestRunSpeed_Normal, "Run tests at human watchable speed (for debugging)")
        .value("cinematic", ImGuiTestRunSpeed_Cinematic, "Run tests with pauses between actions (for e.g. tutorials)")
        .value("count", ImGuiTestRunSpeed_COUNT, "");


    py::enum_<ImGuiTestVerboseLevel>(m, "TestVerboseLevel", py::arithmetic(), "")
        .value("silent", ImGuiTestVerboseLevel_Silent, "-v0")
        .value("error", ImGuiTestVerboseLevel_Error, "-v1")
        .value("warning", ImGuiTestVerboseLevel_Warning, "-v2")
        .value("info", ImGuiTestVerboseLevel_Info, "-v3")
        .value("debug", ImGuiTestVerboseLevel_Debug, "-v4")
        .value("trace", ImGuiTestVerboseLevel_Trace, "")
        .value("count", ImGuiTestVerboseLevel_COUNT, "");


    py::enum_<ImGuiTestStatus>(m, "TestStatus", py::arithmetic(), "Test status (stored in ImGuiTest)")
        .value("unknown", ImGuiTestStatus_Unknown, "")
        .value("success", ImGuiTestStatus_Success, "")
        .value("queued", ImGuiTestStatus_Queued, "")
        .value("running", ImGuiTestStatus_Running, "")
        .value("error", ImGuiTestStatus_Error, "")
        .value("suspended", ImGuiTestStatus_Suspended, "");


    py::enum_<ImGuiTestGroup>(m, "TestGroup", py::arithmetic(), "Test group: this is mostly used to categorize tests in our testing UI. (Stored in ImGuiTest)")
        .value("unknown", ImGuiTestGroup_Unknown, "")
        .value("tests", ImGuiTestGroup_Tests, "")
        .value("perfs", ImGuiTestGroup_Perfs, "")
        .value("count", ImGuiTestGroup_COUNT, "");


    py::enum_<ImGuiTestFlags_>(m, "TestFlags_", py::arithmetic(), "Flags (stored in ImGuiTest)")
        .value("none", ImGuiTestFlags_None, "")
        .value("no_gui_warm_up", ImGuiTestFlags_NoGuiWarmUp, "Disable running the GUI func for 2 frames before starting test code. For tests which absolutely need to start before GuiFunc.")
        .value("no_auto_finish", ImGuiTestFlags_NoAutoFinish, "By default, tests with no TestFunc (only a GuiFunc) will end after warmup. Setting this require test to call ctx->Finish().")
        .value("no_recovery_warnings", ImGuiTestFlags_NoRecoveryWarnings, "Disable state recovery warnings (missing End/Pop calls etc.) for tests which may rely on those.");


    py::enum_<ImGuiTestCheckFlags_>(m, "TestCheckFlags_", py::arithmetic(), "Flags for IM_CHECK* macros.")
        .value("none", ImGuiTestCheckFlags_None, "")
        .value("silent_success", ImGuiTestCheckFlags_SilentSuccess, "");


    py::enum_<ImGuiTestLogFlags_>(m, "TestLogFlags_", py::arithmetic(), "Flags for ImGuiTestContext::Log* functions.")
        .value("none", ImGuiTestLogFlags_None, "")
        .value("no_header", ImGuiTestLogFlags_NoHeader, "Do not display frame count and depth padding");


    py::enum_<ImGuiTestRunFlags_>(m, "TestRunFlags_", py::arithmetic(), "")
        .value("none", ImGuiTestRunFlags_None, "")
        .value("gui_func_disable", ImGuiTestRunFlags_GuiFuncDisable, "Used internally to temporarily disable the GUI func (at the end of a test, etc)")
        .value("gui_func_only", ImGuiTestRunFlags_GuiFuncOnly, "Set when user selects \"Run GUI func\"")
        .value("no_success_msg", ImGuiTestRunFlags_NoSuccessMsg, "")
        .value("no_stop_on_error", ImGuiTestRunFlags_NoStopOnError, "")
        .value("no_break_on_error", ImGuiTestRunFlags_NoBreakOnError, "")
        .value("enable_raw_inputs", ImGuiTestRunFlags_EnableRawInputs, "Disable input submission to let test submission raw input event (in order to test e.g. IO queue)")
        .value("manual_run", ImGuiTestRunFlags_ManualRun, "")
        .value("command_line", ImGuiTestRunFlags_CommandLine, "");


    m.def("hook_item_add",
        ImGuiTestEngineHook_ItemAdd,
        py::arg("ui_ctx"), py::arg("id_"), py::arg("bb"), py::arg("item_data"),
        " Hooks for core imgui/ library (generally called via macros)\n(private API)");

    m.def("hook_log",
        [](ImGuiContext * ui_ctx, const char * fmt)
        {
            auto ImGuiTestEngineHook_Log_adapt_variadic_format = [](ImGuiContext * ui_ctx, const char * fmt)
            {
                ImGuiTestEngineHook_Log(ui_ctx, "%s", fmt);
            };

            ImGuiTestEngineHook_Log_adapt_variadic_format(ui_ctx, fmt);
        },
        py::arg("ui_ctx"), py::arg("fmt"),
        "(private API)");

    m.def("find_item_debug_label",
        ImGuiTestEngine_FindItemDebugLabel,
        py::arg("ui_ctx"), py::arg("id_"),
        "(private API)",
        pybind11::return_value_policy::reference);

    m.def("check",
        ImGuiTestEngine_Check, py::arg("file"), py::arg("func"), py::arg("line"), py::arg("flags"), py::arg("result"), py::arg("expr"));

    m.def("check_str_op",
        [](const char * file, const char * func, int line, ImGuiTestCheckFlags flags, const char * op, const char * lhs_var, const char * lhs_value, const char * rhs_var, const char * rhs_value, bool out_result) -> std::tuple<bool, bool>
        {
            auto ImGuiTestEngine_CheckStrOp_adapt_modifiable_immutable_to_return = [](const char * file, const char * func, int line, ImGuiTestCheckFlags flags, const char * op, const char * lhs_var, const char * lhs_value, const char * rhs_var, const char * rhs_value, bool out_result) -> std::tuple<bool, bool>
            {
                bool * out_result_adapt_modifiable = & out_result;

                bool r = ImGuiTestEngine_CheckStrOp(file, func, line, flags, op, lhs_var, lhs_value, rhs_var, rhs_value, out_result_adapt_modifiable);
                return std::make_tuple(r, out_result);
            };

            return ImGuiTestEngine_CheckStrOp_adapt_modifiable_immutable_to_return(file, func, line, flags, op, lhs_var, lhs_value, rhs_var, rhs_value, out_result);
        },     py::arg("file"), py::arg("func"), py::arg("line"), py::arg("flags"), py::arg("op"), py::arg("lhs_var"), py::arg("lhs_value"), py::arg("rhs_var"), py::arg("rhs_value"), py::arg("out_result"));

    m.def("error",
        [](const char * file, const char * func, int line, ImGuiTestCheckFlags flags, const char * fmt) -> bool
        {
            auto ImGuiTestEngine_Error_adapt_variadic_format = [](const char * file, const char * func, int line, ImGuiTestCheckFlags flags, const char * fmt) -> bool
            {
                auto lambda_result = ImGuiTestEngine_Error(file, func, line, flags, "%s", fmt);
                return lambda_result;
            };

            return ImGuiTestEngine_Error_adapt_variadic_format(file, func, line, flags, fmt);
        },     py::arg("file"), py::arg("func"), py::arg("line"), py::arg("flags"), py::arg("fmt"));

    m.def("assert_log",
        ImGuiTestEngine_AssertLog, py::arg("expr"), py::arg("file"), py::arg("function"), py::arg("line"));

    m.def("create_context",
        ImGuiTestEngine_CreateContext,
        "Create test engine",
        pybind11::return_value_policy::reference);

    m.def("destroy_context",
        ImGuiTestEngine_DestroyContext,
        py::arg("engine"),
        "Destroy test engine. Call after ImGui::DestroyContext() so test engine specific ini data gets saved.");

    m.def("start",
        ImGuiTestEngine_Start,
        py::arg("engine"), py::arg("ui_ctx"),
        "Bind to a dear imgui context. Start coroutine.");

    m.def("stop",
        ImGuiTestEngine_Stop,
        py::arg("engine"),
        "Stop coroutine and export if any. (Unbind will lazily happen on context shutdown)");

    m.def("post_swap",
        ImGuiTestEngine_PostSwap,
        py::arg("engine"),
        "Call every frame after framebuffer swap, will process screen capture and call test_io.ScreenCaptureFunc()");

    m.def("get_io",
        ImGuiTestEngine_GetIO,
        py::arg("engine"),
        pybind11::return_value_policy::reference);

    m.def("register_test",
        ImGuiTestEngine_RegisterTest,
        py::arg("engine"), py::arg("category"), py::arg("name"), py::arg("src_file") = py::none(), py::arg("src_line") = 0,
        "Prefer calling IM_REGISTER_TEST()",
        pybind11::return_value_policy::reference);

    m.def("queue_test",
        ImGuiTestEngine_QueueTest, py::arg("engine"), py::arg("test"), py::arg("run_flags") = 0);

    m.def("queue_tests",
        ImGuiTestEngine_QueueTests, py::arg("engine"), py::arg("group"), py::arg("filter") = py::none(), py::arg("run_flags") = 0);

    m.def("try_abort_engine",
        ImGuiTestEngine_TryAbortEngine, py::arg("engine"));

    m.def("abort_current_test",
        ImGuiTestEngine_AbortCurrentTest, py::arg("engine"));

    m.def("is_test_queue_empty",
        ImGuiTestEngine_IsTestQueueEmpty, py::arg("engine"));

    m.def("is_using_simulated_inputs",
        ImGuiTestEngine_IsUsingSimulatedInputs, py::arg("engine"));

    m.def("get_result",
        [](ImGuiTestEngine * engine, int count_tested, int success_count) -> std::tuple<int, int>
        {
            auto ImGuiTestEngine_GetResult_adapt_modifiable_immutable_to_return = [](ImGuiTestEngine * engine, int count_tested, int success_count) -> std::tuple<int, int>
            {
                int & count_tested_adapt_modifiable = count_tested;
                int & success_count_adapt_modifiable = success_count;

                ImGuiTestEngine_GetResult(engine, count_tested_adapt_modifiable, success_count_adapt_modifiable);
                return std::make_tuple(count_tested, success_count);
            };

            return ImGuiTestEngine_GetResult_adapt_modifiable_immutable_to_return(engine, count_tested, success_count);
        },     py::arg("engine"), py::arg("count_tested"), py::arg("success_count"));

    m.def("install_default_crash_handler",
        ImGuiTestEngine_InstallDefaultCrashHandler, "Install default crash handler (if you don't have one)");

    m.def("crash_handler",
        ImGuiTestEngine_CrashHandler, "Default crash handler, should be called from a custom crash handler if such exists");


    auto pyClassImGuiTestEngineIO =
        py::class_<ImGuiTestEngineIO>
            (m, "TestEngineIO", "")
        .def(py::init<>([](
        bool ConfigSavedSettings = true, ImGuiTestRunSpeed ConfigRunSpeed = ImGuiTestRunSpeed_Fast, bool ConfigStopOnError = false, bool ConfigBreakOnError = false, bool ConfigKeepGuiFunc = false, ImGuiTestVerboseLevel ConfigVerboseLevel = ImGuiTestVerboseLevel_Warning, ImGuiTestVerboseLevel ConfigVerboseLevelOnError = ImGuiTestVerboseLevel_Info, bool ConfigLogToTTY = false, bool ConfigLogToDebugger = false, bool ConfigRestoreFocusAfterTests = true, bool ConfigCaptureEnabled = true, bool ConfigCaptureOnError = false, bool ConfigNoThrottle = false, bool ConfigMouseDrawCursor = true, float ConfigFixedDeltaTime = 0.0f, int PerfStressAmount = 1, float MouseSpeed = 600.0f, float MouseWobble = 0.25f, float ScrollSpeed = 1400.0f, float TypingSpeed = 20.0f, float ActionDelayShort = 0.15f, float ActionDelayStandard = 0.40f, float ConfigWatchdogWarning = 30.0f, float ConfigWatchdogKillTest = 60.0f, float ConfigWatchdogKillApp = FLT_MAX, bool CheckDrawDataIntegrity = false, bool IsRunningTests = false, bool IsRequestingMaxAppSpeed = false, bool IsCapturing = false)
        {
            auto r = std::make_unique<ImGuiTestEngineIO>();
            r->ConfigSavedSettings = ConfigSavedSettings;
            r->ConfigRunSpeed = ConfigRunSpeed;
            r->ConfigStopOnError = ConfigStopOnError;
            r->ConfigBreakOnError = ConfigBreakOnError;
            r->ConfigKeepGuiFunc = ConfigKeepGuiFunc;
            r->ConfigVerboseLevel = ConfigVerboseLevel;
            r->ConfigVerboseLevelOnError = ConfigVerboseLevelOnError;
            r->ConfigLogToTTY = ConfigLogToTTY;
            r->ConfigLogToDebugger = ConfigLogToDebugger;
            r->ConfigRestoreFocusAfterTests = ConfigRestoreFocusAfterTests;
            r->ConfigCaptureEnabled = ConfigCaptureEnabled;
            r->ConfigCaptureOnError = ConfigCaptureOnError;
            r->ConfigNoThrottle = ConfigNoThrottle;
            r->ConfigMouseDrawCursor = ConfigMouseDrawCursor;
            r->ConfigFixedDeltaTime = ConfigFixedDeltaTime;
            r->PerfStressAmount = PerfStressAmount;
            r->MouseSpeed = MouseSpeed;
            r->MouseWobble = MouseWobble;
            r->ScrollSpeed = ScrollSpeed;
            r->TypingSpeed = TypingSpeed;
            r->ActionDelayShort = ActionDelayShort;
            r->ActionDelayStandard = ActionDelayStandard;
            r->ConfigWatchdogWarning = ConfigWatchdogWarning;
            r->ConfigWatchdogKillTest = ConfigWatchdogKillTest;
            r->ConfigWatchdogKillApp = ConfigWatchdogKillApp;
            r->CheckDrawDataIntegrity = CheckDrawDataIntegrity;
            r->IsRunningTests = IsRunningTests;
            r->IsRequestingMaxAppSpeed = IsRequestingMaxAppSpeed;
            r->IsCapturing = IsCapturing;
            return r;
        })
        , py::arg("config_saved_settings") = true, py::arg("config_run_speed") = ImGuiTestRunSpeed_Fast, py::arg("config_stop_on_error") = false, py::arg("config_break_on_error") = false, py::arg("config_keep_gui_func") = false, py::arg("config_verbose_level") = ImGuiTestVerboseLevel_Warning, py::arg("config_verbose_level_on_error") = ImGuiTestVerboseLevel_Info, py::arg("config_log_to_tty") = false, py::arg("config_log_to_debugger") = false, py::arg("config_restore_focus_after_tests") = true, py::arg("config_capture_enabled") = true, py::arg("config_capture_on_error") = false, py::arg("config_no_throttle") = false, py::arg("config_mouse_draw_cursor") = true, py::arg("config_fixed_delta_time") = 0.0f, py::arg("perf_stress_amount") = 1, py::arg("mouse_speed") = 600.0f, py::arg("mouse_wobble") = 0.25f, py::arg("scroll_speed") = 1400.0f, py::arg("typing_speed") = 20.0f, py::arg("action_delay_short") = 0.15f, py::arg("action_delay_standard") = 0.40f, py::arg("config_watchdog_warning") = 30.0f, py::arg("config_watchdog_kill_test") = 60.0f, py::arg("config_watchdog_kill_app") = FLT_MAX, py::arg("check_draw_data_integrity") = false, py::arg("is_running_tests") = false, py::arg("is_requesting_max_app_speed") = false, py::arg("is_capturing") = false
        )
        .def_readwrite("src_file_open_user_data", &ImGuiTestEngineIO::SrcFileOpenUserData, "(Optional) User data for SrcFileOpenFunc")
        .def_readwrite("screen_capture_user_data", &ImGuiTestEngineIO::ScreenCaptureUserData, "(Optional) User data for ScreenCaptureFunc")
        .def_readwrite("config_saved_settings", &ImGuiTestEngineIO::ConfigSavedSettings, "Load/Save settings in main context .ini file.")
        .def_readwrite("config_run_speed", &ImGuiTestEngineIO::ConfigRunSpeed, "Run tests in fast/normal/cinematic mode")
        .def_readwrite("config_stop_on_error", &ImGuiTestEngineIO::ConfigStopOnError, "Stop queued tests on test error")
        .def_readwrite("config_break_on_error", &ImGuiTestEngineIO::ConfigBreakOnError, "Break debugger on test error by calling IM_DEBUG_BREAK()")
        .def_readwrite("config_keep_gui_func", &ImGuiTestEngineIO::ConfigKeepGuiFunc, "Keep test GUI running at the end of the test")
        .def_readwrite("config_verbose_level", &ImGuiTestEngineIO::ConfigVerboseLevel, "")
        .def_readwrite("config_verbose_level_on_error", &ImGuiTestEngineIO::ConfigVerboseLevelOnError, "")
        .def_readwrite("config_log_to_tty", &ImGuiTestEngineIO::ConfigLogToTTY, "")
        .def_readwrite("config_log_to_debugger", &ImGuiTestEngineIO::ConfigLogToDebugger, "")
        .def_readwrite("config_restore_focus_after_tests", &ImGuiTestEngineIO::ConfigRestoreFocusAfterTests, "Restore focus back after running tests")
        .def_readwrite("config_capture_enabled", &ImGuiTestEngineIO::ConfigCaptureEnabled, "Master enable flags for capturing and saving captures. Disable to avoid e.g. lengthy saving of large PNG files.")
        .def_readwrite("config_capture_on_error", &ImGuiTestEngineIO::ConfigCaptureOnError, "")
        .def_readwrite("config_no_throttle", &ImGuiTestEngineIO::ConfigNoThrottle, "Disable vsync for performance measurement or fast test running")
        .def_readwrite("config_mouse_draw_cursor", &ImGuiTestEngineIO::ConfigMouseDrawCursor, "Enable drawing of Dear ImGui software mouse cursor when running tests")
        .def_readwrite("config_fixed_delta_time", &ImGuiTestEngineIO::ConfigFixedDeltaTime, "Use fixed delta time instead of calculating it from wall clock")
        .def_readwrite("perf_stress_amount", &ImGuiTestEngineIO::PerfStressAmount, "Integer to scale the amount of items submitted in test")
        .def_readwrite("mouse_speed", &ImGuiTestEngineIO::MouseSpeed, "Mouse speed (pixel/second) when not running in fast mode")
        .def_readwrite("mouse_wobble", &ImGuiTestEngineIO::MouseWobble, "(0.0..1.0) How much wobble to apply to the mouse (pixels per pixel of move distance) when not running in fast mode")
        .def_readwrite("scroll_speed", &ImGuiTestEngineIO::ScrollSpeed, "Scroll speed (pixel/second) when not running in fast mode")
        .def_readwrite("typing_speed", &ImGuiTestEngineIO::TypingSpeed, "Char input speed (characters/second) when not running in fast mode")
        .def_readwrite("action_delay_short", &ImGuiTestEngineIO::ActionDelayShort, "Time between short actions")
        .def_readwrite("action_delay_standard", &ImGuiTestEngineIO::ActionDelayStandard, "Time between most actions")
        .def_readwrite("config_watchdog_warning", &ImGuiTestEngineIO::ConfigWatchdogWarning, "Warn when a test exceed this time (in second)")
        .def_readwrite("config_watchdog_kill_test", &ImGuiTestEngineIO::ConfigWatchdogKillTest, "Attempt to stop running a test when exceeding this time (in second)")
        .def_readwrite("config_watchdog_kill_app", &ImGuiTestEngineIO::ConfigWatchdogKillApp, "Stop application when exceeding this time (in second)")
        .def_readonly("export_results_filename", &ImGuiTestEngineIO::ExportResultsFilename, "")
        .def_readwrite("check_draw_data_integrity", &ImGuiTestEngineIO::CheckDrawDataIntegrity, "Check ImDrawData integrity (buffer count, etc.). Currently cheap but may become a slow operation.")
        .def_readwrite("is_running_tests", &ImGuiTestEngineIO::IsRunningTests, "")
        .def_readwrite("is_requesting_max_app_speed", &ImGuiTestEngineIO::IsRequestingMaxAppSpeed, "When running in fast mode: request app to skip vsync or even skip rendering if it wants")
        .def_readwrite("is_capturing", &ImGuiTestEngineIO::IsCapturing, "Capture is in progress")
        ;


    auto pyClassImGuiTestItemInfo =
        py::class_<ImGuiTestItemInfo>
            (m, "TestItemInfo", "Information about a given item or window, result of an ItemInfo() or WindowInfo() query")
        .def_readwrite("timestamp_main", &ImGuiTestItemInfo::TimestampMain, "Timestamp of main result (all fields)")
        .def_readwrite("timestamp_status", &ImGuiTestItemInfo::TimestampStatus, "Timestamp of StatusFlags")
        .def_readwrite("id_", &ImGuiTestItemInfo::ID, "Item ID")
        .def_readwrite("parent_id", &ImGuiTestItemInfo::ParentID, "Item Parent ID (value at top of the ID stack)")
        .def_readwrite("window", &ImGuiTestItemInfo::Window, "Item Window")
        .def_readwrite("rect_full", &ImGuiTestItemInfo::RectFull, "Item Rectangle")
        .def_readwrite("rect_clipped", &ImGuiTestItemInfo::RectClipped, "Item Rectangle (clipped with window->ClipRect at time of item submission)")
        .def_readwrite("in_flags", &ImGuiTestItemInfo::InFlags, "Item flags")
        .def_readwrite("status_flags", &ImGuiTestItemInfo::StatusFlags, "Item Status flags (fully updated for some items only, compare TimestampStatus to FrameCount)")
        .def(py::init<>())
        .def("is_empty",
            &ImGuiTestItemInfo::IsEmpty, "(private API)")
        ;


    auto pyClassImGuiTestItemList =
        py::class_<ImGuiTestItemList>
            (m, "TestItemList", "Result of an GatherItems() query")
        .def(py::init<>()) // implicit default constructor
        .def("clear",
            &ImGuiTestItemList::Clear, "(private API)")
        .def("reserve",
            &ImGuiTestItemList::Reserve,
            py::arg("capacity"),
            "(private API)")
        .def("get_size",
            &ImGuiTestItemList::GetSize, "(private API)")
        .def("get_by_index",
            &ImGuiTestItemList::GetByIndex,
            py::arg("n"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_by_id",
            &ImGuiTestItemList::GetByID,
            py::arg("id_"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("size",
            &ImGuiTestItemList::size, "(private API)")
        .def("begin",
            &ImGuiTestItemList::begin,
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("end",
            &ImGuiTestItemList::end,
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("__getitem__",
            &ImGuiTestItemList::operator[],
            py::arg("n"),
            "(private API)",
            pybind11::return_value_policy::reference)
        ;


    auto pyClassImGuiTestLogLineInfo =
        py::class_<ImGuiTestLogLineInfo>
            (m, "TestLogLineInfo", "")
        .def(py::init<>([](
        ImGuiTestVerboseLevel Level = ImGuiTestVerboseLevel(), int LineOffset = int())
        {
            auto r = std::make_unique<ImGuiTestLogLineInfo>();
            r->Level = Level;
            r->LineOffset = LineOffset;
            return r;
        })
        , py::arg("level") = ImGuiTestVerboseLevel(), py::arg("line_offset") = int()
        )
        .def_readwrite("level", &ImGuiTestLogLineInfo::Level, "")
        .def_readwrite("line_offset", &ImGuiTestLogLineInfo::LineOffset, "")
        ;


    auto pyClassImGuiTestLog =
        py::class_<ImGuiTestLog>
            (m, "TestLog", "")
        .def_readwrite("buffer", &ImGuiTestLog::Buffer, "")
        .def(py::init<>(),
            "Functions")
        .def("is_empty",
            &ImGuiTestLog::IsEmpty, "(private API)")
        .def("clear",
            &ImGuiTestLog::Clear, "(private API)")
        .def("extract_lines_for_verbose_levels",
            &ImGuiTestLog::ExtractLinesForVerboseLevels,
            py::arg("level_min"), py::arg("level_max"), py::arg("out_buffer"),
            " Extract log contents filtered per log-level.\n Output:\n - If 'buffer != None': all extracted lines are appended to 'buffer'. Use 'buffer->c_str()' on your side to obtain the text.\n - Return value: number of lines extracted (should be equivalent to number of '\n' inside buffer->c_str()).\n - You may call the function with buffer == None to only obtain a count without getting the data.\n Verbose levels are inclusive:\n - To get ONLY Error:                     Use level_min == ImGuiTestVerboseLevel_Error, level_max = ImGuiTestVerboseLevel_Error\n - To get ONLY Error and Warnings:        Use level_min == ImGuiTestVerboseLevel_Error, level_max = ImGuiTestVerboseLevel_Warning\n - To get All Errors, Warnings, Debug...  Use level_min == ImGuiTestVerboseLevel_Error, level_max = ImGuiTestVerboseLevel_Trace\n(private API)")
        .def("update_line_offsets",
            &ImGuiTestLog::UpdateLineOffsets,
            py::arg("engine_io"), py::arg("level"), py::arg("start"),
            " [Internal]\n(private API)")
        ;


    auto pyClassImGuiTest =
        py::class_<ImGuiTest>
            (m, "Test", "Storage for one test")
        .def_readwrite("group", &ImGuiTest::Group, "Coarse groups: 'Tests' or 'Perf'")
        .def_readwrite("source_line", &ImGuiTest::SourceLine, "__LINE__")
        .def_readwrite("source_line_end", &ImGuiTest::SourceLineEnd, "Calculated by ImGuiTestEngine_StartCalcSourceLineEnds()")
        .def_readwrite("arg_variant", &ImGuiTest::ArgVariant, "User parameter. Generally we use it to run variations of a same test by sharing GuiFunc/TestFunc")
        .def_readwrite("flags", &ImGuiTest::Flags, "See ImGuiTestFlags_")
        .def_readwrite("gui_func", &ImGuiTest::GuiFunc, "GUI function (optional if your test are running over an existing GUI application)")
        .def_readwrite("test_func", &ImGuiTest::TestFunc, "Test function")
        .def_readwrite("user_data", &ImGuiTest::UserData, "General purpose user data (if assigning capturing lambdas on GuiFunc/TestFunc you may not need to se this)")
        .def_readwrite("status", &ImGuiTest::Status, "")
        .def_readwrite("test_log", &ImGuiTest::TestLog, "")
        .def_readwrite("start_time", &ImGuiTest::StartTime, "")
        .def_readwrite("end_time", &ImGuiTest::EndTime, "")
        .def_readwrite("gui_func_last_frame", &ImGuiTest::GuiFuncLastFrame, "")
        .def_readwrite("vars_size", &ImGuiTest::VarsSize, "")
        .def_readwrite("vars_post_constructor_user_fn", &ImGuiTest::VarsPostConstructorUserFn, "")
        .def(py::init<>(),
            "Functions")
        ;


    auto pyClassImGuiTestRunTask =
        py::class_<ImGuiTestRunTask>
            (m, "TestRunTask", "Stored in test queue")
        .def(py::init<>([](
        ImGuiTestRunFlags RunFlags = ImGuiTestRunFlags_None)
        {
            auto r = std::make_unique<ImGuiTestRunTask>();
            r->RunFlags = RunFlags;
            return r;
        })
        , py::arg("run_flags") = ImGuiTestRunFlags_None
        )
        .def_readwrite("test", &ImGuiTestRunTask::Test, "")
        .def_readwrite("run_flags", &ImGuiTestRunTask::RunFlags, "")
        ;
    ////////////////////    </generated_from:imgui_te_engine.h>    ////////////////////


    ////////////////////    <generated_from:imgui_te_context.h>    ////////////////////
    auto pyClassImGuiTestRef =
        py::class_<ImGuiTestRef>
            (m, "TestRef", " Weak reference to an Item/Window given an hashed ID _or_ a string path ID.\n This is most often passed as argument to function and generally has a very short lifetime.\n Documentation: https://github.com/ocornut/imgui_test_engine/wiki/Named-References\n (SUGGESTION: add those constructors to \"VA Step Filter\" (Visual Assist) or a .natstepfilter file (Visual Studio) so they are skipped by F11 (StepInto)")
        .def_readwrite("id_", &ImGuiTestRef::ID, "Pre-hashed ID")
        .def(py::init<>())
        .def(py::init<ImGuiID>(),
            py::arg("id_"))
        .def(py::init<const char *>(),
            py::arg("path"))
        .def("is_empty",
            &ImGuiTestRef::IsEmpty, "(private API)")
        ;


    auto pyClassImGuiTestRefDesc =
        py::class_<ImGuiTestRefDesc>
            (m, "TestRefDesc", " Debug helper to output a string showing the Path, ID or Debug Label based on what is available (some items only have ID as we couldn't find/store a Path)\n (The size is arbitrary, this is only used for logging info the user/debugger)")
        .def("c_str",
            &ImGuiTestRefDesc::c_str,
            "(private API)",
            pybind11::return_value_policy::reference)
        .def(py::init<const ImGuiTestRef &, const ImGuiTestItemInfo *>(),
            py::arg("ref"), py::arg("item"))
        ;


    py::enum_<ImGuiTestAction>(m, "TestAction", py::arithmetic(), "Named actions. Generally you will call the named helpers e.g. ItemClick(). This is used by shared/low-level functions such as ItemAction().")
        .value("unknown", ImGuiTestAction_Unknown, "")
        .value("hover", ImGuiTestAction_Hover, "Move mouse")
        .value("click", ImGuiTestAction_Click, "Move mouse and click")
        .value("double_click", ImGuiTestAction_DoubleClick, "Move mouse and double-click")
        .value("check", ImGuiTestAction_Check, "Check item if unchecked (Checkbox, MenuItem or any widget reporting ImGuiItemStatusFlags_Checkable)")
        .value("uncheck", ImGuiTestAction_Uncheck, "Uncheck item if checked")
        .value("open", ImGuiTestAction_Open, "Open item if closed (TreeNode, BeginMenu or any widget reporting ImGuiItemStatusFlags_Openable)")
        .value("close", ImGuiTestAction_Close, "Close item if opened")
        .value("input", ImGuiTestAction_Input, "Start text inputing into a field (e.g. CTRL+Click on Drags/Slider, click on InputText etc.)")
        .value("nav_activate", ImGuiTestAction_NavActivate, "Activate item with navigation")
        .value("count", ImGuiTestAction_COUNT, "");


    py::enum_<ImGuiTestOpFlags_>(m, "TestOpFlags_", py::arithmetic(), "Generic flags for many ImGuiTestContext functions")
        .value("none", ImGuiTestOpFlags_None, "")
        .value("no_check_hovered_id", ImGuiTestOpFlags_NoCheckHoveredId, "Don't check for HoveredId after aiming for a widget. A few situations may want this: while e.g. dragging or another items prevents hovering, or for items that don't use ItemHoverable()")
        .value("no_error", ImGuiTestOpFlags_NoError, "Don't abort/error e.g. if the item cannot be found or the operation doesn't succeed.")
        .value("no_focus_window", ImGuiTestOpFlags_NoFocusWindow, "Don't focus window when aiming at an item")
        .value("no_auto_uncollapse", ImGuiTestOpFlags_NoAutoUncollapse, "Disable automatically uncollapsing windows (useful when specifically testing Collapsing behaviors)")
        .value("no_auto_open_full_path", ImGuiTestOpFlags_NoAutoOpenFullPath, "Disable automatically opening intermediaries (e.g. ItemClick(\"Hello/OK\") will automatically first open \"Hello\" if \"OK\" isn't found. Only works if ref is a string path.")
        .value("is_second_attempt", ImGuiTestOpFlags_IsSecondAttempt, "Used by recursing functions to indicate a second attempt")
        .value("move_to_edge_l", ImGuiTestOpFlags_MoveToEdgeL, "Simple Dumb aiming helpers to test widget that care about clicking position. May need to replace will better functionalities.")
        .value("move_to_edge_r", ImGuiTestOpFlags_MoveToEdgeR, "")
        .value("move_to_edge_u", ImGuiTestOpFlags_MoveToEdgeU, "")
        .value("move_to_edge_d", ImGuiTestOpFlags_MoveToEdgeD, "");


    auto pyClassImGuiTestActionFilter =
        py::class_<ImGuiTestActionFilter>
            (m, "TestActionFilter", "Advanced filtering for ItemActionAll()")
        .def_readwrite("max_depth", &ImGuiTestActionFilter::MaxDepth, "")
        .def_readwrite("max_passes", &ImGuiTestActionFilter::MaxPasses, "")
        .def_readonly("max_item_count_per_depth", &ImGuiTestActionFilter::MaxItemCountPerDepth, "")
        .def_readwrite("require_all_status_flags", &ImGuiTestActionFilter::RequireAllStatusFlags, "")
        .def_readwrite("require_any_status_flags", &ImGuiTestActionFilter::RequireAnyStatusFlags, "")
        .def(py::init<>())
        ;


    auto pyClassImGuiTestGenericItemStatus =
        py::class_<ImGuiTestGenericItemStatus>
            (m, "TestGenericItemStatus", " Helper struct to store various query-able state of an item.\n This facilitate interactions between GuiFunc and TestFunc, since those state are frequently used.")
        .def_readwrite("ret_value", &ImGuiTestGenericItemStatus::RetValue, "return value")
        .def_readwrite("hovered", &ImGuiTestGenericItemStatus::Hovered, "result of IsItemHovered()")
        .def_readwrite("active", &ImGuiTestGenericItemStatus::Active, "result of IsItemActive()")
        .def_readwrite("focused", &ImGuiTestGenericItemStatus::Focused, "result of IsItemFocused()")
        .def_readwrite("clicked", &ImGuiTestGenericItemStatus::Clicked, "result of IsItemClicked()")
        .def_readwrite("visible", &ImGuiTestGenericItemStatus::Visible, "result of IsItemVisible()")
        .def_readwrite("edited", &ImGuiTestGenericItemStatus::Edited, "result of IsItemEdited()")
        .def_readwrite("activated", &ImGuiTestGenericItemStatus::Activated, "result of IsItemActivated()")
        .def_readwrite("deactivated", &ImGuiTestGenericItemStatus::Deactivated, "result of IsItemDeactivated()")
        .def_readwrite("deactivated_after_edit", &ImGuiTestGenericItemStatus::DeactivatedAfterEdit, "result of IsItemDeactivatedAfterEdit()")
        .def(py::init<>())
        .def("clear",
            &ImGuiTestGenericItemStatus::Clear, "(private API)")
        .def("query_set",
            &ImGuiTestGenericItemStatus::QuerySet,
            py::arg("ret_val") = false,
            "(private API)")
        .def("query_inc",
            &ImGuiTestGenericItemStatus::QueryInc,
            py::arg("ret_val") = false,
            "(private API)")
        ;


    auto pyClassImGuiTestGenericVars =
        py::class_<ImGuiTestGenericVars>
            (m, "TestGenericVars", " Generic structure with various storage fields.\n This is useful for tests to quickly share data between GuiFunc and TestFunc without creating custom data structure.\n If those fields are not enough: using test->SetVarsDataType<>() + ctx->GetVars<>() it is possible to store custom data.")
        .def_readwrite("step", &ImGuiTestGenericVars::Step, "")
        .def_readwrite("count", &ImGuiTestGenericVars::Count, "")
        .def_readwrite("dock_id", &ImGuiTestGenericVars::DockId, "")
        .def_readwrite("window_flags", &ImGuiTestGenericVars::WindowFlags, "")
        .def_readwrite("table_flags", &ImGuiTestGenericVars::TableFlags, "")
        .def_readwrite("popup_flags", &ImGuiTestGenericVars::PopupFlags, "")
        .def_readwrite("status", &ImGuiTestGenericVars::Status, "")
        .def_readwrite("show_window1", &ImGuiTestGenericVars::ShowWindow1, "")
        .def_readwrite("show_window2", &ImGuiTestGenericVars::ShowWindow2, "")
        .def_readwrite("use_clipper", &ImGuiTestGenericVars::UseClipper, "")
        .def_readwrite("use_viewports", &ImGuiTestGenericVars::UseViewports, "")
        .def_readwrite("width", &ImGuiTestGenericVars::Width, "")
        .def_readwrite("pos", &ImGuiTestGenericVars::Pos, "")
        .def_readwrite("size", &ImGuiTestGenericVars::Size, "")
        .def_readwrite("pivot", &ImGuiTestGenericVars::Pivot, "")
        .def_readwrite("color1", &ImGuiTestGenericVars::Color1, "")
        .def_readwrite("color2", &ImGuiTestGenericVars::Color2, "")
        .def_readwrite("int1", &ImGuiTestGenericVars::Int1, "")
        .def_readwrite("int2", &ImGuiTestGenericVars::Int2, "")
        .def_property("int_array",
            [](ImGuiTestGenericVars &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<int>::format());
                auto base = pybind11::array(dtype, {10}, {sizeof(int)});
                return pybind11::array(dtype, {10}, {sizeof(int)}, self.IntArray, base);
            }, [](ImGuiTestGenericVars& self) {},
            "")
        .def_readwrite("float1", &ImGuiTestGenericVars::Float1, "")
        .def_readwrite("float2", &ImGuiTestGenericVars::Float2, "")
        .def_property("float_array",
            [](ImGuiTestGenericVars &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<float>::format());
                auto base = pybind11::array(dtype, {10}, {sizeof(float)});
                return pybind11::array(dtype, {10}, {sizeof(float)}, self.FloatArray, base);
            }, [](ImGuiTestGenericVars& self) {},
            "")
        .def_readwrite("bool1", &ImGuiTestGenericVars::Bool1, "")
        .def_readwrite("bool2", &ImGuiTestGenericVars::Bool2, "")
        .def_property("bool_array",
            [](ImGuiTestGenericVars &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<bool>::format());
                auto base = pybind11::array(dtype, {10}, {sizeof(bool)});
                return pybind11::array(dtype, {10}, {sizeof(bool)}, self.BoolArray, base);
            }, [](ImGuiTestGenericVars& self) {},
            "")
        .def_readwrite("id_", &ImGuiTestGenericVars::Id, "")
        .def_property("id_array",
            [](ImGuiTestGenericVars &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<ImGuiID>::format());
                auto base = pybind11::array(dtype, {10}, {sizeof(ImGuiID)});
                return pybind11::array(dtype, {10}, {sizeof(ImGuiID)}, self.IdArray, base);
            }, [](ImGuiTestGenericVars& self) {},
            "")
        .def(py::init<>())
        .def("clear",
            &ImGuiTestGenericVars::Clear, "(private API)")
        ;


    auto pyClassImGuiTestContext =
        py::class_<ImGuiTestContext>
            (m, "TestContext", "")
        .def(py::init<>([](
        ImGuiTestGenericVars GenericVars = ImGuiTestGenericVars(), ImGuiTestOpFlags OpFlags = ImGuiTestOpFlags_None, int PerfStressAmount = 0, int FrameCount = 0, int FirstTestFrameCount = 0, bool FirstGuiFrame = false, bool HasDock = false, ImGuiTestRunFlags RunFlags = ImGuiTestRunFlags_None, ImGuiTestActiveFunc ActiveFunc = ImGuiTestActiveFunc_None, double RunningTime = 0.0, int ActionDepth = 0, int CaptureCounter = 0, int ErrorCounter = 0, bool Abort = false, double PerfRefDt = -1.0, int PerfIterations = 400, ImGuiID RefID = 0, ImGuiID RefWindowID = 0, ImGuiInputSource InputMode = ImGuiInputSource_Mouse, ImVector<char> Clipboard = ImVector<char>(), ImVector<ImGuiWindow*> ForeignWindowsToHide = ImVector<ImGuiWindow*>(), ImGuiTestItemInfo DummyItemInfoNull = ImGuiTestItemInfo(), bool CachedLinesPrintedToTTY = false)
        {
            auto r = std::make_unique<ImGuiTestContext>();
            r->GenericVars = GenericVars;
            r->OpFlags = OpFlags;
            r->PerfStressAmount = PerfStressAmount;
            r->FrameCount = FrameCount;
            r->FirstTestFrameCount = FirstTestFrameCount;
            r->FirstGuiFrame = FirstGuiFrame;
            r->HasDock = HasDock;
            r->RunFlags = RunFlags;
            r->ActiveFunc = ActiveFunc;
            r->RunningTime = RunningTime;
            r->ActionDepth = ActionDepth;
            r->CaptureCounter = CaptureCounter;
            r->ErrorCounter = ErrorCounter;
            r->Abort = Abort;
            r->PerfRefDt = PerfRefDt;
            r->PerfIterations = PerfIterations;
            r->RefID = RefID;
            r->RefWindowID = RefWindowID;
            r->InputMode = InputMode;
            r->Clipboard = Clipboard;
            r->ForeignWindowsToHide = ForeignWindowsToHide;
            r->DummyItemInfoNull = DummyItemInfoNull;
            r->CachedLinesPrintedToTTY = CachedLinesPrintedToTTY;
            return r;
        })
        , py::arg("generic_vars") = ImGuiTestGenericVars(), py::arg("op_flags") = ImGuiTestOpFlags_None, py::arg("perf_stress_amount") = 0, py::arg("frame_count") = 0, py::arg("first_test_frame_count") = 0, py::arg("first_gui_frame") = false, py::arg("has_dock") = false, py::arg("run_flags") = ImGuiTestRunFlags_None, py::arg("active_func") = ImGuiTestActiveFunc_None, py::arg("running_time") = 0.0, py::arg("action_depth") = 0, py::arg("capture_counter") = 0, py::arg("error_counter") = 0, py::arg("abort") = false, py::arg("perf_ref_dt") = -1.0, py::arg("perf_iterations") = 400, py::arg("ref_id") = 0, py::arg("ref_window_id") = 0, py::arg("input_mode") = ImGuiInputSource_Mouse, py::arg("clipboard") = ImVector<char>(), py::arg("foreign_windows_to_hide") = ImVector<ImGuiWindow*>(), py::arg("dummy_item_info_null") = ImGuiTestItemInfo(), py::arg("cached_lines_printed_to_tty") = false
        )
        .def_readwrite("generic_vars", &ImGuiTestContext::GenericVars, "")
        .def_readwrite("user_vars", &ImGuiTestContext::UserVars, "Access using ctx->GetVars<Type>(). Setup with test->SetVarsDataType<>().")
        .def_readwrite("ui_context", &ImGuiTestContext::UiContext, "UI context")
        .def_readwrite("engine_io", &ImGuiTestContext::EngineIO, "Test Engine IO/settings")
        .def_readwrite("test", &ImGuiTestContext::Test, "Test currently running")
        .def_readwrite("op_flags", &ImGuiTestContext::OpFlags, "Flags affecting all operation (supported: ImGuiTestOpFlags_NoAutoUncollapse)")
        .def_readwrite("perf_stress_amount", &ImGuiTestContext::PerfStressAmount, "Convenience copy of engine->IO.PerfStressAmount")
        .def_readwrite("frame_count", &ImGuiTestContext::FrameCount, "Test frame count (restarts from zero every time)")
        .def_readwrite("first_test_frame_count", &ImGuiTestContext::FirstTestFrameCount, "First frame where TestFunc is running (after warm-up frame). This is generally -1 or 0 depending on whether we have warm up enabled")
        .def_readwrite("first_gui_frame", &ImGuiTestContext::FirstGuiFrame, "")
        .def_readwrite("has_dock", &ImGuiTestContext::HasDock, "#ifdef IMGUI_HAS_DOCK expressed in an easier to test value")
        .def_readwrite("engine", &ImGuiTestContext::Engine, "")
        .def_readwrite("inputs", &ImGuiTestContext::Inputs, "")
        .def_readwrite("run_flags", &ImGuiTestContext::RunFlags, "")
        .def_readwrite("active_func", &ImGuiTestContext::ActiveFunc, "None/GuiFunc/TestFunc")
        .def_readwrite("running_time", &ImGuiTestContext::RunningTime, "Amount of wall clock time the Test has been running. Used by safety watchdog.")
        .def_readwrite("action_depth", &ImGuiTestContext::ActionDepth, "Nested depth of ctx-> function calls (used to decorate log)")
        .def_readwrite("capture_counter", &ImGuiTestContext::CaptureCounter, "Number of captures")
        .def_readwrite("error_counter", &ImGuiTestContext::ErrorCounter, "Number of errors (generally this maxxes at 1 as most functions will early out)")
        .def_readwrite("abort", &ImGuiTestContext::Abort, "")
        .def_readwrite("perf_ref_dt", &ImGuiTestContext::PerfRefDt, "")
        .def_readwrite("perf_iterations", &ImGuiTestContext::PerfIterations, "Number of frames for PerfCapture() measurements")
        .def_readwrite("ref_id", &ImGuiTestContext::RefID, "Reference ID over which all named references are based")
        .def_readwrite("ref_window_id", &ImGuiTestContext::RefWindowID, "ID of a window that contains RefID item")
        .def_readwrite("input_mode", &ImGuiTestContext::InputMode, "Prefer interacting with mouse/keyboard/gamepad")
        .def_readwrite("clipboard", &ImGuiTestContext::Clipboard, "Private clipboard for the test instance")
        .def_readwrite("foreign_windows_to_hide", &ImGuiTestContext::ForeignWindowsToHide, "")
        .def_readwrite("dummy_item_info_null", &ImGuiTestContext::DummyItemInfoNull, "Storage for ItemInfoNull()")
        .def_readwrite("cached_lines_printed_to_tty", &ImGuiTestContext::CachedLinesPrintedToTTY, "")
        .def("finish",
            &ImGuiTestContext::Finish, "(private API)")
        .def("recover_from_ui_context_errors",
            &ImGuiTestContext::RecoverFromUiContextErrors, "(private API)")
        .def("is_error",
            &ImGuiTestContext::IsError, "(private API)")
        .def("is_warm_up_gui_frame",
            &ImGuiTestContext::IsWarmUpGuiFrame, "(private API)\n\n Unless test->Flags has ImGuiTestFlags_NoGuiWarmUp, we run GuiFunc() twice before running TestFunc(). Those frames are called \"WarmUp\" frames.")
        .def("is_first_gui_frame",
            &ImGuiTestContext::IsFirstGuiFrame, "(private API)")
        .def("is_first_test_frame",
            &ImGuiTestContext::IsFirstTestFrame, "(private API)\n\n First frame where TestFunc is running (after warm-up frame).")
        .def("is_gui_func_only",
            &ImGuiTestContext::IsGuiFuncOnly, "(private API)")
        .def("set_gui_func_enabled",
            &ImGuiTestContext::SetGuiFuncEnabled,
            py::arg("v"),
            "(private API)")
        .def("suspend_test_func",
            &ImGuiTestContext::SuspendTestFunc,
            py::arg("file") = py::none(), py::arg("line") = 0,
            "(private API)\n\n Generally called via IM_SUSPEND_TESTFUNC")
        .def("log_ex",
            [](ImGuiTestContext & self, ImGuiTestVerboseLevel level, ImGuiTestLogFlags flags, const char * fmt)
            {
                auto LogEx_adapt_variadic_format = [&self](ImGuiTestVerboseLevel level, ImGuiTestLogFlags flags, const char * fmt)
                {
                    self.LogEx(level, flags, "%s", fmt);
                };

                LogEx_adapt_variadic_format(level, flags, fmt);
            },
            py::arg("level"), py::arg("flags"), py::arg("fmt"),
            "(private API)")
        .def("log_to_tty",
            &ImGuiTestContext::LogToTTY,
            py::arg("level"), py::arg("message"), py::arg("message_end") = py::none(),
            "(private API)")
        .def("log_to_debugger",
            &ImGuiTestContext::LogToDebugger,
            py::arg("level"), py::arg("message"),
            "(private API)")
        .def("log_debug",
            [](ImGuiTestContext & self, const char * fmt)
            {
                auto LogDebug_adapt_variadic_format = [&self](const char * fmt)
                {
                    self.LogDebug("%s", fmt);
                };

                LogDebug_adapt_variadic_format(fmt);
            },
            py::arg("fmt"),
            "(private API)\n\n ImGuiTestVerboseLevel_Debug or ImGuiTestVerboseLevel_Trace depending on context depth")
        .def("log_info",
            [](ImGuiTestContext & self, const char * fmt)
            {
                auto LogInfo_adapt_variadic_format = [&self](const char * fmt)
                {
                    self.LogInfo("%s", fmt);
                };

                LogInfo_adapt_variadic_format(fmt);
            },
            py::arg("fmt"),
            "(private API)\n\n ImGuiTestVerboseLevel_Info")
        .def("log_warning",
            [](ImGuiTestContext & self, const char * fmt)
            {
                auto LogWarning_adapt_variadic_format = [&self](const char * fmt)
                {
                    self.LogWarning("%s", fmt);
                };

                LogWarning_adapt_variadic_format(fmt);
            },
            py::arg("fmt"),
            "(private API)\n\n ImGuiTestVerboseLevel_Warning")
        .def("log_error",
            [](ImGuiTestContext & self, const char * fmt)
            {
                auto LogError_adapt_variadic_format = [&self](const char * fmt)
                {
                    self.LogError("%s", fmt);
                };

                LogError_adapt_variadic_format(fmt);
            },
            py::arg("fmt"),
            "(private API)\n\n ImGuiTestVerboseLevel_Error")
        .def("log_basic_ui_state",
            &ImGuiTestContext::LogBasicUiState, "(private API)")
        .def("log_item_list",
            &ImGuiTestContext::LogItemList,
            py::arg("list"),
            "(private API)")
        .def("yield_",
            &ImGuiTestContext::Yield,
            py::arg("count") = 1,
            "(private API)")
        .def("yield_until",
            &ImGuiTestContext::YieldUntil,
            py::arg("frame_count"),
            "(private API)")
        .def("sleep",
            &ImGuiTestContext::Sleep,
            py::arg("time_in_second"),
            "(private API)\n\n Sleep for a given simulation time, unless in Fast mode")
        .def("sleep_short",
            &ImGuiTestContext::SleepShort, "(private API)\n\n Standard short delay of io.ActionDelayShort (~0.15), unless in Fast mode.")
        .def("sleep_standard",
            &ImGuiTestContext::SleepStandard, "(private API)\n\n Standard regular delay of io.ActionDelayStandard (~0.40), unless in Fast mode.")
        .def("sleep_no_skip",
            &ImGuiTestContext::SleepNoSkip,
            py::arg("time_in_second"), py::arg("framestep_in_second"),
            "(private API)")
        .def("set_ref",
            py::overload_cast<ImGuiTestRef>(&ImGuiTestContext::SetRef),
            py::arg("ref"),
            "(private API)")
        .def("set_ref",
            py::overload_cast<ImGuiWindow *>(&ImGuiTestContext::SetRef),
            py::arg("window"),
            "(private API)\n\n Shortcut to SetRef(window->Name) which works for ChildWindow (see code)")
        .def("get_ref",
            &ImGuiTestContext::GetRef, "(private API)")
        .def("window_info",
            &ImGuiTestContext::WindowInfo,
            py::arg("window_ref"), py::arg("flags") = ImGuiTestOpFlags_None,
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("window_close",
            &ImGuiTestContext::WindowClose,
            py::arg("window_ref"),
            "(private API)")
        .def("window_collapse",
            &ImGuiTestContext::WindowCollapse,
            py::arg("window_ref"), py::arg("collapsed"),
            "(private API)")
        .def("window_focus",
            &ImGuiTestContext::WindowFocus,
            py::arg("window_ref"), py::arg("flags") = ImGuiTestOpFlags_None,
            "(private API)")
        .def("window_bring_to_front",
            &ImGuiTestContext::WindowBringToFront,
            py::arg("window_ref"), py::arg("flags") = ImGuiTestOpFlags_None,
            "(private API)")
        .def("window_move",
            &ImGuiTestContext::WindowMove,
            py::arg("window_ref"), py::arg("pos"), py::arg("pivot") = ImVec2(0.0f, 0.0f), py::arg("flags") = ImGuiTestOpFlags_None,
            "(private API)")
        .def("window_resize",
            &ImGuiTestContext::WindowResize,
            py::arg("window_ref"), py::arg("sz"),
            "(private API)")
        .def("window_teleport_to_make_pos_visible",
            &ImGuiTestContext::WindowTeleportToMakePosVisible,
            py::arg("window_ref"), py::arg("pos_in_window"),
            "(private API)")
        .def("get_window_by_ref",
            &ImGuiTestContext::GetWindowByRef,
            py::arg("window_ref"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("popup_close_one",
            [](ImGuiTestContext & self) { return self.PopupCloseOne(); }, "(private API)")
        .def("popup_close_all",
            [](ImGuiTestContext & self) { return self.PopupCloseAll(); }, "(private API)")
        .def("popup_get_window_id",
            py::overload_cast<ImGuiTestRef>(&ImGuiTestContext::PopupGetWindowID),
            py::arg("ref"),
            "(private API)")
        .def("get_id",
            py::overload_cast<ImGuiTestRef>(&ImGuiTestContext::GetID),
            py::arg("ref"),
            "(private API)")
        .def("get_id",
            py::overload_cast<ImGuiTestRef, ImGuiTestRef>(&ImGuiTestContext::GetID),
            py::arg("ref"), py::arg("seed_ref"),
            "(private API)")
        .def("get_pos_on_void",
            &ImGuiTestContext::GetPosOnVoid,
            py::arg("viewport"),
            "(private API)\n\n Find a point that has no windows // FIXME: This needs error return and flag to enable/disable forcefully finding None.")
        .def("get_window_titlebar_point",
            &ImGuiTestContext::GetWindowTitlebarPoint,
            py::arg("window_ref"),
            "(private API)\n\n Return a clickable point on window title-bar (window tab for docked windows).")
        .def("get_main_monitor_work_pos",
            &ImGuiTestContext::GetMainMonitorWorkPos, "(private API)\n\n Work pos and size of main viewport when viewports are disabled, or work pos and size of monitor containing main viewport when viewports are enabled.")
        .def("get_main_monitor_work_size",
            &ImGuiTestContext::GetMainMonitorWorkSize, "(private API)")
        .def("capture_reset",
            &ImGuiTestContext::CaptureReset, "(private API)\n\n Reset state (use when doing multiple captures)")
        .def("capture_set_extension",
            &ImGuiTestContext::CaptureSetExtension,
            py::arg("ext"),
            "(private API)\n\n Set capture file format (otherwise for video this default to EngineIO->VideoCaptureExtension)")
        .def("capture_add_window",
            &ImGuiTestContext::CaptureAddWindow,
            py::arg("ref"),
            "(private API)\n\n Add window to be captured (default to capture everything)")
        .def("capture_screenshot_window",
            &ImGuiTestContext::CaptureScreenshotWindow,
            py::arg("ref"), py::arg("capture_flags") = 0,
            "(private API)\n\n Trigger a screen capture of a single window (== CaptureAddWindow() + CaptureScreenshot())")
        .def("capture_screenshot",
            &ImGuiTestContext::CaptureScreenshot,
            py::arg("capture_flags") = 0,
            "(private API)\n\n Trigger a screen capture")
        .def("capture_begin_video",
            &ImGuiTestContext::CaptureBeginVideo, "(private API)\n\n Start a video capture")
        .def("capture_end_video",
            &ImGuiTestContext::CaptureEndVideo, "(private API)")
        .def("mouse_move",
            &ImGuiTestContext::MouseMove,
            py::arg("ref"), py::arg("flags") = ImGuiTestOpFlags_None,
            "(private API)")
        .def("mouse_move_to_pos",
            &ImGuiTestContext::MouseMoveToPos,
            py::arg("pos"),
            "(private API)")
        .def("mouse_teleport_to_pos",
            &ImGuiTestContext::MouseTeleportToPos,
            py::arg("pos"),
            "(private API)")
        .def("mouse_click",
            &ImGuiTestContext::MouseClick,
            py::arg("button") = 0,
            "(private API)")
        .def("mouse_click_multi",
            &ImGuiTestContext::MouseClickMulti,
            py::arg("button"), py::arg("count"),
            "(private API)")
        .def("mouse_double_click",
            &ImGuiTestContext::MouseDoubleClick,
            py::arg("button") = 0,
            "(private API)")
        .def("mouse_down",
            &ImGuiTestContext::MouseDown,
            py::arg("button") = 0,
            "(private API)")
        .def("mouse_up",
            &ImGuiTestContext::MouseUp,
            py::arg("button") = 0,
            "(private API)")
        .def("mouse_lift_drag_threshold",
            &ImGuiTestContext::MouseLiftDragThreshold,
            py::arg("button") = 0,
            "(private API)")
        .def("mouse_drag_with_delta",
            &ImGuiTestContext::MouseDragWithDelta,
            py::arg("delta"), py::arg("button") = 0,
            "(private API)")
        .def("mouse_wheel",
            &ImGuiTestContext::MouseWheel,
            py::arg("delta"),
            "(private API)")
        .def("mouse_wheel_x",
            &ImGuiTestContext::MouseWheelX,
            py::arg("dx"),
            "(private API)")
        .def("mouse_wheel_y",
            &ImGuiTestContext::MouseWheelY,
            py::arg("dy"),
            "(private API)")
        .def("mouse_move_to_void",
            &ImGuiTestContext::MouseMoveToVoid,
            py::arg("viewport") = py::none(),
            "(private API)")
        .def("mouse_click_on_void",
            &ImGuiTestContext::MouseClickOnVoid,
            py::arg("button") = 0, py::arg("viewport") = py::none(),
            "(private API)")
        .def("find_hovered_window_at_pos",
            &ImGuiTestContext::FindHoveredWindowAtPos,
            py::arg("pos"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("find_existing_void_pos_on_viewport",
            &ImGuiTestContext::FindExistingVoidPosOnViewport,
            py::arg("viewport"), py::arg("out"),
            "(private API)")
        .def("mouse_set_viewport",
            &ImGuiTestContext::MouseSetViewport,
            py::arg("window"),
            "(private API)")
        .def("mouse_set_viewport_id",
            &ImGuiTestContext::MouseSetViewportID,
            py::arg("viewport_id"),
            "(private API)")
        .def("key_down",
            &ImGuiTestContext::KeyDown,
            py::arg("key_chord"),
            "(private API)")
        .def("key_up",
            &ImGuiTestContext::KeyUp,
            py::arg("key_chord"),
            "(private API)")
        .def("key_press",
            &ImGuiTestContext::KeyPress,
            py::arg("key_chord"), py::arg("count") = 1,
            "(private API)")
        .def("key_hold",
            &ImGuiTestContext::KeyHold,
            py::arg("key_chord"), py::arg("time"),
            "(private API)")
        .def("key_chars",
            &ImGuiTestContext::KeyChars,
            py::arg("chars"),
            "(private API)\n\n Input characters")
        .def("key_chars_append",
            &ImGuiTestContext::KeyCharsAppend,
            py::arg("chars"),
            "(private API)\n\n Input characters at end of field")
        .def("key_chars_append_enter",
            &ImGuiTestContext::KeyCharsAppendEnter,
            py::arg("chars"),
            "(private API)\n\n Input characters at end of field, press Enter")
        .def("key_chars_replace",
            &ImGuiTestContext::KeyCharsReplace,
            py::arg("chars"),
            "(private API)\n\n Delete existing field then input characters")
        .def("key_chars_replace_enter",
            &ImGuiTestContext::KeyCharsReplaceEnter,
            py::arg("chars"),
            "(private API)\n\n Delete existing field then input characters, press Enter")
        .def("set_input_mode",
            &ImGuiTestContext::SetInputMode,
            py::arg("input_mode"),
            "(private API)\n\n Mouse or Keyboard or Gamepad. In Keyboard or Gamepad mode, actions such as ItemClick or ItemInput are using nav facilities instead of Mouse.")
        .def("nav_move_to",
            &ImGuiTestContext::NavMoveTo,
            py::arg("ref"),
            "(private API)")
        .def("nav_activate",
            &ImGuiTestContext::NavActivate, "(private API)\n\n Activate current selected item: activate button, tweak sliders/drags. Equivalent of pressing Space on keyboard, ImGuiKey_GamepadFaceUp on a gamepad.")
        .def("nav_input",
            &ImGuiTestContext::NavInput, "(private API)\n\n Input into select item: input sliders/drags. Equivalent of pressing Enter on keyboard, ImGuiKey_GamepadFaceDown on a gamepad.")
        .def("scroll_to",
            &ImGuiTestContext::ScrollTo,
            py::arg("ref"), py::arg("axis"), py::arg("scroll_v"), py::arg("flags") = ImGuiTestOpFlags_None,
            " Scrolling\n(private API)")
        .def("scroll_to_x",
            &ImGuiTestContext::ScrollToX,
            py::arg("ref"), py::arg("scroll_x"),
            "(private API)")
        .def("scroll_to_y",
            &ImGuiTestContext::ScrollToY,
            py::arg("ref"), py::arg("scroll_y"),
            "(private API)")
        .def("scroll_to_top",
            &ImGuiTestContext::ScrollToTop,
            py::arg("ref"),
            "(private API)")
        .def("scroll_to_bottom",
            &ImGuiTestContext::ScrollToBottom,
            py::arg("ref"),
            "(private API)")
        .def("scroll_to_item",
            &ImGuiTestContext::ScrollToItem,
            py::arg("ref"), py::arg("axis"), py::arg("flags") = ImGuiTestOpFlags_None,
            "(private API)")
        .def("scroll_to_item_x",
            &ImGuiTestContext::ScrollToItemX,
            py::arg("ref"),
            "(private API)")
        .def("scroll_to_item_y",
            &ImGuiTestContext::ScrollToItemY,
            py::arg("ref"),
            "(private API)")
        .def("scroll_to_tab_item",
            &ImGuiTestContext::ScrollToTabItem,
            py::arg("tab_bar"), py::arg("tab_id"),
            "(private API)")
        .def("scroll_error_check",
            [](ImGuiTestContext & self, ImGuiAxis axis, float expected, float actual, int remaining_attempts) -> std::tuple<bool, int>
            {
                auto ScrollErrorCheck_adapt_modifiable_immutable_to_return = [&self](ImGuiAxis axis, float expected, float actual, int remaining_attempts) -> std::tuple<bool, int>
                {
                    int * remaining_attempts_adapt_modifiable = & remaining_attempts;

                    bool r = self.ScrollErrorCheck(axis, expected, actual, remaining_attempts_adapt_modifiable);
                    return std::make_tuple(r, remaining_attempts);
                };

                return ScrollErrorCheck_adapt_modifiable_immutable_to_return(axis, expected, actual, remaining_attempts);
            },
            py::arg("axis"), py::arg("expected"), py::arg("actual"), py::arg("remaining_attempts"),
            "(private API)")
        .def("scroll_verify_scroll_max",
            &ImGuiTestContext::ScrollVerifyScrollMax,
            py::arg("ref"),
            "(private API)")
        .def("item_info",
            &ImGuiTestContext::ItemInfo,
            py::arg("ref"), py::arg("flags") = ImGuiTestOpFlags_None,
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("item_info_open_full_path",
            &ImGuiTestContext::ItemInfoOpenFullPath,
            py::arg("ref"), py::arg("flags") = ImGuiTestOpFlags_None,
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("item_info_handle_wildcard_search",
            &ImGuiTestContext::ItemInfoHandleWildcardSearch,
            py::arg("wildcard_prefix_start"), py::arg("wildcard_prefix_end"), py::arg("wildcard_suffix_start"),
            "(private API)")
        .def("item_info_null",
            &ImGuiTestContext::ItemInfoNull,
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("gather_items",
            &ImGuiTestContext::GatherItems,
            py::arg("out_list"), py::arg("parent"), py::arg("depth") = -1,
            "(private API)")
        .def("item_action",
            &ImGuiTestContext::ItemAction,
            py::arg("action"), py::arg("ref"), py::arg("flags") = 0, py::arg("action_arg") = py::none(),
            " Item/Widgets manipulation\n(private API)")
        .def("item_click",
            &ImGuiTestContext::ItemClick,
            py::arg("ref"), py::arg("button") = 0, py::arg("flags") = 0,
            "(private API)")
        .def("item_double_click",
            &ImGuiTestContext::ItemDoubleClick,
            py::arg("ref"), py::arg("flags") = 0,
            "(private API)")
        .def("item_check",
            &ImGuiTestContext::ItemCheck,
            py::arg("ref"), py::arg("flags") = 0,
            "(private API)")
        .def("item_uncheck",
            &ImGuiTestContext::ItemUncheck,
            py::arg("ref"), py::arg("flags") = 0,
            "(private API)")
        .def("item_open",
            &ImGuiTestContext::ItemOpen,
            py::arg("ref"), py::arg("flags") = 0,
            "(private API)")
        .def("item_close",
            &ImGuiTestContext::ItemClose,
            py::arg("ref"), py::arg("flags") = 0,
            "(private API)")
        .def("item_input",
            &ImGuiTestContext::ItemInput,
            py::arg("ref"), py::arg("flags") = 0,
            "(private API)")
        .def("item_nav_activate",
            &ImGuiTestContext::ItemNavActivate,
            py::arg("ref"), py::arg("flags") = 0,
            "(private API)")
        .def("item_action_all",
            &ImGuiTestContext::ItemActionAll,
            py::arg("action"), py::arg("ref_parent"), py::arg("filter") = py::none(),
            "(private API)")
        .def("item_open_all",
            &ImGuiTestContext::ItemOpenAll,
            py::arg("ref_parent"), py::arg("depth") = -1, py::arg("passes") = -1,
            "(private API)")
        .def("item_close_all",
            &ImGuiTestContext::ItemCloseAll,
            py::arg("ref_parent"), py::arg("depth") = -1, py::arg("passes") = -1,
            "(private API)")
        .def("item_input_value",
            py::overload_cast<ImGuiTestRef, int>(&ImGuiTestContext::ItemInputValue),
            py::arg("ref"), py::arg("v"),
            "(private API)")
        .def("item_input_value",
            py::overload_cast<ImGuiTestRef, float>(&ImGuiTestContext::ItemInputValue),
            py::arg("ref"), py::arg("f"),
            "(private API)")
        .def("item_input_value",
            py::overload_cast<ImGuiTestRef, const char *>(&ImGuiTestContext::ItemInputValue),
            py::arg("ref"), py::arg("str"),
            "(private API)")
        .def("item_hold",
            &ImGuiTestContext::ItemHold,
            py::arg("ref"), py::arg("time"),
            "(private API)")
        .def("item_hold_for_frames",
            &ImGuiTestContext::ItemHoldForFrames,
            py::arg("ref"), py::arg("frames"),
            "(private API)")
        .def("item_drag_over_and_hold",
            &ImGuiTestContext::ItemDragOverAndHold,
            py::arg("ref_src"), py::arg("ref_dst"),
            "(private API)")
        .def("item_drag_and_drop",
            &ImGuiTestContext::ItemDragAndDrop,
            py::arg("ref_src"), py::arg("ref_dst"), py::arg("button") = 0,
            "(private API)")
        .def("item_drag_with_delta",
            &ImGuiTestContext::ItemDragWithDelta,
            py::arg("ref_src"), py::arg("pos_delta"),
            "(private API)")
        .def("item_exists",
            &ImGuiTestContext::ItemExists,
            py::arg("ref"),
            "(private API)")
        .def("item_is_checked",
            &ImGuiTestContext::ItemIsChecked,
            py::arg("ref"),
            "(private API)")
        .def("item_is_opened",
            &ImGuiTestContext::ItemIsOpened,
            py::arg("ref"),
            "(private API)")
        .def("item_verify_checked_if_alive",
            &ImGuiTestContext::ItemVerifyCheckedIfAlive,
            py::arg("ref"), py::arg("checked"),
            "(private API)")
        .def("tab_close",
            &ImGuiTestContext::TabClose,
            py::arg("ref"),
            "(private API)")
        .def("menu_action",
            &ImGuiTestContext::MenuAction,
            py::arg("action"), py::arg("ref"),
            "(private API)")
        .def("menu_action_all",
            &ImGuiTestContext::MenuActionAll,
            py::arg("action"), py::arg("ref_parent"),
            "(private API)")
        .def("menu_click",
            &ImGuiTestContext::MenuClick,
            py::arg("ref"),
            "(private API)")
        .def("menu_check",
            &ImGuiTestContext::MenuCheck,
            py::arg("ref"),
            "(private API)")
        .def("menu_uncheck",
            &ImGuiTestContext::MenuUncheck,
            py::arg("ref"),
            "(private API)")
        .def("menu_check_all",
            &ImGuiTestContext::MenuCheckAll,
            py::arg("ref_parent"),
            "(private API)")
        .def("menu_uncheck_all",
            &ImGuiTestContext::MenuUncheckAll,
            py::arg("ref_parent"),
            "(private API)")
        .def("combo_click",
            &ImGuiTestContext::ComboClick,
            py::arg("ref"),
            "(private API)")
        .def("combo_click_all",
            &ImGuiTestContext::ComboClickAll,
            py::arg("ref"),
            "(private API)")
        .def("table_open_context_menu",
            py::overload_cast<ImGuiTestRef, int>(&ImGuiTestContext::TableOpenContextMenu),
            py::arg("ref"), py::arg("column_n") = -1,
            "(private API)")
        .def("table_click_header",
            py::overload_cast<ImGuiTestRef, const char *, ImGuiKeyChord>(&ImGuiTestContext::TableClickHeader),
            py::arg("ref"), py::arg("label"), py::arg("key_mods") = 0,
            "(private API)")
        .def("table_set_column_enabled",
            py::overload_cast<ImGuiTestRef, const char *, bool>(&ImGuiTestContext::TableSetColumnEnabled),
            py::arg("ref"), py::arg("label"), py::arg("enabled"),
            "(private API)")
        .def("table_resize_column",
            py::overload_cast<ImGuiTestRef, int, float>(&ImGuiTestContext::TableResizeColumn),
            py::arg("ref"), py::arg("column_n"), py::arg("width"),
            "(private API)")
        .def("table_get_sort_specs",
            py::overload_cast<ImGuiTestRef>(&ImGuiTestContext::TableGetSortSpecs),
            py::arg("ref"),
            "(private API)",
            pybind11::return_value_policy::reference)
        // #ifdef IMGUI_HAS_DOCK
        //
        .def("dock_clear",
            [](ImGuiTestContext & self, const char * window_name)
            {
                auto DockClear_adapt_variadic_format = [&self](const char * window_name)
                {
                    self.DockClear("%s", window_name);
                };

                DockClear_adapt_variadic_format(window_name);
            },
            py::arg("window_name"),
            "(private API)")
        .def("dock_into",
            &ImGuiTestContext::DockInto,
            py::arg("src_id"), py::arg("dst_id"), py::arg("split_dir") = ImGuiDir_None, py::arg("is_outer_docking") = false, py::arg("flags") = 0,
            "(private API)")
        .def("undock_node",
            &ImGuiTestContext::UndockNode,
            py::arg("dock_id"),
            "(private API)")
        .def("undock_window",
            &ImGuiTestContext::UndockWindow,
            py::arg("window_name"),
            "(private API)")
        .def("window_is_undocked_or_standalone",
            &ImGuiTestContext::WindowIsUndockedOrStandalone,
            py::arg("window"),
            "(private API)")
        .def("dock_id_is_undocked_or_standalone",
            &ImGuiTestContext::DockIdIsUndockedOrStandalone,
            py::arg("dock_id"),
            "(private API)")
        .def("dock_node_hide_tab_bar",
            &ImGuiTestContext::DockNodeHideTabBar,
            py::arg("node"), py::arg("hidden"),
            "(private API)")
        // #endif
        //
        .def("perf_calc_ref",
            &ImGuiTestContext::PerfCalcRef, "(private API)")
        .def("perf_capture",
            &ImGuiTestContext::PerfCapture,
            py::arg("category") = py::none(), py::arg("test_name") = py::none(), py::arg("csv_file") = py::none(),
            "(private API)")
        .def("foreign_windows_unhide_all",
            &ImGuiTestContext::ForeignWindowsUnhideAll, "(private API)")
        ;
    ////////////////////    </generated_from:imgui_te_context.h>    ////////////////////


    ////////////////////    <generated_from:imgui_te_internal.h>    ////////////////////
    auto pyClassImGuiTestInfoTask =
        py::class_<ImGuiTestInfoTask>
            (m, "TestInfoTask", "Query item position/window/state given ID.")
        .def(py::init<>([](
        ImGuiID ID = 0, int FrameCount = -1, ImGuiTestItemInfo Result = ImGuiTestItemInfo())
        {
            auto r = std::make_unique<ImGuiTestInfoTask>();
            r->ID = ID;
            r->FrameCount = FrameCount;
            r->Result = Result;
            return r;
        })
        , py::arg("id_") = 0, py::arg("frame_count") = -1, py::arg("result") = ImGuiTestItemInfo()
        )
        .def_readwrite("id_", &ImGuiTestInfoTask::ID, "")
        .def_readwrite("frame_count", &ImGuiTestInfoTask::FrameCount, "Timestamp of request")
        .def_readwrite("result", &ImGuiTestInfoTask::Result, "Output")
        ;


    auto pyClassImGuiTestGatherTask =
        py::class_<ImGuiTestGatherTask>
            (m, "TestGatherTask", "Gather item list in given parent ID.")
        .def(py::init<>([](
        ImGuiID InParentID = 0, int InMaxDepth = 0, short InLayerMask = 0)
        {
            auto r = std::make_unique<ImGuiTestGatherTask>();
            r->InParentID = InParentID;
            r->InMaxDepth = InMaxDepth;
            r->InLayerMask = InLayerMask;
            return r;
        })
        , py::arg("in_parent_id") = 0, py::arg("in_max_depth") = 0, py::arg("in_layer_mask") = 0
        )
        .def_readwrite("in_parent_id", &ImGuiTestGatherTask::InParentID, "")
        .def_readwrite("in_max_depth", &ImGuiTestGatherTask::InMaxDepth, "")
        .def_readwrite("in_layer_mask", &ImGuiTestGatherTask::InLayerMask, "")
        .def_readwrite("out_list", &ImGuiTestGatherTask::OutList, "")
        .def_readwrite("last_item_info", &ImGuiTestGatherTask::LastItemInfo, "")
        .def("clear",
            &ImGuiTestGatherTask::Clear, "(private API)")
        ;


    auto pyClassImGuiTestFindByLabelTask =
        py::class_<ImGuiTestFindByLabelTask>
            (m, "TestFindByLabelTask", " Find item ID given a label and a parent id\n Usually used by queries with wildcards such as ItemInfo(\"hello/**/foo/bar\")")
        .def(py::init<>([](
        ImGuiID InPrefixId = 0, int InSuffixDepth = 0, ImGuiID InSuffixLastItemHash = 0, ImGuiItemStatusFlags InFilterItemStatusFlags = 0, ImGuiID OutItemId = 0)
        {
            auto r = std::make_unique<ImGuiTestFindByLabelTask>();
            r->InPrefixId = InPrefixId;
            r->InSuffixDepth = InSuffixDepth;
            r->InSuffixLastItemHash = InSuffixLastItemHash;
            r->InFilterItemStatusFlags = InFilterItemStatusFlags;
            r->OutItemId = OutItemId;
            return r;
        })
        , py::arg("in_prefix_id") = 0, py::arg("in_suffix_depth") = 0, py::arg("in_suffix_last_item_hash") = 0, py::arg("in_filter_item_status_flags") = 0, py::arg("out_item_id") = 0
        )
        .def_readwrite("in_prefix_id", &ImGuiTestFindByLabelTask::InPrefixId, "A known base ID which appears BEFORE the wildcard ID (for \"hello/**/foo/bar\" it would be hash of \"hello\")")
        .def_readwrite("in_suffix_depth", &ImGuiTestFindByLabelTask::InSuffixDepth, "Number of labels in a path, after unknown base ID (for \"hello/**/foo/bar\" it would be 2)")
        .def_readonly("in_suffix", &ImGuiTestFindByLabelTask::InSuffix, "A label string which appears on ID stack after unknown base ID (for \"hello/**/foo/bar\" it would be \"foo/bar\")")
        .def_readonly("in_suffix_last_item", &ImGuiTestFindByLabelTask::InSuffixLastItem, "A last label string (for \"hello/**/foo/bar\" it would be \"bar\")")
        .def_readwrite("in_suffix_last_item_hash", &ImGuiTestFindByLabelTask::InSuffixLastItemHash, "")
        .def_readwrite("in_filter_item_status_flags", &ImGuiTestFindByLabelTask::InFilterItemStatusFlags, "Flags required for item to be returned")
        .def_readwrite("out_item_id", &ImGuiTestFindByLabelTask::OutItemId, "Result item ID")
        ;


    py::enum_<ImGuiTestInputType>(m, "TestInputType", py::arithmetic(), "")
        .value("none", ImGuiTestInputType_None, "")
        .value("key", ImGuiTestInputType_Key, "")
        .value("char", ImGuiTestInputType_Char, "")
        .value("viewport_focus", ImGuiTestInputType_ViewportFocus, "")
        .value("viewport_close", ImGuiTestInputType_ViewportClose, "");


    auto pyClassImGuiTestInput =
        py::class_<ImGuiTestInput>
            (m, "TestInput", "FIXME: May want to strip further now that core imgui is using its own input queue")
        .def(py::init<>([](
        ImGuiTestInputType Type = ImGuiTestInputType_None, ImGuiKeyChord KeyChord = ImGuiKey_None, ImWchar Char = 0, bool Down = false, ImGuiID ViewportId = 0)
        {
            auto r = std::make_unique<ImGuiTestInput>();
            r->Type = Type;
            r->KeyChord = KeyChord;
            r->Char = Char;
            r->Down = Down;
            r->ViewportId = ViewportId;
            return r;
        })
        , py::arg("type") = ImGuiTestInputType_None, py::arg("key_chord") = ImGuiKey_None, py::arg("char") = 0, py::arg("down") = false, py::arg("viewport_id") = 0
        )
        .def_readwrite("type", &ImGuiTestInput::Type, "")
        .def_readwrite("key_chord", &ImGuiTestInput::KeyChord, "")
        .def_readwrite("char", &ImGuiTestInput::Char, "")
        .def_readwrite("down", &ImGuiTestInput::Down, "")
        .def_readwrite("viewport_id", &ImGuiTestInput::ViewportId, "")
        .def_static("for_key_chord",
            &ImGuiTestInput::ForKeyChord,
            py::arg("key_chord"), py::arg("down"),
            "(private API)")
        .def_static("for_char",
            &ImGuiTestInput::ForChar,
            py::arg("v"),
            "(private API)")
        .def_static("for_viewport_focus",
            &ImGuiTestInput::ForViewportFocus,
            py::arg("viewport_id"),
            "(private API)")
        .def_static("for_viewport_close",
            &ImGuiTestInput::ForViewportClose,
            py::arg("viewport_id"),
            "(private API)")
        ;


    auto pyClassImGuiTestInputs =
        py::class_<ImGuiTestInputs>
            (m, "TestInputs", "")
        .def(py::init<>([](
        ImVec2 MousePosValue = ImVec2(), ImVec2 MouseWheel = ImVec2(), ImGuiID MouseHoveredViewport = 0, int MouseButtonsValue = 0x00, bool HostEscDown = false, float HostEscDownDuration = -1.0f)
        {
            auto r = std::make_unique<ImGuiTestInputs>();
            r->MousePosValue = MousePosValue;
            r->MouseWheel = MouseWheel;
            r->MouseHoveredViewport = MouseHoveredViewport;
            r->MouseButtonsValue = MouseButtonsValue;
            r->HostEscDown = HostEscDown;
            r->HostEscDownDuration = HostEscDownDuration;
            return r;
        })
        , py::arg("mouse_pos_value") = ImVec2(), py::arg("mouse_wheel") = ImVec2(), py::arg("mouse_hovered_viewport") = 0, py::arg("mouse_buttons_value") = 0x00, py::arg("host_esc_down") = false, py::arg("host_esc_down_duration") = -1.0f
        )
        .def_readwrite("mouse_pos_value", &ImGuiTestInputs::MousePosValue, "Own non-rounded copy of MousePos in order facilitate simulating mouse movement very slow speed and high-framerate")
        .def_readwrite("mouse_wheel", &ImGuiTestInputs::MouseWheel, "")
        .def_readwrite("mouse_hovered_viewport", &ImGuiTestInputs::MouseHoveredViewport, "")
        .def_readwrite("mouse_buttons_value", &ImGuiTestInputs::MouseButtonsValue, "FIXME-TESTS: Use simulated_io.MouseDown[] ?")
        .def_readwrite("host_esc_down", &ImGuiTestInputs::HostEscDown, "")
        .def_readwrite("host_esc_down_duration", &ImGuiTestInputs::HostEscDownDuration, "Maintain our own DownDuration for host/backend ESC key so we can abort.")
        ;


    auto pyClassImGuiTestEngine =
        py::class_<ImGuiTestEngine>
            (m, "TestEngine", "[Internal] Test Engine Context")
        .def_readwrite("io", &ImGuiTestEngine::IO, "")
        .def_readwrite("ui_context_target", &ImGuiTestEngine::UiContextTarget, "imgui context for testing")
        .def_readwrite("ui_context_active", &ImGuiTestEngine::UiContextActive, "imgui context for testing == UiContextTarget or None")
        .def_readwrite("started", &ImGuiTestEngine::Started, "")
        .def_readwrite("batch_start_time", &ImGuiTestEngine::BatchStartTime, "")
        .def_readwrite("batch_end_time", &ImGuiTestEngine::BatchEndTime, "")
        .def_readwrite("frame_count", &ImGuiTestEngine::FrameCount, "")
        .def_readwrite("override_delta_time", &ImGuiTestEngine::OverrideDeltaTime, "Inject custom delta time into imgui context to simulate clock passing faster than wall clock time.")
        .def_readwrite("test_context", &ImGuiTestEngine::TestContext, "")
        .def_readwrite("gather_task", &ImGuiTestEngine::GatherTask, "")
        .def_readwrite("find_by_label_task", &ImGuiTestEngine::FindByLabelTask, "")
        .def_readwrite("user_data_buffer", &ImGuiTestEngine::UserDataBuffer, "")
        .def_readwrite("user_data_buffer_size", &ImGuiTestEngine::UserDataBufferSize, "")
        .def_readwrite("inputs", &ImGuiTestEngine::Inputs, "Inputs")
        .def_readwrite("abort", &ImGuiTestEngine::Abort, "")
        .def_readwrite("ui_select_and_scroll_to_test", &ImGuiTestEngine::UiSelectAndScrollToTest, "")
        .def_readwrite("ui_selected_test", &ImGuiTestEngine::UiSelectedTest, "")
        .def_readwrite("ui_metrics_open", &ImGuiTestEngine::UiMetricsOpen, "")
        .def_readwrite("ui_debug_log_open", &ImGuiTestEngine::UiDebugLogOpen, "")
        .def_readwrite("ui_capture_tool_open", &ImGuiTestEngine::UiCaptureToolOpen, "")
        .def_readwrite("ui_stack_tool_open", &ImGuiTestEngine::UiStackToolOpen, "")
        .def_readwrite("ui_perf_tool_open", &ImGuiTestEngine::UiPerfToolOpen, "")
        .def_readwrite("ui_log_height", &ImGuiTestEngine::UiLogHeight, "")
        .def_readwrite("perf_ref_delta_time", &ImGuiTestEngine::PerfRefDeltaTime, "")
        .def_readwrite("post_swap_called", &ImGuiTestEngine::PostSwapCalled, "")
        .def_readwrite("tool_debug_reboot_ui_context", &ImGuiTestEngine::ToolDebugRebootUiContext, "Completely shutdown and recreate the dear imgui context in place")
        .def_readwrite("tool_slow_down", &ImGuiTestEngine::ToolSlowDown, "")
        .def_readwrite("tool_slow_down_ms", &ImGuiTestEngine::ToolSlowDownMs, "")
        .def_readwrite("backup_config_run_speed", &ImGuiTestEngine::BackupConfigRunSpeed, "")
        .def_readwrite("backup_config_no_throttle", &ImGuiTestEngine::BackupConfigNoThrottle, "")
        .def(py::init<>(),
            "Functions")
        ;


    m.def("find_item_info",
        ImGuiTestEngine_FindItemInfo,
        py::arg("engine"), py::arg("id_"), py::arg("debug_id"),
        "(private API)",
        pybind11::return_value_policy::reference);

    m.def("yield_",
        ImGuiTestEngine_Yield,
        py::arg("engine"),
        "(private API)");

    m.def("set_delta_time",
        ImGuiTestEngine_SetDeltaTime,
        py::arg("engine"), py::arg("delta_time"),
        "(private API)");

    m.def("get_frame_count",
        ImGuiTestEngine_GetFrameCount,
        py::arg("engine"),
        "(private API)");

    m.def("pass_filter",
        ImGuiTestEngine_PassFilter,
        py::arg("test"), py::arg("filter"),
        "(private API)");

    m.def("reboot_ui_context",
        ImGuiTestEngine_RebootUiContext,
        py::arg("engine"),
        "(private API)");

    m.def("get_run_speed_name",
        ImGuiTestEngine_GetRunSpeedName,
        py::arg("v"),
        "(private API)",
        pybind11::return_value_policy::reference);

    m.def("get_verbose_level_name",
        ImGuiTestEngine_GetVerboseLevelName,
        py::arg("v"),
        "(private API)",
        pybind11::return_value_policy::reference);
    ////////////////////    </generated_from:imgui_te_internal.h>    ////////////////////


    ////////////////////    <generated_from:imgui_te_ui.h>    ////////////////////
    m.def("show_test_engine_windows",
        [](ImGuiTestEngine * engine, bool p_open) -> bool
        {
            auto ImGuiTestEngine_ShowTestEngineWindows_adapt_modifiable_immutable_to_return = [](ImGuiTestEngine * engine, bool p_open) -> bool
            {
                bool * p_open_adapt_modifiable = & p_open;

                ImGuiTestEngine_ShowTestEngineWindows(engine, p_open_adapt_modifiable);
                return p_open;
            };

            return ImGuiTestEngine_ShowTestEngineWindows_adapt_modifiable_immutable_to_return(engine, p_open);
        },
        py::arg("engine"), py::arg("p_open"),
        "Functions");
    ////////////////////    </generated_from:imgui_te_ui.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    py::implicitly_convertible<ImGuiID, ImGuiTestRef>();
    py::implicitly_convertible<const char*, ImGuiTestRef>();
}
