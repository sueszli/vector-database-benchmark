// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2023 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>

#include "hello_imgui/hello_imgui.h"
#include "hello_imgui/hello_imgui_screenshot.h"
#include "imgui/imgui_internal.h"
#include "imgui_test_engine/imgui_te_engine.h"
#include "imgui_test_engine/imgui_te_internal.h"

namespace py = pybind11;


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


py::array_t<uint8_t> FinalAppWindowScreenshot()
{
    auto imageBuffer = HelloImGui::FinalAppWindowScreenshotRgbBuffer();

    std::vector<std::size_t> shape{
        imageBuffer.height,
        imageBuffer.width,
        3
    };
    std::vector<std::size_t> stride{
        imageBuffer.width * 3,
        3,
        1
    };
    py::array_t<uint8_t> r(
        shape,
        stride,
        imageBuffer.bufferRgb.data());
    return r;
}


void py_init_module_hello_imgui(py::module& m)
{
    using namespace HelloImGui;
    using namespace ImGuiTheme;


    m.def("final_app_window_screenshot", FinalAppWindowScreenshot);

    m.def("get_glfw_window_address", []() {
        return (size_t) HelloImGui::GetRunnerParams()->backendPointers.glfwWindow;
    });
    m.def("get_sdl_window_address", []() {
        return (size_t) HelloImGui::GetRunnerParams()->backendPointers.sdlWindow;
    });
    m.def("get_sdl_gl_context", []() {
        return (size_t) HelloImGui::GetRunnerParams()->backendPointers.sdlGlContext;
    });


    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:hello_imgui_amalgamation.h>    ////////////////////
    auto pyClassAssetFileData =
        py::class_<HelloImGui::AssetFileData>
            (m, "AssetFileData", "*\n@@md#LoadAssetFileData\n\n* `AssetFileData LoadAssetFileData(const char *assetPath)` will load an entire asset file into memory.\n This works on all platforms, including android.\n ```cpp\n    struct AssetFileData\n    {\n        None * data = None;\n        size_t dataSize = 0;\n    };\n ```\n* `FreeAssetFileData(AssetFileData * assetFileData)` will free the memory.\n\n  Note about ImGui: \"ImGui::GetIO().Fonts->AddFontFromMemoryTTF\" takes ownership of the data\n  and will free the memory for you.\n\n@@md\n*")
        .def(py::init<>([](
        size_t dataSize = 0)
        {
            auto r = std::make_unique<AssetFileData>();
            r->dataSize = dataSize;
            return r;
        })
        , py::arg("data_size") = 0
        )
        .def_readwrite("data", &AssetFileData::data, "")
        .def_readwrite("data_size", &AssetFileData::dataSize, "")
        ;


    m.def("load_asset_file_data",
        HelloImGui::LoadAssetFileData, py::arg("asset_path"));

    m.def("free_asset_file_data",
        HelloImGui::FreeAssetFileData, py::arg("asset_file_data"));

    m.def("asset_file_full_path",
        HelloImGui::AssetFileFullPath,
        py::arg("asset_relative_filename"),
        "*\n@@md#assetFileFullPath\n\n`std::string AssetFileFullPath(const std::string& assetRelativeFilename)` will return the path to assets.\n\nThis works under all platforms __except Android__.\nFor compatibility with Android and other platforms, prefer to use `LoadAssetFileData` whenever possible.\n\n* Under iOS it will give a path in the app bundle (/private/XXX/....)\n* Under emscripten, it will be stored in the virtual filesystem at \"/\"\n* Under Android, assetFileFullPath is *not* implemented, and will throw an error:\n  assets can be compressed under android, and you cannot use standard file operations!\n  Use LoadAssetFileData instead\n\n@@md\n");

    m.def("asset_file_full_path",
        HelloImGui::assetFileFullPath, py::arg("asset_relative_filename"));

    m.def("asset_exists",
        HelloImGui::AssetExists,
        py::arg("asset_relative_filename"),
        "Returns True if this asset file exists");

    m.def("set_assets_folder",
        py::overload_cast<const char *>(HelloImGui::SetAssetsFolder), py::arg("folder"));

    m.def("set_assets_folder",
        py::overload_cast<const std::string &>(HelloImGui::SetAssetsFolder), py::arg("folder"));

    m.def("override_assets_folder",
        HelloImGui::overrideAssetsFolder,
        py::arg("folder"),
        "synonym");


    m.def("image_from_asset",
        HelloImGui::ImageFromAsset, py::arg("asset_path"), py::arg("size") = ImVec2(0, 0), py::arg("uv0") = ImVec2(0, 0), py::arg("uv1") = ImVec2(1,1), py::arg("tint_col") = ImVec4(1,1,1,1), py::arg("border_col") = ImVec4(0,0,0,0));

    m.def("image_button_from_asset",
        HelloImGui::ImageButtonFromAsset, py::arg("asset_path"), py::arg("size") = ImVec2(0, 0), py::arg("uv0") = ImVec2(0, 0), py::arg("uv1") = ImVec2(1,1), py::arg("frame_padding") = -1, py::arg("bg_col") = ImVec4(0,0,0,0), py::arg("tint_col") = ImVec4(1,1,1,1));

    m.def("im_texture_id_from_asset",
        HelloImGui::ImTextureIdFromAsset, py::arg("asset_path"));


    auto pyClassScreenBounds =
        py::class_<HelloImGui::ScreenBounds>
            (m, "ScreenBounds", "")
        .def(py::init<>([](
        ScreenPosition position = HelloImGui::DefaultScreenPosition, ScreenSize size = HelloImGui::DefaultWindowSize)
        {
            auto r = std::make_unique<ScreenBounds>();
            r->position = position;
            r->size = size;
            return r;
        })
        , py::arg("position") = HelloImGui::DefaultScreenPosition, py::arg("size") = HelloImGui::DefaultWindowSize
        )
        .def_readwrite("position", &ScreenBounds::position, "")
        .def_readwrite("size", &ScreenBounds::size, "")
        .def("top_left_corner",
            &ScreenBounds::TopLeftCorner)
        .def("bottom_right_corner",
            &ScreenBounds::BottomRightCorner)
        .def("center",
            &ScreenBounds::Center)
        .def("contains",
            &ScreenBounds::Contains, py::arg("pixel"))
        .def("win_position_centered",
            &ScreenBounds::WinPositionCentered, py::arg("window_size"))
        .def("distance_from_pixel",
            &ScreenBounds::DistanceFromPixel, py::arg("point"))
        .def("ensure_window_fits_this_monitor",
            &ScreenBounds::EnsureWindowFitsThisMonitor, py::arg("window_bounds_original"))
        .def("__eq__",
            &ScreenBounds::operator==, py::arg("other"))
        ;


    m.def("int_pair_to_string",
        HelloImGui::IntPairToString, py::arg("v"));

    m.def("string_to_int_pair",
        HelloImGui::StringToIntPair, py::arg("s"));


    py::enum_<HelloImGui::FullScreenMode>(m, "FullScreenMode", py::arithmetic(), "")
        .value("no_full_screen", HelloImGui::FullScreenMode::NoFullScreen, "")
        .value("full_screen", HelloImGui::FullScreenMode::FullScreen, "Full screen with specified resolution")
        .value("full_screen_desktop_resolution", HelloImGui::FullScreenMode::FullScreenDesktopResolution, "Full screen with current desktop mode & resolution")
        .value("full_monitor_work_area", HelloImGui::FullScreenMode::FullMonitorWorkArea, "Fake full screen, maximized window on the selected monitor");


    py::enum_<HelloImGui::WindowSizeState>(m, "WindowSizeState", py::arithmetic(), "")
        .value("standard", HelloImGui::WindowSizeState::Standard, "")
        .value("minimized", HelloImGui::WindowSizeState::Minimized, "")
        .value("maximized", HelloImGui::WindowSizeState::Maximized, "");


    py::enum_<HelloImGui::WindowPositionMode>(m, "WindowPositionMode", py::arithmetic(), "")
        .value("os_default", HelloImGui::WindowPositionMode::OsDefault, "")
        .value("monitor_center", HelloImGui::WindowPositionMode::MonitorCenter, "")
        .value("from_coords", HelloImGui::WindowPositionMode::FromCoords, "");


    py::enum_<HelloImGui::WindowSizeMeasureMode>(m, "WindowSizeMeasureMode", py::arithmetic(), "")
        .value("screen_coords", HelloImGui::WindowSizeMeasureMode::ScreenCoords, " ScreenCoords: measure window size in screen coords.\n     Note: screen coordinates *might* differ from real pixel on high dpi screens; but this depends on the OS.\n         - For example, on apple a retina screenpixel size 3456x2052 might be seen as 1728x1026 in screen\n           coordinates\n         - Under windows, and if the application is DPI aware, ScreenCoordinates correspond to real pixels,\n           even on high density screens")
        .value("relative_to96_ppi", HelloImGui::WindowSizeMeasureMode::RelativeTo96Ppi, " RelativeTo96Ppi enables to give screen size that are independant from the screen density.\n For example, a window size expressed as 800x600 will correspond to a size\n    800x600 (in screen coords) if the monitor dpi is 96\n    1600x120 (in screen coords) if the monitor dpi is 192");


    auto pyClassWindowGeometry =
        py::class_<HelloImGui::WindowGeometry>
            (m, "WindowGeometry", "*\n@@md#WindowGeometry\n\n__WindowGeometry__ is a struct that defines the window geometry.\n\nMembers:\n* `size`: _int[2], default=\"{800, 600}\"_. Size of the application window\n  used if fullScreenMode==NoFullScreen and sizeAuto==False\n* `sizeAuto`: _bool, default=false_\n  If True, adapt the app window size to the presented widgets.\n  After the first frame was displayed, HelloImGui will measure its size,\n  and the backend application window will be resized. As a consequence, the application window size may\n  vary between the first and the second frame.\n\n* `fullScreenMode`: _FullScreenMode, default=NoFullScreen_.\n   You can choose between several full screen modes:\n   ```cpp\n        NoFullScreen,\n        FullScreen,                    // Full screen with specified resolution\n        FullScreenDesktopResolution,   // Full screen with current desktop mode & resolution\n        FullMonitorWorkArea            // Fake full screen, maximized window on the selected monitor\n    ```\n* `positionMode`: _WindowPositionMode, default = OsDefault_.\n   You can choose between several window position modes:\n   ```cpp\n        OsDefault,\n        MonitorCenter,\n        FromCoords,\n    ```\n* `monitorIdx`: _int, default = 0_.\n  used if positionMode==MonitorCenter or if fullScreenMode!=NoFullScreen\n* `windowSizeState`: _WindowSizeState, default=Standard_\n   You can choose between several window size states:\n   ```cpp\n        Standard,\n        Minimized,\n        Maximized\n    ```\n* `windowSizeMeasureMode`: _WindowSizeMeasureMode_, default=RelativeTo96Ppi\n  how the window size is specified:\n  * RelativeTo96Ppi enables to give screen size that are independant from the screen density.\n     For example, a window size expressed as 800x600 will correspond to a size\n        - 800x600 (in screen coords) if the monitor dpi is 96\n        - 1600x120 (in screen coords) if the monitor dpi is 192\n      (this works with Glfw. With SDL, it only works under windows)\n  * ScreenCoords: measure window size in screen coords\n    (Note: screen coordinates might differ from real pixels on high dpi screen)\n\n* `resizeAppWindowAtNextFrame`: _bool_, default=False;\n  If you set this to flag to True at any point during the execution, the application window\n  will then try to resize based on its content on the next displayed frame,\n  and this flag will subsequently be set to False.\n  Example:\n  ```cpp\n  // Will resize the app window at next displayed frame\n  HelloImGui::GetRunnerParams()->appWindowParams.windowGeometry.resizeAppWindowAtNextFrame = True;\n  ```\n\n  :::Note: this flag is intended to be used during execution, not at startup (use sizeAuto at startup):::\n@@md\n*")
        .def(py::init<>([](
        ScreenSize size = HelloImGui::DefaultWindowSize, bool sizeAuto = false, HelloImGui::FullScreenMode fullScreenMode = HelloImGui::FullScreenMode::NoFullScreen, HelloImGui::WindowPositionMode positionMode = HelloImGui::WindowPositionMode::OsDefault, ScreenPosition position = HelloImGui::DefaultScreenPosition, int monitorIdx = 0, HelloImGui::WindowSizeState windowSizeState = HelloImGui::WindowSizeState::Standard, HelloImGui::WindowSizeMeasureMode windowSizeMeasureMode = HelloImGui::WindowSizeMeasureMode::RelativeTo96Ppi, bool resizeAppWindowAtNextFrame = false)
        {
            auto r = std::make_unique<WindowGeometry>();
            r->size = size;
            r->sizeAuto = sizeAuto;
            r->fullScreenMode = fullScreenMode;
            r->positionMode = positionMode;
            r->position = position;
            r->monitorIdx = monitorIdx;
            r->windowSizeState = windowSizeState;
            r->windowSizeMeasureMode = windowSizeMeasureMode;
            r->resizeAppWindowAtNextFrame = resizeAppWindowAtNextFrame;
            return r;
        })
        , py::arg("size") = HelloImGui::DefaultWindowSize, py::arg("size_auto") = false, py::arg("full_screen_mode") = HelloImGui::FullScreenMode::NoFullScreen, py::arg("position_mode") = HelloImGui::WindowPositionMode::OsDefault, py::arg("position") = HelloImGui::DefaultScreenPosition, py::arg("monitor_idx") = 0, py::arg("window_size_state") = HelloImGui::WindowSizeState::Standard, py::arg("window_size_measure_mode") = HelloImGui::WindowSizeMeasureMode::RelativeTo96Ppi, py::arg("resize_app_window_at_next_frame") = false
        )
        .def_readwrite("size", &WindowGeometry::size, "used if fullScreenMode==NoFullScreen and sizeAuto==False. Value=(800, 600)")
        .def_readwrite("size_auto", &WindowGeometry::sizeAuto, "If True, adapt the app window size to the presented widgets. This is done at startup")
        .def_readwrite("full_screen_mode", &WindowGeometry::fullScreenMode, "")
        .def_readwrite("position_mode", &WindowGeometry::positionMode, "")
        .def_readwrite("position", &WindowGeometry::position, "used if windowPositionMode==FromCoords, default=(40, 40)")
        .def_readwrite("monitor_idx", &WindowGeometry::monitorIdx, "used if positionMode==MonitorCenter or if fullScreenMode!=NoFullScreen")
        .def_readwrite("window_size_state", &WindowGeometry::windowSizeState, "")
        .def_readwrite("window_size_measure_mode", &WindowGeometry::windowSizeMeasureMode, "")
        .def_readwrite("resize_app_window_at_next_frame", &WindowGeometry::resizeAppWindowAtNextFrame, "If True, the application window will try to resize based on its content on the next displayed frame")
        ;


    auto pyClassAppWindowParams =
        py::class_<HelloImGui::AppWindowParams>
            (m, "AppWindowParams", "*\n@@md#AppWindowParams\n\n__AppWindowParams__ is a struct that defines the application window display params.\nSee [doc_src/hello_imgui_diagram.png](https://raw.githubusercontent.com/pthom/hello_imgui/master/src/hello_imgui/doc_src/hello_imgui_diagram.png)\nfor details.\n\nMembers:\n* `windowTitle`: _string, default=\"\"_. Title of the application window\n* `windowGeometry`: _WindowGeometry_\n  Enables to precisely set the window geometry (position, monitor, size, full screen, fake full screen, etc.)\n   _Note: on a mobile device, the application will always be full screen._\n* `restorePreviousGeometry`: _bool, default=false_.\n  If True, then save & restore windowGeometry from last run (the geometry will be written in imgui_app_window.ini)\n* `borderless`: _bool, default = false_. Should the window have borders. This is taken into account at\ncreation.\n* `resizable`: _bool, default = false_. Should the window have borders. This is taken into account at\ncreation.\n* `hidden`: _bool, default = false_. Should the window be hidden. This is taken into account dynamically (you\ncan show/hide the window with this). Full screen windows cannot be hidden.@@md\n*")
        .def(py::init<>([](
        std::string windowTitle = std::string(), WindowGeometry windowGeometry = WindowGeometry(), bool restorePreviousGeometry = false, bool borderless = false, bool resizable = true, bool hidden = false)
        {
            auto r = std::make_unique<AppWindowParams>();
            r->windowTitle = windowTitle;
            r->windowGeometry = windowGeometry;
            r->restorePreviousGeometry = restorePreviousGeometry;
            r->borderless = borderless;
            r->resizable = resizable;
            r->hidden = hidden;
            return r;
        })
        , py::arg("window_title") = std::string(), py::arg("window_geometry") = WindowGeometry(), py::arg("restore_previous_geometry") = false, py::arg("borderless") = false, py::arg("resizable") = true, py::arg("hidden") = false
        )
        .def_readwrite("window_title", &AppWindowParams::windowTitle, "")
        .def_readwrite("window_geometry", &AppWindowParams::windowGeometry, "")
        .def_readwrite("restore_previous_geometry", &AppWindowParams::restorePreviousGeometry, "if True, then save & restore from last run")
        .def_readwrite("borderless", &AppWindowParams::borderless, "")
        .def_readwrite("resizable", &AppWindowParams::resizable, "")
        .def_readwrite("hidden", &AppWindowParams::hidden, "")
        ;


    py::enum_<ImGuiTheme::ImGuiTheme_>(m, "ImGuiTheme_", py::arithmetic(), "")
        .value("imgui_colors_classic", ImGuiTheme::ImGuiTheme_ImGuiColorsClassic, "")
        .value("imgui_colors_dark", ImGuiTheme::ImGuiTheme_ImGuiColorsDark, "")
        .value("imgui_colors_light", ImGuiTheme::ImGuiTheme_ImGuiColorsLight, "")
        .value("material_flat", ImGuiTheme::ImGuiTheme_MaterialFlat, "")
        .value("photoshop_style", ImGuiTheme::ImGuiTheme_PhotoshopStyle, "")
        .value("gray_variations", ImGuiTheme::ImGuiTheme_GrayVariations, "")
        .value("gray_variations_darker", ImGuiTheme::ImGuiTheme_GrayVariations_Darker, "")
        .value("microsoft_style", ImGuiTheme::ImGuiTheme_MicrosoftStyle, "")
        .value("cherry", ImGuiTheme::ImGuiTheme_Cherry, "")
        .value("darcula", ImGuiTheme::ImGuiTheme_Darcula, "")
        .value("darcula_darker", ImGuiTheme::ImGuiTheme_DarculaDarker, "")
        .value("light_rounded", ImGuiTheme::ImGuiTheme_LightRounded, "")
        .value("so_dark_accent_blue", ImGuiTheme::ImGuiTheme_SoDark_AccentBlue, "")
        .value("so_dark_accent_yellow", ImGuiTheme::ImGuiTheme_SoDark_AccentYellow, "")
        .value("so_dark_accent_red", ImGuiTheme::ImGuiTheme_SoDark_AccentRed, "")
        .value("black_is_black", ImGuiTheme::ImGuiTheme_BlackIsBlack, "")
        .value("white_is_white", ImGuiTheme::ImGuiTheme_WhiteIsWhite, "")
        .value("count", ImGuiTheme::ImGuiTheme_Count, "");


    m.def("imgui_theme_name",
        ImGuiTheme::ImGuiTheme_Name,
        py::arg("theme"),
        pybind11::return_value_policy::reference);

    m.def("imgui_theme_from_name",
        ImGuiTheme::ImGuiTheme_FromName, py::arg("theme_name"));

    m.def("theme_to_style",
        ImGuiTheme::ThemeToStyle, py::arg("theme"));

    m.def("apply_theme",
        ImGuiTheme::ApplyTheme, py::arg("theme"));


    auto pyClassImGuiThemeTweaks =
        py::class_<ImGuiTheme::ImGuiThemeTweaks>
            (m, "ImGuiThemeTweaks", "")
        .def_readwrite("rounding", &ImGuiThemeTweaks::Rounding, "Common rounding for widgets. If < 0, this is ignored.")
        .def_readwrite("rounding_scrollbar_ratio", &ImGuiThemeTweaks::RoundingScrollbarRatio, "If rounding is applied, scrollbar rounding needs to be adjusted to be visually pleasing in conjunction with other widgets roundings. Only applied if Rounding > 0.)")
        .def_readwrite("alpha_multiplier", &ImGuiThemeTweaks::AlphaMultiplier, "Change the alpha that will be applied to windows, popups, etc. If < 0, this is ignored.")
        .def_readwrite("hue", &ImGuiThemeTweaks::Hue, "\n HSV Color tweaks\n\n Change the hue of all widgets (gray widgets will remain gray, since their saturation is zero). If < 0, this is ignored.")
        .def_readwrite("saturation_multiplier", &ImGuiThemeTweaks::SaturationMultiplier, "Multiply the saturation of all widgets (gray widgets will remain gray, since their saturation is zero). If < 0, this is ignored.")
        .def_readwrite("value_multiplier_front", &ImGuiThemeTweaks::ValueMultiplierFront, "Multiply the value (luminance) of all front widgets. If < 0, this is ignored.")
        .def_readwrite("value_multiplier_bg", &ImGuiThemeTweaks::ValueMultiplierBg, "Multiply the value (luminance) of all backgrounds. If < 0, this is ignored.")
        .def_readwrite("value_multiplier_text", &ImGuiThemeTweaks::ValueMultiplierText, "Multiply the value (luminance) of text. If < 0, this is ignored.")
        .def_readwrite("value_multiplier_frame_bg", &ImGuiThemeTweaks::ValueMultiplierFrameBg, " Multiply the value (luminance) of FrameBg. If < 0, this is ignored.\n (Background of checkbox, radio button, plot, slider, text input)")
        .def(py::init<>())
        ;


    auto pyClassImGuiTweakedTheme =
        py::class_<ImGuiTheme::ImGuiTweakedTheme>
            (m, "ImGuiTweakedTheme", "")
        .def(py::init<>([](
        ImGuiTheme::ImGuiTheme_ Theme = ImGuiTheme::ImGuiTheme_DarculaDarker, ImGuiThemeTweaks Tweaks = ImGuiThemeTweaks())
        {
            auto r = std::make_unique<ImGuiTweakedTheme>();
            r->Theme = Theme;
            r->Tweaks = Tweaks;
            return r;
        })
        , py::arg("theme") = ImGuiTheme::ImGuiTheme_DarculaDarker, py::arg("tweaks") = ImGuiThemeTweaks()
        )
        .def_readwrite("theme", &ImGuiTweakedTheme::Theme, "")
        .def_readwrite("tweaks", &ImGuiTweakedTheme::Tweaks, "")
        ;


    m.def("tweaked_theme_theme_to_style",
        ImGuiTheme::TweakedThemeThemeToStyle, py::arg("tweaked_theme"));

    m.def("apply_tweaked_theme",
        ImGuiTheme::ApplyTweakedTheme, py::arg("tweaked_theme"));

    m.def("show_theme_tweak_gui",
        ImGuiTheme::ShowThemeTweakGui,
        py::arg("tweaked_theme"),
        "Show the theme selection listbox, the theme tweak widgets, as well as ImGui::ShowStyleEditor. Returns True if modified (Warning, when using ShowStyleEditor, no info about modification is transmitted)");

    m.def("so_dark",
        ImGuiTheme::SoDark, py::arg("hue"));

    m.def("shades_of_gray",
        ImGuiTheme::ShadesOfGray, py::arg("rounding") = 0.f, py::arg("value_multiplier_front") = 1.f, py::arg("value_multiplier_bg") = 1.f);

    m.def("darcula",
        ImGuiTheme::Darcula, py::arg("rounding") = 1.f, py::arg("hue") = -1.f, py::arg("saturation_multiplier") = 1.f, py::arg("value_multiplier_front") = 1.f, py::arg("value_multiplier_bg") = 1.f, py::arg("alpha_bg_transparency") = 1.f);


    py::enum_<HelloImGui::DefaultImGuiWindowType>(m, "DefaultImGuiWindowType", py::arithmetic(), "*\n@@md#DefaultImGuiWindowType\n\n__DefaultImGuiWindowType__ is an enum class that defines whether or not a full screen background window is provided.\n\n Values:\n  * _ProvideFullScreenWindow_: a full window is provided in the background\n  * _ProvideFullScreenDockSpace_: a full screen dockspace is provided in the background\n  * _NoDefaultWindow_: No default window is provided (except for ImGui's default \"debug\" window)\n\n@@md\n")
        .value("provide_full_screen_window", HelloImGui::DefaultImGuiWindowType::ProvideFullScreenWindow, "")
        .value("provide_full_screen_dock_space", HelloImGui::DefaultImGuiWindowType::ProvideFullScreenDockSpace, "")
        .value("no_default_window", HelloImGui::DefaultImGuiWindowType::NoDefaultWindow, "");


    auto pyClassImGuiWindowParams =
        py::class_<HelloImGui::ImGuiWindowParams>
            (m, "ImGuiWindowParams", "*\n@@md#ImGuiWindowParams\n\n__ImGuiWindowParams__ is a struct that defines the ImGui inner windows params\nThese settings affect the imgui inner windows inside the application window.\nIn order to change the application window settings, change the _AppWindowsParams_\n\n Members:\n\n  * `defaultImGuiWindowType`: _DefaultImGuiWindowType, default=ProvideFullScreenWindow_.\n      By default, a full window is provided in the background. You can still\n      add windows on top of it, since the Z-order of this background window is always behind\n\n  * `backgroundColor`: _ImVec4, default=ImVec4(0.45, 0.55, 0.60, 1.00)_.\n      This is the \"clearColor\", only visible is defaultImGuiWindowType is NoDefaultWindow.\n\n  * `showMenuBar`: _bool, default=false_.\n    Show Menu bar on top of imgui main window\n    You can customize the menu via `RunnerCallbacks.ShowMenus()`\n\n  * `showMenu_App`: _bool, default=true_.\n    If menu bar is shown, include or not the default app menu\n\n   * `showMenu_App_Quit`: _bool, default=true_.\n    Include or not a \"Quit\" item in the default app menu.\n    Set this to False if you intend to provide your own quit callback with possible user confirmation\n    (and implement it inside RunnerCallbacks.ShowAppMenuItems)\n\n  * `showMenu_View`: _bool, default=true_.\n    If menu bar is shown, include or not the default _View_ menu, that enables to change the layout and\n    set the docked windows and status bar visibility)\n\n  * `showStatusBar`: _bool, default=false_.\n    Flag that enable to show a Status bar at the bottom. You can customize the status bar\n    via RunnerCallbacks.ShowStatus()\n  * `showStatus_Fps`: _bool, default=true_. If set, display the FPS in the status bar.\n  * `rememberStatusBarSettings`: _bool, default=true_. If set, showStatusBar and showStatus_Fps are stored in the application settings.\n\n  * `configWindowsMoveFromTitleBarOnly`: _bool, default=true_.\n    Make windows only movable from the title bar\n\n  * `enableViewports`: _bool, default=false_. Enable multiple viewports (i.e multiple native windows)\n    If True, you can drag windows outside out the main window in order to put their content into new native windows.\n\n   * `menuAppTitle`: _string, default=\"\"_. Set the title of the App menu. If empty, this menu name will use\n     the \"windowTitle\" from AppWindowParams\n\n  * `tweakedTheme`: _ImGuiTheme::ImGuiTweakedTheme_.\n    Change the ImGui theme. Several themes are available, you can query the list by calling\n    HelloImGui::AvailableThemes()\n  * `showMenu_View_Themes`: _bool, default=true_.\n    Show theme selection in view menu\n  * `rememberTheme`: _bool, default=true_.\n    Remember selected theme\n@@md\n")
        .def(py::init<>([](
        HelloImGui::DefaultImGuiWindowType defaultImGuiWindowType = HelloImGui::DefaultImGuiWindowType::ProvideFullScreenWindow, ImVec4 backgroundColor = ImVec4(0.45f, 0.55f, 0.60f, 1.00f), bool showMenuBar = false, bool showMenu_App = true, bool showMenu_App_Quit = true, bool showMenu_View = true, bool showStatusBar = false, bool showStatus_Fps = true, bool rememberStatusBarSettings = true, bool configWindowsMoveFromTitleBarOnly = true, bool enableViewports = false, std::string menuAppTitle = "", ImGuiTheme::ImGuiTweakedTheme tweakedTheme = ImGuiTheme::ImGuiTweakedTheme(), bool showMenu_View_Themes = true, bool rememberTheme = true)
        {
            auto r = std::make_unique<ImGuiWindowParams>();
            r->defaultImGuiWindowType = defaultImGuiWindowType;
            r->backgroundColor = backgroundColor;
            r->showMenuBar = showMenuBar;
            r->showMenu_App = showMenu_App;
            r->showMenu_App_Quit = showMenu_App_Quit;
            r->showMenu_View = showMenu_View;
            r->showStatusBar = showStatusBar;
            r->showStatus_Fps = showStatus_Fps;
            r->rememberStatusBarSettings = rememberStatusBarSettings;
            r->configWindowsMoveFromTitleBarOnly = configWindowsMoveFromTitleBarOnly;
            r->enableViewports = enableViewports;
            r->menuAppTitle = menuAppTitle;
            r->tweakedTheme = tweakedTheme;
            r->showMenu_View_Themes = showMenu_View_Themes;
            r->rememberTheme = rememberTheme;
            return r;
        })
        , py::arg("default_imgui_window_type") = HelloImGui::DefaultImGuiWindowType::ProvideFullScreenWindow, py::arg("background_color") = ImVec4(0.45f, 0.55f, 0.60f, 1.00f), py::arg("show_menu_bar") = false, py::arg("show_menu_app") = true, py::arg("show_menu_app_quit") = true, py::arg("show_menu_view") = true, py::arg("show_status_bar") = false, py::arg("show_status_fps") = true, py::arg("remember_status_bar_settings") = true, py::arg("config_windows_move_from_title_bar_only") = true, py::arg("enable_viewports") = false, py::arg("menu_app_title") = "", py::arg("tweaked_theme") = ImGuiTheme::ImGuiTweakedTheme(), py::arg("show_menu_view_themes") = true, py::arg("remember_theme") = true
        )
        .def_readwrite("default_imgui_window_type", &ImGuiWindowParams::defaultImGuiWindowType, "")
        .def_readwrite("background_color", &ImGuiWindowParams::backgroundColor, "")
        .def_readwrite("show_menu_bar", &ImGuiWindowParams::showMenuBar, "")
        .def_readwrite("show_menu_app", &ImGuiWindowParams::showMenu_App, "")
        .def_readwrite("show_menu_app_quit", &ImGuiWindowParams::showMenu_App_Quit, "")
        .def_readwrite("show_menu_view", &ImGuiWindowParams::showMenu_View, "")
        .def_readwrite("show_status_bar", &ImGuiWindowParams::showStatusBar, "")
        .def_readwrite("show_status_fps", &ImGuiWindowParams::showStatus_Fps, "")
        .def_readwrite("remember_status_bar_settings", &ImGuiWindowParams::rememberStatusBarSettings, "")
        .def_readwrite("config_windows_move_from_title_bar_only", &ImGuiWindowParams::configWindowsMoveFromTitleBarOnly, "")
        .def_readwrite("enable_viewports", &ImGuiWindowParams::enableViewports, "")
        .def_readwrite("menu_app_title", &ImGuiWindowParams::menuAppTitle, "")
        .def_readwrite("tweaked_theme", &ImGuiWindowParams::tweakedTheme, "")
        .def_readwrite("show_menu_view_themes", &ImGuiWindowParams::showMenu_View_Themes, "")
        .def_readwrite("remember_theme", &ImGuiWindowParams::rememberTheme, "")
        ;


    m.def("append_callback",
        HelloImGui::AppendCallback, py::arg("previous_callback"), py::arg("new_callback"));

    m.def("empty_void_function",
        HelloImGui::EmptyVoidFunction);

    m.def("empty_event_callback",
        HelloImGui::EmptyEventCallback);


    m.def("load_font_ttf",
        HelloImGui::LoadFontTTF,
        py::arg("font_filename"), py::arg("font_size"), py::arg("use_full_glyph_range") = false, py::arg("config") = ImFontConfig(),
        pybind11::return_value_policy::reference);

    m.def("load_font_ttf_with_font_awesome_icons",
        HelloImGui::LoadFontTTF_WithFontAwesomeIcons,
        py::arg("font_filename"), py::arg("font_size"), py::arg("use_full_glyph_range") = false, py::arg("config_font") = ImFontConfig(), py::arg("config_icons") = ImFontConfig(),
        pybind11::return_value_policy::reference);

    m.def("merge_font_awesome_to_last_font",
        HelloImGui::MergeFontAwesomeToLastFont,
        py::arg("font_size"), py::arg("config") = ImFontConfig(),
        pybind11::return_value_policy::reference);


    auto pyClassMobileCallbacks =
        py::class_<HelloImGui::MobileCallbacks>
            (m, "MobileCallbacks", "*\n@@md#MobileCallbacks\n\n**MobileCallbacks** is a struct that contains callbacks that are called by the application\n when running under \"Android, iOS and WinRT\".\n These events are specific to mobile and embedded devices that have different requirements\n than your usual desktop application. These events must be handled quickly,\n since often the OS needs an immediate response and will terminate your process shortly\n after sending the event if you do not handle them apprpriately.\n\n Note: on mobile devices, it is not possible to \"Quit\" an application, it can only be put on Pause.\n\n * `OnDestroy`: _VoidFunction, default=empty_. The application is being terminated by the OS.\n * `OnLowMemory`: _VoidFunction, default=empty_. The application is low on memory, free memory if possible.\n * `OnPause`: _VoidFunction, default=empty_. The application is about to enter the background.\n * `OnResume`: _VoidFunction, default=empty_. The application is has come to foreground and is now interactive.\n\n Note: 'OnPause' and 'OnResume' are called twice consecutively under iOS (before and after entering background\n or foreground).\n\n@@md\n")
        .def(py::init<>([](
        VoidFunction OnDestroy = HelloImGui::EmptyVoidFunction(), VoidFunction OnLowMemory = HelloImGui::EmptyVoidFunction(), VoidFunction OnPause = HelloImGui::EmptyVoidFunction(), VoidFunction OnResume = HelloImGui::EmptyVoidFunction())
        {
            auto r = std::make_unique<MobileCallbacks>();
            r->OnDestroy = OnDestroy;
            r->OnLowMemory = OnLowMemory;
            r->OnPause = OnPause;
            r->OnResume = OnResume;
            return r;
        })
        , py::arg("on_destroy") = HelloImGui::EmptyVoidFunction(), py::arg("on_low_memory") = HelloImGui::EmptyVoidFunction(), py::arg("on_pause") = HelloImGui::EmptyVoidFunction(), py::arg("on_resume") = HelloImGui::EmptyVoidFunction()
        )
        .def_readwrite("on_destroy", &MobileCallbacks::OnDestroy, "")
        .def_readwrite("on_low_memory", &MobileCallbacks::OnLowMemory, "")
        .def_readwrite("on_pause", &MobileCallbacks::OnPause, "")
        .def_readwrite("on_resume", &MobileCallbacks::OnResume, "")
        ;


    auto pyClassRunnerCallbacks =
        py::class_<HelloImGui::RunnerCallbacks>
            (m, "RunnerCallbacks", "*\n @@md#RunnerCallbacks\n\n **RunnerCallbacks** is a struct that contains the callbacks that are called by the application\n\n _Members_\n\n* `ShowGui`: *VoidFunction, default=empty*.\n  Fill it with a function that will add your widgets.\n\n* `ShowMenus`: *VoidFunction, default=empty*.\n    A function that will render your menus. Fill it with a function that will add ImGui menus by calling:\n    _ImGui::BeginMenu(...) / ImGui::MenuItem(...) / ImGui::EndMenu()_\n\n    _Notes:_\n    * you do not need to call _ImGui::BeginMenuBar_ and _ImGui::EndMenuBar_\n    * Some default menus can be provided: see _ImGuiWindowParams_ options\n      (_showMenuBar, showMenu_App_QuitAbout, showMenu_View_)\n\n* `ShowAppMenuItems`: *VoidFunction, default=empty*.\n  A function that will render items that will be placed in the App menu.\n  They will be placed before the \"Quit\" MenuItem, which is added automatically by HelloImGui.\n  This will be displayed only if ImGuiWindowParams.showMenu_App is True\n\n* `ShowStatus`: *VoidFunction, default=empty*.\n  A function that will add items to the status bar. Use small items (ImGui::Text for example),\n  since the height of the status is 30. Also, remember to call ImGui::SameLine() between items.\n\n* `PostInit`: *VoidFunction, default=empty*.\n    You can here add a function that will be called once after OpenGL and ImGui are inited, but before\n    the backend callback are initialized.\n    If you, for instance, want to add your own glfw callbacks, you should use this function to do so.\"\n\n* `BeforeExit`: *VoidFunction, default=empty*.\n    You can here add a function that will be called once before exiting (when OpenGL and ImGui are\n    still inited)\n\n* `BeforeExit_PostCleanup`: *VoidFunction, default=empty*.\n    You can here add a function that will be called once before exiting (after OpenGL and ImGui have been deinited)\n\n* `PreNewFrame`: *VoidFunction, default=empty*.\n    You can here add a function that will be called at each frame, and before the call to ImGui::NewFrame().\n    It is a good place to dynamically add new fonts, or dynamically add new dockable windows.\n\n* `BeforeImGuiRender`: *VoidFunction, default=empty*.\n    You can here add a function that will be called at each frame, after the user Gui code,\n    and just before the call to ImGui::Render() (which will also call ImGui::EndFrame()).\n\n* `AfterSwap`: *VoidFunction, default=empty*.\n    You can here add a function that will be called at each frame, after the Gui was rendered\n    and swapped to the screen.\n\n* `AnyBackendEventCallback`: *AnyBackendCallback, default=empty*.\n  Callbacks for events from a specific backend. _Only implemented for SDL, where the event\n  will be of type 'SDL_Event *'_\n  This callback should return True if the event was handled and shall not be processed further.\n  Note: in the case of GLFW, you should use register them in `PostInit`\n\n* `LoadAdditionalFonts`: *VoidFunction, default=_LoadDefaultFont_WithFontAwesome*.\n   A function that is called once, when fonts are ready to be loaded.\n   By default, _LoadDefaultFont_WithFontAwesome_ is called but you can copy and customize it.\n   (LoadDefaultFont_WithFontAwesome will load from assets/fonts/ but reverts to the ImGui embedded font if not found)\n\n* `SetupImGuiConfig`: *VoidFunction, default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.\n    If needed, change ImGui config via SetupImGuiConfig (enable docking, gamepad, etc)\n\n* `SetupImGuiStyle`: *VoidFunction, default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.\n    If needed, setup your own style by providing your own SetupImGuiStyle callback\n\n* `RegisterTests`: *VoidFunction, default=empty*.\n   A function that is called once ImGuiTestEngine is ready to be filled with tests and automations definitions.\n\n* `mobileCallbacks`: *_MobileCallbacks_*. Callbacks that are called by the application\n    when running under \"Android, iOS and WinRT\".\nNotes:\n  * 'mobileCallbacks' is present only if the target device is a mobile device (iOS, Android).\n     Use `#ifdef HELLOIMGUI_MOBILEDEVICE` to detect this.\n  * These events are currently handled only with SDL backend.\n\n@@md\n")
        .def(py::init<>([](
        VoidFunction ShowGui = HelloImGui::EmptyVoidFunction(), VoidFunction ShowMenus = HelloImGui::EmptyVoidFunction(), VoidFunction ShowAppMenuItems = HelloImGui::EmptyVoidFunction(), VoidFunction ShowStatus = HelloImGui::EmptyVoidFunction(), VoidFunction PostInit = HelloImGui::EmptyVoidFunction(), VoidFunction BeforeExit = HelloImGui::EmptyVoidFunction(), VoidFunction BeforeExit_PostCleanup = HelloImGui::EmptyVoidFunction(), VoidFunction PreNewFrame = HelloImGui::EmptyVoidFunction(), VoidFunction BeforeImGuiRender = HelloImGui::EmptyVoidFunction(), VoidFunction AfterSwap = HelloImGui::EmptyVoidFunction(), AnyEventCallback AnyBackendEventCallback = HelloImGui::EmptyEventCallback(), VoidFunction LoadAdditionalFonts = (VoidFunction)(ImGuiDefaultSettings::LoadDefaultFont_WithFontAwesomeIcons), VoidFunction SetupImGuiConfig = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiConfig), VoidFunction SetupImGuiStyle = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiStyle), VoidFunction RegisterTests = HelloImGui::EmptyVoidFunction())
        {
            auto r = std::make_unique<RunnerCallbacks>();
            r->ShowGui = ShowGui;
            r->ShowMenus = ShowMenus;
            r->ShowAppMenuItems = ShowAppMenuItems;
            r->ShowStatus = ShowStatus;
            r->PostInit = PostInit;
            r->BeforeExit = BeforeExit;
            r->BeforeExit_PostCleanup = BeforeExit_PostCleanup;
            r->PreNewFrame = PreNewFrame;
            r->BeforeImGuiRender = BeforeImGuiRender;
            r->AfterSwap = AfterSwap;
            r->AnyBackendEventCallback = AnyBackendEventCallback;
            r->LoadAdditionalFonts = LoadAdditionalFonts;
            r->SetupImGuiConfig = SetupImGuiConfig;
            r->SetupImGuiStyle = SetupImGuiStyle;
            r->RegisterTests = RegisterTests;
            return r;
        })
        , py::arg("show_gui") = HelloImGui::EmptyVoidFunction(), py::arg("show_menus") = HelloImGui::EmptyVoidFunction(), py::arg("show_app_menu_items") = HelloImGui::EmptyVoidFunction(), py::arg("show_status") = HelloImGui::EmptyVoidFunction(), py::arg("post_init") = HelloImGui::EmptyVoidFunction(), py::arg("before_exit") = HelloImGui::EmptyVoidFunction(), py::arg("before_exit_post_cleanup") = HelloImGui::EmptyVoidFunction(), py::arg("pre_new_frame") = HelloImGui::EmptyVoidFunction(), py::arg("before_imgui_render") = HelloImGui::EmptyVoidFunction(), py::arg("after_swap") = HelloImGui::EmptyVoidFunction(), py::arg("any_backend_event_callback") = HelloImGui::EmptyEventCallback(), py::arg("load_additional_fonts") = (VoidFunction)(ImGuiDefaultSettings::LoadDefaultFont_WithFontAwesomeIcons), py::arg("setup_imgui_config") = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiConfig), py::arg("setup_imgui_style") = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiStyle), py::arg("register_tests") = HelloImGui::EmptyVoidFunction()
        )
        .def_readwrite("show_gui", &RunnerCallbacks::ShowGui, "")
        .def_readwrite("show_menus", &RunnerCallbacks::ShowMenus, "")
        .def_readwrite("show_app_menu_items", &RunnerCallbacks::ShowAppMenuItems, "")
        .def_readwrite("show_status", &RunnerCallbacks::ShowStatus, "")
        .def_readwrite("post_init", &RunnerCallbacks::PostInit, "")
        .def_readwrite("before_exit", &RunnerCallbacks::BeforeExit, "")
        .def_readwrite("before_exit_post_cleanup", &RunnerCallbacks::BeforeExit_PostCleanup, "")
        .def_readwrite("pre_new_frame", &RunnerCallbacks::PreNewFrame, "")
        .def_readwrite("before_imgui_render", &RunnerCallbacks::BeforeImGuiRender, "")
        .def_readwrite("after_swap", &RunnerCallbacks::AfterSwap, "")
        .def_readwrite("any_backend_event_callback", &RunnerCallbacks::AnyBackendEventCallback, "")
        .def_readwrite("load_additional_fonts", &RunnerCallbacks::LoadAdditionalFonts, "")
        .def_readwrite("setup_imgui_config", &RunnerCallbacks::SetupImGuiConfig, "")
        .def_readwrite("setup_imgui_style", &RunnerCallbacks::SetupImGuiStyle, "")
        .def_readwrite("register_tests", &RunnerCallbacks::RegisterTests, "")
        ;


    auto pyClassDockingSplit =
        py::class_<HelloImGui::DockingSplit>
            (m, "DockingSplit", "*\n@@md#DockingSplit\n\n**DockingSplit** is a struct that defines the way the docking splits should be applied on the screen\nin order to create new Dock Spaces. _DockingParams_ contains a _vector[DockingSplit]_,\nin order to partition the screen at your will.\n\n_Members:_\n\n* `initialDock`: _DockSpaceName (aka string)_\n\n    id of the space that should be split.\n    At the start, there is only one Dock Space named \"MainDockSpace\".\n    You should start by partitioning this space, in order to create a new dock space.\n\n* `newDock`: _DockSpaceName (aka string)_. id of the new dock space that will be created.\n* `direction`: *ImGuiDir_ (enum with ImGuiDir_Down, ImGuiDir_Down, ImGuiDir_Left, ImGuiDir_Right)*.\nDirection where this dock space should be created.\n* `ratio`: _float, default=0.25_. Ratio of the initialDock size that should be used by the new dock space.\n* `nodeFlags`: *ImGuiDockNodeFlags_ (enum)*. Flags to apply to the new dock space (enable/disable resizing, splitting, tab bar, etc.)\n\n@@md\n")
        .def(py::init<const DockSpaceName &, const DockSpaceName &, ImGuiDir_, float, ImGuiDockNodeFlags>(),
            py::arg("initial_dock_") = "", py::arg("new_dock_") = "", py::arg("direction_") = ImGuiDir_Down, py::arg("ratio_") = 0.25f, py::arg("node_flags_") = ImGuiDockNodeFlags_None)
        .def_readwrite("initial_dock", &DockingSplit::initialDock, "")
        .def_readwrite("new_dock", &DockingSplit::newDock, "")
        .def_readwrite("direction", &DockingSplit::direction, "")
        .def_readwrite("ratio", &DockingSplit::ratio, "")
        .def_readwrite("node_flags", &DockingSplit::nodeFlags, "")
        ;


    auto pyClassDockableWindow =
        py::class_<HelloImGui::DockableWindow>
            (m, "DockableWindow", "*\n@@md#DockableWindow\n\n**DockableWindow** is a struct that represents a window that can be docked.\n\n_Members:_\n\n* `label`: _string_. Title of the window.\n* `dockSpaceName`: _DockSpaceName (aka string)_. Id of the dock space where this window\n   should initially be placed\n* `GuiFunction`: _VoidFunction_. Any function that will render this window's Gui.\n* `isVisible`: _bool, default=true_. Flag that indicates whether this window is visible or not.\n* `rememberIsVisible`: _bool, default=true_. Flag that indicates whether the window visibility should be saved in settings or not.\n* `canBeClosed`: _bool, default=true_. Flag that indicates whether the user can close this window.\n* `callBeginEnd`: _bool, default=true_. Flag that indicates whether ImGui::Begin and ImGui::End\n   calls should be added automatically (with the given \"label\"). Set to False if you want to call\n   ImGui::Begin/End yourself\n* `includeInViewMenu`: _bool, default=true_. Flag that indicates whether this window should be mentioned\n   in the view menu.\n* `imGuiWindowFlags`: _ImGuiWindowFlags, default=0_. Window flags, see enum ImGuiWindowFlags_\n* `windowSize`: _ImVec2, default=(0., 0.) (i.e let the app decide)_. Window size (unused if docked)\n* `windowSizeCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_. When to apply the window size.\n* `windowPos`: _ImVec2, default=(0., 0.) (i.e let the app decide)_. Window position (unused if docked)\n* `windowPosCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_. When to apply the window position.\n* `focusWindowAtNextFrame`: _bool, default = false_. If set to True this window will be focused at the next frame.\n\n@@md\n*")
        .def(py::init<const std::string &, const DockSpaceName &, const VoidFunction, bool, bool>(),
            py::arg("label_") = "", py::arg("dock_space_name_") = "", py::arg("gui_function_") = HelloImGui::EmptyVoidFunction(), py::arg("is_visible_") = true, py::arg("can_be_closed_") = true)
        .def_readwrite("label", &DockableWindow::label, "")
        .def_readwrite("dock_space_name", &DockableWindow::dockSpaceName, "")
        .def_readwrite("gui_function", &DockableWindow::GuiFunction, "")
        .def_readwrite("is_visible", &DockableWindow::isVisible, "")
        .def_readwrite("remember_is_visible", &DockableWindow::rememberIsVisible, "")
        .def_readwrite("can_be_closed", &DockableWindow::canBeClosed, "")
        .def_readwrite("call_begin_end", &DockableWindow::callBeginEnd, "")
        .def_readwrite("include_in_view_menu", &DockableWindow::includeInViewMenu, "")
        .def_readwrite("imgui_window_flags", &DockableWindow::imGuiWindowFlags, "")
        .def_readwrite("window_size", &DockableWindow::windowSize, "")
        .def_readwrite("window_size_condition", &DockableWindow::windowSizeCondition, "")
        .def_readwrite("window_position", &DockableWindow::windowPosition, "")
        .def_readwrite("window_position_condition", &DockableWindow::windowPositionCondition, "")
        .def_readwrite("focus_window_at_next_frame", &DockableWindow::focusWindowAtNextFrame, "")
        ;


    py::enum_<HelloImGui::DockingLayoutCondition>(m, "DockingLayoutCondition", py::arithmetic(), "")
        .value("first_use_ever", HelloImGui::DockingLayoutCondition::FirstUseEver, "")
        .value("application_start", HelloImGui::DockingLayoutCondition::ApplicationStart, "")
        .value("never", HelloImGui::DockingLayoutCondition::Never, "");


    auto pyClassDockingParams =
        py::class_<HelloImGui::DockingParams>
            (m, "DockingParams", "")
        .def(py::init<>([](
        std::vector<DockingSplit> dockingSplits = std::vector<DockingSplit>(), std::vector<DockableWindow> dockableWindows = std::vector<DockableWindow>(), std::string layoutName = "Default", HelloImGui::DockingLayoutCondition layoutCondition = HelloImGui::DockingLayoutCondition::FirstUseEver, bool layoutReset = false, ImGuiDockNodeFlags mainDockSpaceNodeFlags = ImGuiDockNodeFlags_PassthruCentralNode)
        {
            auto r = std::make_unique<DockingParams>();
            r->dockingSplits = dockingSplits;
            r->dockableWindows = dockableWindows;
            r->layoutName = layoutName;
            r->layoutCondition = layoutCondition;
            r->layoutReset = layoutReset;
            r->mainDockSpaceNodeFlags = mainDockSpaceNodeFlags;
            return r;
        })
        , py::arg("docking_splits") = std::vector<DockingSplit>(), py::arg("dockable_windows") = std::vector<DockableWindow>(), py::arg("layout_name") = "Default", py::arg("layout_condition") = HelloImGui::DockingLayoutCondition::FirstUseEver, py::arg("layout_reset") = false, py::arg("main_dock_space_node_flags") = ImGuiDockNodeFlags_PassthruCentralNode
        )
        .def_readwrite("docking_splits", &DockingParams::dockingSplits, "")
        .def_readwrite("dockable_windows", &DockingParams::dockableWindows, "")
        .def_readwrite("layout_name", &DockingParams::layoutName, "")
        .def_readwrite("layout_condition", &DockingParams::layoutCondition, "")
        .def_readwrite("layout_reset", &DockingParams::layoutReset, "")
        .def_readwrite("main_dock_space_node_flags", &DockingParams::mainDockSpaceNodeFlags, "")
        .def("dockable_window_of_name",
            &DockingParams::dockableWindowOfName,
            py::arg("name"),
            pybind11::return_value_policy::reference)
        .def("focus_dockable_window",
            &DockingParams::focusDockableWindow, py::arg("window_name"))
        .def("dock_space_id_from_name",
            &DockingParams::dockSpaceIdFromName, py::arg("dock_space_name"))
        ;


    auto pyClassBackendPointers =
        py::class_<HelloImGui::BackendPointers>
            (m, "BackendPointers", "*\n @@md#BackendPointers\n\n**BackendPointers** is a struct that contains optional pointers to the backend implementations (for SDL and GLFW).\n\nThese pointers will be filled when the application starts, and you can use them to customize\nyour application behavior using the selected backend.\n\n Members:\n* `glfwWindow`: _void *, default=nullptr_. Pointer to the main GLFW window (of type `GLFWwindow*`).\n  Only filled if the backend is GLFW.\n* `sdlWindow`: _void *, default=nullptr_. Pointer to the main SDL window (of type `SDL_Window*`).\n  Only filled if the backend is SDL (or emscripten + sdl)\n* `sdlGlContext`: _void *, default=nullptr_. Pointer to SDL's GlContext (of type `SDL_GLContext`).\n  Only filled if the backend is SDL (or emscripten + sdl)\n\n@@md\n")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("glfw_window", &BackendPointers::glfwWindow, "")
        .def_readwrite("sdl_window", &BackendPointers::sdlWindow, "")
        .def_readwrite("sdl_gl_context", &BackendPointers::sdlGlContext, "")
        ;


    py::enum_<HelloImGui::BackendType>(m, "BackendType", py::arithmetic(), "")
        .value("first_available", HelloImGui::BackendType::FirstAvailable, "")
        .value("sdl", HelloImGui::BackendType::Sdl, "")
        .value("glfw", HelloImGui::BackendType::Glfw, "")
        .value("qt", HelloImGui::BackendType::Qt, "");


    auto pyClassFpsIdling =
        py::class_<HelloImGui::FpsIdling>
            (m, "FpsIdling", "*\n @@md#FpsIdling\n\n**FpsIdling** is a struct that contains Fps Idling parameters\n\n* `fpsIdle`: _float, default=9_.\n  ImGui applications can consume a lot of CPU, since they update the screen very frequently.\n  In order to reduce the CPU usage, the FPS is reduced when no user interaction is detected.\n  This is ok most of the time but if you are displaying animated widgets (for example a live video),\n  you may want to ask for a faster refresh: either increase fpsIdle, or set it to 0 for maximum refresh speed\n  (you can change this value during the execution depending on your application refresh needs)\n* `enableIdling`: _bool, default=true_.\n  Set this to False to disable idling (this can be changed dynamically during execution)\n* `isIdling`: bool (dynamically updated during execution)\n  This bool will be updated during the application execution, and will be set to True when it is idling.\n* `rememberEnableIdling`: _bool, default=true_.\n  If True, the last value of enableIdling is restored from the settings at startup.\n@@md\n")
        .def(py::init<>([](
        float fpsIdle = 9.f, bool enableIdling = true, bool isIdling = false, bool rememberEnableIdling = true)
        {
            auto r = std::make_unique<FpsIdling>();
            r->fpsIdle = fpsIdle;
            r->enableIdling = enableIdling;
            r->isIdling = isIdling;
            r->rememberEnableIdling = rememberEnableIdling;
            return r;
        })
        , py::arg("fps_idle") = 9.f, py::arg("enable_idling") = true, py::arg("is_idling") = false, py::arg("remember_enable_idling") = true
        )
        .def_readwrite("fps_idle", &FpsIdling::fpsIdle, "")
        .def_readwrite("enable_idling", &FpsIdling::enableIdling, "")
        .def_readwrite("is_idling", &FpsIdling::isIdling, "")
        .def_readwrite("remember_enable_idling", &FpsIdling::rememberEnableIdling, "")
        ;


    auto pyClassRunnerParams =
        py::class_<HelloImGui::RunnerParams>
            (m, "RunnerParams", "*\n @@md#RunnerParams\n\n**RunnerParams** is a struct that contains all the settings and callbacks needed to run an application.\n\n Members:\n* `callbacks`: _see [runner_callbacks.h](runner_callbacks.h)_.\n   callbacks.ShowGui() will render the gui, ShowMenus() will show the menus, etc.\n* `appWindowParams`: _see [app_window_params.h](app_window_params.h)_.\n   application Window Params (position, size, title)\n* `imGuiWindowParams`: _see [imgui_window_params.h](imgui_window_params.h)_.\n   imgui window params (use docking, showMenuBar, ProvideFullScreenWindow, etc)\n* `dockingParams`: _see [docking_params.h](docking_params.h)_.\n   dockable windows content and layout\n* `alternativeDockingLayouts`: _vector<DockingParams>, default=empty_\n   List of possible additional layout for the applications. Only used in advanced cases when several layouts are available.\n* `rememberSelectedAlternativeLayout`: _bool, default=true_\n   Shall the application remember the last selected layout. Only used in advanced cases when several layouts are available.\n* `backendPointers`: _see [backend_pointers.h](backend_pointers.h)_.\n   A struct that contains optional pointers to the backend implementations. These pointers will be filled\n   when the application starts\n* `backendType`: _enum BackendType, default=BackendType::FirstAvailable_\n  Select the wanted backend type between `Sdl`, `Glfw` and `Qt`. Only useful when multiple backend are compiled\n  and available.\n* `fpsIdling`: _FpsIdling_. Idling parameters (set fpsIdling.enableIdling to False to disable Idling)\n* `useImGuiTestEngine`: _bool, default=false_.\n   Set this to True if you intend to use imgui_test_engine (please read note below)\n* `iniFilename`: _string, default = \"\"_\n  Sets the ini filename under which imgui will save its params. Path is relative to the current app working dir.\n  If empty, then the ini file name will be derived from appWindowParams.windowTitle (if both are empty, the ini filename will be imgui.ini).\n  Note: if appWindowParams.restorePreviousGeometry is True, then HelloImGui will also store the app window size and position into \"iniFilename + _appWindow.ini\"\n* `iniFilename_useAppWindowTitle`: _bool, default = true_.\n  Shall the iniFilename be derived from appWindowParams.windowTitle if empty\n* `appShallExit`: _bool, default=false_.\n   During execution, set this to True to exit the app.\n   _Note: 'appShallExit' has no effect on Mobile Devices (iOS, Android) and under emscripten, since these apps\n   shall not exit._\n* `emscripten_fps`: _int, default = 0_.\n  Set the application refresh rate (only used on emscripten: 0 stands for \"let the app or the browser decide\")\n\nNotes about the use of [Dear ImGui Test & Automation Engine](https://github.com/ocornut/imgui_test_engine):\n* HelloImGui must be compiled with the option HELLOIMGUI_WITH_TEST_ENGINE (-DHELLOIMGUI_WITH_TEST_ENGINE=ON)\n* See demo in src/hello_imgui_demos/hello_imgui_demo_test_engine.\n* imgui_test_engine is subject to a [specific license](https://github.com/ocornut/imgui_test_engine/blob/main/imgui_test_engine/LICENSE.txt)\n  (TL;DR: free for individuals, educational, open-source and small businesses uses. Paid for larger businesses.)\n\n    @@md\n")
        .def(py::init<>([](
        RunnerCallbacks callbacks = RunnerCallbacks(), AppWindowParams appWindowParams = AppWindowParams(), ImGuiWindowParams imGuiWindowParams = ImGuiWindowParams(), DockingParams dockingParams = DockingParams(), std::vector<DockingParams> alternativeDockingLayouts = std::vector<DockingParams>(), bool rememberSelectedAlternativeLayout = true, BackendPointers backendPointers = BackendPointers(), HelloImGui::BackendType backendType = HelloImGui::BackendType::FirstAvailable, FpsIdling fpsIdling = FpsIdling(), bool useImGuiTestEngine = false, std::string iniFilename = "", bool iniFilename_useAppWindowTitle = true, bool appShallExit = false, int emscripten_fps = 0)
        {
            auto r = std::make_unique<RunnerParams>();
            r->callbacks = callbacks;
            r->appWindowParams = appWindowParams;
            r->imGuiWindowParams = imGuiWindowParams;
            r->dockingParams = dockingParams;
            r->alternativeDockingLayouts = alternativeDockingLayouts;
            r->rememberSelectedAlternativeLayout = rememberSelectedAlternativeLayout;
            r->backendPointers = backendPointers;
            r->backendType = backendType;
            r->fpsIdling = fpsIdling;
            r->useImGuiTestEngine = useImGuiTestEngine;
            r->iniFilename = iniFilename;
            r->iniFilename_useAppWindowTitle = iniFilename_useAppWindowTitle;
            r->appShallExit = appShallExit;
            r->emscripten_fps = emscripten_fps;
            return r;
        })
        , py::arg("callbacks") = RunnerCallbacks(), py::arg("app_window_params") = AppWindowParams(), py::arg("imgui_window_params") = ImGuiWindowParams(), py::arg("docking_params") = DockingParams(), py::arg("alternative_docking_layouts") = std::vector<DockingParams>(), py::arg("remember_selected_alternative_layout") = true, py::arg("backend_pointers") = BackendPointers(), py::arg("backend_type") = HelloImGui::BackendType::FirstAvailable, py::arg("fps_idling") = FpsIdling(), py::arg("use_imgui_test_engine") = false, py::arg("ini_filename") = "", py::arg("ini_filename_use_app_window_title") = true, py::arg("app_shall_exit") = false, py::arg("emscripten_fps") = 0
        )
        .def_readwrite("callbacks", &RunnerParams::callbacks, "")
        .def_readwrite("app_window_params", &RunnerParams::appWindowParams, "")
        .def_readwrite("imgui_window_params", &RunnerParams::imGuiWindowParams, "")
        .def_readwrite("docking_params", &RunnerParams::dockingParams, "")
        .def_readwrite("alternative_docking_layouts", &RunnerParams::alternativeDockingLayouts, "")
        .def_readwrite("remember_selected_alternative_layout", &RunnerParams::rememberSelectedAlternativeLayout, "")
        .def_readwrite("backend_pointers", &RunnerParams::backendPointers, "")
        .def_readwrite("backend_type", &RunnerParams::backendType, "")
        .def_readwrite("fps_idling", &RunnerParams::fpsIdling, "")
        .def_readwrite("use_imgui_test_engine", &RunnerParams::useImGuiTestEngine, "")
        .def_readwrite("ini_filename", &RunnerParams::iniFilename, "")
        .def_readwrite("ini_filename_use_app_window_title", &RunnerParams::iniFilename_useAppWindowTitle, "")
        .def_readwrite("app_shall_exit", &RunnerParams::appShallExit, "")
        .def_readwrite("emscripten_fps", &RunnerParams::emscripten_fps, "")
        ;


    auto pyClassSimpleRunnerParams =
        py::class_<HelloImGui::SimpleRunnerParams>
            (m, "SimpleRunnerParams", "*\n @@md#SimpleRunnerParams\n\n**SimpleRunnerParams** is a struct that contains simpler params adapted for simple use cases.\n\n Members:\n* `guiFunction`: _VoidFunction_.\n   Function that renders the Gui.\n* `windowTitle`: _string, default=\"\"_.\n   Title of the application window\n* `windowSizeAuto`: _bool, default=false_.\n   If True, the size of the window will be computed from its widgets.\n* `windowRestorePreviousGeometry`: _bool, default=true_.\n   If True, restore the size and position of the window between runs.\n* `windowSize`: _ScreenSize, default={800, 600}_.\n   Size of the window\n* `fpsIdle`: _float, default=9_.\n   FPS of the application when idle (set to 0 for full speed).\n\nFor example, this is sufficient to run an application:\n\n```cpp\nNone MyGui() {\n    ImGui::Text(\"Hello, world\");\n    if (ImGui::Button(\"Exit\"))\n        HelloImGui::GetRunnerParams()->appShallExit = True;\n}\n\nint main(){\n    auto params = HelloImGui::SimpleRunnerParams {.guiFunction = MyGui, .windowSizeAuto = True, .windowTitle = \"Example\"};\n    HelloImGui::Run(params);\n}\n```\n\n@@md\n")
        .def(py::init<>([](
        VoidFunction guiFunction = HelloImGui::EmptyVoidFunction(), std::string windowTitle = "", bool windowSizeAuto = false, bool windowRestorePreviousGeometry = false, ScreenSize windowSize = HelloImGui::DefaultWindowSize, float fpsIdle = 9.f, bool enableIdling = true)
        {
            auto r = std::make_unique<SimpleRunnerParams>();
            r->guiFunction = guiFunction;
            r->windowTitle = windowTitle;
            r->windowSizeAuto = windowSizeAuto;
            r->windowRestorePreviousGeometry = windowRestorePreviousGeometry;
            r->windowSize = windowSize;
            r->fpsIdle = fpsIdle;
            r->enableIdling = enableIdling;
            return r;
        })
        , py::arg("gui_function") = HelloImGui::EmptyVoidFunction(), py::arg("window_title") = "", py::arg("window_size_auto") = false, py::arg("window_restore_previous_geometry") = false, py::arg("window_size") = HelloImGui::DefaultWindowSize, py::arg("fps_idle") = 9.f, py::arg("enable_idling") = true
        )
        .def_readwrite("gui_function", &SimpleRunnerParams::guiFunction, "")
        .def_readwrite("window_title", &SimpleRunnerParams::windowTitle, "")
        .def_readwrite("window_size_auto", &SimpleRunnerParams::windowSizeAuto, "")
        .def_readwrite("window_restore_previous_geometry", &SimpleRunnerParams::windowRestorePreviousGeometry, "")
        .def_readwrite("window_size", &SimpleRunnerParams::windowSize, "")
        .def_readwrite("fps_idle", &SimpleRunnerParams::fpsIdle, "")
        .def_readwrite("enable_idling", &SimpleRunnerParams::enableIdling, "")
        .def("to_runner_params",
            &SimpleRunnerParams::ToRunnerParams)
        ;


    py::enum_<HelloImGui::LogLevel>(m, "LogLevel", py::arithmetic(), "")
        .value("debug", HelloImGui::LogLevel::Debug, "")
        .value("info", HelloImGui::LogLevel::Info, "")
        .value("warning", HelloImGui::LogLevel::Warning, "")
        .value("error", HelloImGui::LogLevel::Error, "");


    m.def("log",
        [](HelloImGui::LogLevel level, const char * const format)
        {
            auto Log_adapt_variadic_format = [](HelloImGui::LogLevel level, const char * const format)
            {
                HelloImGui::Log(level, "%s", format);
            };

            Log_adapt_variadic_format(level, format);
        },     py::arg("level"), py::arg("format"));

    m.def("log_clear",
        HelloImGui::LogClear);

    m.def("log_gui",
        HelloImGui::LogGui, py::arg("size") = ImVec2(0.f, 0.f));


    m.def("em_size",
        py::overload_cast<>(HelloImGui::EmSize), " __HelloImGui::EmSize()__ returns the visible font size on the screen. For good results on HighDPI screens, always scale your\n widgets and windows relatively to this size.\n It is somewhat comparable to the [em CSS Unit](https://lyty.dev/css/css-unit.html).\n EmSize() = ImGui::GetFontSize()");

    m.def("em_size",
        py::overload_cast<float>(HelloImGui::EmSize),
        py::arg("nb_lines"),
        "__HelloImGui::EmSize(nbLines)__ returns a size corresponding to nbLines text lines");

    m.def("em_to_vec2",
        py::overload_cast<float, float>(HelloImGui::EmToVec2), py::arg("x"), py::arg("y"));

    m.def("em_to_vec2",
        py::overload_cast<ImVec2>(HelloImGui::EmToVec2), py::arg("v"));

    m.def("dpi_font_loading_factor",
        HelloImGui::DpiFontLoadingFactor, " Multiply font sizes by this factor when loading fonts manually with ImGui::GetIO().Fonts->AddFont...\n (HelloImGui::LoadFontTTF does this by default)");

    m.def("dpi_window_size_factor",
        HelloImGui::DpiWindowSizeFactor, " DpiWindowSizeFactor() is the factor by which window size should be multiplied to get a similar visible size on different OSes.\n It returns ApplicationScreenPixelPerInch / 96  under windows and linux. Under macOS, it will return 1.");

    m.def("imgui_default_font_global_scale",
        HelloImGui::ImGuiDefaultFontGlobalScale, "returns the default value that should be stored inside `ImGui::GetIO().FontGlobalScale`");


    m.def("run",
        py::overload_cast<HelloImGui::RunnerParams &>(HelloImGui::Run),
        py::arg("runner_params"),
        "*\n@@md#HelloImGui::Run\n\n__HelloImGui::Run()__ will run an application with a single call.\n\nThree signatures are provided:\n\n* `HelloImGui::Run(RunnerParams &)`: full signature, the most customizable version.\n   Runs an application whose params and Gui are provided by runnerParams.\n\n* `HelloImGui::Run(const SimpleRunnerParams&)`:\n   Runs an application, using simpler params.\n\n* `HelloImGui::Run(guiFunction, windowTitle, windowSize, windowSizeAuto=False, restoreLastWindowGeometry=False, fpsIdle=10)`\n\n\n__Other utilities:__\n\n* `HelloImGui::GetRunnerParams()`:\n  a convenience function that will return the runnerParams of the current application\n\n* `FrameRate(durationForMean = 0.5)`: Returns the current FrameRate.\n  May differ from ImGui::GetIO().FrameRate, since one can choose the duration for the calculation of the mean value of the fps\n\n* `ImGuiTestEngine* GetImGuiTestEngine()`: returns a pointer to the global instance of ImGuiTestEngine that was\n  initialized by HelloImGui (iif ImGui Test Engine is active).\n@@md\n");

    m.def("run",
        py::overload_cast<const HelloImGui::SimpleRunnerParams &>(HelloImGui::Run), py::arg("simple_params"));

    m.def("run",
        py::overload_cast<const VoidFunction &, const std::string &, bool, bool, const ScreenSize &, float>(HelloImGui::Run), py::arg("gui_function"), py::arg("window_title") = "", py::arg("window_size_auto") = false, py::arg("window_restore_previous_geometry") = false, py::arg("window_size") = HelloImGui::DefaultWindowSize, py::arg("fps_idle") = 10.f);

    m.def("get_runner_params",
        HelloImGui::GetRunnerParams, pybind11::return_value_policy::reference);

    m.def("frame_rate",
        HelloImGui::FrameRate,
        py::arg("duration_for_mean") = 0.5f,
        " Returns the current FrameRate. May differ from ImGui::GetIO().FrameRate,\n since one can choose the duration for the calculation of the mean value of the fps\n (Will only lead to accurate values if you call it at each frame)");

    m.def("get_imgui_test_engine",
        HelloImGui::GetImGuiTestEngine, pybind11::return_value_policy::reference);

    m.def("switch_layout",
        HelloImGui::SwitchLayout, py::arg("layout_name"));

    m.def("current_layout_name",
        HelloImGui::CurrentLayoutName);

    m.def("save_user_pref",
        HelloImGui::SaveUserPref, py::arg("user_pref_name"), py::arg("user_pref_content"));

    m.def("load_user_pref",
        HelloImGui::LoadUserPref, py::arg("user_pref_name"));

    { // <namespace ImGuiDefaultSettings>
        py::module_ pyNsImGuiDefaultSettings = m.def_submodule("imgui_default_settings", "namespace ImGuiDefaultSettings");
        pyNsImGuiDefaultSettings.def("load_default_font_with_font_awesome_icons",
            HelloImGui::ImGuiDefaultSettings::LoadDefaultFont_WithFontAwesomeIcons, "LoadDefaultFont_WithFontAwesome will load from assets/fonts and reverts to the imgui embedded font if not found.");

        pyNsImGuiDefaultSettings.def("setup_default_imgui_config",
            HelloImGui::ImGuiDefaultSettings::SetupDefaultImGuiConfig);

        pyNsImGuiDefaultSettings.def("setup_default_imgui_style",
            HelloImGui::ImGuiDefaultSettings::SetupDefaultImGuiStyle);

        pyNsImGuiDefaultSettings.def("did_call_hello_imgui_load_font_ttf",
            HelloImGui::ImGuiDefaultSettings::DidCallHelloImGuiLoadFontTTF, " indicates that fonts were loaded using HelloImGui::LoadFontTTF. In that case, fonts may have been resized to\n account for HighDPI (on macOS and emscripten)");
    } // </namespace ImGuiDefaultSettings>
    ////////////////////    </generated_from:hello_imgui_amalgamation.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
