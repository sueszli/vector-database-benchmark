// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2023 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>

#include "imgui.h"
#include "implot/implot.h"
#include "implot/implot_internal.h"


namespace py = pybind11;


// this is an internal function that should only be called with a tuple, list or array argument
ImPlotPoint cast_to_point(py::handle obj)
{
    if (len(obj) != 2)
        throw std::invalid_argument("Python tuple/list/array to implot.Point: size should be 2!");
    auto floats = obj.cast<std::vector<float>>();
    return ImPlotPoint(floats[0], floats[1]);
}

///////////////////////////////////////////////////////////////////////////////
// Utilities / py::array type
///////////////////////////////////////////////////////////////////////////////
// py::array can represent several types which are identified by a character (values.dtype().char_()):
// 'B' <=> uint8
// 'b' <=> int8
// 'H' <=> uint16
// 'h' <=> int16
// 'I' <=> uint32
// 'i' <=> int32
// 'L' <=> uint64 on *nixes, uint32 on windows
// 'l' <=> int64 on *nixes, int32 on windows
// 'q' <=> long long
// ---
// 'f' <=> float
// 'd' <=> double
// 'g' <=> long double
bool is_py_array_signed_integer(char array_type_char)
{
    bool r = (array_type_char == 'b') || (array_type_char == 'h') || (array_type_char == 'i') || (array_type_char == 'l') || (array_type_char == 'q');
    return r;
}
bool is_py_array_signed_integer(const py::array& a) { return is_py_array_signed_integer(a.dtype().char_()); }

bool is_py_array_unsigned_integer(char array_type_char)
{
    bool r = (array_type_char == 'B') || (array_type_char == 'H') || (array_type_char == 'I') || (array_type_char == 'L');
    return r;
}
bool is_py_array_unsigned_integer(const py::array& a) { return is_py_array_unsigned_integer(a.dtype().char_()); }

bool is_py_array_integer(char array_type_char)
{
    bool r = is_py_array_signed_integer(array_type_char) || is_py_array_unsigned_integer(array_type_char);
    return r;
}
bool is_py_array_integer(const py::array& a) { return is_py_array_integer(a.dtype().char_()); }

bool is_py_array_floating_type(char array_type_char)
{
    bool r = (array_type_char == 'f') || (array_type_char == 'd') || (array_type_char == 'g');
    return r;
}
bool is_py_array_floating_type(const py::array& a) { return is_py_array_floating_type(a.dtype().char_()); }


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_implot(py::module& m)
{
    // py::class_<ImPlotContext>(m, "ImPlotContext", "ImPlotContext is an opaque pointer!");

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:implot.h>    ////////////////////
    py::enum_<ImAxis_>(m, "ImAxis_", py::arithmetic(), "Axis indices. The values assigned may change; NEVER hardcode these.")
        .value("x1", ImAxis_X1, "enabled by default")
        .value("x2", ImAxis_X2, "disabled by default")
        .value("x3", ImAxis_X3, "disabled by default")
        .value("y1", ImAxis_Y1, "enabled by default")
        .value("y2", ImAxis_Y2, "disabled by default")
        .value("y3", ImAxis_Y3, "disabled by default")
        .value("count", ImAxis_COUNT, "bookeeping");


    py::enum_<ImPlotFlags_>(m, "Flags_", py::arithmetic(), "Options for plots (see BeginPlot).")
        .value("none", ImPlotFlags_None, "default")
        .value("no_title", ImPlotFlags_NoTitle, "the plot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. \"##MyPlot\")")
        .value("no_legend", ImPlotFlags_NoLegend, "the legend will not be displayed")
        .value("no_mouse_text", ImPlotFlags_NoMouseText, "the mouse position, in plot coordinates, will not be displayed inside of the plot")
        .value("no_inputs", ImPlotFlags_NoInputs, "the user will not be able to interact with the plot")
        .value("no_menus", ImPlotFlags_NoMenus, "the user will not be able to open context menus")
        .value("no_box_select", ImPlotFlags_NoBoxSelect, "the user will not be able to box-select")
        .value("no_frame", ImPlotFlags_NoFrame, "the ImGui frame will not be rendered")
        .value("equal", ImPlotFlags_Equal, "x and y axes pairs will be constrained to have the same units/pixel")
        .value("crosshairs", ImPlotFlags_Crosshairs, "the default mouse cursor will be replaced with a crosshair when hovered")
        .value("canvas_only", ImPlotFlags_CanvasOnly, "");


    py::enum_<ImPlotAxisFlags_>(m, "AxisFlags_", py::arithmetic(), "Options for plot axes (see SetupAxis).")
        .value("none", ImPlotAxisFlags_None, "default")
        .value("no_label", ImPlotAxisFlags_NoLabel, "the axis label will not be displayed (axis labels are also hidden if the supplied string name is None)")
        .value("no_grid_lines", ImPlotAxisFlags_NoGridLines, "no grid lines will be displayed")
        .value("no_tick_marks", ImPlotAxisFlags_NoTickMarks, "no tick marks will be displayed")
        .value("no_tick_labels", ImPlotAxisFlags_NoTickLabels, "no text labels will be displayed")
        .value("no_initial_fit", ImPlotAxisFlags_NoInitialFit, "axis will not be initially fit to data extents on the first rendered frame")
        .value("no_menus", ImPlotAxisFlags_NoMenus, "the user will not be able to open context menus with right-click")
        .value("no_side_switch", ImPlotAxisFlags_NoSideSwitch, "the user will not be able to switch the axis side by dragging it")
        .value("no_highlight", ImPlotAxisFlags_NoHighlight, "the axis will not have its background highlighted when hovered or held")
        .value("opposite", ImPlotAxisFlags_Opposite, "axis ticks and labels will be rendered on the conventionally opposite side (i.e, right or top)")
        .value("foreground", ImPlotAxisFlags_Foreground, "grid lines will be displayed in the foreground (i.e. on top of data) instead of the background")
        .value("invert", ImPlotAxisFlags_Invert, "the axis will be inverted")
        .value("auto_fit", ImPlotAxisFlags_AutoFit, "axis will be auto-fitting to data extents")
        .value("range_fit", ImPlotAxisFlags_RangeFit, "axis will only fit points if the point is in the visible range of the **orthogonal** axis")
        .value("pan_stretch", ImPlotAxisFlags_PanStretch, "panning in a locked or constrained state will cause the axis to stretch if possible")
        .value("lock_min", ImPlotAxisFlags_LockMin, "the axis minimum value will be locked when panning/zooming")
        .value("lock_max", ImPlotAxisFlags_LockMax, "the axis maximum value will be locked when panning/zooming")
        .value("lock", ImPlotAxisFlags_Lock, "")
        .value("no_decorations", ImPlotAxisFlags_NoDecorations, "")
        .value("aux_default", ImPlotAxisFlags_AuxDefault, "");


    py::enum_<ImPlotSubplotFlags_>(m, "SubplotFlags_", py::arithmetic(), "Options for subplots (see BeginSubplot)")
        .value("none", ImPlotSubplotFlags_None, "default")
        .value("no_title", ImPlotSubplotFlags_NoTitle, "the subplot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. \"##MySubplot\")")
        .value("no_legend", ImPlotSubplotFlags_NoLegend, "the legend will not be displayed (only applicable if ImPlotSubplotFlags_ShareItems is enabled)")
        .value("no_menus", ImPlotSubplotFlags_NoMenus, "the user will not be able to open context menus with right-click")
        .value("no_resize", ImPlotSubplotFlags_NoResize, "resize splitters between subplot cells will be not be provided")
        .value("no_align", ImPlotSubplotFlags_NoAlign, "subplot edges will not be aligned vertically or horizontally")
        .value("share_items", ImPlotSubplotFlags_ShareItems, "items across all subplots will be shared and rendered into a single legend entry")
        .value("link_rows", ImPlotSubplotFlags_LinkRows, "link the y-axis limits of all plots in each row (does not apply to auxiliary axes)")
        .value("link_cols", ImPlotSubplotFlags_LinkCols, "link the x-axis limits of all plots in each column (does not apply to auxiliary axes)")
        .value("link_all_x", ImPlotSubplotFlags_LinkAllX, "link the x-axis limits in every plot in the subplot (does not apply to auxiliary axes)")
        .value("link_all_y", ImPlotSubplotFlags_LinkAllY, "link the y-axis limits in every plot in the subplot (does not apply to auxiliary axes)")
        .value("col_major", ImPlotSubplotFlags_ColMajor, "subplots are added in column major order instead of the default row major order");


    py::enum_<ImPlotLegendFlags_>(m, "LegendFlags_", py::arithmetic(), "Options for legends (see SetupLegend)")
        .value("none", ImPlotLegendFlags_None, "default")
        .value("no_buttons", ImPlotLegendFlags_NoButtons, "legend icons will not function as hide/show buttons")
        .value("no_highlight_item", ImPlotLegendFlags_NoHighlightItem, "plot items will not be highlighted when their legend entry is hovered")
        .value("no_highlight_axis", ImPlotLegendFlags_NoHighlightAxis, "axes will not be highlighted when legend entries are hovered (only relevant if x/y-axis count > 1)")
        .value("no_menus", ImPlotLegendFlags_NoMenus, "the user will not be able to open context menus with right-click")
        .value("outside", ImPlotLegendFlags_Outside, "legend will be rendered outside of the plot area")
        .value("horizontal", ImPlotLegendFlags_Horizontal, "legend entries will be displayed horizontally")
        .value("sort", ImPlotLegendFlags_Sort, "legend entries will be displayed in alphabetical order");


    py::enum_<ImPlotMouseTextFlags_>(m, "MouseTextFlags_", py::arithmetic(), "Options for mouse hover text (see SetupMouseText)")
        .value("none", ImPlotMouseTextFlags_None, "default")
        .value("no_aux_axes", ImPlotMouseTextFlags_NoAuxAxes, "only show the mouse position for primary axes")
        .value("no_format", ImPlotMouseTextFlags_NoFormat, "axes label formatters won't be used to render text")
        .value("show_always", ImPlotMouseTextFlags_ShowAlways, "always display mouse position even if plot not hovered");


    py::enum_<ImPlotDragToolFlags_>(m, "DragToolFlags_", py::arithmetic(), "Options for DragPoint, DragLine, DragRect")
        .value("none", ImPlotDragToolFlags_None, "default")
        .value("no_cursors", ImPlotDragToolFlags_NoCursors, "drag tools won't change cursor icons when hovered or held")
        .value("no_fit", ImPlotDragToolFlags_NoFit, "the drag tool won't be considered for plot fits")
        .value("no_inputs", ImPlotDragToolFlags_NoInputs, "lock the tool from user inputs")
        .value("delayed", ImPlotDragToolFlags_Delayed, "tool rendering will be delayed one frame; useful when applying position-constraints");


    py::enum_<ImPlotColormapScaleFlags_>(m, "ColormapScaleFlags_", py::arithmetic(), "Flags for ColormapScale")
        .value("none", ImPlotColormapScaleFlags_None, "default")
        .value("no_label", ImPlotColormapScaleFlags_NoLabel, "the colormap axis label will not be displayed")
        .value("opposite", ImPlotColormapScaleFlags_Opposite, "render the colormap label and tick labels on the opposite side")
        .value("invert", ImPlotColormapScaleFlags_Invert, "invert the colormap bar and axis scale (this only affects rendering; if you only want to reverse the scale mapping, make scale_min > scale_max)");


    py::enum_<ImPlotItemFlags_>(m, "ItemFlags_", py::arithmetic(), "Flags for ANY PlotX function")
        .value("none", ImPlotItemFlags_None, "")
        .value("no_legend", ImPlotItemFlags_NoLegend, "the item won't have a legend entry displayed")
        .value("no_fit", ImPlotItemFlags_NoFit, "the item won't be considered for plot fits");


    py::enum_<ImPlotLineFlags_>(m, "LineFlags_", py::arithmetic(), "Flags for PlotLine")
        .value("none", ImPlotLineFlags_None, "default")
        .value("segments", ImPlotLineFlags_Segments, "a line segment will be rendered from every two consecutive points")
        .value("loop", ImPlotLineFlags_Loop, "the last and first point will be connected to form a closed loop")
        .value("skip_na_n", ImPlotLineFlags_SkipNaN, "NaNs values will be skipped instead of rendered as missing data")
        .value("no_clip", ImPlotLineFlags_NoClip, "markers (if displayed) on the edge of a plot will not be clipped")
        .value("shaded", ImPlotLineFlags_Shaded, "a filled region between the line and horizontal origin will be rendered; use PlotShaded for more advanced cases");


    py::enum_<ImPlotScatterFlags_>(m, "ScatterFlags_", py::arithmetic(), "Flags for PlotScatter")
        .value("none", ImPlotScatterFlags_None, "default")
        .value("no_clip", ImPlotScatterFlags_NoClip, "markers on the edge of a plot will not be clipped");


    py::enum_<ImPlotStairsFlags_>(m, "StairsFlags_", py::arithmetic(), "Flags for PlotStairs")
        .value("none", ImPlotStairsFlags_None, "default")
        .value("pre_step", ImPlotStairsFlags_PreStep, "the y value is continued constantly to the left from every x position, i.e. the interval (x[i-1], x[i]] has the value y[i]")
        .value("shaded", ImPlotStairsFlags_Shaded, "a filled region between the stairs and horizontal origin will be rendered; use PlotShaded for more advanced cases");


    py::enum_<ImPlotShadedFlags_>(m, "ShadedFlags_", py::arithmetic(), "Flags for PlotShaded (placeholder)")
        .value("none", ImPlotShadedFlags_None, "default");


    py::enum_<ImPlotBarsFlags_>(m, "BarsFlags_", py::arithmetic(), "Flags for PlotBars")
        .value("none", ImPlotBarsFlags_None, "default")
        .value("horizontal", ImPlotBarsFlags_Horizontal, "bars will be rendered horizontally on the current y-axis");


    py::enum_<ImPlotBarGroupsFlags_>(m, "BarGroupsFlags_", py::arithmetic(), "Flags for PlotBarGroups")
        .value("none", ImPlotBarGroupsFlags_None, "default")
        .value("horizontal", ImPlotBarGroupsFlags_Horizontal, "bar groups will be rendered horizontally on the current y-axis")
        .value("stacked", ImPlotBarGroupsFlags_Stacked, "items in a group will be stacked on top of each other");


    py::enum_<ImPlotErrorBarsFlags_>(m, "ErrorBarsFlags_", py::arithmetic(), "Flags for PlotErrorBars")
        .value("none", ImPlotErrorBarsFlags_None, "default")
        .value("horizontal", ImPlotErrorBarsFlags_Horizontal, "error bars will be rendered horizontally on the current y-axis");


    py::enum_<ImPlotStemsFlags_>(m, "StemsFlags_", py::arithmetic(), "Flags for PlotStems")
        .value("none", ImPlotStemsFlags_None, "default")
        .value("horizontal", ImPlotStemsFlags_Horizontal, "stems will be rendered horizontally on the current y-axis");


    py::enum_<ImPlotInfLinesFlags_>(m, "InfLinesFlags_", py::arithmetic(), "Flags for PlotInfLines")
        .value("none", ImPlotInfLinesFlags_None, "default")
        .value("horizontal", ImPlotInfLinesFlags_Horizontal, "lines will be rendered horizontally on the current y-axis");


    py::enum_<ImPlotPieChartFlags_>(m, "PieChartFlags_", py::arithmetic(), "Flags for PlotPieChart")
        .value("none", ImPlotPieChartFlags_None, "default")
        .value("normalize", ImPlotPieChartFlags_Normalize, "force normalization of pie chart values (i.e. always make a full circle if sum < 0)")
        .value("ignore_hidden", ImPlotPieChartFlags_IgnoreHidden, "ignore hidden slices when drawing the pie chart (as if they were not there)");


    py::enum_<ImPlotHeatmapFlags_>(m, "HeatmapFlags_", py::arithmetic(), "Flags for PlotHeatmap")
        .value("none", ImPlotHeatmapFlags_None, "default")
        .value("col_major", ImPlotHeatmapFlags_ColMajor, "data will be read in column major order");


    py::enum_<ImPlotHistogramFlags_>(m, "HistogramFlags_", py::arithmetic(), "Flags for PlotHistogram and PlotHistogram2D")
        .value("none", ImPlotHistogramFlags_None, "default")
        .value("horizontal", ImPlotHistogramFlags_Horizontal, "histogram bars will be rendered horizontally (not supported by PlotHistogram2D)")
        .value("cumulative", ImPlotHistogramFlags_Cumulative, "each bin will contain its count plus the counts of all previous bins (not supported by PlotHistogram2D)")
        .value("density", ImPlotHistogramFlags_Density, "counts will be normalized, i.e. the PDF will be visualized, or the CDF will be visualized if Cumulative is also set")
        .value("no_outliers", ImPlotHistogramFlags_NoOutliers, "exclude values outside the specifed histogram range from the count toward normalizing and cumulative counts")
        .value("col_major", ImPlotHistogramFlags_ColMajor, "data will be read in column major order (not supported by PlotHistogram)");


    py::enum_<ImPlotDigitalFlags_>(m, "DigitalFlags_", py::arithmetic(), "Flags for PlotDigital (placeholder)")
        .value("none", ImPlotDigitalFlags_None, "default");


    py::enum_<ImPlotImageFlags_>(m, "ImageFlags_", py::arithmetic(), "Flags for PlotImage (placeholder)")
        .value("none", ImPlotImageFlags_None, "default");


    py::enum_<ImPlotTextFlags_>(m, "TextFlags_", py::arithmetic(), "Flags for PlotText")
        .value("none", ImPlotTextFlags_None, "default")
        .value("vertical", ImPlotTextFlags_Vertical, "text will be rendered vertically");


    py::enum_<ImPlotDummyFlags_>(m, "DummyFlags_", py::arithmetic(), "Flags for PlotDummy (placeholder)")
        .value("none", ImPlotDummyFlags_None, "default");


    py::enum_<ImPlotCond_>(m, "Cond_", py::arithmetic(), "Represents a condition for SetupAxisLimits etc. (same as ImGuiCond, but we only support a subset of those enums)")
        .value("none", ImPlotCond_None, "No condition (always set the variable), same as _Always")
        .value("always", ImPlotCond_Always, "No condition (always set the variable)")
        .value("once", ImPlotCond_Once, "Set the variable once per runtime session (only the first call will succeed)");


    py::enum_<ImPlotCol_>(m, "Col_", py::arithmetic(), "Plot styling colors.")
        .value("line", ImPlotCol_Line, "plot line/outline color (defaults to next unused color in current colormap)")
        .value("fill", ImPlotCol_Fill, "plot fill color for bars (defaults to the current line color)")
        .value("marker_outline", ImPlotCol_MarkerOutline, "marker outline color (defaults to the current line color)")
        .value("marker_fill", ImPlotCol_MarkerFill, "marker fill color (defaults to the current line color)")
        .value("error_bar", ImPlotCol_ErrorBar, "error bar color (defaults to ImGuiCol_Text)")
        .value("frame_bg", ImPlotCol_FrameBg, "plot frame background color (defaults to ImGuiCol_FrameBg)")
        .value("plot_bg", ImPlotCol_PlotBg, "plot area background color (defaults to ImGuiCol_WindowBg)")
        .value("plot_border", ImPlotCol_PlotBorder, "plot area border color (defaults to ImGuiCol_Border)")
        .value("legend_bg", ImPlotCol_LegendBg, "legend background color (defaults to ImGuiCol_PopupBg)")
        .value("legend_border", ImPlotCol_LegendBorder, "legend border color (defaults to ImPlotCol_PlotBorder)")
        .value("legend_text", ImPlotCol_LegendText, "legend text color (defaults to ImPlotCol_InlayText)")
        .value("title_text", ImPlotCol_TitleText, "plot title text color (defaults to ImGuiCol_Text)")
        .value("inlay_text", ImPlotCol_InlayText, "color of text appearing inside of plots (defaults to ImGuiCol_Text)")
        .value("axis_text", ImPlotCol_AxisText, "axis label and tick lables color (defaults to ImGuiCol_Text)")
        .value("axis_grid", ImPlotCol_AxisGrid, "axis grid color (defaults to 25% ImPlotCol_AxisText)")
        .value("axis_tick", ImPlotCol_AxisTick, "axis tick color (defaults to AxisGrid)")
        .value("axis_bg", ImPlotCol_AxisBg, "background color of axis hover region (defaults to transparent)")
        .value("axis_bg_hovered", ImPlotCol_AxisBgHovered, "axis hover color (defaults to ImGuiCol_ButtonHovered)")
        .value("axis_bg_active", ImPlotCol_AxisBgActive, "axis active color (defaults to ImGuiCol_ButtonActive)")
        .value("selection", ImPlotCol_Selection, "box-selection color (defaults to yellow)")
        .value("crosshairs", ImPlotCol_Crosshairs, "crosshairs color (defaults to ImPlotCol_PlotBorder)")
        .value("count", ImPlotCol_COUNT, "");


    py::enum_<ImPlotStyleVar_>(m, "StyleVar_", py::arithmetic(), "Plot styling variables.")
        .value("line_weight", ImPlotStyleVar_LineWeight, "float,  plot item line weight in pixels")
        .value("marker", ImPlotStyleVar_Marker, "int,    marker specification")
        .value("marker_size", ImPlotStyleVar_MarkerSize, "float,  marker size in pixels (roughly the marker's \"radius\")")
        .value("marker_weight", ImPlotStyleVar_MarkerWeight, "float,  plot outline weight of markers in pixels")
        .value("fill_alpha", ImPlotStyleVar_FillAlpha, "float,  alpha modifier applied to all plot item fills")
        .value("error_bar_size", ImPlotStyleVar_ErrorBarSize, "float,  error bar whisker width in pixels")
        .value("error_bar_weight", ImPlotStyleVar_ErrorBarWeight, "float,  error bar whisker weight in pixels")
        .value("digital_bit_height", ImPlotStyleVar_DigitalBitHeight, "float,  digital channels bit height (at 1) in pixels")
        .value("digital_bit_gap", ImPlotStyleVar_DigitalBitGap, "float,  digital channels bit padding gap in pixels")
        .value("plot_border_size", ImPlotStyleVar_PlotBorderSize, "float,  thickness of border around plot area")
        .value("minor_alpha", ImPlotStyleVar_MinorAlpha, "float,  alpha multiplier applied to minor axis grid lines")
        .value("major_tick_len", ImPlotStyleVar_MajorTickLen, "ImVec2, major tick lengths for X and Y axes")
        .value("minor_tick_len", ImPlotStyleVar_MinorTickLen, "ImVec2, minor tick lengths for X and Y axes")
        .value("major_tick_size", ImPlotStyleVar_MajorTickSize, "ImVec2, line thickness of major ticks")
        .value("minor_tick_size", ImPlotStyleVar_MinorTickSize, "ImVec2, line thickness of minor ticks")
        .value("major_grid_size", ImPlotStyleVar_MajorGridSize, "ImVec2, line thickness of major grid lines")
        .value("minor_grid_size", ImPlotStyleVar_MinorGridSize, "ImVec2, line thickness of minor grid lines")
        .value("plot_padding", ImPlotStyleVar_PlotPadding, "ImVec2, padding between widget frame and plot area, labels, or outside legends (i.e. main padding)")
        .value("label_padding", ImPlotStyleVar_LabelPadding, "ImVec2, padding between axes labels, tick labels, and plot edge")
        .value("legend_padding", ImPlotStyleVar_LegendPadding, "ImVec2, legend padding from plot edges")
        .value("legend_inner_padding", ImPlotStyleVar_LegendInnerPadding, "ImVec2, legend inner padding from legend edges")
        .value("legend_spacing", ImPlotStyleVar_LegendSpacing, "ImVec2, spacing between legend entries")
        .value("mouse_pos_padding", ImPlotStyleVar_MousePosPadding, "ImVec2, padding between plot edge and interior info text")
        .value("annotation_padding", ImPlotStyleVar_AnnotationPadding, "ImVec2, text padding around annotation labels")
        .value("fit_padding", ImPlotStyleVar_FitPadding, "ImVec2, additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1,0.1) adds 10% to the fit extents of X and Y)")
        .value("plot_default_size", ImPlotStyleVar_PlotDefaultSize, "ImVec2, default size used when ImVec2(0,0) is passed to BeginPlot")
        .value("plot_min_size", ImPlotStyleVar_PlotMinSize, "ImVec2, minimum size plot frame can be when shrunk")
        .value("count", ImPlotStyleVar_COUNT, "");


    py::enum_<ImPlotScale_>(m, "Scale_", py::arithmetic(), "Axis scale")
        .value("linear", ImPlotScale_Linear, "default linear scale")
        .value("time", ImPlotScale_Time, "date/time scale")
        .value("log10", ImPlotScale_Log10, "base 10 logartithmic scale")
        .value("sym_log", ImPlotScale_SymLog, "symmetric log scale");


    py::enum_<ImPlotMarker_>(m, "Marker_", py::arithmetic(), "Marker specifications.")
        .value("none", ImPlotMarker_None, "no marker")
        .value("circle", ImPlotMarker_Circle, "a circle marker (default)")
        .value("square", ImPlotMarker_Square, "a square maker")
        .value("diamond", ImPlotMarker_Diamond, "a diamond marker")
        .value("up", ImPlotMarker_Up, "an upward-pointing triangle marker")
        .value("down", ImPlotMarker_Down, "an downward-pointing triangle marker")
        .value("left", ImPlotMarker_Left, "an leftward-pointing triangle marker")
        .value("right", ImPlotMarker_Right, "an rightward-pointing triangle marker")
        .value("cross", ImPlotMarker_Cross, "a cross marker (not fillable)")
        .value("plus", ImPlotMarker_Plus, "a plus marker (not fillable)")
        .value("asterisk", ImPlotMarker_Asterisk, "a asterisk marker (not fillable)")
        .value("count", ImPlotMarker_COUNT, "");


    py::enum_<ImPlotColormap_>(m, "Colormap_", py::arithmetic(), "Built-in colormaps")
        .value("deep", ImPlotColormap_Deep, "a.k.a. seaborn deep             (qual=True,  n=10) (default)")
        .value("dark", ImPlotColormap_Dark, "a.k.a. matplotlib \"Set1\"        (qual=True,  n=9 )")
        .value("pastel", ImPlotColormap_Pastel, "a.k.a. matplotlib \"Pastel1\"     (qual=True,  n=9 )")
        .value("paired", ImPlotColormap_Paired, "a.k.a. matplotlib \"Paired\"      (qual=True,  n=12)")
        .value("viridis", ImPlotColormap_Viridis, "a.k.a. matplotlib \"viridis\"     (qual=False, n=11)")
        .value("plasma", ImPlotColormap_Plasma, "a.k.a. matplotlib \"plasma\"      (qual=False, n=11)")
        .value("hot", ImPlotColormap_Hot, "a.k.a. matplotlib/MATLAB \"hot\"  (qual=False, n=11)")
        .value("cool", ImPlotColormap_Cool, "a.k.a. matplotlib/MATLAB \"cool\" (qual=False, n=11)")
        .value("pink", ImPlotColormap_Pink, "a.k.a. matplotlib/MATLAB \"pink\" (qual=False, n=11)")
        .value("jet", ImPlotColormap_Jet, "a.k.a. MATLAB \"jet\"             (qual=False, n=11)")
        .value("twilight", ImPlotColormap_Twilight, "a.k.a. matplotlib \"twilight\"    (qual=False, n=11)")
        .value("rd_bu", ImPlotColormap_RdBu, "red/blue, Color Brewer          (qual=False, n=11)")
        .value("br_bg", ImPlotColormap_BrBG, "brown/blue-green, Color Brewer  (qual=False, n=11)")
        .value("pi_yg", ImPlotColormap_PiYG, "pink/yellow-green, Color Brewer (qual=False, n=11)")
        .value("spectral", ImPlotColormap_Spectral, "color spectrum, Color Brewer    (qual=False, n=11)")
        .value("greys", ImPlotColormap_Greys, "white/black                     (qual=False, n=2 )");


    py::enum_<ImPlotLocation_>(m, "Location_", py::arithmetic(), "Used to position items on a plot (e.g. legends, labels, etc.)")
        .value("center", ImPlotLocation_Center, "center-center")
        .value("north", ImPlotLocation_North, "top-center")
        .value("south", ImPlotLocation_South, "bottom-center")
        .value("west", ImPlotLocation_West, "center-left")
        .value("east", ImPlotLocation_East, "center-right")
        .value("north_west", ImPlotLocation_NorthWest, "top-left")
        .value("north_east", ImPlotLocation_NorthEast, "top-right")
        .value("south_west", ImPlotLocation_SouthWest, "bottom-left")
        .value("south_east", ImPlotLocation_SouthEast, "bottom-right");


    py::enum_<ImPlotBin_>(m, "Bin_", py::arithmetic(), "Enums for different automatic histogram binning methods (k = bin count or w = bin width)")
        .value("sqrt", ImPlotBin_Sqrt, "k = sqrt(n)")
        .value("sturges", ImPlotBin_Sturges, "k = 1 + log2(n)")
        .value("rice", ImPlotBin_Rice, "k = 2 * cbrt(n)")
        .value("scott", ImPlotBin_Scott, "w = 3.49 * sigma / cbrt(n)");


    auto pyClassImPlotPoint =
        py::class_<ImPlotPoint>
            (m, "Point", "")
        .def_readwrite("x", &ImPlotPoint::x, "")
        .def_readwrite("y", &ImPlotPoint::y, "")
        .def(py::init<>())
        .def(py::init<double, double>(),
            py::arg("_x"), py::arg("_y"))
        .def(py::init<const ImVec2 &>(),
            py::arg("p"))
        .def("__getitem__",
            py::overload_cast<size_t>(&ImPlotPoint::operator[]),
            py::arg("idx"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("__getitem__",
            py::overload_cast<size_t>(&ImPlotPoint::operator[]),
            py::arg("idx"),
            "(private API)")
        ;


    auto pyClassImPlotRange =
        py::class_<ImPlotRange>
            (m, "Range", "Range defined by a min/max value.")
        .def_readwrite("min", &ImPlotRange::Min, "")
        .def_readwrite("max", &ImPlotRange::Max, "")
        .def(py::init<>())
        .def(py::init<double, double>(),
            py::arg("_min"), py::arg("_max"))
        .def("contains",
            [](const ImPlotRange & self, double value) -> bool
            {
                auto Contains_adapt_force_lambda = [&self](double value) -> bool
                {
                    auto lambda_result = self.Contains(value);
                    return lambda_result;
                };

                return Contains_adapt_force_lambda(value);
            },
            py::arg("value"),
            "(private API)")
        .def("size",
            &ImPlotRange::Size, "(private API)")
        .def("clamp",
            &ImPlotRange::Clamp,
            py::arg("value"),
            "(private API)")
        ;


    auto pyClassImPlotRect =
        py::class_<ImPlotRect>
            (m, "Rect", "Combination of two range limits for X and Y axes. Also an AABB defined by Min()/Max().")
        .def_readwrite("x", &ImPlotRect::X, "")
        .def_readwrite("y", &ImPlotRect::Y, "")
        .def(py::init<>())
        .def(py::init<double, double, double, double>(),
            py::arg("x_min"), py::arg("x_max"), py::arg("y_min"), py::arg("y_max"))
        .def("contains",
            [](const ImPlotRect & self, const ImPlotPoint & p) -> bool
            {
                auto Contains_adapt_force_lambda = [&self](const ImPlotPoint & p) -> bool
                {
                    auto lambda_result = self.Contains(p);
                    return lambda_result;
                };

                return Contains_adapt_force_lambda(p);
            },
            py::arg("p"),
            "(private API)")
        .def("contains",
            [](const ImPlotRect & self, double x, double y) -> bool
            {
                auto Contains_adapt_force_lambda = [&self](double x, double y) -> bool
                {
                    auto lambda_result = self.Contains(x, y);
                    return lambda_result;
                };

                return Contains_adapt_force_lambda(x, y);
            },
            py::arg("x"), py::arg("y"),
            "(private API)")
        .def("size",
            &ImPlotRect::Size, "(private API)")
        .def("clamp",
            py::overload_cast<const ImPlotPoint &>(&ImPlotRect::Clamp),
            py::arg("p"),
            "(private API)")
        .def("clamp",
            py::overload_cast<double, double>(&ImPlotRect::Clamp),
            py::arg("x"), py::arg("y"),
            "(private API)")
        .def("min",
            &ImPlotRect::Min, "(private API)")
        .def("max",
            &ImPlotRect::Max, "(private API)")
        ;


    auto pyClassImPlotStyle =
        py::class_<ImPlotStyle>
            (m, "Style", "Plot style structure")
        .def_readwrite("line_weight", &ImPlotStyle::LineWeight, "= 1,      item line weight in pixels")
        .def_readwrite("marker", &ImPlotStyle::Marker, "= ImPlotMarker_None, marker specification")
        .def_readwrite("marker_size", &ImPlotStyle::MarkerSize, "= 4,      marker size in pixels (roughly the marker's \"radius\")")
        .def_readwrite("marker_weight", &ImPlotStyle::MarkerWeight, "= 1,      outline weight of markers in pixels")
        .def_readwrite("fill_alpha", &ImPlotStyle::FillAlpha, "= 1,      alpha modifier applied to plot fills")
        .def_readwrite("error_bar_size", &ImPlotStyle::ErrorBarSize, "= 5,      error bar whisker width in pixels")
        .def_readwrite("error_bar_weight", &ImPlotStyle::ErrorBarWeight, "= 1.5,    error bar whisker weight in pixels")
        .def_readwrite("digital_bit_height", &ImPlotStyle::DigitalBitHeight, "= 8,      digital channels bit height (at y = 1.0) in pixels")
        .def_readwrite("digital_bit_gap", &ImPlotStyle::DigitalBitGap, "= 4,      digital channels bit padding gap in pixels")
        .def_readwrite("plot_border_size", &ImPlotStyle::PlotBorderSize, "= 1,      line thickness of border around plot area")
        .def_readwrite("minor_alpha", &ImPlotStyle::MinorAlpha, "= 0.25    alpha multiplier applied to minor axis grid lines")
        .def_readwrite("major_tick_len", &ImPlotStyle::MajorTickLen, "= 10,10   major tick lengths for X and Y axes")
        .def_readwrite("minor_tick_len", &ImPlotStyle::MinorTickLen, "= 5,5     minor tick lengths for X and Y axes")
        .def_readwrite("major_tick_size", &ImPlotStyle::MajorTickSize, "= 1,1     line thickness of major ticks")
        .def_readwrite("minor_tick_size", &ImPlotStyle::MinorTickSize, "= 1,1     line thickness of minor ticks")
        .def_readwrite("major_grid_size", &ImPlotStyle::MajorGridSize, "= 1,1     line thickness of major grid lines")
        .def_readwrite("minor_grid_size", &ImPlotStyle::MinorGridSize, "= 1,1     line thickness of minor grid lines")
        .def_readwrite("plot_padding", &ImPlotStyle::PlotPadding, "= 10,10   padding between widget frame and plot area, labels, or outside legends (i.e. main padding)")
        .def_readwrite("label_padding", &ImPlotStyle::LabelPadding, "= 5,5     padding between axes labels, tick labels, and plot edge")
        .def_readwrite("legend_padding", &ImPlotStyle::LegendPadding, "= 10,10   legend padding from plot edges")
        .def_readwrite("legend_inner_padding", &ImPlotStyle::LegendInnerPadding, "= 5,5     legend inner padding from legend edges")
        .def_readwrite("legend_spacing", &ImPlotStyle::LegendSpacing, "= 5,0     spacing between legend entries")
        .def_readwrite("mouse_pos_padding", &ImPlotStyle::MousePosPadding, "= 10,10   padding between plot edge and interior mouse location text")
        .def_readwrite("annotation_padding", &ImPlotStyle::AnnotationPadding, "= 2,2     text padding around annotation labels")
        .def_readwrite("fit_padding", &ImPlotStyle::FitPadding, "= 0,0     additional fit padding as a percentage of the fit extents (e.g. ImVec2(0.1,0.1) adds 10% to the fit extents of X and Y)")
        .def_readwrite("plot_default_size", &ImPlotStyle::PlotDefaultSize, "= 400,300 default size used when ImVec2(0,0) is passed to BeginPlot")
        .def_readwrite("plot_min_size", &ImPlotStyle::PlotMinSize, "= 200,150 minimum size plot frame can be when shrunk")
        .def_readwrite("colormap", &ImPlotStyle::Colormap, "The current colormap. Set this to either an ImPlotColormap_ enum or an index returned by AddColormap.")
        .def_readwrite("use_local_time", &ImPlotStyle::UseLocalTime, "= False,  axis labels will be formatted for your timezone when ImPlotAxisFlag_Time is enabled")
        .def_readwrite("use_iso8601", &ImPlotStyle::UseISO8601, "= False,  dates will be formatted according to ISO 8601 where applicable (e.g. YYYY-MM-DD, YYYY-MM, --MM-DD, etc.)")
        .def_readwrite("use24_hour_clock", &ImPlotStyle::Use24HourClock, "= False,  times will be formatted using a 24 hour clock")
        .def(py::init<>())
        ;


    auto pyClassImPlotInputMap =
        py::class_<ImPlotInputMap>
            (m, "InputMap", "Input mapping structure. Default values listed. See also MapInputDefault, MapInputReverse.")
        .def_readwrite("pan", &ImPlotInputMap::Pan, "LMB    enables panning when held,")
        .def_readwrite("pan_mod", &ImPlotInputMap::PanMod, "none   optional modifier that must be held for panning/fitting")
        .def_readwrite("fit", &ImPlotInputMap::Fit, "LMB    initiates fit when double clicked")
        .def_readwrite("select", &ImPlotInputMap::Select, "RMB    begins box selection when pressed and confirms selection when released")
        .def_readwrite("select_cancel", &ImPlotInputMap::SelectCancel, "LMB    cancels active box selection when pressed; cannot be same as Select")
        .def_readwrite("select_mod", &ImPlotInputMap::SelectMod, "none   optional modifier that must be held for box selection")
        .def_readwrite("select_horz_mod", &ImPlotInputMap::SelectHorzMod, "Alt    expands active box selection horizontally to plot edge when held")
        .def_readwrite("select_vert_mod", &ImPlotInputMap::SelectVertMod, "Shift  expands active box selection vertically to plot edge when held")
        .def_readwrite("menu", &ImPlotInputMap::Menu, "RMB    opens context menus (if enabled) when clicked")
        .def_readwrite("override_mod", &ImPlotInputMap::OverrideMod, "Ctrl   when held, all input is ignored; used to enable axis/plots as DND sources")
        .def_readwrite("zoom_mod", &ImPlotInputMap::ZoomMod, "none   optional modifier that must be held for scroll wheel zooming")
        .def_readwrite("zoom_rate", &ImPlotInputMap::ZoomRate, "0.1   zoom rate for scroll (e.g. 0.1 = 10% plot range every scroll click); make negative to invert")
        .def(py::init<>())
        ;


    m.def("create_context",
        ImPlot::CreateContext,
        "Creates a new ImPlot context. Call this after ImGui::CreateContext.",
        pybind11::return_value_policy::reference);

    m.def("destroy_context",
        ImPlot::DestroyContext,
        py::arg("ctx") = py::none(),
        "Destroys an ImPlot context. Call this before ImGui::DestroyContext. None = destroy current context.");

    m.def("get_current_context",
        ImPlot::GetCurrentContext,
        "Returns the current ImPlot context. None if no context has ben set.",
        pybind11::return_value_policy::reference);

    m.def("set_current_context",
        ImPlot::SetCurrentContext,
        py::arg("ctx"),
        "Sets the current ImPlot context.");

    m.def("set_imgui_context",
        ImPlot::SetImGuiContext,
        py::arg("ctx"),
        " Sets the current **ImGui** context. This is ONLY necessary if you are compiling\n ImPlot as a DLL (not recommended) separate from your ImGui compilation. It\n sets the global variable GImGui, which is not shared across DLL boundaries.\n See GImGui documentation in imgui.cpp for more details.");

    m.def("begin_plot",
        py::overload_cast<const char *, const ImVec2 &, ImPlotFlags>(ImPlot::BeginPlot),
        py::arg("title_id"), py::arg("size") = ImVec2(-1,0), py::arg("flags") = 0,
        " Starts a 2D plotting context. If this function returns True, EndPlot() MUST\n be called! You are encouraged to use the following convention:\n\n if (BeginPlot(...)) {\n     PlotLine(...);\n     ...\n     EndPlot();\n }\n\n Important notes:\n\n - #title_id must be unique to the current ImGui ID scope. If you need to avoid ID\n   collisions or don't want to display a title in the plot, use double hashes\n   (e.g. \"MyPlot##HiddenIdText\" or \"##NoTitle\").\n - #size is the **frame** size of the plot widget, not the plot area. The default\n   size of plots (i.e. when ImVec2(0,0)) can be modified in your ImPlotStyle.");

    m.def("end_plot",
        ImPlot::EndPlot, " Only call EndPlot() if BeginPlot() returns True! Typically called at the end\n of an if statement conditioned on BeginPlot(). See example above.");

    m.def("begin_subplots",
        [](const char * title_id, int rows, int cols, const ImVec2 & size, ImPlotSubplotFlags flags = 0, std::optional<float> row_ratios = std::nullopt, std::optional<float> col_ratios = std::nullopt) -> std::tuple<bool, std::optional<float>, std::optional<float>>
        {
            auto BeginSubplots_adapt_modifiable_immutable_to_return = [](const char * title_id, int rows, int cols, const ImVec2 & size, ImPlotSubplotFlags flags = 0, std::optional<float> row_ratios = std::nullopt, std::optional<float> col_ratios = std::nullopt) -> std::tuple<bool, std::optional<float>, std::optional<float>>
            {
                float * row_ratios_adapt_modifiable = nullptr;
                if (row_ratios.has_value())
                    row_ratios_adapt_modifiable = & (*row_ratios);
                float * col_ratios_adapt_modifiable = nullptr;
                if (col_ratios.has_value())
                    col_ratios_adapt_modifiable = & (*col_ratios);

                bool r = ImPlot::BeginSubplots(title_id, rows, cols, size, flags, row_ratios_adapt_modifiable, col_ratios_adapt_modifiable);
                return std::make_tuple(r, row_ratios, col_ratios);
            };

            return BeginSubplots_adapt_modifiable_immutable_to_return(title_id, rows, cols, size, flags, row_ratios, col_ratios);
        },     py::arg("title_id"), py::arg("rows"), py::arg("cols"), py::arg("size"), py::arg("flags") = 0, py::arg("row_ratios") = py::none(), py::arg("col_ratios") = py::none());

    m.def("end_subplots",
        ImPlot::EndSubplots, " Only call EndSubplots() if BeginSubplots() returns True! Typically called at the end\n of an if statement conditioned on BeginSublots(). See example above.");

    m.def("setup_axis",
        ImPlot::SetupAxis,
        py::arg("axis"), py::arg("label") = py::none(), py::arg("flags") = 0,
        "Enables an axis or sets the label and/or flags for an existing axis. Leave #label = None for no label.");

    m.def("setup_axis_limits",
        ImPlot::SetupAxisLimits,
        py::arg("axis"), py::arg("v_min"), py::arg("v_max"), py::arg("cond") = ImPlotCond_Once,
        "Sets an axis range limits. If ImPlotCond_Always is used, the axes limits will be locked. Inversion with v_min > v_max is not supported; use SetupAxisLimits instead.");

    m.def("setup_axis_links",
        [](ImAxis axis, double link_min, double link_max) -> std::tuple<double, double>
        {
            auto SetupAxisLinks_adapt_modifiable_immutable_to_return = [](ImAxis axis, double link_min, double link_max) -> std::tuple<double, double>
            {
                double * link_min_adapt_modifiable = & link_min;
                double * link_max_adapt_modifiable = & link_max;

                ImPlot::SetupAxisLinks(axis, link_min_adapt_modifiable, link_max_adapt_modifiable);
                return std::make_tuple(link_min, link_max);
            };

            return SetupAxisLinks_adapt_modifiable_immutable_to_return(axis, link_min, link_max);
        },
        py::arg("axis"), py::arg("link_min"), py::arg("link_max"),
        "Links an axis range limits to external values. Set to None for no linkage. The pointer data must remain valid until EndPlot.");

    m.def("setup_axis_format",
        py::overload_cast<ImAxis, const char *>(ImPlot::SetupAxisFormat),
        py::arg("axis"), py::arg("fmt"),
        "Sets the format of numeric axis labels via formater specifier (default=\"%g\"). Formated values will be double (i.e. use %f).");

    m.def("setup_axis_scale",
        py::overload_cast<ImAxis, ImPlotScale>(ImPlot::SetupAxisScale),
        py::arg("axis"), py::arg("scale"),
        "Sets an axis' scale using built-in options.");

    m.def("setup_axis_limits_constraints",
        ImPlot::SetupAxisLimitsConstraints,
        py::arg("axis"), py::arg("v_min"), py::arg("v_max"),
        "Sets an axis' limits constraints.");

    m.def("setup_axis_zoom_constraints",
        ImPlot::SetupAxisZoomConstraints,
        py::arg("axis"), py::arg("z_min"), py::arg("z_max"),
        "Sets an axis' zoom constraints.");

    m.def("setup_axes",
        ImPlot::SetupAxes,
        py::arg("x_label"), py::arg("y_label"), py::arg("x_flags") = 0, py::arg("y_flags") = 0,
        "Sets the label and/or flags for primary X and Y axes (shorthand for two calls to SetupAxis).");

    m.def("setup_axes_limits",
        ImPlot::SetupAxesLimits,
        py::arg("x_min"), py::arg("x_max"), py::arg("y_min"), py::arg("y_max"), py::arg("cond") = ImPlotCond_Once,
        "Sets the primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).");

    m.def("setup_legend",
        ImPlot::SetupLegend,
        py::arg("location"), py::arg("flags") = 0,
        "Sets up the plot legend. This can also be called immediately after BeginSubplots when using ImPlotSubplotFlags_ShareItems.");

    m.def("setup_mouse_text",
        ImPlot::SetupMouseText,
        py::arg("location"), py::arg("flags") = 0,
        "Set the location of the current plot's mouse position text (default = South|East).");

    m.def("setup_finish",
        ImPlot::SetupFinish, " Explicitly finalize plot setup. Once you call this, you cannot make anymore Setup calls for the current plot!\n Note that calling this function is OPTIONAL; it will be called by the first subsequent setup-locking API call.");

    m.def("set_next_axis_limits",
        ImPlot::SetNextAxisLimits,
        py::arg("axis"), py::arg("v_min"), py::arg("v_max"), py::arg("cond") = ImPlotCond_Once,
        "Sets an upcoming axis range limits. If ImPlotCond_Always is used, the axes limits will be locked.");

    m.def("set_next_axis_links",
        [](ImAxis axis, double link_min, double link_max) -> std::tuple<double, double>
        {
            auto SetNextAxisLinks_adapt_modifiable_immutable_to_return = [](ImAxis axis, double link_min, double link_max) -> std::tuple<double, double>
            {
                double * link_min_adapt_modifiable = & link_min;
                double * link_max_adapt_modifiable = & link_max;

                ImPlot::SetNextAxisLinks(axis, link_min_adapt_modifiable, link_max_adapt_modifiable);
                return std::make_tuple(link_min, link_max);
            };

            return SetNextAxisLinks_adapt_modifiable_immutable_to_return(axis, link_min, link_max);
        },
        py::arg("axis"), py::arg("link_min"), py::arg("link_max"),
        "Links an upcoming axis range limits to external values. Set to None for no linkage. The pointer data must remain valid until EndPlot!");

    m.def("set_next_axis_to_fit",
        ImPlot::SetNextAxisToFit,
        py::arg("axis"),
        "Set an upcoming axis to auto fit to its data.");

    m.def("set_next_axes_limits",
        ImPlot::SetNextAxesLimits,
        py::arg("x_min"), py::arg("x_max"), py::arg("y_min"), py::arg("y_max"), py::arg("cond") = ImPlotCond_Once,
        "Sets the upcoming primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).");

    m.def("set_next_axes_to_fit",
        ImPlot::SetNextAxesToFit, "Sets all upcoming axes to auto fit to their data.");

    m.def("plot_line",
        [](const char * label_id, const py::array & values, double xscale = 1, double xstart = 0, ImPlotLineFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotLine_adapt_c_buffers = [](const char * label_id, const py::array & values, double xscale = 1, double xstart = 0, ImPlotLineFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int values_stride = stride;
                if (values_stride == -1)
                    values_stride = (int)values.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotLine(label_id, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'b')
                    ImPlot::PlotLine(label_id, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'H')
                    ImPlot::PlotLine(label_id, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'h')
                    ImPlot::PlotLine(label_id, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'I')
                    ImPlot::PlotLine(label_id, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'i')
                    ImPlot::PlotLine(label_id, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'L')
                    ImPlot::PlotLine(label_id, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'l')
                    ImPlot::PlotLine(label_id, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'f')
                    ImPlot::PlotLine(label_id, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'd')
                    ImPlot::PlotLine(label_id, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'g')
                    ImPlot::PlotLine(label_id, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'q')
                    ImPlot::PlotLine(label_id, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };

            PlotLine_adapt_c_buffers(label_id, values, xscale, xstart, flags, offset, stride);
        },     py::arg("label_id"), py::arg("values"), py::arg("xscale") = 1, py::arg("xstart") = 0, py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_line",
        [](const char * label_id, const py::array & xs, const py::array & ys, ImPlotLineFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotLine_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, ImPlotLineFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int ys_stride = stride;
                if (ys_stride == -1)
                    ys_stride = (int)ys.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys_type = ys.dtype().char_();
                if (ys_type == 'B')
                    ImPlot::PlotLine(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'b')
                    ImPlot::PlotLine(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'H')
                    ImPlot::PlotLine(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'h')
                    ImPlot::PlotLine(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'I')
                    ImPlot::PlotLine(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'i')
                    ImPlot::PlotLine(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'L')
                    ImPlot::PlotLine(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'l')
                    ImPlot::PlotLine(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'f')
                    ImPlot::PlotLine(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'd')
                    ImPlot::PlotLine(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'g')
                    ImPlot::PlotLine(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'q')
                    ImPlot::PlotLine(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys_type + "') for param ys");
            };

            PlotLine_adapt_c_buffers(label_id, xs, ys, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_scatter",
        [](const char * label_id, const py::array & values, double xscale = 1, double xstart = 0, ImPlotScatterFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotScatter_adapt_c_buffers = [](const char * label_id, const py::array & values, double xscale = 1, double xstart = 0, ImPlotScatterFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int values_stride = stride;
                if (values_stride == -1)
                    values_stride = (int)values.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotScatter(label_id, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'b')
                    ImPlot::PlotScatter(label_id, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'H')
                    ImPlot::PlotScatter(label_id, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'h')
                    ImPlot::PlotScatter(label_id, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'I')
                    ImPlot::PlotScatter(label_id, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'i')
                    ImPlot::PlotScatter(label_id, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'L')
                    ImPlot::PlotScatter(label_id, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'l')
                    ImPlot::PlotScatter(label_id, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'f')
                    ImPlot::PlotScatter(label_id, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'd')
                    ImPlot::PlotScatter(label_id, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'g')
                    ImPlot::PlotScatter(label_id, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'q')
                    ImPlot::PlotScatter(label_id, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };

            PlotScatter_adapt_c_buffers(label_id, values, xscale, xstart, flags, offset, stride);
        },     py::arg("label_id"), py::arg("values"), py::arg("xscale") = 1, py::arg("xstart") = 0, py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_scatter",
        [](const char * label_id, const py::array & xs, const py::array & ys, ImPlotScatterFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotScatter_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, ImPlotScatterFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int ys_stride = stride;
                if (ys_stride == -1)
                    ys_stride = (int)ys.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys_type = ys.dtype().char_();
                if (ys_type == 'B')
                    ImPlot::PlotScatter(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'b')
                    ImPlot::PlotScatter(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'H')
                    ImPlot::PlotScatter(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'h')
                    ImPlot::PlotScatter(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'I')
                    ImPlot::PlotScatter(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'i')
                    ImPlot::PlotScatter(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'L')
                    ImPlot::PlotScatter(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'l')
                    ImPlot::PlotScatter(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'f')
                    ImPlot::PlotScatter(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'd')
                    ImPlot::PlotScatter(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'g')
                    ImPlot::PlotScatter(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'q')
                    ImPlot::PlotScatter(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys_type + "') for param ys");
            };

            PlotScatter_adapt_c_buffers(label_id, xs, ys, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_stairs",
        [](const char * label_id, const py::array & values, double xscale = 1, double xstart = 0, ImPlotStairsFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotStairs_adapt_c_buffers = [](const char * label_id, const py::array & values, double xscale = 1, double xstart = 0, ImPlotStairsFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int values_stride = stride;
                if (values_stride == -1)
                    values_stride = (int)values.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotStairs(label_id, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'b')
                    ImPlot::PlotStairs(label_id, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'H')
                    ImPlot::PlotStairs(label_id, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'h')
                    ImPlot::PlotStairs(label_id, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'I')
                    ImPlot::PlotStairs(label_id, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'i')
                    ImPlot::PlotStairs(label_id, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'L')
                    ImPlot::PlotStairs(label_id, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'l')
                    ImPlot::PlotStairs(label_id, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'f')
                    ImPlot::PlotStairs(label_id, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'd')
                    ImPlot::PlotStairs(label_id, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'g')
                    ImPlot::PlotStairs(label_id, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'q')
                    ImPlot::PlotStairs(label_id, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), xscale, xstart, flags, offset, values_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };

            PlotStairs_adapt_c_buffers(label_id, values, xscale, xstart, flags, offset, stride);
        },     py::arg("label_id"), py::arg("values"), py::arg("xscale") = 1, py::arg("xstart") = 0, py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_stairs",
        [](const char * label_id, const py::array & xs, const py::array & ys, ImPlotStairsFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotStairs_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, ImPlotStairsFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int ys_stride = stride;
                if (ys_stride == -1)
                    ys_stride = (int)ys.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys_type = ys.dtype().char_();
                if (ys_type == 'B')
                    ImPlot::PlotStairs(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'b')
                    ImPlot::PlotStairs(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'H')
                    ImPlot::PlotStairs(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'h')
                    ImPlot::PlotStairs(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'I')
                    ImPlot::PlotStairs(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'i')
                    ImPlot::PlotStairs(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'L')
                    ImPlot::PlotStairs(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'l')
                    ImPlot::PlotStairs(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'f')
                    ImPlot::PlotStairs(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'd')
                    ImPlot::PlotStairs(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'g')
                    ImPlot::PlotStairs(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'q')
                    ImPlot::PlotStairs(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys_type + "') for param ys");
            };

            PlotStairs_adapt_c_buffers(label_id, xs, ys, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_shaded",
        [](const char * label_id, const py::array & values, double yref = 0, double xscale = 1, double xstart = 0, ImPlotShadedFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotShaded_adapt_c_buffers = [](const char * label_id, const py::array & values, double yref = 0, double xscale = 1, double xstart = 0, ImPlotShadedFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int values_stride = stride;
                if (values_stride == -1)
                    values_stride = (int)values.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotShaded(label_id, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'b')
                    ImPlot::PlotShaded(label_id, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'H')
                    ImPlot::PlotShaded(label_id, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'h')
                    ImPlot::PlotShaded(label_id, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'I')
                    ImPlot::PlotShaded(label_id, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'i')
                    ImPlot::PlotShaded(label_id, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'L')
                    ImPlot::PlotShaded(label_id, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'l')
                    ImPlot::PlotShaded(label_id, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'f')
                    ImPlot::PlotShaded(label_id, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'd')
                    ImPlot::PlotShaded(label_id, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'g')
                    ImPlot::PlotShaded(label_id, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                else if (values_type == 'q')
                    ImPlot::PlotShaded(label_id, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), yref, xscale, xstart, flags, offset, values_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };

            PlotShaded_adapt_c_buffers(label_id, values, yref, xscale, xstart, flags, offset, stride);
        },     py::arg("label_id"), py::arg("values"), py::arg("yref") = 0, py::arg("xscale") = 1, py::arg("xstart") = 0, py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_shaded",
        [](const char * label_id, const py::array & xs, const py::array & ys, double yref = 0, ImPlotShadedFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotShaded_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, double yref = 0, ImPlotShadedFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int ys_stride = stride;
                if (ys_stride == -1)
                    ys_stride = (int)ys.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys_type = ys.dtype().char_();
                if (ys_type == 'B')
                    ImPlot::PlotShaded(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'b')
                    ImPlot::PlotShaded(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'H')
                    ImPlot::PlotShaded(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'h')
                    ImPlot::PlotShaded(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'I')
                    ImPlot::PlotShaded(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'i')
                    ImPlot::PlotShaded(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'L')
                    ImPlot::PlotShaded(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'l')
                    ImPlot::PlotShaded(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'f')
                    ImPlot::PlotShaded(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'd')
                    ImPlot::PlotShaded(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'g')
                    ImPlot::PlotShaded(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                else if (ys_type == 'q')
                    ImPlot::PlotShaded(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), yref, flags, offset, ys_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys_type + "') for param ys");
            };

            PlotShaded_adapt_c_buffers(label_id, xs, ys, yref, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("yref") = 0, py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_shaded",
        [](const char * label_id, const py::array & xs, const py::array & ys1, const py::array & ys2, ImPlotShadedFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotShaded_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys1, const py::array & ys2, ImPlotShadedFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys1_from_pyarray = ys1.data();
                py::ssize_t ys1_count = ys1.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys2_from_pyarray = ys2.data();
                py::ssize_t ys2_count = ys2.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int ys2_stride = stride;
                if (ys2_stride == -1)
                    ys2_stride = (int)ys2.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys2_type = ys2.dtype().char_();
                if (ys2_type == 'B')
                    ImPlot::PlotShaded(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys1_from_pyarray), static_cast<const uint8_t *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'b')
                    ImPlot::PlotShaded(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys1_from_pyarray), static_cast<const int8_t *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'H')
                    ImPlot::PlotShaded(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys1_from_pyarray), static_cast<const uint16_t *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'h')
                    ImPlot::PlotShaded(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys1_from_pyarray), static_cast<const int16_t *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'I')
                    ImPlot::PlotShaded(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys1_from_pyarray), static_cast<const uint32_t *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'i')
                    ImPlot::PlotShaded(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys1_from_pyarray), static_cast<const int32_t *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'L')
                    ImPlot::PlotShaded(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys1_from_pyarray), static_cast<const np_uint_l *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'l')
                    ImPlot::PlotShaded(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys1_from_pyarray), static_cast<const np_int_l *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'f')
                    ImPlot::PlotShaded(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys1_from_pyarray), static_cast<const float *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'd')
                    ImPlot::PlotShaded(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys1_from_pyarray), static_cast<const double *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'g')
                    ImPlot::PlotShaded(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys1_from_pyarray), static_cast<const long double *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                else if (ys2_type == 'q')
                    ImPlot::PlotShaded(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys1_from_pyarray), static_cast<const long long *>(ys2_from_pyarray), static_cast<int>(ys2_count), flags, offset, ys2_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys2_type + "') for param ys2");
            };

            PlotShaded_adapt_c_buffers(label_id, xs, ys1, ys2, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys1"), py::arg("ys2"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_bars",
        [](const char * label_id, const py::array & values, double bar_size = 0.67, double shift = 0, ImPlotBarsFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotBars_adapt_c_buffers = [](const char * label_id, const py::array & values, double bar_size = 0.67, double shift = 0, ImPlotBarsFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int values_stride = stride;
                if (values_stride == -1)
                    values_stride = (int)values.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotBars(label_id, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'b')
                    ImPlot::PlotBars(label_id, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'H')
                    ImPlot::PlotBars(label_id, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'h')
                    ImPlot::PlotBars(label_id, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'I')
                    ImPlot::PlotBars(label_id, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'i')
                    ImPlot::PlotBars(label_id, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'L')
                    ImPlot::PlotBars(label_id, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'l')
                    ImPlot::PlotBars(label_id, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'f')
                    ImPlot::PlotBars(label_id, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'd')
                    ImPlot::PlotBars(label_id, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'g')
                    ImPlot::PlotBars(label_id, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                else if (values_type == 'q')
                    ImPlot::PlotBars(label_id, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), bar_size, shift, flags, offset, values_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };

            PlotBars_adapt_c_buffers(label_id, values, bar_size, shift, flags, offset, stride);
        },     py::arg("label_id"), py::arg("values"), py::arg("bar_size") = 0.67, py::arg("shift") = 0, py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_bars",
        [](const char * label_id, const py::array & xs, const py::array & ys, double bar_size, ImPlotBarsFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotBars_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, double bar_size, ImPlotBarsFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int ys_stride = stride;
                if (ys_stride == -1)
                    ys_stride = (int)ys.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys_type = ys.dtype().char_();
                if (ys_type == 'B')
                    ImPlot::PlotBars(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'b')
                    ImPlot::PlotBars(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'H')
                    ImPlot::PlotBars(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'h')
                    ImPlot::PlotBars(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'I')
                    ImPlot::PlotBars(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'i')
                    ImPlot::PlotBars(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'L')
                    ImPlot::PlotBars(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'l')
                    ImPlot::PlotBars(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'f')
                    ImPlot::PlotBars(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'd')
                    ImPlot::PlotBars(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'g')
                    ImPlot::PlotBars(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                else if (ys_type == 'q')
                    ImPlot::PlotBars(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), bar_size, flags, offset, ys_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys_type + "') for param ys");
            };

            PlotBars_adapt_c_buffers(label_id, xs, ys, bar_size, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("bar_size"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_bar_groups",
        [](const std::vector<std::string> & label_ids, const py::array & values, int group_count, double group_size = 0.67, double shift = 0, ImPlotBarGroupsFlags flags = 0)
        {
            auto PlotBarGroups_adapt_c_buffers = [](const char * const label_ids[], const py::array & values, int group_count, double group_size = 0.67, double shift = 0, ImPlotBarGroupsFlags flags = 0)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'b')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'H')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'h')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'I')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'i')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'L')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'l')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'f')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'd')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'g')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                else if (values_type == 'q')
                    ImPlot::PlotBarGroups(label_ids, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), group_count, group_size, shift, flags);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };
            auto PlotBarGroups_adapt_c_string_list_no_count = [&PlotBarGroups_adapt_c_buffers](const std::vector<std::string> & label_ids, const py::array & values, int group_count, double group_size = 0.67, double shift = 0, ImPlotBarGroupsFlags flags = 0)
            {
                std::vector<const char *> label_ids_ptrs;
                for (const auto& v: label_ids)
                    label_ids_ptrs.push_back(v.c_str());

                PlotBarGroups_adapt_c_buffers(label_ids_ptrs.data(), values, group_count, group_size, shift, flags);
            };

            PlotBarGroups_adapt_c_string_list_no_count(label_ids, values, group_count, group_size, shift, flags);
        },
        py::arg("label_ids"), py::arg("values"), py::arg("group_count"), py::arg("group_size") = 0.67, py::arg("shift") = 0, py::arg("flags") = 0,
        "Plots a group of bars. #values is a row-major matrix with #item_count rows and #group_count cols. #label_ids should have #item_count elements.");

    m.def("plot_error_bars",
        [](const char * label_id, const py::array & xs, const py::array & ys, const py::array & err, ImPlotErrorBarsFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotErrorBars_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, const py::array & err, ImPlotErrorBarsFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * err_from_pyarray = err.data();
                py::ssize_t err_count = err.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int err_stride = stride;
                if (err_stride == -1)
                    err_stride = (int)err.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char err_type = err.dtype().char_();
                if (err_type == 'B')
                    ImPlot::PlotErrorBars(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<const uint8_t *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'b')
                    ImPlot::PlotErrorBars(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<const int8_t *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'H')
                    ImPlot::PlotErrorBars(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<const uint16_t *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'h')
                    ImPlot::PlotErrorBars(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<const int16_t *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'I')
                    ImPlot::PlotErrorBars(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<const uint32_t *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'i')
                    ImPlot::PlotErrorBars(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<const int32_t *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'L')
                    ImPlot::PlotErrorBars(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<const np_uint_l *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'l')
                    ImPlot::PlotErrorBars(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<const np_int_l *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'f')
                    ImPlot::PlotErrorBars(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<const float *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'd')
                    ImPlot::PlotErrorBars(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<const double *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'g')
                    ImPlot::PlotErrorBars(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<const long double *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                else if (err_type == 'q')
                    ImPlot::PlotErrorBars(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<const long long *>(err_from_pyarray), static_cast<int>(err_count), flags, offset, err_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + err_type + "') for param err");
            };

            PlotErrorBars_adapt_c_buffers(label_id, xs, ys, err, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("err"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_error_bars",
        [](const char * label_id, const py::array & xs, const py::array & ys, const py::array & neg, const py::array & pos, ImPlotErrorBarsFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotErrorBars_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, const py::array & neg, const py::array & pos, ImPlotErrorBarsFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * neg_from_pyarray = neg.data();
                py::ssize_t neg_count = neg.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * pos_from_pyarray = pos.data();
                py::ssize_t pos_count = pos.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int pos_stride = stride;
                if (pos_stride == -1)
                    pos_stride = (int)pos.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char pos_type = pos.dtype().char_();
                if (pos_type == 'B')
                    ImPlot::PlotErrorBars(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<const uint8_t *>(neg_from_pyarray), static_cast<const uint8_t *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'b')
                    ImPlot::PlotErrorBars(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<const int8_t *>(neg_from_pyarray), static_cast<const int8_t *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'H')
                    ImPlot::PlotErrorBars(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<const uint16_t *>(neg_from_pyarray), static_cast<const uint16_t *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'h')
                    ImPlot::PlotErrorBars(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<const int16_t *>(neg_from_pyarray), static_cast<const int16_t *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'I')
                    ImPlot::PlotErrorBars(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<const uint32_t *>(neg_from_pyarray), static_cast<const uint32_t *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'i')
                    ImPlot::PlotErrorBars(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<const int32_t *>(neg_from_pyarray), static_cast<const int32_t *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'L')
                    ImPlot::PlotErrorBars(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<const np_uint_l *>(neg_from_pyarray), static_cast<const np_uint_l *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'l')
                    ImPlot::PlotErrorBars(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<const np_int_l *>(neg_from_pyarray), static_cast<const np_int_l *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'f')
                    ImPlot::PlotErrorBars(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<const float *>(neg_from_pyarray), static_cast<const float *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'd')
                    ImPlot::PlotErrorBars(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<const double *>(neg_from_pyarray), static_cast<const double *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'g')
                    ImPlot::PlotErrorBars(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<const long double *>(neg_from_pyarray), static_cast<const long double *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                else if (pos_type == 'q')
                    ImPlot::PlotErrorBars(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<const long long *>(neg_from_pyarray), static_cast<const long long *>(pos_from_pyarray), static_cast<int>(pos_count), flags, offset, pos_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + pos_type + "') for param pos");
            };

            PlotErrorBars_adapt_c_buffers(label_id, xs, ys, neg, pos, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("neg"), py::arg("pos"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_stems",
        [](const char * label_id, const py::array & values, double ref = 0, double scale = 1, double start = 0, ImPlotStemsFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotStems_adapt_c_buffers = [](const char * label_id, const py::array & values, double ref = 0, double scale = 1, double start = 0, ImPlotStemsFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int values_stride = stride;
                if (values_stride == -1)
                    values_stride = (int)values.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotStems(label_id, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'b')
                    ImPlot::PlotStems(label_id, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'H')
                    ImPlot::PlotStems(label_id, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'h')
                    ImPlot::PlotStems(label_id, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'I')
                    ImPlot::PlotStems(label_id, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'i')
                    ImPlot::PlotStems(label_id, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'L')
                    ImPlot::PlotStems(label_id, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'l')
                    ImPlot::PlotStems(label_id, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'f')
                    ImPlot::PlotStems(label_id, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'd')
                    ImPlot::PlotStems(label_id, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'g')
                    ImPlot::PlotStems(label_id, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                else if (values_type == 'q')
                    ImPlot::PlotStems(label_id, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), ref, scale, start, flags, offset, values_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };

            PlotStems_adapt_c_buffers(label_id, values, ref, scale, start, flags, offset, stride);
        },     py::arg("label_id"), py::arg("values"), py::arg("ref") = 0, py::arg("scale") = 1, py::arg("start") = 0, py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_stems",
        [](const char * label_id, const py::array & xs, const py::array & ys, double ref = 0, ImPlotStemsFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotStems_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, double ref = 0, ImPlotStemsFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int ys_stride = stride;
                if (ys_stride == -1)
                    ys_stride = (int)ys.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys_type = ys.dtype().char_();
                if (ys_type == 'B')
                    ImPlot::PlotStems(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'b')
                    ImPlot::PlotStems(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'H')
                    ImPlot::PlotStems(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'h')
                    ImPlot::PlotStems(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'I')
                    ImPlot::PlotStems(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'i')
                    ImPlot::PlotStems(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'L')
                    ImPlot::PlotStems(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'l')
                    ImPlot::PlotStems(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'f')
                    ImPlot::PlotStems(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'd')
                    ImPlot::PlotStems(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'g')
                    ImPlot::PlotStems(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                else if (ys_type == 'q')
                    ImPlot::PlotStems(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), ref, flags, offset, ys_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys_type + "') for param ys");
            };

            PlotStems_adapt_c_buffers(label_id, xs, ys, ref, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("ref") = 0, py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_inf_lines",
        [](const char * label_id, const py::array & values, ImPlotInfLinesFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotInfLines_adapt_c_buffers = [](const char * label_id, const py::array & values, ImPlotInfLinesFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int values_stride = stride;
                if (values_stride == -1)
                    values_stride = (int)values.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotInfLines(label_id, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'b')
                    ImPlot::PlotInfLines(label_id, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'H')
                    ImPlot::PlotInfLines(label_id, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'h')
                    ImPlot::PlotInfLines(label_id, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'I')
                    ImPlot::PlotInfLines(label_id, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'i')
                    ImPlot::PlotInfLines(label_id, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'L')
                    ImPlot::PlotInfLines(label_id, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'l')
                    ImPlot::PlotInfLines(label_id, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'f')
                    ImPlot::PlotInfLines(label_id, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'd')
                    ImPlot::PlotInfLines(label_id, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'g')
                    ImPlot::PlotInfLines(label_id, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                else if (values_type == 'q')
                    ImPlot::PlotInfLines(label_id, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), flags, offset, values_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };

            PlotInfLines_adapt_c_buffers(label_id, values, flags, offset, stride);
        },
        py::arg("label_id"), py::arg("values"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1,
        "Plots infinite vertical or horizontal lines (e.g. for references or asymptotes).");

    m.def("plot_pie_chart",
        [](const std::vector<std::string> & label_ids, const py::array & values, double x, double y, double radius, const char * label_fmt = "%.1f", double angle0 = 90, ImPlotPieChartFlags flags = 0)
        {
            auto PlotPieChart_adapt_c_buffers = [](const char * const label_ids[], const py::array & values, double x, double y, double radius, const char * label_fmt = "%.1f", double angle0 = 90, ImPlotPieChartFlags flags = 0)
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    ImPlot::PlotPieChart(label_ids, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'b')
                    ImPlot::PlotPieChart(label_ids, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'H')
                    ImPlot::PlotPieChart(label_ids, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'h')
                    ImPlot::PlotPieChart(label_ids, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'I')
                    ImPlot::PlotPieChart(label_ids, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'i')
                    ImPlot::PlotPieChart(label_ids, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'L')
                    ImPlot::PlotPieChart(label_ids, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'l')
                    ImPlot::PlotPieChart(label_ids, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'f')
                    ImPlot::PlotPieChart(label_ids, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'd')
                    ImPlot::PlotPieChart(label_ids, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'g')
                    ImPlot::PlotPieChart(label_ids, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                else if (values_type == 'q')
                    ImPlot::PlotPieChart(label_ids, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), x, y, radius, label_fmt, angle0, flags);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };
            auto PlotPieChart_adapt_c_string_list_no_count = [&PlotPieChart_adapt_c_buffers](const std::vector<std::string> & label_ids, const py::array & values, double x, double y, double radius, const char * label_fmt = "%.1f", double angle0 = 90, ImPlotPieChartFlags flags = 0)
            {
                std::vector<const char *> label_ids_ptrs;
                for (const auto& v: label_ids)
                    label_ids_ptrs.push_back(v.c_str());

                PlotPieChart_adapt_c_buffers(label_ids_ptrs.data(), values, x, y, radius, label_fmt, angle0, flags);
            };

            PlotPieChart_adapt_c_string_list_no_count(label_ids, values, x, y, radius, label_fmt, angle0, flags);
        },     py::arg("label_ids"), py::arg("values"), py::arg("x"), py::arg("y"), py::arg("radius"), py::arg("label_fmt") = "%.1f", py::arg("angle0") = 90, py::arg("flags") = 0);

    m.def("plot_histogram",
        [](const char * label_id, const py::array & values, int bins = ImPlotBin_Sturges, double bar_scale = 1.0, ImPlotRange range = ImPlotRange(), ImPlotHistogramFlags flags = 0) -> double
        {
            auto PlotHistogram_adapt_c_buffers = [](const char * label_id, const py::array & values, int bins = ImPlotBin_Sturges, double bar_scale = 1.0, ImPlotRange range = ImPlotRange(), ImPlotHistogramFlags flags = 0) -> double
            {
                // convert py::array to C standard buffer (const)
                const void * values_from_pyarray = values.data();
                py::ssize_t values_count = values.shape()[0];

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char values_type = values.dtype().char_();
                if (values_type == 'B')
                    return ImPlot::PlotHistogram(label_id, static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'b')
                    return ImPlot::PlotHistogram(label_id, static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'H')
                    return ImPlot::PlotHistogram(label_id, static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'h')
                    return ImPlot::PlotHistogram(label_id, static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'I')
                    return ImPlot::PlotHistogram(label_id, static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'i')
                    return ImPlot::PlotHistogram(label_id, static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'L')
                    return ImPlot::PlotHistogram(label_id, static_cast<const np_uint_l *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'l')
                    return ImPlot::PlotHistogram(label_id, static_cast<const np_int_l *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'f')
                    return ImPlot::PlotHistogram(label_id, static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'd')
                    return ImPlot::PlotHistogram(label_id, static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'g')
                    return ImPlot::PlotHistogram(label_id, static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                else if (values_type == 'q')
                    return ImPlot::PlotHistogram(label_id, static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count), bins, bar_scale, range, flags);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
            };

            return PlotHistogram_adapt_c_buffers(label_id, values, bins, bar_scale, range, flags);
        },
        py::arg("label_id"), py::arg("values"), py::arg("bins") = ImPlotBin_Sturges, py::arg("bar_scale") = 1.0, py::arg("range") = ImPlotRange(), py::arg("flags") = 0,
        " Plots a horizontal histogram. #bins can be a positive integer or an ImPlotBin_ method. If #range is left unspecified, the min/max of #values will be used as the range.\n Otherwise, outlier values outside of the range are not binned. The largest bin count or density is returned.");

    m.def("plot_histogram2_d",
        [](const char * label_id, const py::array & xs, const py::array & ys, int x_bins = ImPlotBin_Sturges, int y_bins = ImPlotBin_Sturges, ImPlotRect range = ImPlotRect(), ImPlotHistogramFlags flags = 0) -> double
        {
            auto PlotHistogram2D_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, int x_bins = ImPlotBin_Sturges, int y_bins = ImPlotBin_Sturges, ImPlotRect range = ImPlotRect(), ImPlotHistogramFlags flags = 0) -> double
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys_type = ys.dtype().char_();
                if (ys_type == 'B')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'b')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'H')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'h')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'I')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'i')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'L')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'l')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'f')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'd')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'g')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                else if (ys_type == 'q')
                    return ImPlot::PlotHistogram2D(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), x_bins, y_bins, range, flags);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys_type + "') for param ys");
            };

            return PlotHistogram2D_adapt_c_buffers(label_id, xs, ys, x_bins, y_bins, range, flags);
        },
        py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("x_bins") = ImPlotBin_Sturges, py::arg("y_bins") = ImPlotBin_Sturges, py::arg("range") = ImPlotRect(), py::arg("flags") = 0,
        " Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of\n #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.");

    m.def("plot_digital",
        [](const char * label_id, const py::array & xs, const py::array & ys, ImPlotDigitalFlags flags = 0, int offset = 0, int stride = -1)
        {
            auto PlotDigital_adapt_c_buffers = [](const char * label_id, const py::array & xs, const py::array & ys, ImPlotDigitalFlags flags = 0, int offset = 0, int stride = -1)
            {
                // convert py::array to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                py::ssize_t xs_count = xs.shape()[0];

                // convert py::array to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                py::ssize_t ys_count = ys.shape()[0];

                // process stride default value (which was a sizeof in C++)
                int ys_stride = stride;
                if (ys_stride == -1)
                    ys_stride = (int)ys.itemsize();

                #ifdef _WIN32
                using np_uint_l = uint32_t;
                using np_int_l = int32_t;
                #else
                using np_uint_l = uint64_t;
                using np_int_l = int64_t;
                #endif
                // call the correct template version by casting
                char ys_type = ys.dtype().char_();
                if (ys_type == 'B')
                    ImPlot::PlotDigital(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'b')
                    ImPlot::PlotDigital(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'H')
                    ImPlot::PlotDigital(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'h')
                    ImPlot::PlotDigital(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'I')
                    ImPlot::PlotDigital(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'i')
                    ImPlot::PlotDigital(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'L')
                    ImPlot::PlotDigital(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'l')
                    ImPlot::PlotDigital(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'f')
                    ImPlot::PlotDigital(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'd')
                    ImPlot::PlotDigital(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'g')
                    ImPlot::PlotDigital(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                else if (ys_type == 'q')
                    ImPlot::PlotDigital(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), flags, offset, ys_stride);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + ys_type + "') for param ys");
            };

            PlotDigital_adapt_c_buffers(label_id, xs, ys, flags, offset, stride);
        },     py::arg("label_id"), py::arg("xs"), py::arg("ys"), py::arg("flags") = 0, py::arg("offset") = 0, py::arg("stride") = -1);

    m.def("plot_image",
        ImPlot::PlotImage,
        py::arg("label_id"), py::arg("user_texture_id"), py::arg("bounds_min"), py::arg("bounds_max"), py::arg("uv0") = ImVec2(0,0), py::arg("uv1") = ImVec2(1,1), py::arg("tint_col") = ImVec4(1,1,1,1), py::arg("flags") = 0,
        "Plots an axis-aligned image. #bounds_min/bounds_max are in plot coordinates (y-up) and #uv0/uv1 are in texture coordinates (y-down).");

    m.def("plot_text",
        ImPlot::PlotText,
        py::arg("text"), py::arg("x"), py::arg("y"), py::arg("pix_offset") = ImVec2(0,0), py::arg("flags") = 0,
        "Plots a centered text label at point x,y with an optional pixel offset. Text color can be changed with ImPlot::PushStyleColor(ImPlotCol_InlayText, ...).");

    m.def("plot_dummy",
        ImPlot::PlotDummy,
        py::arg("label_id"), py::arg("flags") = 0,
        "Plots a dummy item (i.e. adds a legend entry colored by ImPlotCol_Line)");

    m.def("drag_point",
        [](int id, double x, double y, const ImVec4 & col, float size = 4, ImPlotDragToolFlags flags = 0, std::optional<bool> out_clicked = std::nullopt, std::optional<bool> out_hovered = std::nullopt, std::optional<bool> held = std::nullopt) -> std::tuple<bool, double, double, std::optional<bool>, std::optional<bool>, std::optional<bool>>
        {
            auto DragPoint_adapt_modifiable_immutable_to_return = [](int id, double x, double y, const ImVec4 & col, float size = 4, ImPlotDragToolFlags flags = 0, std::optional<bool> out_clicked = std::nullopt, std::optional<bool> out_hovered = std::nullopt, std::optional<bool> held = std::nullopt) -> std::tuple<bool, double, double, std::optional<bool>, std::optional<bool>, std::optional<bool>>
            {
                double * x_adapt_modifiable = & x;
                double * y_adapt_modifiable = & y;
                bool * out_clicked_adapt_modifiable = nullptr;
                if (out_clicked.has_value())
                    out_clicked_adapt_modifiable = & (*out_clicked);
                bool * out_hovered_adapt_modifiable = nullptr;
                if (out_hovered.has_value())
                    out_hovered_adapt_modifiable = & (*out_hovered);
                bool * held_adapt_modifiable = nullptr;
                if (held.has_value())
                    held_adapt_modifiable = & (*held);

                bool r = ImPlot::DragPoint(id, x_adapt_modifiable, y_adapt_modifiable, col, size, flags, out_clicked_adapt_modifiable, out_hovered_adapt_modifiable, held_adapt_modifiable);
                return std::make_tuple(r, x, y, out_clicked, out_hovered, held);
            };

            return DragPoint_adapt_modifiable_immutable_to_return(id, x, y, col, size, flags, out_clicked, out_hovered, held);
        },
        py::arg("id_"), py::arg("x"), py::arg("y"), py::arg("col"), py::arg("size") = 4, py::arg("flags") = 0, py::arg("out_clicked") = py::none(), py::arg("out_hovered") = py::none(), py::arg("held") = py::none(),
        "Shows a draggable point at x,y. #col defaults to ImGuiCol_Text.");

    m.def("drag_line_x",
        [](int id, double x, const ImVec4 & col, float thickness = 1, ImPlotDragToolFlags flags = 0, std::optional<bool> out_clicked = std::nullopt, std::optional<bool> out_hovered = std::nullopt, std::optional<bool> held = std::nullopt) -> std::tuple<bool, double, std::optional<bool>, std::optional<bool>, std::optional<bool>>
        {
            auto DragLineX_adapt_modifiable_immutable_to_return = [](int id, double x, const ImVec4 & col, float thickness = 1, ImPlotDragToolFlags flags = 0, std::optional<bool> out_clicked = std::nullopt, std::optional<bool> out_hovered = std::nullopt, std::optional<bool> held = std::nullopt) -> std::tuple<bool, double, std::optional<bool>, std::optional<bool>, std::optional<bool>>
            {
                double * x_adapt_modifiable = & x;
                bool * out_clicked_adapt_modifiable = nullptr;
                if (out_clicked.has_value())
                    out_clicked_adapt_modifiable = & (*out_clicked);
                bool * out_hovered_adapt_modifiable = nullptr;
                if (out_hovered.has_value())
                    out_hovered_adapt_modifiable = & (*out_hovered);
                bool * held_adapt_modifiable = nullptr;
                if (held.has_value())
                    held_adapt_modifiable = & (*held);

                bool r = ImPlot::DragLineX(id, x_adapt_modifiable, col, thickness, flags, out_clicked_adapt_modifiable, out_hovered_adapt_modifiable, held_adapt_modifiable);
                return std::make_tuple(r, x, out_clicked, out_hovered, held);
            };

            return DragLineX_adapt_modifiable_immutable_to_return(id, x, col, thickness, flags, out_clicked, out_hovered, held);
        },
        py::arg("id_"), py::arg("x"), py::arg("col"), py::arg("thickness") = 1, py::arg("flags") = 0, py::arg("out_clicked") = py::none(), py::arg("out_hovered") = py::none(), py::arg("held") = py::none(),
        "Shows a draggable vertical guide line at an x-value. #col defaults to ImGuiCol_Text.");

    m.def("drag_line_y",
        [](int id, double y, const ImVec4 & col, float thickness = 1, ImPlotDragToolFlags flags = 0, std::optional<bool> out_clicked = std::nullopt, std::optional<bool> out_hovered = std::nullopt, std::optional<bool> held = std::nullopt) -> std::tuple<bool, double, std::optional<bool>, std::optional<bool>, std::optional<bool>>
        {
            auto DragLineY_adapt_modifiable_immutable_to_return = [](int id, double y, const ImVec4 & col, float thickness = 1, ImPlotDragToolFlags flags = 0, std::optional<bool> out_clicked = std::nullopt, std::optional<bool> out_hovered = std::nullopt, std::optional<bool> held = std::nullopt) -> std::tuple<bool, double, std::optional<bool>, std::optional<bool>, std::optional<bool>>
            {
                double * y_adapt_modifiable = & y;
                bool * out_clicked_adapt_modifiable = nullptr;
                if (out_clicked.has_value())
                    out_clicked_adapt_modifiable = & (*out_clicked);
                bool * out_hovered_adapt_modifiable = nullptr;
                if (out_hovered.has_value())
                    out_hovered_adapt_modifiable = & (*out_hovered);
                bool * held_adapt_modifiable = nullptr;
                if (held.has_value())
                    held_adapt_modifiable = & (*held);

                bool r = ImPlot::DragLineY(id, y_adapt_modifiable, col, thickness, flags, out_clicked_adapt_modifiable, out_hovered_adapt_modifiable, held_adapt_modifiable);
                return std::make_tuple(r, y, out_clicked, out_hovered, held);
            };

            return DragLineY_adapt_modifiable_immutable_to_return(id, y, col, thickness, flags, out_clicked, out_hovered, held);
        },
        py::arg("id_"), py::arg("y"), py::arg("col"), py::arg("thickness") = 1, py::arg("flags") = 0, py::arg("out_clicked") = py::none(), py::arg("out_hovered") = py::none(), py::arg("held") = py::none(),
        "Shows a draggable horizontal guide line at a y-value. #col defaults to ImGuiCol_Text.");

    m.def("drag_rect",
        [](int id, double x1, double y1, double x2, double y2, const ImVec4 & col, ImPlotDragToolFlags flags = 0, std::optional<bool> out_clicked = std::nullopt, std::optional<bool> out_hovered = std::nullopt, std::optional<bool> held = std::nullopt) -> std::tuple<bool, double, double, double, double, std::optional<bool>, std::optional<bool>, std::optional<bool>>
        {
            auto DragRect_adapt_modifiable_immutable_to_return = [](int id, double x1, double y1, double x2, double y2, const ImVec4 & col, ImPlotDragToolFlags flags = 0, std::optional<bool> out_clicked = std::nullopt, std::optional<bool> out_hovered = std::nullopt, std::optional<bool> held = std::nullopt) -> std::tuple<bool, double, double, double, double, std::optional<bool>, std::optional<bool>, std::optional<bool>>
            {
                double * x1_adapt_modifiable = & x1;
                double * y1_adapt_modifiable = & y1;
                double * x2_adapt_modifiable = & x2;
                double * y2_adapt_modifiable = & y2;
                bool * out_clicked_adapt_modifiable = nullptr;
                if (out_clicked.has_value())
                    out_clicked_adapt_modifiable = & (*out_clicked);
                bool * out_hovered_adapt_modifiable = nullptr;
                if (out_hovered.has_value())
                    out_hovered_adapt_modifiable = & (*out_hovered);
                bool * held_adapt_modifiable = nullptr;
                if (held.has_value())
                    held_adapt_modifiable = & (*held);

                bool r = ImPlot::DragRect(id, x1_adapt_modifiable, y1_adapt_modifiable, x2_adapt_modifiable, y2_adapt_modifiable, col, flags, out_clicked_adapt_modifiable, out_hovered_adapt_modifiable, held_adapt_modifiable);
                return std::make_tuple(r, x1, y1, x2, y2, out_clicked, out_hovered, held);
            };

            return DragRect_adapt_modifiable_immutable_to_return(id, x1, y1, x2, y2, col, flags, out_clicked, out_hovered, held);
        },
        py::arg("id_"), py::arg("x1"), py::arg("y1"), py::arg("x2"), py::arg("y2"), py::arg("col"), py::arg("flags") = 0, py::arg("out_clicked") = py::none(), py::arg("out_hovered") = py::none(), py::arg("held") = py::none(),
        "Shows a draggable and resizeable rectangle.");

    m.def("annotation",
        py::overload_cast<double, double, const ImVec4 &, const ImVec2 &, bool, bool>(ImPlot::Annotation), py::arg("x"), py::arg("y"), py::arg("col"), py::arg("pix_offset"), py::arg("clamp"), py::arg("round") = false);

    m.def("annotation",
        [](double x, double y, const ImVec4 & col, const ImVec2 & pix_offset, bool clamp, const char * fmt)
        {
            auto Annotation_adapt_variadic_format = [](double x, double y, const ImVec4 & col, const ImVec2 & pix_offset, bool clamp, const char * fmt)
            {
                ImPlot::Annotation(x, y, col, pix_offset, clamp, "%s", fmt);
            };

            Annotation_adapt_variadic_format(x, y, col, pix_offset, clamp, fmt);
        },     py::arg("x"), py::arg("y"), py::arg("col"), py::arg("pix_offset"), py::arg("clamp"), py::arg("fmt"));

    m.def("tag_x",
        py::overload_cast<double, const ImVec4 &, bool>(ImPlot::TagX), py::arg("x"), py::arg("col"), py::arg("round") = false);

    m.def("tag_x",
        [](double x, const ImVec4 & col, const char * fmt)
        {
            auto TagX_adapt_variadic_format = [](double x, const ImVec4 & col, const char * fmt)
            {
                ImPlot::TagX(x, col, "%s", fmt);
            };

            TagX_adapt_variadic_format(x, col, fmt);
        },     py::arg("x"), py::arg("col"), py::arg("fmt"));

    m.def("tag_y",
        py::overload_cast<double, const ImVec4 &, bool>(ImPlot::TagY), py::arg("y"), py::arg("col"), py::arg("round") = false);

    m.def("tag_y",
        [](double y, const ImVec4 & col, const char * fmt)
        {
            auto TagY_adapt_variadic_format = [](double y, const ImVec4 & col, const char * fmt)
            {
                ImPlot::TagY(y, col, "%s", fmt);
            };

            TagY_adapt_variadic_format(y, col, fmt);
        },     py::arg("y"), py::arg("col"), py::arg("fmt"));

    m.def("set_axis",
        ImPlot::SetAxis, py::arg("axis"));

    m.def("set_axes",
        ImPlot::SetAxes, py::arg("x_axis"), py::arg("y_axis"));

    m.def("pixels_to_plot",
        py::overload_cast<const ImVec2 &, ImAxis, ImAxis>(ImPlot::PixelsToPlot), py::arg("pix"), py::arg("x_axis") = IMPLOT_AUTO, py::arg("y_axis") = IMPLOT_AUTO);

    m.def("pixels_to_plot",
        py::overload_cast<float, float, ImAxis, ImAxis>(ImPlot::PixelsToPlot), py::arg("x"), py::arg("y"), py::arg("x_axis") = IMPLOT_AUTO, py::arg("y_axis") = IMPLOT_AUTO);

    m.def("plot_to_pixels",
        py::overload_cast<const ImPlotPoint &, ImAxis, ImAxis>(ImPlot::PlotToPixels), py::arg("plt"), py::arg("x_axis") = IMPLOT_AUTO, py::arg("y_axis") = IMPLOT_AUTO);

    m.def("plot_to_pixels",
        py::overload_cast<double, double, ImAxis, ImAxis>(ImPlot::PlotToPixels), py::arg("x"), py::arg("y"), py::arg("x_axis") = IMPLOT_AUTO, py::arg("y_axis") = IMPLOT_AUTO);

    m.def("get_plot_pos",
        ImPlot::GetPlotPos, "Get the current Plot position (top-left) in pixels.");

    m.def("get_plot_size",
        ImPlot::GetPlotSize, "Get the curent Plot size in pixels.");

    m.def("get_plot_mouse_pos",
        ImPlot::GetPlotMousePos,
        py::arg("x_axis") = IMPLOT_AUTO, py::arg("y_axis") = IMPLOT_AUTO,
        "Returns the mouse position in x,y coordinates of the current plot. Passing IMPLOT_AUTO uses the current axes.");

    m.def("get_plot_limits",
        ImPlot::GetPlotLimits,
        py::arg("x_axis") = IMPLOT_AUTO, py::arg("y_axis") = IMPLOT_AUTO,
        "Returns the current plot axis range.");

    m.def("is_plot_hovered",
        ImPlot::IsPlotHovered, "Returns True if the plot area in the current plot is hovered.");

    m.def("is_axis_hovered",
        ImPlot::IsAxisHovered,
        py::arg("axis"),
        "Returns True if the axis label area in the current plot is hovered.");

    m.def("is_subplots_hovered",
        ImPlot::IsSubplotsHovered, "Returns True if the bounding frame of a subplot is hovered.");

    m.def("is_plot_selected",
        ImPlot::IsPlotSelected, "Returns True if the current plot is being box selected.");

    m.def("get_plot_selection",
        ImPlot::GetPlotSelection,
        py::arg("x_axis") = IMPLOT_AUTO, py::arg("y_axis") = IMPLOT_AUTO,
        "Returns the current plot box selection bounds. Passing IMPLOT_AUTO uses the current axes.");

    m.def("cancel_plot_selection",
        ImPlot::CancelPlotSelection, "Cancels a the current plot box selection.");

    m.def("hide_next_item",
        ImPlot::HideNextItem,
        py::arg("hidden") = true, py::arg("cond") = ImPlotCond_Once,
        " Hides or shows the next plot item (i.e. as if it were toggled from the legend).\n Use ImPlotCond_Always if you need to forcefully set this every frame.");

    m.def("begin_aligned_plots",
        ImPlot::BeginAlignedPlots,
        py::arg("group_id"), py::arg("vertical") = true,
        " Align axis padding over multiple plots in a single row or column. #group_id must\n be unique. If this function returns True, EndAlignedPlots() must be called.");

    m.def("end_aligned_plots",
        ImPlot::EndAlignedPlots, "Only call EndAlignedPlots() if BeginAlignedPlots() returns True!");

    m.def("begin_legend_popup",
        ImPlot::BeginLegendPopup,
        py::arg("label_id"), py::arg("mouse_button") = 1,
        "Begin a popup for a legend entry.");

    m.def("end_legend_popup",
        ImPlot::EndLegendPopup, "End a popup for a legend entry.");

    m.def("is_legend_entry_hovered",
        ImPlot::IsLegendEntryHovered,
        py::arg("label_id"),
        "Returns True if a plot item legend entry is hovered.");

    m.def("begin_drag_drop_target_plot",
        ImPlot::BeginDragDropTargetPlot, "Turns the current plot's plotting area into a drag and drop target. Don't forget to call EndDragDropTarget!");

    m.def("begin_drag_drop_target_axis",
        ImPlot::BeginDragDropTargetAxis,
        py::arg("axis"),
        "Turns the current plot's X-axis into a drag and drop target. Don't forget to call EndDragDropTarget!");

    m.def("begin_drag_drop_target_legend",
        ImPlot::BeginDragDropTargetLegend, "Turns the current plot's legend into a drag and drop target. Don't forget to call EndDragDropTarget!");

    m.def("end_drag_drop_target",
        ImPlot::EndDragDropTarget, "Ends a drag and drop target (currently just an alias for ImGui::EndDragDropTarget).");

    m.def("begin_drag_drop_source_plot",
        ImPlot::BeginDragDropSourcePlot,
        py::arg("flags") = 0,
        "Turns the current plot's plotting area into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!");

    m.def("begin_drag_drop_source_axis",
        ImPlot::BeginDragDropSourceAxis,
        py::arg("axis"), py::arg("flags") = 0,
        "Turns the current plot's X-axis into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!");

    m.def("begin_drag_drop_source_item",
        ImPlot::BeginDragDropSourceItem,
        py::arg("label_id"), py::arg("flags") = 0,
        "Turns an item in the current plot's legend into drag and drop source. Don't forget to call EndDragDropSource!");

    m.def("end_drag_drop_source",
        ImPlot::EndDragDropSource, "Ends a drag and drop source (currently just an alias for ImGui::EndDragDropSource).");

    m.def("get_style",
        ImPlot::GetStyle,
        "Provides access to plot style structure for permanant modifications to colors, sizes, etc.",
        pybind11::return_value_policy::reference);

    m.def("style_colors_auto",
        ImPlot::StyleColorsAuto,
        py::arg("dst") = py::none(),
        "Style plot colors for current ImGui style (default).");

    m.def("style_colors_classic",
        ImPlot::StyleColorsClassic,
        py::arg("dst") = py::none(),
        "Style plot colors for ImGui \"Classic\".");

    m.def("style_colors_dark",
        ImPlot::StyleColorsDark,
        py::arg("dst") = py::none(),
        "Style plot colors for ImGui \"Dark\".");

    m.def("style_colors_light",
        ImPlot::StyleColorsLight,
        py::arg("dst") = py::none(),
        "Style plot colors for ImGui \"Light\".");

    m.def("push_style_color",
        py::overload_cast<ImPlotCol, ImU32>(ImPlot::PushStyleColor), py::arg("idx"), py::arg("col"));

    m.def("push_style_color",
        py::overload_cast<ImPlotCol, const ImVec4 &>(ImPlot::PushStyleColor), py::arg("idx"), py::arg("col"));

    m.def("pop_style_color",
        ImPlot::PopStyleColor,
        py::arg("count") = 1,
        "Undo temporary style color modification(s). Undo multiple pushes at once by increasing count.");

    m.def("push_style_var",
        py::overload_cast<ImPlotStyleVar, float>(ImPlot::PushStyleVar),
        py::arg("idx"), py::arg("val"),
        "Temporarily modify a style variable of float type. Don't forget to call PopStyleVar!");

    m.def("push_style_var",
        py::overload_cast<ImPlotStyleVar, int>(ImPlot::PushStyleVar),
        py::arg("idx"), py::arg("val"),
        "Temporarily modify a style variable of int type. Don't forget to call PopStyleVar!");

    m.def("push_style_var",
        py::overload_cast<ImPlotStyleVar, const ImVec2 &>(ImPlot::PushStyleVar),
        py::arg("idx"), py::arg("val"),
        "Temporarily modify a style variable of ImVec2 type. Don't forget to call PopStyleVar!");

    m.def("pop_style_var",
        ImPlot::PopStyleVar,
        py::arg("count") = 1,
        "Undo temporary style variable modification(s). Undo multiple pushes at once by increasing count.");

    m.def("set_next_line_style",
        ImPlot::SetNextLineStyle,
        py::arg("col") = IMPLOT_AUTO_COL, py::arg("weight") = IMPLOT_AUTO,
        "Set the line color and weight for the next item only.");

    m.def("set_next_fill_style",
        ImPlot::SetNextFillStyle,
        py::arg("col") = IMPLOT_AUTO_COL, py::arg("alpha_mod") = IMPLOT_AUTO,
        "Set the fill color for the next item only.");

    m.def("set_next_marker_style",
        ImPlot::SetNextMarkerStyle,
        py::arg("marker") = IMPLOT_AUTO, py::arg("size") = IMPLOT_AUTO, py::arg("fill") = IMPLOT_AUTO_COL, py::arg("weight") = IMPLOT_AUTO, py::arg("outline") = IMPLOT_AUTO_COL,
        "Set the marker style for the next item only.");

    m.def("set_next_error_bar_style",
        ImPlot::SetNextErrorBarStyle,
        py::arg("col") = IMPLOT_AUTO_COL, py::arg("size") = IMPLOT_AUTO, py::arg("weight") = IMPLOT_AUTO,
        "Set the error bar style for the next item only.");

    m.def("get_last_item_color",
        ImPlot::GetLastItemColor, "Gets the last item primary color (i.e. its legend icon color)");

    m.def("get_style_color_name",
        ImPlot::GetStyleColorName,
        py::arg("idx"),
        "Returns the null terminated string name for an ImPlotCol.",
        pybind11::return_value_policy::reference);

    m.def("get_marker_name",
        ImPlot::GetMarkerName,
        py::arg("idx"),
        "Returns the null terminated string name for an ImPlotMarker.",
        pybind11::return_value_policy::reference);

    m.def("get_colormap_count",
        ImPlot::GetColormapCount, "Returns the number of available colormaps (i.e. the built-in + user-added count).");

    m.def("get_colormap_name",
        ImPlot::GetColormapName,
        py::arg("cmap"),
        "Returns a null terminated string name for a colormap given an index. Returns None if index is invalid.",
        pybind11::return_value_policy::reference);

    m.def("get_colormap_index",
        ImPlot::GetColormapIndex,
        py::arg("name"),
        "Returns an index number for a colormap given a valid string name. Returns -1 if name is invalid.");

    m.def("push_colormap",
        py::overload_cast<ImPlotColormap>(ImPlot::PushColormap),
        py::arg("cmap"),
        "Temporarily switch to one of the built-in (i.e. ImPlotColormap_XXX) or user-added colormaps (i.e. a return value of AddColormap). Don't forget to call PopColormap!");

    m.def("push_colormap",
        py::overload_cast<const char *>(ImPlot::PushColormap),
        py::arg("name"),
        "Push a colormap by string name. Use built-in names such as \"Default\", \"Deep\", \"Jet\", etc. or a string you provided to AddColormap. Don't forget to call PopColormap!");

    m.def("pop_colormap",
        ImPlot::PopColormap,
        py::arg("count") = 1,
        "Undo temporary colormap modification(s). Undo multiple pushes at once by increasing count.");

    m.def("next_colormap_color",
        ImPlot::NextColormapColor, " Returns the next color from the current colormap and advances the colormap for the current plot.\n Can also be used with no return value to skip colors if desired. You need to call this between Begin/EndPlot!");

    m.def("get_colormap_size",
        ImPlot::GetColormapSize,
        py::arg("cmap") = IMPLOT_AUTO,
        "Returns the size of a colormap.");

    m.def("get_colormap_color",
        ImPlot::GetColormapColor,
        py::arg("idx"), py::arg("cmap") = IMPLOT_AUTO,
        "Returns a color from a colormap given an index >= 0 (modulo will be performed).");

    m.def("sample_colormap",
        ImPlot::SampleColormap,
        py::arg("t"), py::arg("cmap") = IMPLOT_AUTO,
        "Sample a color from the current colormap given t between 0 and 1.");

    m.def("colormap_scale",
        ImPlot::ColormapScale,
        py::arg("label"), py::arg("scale_min"), py::arg("scale_max"), py::arg("size") = ImVec2(0,0), py::arg("format") = "%g", py::arg("flags") = 0, py::arg("cmap") = IMPLOT_AUTO,
        "Shows a vertical color scale with linear spaced ticks using the specified color map. Use double hashes to hide label (e.g. \"##NoLabel\"). If scale_min > scale_max, the scale to color mapping will be reversed.");

    m.def("colormap_slider",
        [](const char * label, float t, ImVec4 * out = nullptr, const char * format = "", ImPlotColormap cmap = IMPLOT_AUTO) -> std::tuple<bool, float>
        {
            auto ColormapSlider_adapt_modifiable_immutable_to_return = [](const char * label, float t, ImVec4 * out = nullptr, const char * format = "", ImPlotColormap cmap = IMPLOT_AUTO) -> std::tuple<bool, float>
            {
                float * t_adapt_modifiable = & t;

                bool r = ImPlot::ColormapSlider(label, t_adapt_modifiable, out, format, cmap);
                return std::make_tuple(r, t);
            };

            return ColormapSlider_adapt_modifiable_immutable_to_return(label, t, out, format, cmap);
        },
        py::arg("label"), py::arg("t"), py::arg("out") = py::none(), py::arg("format") = "", py::arg("cmap") = IMPLOT_AUTO,
        "Shows a horizontal slider with a colormap gradient background. Optionally returns the color sampled at t in [0 1].");

    m.def("colormap_button",
        ImPlot::ColormapButton,
        py::arg("label"), py::arg("size") = ImVec2(0,0), py::arg("cmap") = IMPLOT_AUTO,
        "Shows a button with a colormap gradient brackground.");

    m.def("bust_color_cache",
        ImPlot::BustColorCache,
        py::arg("plot_title_id") = py::none(),
        " When items in a plot sample their color from a colormap, the color is cached and does not change\n unless explicitly overriden. Therefore, if you change the colormap after the item has already been plotted,\n item colors will NOT update. If you need item colors to resample the new colormap, then use this\n function to bust the cached colors. If #plot_title_id is None, then every item in EVERY existing plot\n will be cache busted. Otherwise only the plot specified by #plot_title_id will be busted. For the\n latter, this function must be called in the same ImGui ID scope that the plot is in. You should rarely if ever\n need this function, but it is available for applications that require runtime colormap swaps (e.g. Heatmaps demo).");

    m.def("get_input_map",
        ImPlot::GetInputMap,
        "Provides access to input mapping structure for permanant modifications to controls for pan, select, etc.",
        pybind11::return_value_policy::reference);

    m.def("map_input_default",
        ImPlot::MapInputDefault,
        py::arg("dst") = py::none(),
        "Default input mapping: pan = LMB drag, box select = RMB drag, fit = LMB double click, context menu = RMB click, zoom = scroll.");

    m.def("map_input_reverse",
        ImPlot::MapInputReverse,
        py::arg("dst") = py::none(),
        "Reverse input mapping: pan = RMB drag, box select = LMB drag, fit = LMB double click, context menu = RMB click, zoom = scroll.");

    m.def("item_icon",
        py::overload_cast<const ImVec4 &>(ImPlot::ItemIcon), py::arg("col"));

    m.def("item_icon",
        py::overload_cast<ImU32>(ImPlot::ItemIcon), py::arg("col"));

    m.def("colormap_icon",
        ImPlot::ColormapIcon, py::arg("cmap"));

    m.def("get_plot_draw_list",
        ImPlot::GetPlotDrawList,
        "Get the plot draw list for custom rendering to the current plot area. Call between Begin/EndPlot.",
        pybind11::return_value_policy::reference);

    m.def("push_plot_clip_rect",
        ImPlot::PushPlotClipRect,
        py::arg("expand") = 0,
        "Push clip rect for rendering to current plot area. The rect can be expanded or contracted by #expand pixels. Call between Begin/EndPlot.");

    m.def("pop_plot_clip_rect",
        ImPlot::PopPlotClipRect, "Pop plot clip rect. Call between Begin/EndPlot.");

    m.def("show_style_selector",
        ImPlot::ShowStyleSelector,
        py::arg("label"),
        "Shows ImPlot style selector dropdown menu.");

    m.def("show_colormap_selector",
        ImPlot::ShowColormapSelector,
        py::arg("label"),
        "Shows ImPlot colormap selector dropdown menu.");

    m.def("show_input_map_selector",
        ImPlot::ShowInputMapSelector,
        py::arg("label"),
        "Shows ImPlot input map selector dropdown menu.");

    m.def("show_style_editor",
        ImPlot::ShowStyleEditor,
        py::arg("ref") = py::none(),
        "Shows ImPlot style editor block (not a window).");

    m.def("show_user_guide",
        ImPlot::ShowUserGuide, "Add basic help/info block for end users (not a window).");

    m.def("show_metrics_window",
        [](std::optional<bool> p_popen = std::nullopt) -> std::optional<bool>
        {
            auto ShowMetricsWindow_adapt_modifiable_immutable_to_return = [](std::optional<bool> p_popen = std::nullopt) -> std::optional<bool>
            {
                bool * p_popen_adapt_modifiable = nullptr;
                if (p_popen.has_value())
                    p_popen_adapt_modifiable = & (*p_popen);

                ImPlot::ShowMetricsWindow(p_popen_adapt_modifiable);
                return p_popen;
            };

            return ShowMetricsWindow_adapt_modifiable_immutable_to_return(p_popen);
        },
        py::arg("p_popen") = py::none(),
        "Shows ImPlot metrics/debug information window.");

    m.def("show_demo_window",
        [](std::optional<bool> p_open = std::nullopt) -> std::optional<bool>
        {
            auto ShowDemoWindow_adapt_modifiable_immutable_to_return = [](std::optional<bool> p_open = std::nullopt) -> std::optional<bool>
            {
                bool * p_open_adapt_modifiable = nullptr;
                if (p_open.has_value())
                    p_open_adapt_modifiable = & (*p_open);

                ImPlot::ShowDemoWindow(p_open_adapt_modifiable);
                return p_open;
            };

            return ShowDemoWindow_adapt_modifiable_immutable_to_return(p_open);
        },
        py::arg("p_open") = py::none(),
        "Shows the ImPlot demo window (add implot_demo.cpp to your sources!)");
    ////////////////////    </generated_from:implot.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    ///////////////////////////////////////////////////////////////////////////
    // MANUAL BINDINGS BELOW
    ///////////////////////////////////////////////////////////////////////////

    // Add a new colormap, inputs are np.array[uint32]
    m.def("add_colormap",
        [](const char * name, const py::array & cols, bool qual=true)
        {
            const void * values_from_pyarray = cols.data();

            int ndim = cols.ndim();
            int rows = static_cast<int>(cols.shape()[0]);
            int columns = ndim >= 2 ? static_cast<int>(cols.shape()[1]) : -1;

            char cols_type = cols.dtype().char_();
            bool is_uint32 = is_py_array_unsigned_integer(cols) && cols.itemsize() == 4;

            if (is_uint32 && (ndim == 1))
                return ImPlot::AddColormap(name, static_cast<const uint32_t *>(values_from_pyarray), rows, qual);
            else if ((cols_type =='f') && (ndim == 2) && (columns == 4))
                return ImPlot::AddColormap(name, static_cast<const ImVec4 *>(values_from_pyarray), rows, qual);
            else
                throw std::runtime_error(std::string("Bad array type, expected either 1D array of type uint32, or 2D (Nx4 ->RGBA) array of type float32. Got ('") + cols_type + "') of ndim =" + std::to_string(ndim) + " for cols.");

        }, py::arg("name"), py::arg("cols"), py::arg("qual") = true,
        "Add a new colormap."
        );

    // SetupAxisTicks, cf https://github.com/pthom/imgui_bundle/issues/81
    m.def("setup_axis_ticks",
          [](ImAxis axis, double v_min, double v_max, int n_ticks, const std::vector<std::string>& labels, bool keep_default=false)
          {
              std::vector<const char*> label_char;
              for (std::string const& str : labels){
                  label_char.push_back(str.data());
              }
              ImPlot::SetupAxisTicks(axis, v_min, v_max, n_ticks, label_char.data(), keep_default);
          }, py::arg("axis"), py::arg("v_min"), py::arg("v_max"), py::arg("n_ticks"), py::arg("labels"), py::arg("keep_default"),
          "Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set #keep_default=true."
    );

    // PlotHeatmap, cf https://github.com/pthom/imgui_bundle/issues/81
    m.def("plot_heatmap",
          [](const char * label_id, const py::array & values, double scale_min = 0, double scale_max=0, const char * label_fmt="%.1f", const ImPlotPoint& bounds_min=ImPlotPoint(0,0), const ImPlotPoint& bounds_max=ImPlotPoint(1,1), ImPlotHeatmapFlags flags = 0)
          {
              auto PlotHeatmap_adapt_c_buffers = [](const char * label_id, const py::array & values, double scale_min = 0, double scale_max=0, const char * label_fmt="%.1f",  const ImPlotPoint& bounds_min=ImPlotPoint(0,0), const ImPlotPoint& bounds_max=ImPlotPoint(1,1),  ImPlotHeatmapFlags flags = 0)
              {
                  // convert py::array to C standard buffer (const)
                  const void * values_from_pyarray = values.data();

#ifdef _WIN32
                  using np_uint_l = uint32_t;
                  using np_int_l = int32_t;
#else
                  using np_uint_l = uint64_t;
                  using np_int_l = int64_t;
#endif
                  if (values.ndim() != 2)
                      throw std::runtime_error("plot_heatmap expects a numpy bidimensional array ");
                  int rows = static_cast<int>(values.shape()[0]);
                  int cols = static_cast<int>(values.shape()[1]);

                  // call the correct template version by casting
                  char values_type = values.dtype().char_();
                  if (values_type == 'B')
                      ImPlot::PlotHeatmap(label_id, static_cast<const uint8_t *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'b')
                      ImPlot::PlotHeatmap(label_id, static_cast<const int8_t *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'H')
                      ImPlot::PlotHeatmap(label_id, static_cast<const uint16_t *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'h')
                      ImPlot::PlotHeatmap(label_id, static_cast<const int16_t *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'I')
                      ImPlot::PlotHeatmap(label_id, static_cast<const uint32_t *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'i')
                      ImPlot::PlotHeatmap(label_id, static_cast<const int32_t *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'L')
                      ImPlot::PlotHeatmap(label_id, static_cast<const np_uint_l *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'l')
                      ImPlot::PlotHeatmap(label_id, static_cast<const np_int_l *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'f')
                      ImPlot::PlotHeatmap(label_id, static_cast<const float *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'd')
                      ImPlot::PlotHeatmap(label_id, static_cast<const double *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'g')
                      ImPlot::PlotHeatmap(label_id, static_cast<const long double *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                  else if (values_type == 'q')
                      ImPlot::PlotHeatmap(label_id, static_cast<const long long *>(values_from_pyarray), rows, cols, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
                      // If we reach this point, the array type is not supported!
                  else
                      throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
              };

              PlotHeatmap_adapt_c_buffers(label_id, values, scale_min, scale_max, label_fmt, bounds_min, bounds_max, flags);
          },
          py::arg("label_id"), py::arg("values"), py::arg("scale_min")= 0, py::arg("scale_max") = 0, py::arg("label_fmt")="%.1f", py::arg("bounds_min")=ImPlotPoint(0,0), py::arg("bounds_max")=ImPlotPoint(1,1), py::arg("flags")=0
    );


    pyClassImPlotPoint.def("__str__", [](const ImPlotPoint& self) -> std::string {
       char r[100];
       snprintf(r, 100, "ImPlotPoint(%f, %f)", self.x, self.y);
       return r;
    });
    pyClassImPlotPoint.def("__repr__", [](const ImPlotPoint& self) -> std::string {
        char r[100];
        snprintf(r, 100, "ImPlotPoint(%f, %f)", self.x, self.y);
        return r;
    });
    pyClassImPlotPoint.def("__len__", [](const ImPlotPoint& self) -> size_t {
        return 2;
    });
    pyClassImPlotPoint.def("__iter__", [](const ImPlotPoint& self) {
            return py::make_iterator(&self.x, &self.x+2);
        },
        py::keep_alive<0, 1>() /* Essential: keep object alive while iterator exists */
    );
    pyClassImPlotPoint.def(py::init([](py::tuple t) {
        return cast_to_point(t);
    }), py::arg("tuple"));
    pyClassImPlotPoint.def(py::init([](py::list l) {
        return cast_to_point(l);
    }), py::arg("list"));
    pyClassImPlotPoint.def(py::init([](py::array a) {
        return cast_to_point(a);
    }), py::arg("array"));

    py::implicitly_convertible<py::tuple, ImPlotPoint>();
    py::implicitly_convertible<py::list, ImPlotPoint>();
    py::implicitly_convertible<py::array, ImPlotPoint>();
    py::implicitly_convertible<ImVec2, ImPlotPoint>();

    pyClassImPlotPoint.def(py::init([](ImPlotPoint ipp) {
        return ImPlotPoint(ipp.x, ipp.y);
    }), py::arg("implotpoint"));
}
