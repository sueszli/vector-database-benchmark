/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/isteps/istep11/call_ocmb_check_for_ready.C $          */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2015,2023                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
/**
 *  @file call_ocmb_check_for_ready.C
 *
 *  Support file for IStep: ocmb_check_for_ready
 *    Check that OCMB is ready
 *
 */

/******************************************************************************/
// Includes
/******************************************************************************/

//  Error handling support
#include <errl/errlentry.H>                     // errlHndl_t
#include <errl/errlmanager.H>
#include <errl/errludtarget.H>                  // ErrlUserDetailsTarget
#include <istepHelperFuncs.H>                   // captureError

//  FAPI support
#include <fapi2.H>
#include <plat_hwp_invoker.H>
#include <isteps/hwpisteperror.H>               // IStepError

//  Tracing support
#include <initservice/isteps_trace.H>           // g_trac_isteps_trace

//  Targeting support
#include <attributeenums.H>                     // TYPE_PROC
#include <targeting/common/utilFilter.H>        // getAllChips
#include <targeting/common/targetservice.H>
#include <targeting/odyutil.H>
#include <sbeio/sbeioif.H>
#include <util/misc.H>
#include <sys/time.h>
#include <time.h>

//  HWP call support
#include <exp_check_for_ready.H>
#include <ody_check_for_ready.H>
#include <ody_sppe_config_update.H>
#include <ody_cbs_start.H>
#include <ody_sppe_check_for_ready.H>
#include <pmic_enable.H>
#include <p10_ocmb_enable.H>
#include <platform_vddr.H>
#include <chipids.H>
#include <p10_scom_perv_2.H>

// Explorer error logs
#include <expscom/expscom_errlog.H>

// sendProgressCode
#include <initservice/istepdispatcherif.H>

#include    <hwpThread.H>
#include    <hwpThreadHelper.H>

// Code update
#include <ocmbupd/ocmbupd.H>
#include <ocmbupd/ocmbFwImage.H>
#include <ocmbupd/ody_upd_fsm.H>

using namespace ISTEPS_TRACE;
using namespace ISTEP_ERROR;
using namespace ERRORLOG;
using namespace TARGETING;
using namespace SBEIO;

using namespace ocmbupd;

namespace ISTEP_11
{

/** @brief Check whether the given error has async FFDC or not.
 */
bool err_is_sppe_not_ready_with_async_ffdc(Target* const i_ocmb, const errlHndl_t i_errl)
{
    bool is_sppe_not_ready_with_async_ffdc = false;

    if (i_errl->reasonCode() == fapi2::RC_POZ_SPPE_NOT_READY_ERR)
    {
        errlHndl_t l_errlLocal = ody_has_async_ffdc(i_ocmb, is_sppe_not_ready_with_async_ffdc);
        if(l_errlLocal)
        {
            // Don't care about this error
            delete l_errlLocal;
            l_errlLocal = nullptr;
        }
    }

    return is_sppe_not_ready_with_async_ffdc;
}

errlHndl_t handle_ody_upd_hwps_done(Target* const, errlHndl_t&, bool&); // forward declaration

/** @brief Called to perform the attribute setup for the OCMB.
 *
 *  @param[in] i_ocmb                   The OCMB.
 *
 *  @return    errlHndl_t               Error if any, otherwise nullptr.
 */
errlHndl_t ody_attribute_setup(Target* const i_ocmb)
{
    errlHndl_t l_errl = nullptr;
    const auto boot_flags = i_ocmb->getAttr<TARGETING::ATTR_OCMB_BOOT_FLAGS>();
    const auto boot_side = i_ocmb->getAttr<TARGETING::ATTR_OCMB_BOOT_SIDE>();
    i_ocmb->setAttr<TARGETING::ATTR_SPPE_BOOT_SIDE>(boot_side);

    // See ody_perv_attributes.xml for these definitions
    const uint32_t OCMB_BOOT_FLAGS_BOOT_INDICATION_MASK = 0xC0000000;
    const uint32_t OCMB_BOOT_FLAGS_AUTOBOOT_MODE = 0x00000000;
    const uint32_t OCMB_BOOT_FLAGS_ISTEP_MODE = 0xC0000000;

    const auto sys = UTIL::assertGetToplevelTarget();
    if (boot_side == SPPE_BOOT_SIDE_GOLDEN || sys->getAttr<TARGETING::ATTR_OCMB_ISTEP_MODE>())
    {
        TRACISTEP("ody_attribute_setup: Disable autoboot for Odyssey golden side HUID=0x%X",
                  get_huid(i_ocmb));

        // Disable autoboot on the golden side, so that we execute as
        // little code as possible (and therefore have the smallest chance
        // of failing) before we update the chip.
        i_ocmb->setAttr<TARGETING::ATTR_OCMB_BOOT_FLAGS>((boot_flags & ~OCMB_BOOT_FLAGS_BOOT_INDICATION_MASK)
                                                      | OCMB_BOOT_FLAGS_ISTEP_MODE);
    }
    else
    {
        TRACISTEP("ody_attribute_setup: Enable autoboot for Odyssey side %d HUID=0x%X",
                  boot_side, get_huid(i_ocmb));

        i_ocmb->setAttr<TARGETING::ATTR_OCMB_BOOT_FLAGS>((boot_flags & ~OCMB_BOOT_FLAGS_BOOT_INDICATION_MASK)
                                                      | OCMB_BOOT_FLAGS_AUTOBOOT_MODE);
    }

    TRACISTEP("ody_attribute_setup: Setting boot side to boot_side=%d HUID=x%X", boot_side, get_huid(i_ocmb));
    return l_errl;
}

/** @brief Called to perform deviceWrite for the OCMB.
 *
 *         See ocmbIdecPhase2 description for details on the
 *         cross-check performed for specifics on the data which
 *         is synced.
 *
 *  @param[in] i_ocmb                   The OCMB.
 *
 *  @return    errlHndl_t               Error if any, otherwise nullptr.
 */
errlHndl_t ocmb_idec_sync(Target* const i_ocmb)
{
    errlHndl_t l_errl = nullptr;
    size_t size = 0;

    TRACISTEP("ocmb_idec_sync: Read IDEC HUID=0x%X", get_huid(i_ocmb));

    // This write gets translated into a read of the ocmb chip
    // in the device driver. First, a read of the chip's IDEC
    // register occurs then ATTR_EC, ATTR_HDAT_EC, and ATTR_CHIP_ID
    // are set with the values found in that register. So, this
    // deviceWrite functions more as a setter for an OCMB target's
    // attributes.
    // Pass 2 as a va_arg to signal the ocmbIDEC function to execute
    // phase 2 of its read process.
    const uint64_t Phase2 = 2;
    l_errl = DeviceFW::deviceWrite(i_ocmb,
                                   nullptr,
                                   size,
                                   DEVICE_IDEC_ADDRESS(),
                                   Phase2);
    return l_errl;
}

/** @brief Called to perform the Explorer/Odyssey check_for_ready HWP.
 *
 *  @param[in] i_ocmb                   The OCMB.
 *
 *  @return    errlHndl_t               Error if any, otherwise nullptr.
 */
errlHndl_t check_for_ready_work(Target* const i_ocmb)
{
    errlHndl_t l_errl = nullptr;
    fapi2::Target <fapi2::TARGET_TYPE_OCMB_CHIP>l_fapi_ocmb_target(i_ocmb);

    size_t l_maxTime_secs = 0;
    timespec_t l_preLoopTime = {};
    timespec_t l_ocmbCurrentTime = {};
    clock_gettime(CLOCK_MONOTONIC, &l_preLoopTime);

    bool l_one_more_try = false;

    // Save the original timeout (to be restored after exp_check_for_ready)
    // Units for the attribute are milliseconds; the value returned is > 1 second
    const auto original_timeout_ms = i_ocmb->getAttr<ATTR_MSS_CHECK_FOR_READY_TIMEOUT>();

    // Calculate MAX Wait Time - Round up on seconds
    // - ATTR_MSS_CHECK_FOR_READY_TIMEOUT in msec (see exp_attributes.xml)
    // - This assumes that all of the OCMBs on a processor were started at the same time
    //   and that they all have the same original_timeout value
    // - The calculation is as follows:
    // 1) Start with the 'seconds' value of the pre-loop time
    // 2) Add *double* the 'seconds' amount of the original timeout value
    //    -- the *double* is just to be on the safe side, as we're only dealing with
    //       seconds and not minutes here
    // 3) Add 3 to round up for the nanoseconds of (1) and double the milliseconds of (2)
    if (l_maxTime_secs == 0)
    {
        // If not set yet, then set it here:
        l_maxTime_secs = l_preLoopTime.tv_sec
            + (2 * (original_timeout_ms / MS_PER_SEC))
            + 3;
    }

    // exp_check_for_ready will read this attribute to know how long to
    // poll. If this number is too large and we get too many I2C error
    // logs between calls to FAPI_INVOKE_HWP, we will run out of memory.
    // So break the original timeout into smaller timeouts.
    // This will not affect how the loop below will use l_maxTime_secs to look for a timeouts
    const ATTR_MSS_CHECK_FOR_READY_TIMEOUT_type smaller_timeout_ms = 10;
    i_ocmb->setAttr<ATTR_MSS_CHECK_FOR_READY_TIMEOUT>(smaller_timeout_ms);

    TRACISTEP("check_for_ready_work: OCMB 0x%X: "
              "original_timeout_ms = %d, smaller_timeout_ms = %d, "
              "l_preLoopTime.tv_sec = %lu l_maxTime_secs = %lu",
              get_huid(i_ocmb), original_timeout_ms, smaller_timeout_ms,
              l_preLoopTime.tv_sec, l_maxTime_secs);

    while (true)
    {
        // Delete the log from the previous iteration
        if( l_errl )
        {
            delete l_errl;
            l_errl = nullptr;
        }

        if (UTIL::isOdysseyChip(i_ocmb))
        {
            FAPI_INVOKE_HWP(l_errl, ody_check_for_ready, l_fapi_ocmb_target);
        }
        else
        {
            FAPI_INVOKE_HWP(l_errl, exp_check_for_ready, l_fapi_ocmb_target);
        }
        // On success, quit retrying.
        if (!l_errl)
        {
            TRACISTEP("check_for_ready_work: exp/ody_check_for_ready DONE ! HUID=0x%X", get_huid(i_ocmb));
            break;
        }

        clock_gettime(CLOCK_MONOTONIC, &l_ocmbCurrentTime);
        if (l_ocmbCurrentTime.tv_sec > l_maxTime_secs)
        {
            if (l_one_more_try == false)
            {
                // Do one more attempt just to be safe
                l_one_more_try = true;
                TRACISTEP("check_for_ready_work: Setting 'one more try' based on times HUID=0x%X "
                          "l_ocmbCurrentTime.tv_sec = %lu, l_maxTime_secs = %lu",
                          get_huid(i_ocmb), l_ocmbCurrentTime.tv_sec, l_maxTime_secs);
            }
            else
            {
                // Already done "one more try" so just break
                TRACISTEP("check_for_ready_work: Breaking as 'one more try' exhausted HUID=0x%X "
                          "l_ocmbCurrentTime.tv_sec = %lu, l_maxTime_secs = %lu",
                          get_huid(i_ocmb), l_ocmbCurrentTime.tv_sec, l_maxTime_secs);
                break;
            }
        }
    } // end while

    // Restore original timeout value
    i_ocmb->setAttr<ATTR_MSS_CHECK_FOR_READY_TIMEOUT>(original_timeout_ms);
    return l_errl;
}

/** @brief Called to handle the OCMB boot process on a per PROC basis.
 *
 *         This function handles the boot of the OCMB's on a per PROC
 *         basis.  Any OCMB operations or recovery actions will be
 *         handled by leveraging the parallelization of the permittable
 *         OCMB operations.
 *
 *         During each of the PROC's isolation of its children OCMBs, each PROC
 *         will synchronize the necessary OCMB operations to accomplish the proper
 *         OCMB boot sequences.
 *
 *  @param[in] i_proc                   The PROC.
 *  @param[in/out] io_iStepError        The IStepError which will capture any problems.
 *
 *  @return    errlHndl_t               Error if any, otherwise nullptr.
 */
errlHndl_t boot_all_proc_ocmbs(Target* const i_proc, IStepError& io_iStepError)
{
    errlHndl_t l_errl = nullptr;
    TargetHandleList l_functionalOcmbChipList;
    getChildAffinityTargets( l_functionalOcmbChipList,
                             i_proc,
                             CLASS_CHIP,
                             TYPE_OCMB_CHIP,
                             true);

    while (!l_functionalOcmbChipList.empty())
    {
        const auto ocmbs = move(l_functionalOcmbChipList);
        // Not required in the standard for a moved-from vector to be empty
        // Here for completeness
        l_functionalOcmbChipList.clear();
        bool proc_reboot_odysseys = false;

        // Watchdog refresh - each i2c update may take approximately
        // one minute, but this may re-occur, so sendProgressCode
        // once per iteration in the loop
        INITSERVICE::sendProgressCode();
        TRACISTEP("boot_all_proc_ocmbs: sendProgressCode PROC HUID=0x%X", get_huid(i_proc));

        ISTEP::parallel_for_each(ocmbs,
                                 io_iStepError,
                                 "check_for_ready_work",
                                 [&](Target* const i_ocmb)
        {
            errlHndl_t i_ocmb_errl = nullptr;
            TRACISTEP("parallel_for_each boot_all_proc_ocmbs: WORKING ON HUID=0x%X", get_huid(i_ocmb));
            fapi2::Target <fapi2::TARGET_TYPE_OCMB_CHIP>l_fapi_ocmb_target(i_ocmb);
            do
            {
                if (UTIL::isOdysseyChip(i_ocmb))
                {
                    i_ocmb_errl = ody_attribute_setup(i_ocmb);
                    if (i_ocmb_errl)
                    {
                        TRACISTEP("parallel_for_each ody_attribute_setup: HUID=0x%X PROBLEM !", get_huid(i_ocmb));
                        break;
                    }
                }
                i_ocmb_errl = check_for_ready_work(i_ocmb);
                if (i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each check_for_ready_work: HUID=0x%X PROBLEM !", get_huid(i_ocmb));
                    break;
                }
                i_ocmb_errl = ocmb_idec_sync(i_ocmb);
                if (i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each ocmb_idec_sync: HUID=0x%X PROBLEM !", get_huid(i_ocmb));
                    break;
                }
                // ABOVE COMPLETES EXPLORER
                if (!UTIL::isOdysseyChip(i_ocmb))
                {
                    TRACISTEP("parallel_for_each DONE with EXPLORER HUID=0x%X", get_huid(i_ocmb));
                    break;
                }
                FAPI_INVOKE_HWP(i_ocmb_errl, ody_sppe_config_update, l_fapi_ocmb_target);
                if (i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each ody_sppe_config_update: HUID=0x%X PROBLEM ! ", get_huid(i_ocmb));
                    break;
                }
                FAPI_INVOKE_HWP(i_ocmb_errl, ody_cbs_start, l_fapi_ocmb_target);
                if (i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each ody_cbs_start: HUID=0x%X PROBLEM !", get_huid(i_ocmb));
                    break;
                }
                FAPI_INVOKE_HWP(i_ocmb_errl, ody_sppe_check_for_ready, l_fapi_ocmb_target);
                if (i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each HWP ody_sppe_check_for_ready: HUID=0x%X PROBLEM !", get_huid(i_ocmb));
                    break;
                }
            } while (false);

            if (UTIL::isOdysseyChip(i_ocmb))
            {
                i_ocmb_errl = handle_ody_upd_hwps_done(i_ocmb, i_ocmb_errl, proc_reboot_odysseys); // handle_ody_upd_hwps_done may modify i_ocmb_errl
                if (i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each handle_ody_upd_hwps_done: OCMB HUID=0x%X proc_reboot_odysseys=%d", get_huid(i_ocmb), proc_reboot_odysseys);
                    captureError(i_ocmb_errl, io_iStepError, HWPF_COMP_ID, i_ocmb);
                    goto EXIT_OCMBS;
                }
                if (proc_reboot_odysseys)
                {
                    TRACISTEP("parallel_for_each boot_all_proc_ocmbs: OCMB HUID=0x%X proc_reboot_odysseys=%d EXIT_OCMBS", get_huid(i_ocmb), proc_reboot_odysseys);
                    goto EXIT_OCMBS;
                }
                if (!i_ocmb->getAttr<ATTR_HWAS_STATE>().functional)
                {
                    TRACISTEP("parallel_for_each boot_all_proc_ocmbs: OCMB HUID=0x%X proc_reboot_odysseys=%d DECONFIG EXIT_OCMBS", get_huid(i_ocmb), proc_reboot_odysseys);
                    goto EXIT_OCMBS;
                }
                errlHndl_t no_error = nullptr; // no error for this call
                i_ocmb_errl = ody_upd_process_event(i_ocmb,
                                               CHECK_FOR_READY_COMPLETED,
                                               no_error,
                                               proc_reboot_odysseys);
                if (i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each ody_upd_process_event: OCMB HUID=0x%X proc_reboot_odysseys=%d", get_huid(i_ocmb), proc_reboot_odysseys);
                    captureError(i_ocmb_errl, io_iStepError, HWPF_COMP_ID, i_ocmb);
                    goto EXIT_OCMBS;
                }

                // Check if there is any async FFDC on the Odyssey
                // TODO JIRA: PFHB-487 Make sure that we check for async FFDC AFTER
                // we've checked the SBE flash errors.
                bool l_hasFfdc = false;
                i_ocmb_errl = ody_has_async_ffdc(i_ocmb, l_hasFfdc);
                if(i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each ody_has_async_ffdc: could not get async FFDC bit from OCMB 0x%x", get_huid(i_ocmb));
                    errlCommit(i_ocmb_errl, SBEIO_COMP_ID);
                }
                else
                {
                    if(l_hasFfdc)
                    {
                        SBEIO::processOdyAsyncFFDC(i_ocmb);
                    }
                    else
                    {
                        TRACISTEP("parallel_for_each: No async FFDC for OCMB 0x%x", get_huid(i_ocmb));
                    }
                }
            }
            else // EXPLORER
            {
                if (i_ocmb_errl)
                {
                    TRACISTEP("parallel_for_each boot_all_proc_ocmbs: EXPLORER failed HUID=0x%X", get_huid(i_ocmb));
                    captureError(i_ocmb_errl, io_iStepError, HWPF_COMP_ID, i_ocmb);
                }
            }
            EXIT_OCMBS:
                return nullptr; // No error should be passed back from the parallel_for_each
        }); // parallel_for_each i_ocmb

        if (proc_reboot_odysseys) // ODYSSEY ONLY PATH BELOW, EXPLORER will NOT set proc_reboot_odysseys
        {
            getChildAffinityTargets(l_functionalOcmbChipList, // this will re-seed the OCMBs to cycle again
                                    i_proc,
                                    CLASS_CHIP,
                                    TYPE_OCMB_CHIP,
                                    true /* functional */);

            // After Odyssey restarts, clear their code levels
            std::for_each(begin(l_functionalOcmbChipList),
                          end(l_functionalOcmbChipList),
                          clear_ody_code_levels_state);
            FAPI_INVOKE_HWP(l_errl, p10_ocmb_enable, { i_proc }); // PROC level, ALL Odysseys reboot, Odyssey ONLY path here
            if (l_errl)
            {
                TRACISTEP(ERR_MRK"boot_all_proc_ocmbs: PROBLEM restarting all Odysseys under PROC HUID=0x%X", get_huid(i_proc));
                captureError(l_errl, io_iStepError, HWPF_COMP_ID, i_proc);
                break;
            }
        }
    } // end while (!l_functionalOcmbChipList.empty())

    TRACISTEP(EXIT_MRK"boot_all_proc_ocmbs: HUID=0x%X", get_huid(i_proc));
    return l_errl;
}

/** @brief Commit an info log if required, and set io_return_errl and io_local_errl
 *         as appropriate.
 *         We want the first error to be visible and all secondary errors to be info.
 *         The first error is most relevant to a failure.
 *
 *  @param[in,out] io_return_errl  The errl to be returned from the calling fcn
 *  @param[in,out] io_local_errl   The errl which was just hit in the calling fcn
 */
void check_and_set_errl(errlHndl_t& io_return_errl, errlHndl_t& io_local_errl)
{
    if (io_return_errl)
    {
        // a return errl already exists, so log the new errl as info
        io_local_errl->plid(io_return_errl->plid());
        io_local_errl->setSev(ERRORLOG::ERRL_SEV_INFORMATIONAL);
        errlCommit(io_local_errl, HWPF_COMP_ID);
    }
    else
    {
        io_return_errl = io_local_errl;
    }
    io_local_errl = nullptr;
}

/** @brief Called when all of the check_for_ready HWPs have been invoked on the given OCMB,
 *  whether they failed or not. This function handles errors and checks the code version
 *  running on the OCMB if possible.
 *
 *  @param[in]     i_ocmb               The OCMB.
 *  @param[in/out] io_hwpErrl           Any error returned by a HWP.
 *  @param[out]    o_restart_needed     Set to true if the Odyssey code update
 *                                      FSM indicates that the OCMB needs to run
 *                                      through check_for_ready again.
 *
 *  @return    errlHndl_t               Error if any, otherwise nullptr.
 *                                       If io_hwpErrl, return io_hwpErrl
 *                                       If only a local_error, return local_error
 *                                       Except when code update FSM chooses to
 *                                       switch sides, then no errl is returned
 */
errlHndl_t handle_ody_upd_hwps_done(Target* const i_ocmb,
                                    errlHndl_t& io_hwpErrl,
                                    bool& o_restart_needed)
{
    errlHndl_t      l_return_errl = io_hwpErrl;
    ody_upd_event_t l_event       = NO_EVENT;

    if (io_hwpErrl)
    { // If there was a HWP error, check whether there is async FFDC.
        l_event = OCMB_BOOT_ERROR_NO_FFDC;

        // @TODO: Can we could have async FFDC without a HWP error? If so we should check this
        // in the HWP success path as well.
        if (err_is_sppe_not_ready_with_async_ffdc(i_ocmb, io_hwpErrl))
        {
            l_event = OCMB_BOOT_ERROR_WITH_FFDC;
        }
        else
        {
            // @TODO: call ody_extract_sbe_rc
        }
    }

    if (l_event != OCMB_BOOT_ERROR_NO_FFDC)
    { // If there is async FFDC, we might be able to read the code levels.

        if (i_ocmb->getAttr<ATTR_SBE_NUM_CAPABILITIES>() == 0)
        {
            // This attr is unset, so run the get code levels chipop to pull
            // the data which contains the number of capabilities supported

            if (auto l_local_errl = sendGetCodeLevelsRequest(i_ocmb))
            {
                TRACISTEP("handle_ody_upd_hwps_done: sendGetCodeLevelsRequest "
                          "failed on OCMB 0x%X", get_huid(i_ocmb));

                // If we can't get code levels, treat this as a boot failure with
                // no async FFDC
                l_event = OCMB_BOOT_ERROR_NO_FFDC;

                check_and_set_errl(l_return_errl, l_local_errl);
            }
        }

        if (SPPE_BOOT_SIDE_GOLDEN != i_ocmb->getAttr<TARGETING::ATTR_OCMB_BOOT_SIDE>())
        {
            // getCapabilities is not supported with GOLDEN image
            //  *This chipop did not make it into the GOLDEN image in time, and
            //   and the golden image is now locked.

            if (auto l_local_errl = getFifoSbeCapabilities(i_ocmb))
            {
                TRACISTEP("handle_ody_upd_hwps_done: getFifoSbeCapabilities "
                          "failed on OCMB 0x%X", get_huid(i_ocmb));

                // If we can't get capabilities, treat this as a boot failure
                // with no async FFDC
                l_event = OCMB_BOOT_ERROR_NO_FFDC;

                check_and_set_errl(l_return_errl, l_local_errl);
            }
        }
    }

    if (odysseyCodeUpdateSupported()) // no point in doing anything if we have
                                      // no Odyssey images in PNOR.
    {

        if (l_event != OCMB_BOOT_ERROR_NO_FFDC)
        {
            set_ody_code_levels_state(i_ocmb);
        }

        if (l_return_errl)
        {
            // Pass any HWP error to the code update FSM and let it tell us what to do.

            l_return_errl->addHwCallout(i_ocmb,
                                        HWAS::SRCI_PRIORITY_HIGH,
                                        HWAS::DECONFIG,
                                        HWAS::GARD_NULL);
            l_return_errl = ody_upd_process_event(i_ocmb,
                                                  l_event,
                                                  l_return_errl,
                                                  o_restart_needed);
        }
    }

    // cleanup this errlHndl_t, since we processed the error logs returned
    // in this function, and we will return an appropriate error log handle
    // using l_return_errl
    io_hwpErrl = nullptr;

    return l_return_errl;
}

void* call_ocmb_check_for_ready (void *io_pArgs)
{
    TRACISTEP(ENTER_MRK"call_ocmb_check_for_ready");

    errlHndl_t l_errl = nullptr;
    IStepError l_StepError;

    do
    {

    // We need to do an explicit delay before our first i2c operation
    //  to the OCMBs to ensure we don't catch them too early in the boot
    //  and lock them up.
    const auto ocmb_delay = UTIL::assertGetToplevelTarget()
      ->getAttr<ATTR_OCMB_RESET_DELAY_SEC>();
    nanosleep(ocmb_delay,0);

    TargetHandleList functionalProcChipList;

    getAllChips(functionalProcChipList, TYPE_PROC, true);
    ISTEP::parallel_for_each(composable(getAllChips)(TYPE_PROC, true),
                                                   l_StepError,
                                                   "boot_all_proc_ocmbs",
                                                   [&](Target* const i_proc)
    {
        return boot_all_proc_ocmbs(i_proc, l_StepError);
    });

    const auto reconfig = UTIL::assertGetToplevelTarget()->getAttr<TARGETING::ATTR_RECONFIGURE_LOOP>();
    if ( (!l_StepError.isNull()) || reconfig )
        {
        TRACISTEP(ERR_MRK"call_ocmb_check_for_ready: ISTEPERROR or RECONFIG encountered");
                    goto FAIL_ISTEP;
    }

    // Loop thru the list of processors and send Memory config info to SBE
    for (auto &l_procTarget: functionalProcChipList)
    {
        l_errl = psuSendSbeMemConfig(l_procTarget);

        if (l_errl)
        {
            TRACISTEP(ERR_MRK"ERROR : call_ocmb_check_for_ready HWP(): "
                      "psuSendSbeMemConfig failed HUID=0x%X"
                      TRACE_ERR_FMT,
                      get_huid(l_procTarget),
                      TRACE_ERR_ARGS(l_errl));

            // Commit the error and not fail this istep due to this failure
            errlCommit( l_errl, HWPF_COMP_ID );
        }
        else
        {
            TRACISTEP(INFO_MRK"SUCCESS : call_ocmb_check_for_ready HWP(): "
                      "psuSendSbeMemConfig completed ok HUID=0x%X",
                      get_huid(l_procTarget));
        }
    } // for (auto &l_procTarget: functionalProcChipList)

    // Set ATTR_ATTN_CHK_OCMBS to let ATTN know that we may now get attentions
    // from Odyssey, but interrupts from the OCMB are not enabled yet.
    TargetHandleList l_allOCMBs;
    getAllChips(l_allOCMBs, TYPE_OCMB_CHIP, true);
    for (const auto l_ocmb : l_allOCMBs)
    {
        if (UTIL::isOdysseyChip(l_ocmb))
        {
            TRACISTEP("call_ocmb_check_for_ready: Enable attention processing for Odyssey OCMBs");
            UTIL::assertGetToplevelTarget()->setAttr<ATTR_ATTN_CHK_OCMBS>(1);
        }
        // There can be no mixing of OCMB types so only need to check one
        break;
    }
    // Enable scoms via the Odyssey SBE now that the the SBE is running
    // and we can send it chipops
    for (const auto l_ocmb : l_allOCMBs)
    {
        if (UTIL::isOdysseyChip(l_ocmb))
        {
            ScomSwitches l_switches = l_ocmb->getAttr<ATTR_SCOM_SWITCHES>();

            // Turn on SBE SCOM
            l_switches.useSbeScom = 1;

            // Turn off I2C SCOM since all scoms are restricted on
            // secure parts
            l_switches.useI2cScom = 0;

            l_ocmb->setAttr<ATTR_SCOM_SWITCHES>(l_switches);
        }
    }

    } while (false); // outer do

 FAIL_ISTEP:

    TRACISTEP(EXIT_MRK"call_ocmb_check_for_ready");
    return l_StepError.getErrorHandle();
}

};
