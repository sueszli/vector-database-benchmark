// Copyright (c) 2017 Nuxi, https://nuxi.nl/
//
// SPDX-License-Identifier: BSD-2-Clause

#if defined(__CloudABI__) && defined(__x86_64__)

#include <argdata.h>
#include <fcntl.h>
#include <program.h>
#include <signal.h>
#include <unistd.h>
#include <uv.h>

#include "gtest/gtest.h"
#include "src/gtest_with_tmpdir/gtest_with_tmpdir.h"

// An executable that loops infinitely. Generated with:
//
//     $ cat tiny.asm
//     BITS 64
//     GLOBAL _start
//     SECTION .text
//     _start:
//       jmp _start
//     $ nasm -f elf64 tiny.asm
//     $ ld -pie -o tiny tiny.o
//     $ strip -s tiny
//     $ brandelf -f 17 tiny
//     $ xxd --include tiny
//
static const unsigned char looping_binary[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x40, 0x00,
    0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xeb, 0xfe, 0x00, 0x2e,
    0x73, 0x68, 0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x00, 0x2e, 0x74, 0x65,
    0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static void kill_result(uv_process_t *handle, int64_t exit_status,
                        int term_signal) {
  ASSERT_EQ(0, exit_status);
  ASSERT_EQ(SIGKILL, term_signal);
  ASSERT_FALSE(*(bool *)handle->data);
  *(bool *)handle->data = true;
}

static void close_cb(uv_handle_t *handle) {
  ASSERT_FALSE(*(bool *)handle->data);
  *(bool *)handle->data = true;
}

TEST(uv_process_kill, example) {
  int fd_tmp = gtest_with_tmpdir::CreateTemporaryDirectory();

  // Create our faulty executable.
  int executable = openat(fd_tmp, "Loop", O_CREAT | O_WRONLY);
  ASSERT_LE(0, executable);
  ASSERT_EQ(sizeof(looping_binary),
            write(executable, looping_binary, sizeof(looping_binary)));
  ASSERT_EQ(0, close(executable));

  executable = openat(fd_tmp, "Loop", O_EXEC);
  ASSERT_LE(0, executable);
  uv_loop_t loop;
  ASSERT_EQ(0, uv_loop_init(&loop));

  // Execution should succeed.
  uv_process_t handle;
  ASSERT_EQ(
      0, program_spawn(&loop, &handle, executable, &argdata_null, kill_result));
  ASSERT_EQ(0, close(executable));

  // No termination should be observed.
  bool terminated = false;
  handle.data = &terminated;
  for (int i = 0; i < 1000; ++i)
    ASSERT_EQ(1, uv_run(&loop, UV_RUN_NOWAIT));
  ASSERT_FALSE(terminated);

  // Killing it should make it terminate.
  ASSERT_EQ(0, uv_process_kill(&handle, SIGKILL));
  ASSERT_EQ(0, uv_run(&loop, UV_RUN_DEFAULT));
  ASSERT_TRUE(terminated);

  bool closed = false;
  handle.data = &closed;
  uv_close((uv_handle_t *)&handle, close_cb);
  ASSERT_EQ(0, uv_run(&loop, UV_RUN_DEFAULT));
  ASSERT_TRUE(closed);

  ASSERT_EQ(0, uv_loop_close(&loop));
}

#endif
