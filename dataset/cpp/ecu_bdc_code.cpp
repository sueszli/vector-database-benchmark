
//
// Warning: don't edit - generated by generate_ecu_code.pl processing ../dev/bdc.json: BDC 40: Body domain controller
// This generated code  makes it easier to process CANBUS messages from the BDC ecu in a BMW i3
//

  case I3_PID_BDC_PIA_NR_AKTUELL: {                                               // 0x0F27
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_PIA_NR_AKTUELL", 1);
        break;
    }

    unsigned char STAT_PIA_NR_AKTUELL = (RXBUF_UCHAR(0));
        // The PIA number currently sent by the CAS on the bus. Notes: - Assignment according to table
        // TAB_CAS_PIA_NUMMER. / Das Result aktuell vom CAS auf dem Bus gesendeten PIA Nummer. Hinweise: - Zuordnung
        // gemäß Tabelle TAB_CAS_PIA_NUMMER.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_NR_AKTUELL", "STAT_PIA_NR_AKTUELL", STAT_PIA_NR_AKTUELL, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HOD_KALIBRIERUNG: {                                             // 0xA093
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BATTERIEVORSCHAEDIGUNGSHISTORIE: {                              // 0xA099
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_WISCHER_LIN_EINLERNVORGANG: {                                   // 0xA118
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_WISCHER_LIN_EINLERNVORGANG", 2);
        break;
    }

    unsigned char STAT_ROUTINE = (RXBUF_UCHAR(0));
        // Execution status of the routine / Ausführungsstatus der Routine
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WISCHER_LIN_EINLERNVORGANG", "STAT_ROUTINE", STAT_ROUTINE, "\"0-n\"");

    unsigned char STAT_WISCHER_LIN_EINLERNVORGANG = (RXBUF_UCHAR(1));
        // Indicates the status of the teach-in process / Gibt den Status des Einlernvorgangs an
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WISCHER_LIN_EINLERNVORGANG", "STAT_WISCHER_LIN_EINLERNVORGANG", STAT_WISCHER_LIN_EINLERNVORGANG, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSENSPIEGEL_SELBSTTEST: {                                     // 0xA322
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSENSPIEGEL_SELBSTTEST", 2);
        break;
    }

    char STAT_SELBSTTEST_NR = (RXBUF_SCHAR(0));
        // Status mirror test / Status Spiegeltest
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "AUSSENSPIEGEL_SELBSTTEST", "STAT_SELBSTTEST_NR", STAT_SELBSTTEST_NR, "\"0-n\"");

    char STAT_SELBSTTEST_FC_NR = (RXBUF_SCHAR(1));
        // Internal error output / Ausgabe interner Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "AUSSENSPIEGEL_SELBSTTEST", "STAT_SELBSTTEST_FC_NR", STAT_SELBSTTEST_FC_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_REGENSENSOR_INITIALISIERUNG: {                                  // 0xA3B7
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_REGENSENSOR_INITIALISIERUNG", 1);
        break;
    }

    unsigned char STAT_REGENSENSOR_INIT_VORGANG_NR = (RXBUF_UCHAR(0));
        // Status of rain sensor initialization process / Status Initialisierungsvorgang Regensensor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "REGENSENSOR_INITIALISIERUNG", "STAT_REGENSENSOR_INIT_VORGANG_NR", STAT_REGENSENSOR_INIT_VORGANG_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LEUCHTEN_KALTUEBERWACHUNG: {                                    // 0xA530
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LEUCHTEN_KALTUEBERWACHUNG", 1);
        break;
    }

    unsigned char STAT_KALTUEBERWACHUNG_NR = (RXBUF_UCHAR(0));
        // Result of the routine / Ergebnis der Routine
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LEUCHTEN_KALTUEBERWACHUNG", "STAT_KALTUEBERWACHUNG_NR", STAT_KALTUEBERWACHUNG_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LEUCHTEN_WARMUEBERWACHUNG: {                                    // 0xA531
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LEUCHTEN_WARMUEBERWACHUNG", 1);
        break;
    }

    unsigned char STAT_WARMUEBERWACHUNG_NR = (RXBUF_UCHAR(0));
        // Result of the routine / Ergebnis der Routine
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LEUCHTEN_WARMUEBERWACHUNG", "STAT_WARMUEBERWACHUNG_NR", STAT_WARMUEBERWACHUNG_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HOEHENSTAENDE_OFFSET_RESET: {                                   // 0xA532
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HOEHENSTAENDE_OFFSET_RESET", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_GURTZUBRINGER_INIT: {                                           // 0xA71A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_GURTZUBRINGER_INIT", 2);
        break;
    }

    unsigned char STAT_ROUTINE_FA_NR = (RXBUF_UCHAR(0));
        // Current state of the routine driver / Aktueller Zustand der Routine Fahrer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "GURTZUBRINGER_INIT", "STAT_ROUTINE_FA_NR", STAT_ROUTINE_FA_NR, "\"0-n\"");

    unsigned char STAT_ROUTINE_BF_NR = (RXBUF_UCHAR(1));
        // Current state of the passenger routine / Aktueller Zustand der Routine Beifahrer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "GURTZUBRINGER_INIT", "STAT_ROUTINE_BF_NR", STAT_ROUTINE_BF_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LIN_AUTOADRESSIERUNG: {                                         // 0xA838
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ELV_ANLIEFERZUSTAND: {                                          // 0xAA73
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ELV_ANLIEFERZUSTAND", 1);
        break;
    }

    unsigned char STAT_ELV_ANLIEFERZUSTAND = (RXBUF_UCHAR(0));
        // The result indicates whether resetting the ELV to the delivery state was successful or not 0: successful 1:
        // not successful / Das Result gibt an ob das Rücksetzen der ELV in den Anlieferzustand erfolgreich war oder
        // nicht 0: erfolgreich 1: nicht erfolgreich
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELV_ANLIEFERZUSTAND", "STAT_ELV_ANLIEFERZUSTAND", STAT_ELV_ANLIEFERZUSTAND, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SMO_SIMULATION_BEDIENUNG: {                                     // 0xAA80
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SMO_SIMULATION_BEDIENUNG", 1);
        break;
    }

    unsigned char STAT_AUSFUEHRUNGSSTATUS = (RXBUF_UCHAR(0));
        // The result indicates whether the requested action was carried out successfully or an error occurred / Das
        // Result gibt an, ob die angeforderte Aktion erfolgreich durchgeführt wurde oder ein Fehler aufgetreten ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SMO_SIMULATION_BEDIENUNG", "STAT_AUSFUEHRUNGSSTATUS", STAT_AUSFUEHRUNGSSTATUS, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STEUERN_CA_BROADCAST: {                                         // 0xAC54
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STEUERN_CA_BROADCAST", 8);
        break;
    }

    unsigned char STAT_CA_SCHL_NUM1 = (RXBUF_UCHAR(0));
        // The result contains the key number (0-19) of the key no. 1 found. Notes: - 0-19 = number of the key in the
        // transponder table. - 255 = no further key found. - ATTENTION: not to be confused with CA number (0-7). / Das
        // Result enthält die Schlüssel-Nummer (0-19) des gefundenen Schlüssels Nr. 1. Hinweise: - 0-19= Nummer des
        // Schlüssels in der Transpondertabelle. - 255= kein weiterer Schlüssel gefunden. - ACHTUNG: nicht zu verwechseln
        // mit CA-Nummer (0-7).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_BROADCAST", "STAT_CA_SCHL_NUM1", STAT_CA_SCHL_NUM1, "\"0-n\"");

    unsigned char STAT_CA_SCHL_NUM2 = (RXBUF_UCHAR(1));
        // The result contains the key number (0-19) of the key no. 2 found. Notes: - 0-19 = number of the key in the
        // transponder table. - 255 = no further key found. - ATTENTION: not to be confused with CA number (0-7). / Das
        // Result enthält die Schlüssel-Nummer (0-19) des gefundenen Schlüssels Nr. 2. Hinweise: - 0-19= Nummer des
        // Schlüssels in der Transpondertabelle. - 255= kein weiterer Schlüssel gefunden. - ACHTUNG: nicht zu verwechseln
        // mit CA-Nummer (0-7).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_BROADCAST", "STAT_CA_SCHL_NUM2", STAT_CA_SCHL_NUM2, "\"0-n\"");

    unsigned char STAT_CA_SCHL_NUM3 = (RXBUF_UCHAR(2));
        // The result contains the key number (0-19) of the key no. 3 found. Notes: - 0-19 = number of the key in the
        // transponder table. - 255 = no further key found. - ATTENTION: not to be confused with CA number (0-7). / Das
        // Result enthält die Schlüssel-Nummer (0-19) des gefundenen Schlüssels Nr. 3. Hinweise: - 0-19= Nummer des
        // Schlüssels in der Transpondertabelle. - 255= kein weiterer Schlüssel gefunden. - ACHTUNG: nicht zu verwechseln
        // mit CA-Nummer (0-7).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_BROADCAST", "STAT_CA_SCHL_NUM3", STAT_CA_SCHL_NUM3, "\"0-n\"");

    unsigned char STAT_CA_SCHL_NUM4 = (RXBUF_UCHAR(3));
        // The result contains the key number (0-19) of the key no. 4 found. Notes: - 0-19 = number of the key in the
        // transponder table. - 255 = no further key found. - ATTENTION: not to be confused with CA number (0-7). / Das
        // Result enthält die Schlüssel-Nummer (0-19) des gefundenen Schlüssels Nr. 4. Hinweise: - 0-19= Nummer des
        // Schlüssels in der Transpondertabelle. - 255= kein weiterer Schlüssel gefunden. - ACHTUNG: nicht zu verwechseln
        // mit CA-Nummer (0-7).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_BROADCAST", "STAT_CA_SCHL_NUM4", STAT_CA_SCHL_NUM4, "\"0-n\"");

    unsigned char STAT_CA_SCHL_NUM5 = (RXBUF_UCHAR(4));
        // The result contains the key number (0-19) of the key no. 5 found. Notes: - 0-19 = number of the key in the
        // transponder table. - 255 = no further key found. - ATTENTION: not to be confused with CA number (0-7). / Das
        // Result enthält die Schlüssel-Nummer (0-19) des gefundenen Schlüssels Nr. 5. Hinweise: - 0-19= Nummer des
        // Schlüssels in der Transpondertabelle. - 255= kein weiterer Schlüssel gefunden. - ACHTUNG: nicht zu verwechseln
        // mit CA-Nummer (0-7).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_BROADCAST", "STAT_CA_SCHL_NUM5", STAT_CA_SCHL_NUM5, "\"0-n\"");

    unsigned char STAT_CA_SCHL_NUM6 = (RXBUF_UCHAR(5));
        // The result contains the key number (0-19) of the key no. 6 found. Notes: - 0-19 = number of the key in the
        // transponder table. - 255 = no further key found. - ATTENTION: not to be confused with CA number (0-7). / Das
        // Result enthält die Schlüssel-Nummer (0-19) des gefundenen Schlüssels Nr. 6. Hinweise: - 0-19= Nummer des
        // Schlüssels in der Transpondertabelle. - 255= kein weiterer Schlüssel gefunden. - ACHTUNG: nicht zu verwechseln
        // mit CA-Nummer (0-7).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_BROADCAST", "STAT_CA_SCHL_NUM6", STAT_CA_SCHL_NUM6, "\"0-n\"");

    unsigned char STAT_CA_SCHL_NUM7 = (RXBUF_UCHAR(6));
        // The result contains the key number (0-19) of the key no. 7. Notes: - 0-19 = number of the key in the
        // transponder table. - 255 = no further key found. - ATTENTION: not to be confused with CA number (0-7). / Das
        // Result enthält die Schlüssel-Nummer (0-19) des gefundenen Schlüssels Nr. 7. Hinweise: - 0-19= Nummer des
        // Schlüssels in der Transpondertabelle. - 255= kein weiterer Schlüssel gefunden. - ACHTUNG: nicht zu verwechseln
        // mit CA-Nummer (0-7).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_BROADCAST", "STAT_CA_SCHL_NUM7", STAT_CA_SCHL_NUM7, "\"0-n\"");

    unsigned char STAT_CA_SCHL_NUM8 = (RXBUF_UCHAR(7));
        // The result contains the key number (0-19) of the key no. 8 found. Notes: - 0-19 = number of the key in the
        // transponder table. - 255 = no further key found. - ATTENTION: not to be confused with CA number (0-7). / Das
        // Result enthält die Schlüssel-Nummer (0-19) des gefundenen Schlüssels Nr. 8. Hinweise: - 0-19= Nummer des
        // Schlüssels in der Transpondertabelle. - 255= kein weiterer Schlüssel gefunden. - ACHTUNG: nicht zu verwechseln
        // mit CA-Nummer (0-7).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_BROADCAST", "STAT_CA_SCHL_NUM8", STAT_CA_SCHL_NUM8, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STEUERN_CA_ANTENNEN_TEST: {                                     // 0xAC55
    if (datalen < 17) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STEUERN_CA_ANTENNEN_TEST", 17);
        break;
    }

    unsigned char STAT_CA_ANTENNEN_TEST_OKAY = (RXBUF_UCHAR(0));
        // The result contains the result of the antenna test. Notes: - Allocation takes place according to table
        // TAB_CAS_CA_ANTENNEN_TEST. / Das Result enthält das Ergebnis des Antennentests. Hinweise: - Zuordnung erfolgt
        // gemäß Tabelle TAB_CAS_CA_ANTENNEN_TEST.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_TEST_OKAY", STAT_CA_ANTENNEN_TEST_OKAY, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_VERBAUORT_1 = (RXBUF_UCHAR(1));
        // The result contains the installation location of the 1st antenna in the table. / Das Result enthält das
        // Verbauort der 1. Antenne der Tabelle.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_VERBAUORT_1", STAT_CA_ANTENNEN_VERBAUORT_1, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_VERBAUORT_2 = (RXBUF_UCHAR(2));
        // The result contains the installation location of the 2nd antenna in the table. / Das Result enthält das
        // Verbauort der 2. Antenne der Tabelle.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_VERBAUORT_2", STAT_CA_ANTENNEN_VERBAUORT_2, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_VERBAUORT_3 = (RXBUF_UCHAR(3));
        // The result contains the installation location of the 3rd antenna in the table. / Das Result enthält das
        // Verbauort der 3. Antenne der Tabelle.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_VERBAUORT_3", STAT_CA_ANTENNEN_VERBAUORT_3, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_VERBAUORT_4 = (RXBUF_UCHAR(4));
        // The result contains the location of the 4th antenna in the table. / Das Result enthält das Verbauort der 4.
        // Antenne der Tabelle.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_VERBAUORT_4", STAT_CA_ANTENNEN_VERBAUORT_4, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_VERBAUORT_5 = (RXBUF_UCHAR(5));
        // The result contains the installation location of the 5th antenna in the table. / Das Result enthält das
        // Verbauort der 5. Antenne der Tabelle.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_VERBAUORT_5", STAT_CA_ANTENNEN_VERBAUORT_5, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_VERBAUORT_6 = (RXBUF_UCHAR(6));
        // The result contains the installation location of the 6th antenna in the table. / Das Result enthält das
        // Verbauort der 6. Antenne der Tabelle.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_VERBAUORT_6", STAT_CA_ANTENNEN_VERBAUORT_6, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_VERBAUORT_7 = (RXBUF_UCHAR(7));
        // The result contains the location of the 7th antenna in the table. / Das Result enthält das Verbauort der 7.
        // Antenne der Tabelle.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_VERBAUORT_7", STAT_CA_ANTENNEN_VERBAUORT_7, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_VERBAUORT_8 = (RXBUF_UCHAR(8));
        // The result contains the installation location of the 8th antenna in the table. / Das Result enthält das
        // Verbauort der 8. Antenne der Tabelle.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_VERBAUORT_8", STAT_CA_ANTENNEN_VERBAUORT_8, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_STATUS_1 = (RXBUF_UCHAR(9));
        // The result contains the result of the antenna test. / Das Result enthält das Ergebnis des Antennentests.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_STATUS_1", STAT_CA_ANTENNEN_STATUS_1, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_STATUS_2 = (RXBUF_UCHAR(10));
        // The result contains the result of the antenna test. / Das Result enthält das Ergebnis des Antennentests.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_STATUS_2", STAT_CA_ANTENNEN_STATUS_2, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_STATUS_3 = (RXBUF_UCHAR(11));
        // The result contains the result of the antenna test. / Das Result enthält das Ergebnis des Antennentests.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_STATUS_3", STAT_CA_ANTENNEN_STATUS_3, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_STATUS_4 = (RXBUF_UCHAR(12));
        // The result contains the result of the antenna test. / Das Result enthält das Ergebnis des Antennentests.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_STATUS_4", STAT_CA_ANTENNEN_STATUS_4, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_STATUS_5 = (RXBUF_UCHAR(13));
        // The result contains the result of the antenna test. / Das Result enthält das Ergebnis des Antennentests.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_STATUS_5", STAT_CA_ANTENNEN_STATUS_5, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_STATUS_6 = (RXBUF_UCHAR(14));
        // The result contains the result of the antenna test. / Das Result enthält das Ergebnis des Antennentests.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_STATUS_6", STAT_CA_ANTENNEN_STATUS_6, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_STATUS_7 = (RXBUF_UCHAR(15));
        // The result contains the result of the antenna test. / Das Result enthält das Ergebnis des Antennentests.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_STATUS_7", STAT_CA_ANTENNEN_STATUS_7, "\"0-n\"");

    unsigned char STAT_CA_ANTENNEN_STATUS_8 = (RXBUF_UCHAR(16));
        // The result contains the result of the antenna test. / Das Result enthält das Ergebnis des Antennentests.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_CA_ANTENNEN_TEST", "STAT_CA_ANTENNEN_STATUS_8", STAT_CA_ANTENNEN_STATUS_8, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STEUERN_FBD_EMPFAENGER_INIT: {                                  // 0xAC58
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STEUERN_FBD_EMPFAENGER_INIT", 1);
        break;
    }

    unsigned char STAT_FBD_EMPFAENGER_INIT = (RXBUF_UCHAR(0));
        // Initialization status of the FBD receiver. Notes: - The assignment is made according to table
        // TAB_CAS_FBD_EMPFAENGER_INIT_STATUS. / Initialiserungsstatus des FBD Empfängers. Hinweise: - Die Zuordnung
        // erfolgt gemäß Tabelle TAB_CAS_FBD_EMPFAENGER_INIT_STATUS.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STEUERN_FBD_EMPFAENGER_INIT", "STAT_FBD_EMPFAENGER_INIT", STAT_FBD_EMPFAENGER_INIT, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FBD_REICHWEITENMESSUNG: {                                       // 0xAC5D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FBD_REICHWEITENMESSUNG", 1);
        break;
    }

    unsigned char STAT_REICHWEITENMESSUNG_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the status of whether the FBD receiver is in range measurement mode: 0 = range measurement
        // activated 1 = range measurement deactivated / Das Result enthält den Status, ob der FBD-Empfänger im
        // Reichweitenmessmodus ist: 0 = Reichweitenmessung aktiviert 1 = Reichweitenmessung deaktiviert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_REICHWEITENMESSUNG", "STAT_REICHWEITENMESSUNG_AKTIV", STAT_REICHWEITENMESSUNG_AKTIV, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FBD_FEHLER: {                                                   // 0xAC5E
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FBD_FEHLER", 14);
        break;
    }

    unsigned char STAT_FEHLER_X = (RXBUF_UCHAR(0));
        // The result contains the currently recognized errors in the FBD receiver. Note: For each error, a result is
        // generated dynamically from the bit-coded signal of the FBD receiver. / Das Result enthält die aktuell
        // erkannten Fehler  im FBD-Empfänger.  Hinweis: Pro Fehler wird ein Result dynamisch aus dem bitcodiertem Signal
        // des FBD-Empfängers generiert. 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_FEHLER_X", STAT_FEHLER_X, "\"0-n\"");

    unsigned char STAT_ANZAHL_RESETS_WERT = (RXBUF_UCHAR(1));
        // The result contains the number of FBD receiver resets. 0-254 = number of resets 255 = invalid / unknown / Das
        // Result enthält die Anzahl an FBD-Empfänger Resets. 0-254 = Anzahl Resets 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_RESETS_WERT", STAT_ANZAHL_RESETS_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE1_WERT = (RXBUF_UCHAR(2));
        // The result contains the number of radio interference on channel 1 in the corresponding period. Phase 1 = 1 sec
        // to 10 sec 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die Anzahl
        // der Funkstörung auf Kanal 1 im entsprechenden Zeitraum.  Phase 1 = 1 sek bis 10 sek 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE1_WERT", STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE1_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE2_WERT = (RXBUF_UCHAR(3));
        // The result contains the number of radio interference on channel 1 in the corresponding period. Phase 2 = 10
        // sec to 1 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die
        // Anzahl der Funkstörung auf Kanal 1 im entsprechenden Zeitraum.  Phase 2 = 10 sek bis 1 min 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE2_WERT", STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE2_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE3_WERT = (RXBUF_UCHAR(4));
        // The result contains the number of radio interference on channel 1 in the corresponding period. Phase 3 = 1 min
        // to 10 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die Anzahl
        // der Funkstörung auf Kanal 1 im entsprechenden Zeitraum.  Phase 3 = 1 min bis 10 min 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE3_WERT", STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE3_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE4_WERT = (RXBUF_UCHAR(5));
        // The result contains the number of radio interference on channel 1 in the corresponding period. Phase 4 =
        // greater than 10 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält
        // die Anzahl der Funkstörung auf Kanal 1 im entsprechenden Zeitraum.  Phase 4 = grösser 10 min 0 - 6 = Anzahl
        // der Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE4_WERT", STAT_ANZAHL_STOERUNGEN_KANAL1_PHASE4_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE1_WERT = (RXBUF_UCHAR(6));
        // The result contains the number of radio interference on channel 2 in the corresponding period. Phase 1 = 1 sec
        // to 10 sec 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die Anzahl
        // der Funkstörung auf Kanal 2 im entsprechenden Zeitraum.  Phase 1 = 1 sek bis 10 sek 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE1_WERT", STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE1_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE2_WERT = (RXBUF_UCHAR(7));
        // The result contains the number of radio interference on channel 2 in the corresponding period. Phase 2 = 10
        // sec to 1 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die
        // Anzahl der Funkstörung auf Kanal 2 im entsprechenden Zeitraum.  Phase 2 = 10 sek bis 1 min 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE2_WERT", STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE2_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE3_WERT = (RXBUF_UCHAR(8));
        // The result contains the number of radio interference on channel 2 in the corresponding period. Phase 3 = 1 min
        // to 10 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die Anzahl
        // der Funkstörung auf Kanal 2 im entsprechenden Zeitraum.  Phase 3 = 1 min bis 10 min 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE3_WERT", STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE3_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE4_WERT = (RXBUF_UCHAR(9));
        // The result contains the number of radio interference on channel 2 in the corresponding period. Phase 4 =
        // greater than 10 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält
        // die Anzahl der Funkstörung auf Kanal 2 im entsprechenden Zeitraum.  Phase 4 = grösser 10 min 0 - 6 = Anzahl
        // der Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE4_WERT", STAT_ANZAHL_STOERUNGEN_KANAL2_PHASE4_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE1_WERT = (RXBUF_UCHAR(10));
        // The result contains the number of radio interference on channel 3 in the corresponding period. Phase 1 = 1 sec
        // to 10 sec 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die Anzahl
        // der Funkstörung auf Kanal 3 im entsprechenden Zeitraum.  Phase 1 = 1 sek bis 10 sek 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE1_WERT", STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE1_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE2_WERT = (RXBUF_UCHAR(11));
        // The result contains the number of radio interference on channel 3 in the corresponding period. Phase 2 = 10
        // sec to 1 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die
        // Anzahl der Funkstörung auf Kanal 3 im entsprechenden Zeitraum.  Phase 2 = 10 sek bis 1 min 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE2_WERT", STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE2_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE3_WERT = (RXBUF_UCHAR(12));
        // The result contains the number of radio interference on channel 3 in the corresponding period. Phase 3 = 1 min
        // to 10 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält die Anzahl
        // der Funkstörung auf Kanal 3 im entsprechenden Zeitraum.  Phase 3 = 1 min bis 10 min 0 - 6 = Anzahl der
        // Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE3_WERT", STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE3_WERT, "");

    unsigned char STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE4_WERT = (RXBUF_UCHAR(13));
        // The result contains the number of radio interference on channel 3 in the corresponding period. Phase 4 =
        // greater than 10 min 0 - 6 = number of radio interference 7 ... 255 = invalid / unknown / Das Result enthält
        // die Anzahl der Funkstörung auf Kanal 3 im entsprechenden Zeitraum.  Phase 4 = grösser 10 min 0 - 6 = Anzahl
        // der Funkstörungen 7 ... 255 = Ungültig/Unbekannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FBD_FEHLER", "STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE4_WERT", STAT_ANZAHL_STOERUNGEN_KANAL3_PHASE4_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ELSV_TASTER: {                                                  // 0xD070
    if (datalen < 5) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ELSV_TASTER", 5);
        break;
    }

    char STAT_TASTER_ELSV_HINTEN_EIN = (RXBUF_SCHAR(0));
        // 0: Push button eLSV backwards not actuated 1: Push button eLSV backwards actuated / 0: Taster eLSV nach hinten
        // nicht betätigt 1: Taster eLSV nach hinten betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_TASTER", "STAT_TASTER_ELSV_HINTEN_EIN", STAT_TASTER_ELSV_HINTEN_EIN, "\"0/1\"");

    char STAT_TASTER_ELSV_OBEN_EIN = (RXBUF_SCHAR(1));
        // 0: Push button eLSV upwards not actuated 1: Push button eLSV upwards actuated / 0: Taster eLSV nach oben nicht
        // betätigt 1: Taster eLSV nach oben betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_TASTER", "STAT_TASTER_ELSV_OBEN_EIN", STAT_TASTER_ELSV_OBEN_EIN, "\"0/1\"");

    char STAT_TASTER_ELSV_UNTEN_EIN = (RXBUF_SCHAR(2));
        // 0: Down button eLSV not pressed 1: eLSV button down pressed / 0: Taster eLSV nach unten nicht betätigt 1:
        // Taster eLSV nach unten betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_TASTER", "STAT_TASTER_ELSV_UNTEN_EIN", STAT_TASTER_ELSV_UNTEN_EIN, "\"0/1\"");

    char STAT_TASTER_ELSV_VORNE_EIN = (RXBUF_SCHAR(3));
        // 0: Push button eLSV forward not actuated 1: Push button eLSV forward actuated / 0: Taster eLSV nach vorne
        // nicht betätigt 1: Taster eLSV nach vorne betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_TASTER", "STAT_TASTER_ELSV_VORNE_EIN", STAT_TASTER_ELSV_VORNE_EIN, "\"0/1\"");

    char STAT_TASTER_ELSV_NR = (RXBUF_SCHAR(4));
        // 0: eLSV button not pressed 1: eLSV button pressed backwards 2: eLSV button pressed upwards 3: eLSV button
        // pressed forward 4: eLSV button pressed downwards 5: signal invalid / 0: Taster eLSV nicht betätigt 1: Taster
        // eLSV nach hinten betätigt 2: Taster eLSV nach oben betätigt 3: Taster eLSV nach vorne betätigt 4: Taster eLSV
        // nach unten betätigt 5: Signal ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_TASTER", "STAT_TASTER_ELSV_NR", STAT_TASTER_ELSV_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKRADHEIZUNG_TASTER: {                                        // 0xD073
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKRADHEIZUNG_TASTER", 1);
        break;
    }

    char STAT_TASTER_LENKRADHEIZUNG_EIN = (RXBUF_SCHAR(0));
        // 0: steering wheel heating button not pressed; 1: Steering wheel heating button pressed / 0: Lenkradheizung
        // Taster nicht betätigt; 1: Lenkradheizung Taster betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRADHEIZUNG_TASTER", "STAT_TASTER_LENKRADHEIZUNG_EIN", STAT_TASTER_LENKRADHEIZUNG_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ELSV_STATEMACHINE: {                                            // 0xD07B
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ELSV_STATEMACHINE", 2);
        break;
    }

    short STAT_STATEMACHINE = (RXBUF_SINT(0));
        // &lt;&lt;&lt; to be filled by the delivery person !!! &gt;&gt;&gt; / <<< vom Lieferanren zu befüllen !!! >>>
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "ELSV_STATEMACHINE", "STAT_STATEMACHINE", STAT_STATEMACHINE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ELSV_VORHANDEN: {                                               // 0xD07F
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ELSV_VORHANDEN", 2);
        break;
    }

    short STAT_VORHANDEN_ELSV_EIN = (RXBUF_SINT(0));
        // Electric steering column adjustment 0: not available 1: available / Elektrische Lenksäulenverstellung 0: nicht
        // vorhanden 1: vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "ELSV_VORHANDEN", "STAT_VORHANDEN_ELSV_EIN", STAT_VORHANDEN_ELSV_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKRAD_MFL: {                                                  // 0xD081
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKRAD_MFL", 14);
        break;
    }

    char STAT_TASTER_LENKRAD_MFL_FGR_SET_EIN = (RXBUF_SCHAR(0));
        // 0: FGR button SET not pressed 1: FGR button SET pressed / 0: FGR-Taste SET nicht betätigt 1: FGR-Taste SET
        // betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_FGR_SET_EIN", STAT_TASTER_LENKRAD_MFL_FGR_SET_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_FGR_TIPPRAENDEL_NR = (RXBUF_SCHAR(1));
        // 0: No operation 1: Knurl on level 2 below 2: Knurl on level 1 below 3: Knurl on level 1 above 4: Knurl on
        // level 2 above 5: Invalid position / 0: Keine Betätigung  1: Rändel auf Stufe 2 unten 2: Rändel auf Stufe 1
        // unten 3: Rändel auf Stufe 1 oben 4: Rändel auf Stufe 2 oben 5: ungültige Position
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_FGR_TIPPRAENDEL_NR", STAT_TASTER_LENKRAD_MFL_FGR_TIPPRAENDEL_NR, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_FGR_RES_EIN = (RXBUF_SCHAR(2));
        // 0: FGR button RES (resume) not pressed 1: FGR button RES (resume) pressed / 0: FGR-Taste RES (Wiederaufnahme)
        // nicht betätigt  1: FGR-Taste RES (Wiederaufnahme) betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_FGR_RES_EIN", STAT_TASTER_LENKRAD_MFL_FGR_RES_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_UMSCHALT_TASTE_EIN = (RXBUF_SCHAR(3));
        // 0: ACC / DCC toggle key not pressed 1: ACC / DCC toggle key pressed / 0: Umschalttaste ACC/ DCC nicht betätigt
        // 1: Umschalttaste ACC/ DCC betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_UMSCHALT_TASTE_EIN", STAT_TASTER_LENKRAD_MFL_UMSCHALT_TASTE_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_ACC_ABSTAND_EIN = (RXBUF_SCHAR(4));
        // 0: FGR button ACC distance not pressed 1: FGR button ACC distance pressed / 0: FGR-Taste ACC-Abstand nicht
        // betätigt  1: FGR-Taste ACC-Abstand betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_ACC_ABSTAND_EIN", STAT_TASTER_LENKRAD_MFL_ACC_ABSTAND_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_FGR_OFF_EIN = (RXBUF_SCHAR(5));
        // 0: FGR button OFF not pressed 1: FGR button OFF pressed / 0: FGR-Taste OFF nicht betätigt 1: FGR-Taste OFF
        // betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_FGR_OFF_EIN", STAT_TASTER_LENKRAD_MFL_FGR_OFF_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_PUSH_TO_TALK_EIN = (RXBUF_SCHAR(6));
        // 0: Push to talk not activated 1: Push to talk activated / 0: Push to talk nicht betätigt  1: Push to talk
        // betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_PUSH_TO_TALK_EIN", STAT_TASTER_LENKRAD_MFL_PUSH_TO_TALK_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_MODE_TASTE = (RXBUF_SCHAR(7));
        // 0: Source / Mode button not pressed 1: Source / Mode button pressed / 0: Taste Source / Mode nicht betätigt 1:
        // Taste Source / Mode betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_MODE_TASTE", STAT_TASTER_LENKRAD_MFL_MODE_TASTE, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_TIPPRAENDEL_BC_NR = (RXBUF_SCHAR(8));
        // 0: On-board computer (BC) tapping knurl not activated 1: On-board computer tapping knurl pressed 2: Tipping
        // knurl down 3: Typing knurl up 4: Invalid position / 0: Tipprändel Bordcomputer (BC) nicht betätigt 1:
        // Tipprändel Bordcomputer gedrückt  2: Tipprändel nach unten 3: Tipprändel nach oben 4: ungültige Position
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_TIPPRAENDEL_BC_NR", STAT_TASTER_LENKRAD_MFL_TIPPRAENDEL_BC_NR, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_TEL_EIN = (RXBUF_SCHAR(9));
        // 0: Telephone key not pressed 1: Telephone key pressed / 0: Telefontaste nicht betätigt  1: Telefontaste
        // betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_TEL_EIN", STAT_TASTER_LENKRAD_MFL_TEL_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_VOL_MINUS_EIN = (RXBUF_SCHAR(10));
        // 0: Volume / volume minus button not pressed 1: Volume / volume minus button pressed / 0: Taste
        // Volume/Lautstärke minus nicht betätigt 1: Taste Volume/Lautstärke minus betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_VOL_MINUS_EIN", STAT_TASTER_LENKRAD_MFL_VOL_MINUS_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL_VOL_PLUS_EIN = (RXBUF_SCHAR(11));
        // 0: Volume / volume plus button not pressed 1: Volume / volume plus button pressed / 0: Taste Volume/Lautstärke
        // plus nicht betätigt 1: Taste Volume/Lautstärke plus betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL_VOL_PLUS_EIN", STAT_TASTER_LENKRAD_MFL_VOL_PLUS_EIN, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL1_NR = (RXBUF_SCHAR(12));
        // VS result 0: no action 1-n: see sub-table TAB_MFL_TASTEN1 Numbering is retained, even if one or more functions
        // are omitted. / VS-Result 0: keine Aktion 1-n: siehe Sub-Tabelle TAB_MFL_TASTEN1 Numerierung bleibt erhalten,
        // auch bei Entfall einer oder mehrerer Funktionen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL1_NR", STAT_TASTER_LENKRAD_MFL1_NR, "\"0-n\"");

    char STAT_TASTER_LENKRAD_MFL2_NR = (RXBUF_SCHAR(13));
        // VS result 0: no action 1-n: see sub-table TAB_MFL_TASTEN2 Numbering is retained, even if one or more functions
        // are omitted. / VS-Result 0: keine Aktion 1-n: siehe Sub-Tabelle TAB_MFL_TASTEN2 Numerierung bleibt erhalten,
        // auch bei Entfall einer oder mehrerer Funktionen.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_MFL", "STAT_TASTER_LENKRAD_MFL2_NR", STAT_TASTER_LENKRAD_MFL2_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ELSV_POS_STATUS: {                                              // 0xD089
    if (datalen < 13) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ELSV_POS_STATUS", 13);
        break;
    }

    unsigned short STAT_ELSV_POS_HOEHE_WERT = (RXBUF_UINT(0));
        // Current real value vertical axis / Aktueller Realtivwert vertikale Achse
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_POS_HOEHE_WERT", STAT_ELSV_POS_HOEHE_WERT, "\"Digit\"");

    unsigned short STAT_ELSV_POS_LAENGE_WERT = (RXBUF_UINT(2));
        // Current real value horizontal axis / Aktueller Realtivwert horizontale Achse
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_POS_LAENGE_WERT", STAT_ELSV_POS_LAENGE_WERT, "\"Digit\"");

    char STAT_ELSV_BEWEGUNG_OBEN_EIN = (RXBUF_SCHAR(4));
        // 0: ELSV does not move upwards 1: ELSV moves upwards / 0: ELSV fährt nicht nach oben  1: ELSV fährt nach oben
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_BEWEGUNG_OBEN_EIN", STAT_ELSV_BEWEGUNG_OBEN_EIN, "\"0/1\"");

    char STAT_ELSV_BEWEGUNG_UNTEN_EIN = (RXBUF_SCHAR(5));
        // 0: ELSV does not move down 1: ELSV moves down / 0: ELSV fährt nicht nach unten  1: ELSV fährt nach unten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_BEWEGUNG_UNTEN_EIN", STAT_ELSV_BEWEGUNG_UNTEN_EIN, "\"0/1\"");

    char STAT_ELSV_BEWEGUNG_EINGEFAHREN_EIN = (RXBUF_SCHAR(6));
        // 0: ELSV does not retract (front) 1: ELSV retracts (front) / 0: ELSV fährt nicht ein (vorne)  1: ELSV fährt ein
        // (vorne)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_BEWEGUNG_EINGEFAHREN_EIN", STAT_ELSV_BEWEGUNG_EINGEFAHREN_EIN, "\"0/1\"");

    char STAT_ELSV_BEWEGUNG_AUSGEFAHREN_EIN = (RXBUF_SCHAR(7));
        // 0: ELSV does not extend (rear) 1: ELSV extends (rear) / 0: ELSV fährt nicht aus (hinten)  1: ELSV fährt nach
        // aus (hinten)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_BEWEGUNG_AUSGEFAHREN_EIN", STAT_ELSV_BEWEGUNG_AUSGEFAHREN_EIN, "\"0/1\"");

    char STAT_ELSV_SOFTSTOP_OBEN_EIN = (RXBUF_SCHAR(8));
        // 0: ELSV in the travel range window 1: Upper soft stop reached / 0: ELSV im Verfahrbereichsfenster  1: Softstop
        // oben erreicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_SOFTSTOP_OBEN_EIN", STAT_ELSV_SOFTSTOP_OBEN_EIN, "\"0/1\"");

    char STAT_ELSV_SOFTSTOP_UNTEN_EIN = (RXBUF_SCHAR(9));
        // 0: ELSV in the travel range window 1: Lower soft stop reached / 0: ELSV im Verfahrbereichsfenster  1: Softstop
        // unten erreicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_SOFTSTOP_UNTEN_EIN", STAT_ELSV_SOFTSTOP_UNTEN_EIN, "\"0/1\"");

    char STAT_ELSV_SOFTSTOP_EINGEFAHREN_EIN = (RXBUF_SCHAR(10));
        // 0: ELSV in the travel range window 1: Soft stop retracted reached / 0: ELSV im Verfahrbereichsfenster  1:
        // Softstop eingefahren erreicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_SOFTSTOP_EINGEFAHREN_EIN", STAT_ELSV_SOFTSTOP_EINGEFAHREN_EIN, "\"0/1\"");

    char STAT_ELSV_SOFTSTOP_AUSGEFAHREN_EIN = (RXBUF_SCHAR(11));
        // 0: ELSV in the travel range window 1: Soft stop extended reached / 0: ELSV im Verfahrbereichsfenster  1:
        // Softstop ausgefahren erreicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_SOFTSTOP_AUSGEFAHREN_EIN", STAT_ELSV_SOFTSTOP_AUSGEFAHREN_EIN, "\"0/1\"");

    char STAT_ELSV_NORMIERUNG = (RXBUF_SCHAR(12));
        // Status ELSV normalization see TAB_ELSV_NORMIERUNG_STATUS / Status ELSV Normierung siehe
        // TAB_ELSV_NORMIERUNG_STATUS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ELSV_POS_STATUS", "STAT_ELSV_NORMIERUNG", STAT_ELSV_NORMIERUNG, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SMO_SPIELSCHUTZZAEHLER: {                                       // 0xD096
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SMO_SPIELSCHUTZZAEHLER", 1);
        break;
    }

    unsigned char STAT_SPIELSCHUTZZAEHLER_WERT = (RXBUF_UCHAR(0));
        // The result indicates how often the SMO sensor has detected a trip without a valid key being detected in the
        // rear exterior / Das Result gibt an, wie oft der SMO-Sensor eine Auslösung erkannt hat, ohne das ein gültiger
        // Schlüssel im Heck-Aussenraum erkannt wurde
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SMO_SPIELSCHUTZZAEHLER", "STAT_SPIELSCHUTZZAEHLER_WERT", STAT_SPIELSCHUTZZAEHLER_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SMO_VARIANTE: {                                                 // 0xD098
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SMO_VARIANTE", 1);
        break;
    }

    unsigned char STAT_FAHRZEUGTYP = (RXBUF_UCHAR(0));
        // The result indicates which vehicle type the SMO has just set / Das Result gibt an, welchen Fahrzeugtyp das SMO
        // gerade eingestellt hat
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SMO_VARIANTE", "STAT_FAHRZEUGTYP", STAT_FAHRZEUGTYP, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_PLOCK: {                                                        // 0xD09D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_PLOCK", 1);
        break;
    }

    unsigned char STAT_PLOCK_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the current status of the HW input PLOCK / Das Result enthält den aktuellen Zustand des
        // HW-Eingangs PLOCK
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PLOCK", "STAT_PLOCK_AKTIV", STAT_PLOCK_AKTIV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZUSATZINFO_LICHT: {                                             // 0xD0F1
    if (datalen < 24) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZUSATZINFO_LICHT", 24);
        break;
    }

    unsigned long STAT_KM_STAND_1_WERT = (RXBUF_UINT32(0));
        // Mileage / Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_KM_STAND_1_WERT", STAT_KM_STAND_1_WERT, "\"km\"");

    unsigned char STAT_ENBN_AEP_STATUS_1_WERT = (RXBUF_UCHAR(4));
        // Status energy power management / Status Energie Powermanagement
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_ENBN_AEP_STATUS_1_WERT", STAT_ENBN_AEP_STATUS_1_WERT, "");

    unsigned char STAT_U_BATT_ANFANG_1_WERT = (RXBUF_UCHAR(5));
        // Supply voltage off 3 minutes after terminal 15 / Versorgungsspannung 3 Minuten nach Klemme 15 aus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_U_BATT_ANFANG_1_WERT", STAT_U_BATT_ANFANG_1_WERT, "\"V\"");

    unsigned short STAT_DAUER_1_WERT = (RXBUF_UINT(6));
        // Duration of light activity while standing / Dauer der Lichtaktivität im Stand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_DAUER_1_WERT", STAT_DAUER_1_WERT, "\"min\"");

    unsigned char STAT_LICHT_1_NR = (RXBUF_UCHAR(8));
        // Involved lighting / Beteiligte Beleuchtung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_LICHT_1_NR", STAT_LICHT_1_NR, "\"0-n\"");

    unsigned char STAT_ABSCHALTUNG_LICHT_1_WERT = (RXBUF_UCHAR(9));
        // Switch off light at SFG (it was switched off after 12 hours and the start capability limit was reached). /
        // Abschaltung Licht bei SFG (fand eine Abschaltung nach Ablauf 12h und Erreichen der Startfähigkeitsgrenze
        // statt).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_ABSCHALTUNG_LICHT_1_WERT", STAT_ABSCHALTUNG_LICHT_1_WERT, "");

    unsigned char STAT_ABSCHALTVERHINDERER_1_WERT = (RXBUF_UCHAR(10));
        // Shutdown prevention reason light (reaching upper start capability limit and 12h timer not expired, driver's
        // door not opened, further tbd). / Abschaltverhinderergrund Licht (Erreichen obere Startfähigkeitsgrenze und 12h
        // Timer nicht abgelaufen, kein Öffnen der Fahrertür, weitere tbd).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_ABSCHALTVERHINDERER_1_WERT", STAT_ABSCHALTVERHINDERER_1_WERT, "");

    unsigned char STAT_KLEMMENSTATUS_1_WERT = (RXBUF_UCHAR(11));
        // Terminal status (at the time of entry / snapshot). / Klemmenstatus (zum Zeitpunkt des Eintrags/Snapshots).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_KLEMMENSTATUS_1_WERT", STAT_KLEMMENSTATUS_1_WERT, "");

    unsigned long STAT_KM_STAND_2_WERT = (RXBUF_UINT32(12));
        // Mileage / Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_KM_STAND_2_WERT", STAT_KM_STAND_2_WERT, "\"km\"");

    unsigned char STAT_ENBN_AEP_STATUS_2_WERT = (RXBUF_UCHAR(16));
        // Status energy power management / Status Energie Powermanagement
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_ENBN_AEP_STATUS_2_WERT", STAT_ENBN_AEP_STATUS_2_WERT, "");

    unsigned char STAT_U_BATT_ANFANG_2_WERT = (RXBUF_UCHAR(17));
        // Supply voltage off 3 minutes after terminal 15 / Versorgungsspannung 3 Minuten nach Klemme 15 aus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_U_BATT_ANFANG_2_WERT", STAT_U_BATT_ANFANG_2_WERT, "\"V\"");

    unsigned short STAT_DAUER_2_WERT = (RXBUF_UINT(18));
        // Duration of light activity while standing / Dauer der Lichtaktivität im Stand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_DAUER_2_WERT", STAT_DAUER_2_WERT, "\"min\"");

    unsigned char STAT_LICHT_2_NR = (RXBUF_UCHAR(20));
        // Involved lighting / Beteiligte Beleuchtung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_LICHT_2_NR", STAT_LICHT_2_NR, "\"0-n\"");

    unsigned char STAT_ABSCHALTUNG_LICHT_2_WERT = (RXBUF_UCHAR(21));
        // Switch off light at SFG (it was switched off after 12 hours and the start capability limit was reached). /
        // Abschaltung Licht bei SFG (fand eine Abschaltung nach Ablauf 12h und Erreichen der Startfähigkeitsgrenze
        // statt).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_ABSCHALTUNG_LICHT_2_WERT", STAT_ABSCHALTUNG_LICHT_2_WERT, "");

    unsigned char STAT_ABSCHALTVERHINDERER_2_WERT = (RXBUF_UCHAR(22));
        // Shutdown prevention reason light (reaching upper start capability limit and 12h timer not expired, driver's
        // door not opened, further tbd). / Abschaltverhinderergrund Licht (Erreichen obere Startfähigkeitsgrenze und 12h
        // Timer nicht abgelaufen, kein Öffnen der Fahrertür, weitere tbd).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_ABSCHALTVERHINDERER_2_WERT", STAT_ABSCHALTVERHINDERER_2_WERT, "");

    unsigned char STAT_KLEMMENSTATUS_2_WERT = (RXBUF_UCHAR(23));
        // Terminal status (at the time of entry / snapshot). / Klemmenstatus (zum Zeitpunkt des Eintrags/Snapshots).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZUSATZINFO_LICHT", "STAT_KLEMMENSTATUS_2_WERT", STAT_KLEMMENSTATUS_2_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HANDBREMSE_KONTAKT: {                                           // 0xD130
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HANDBREMSE_KONTAKT", 1);
        break;
    }

    unsigned char STAT_HANDBREMSE_KONTAKT_EIN = (RXBUF_UCHAR(0));
        // 0: handbrake released; 1: handbrake applied / 0: Handbremse gelöst; 1: Handbremse angezogen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HANDBREMSE_KONTAKT", "STAT_HANDBREMSE_KONTAKT_EIN", STAT_HANDBREMSE_KONTAKT_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_HINTEN_TASTER_LINKS: {                              // 0xD161
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_HINTEN_TASTER_LINKS", 1);
        break;
    }

    unsigned char STAT_TASTER_SITZHEIZUNG_HINTEN_LINKS_EIN = (RXBUF_UCHAR(0));
        // 0 = button not pressed, 1 = button pressed / 0 = Taste nicht betätigt, 1 = Taste betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_HINTEN_TASTER_LINKS", "STAT_TASTER_SITZHEIZUNG_HINTEN_LINKS_EIN", STAT_TASTER_SITZHEIZUNG_HINTEN_LINKS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_HINTEN_TASTER_RECHTS: {                             // 0xD162
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_HINTEN_TASTER_RECHTS", 1);
        break;
    }

    unsigned char STAT_TASTER_SITZHEIZUNG_HINTEN_RECHTS_EIN = (RXBUF_UCHAR(0));
        // 0 = button not pressed, 1 = button pressed / 0 = Taste nicht betätigt, 1 = Taste betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_HINTEN_TASTER_RECHTS", "STAT_TASTER_SITZHEIZUNG_HINTEN_RECHTS_EIN", STAT_TASTER_SITZHEIZUNG_HINTEN_RECHTS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FA_TASTER: {                                                 // 0xD188
    if (datalen < 9) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FA_TASTER", 9);
        break;
    }

    unsigned char STAT_TASTER_FA_FA_NR = (RXBUF_UCHAR(0));
        // Driver's side (keypad): Driver button, see table / Fahrerseite (Tastenblock): Taster Fahrer siehe Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_TASTER", "STAT_TASTER_FA_FA_NR", STAT_TASTER_FA_FA_NR, "\"0-n\"");

    unsigned char STAT_TASTER_FA_BF_NR = (RXBUF_UCHAR(1));
        // Driver's side (keypad): See table for co-driver button / Fahrerseite (Tastenblock): Taster Beifahrer siehe
        // Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_TASTER", "STAT_TASTER_FA_BF_NR", STAT_TASTER_FA_BF_NR, "\"0-n\"");

    unsigned char STAT_TASTER_FA_FAH_NR = (RXBUF_UCHAR(2));
        // Driver's side (keypad): Rear driver button, see table / Fahrerseite (Tastenblock): Taster Fahrer hinten siehe
        // Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_TASTER", "STAT_TASTER_FA_FAH_NR", STAT_TASTER_FA_FAH_NR, "\"0-n\"");

    unsigned char STAT_TASTER_FA_BFH_NR = (RXBUF_UCHAR(3));
        // Driver's side (keypad): Rear passenger button see table / Fahrerseite (Tastenblock): Taster Beifahrer hinten
        // siehe Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_TASTER", "STAT_TASTER_FA_BFH_NR", STAT_TASTER_FA_BFH_NR, "\"0-n\"");

    unsigned char STAT_TASTER_FA_HS_NR = (RXBUF_UCHAR(4));
        // Driver's side (keypad): button H rear window see table / Fahrerseite (Tastenblock): Taster HEckscheibe siehe
        // Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_TASTER", "STAT_TASTER_FA_HS_NR", STAT_TASTER_FA_HS_NR, "\"0-n\"");

    unsigned long STAT_TASTER_FA_RESERVE = (RXBUF_UINT32(5));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FA_TASTER", "STAT_TASTER_FA_RESERVE", STAT_TASTER_FA_RESERVE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BF_TASTER: {                                                 // 0xD189
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BF_TASTER", 1);
        break;
    }

    unsigned char STAT_TASTER_BF_BF_NR = (RXBUF_UCHAR(0));
        // Passenger side (local button): Window lifter, passenger side 0: Button not pressed 1: Open window 2: Close
        // window 3: Open toll window 4: Close toll window / Beifahrerseite (lokaler Taster):  Fensterheber
        // Beifahrerseite 0: Taster nicht gedrueckt 1: Fenster oeffnen 2: Fenster schliessen 3: Fenster Maut oeffnen 4:
        // Fenster Maut schliessen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_TASTER", "STAT_TASTER_BF_BF_NR", STAT_TASTER_BF_BF_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FAH_TASTER: {                                                // 0xD18A
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FAH_TASTER", 1);
        break;
    }

    unsigned char STAT_TASTER_FAH_FAH_NR = (RXBUF_UCHAR(0));
        // Rear driver's side (local button): Windows rear driver's side 0: Button not pressed 1: Open window 2: Close
        // window 3: Open toll window 4: Close toll window / Fahrerseite hinten (lokaler Taster): Fensterheber
        // Fahrerseite hinten 0: Taster nicht gedrueckt 1: Fenster oeffnen 2: Fenster schliessen 3: Fenster Maut oeffnen
        // 4: Fenster Maut schliessen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_TASTER", "STAT_TASTER_FAH_FAH_NR", STAT_TASTER_FAH_FAH_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BFH_TASTER: {                                                // 0xD18B
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BFH_TASTER", 1);
        break;
    }

    unsigned char STAT_TASTER_BFH_BFH_NR = (RXBUF_UCHAR(0));
        // Rear passenger side (local button): Windows passenger side 0: button not pressed 1: open window 2: close
        // window 3: open window toll 4: close window toll / Beifahrerseite hinten (lokaler Taster):  Fensterheber
        // Beifahrerseite 0: Taster nicht gedrueckt 1: oeffnen Fenster  2: schliessen Fenster  3: oeffnen Fenster Maut 
        // 4: schliessen Fenster Maut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_TASTER", "STAT_TASTER_BFH_BFH_NR", STAT_TASTER_BFH_BFH_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_KISI_LED: {                                                  // 0xD18D
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_KISI_LED", 2);
        break;
    }

    short STAT_KISI_LED_EIN = (RXBUF_SINT(0));
        // 0: Status LED child lock off 1: Status LED child lock on / 0: Status LED Kindersicherung aus 1: Status LED
        // Kindersicherung ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_KISI_LED", "STAT_KISI_LED_EIN", STAT_KISI_LED_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FA_BEWEGUNG: {                                               // 0xD1A7
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FA_BEWEGUNG", 20);
        break;
    }

    unsigned char STAT_FH_FA_INIT_NR = (RXBUF_UCHAR(0));
        // 0x01 - INIT window regulator complete IO 0x02 - 0x08 One or more errors have occurred / 0x01 - Fensterheber
        // INIT vollständig IO 0x02 - 0x08 Ein oder mehrere Fehler sind aufgetreten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_INIT_NR", STAT_FH_FA_INIT_NR, "\"0-n\"");

    unsigned char STAT_FH_FA_BEWEGUNG_NR = (RXBUF_UCHAR(1));
        // Current direction of movement / Aktuelle Bewegungsrichtung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_BEWEGUNG_NR", STAT_FH_FA_BEWEGUNG_NR, "\"0-n\"");

    unsigned char STAT_FH_FA_POSITION_NR = (RXBUF_UCHAR(2));
        // Current position of the window regulator / Aktuelle Position des Fensterhebers
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_POSITION_NR", STAT_FH_FA_POSITION_NR, "\"0-n\"");

    short STAT_FH_FA_POSITION_HALL_WERT = (RXBUF_SINT(3));
        // Current window regulator position in Hall pulses (0 means completely closed) / Aktuelle Fensterheber-Position
        // in Hall-Pulsen (0 bedeutet komplett geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_POSITION_HALL_WERT", STAT_FH_FA_POSITION_HALL_WERT, "\"Ink\"");

    short STAT_FH_FA_POSITION_HALL_MAX_WERT = (RXBUF_SINT(5));
        // Maximum window regulator position in Hall pulses / Maximale Fensterheber-Position in Hall-Pulsen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_POSITION_HALL_MAX_WERT", STAT_FH_FA_POSITION_HALL_MAX_WERT, "\"Ink\"");

    short STAT_FH_FA_POSITION_MM_WERT = (RXBUF_SINT(7));
        // Current window regulator position in millimeters (0 means completely closed) / Aktuelle Fensterheber-Position
        // in Millimeter (0 bedeutet komplett geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_POSITION_MM_WERT", STAT_FH_FA_POSITION_MM_WERT, "\"mm\"");

    short STAT_FH_FA_POSITION_MM_MAX_WERT = (RXBUF_SINT(9));
        // Maximum window regulator position in millimeters / Maximale Fensterheber-Position in Millimeter
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_POSITION_MM_MAX_WERT", STAT_FH_FA_POSITION_MM_MAX_WERT, "\"mm\"");

    unsigned char STAT_FH_FA_POSITION_PROZENT_WERT = (RXBUF_UCHAR(11));
        // % of the maximum travel / % vom maximalen Verfahrweg
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_POSITION_PROZENT_WERT", STAT_FH_FA_POSITION_PROZENT_WERT, "\"%\"");

    unsigned char STAT_FH_FA_LAGE_NR = (RXBUF_UCHAR(12));
        // 0xFF: Window regulator value not used! / 0xFF: Wert von Fensterheber nicht belegt!
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_LAGE_NR", STAT_FH_FA_LAGE_NR, "\"0-n\"");

    unsigned char STAT_FH_FA_ZUSTAND_TUER_NR = (RXBUF_UCHAR(13));
        // Status of the door contact that is available to the motor driver. / Status Türkontakt, der den Motortreiber
        // zur Verfügung steht.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_ZUSTAND_TUER_NR", STAT_FH_FA_ZUSTAND_TUER_NR, "\"0-n\"");

    unsigned char STAT_FH_FA_FREIGABE_AKTIV_NR = (RXBUF_UCHAR(14));
        // Current status release from the ZV master / Aktueller Zustand Freigabe vom ZV-Master
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_FREIGABE_AKTIV_NR", STAT_FH_FA_FREIGABE_AKTIV_NR, "\"0-n\"");

    unsigned char STAT_FH_FA_PANIKMODUS_AKTIV_NR = (RXBUF_UCHAR(15));
        // Status link enable panic mode / Status Verknüpfung Freigabe Panikmodus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_PANIKMODUS_AKTIV_NR", STAT_FH_FA_PANIKMODUS_AKTIV_NR, "\"0-n\"");

    unsigned long STAT_FH_FA_RESERVE = (RXBUF_UINT32(16));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FA_BEWEGUNG", "STAT_FH_FA_RESERVE", STAT_FH_FA_RESERVE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BF_BEWEGUNG: {                                               // 0xD1A8
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BF_BEWEGUNG", 20);
        break;
    }

    unsigned char STAT_FH_BF_INIT_NR = (RXBUF_UCHAR(0));
        // 0x01 - INIT window regulator complete IO 0x02 - 0x08 One or more errors have occurred / 0x01 - Fensterheber
        // INIT vollständig IO 0x02 - 0x08 Ein oder mehrere Fehler sind aufgetreten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_INIT_NR", STAT_FH_BF_INIT_NR, "\"0-n\"");

    unsigned char STAT_FH_BF_BEWEGUNG_NR = (RXBUF_UCHAR(1));
        // Current direction of movement / Aktuelle Bewegungsrichtung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_BEWEGUNG_NR", STAT_FH_BF_BEWEGUNG_NR, "\"0-n\"");

    unsigned char STAT_FH_BF_POSITION_NR = (RXBUF_UCHAR(2));
        // Current position of the window regulator / Aktuelle Position des Fensterhebers
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_POSITION_NR", STAT_FH_BF_POSITION_NR, "\"0-n\"");

    short STAT_FH_BF_POSITION_HALL_WERT = (RXBUF_SINT(3));
        // Current window regulator position in Hall pulses (0 means completely closed) / Aktuelle Fensterheber-Position
        // in Hall-Pulsen (0 bedeutet komplett geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_POSITION_HALL_WERT", STAT_FH_BF_POSITION_HALL_WERT, "\"Ink\"");

    short STAT_FH_BF_POSITION_HALL_MAX_WERT = (RXBUF_SINT(5));
        // Maximum window regulator position in Hall pulses / Maximale Fensterheber-Position in Hall-Pulsen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_POSITION_HALL_MAX_WERT", STAT_FH_BF_POSITION_HALL_MAX_WERT, "\"Ink\"");

    short STAT_FH_BF_POSITION_MM_WERT = (RXBUF_SINT(7));
        // Current window regulator position in millimeters (0 means completely closed) / Aktuelle Fensterheber-Position
        // in Millimeter (0 bedeutet komplett geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_POSITION_MM_WERT", STAT_FH_BF_POSITION_MM_WERT, "\"mm\"");

    short STAT_FH_BF_POSITION_MM_MAX_WERT = (RXBUF_SINT(9));
        // Maximum window regulator position in millimeters / Maximale Fensterheber-Position in Millimeter
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_POSITION_MM_MAX_WERT", STAT_FH_BF_POSITION_MM_MAX_WERT, "\"mm\"");

    unsigned char STAT_FH_BF_POSITION_PROZENT_WERT = (RXBUF_UCHAR(11));
        // % of the maximum travel / % vom maximalen Verfahrweg
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_POSITION_PROZENT_WERT", STAT_FH_BF_POSITION_PROZENT_WERT, "\"%\"");

    unsigned char STAT_FH_BF_LAGE_NR = (RXBUF_UCHAR(12));
        // 0xFF: Value from window regulator not used! / 0xFF: Wert vom Fensterheber nicht belegt!
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_LAGE_NR", STAT_FH_BF_LAGE_NR, "\"0-n\"");

    unsigned char STAT_FH_BF_ZUSTAND_TUER_NR = (RXBUF_UCHAR(13));
        // Status of the door contact that is available to the motor driver. / Status Türkontakt, der den Motortreiber
        // zur Verfügung steht.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_ZUSTAND_TUER_NR", STAT_FH_BF_ZUSTAND_TUER_NR, "\"0-n\"");

    unsigned char STAT_FH_BF_FREIGABE_AKTIV_NR = (RXBUF_UCHAR(14));
        // Current status release from the ZV master / Aktueller Zustand Freigabe vom ZV-Master
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_FREIGABE_AKTIV_NR", STAT_FH_BF_FREIGABE_AKTIV_NR, "\"0-n\"");

    unsigned char STAT_FH_BF_PANIKMODUS_AKTIV_NR = (RXBUF_UCHAR(15));
        // Status link enable panic mode / Status Verknüpfung Freigabe Panikmodus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_PANIKMODUS_AKTIV_NR", STAT_FH_BF_PANIKMODUS_AKTIV_NR, "\"0-n\"");

    unsigned long STAT_FH_BF_RESERVE = (RXBUF_UINT32(16));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_BF_BEWEGUNG", "STAT_FH_BF_RESERVE", STAT_FH_BF_RESERVE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FAH_BEWEGUNG: {                                              // 0xD1A9
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FAH_BEWEGUNG", 20);
        break;
    }

    unsigned char STAT_FH_FAH_INIT_NR = (RXBUF_UCHAR(0));
        // 0x01 - INIT window regulator complete IO 0x02 - 0x08 One or more errors have occurred / 0x01 - Fensterheber
        // INIT vollständig IO 0x02 - 0x08 Ein oder mehrere Fehler sind aufgetreten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_INIT_NR", STAT_FH_FAH_INIT_NR, "\"0-n\"");

    unsigned char STAT_FH_FAH_BEWEGUNG_NR = (RXBUF_UCHAR(1));
        // Current direction of movement / Aktuelle Bewegungsrichtung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_BEWEGUNG_NR", STAT_FH_FAH_BEWEGUNG_NR, "\"0-n\"");

    unsigned char STAT_FH_FAH_POSITION_NR = (RXBUF_UCHAR(2));
        // Current position of the window regulator / Aktuelle Position des Fensterhebers
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_POSITION_NR", STAT_FH_FAH_POSITION_NR, "\"0-n\"");

    short STAT_FH_FAH_POSITION_HALL_WERT = (RXBUF_SINT(3));
        // Current window regulator position in Hall pulses (0 means completely closed) / Aktuelle Fensterheber-Position
        // in Hall-Pulsen (0 bedeutet komplett geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_POSITION_HALL_WERT", STAT_FH_FAH_POSITION_HALL_WERT, "\"Ink\"");

    short STAT_FH_FAH_POSITION_HALL_MAX_WERT = (RXBUF_SINT(5));
        // Maximum window regulator position in Hall pulses / Maximale Fensterheber-Position in Hall-Pulsen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_POSITION_HALL_MAX_WERT", STAT_FH_FAH_POSITION_HALL_MAX_WERT, "\"Ink\"");

    short STAT_FH_FAH_POSITION_MM_WERT = (RXBUF_SINT(7));
        // Current window regulator position in millimeters (0 means completely closed) / Aktuelle Fensterheber-Position
        // in Millimeter (0 bedeutet komplett geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_POSITION_MM_WERT", STAT_FH_FAH_POSITION_MM_WERT, "\"mm\"");

    short STAT_FH_FAH_POSITION_MM_MAX_WERT = (RXBUF_SINT(9));
        // Maximum window regulator position in millimeters / Maximale Fensterheber-Position in Millimeter
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_POSITION_MM_MAX_WERT", STAT_FH_FAH_POSITION_MM_MAX_WERT, "\"mm\"");

    unsigned char STAT_FH_FAH_POSITION_PROZENT_WERT = (RXBUF_UCHAR(11));
        // % of the maximum travel / % vom maximalen Verfahrweg
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_POSITION_PROZENT_WERT", STAT_FH_FAH_POSITION_PROZENT_WERT, "\"%\"");

    unsigned char STAT_FH_FAH_LAGE_NR = (RXBUF_UCHAR(12));
        // 0xFF: Value from window regulator not used! / 0xFF: Wert vom Fensterheber nicht belegt!
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_LAGE_NR", STAT_FH_FAH_LAGE_NR, "\"0-n\"");

    unsigned char STAT_FH_FAH_ZUSTAND_TUER_NR = (RXBUF_UCHAR(13));
        // Status of the door contact that is available to the motor driver. / Status Türkontakt, der den Motortreiber
        // zur Verfügung steht.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_ZUSTAND_TUER_NR", STAT_FH_FAH_ZUSTAND_TUER_NR, "\"0-n\"");

    unsigned char STAT_FH_FAH_FREIGABE_AKTIV_NR = (RXBUF_UCHAR(14));
        // Current status release from the ZV master / Aktueller Zustand Freigabe vom ZV-Master
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_FREIGABE_AKTIV_NR", STAT_FH_FAH_FREIGABE_AKTIV_NR, "\"0-n\"");

    unsigned char STAT_FH_FAH_PANIKMODUS_AKTIV_NR = (RXBUF_UCHAR(15));
        // Status link enable panic mode / Status Verknüpfung Freigabe Panikmodus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_PANIKMODUS_AKTIV_NR", STAT_FH_FAH_PANIKMODUS_AKTIV_NR, "\"0-n\"");

    unsigned long STAT_FH_FAH_RESERVE = (RXBUF_UINT32(16));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FAH_BEWEGUNG", "STAT_FH_FAH_RESERVE", STAT_FH_FAH_RESERVE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BFH_BEWEGUNG: {                                              // 0xD1AA
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BFH_BEWEGUNG", 20);
        break;
    }

    unsigned char STAT_FH_BFH_INIT_NR = (RXBUF_UCHAR(0));
        // 0x01 - INIT window regulator complete IO 0x02 - 0x08 One or more errors have occurred / 0x01 - Fensterheber
        // INIT vollständig IO 0x02 - 0x08 Ein oder mehrere Fehler sind aufgetreten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_INIT_NR", STAT_FH_BFH_INIT_NR, "\"0-n\"");

    unsigned char STAT_FH_BFH_BEWEGUNG_NR = (RXBUF_UCHAR(1));
        // Current direction of movement / Aktuelle Bewegungsrichtung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_BEWEGUNG_NR", STAT_FH_BFH_BEWEGUNG_NR, "\"0-n\"");

    unsigned char STAT_FH_BFH_POSITION_NR = (RXBUF_UCHAR(2));
        // Current position of the window regulator / Aktuelle Position des Fensterhebers
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_POSITION_NR", STAT_FH_BFH_POSITION_NR, "\"0-n\"");

    short STAT_FH_BFH_POSITION_HALL_WERT = (RXBUF_SINT(3));
        // Current window regulator position in Hall pulses (0 means completely closed) / Aktuelle Fensterheber-Position
        // in Hall-Pulsen (0 bedeutet komplett geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_POSITION_HALL_WERT", STAT_FH_BFH_POSITION_HALL_WERT, "\"Ink\"");

    short STAT_FH_BFH_POSITION_HALL_MAX_WERT = (RXBUF_SINT(5));
        // Maximum window regulator position in Hall pulses / Maximale Fensterheber-Position in Hall-Pulsen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_POSITION_HALL_MAX_WERT", STAT_FH_BFH_POSITION_HALL_MAX_WERT, "\"Ink\"");

    short STAT_FH_BFH_POSITION_MM_WERT = (RXBUF_SINT(7));
        // Current window regulator position in millimeters (0 means completely closed) / Aktuelle Fensterheber-Position
        // in Millimeter (0 bedeutet komplett geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_POSITION_MM_WERT", STAT_FH_BFH_POSITION_MM_WERT, "\"mm\"");

    short STAT_FH_BFH_POSITION_MM_MAX_WERT = (RXBUF_SINT(9));
        // Maximum window regulator position in millimeters / Maximale Fensterheber-Position in Millimeter
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_POSITION_MM_MAX_WERT", STAT_FH_BFH_POSITION_MM_MAX_WERT, "\"mm\"");

    unsigned char STAT_FH_BFH_POSITION_PROZENT_WERT = (RXBUF_UCHAR(11));
        // % of the maximum travel / % vom maximalen Verfahrweg
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_POSITION_PROZENT_WERT", STAT_FH_BFH_POSITION_PROZENT_WERT, "\"%\"");

    unsigned char STAT_FH_BFH_LAGE_NR = (RXBUF_UCHAR(12));
        // 0xFF: Value from window regulator not used! / 0xFF: Wert vom Fensterheber nicht belegt!
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_LAGE_NR", STAT_FH_BFH_LAGE_NR, "\"0-n\"");

    unsigned char STAT_FH_BFH_ZUSTAND_TUER_NR = (RXBUF_UCHAR(13));
        // Status of the door contact that is available to the motor driver. / Status Türkontakt, der den Motortreiber
        // zur Verfügung steht.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_ZUSTAND_TUER_NR", STAT_FH_BFH_ZUSTAND_TUER_NR, "\"0-n\"");

    unsigned char STAT_FH_BFH_FREIGABE_AKTIV_NR = (RXBUF_UCHAR(14));
        // Current status release from the ZV master / Aktueller Zustand Freigabe vom ZV-Master
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_FREIGABE_AKTIV_NR", STAT_FH_BFH_FREIGABE_AKTIV_NR, "\"0-n\"");

    unsigned char STAT_FH_BFH_PANIKMODUS_AKTIV_NR = (RXBUF_UCHAR(15));
        // Status link enable panic mode / Status Verknüpfung Freigabe Panikmodus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_PANIKMODUS_AKTIV_NR", STAT_FH_BFH_PANIKMODUS_AKTIV_NR, "\"0-n\"");

    unsigned long STAT_FH_BFH_RESERVE = (RXBUF_UINT32(16));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_BFH_BEWEGUNG", "STAT_FH_BFH_RESERVE", STAT_FH_BFH_RESERVE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BFH_RELAIS: {                                                // 0xD1AD
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BFH_RELAIS", 8);
        break;
    }

    unsigned char STAT_RELAIS_A_ANSTEUERUNG_EIN = (RXBUF_UCHAR(0));
        // Status control relay A 0: off 1: on / Status Ansteuerung Relais A 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_RELAIS", "STAT_RELAIS_A_ANSTEUERUNG_EIN", STAT_RELAIS_A_ANSTEUERUNG_EIN, "\"0/1\"");

    unsigned char STAT_RELAIS_A_RUECK_EIN = (RXBUF_UCHAR(1));
        // Status of the read-back line relay A 0: off 1: on / Status Rückleseleitung Relais A 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_RELAIS", "STAT_RELAIS_A_RUECK_EIN", STAT_RELAIS_A_RUECK_EIN, "\"0/1\"");

    unsigned char STAT_RELAIS_B_ANSTEUERUNG_EIN = (RXBUF_UCHAR(2));
        // Status control relay B 0: off 1: on / Status Ansteuerung Relais B 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_RELAIS", "STAT_RELAIS_B_ANSTEUERUNG_EIN", STAT_RELAIS_B_ANSTEUERUNG_EIN, "\"0/1\"");

    unsigned char STAT_RELAIS_B_RUECK_EIN = (RXBUF_UCHAR(3));
        // Status of the readback line relay B 0: off 1: on / Status Rückleseleitung Relais B 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_RELAIS", "STAT_RELAIS_B_RUECK_EIN", STAT_RELAIS_B_RUECK_EIN, "\"0/1\"");

    unsigned short STAT_RELAIS_A_VERSORGUNG_WERT = (RXBUF_UINT(4));
        // The input voltage at the relay is measured. This is ultimately also the terminal voltage of the motor if you
        // neglect contact resistances on relays and plugs as well as line resistances. The function is carried out by
        // the BSW. / Es wird die Eingangsspannung am Relais gemessen. Dies ist dann letztendlich auch die
        // Klemmenspannung des Motors, wenn man Kontaktwiderstände an Relais und Stecker sowie Leitungswiderstände
        // vernachlässigt. Die Funktion wird von der BSW ausgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "FH_BFH_RELAIS", "STAT_RELAIS_A_VERSORGUNG_WERT", STAT_RELAIS_A_VERSORGUNG_WERT, "\"mV\"");

    unsigned short STAT_RELAIS_B_VERSORGUNG_WERT = (RXBUF_UINT(6));
        // The input voltage at the relay is measured. This is ultimately also the terminal voltage of the motor if you
        // neglect contact resistances on relays and plugs as well as line resistances. The function is carried out by
        // the BSW. / Es wird die Eingangsspannung am Relais gemessen. Dies ist dann letztendlich auch die
        // Klemmenspannung des Motors, wenn man Kontaktwiderstände an Relais und Stecker sowie Leitungswiderstände
        // vernachlässigt. Die Funktion wird von der BSW ausgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "FH_BFH_RELAIS", "STAT_RELAIS_B_VERSORGUNG_WERT", STAT_RELAIS_B_VERSORGUNG_WERT, "\"mV\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BFH_HALLSENSOREN: {                                          // 0xD1AE
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BFH_HALLSENSOREN", 6);
        break;
    }

    unsigned char STAT_HALL_A_SCHALTZUSTAND_EIN = (RXBUF_UCHAR(0));
        // The function is carried out by the BSW. 0: off 1: on / Die Funktion wird von der BSW ausgeführt. 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_HALLSENSOREN", "STAT_HALL_A_SCHALTZUSTAND_EIN", STAT_HALL_A_SCHALTZUSTAND_EIN, "\"0/1\"");

    unsigned char STAT_HALL_A_VERSORGUNG_EIN = (RXBUF_UCHAR(1));
        // Switching status of Hall element A supply / Schaltzustand Hallelement A Versorgung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_HALLSENSOREN", "STAT_HALL_A_VERSORGUNG_EIN", STAT_HALL_A_VERSORGUNG_EIN, "\"0/1\"");

    unsigned char STAT_HALL_A_FEHLERZUSZTAND_NR = (RXBUF_UCHAR(2));
        // Hall element A fault condition / Fehlerzustand Hallelement A
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_HALLSENSOREN", "STAT_HALL_A_FEHLERZUSZTAND_NR", STAT_HALL_A_FEHLERZUSZTAND_NR, "\"0-n\"");

    unsigned char STAT_HALL_B_SCHALTZUSTAND_EIN = (RXBUF_UCHAR(3));
        // The function is carried out by the BSW. 0: off 1: on / Die Funktion wird von der BSW ausgeführt. 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_HALLSENSOREN", "STAT_HALL_B_SCHALTZUSTAND_EIN", STAT_HALL_B_SCHALTZUSTAND_EIN, "\"0/1\"");

    unsigned char STAT_HALL_B_VERSORGUNG_EIN = (RXBUF_UCHAR(4));
        // Switching state of Hall element B supply / Schaltzustand Hallelement B Versorgung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_HALLSENSOREN", "STAT_HALL_B_VERSORGUNG_EIN", STAT_HALL_B_VERSORGUNG_EIN, "\"0/1\"");

    unsigned char STAT_HALL_B_FEHLERZUSZTAND_NR = (RXBUF_UCHAR(5));
        // Hall element error condition B / Fehlerzustand Hallelement B
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_HALLSENSOREN", "STAT_HALL_B_FEHLERZUSZTAND_NR", STAT_HALL_B_FEHLERZUSZTAND_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FAH_RELAIS: {                                                // 0xD1AF
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FAH_RELAIS", 8);
        break;
    }

    unsigned char STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1AF = (RXBUF_UCHAR(0));
        // Status control relay A 0: off 1: on / Status Ansteuerung Relais A 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_RELAIS", "STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1AF", STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1AF, "\"0/1\"");

    unsigned char STAT_RELAIS_A_RUECK_EIN_0XD1AF = (RXBUF_UCHAR(1));
        // Status of the read-back line relay A 0: off 1: on / Status Rückleseleitung Relais A 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_RELAIS", "STAT_RELAIS_A_RUECK_EIN_0XD1AF", STAT_RELAIS_A_RUECK_EIN_0XD1AF, "\"0/1\"");

    unsigned char STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1AF = (RXBUF_UCHAR(2));
        // Status control relay B 0: off 1: on / Status Ansteuerung Relais B 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_RELAIS", "STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1AF", STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1AF, "\"0/1\"");

    unsigned char STAT_RELAIS_B_RUECK_EIN_0XD1AF = (RXBUF_UCHAR(3));
        // Status of the readback line relay B 0: off 1: on / Status Rückleseleitung Relais B 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_RELAIS", "STAT_RELAIS_B_RUECK_EIN_0XD1AF", STAT_RELAIS_B_RUECK_EIN_0XD1AF, "\"0/1\"");

    unsigned short STAT_RELAIS_A_VERSORGUNG_WERT_0XD1AF = (RXBUF_UINT(4));
        // The input voltage at the relay is measured. This is ultimately also the terminal voltage of the motor if you
        // neglect contact resistances on relays and plugs as well as line resistances. The function is carried out by
        // the BSW. / Es wird die Eingangsspannung am Relais gemessen. Dies ist dann letztendlich auch die
        // Klemmenspannung des Motors, wenn man Kontaktwiderstände an Relais und Stecker sowie Leitungswiderstände
        // vernachlässigt. Die Funktion wird von der BSW ausgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "FH_FAH_RELAIS", "STAT_RELAIS_A_VERSORGUNG_WERT_0XD1AF", STAT_RELAIS_A_VERSORGUNG_WERT_0XD1AF, "\"mV\"");

    unsigned short STAT_RELAIS_B_VERSORGUNG_WERT_0XD1AF = (RXBUF_UINT(6));
        // The input voltage at the relay is measured. This is ultimately also the terminal voltage of the motor if you
        // neglect contact resistances on relays and plugs as well as line resistances. The function is carried out by
        // the BSW. / Es wird die Eingangsspannung am Relais gemessen. Dies ist dann letztendlich auch die
        // Klemmenspannung des Motors, wenn man Kontaktwiderstände an Relais und Stecker sowie Leitungswiderstände
        // vernachlässigt. Die Funktion wird von der BSW ausgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "FH_FAH_RELAIS", "STAT_RELAIS_B_VERSORGUNG_WERT_0XD1AF", STAT_RELAIS_B_VERSORGUNG_WERT_0XD1AF, "\"mV\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FAH_HALLSENSOREN: {                                          // 0xD1B0
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FAH_HALLSENSOREN", 6);
        break;
    }

    unsigned char STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B0 = (RXBUF_UCHAR(0));
        // The function is carried out by the BSW. 0: off 1: on / Die Funktion wird von der BSW ausgeführt. 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_HALLSENSOREN", "STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B0", STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B0, "\"0/1\"");

    unsigned char STAT_HALL_A_VERSORGUNG_EIN_0XD1B0 = (RXBUF_UCHAR(1));
        // Switching status of Hall element A supply / Schaltzustand Hallelement A Versorgung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_HALLSENSOREN", "STAT_HALL_A_VERSORGUNG_EIN_0XD1B0", STAT_HALL_A_VERSORGUNG_EIN_0XD1B0, "\"0/1\"");

    unsigned char STAT_HALL_A_FEHLERZUSZTAND_NR_0XD1B0 = (RXBUF_UCHAR(2));
        // Hall element A fault condition / Fehlerzustand Hallelement A
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_HALLSENSOREN", "STAT_HALL_A_FEHLERZUSZTAND_NR_0XD1B0", STAT_HALL_A_FEHLERZUSZTAND_NR_0XD1B0, "\"0-n\"");

    unsigned char STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B0 = (RXBUF_UCHAR(3));
        // The function is carried out by the BSW. 0: off 1: on / Die Funktion wird von der BSW ausgeführt. 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_HALLSENSOREN", "STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B0", STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B0, "\"0/1\"");

    unsigned char STAT_HALL_B_VERSORGUNG_EIN_1 = (RXBUF_UCHAR(4));
        // Switching state of Hall element B supply / Schaltzustand Hallelement B Versorgung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_HALLSENSOREN", "STAT_HALL_B_VERSORGUNG_EIN_1", STAT_HALL_B_VERSORGUNG_EIN_1, "\"0/1\"");

    unsigned char STAT_HALL_B_FEHLERZUSZTAND_NR_0XD1B0 = (RXBUF_UCHAR(5));
        // Hall element error condition B / Fehlerzustand Hallelement B
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_HALLSENSOREN", "STAT_HALL_B_FEHLERZUSZTAND_NR_0XD1B0", STAT_HALL_B_FEHLERZUSZTAND_NR_0XD1B0, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FA_RELAIS: {                                                 // 0xD1B1
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FA_RELAIS", 8);
        break;
    }

    unsigned char STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1B1 = (RXBUF_UCHAR(0));
        // Status control relay A 0: off 1: on / Status Ansteuerung Relais A 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_RELAIS", "STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1B1", STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1B1, "\"0/1\"");

    unsigned char STAT_RELAIS_A_RUECK_EIN_0XD1B1 = (RXBUF_UCHAR(1));
        // Status of the read-back line relay A 0: off 1: on / Status Rückleseleitung Relais A 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_RELAIS", "STAT_RELAIS_A_RUECK_EIN_0XD1B1", STAT_RELAIS_A_RUECK_EIN_0XD1B1, "\"0/1\"");

    unsigned char STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1B1 = (RXBUF_UCHAR(2));
        // Status control relay B 0: off 1: on / Status Ansteuerung Relais B 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_RELAIS", "STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1B1", STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1B1, "\"0/1\"");

    unsigned char STAT_RELAIS_B_RUECK_EIN_0XD1B1 = (RXBUF_UCHAR(3));
        // Status of the readback line relay B 0: off 1: on / Status Rückleseleitung Relais B 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_RELAIS", "STAT_RELAIS_B_RUECK_EIN_0XD1B1", STAT_RELAIS_B_RUECK_EIN_0XD1B1, "\"0/1\"");

    unsigned short STAT_RELAIS_A_VERSORGUNG_WERT_0XD1B1 = (RXBUF_UINT(4));
        // The input voltage at the relay is measured. This is ultimately also the terminal voltage of the motor if you
        // neglect contact resistances on relays and plugs as well as line resistances. The function is carried out by
        // the BSW. / Es wird die Eingangsspannung am Relais gemessen. Dies ist dann letztendlich auch die
        // Klemmenspannung des Motors, wenn man Kontaktwiderstände an Relais und Stecker sowie Leitungswiderstände
        // vernachlässigt. Die Funktion wird von der BSW ausgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "FH_FA_RELAIS", "STAT_RELAIS_A_VERSORGUNG_WERT_0XD1B1", STAT_RELAIS_A_VERSORGUNG_WERT_0XD1B1, "\"mV\"");

    unsigned short STAT_RELAIS_B_VERSORGUNG_WERT_0XD1B1 = (RXBUF_UINT(6));
        // The input voltage at the relay is measured. This is ultimately also the terminal voltage of the motor if you
        // neglect contact resistances on relays and plugs as well as line resistances. The function is carried out by
        // the BSW. / Es wird die Eingangsspannung am Relais gemessen. Dies ist dann letztendlich auch die
        // Klemmenspannung des Motors, wenn man Kontaktwiderstände an Relais und Stecker sowie Leitungswiderstände
        // vernachlässigt. Die Funktion wird von der BSW ausgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "FH_FA_RELAIS", "STAT_RELAIS_B_VERSORGUNG_WERT_0XD1B1", STAT_RELAIS_B_VERSORGUNG_WERT_0XD1B1, "\"mV\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FA_HALLSENSOREN: {                                           // 0xD1B2
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FA_HALLSENSOREN", 6);
        break;
    }

    unsigned char STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B2 = (RXBUF_UCHAR(0));
        // The function is carried out by the BSW. 0: off 1: on / Die Funktion wird von der BSW ausgeführt. 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_HALLSENSOREN", "STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B2", STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B2, "\"0/1\"");

    unsigned char STAT_HALL_A_VERSORGUNG_EIN_0XD1B2 = (RXBUF_UCHAR(1));
        // Switching status of Hall element A supply / Schaltzustand Hallelement A Versorgung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_HALLSENSOREN", "STAT_HALL_A_VERSORGUNG_EIN_0XD1B2", STAT_HALL_A_VERSORGUNG_EIN_0XD1B2, "\"0/1\"");

    unsigned char STAT_HALL_A_FEHLERZUSTAND_NR = (RXBUF_UCHAR(2));
        // Hall element A fault condition / Fehlerzustand Hallelement A
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_HALLSENSOREN", "STAT_HALL_A_FEHLERZUSTAND_NR", STAT_HALL_A_FEHLERZUSTAND_NR, "\"0-n\"");

    unsigned char STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B2 = (RXBUF_UCHAR(3));
        // The function is carried out by the BSW. 0: off 1: on / Die Funktion wird von der BSW ausgeführt. 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_HALLSENSOREN", "STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B2", STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B2, "\"0/1\"");

    unsigned char STAT_HALL_B_VERSORGUNG_EIN_0XD1B2 = (RXBUF_UCHAR(4));
        // Switching state of Hall element B supply / Schaltzustand Hallelement B Versorgung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_HALLSENSOREN", "STAT_HALL_B_VERSORGUNG_EIN_0XD1B2", STAT_HALL_B_VERSORGUNG_EIN_0XD1B2, "\"0/1\"");

    unsigned char STAT_HALL_B_FEHLERZUSTAND_NR = (RXBUF_UCHAR(5));
        // Hall element error condition B / Fehlerzustand Hallelement B
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_HALLSENSOREN", "STAT_HALL_B_FEHLERZUSTAND_NR", STAT_HALL_B_FEHLERZUSTAND_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BF_RELAIS: {                                                 // 0xD1B3
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BF_RELAIS", 8);
        break;
    }

    unsigned char STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1B3 = (RXBUF_UCHAR(0));
        // Status control relay A 0: off 1: on / Status Ansteuerung Relais A 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_RELAIS", "STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1B3", STAT_RELAIS_A_ANSTEUERUNG_EIN_0XD1B3, "\"0/1\"");

    unsigned char STAT_RELAIS_A_RUECK_EIN_0XD1B3 = (RXBUF_UCHAR(1));
        // Status of the read-back line relay A 0: off 1: on / Status Rückleseleitung Relais A 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_RELAIS", "STAT_RELAIS_A_RUECK_EIN_0XD1B3", STAT_RELAIS_A_RUECK_EIN_0XD1B3, "\"0/1\"");

    unsigned char STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1B3 = (RXBUF_UCHAR(2));
        // Status control relay B 0: off 1: on / Status Ansteuerung Relais B 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_RELAIS", "STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1B3", STAT_RELAIS_B_ANSTEUERUNG_EIN_0XD1B3, "\"0/1\"");

    unsigned char STAT_RELAIS_B_RUECK_EIN_0XD1B3 = (RXBUF_UCHAR(3));
        // Status of the readback line relay B 0: off 1: on / Status Rückleseleitung Relais B 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_RELAIS", "STAT_RELAIS_B_RUECK_EIN_0XD1B3", STAT_RELAIS_B_RUECK_EIN_0XD1B3, "\"0/1\"");

    unsigned short STAT_RELAIS_A_VERSORGUNG_WERT_0XD1B3 = (RXBUF_UINT(4));
        // The input voltage at the relay is measured. This is ultimately also the terminal voltage of the motor if you
        // neglect contact resistances on relays and plugs as well as line resistances. The function is carried out by
        // the BSW. / Es wird die Eingangsspannung am Relais gemessen. Dies ist dann letztendlich auch die
        // Klemmenspannung des Motors, wenn man Kontaktwiderstände an Relais und Stecker sowie Leitungswiderstände
        // vernachlässigt. Die Funktion wird von der BSW ausgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "FH_BF_RELAIS", "STAT_RELAIS_A_VERSORGUNG_WERT_0XD1B3", STAT_RELAIS_A_VERSORGUNG_WERT_0XD1B3, "\"mV\"");

    unsigned short STAT_RELAIS_B_VERSORGUNG_WERT_0XD1B3 = (RXBUF_UINT(6));
        // The input voltage at the relay is measured. This is ultimately also the terminal voltage of the motor if you
        // neglect contact resistances on relays and plugs as well as line resistances. The function is carried out by
        // the BSW. / Es wird die Eingangsspannung am Relais gemessen. Dies ist dann letztendlich auch die
        // Klemmenspannung des Motors, wenn man Kontaktwiderstände an Relais und Stecker sowie Leitungswiderstände
        // vernachlässigt. Die Funktion wird von der BSW ausgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "FH_BF_RELAIS", "STAT_RELAIS_B_VERSORGUNG_WERT_0XD1B3", STAT_RELAIS_B_VERSORGUNG_WERT_0XD1B3, "\"mV\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BF_HALLSENSOREN: {                                           // 0xD1B4
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BF_HALLSENSOREN", 6);
        break;
    }

    unsigned char STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B4 = (RXBUF_UCHAR(0));
        // The function is carried out by the BSW. 0: off 1: on / Die Funktion wird von der BSW ausgeführt. 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_HALLSENSOREN", "STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B4", STAT_HALL_A_SCHALTZUSTAND_EIN_0XD1B4, "\"0/1\"");

    unsigned char STAT_HALL_A_VERSORGUNG_EIN_0XD1B4 = (RXBUF_UCHAR(1));
        // Switching status of Hall element A supply / Schaltzustand Hallelement A Versorgung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_HALLSENSOREN", "STAT_HALL_A_VERSORGUNG_EIN_0XD1B4", STAT_HALL_A_VERSORGUNG_EIN_0XD1B4, "\"0/1\"");

    unsigned char STAT_HALL_A_FEHLERZUSTAND_NR_0XD1B4 = (RXBUF_UCHAR(2));
        // Hall element A fault condition / Fehlerzustand Hallelement A
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_HALLSENSOREN", "STAT_HALL_A_FEHLERZUSTAND_NR_0XD1B4", STAT_HALL_A_FEHLERZUSTAND_NR_0XD1B4, "\"0-n\"");

    unsigned char STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B4 = (RXBUF_UCHAR(3));
        // The function is carried out by the BSW. 0: off 1: on / Die Funktion wird von der BSW ausgeführt. 0: aus 1: ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_HALLSENSOREN", "STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B4", STAT_HALL_B_SCHALTZUSTAND_EIN_0XD1B4, "\"0/1\"");

    unsigned char STAT_HALL_B_VERSORGUNG_EIN_0XD1B4 = (RXBUF_UCHAR(4));
        // Switching state of Hall element B supply / Schaltzustand Hallelement B Versorgung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_HALLSENSOREN", "STAT_HALL_B_VERSORGUNG_EIN_0XD1B4", STAT_HALL_B_VERSORGUNG_EIN_0XD1B4, "\"0/1\"");

    unsigned char STAT_HALL_B_FEHLERZUSTAND_NR_0XD1B4 = (RXBUF_UCHAR(5));
        // Hall element error condition B / Fehlerzustand Hallelement B
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_HALLSENSOREN", "STAT_HALL_B_FEHLERZUSTAND_NR_0XD1B4", STAT_HALL_B_FEHLERZUSTAND_NR_0XD1B4, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FA_STATUS_DETAIL: {                                          // 0xD1B5
    if (datalen < 26) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FA_STATUS_DETAIL", 26);
        break;
    }

    unsigned char STAT_FH_FA_KURZHUB_VORHANDEN = (RXBUF_UCHAR(0));
        // Coding option status / Status der Kodieroption
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_KURZHUB_VORHANDEN", STAT_FH_FA_KURZHUB_VORHANDEN, "\"0-n\"");

    unsigned char STAT_FH_FA_MOTORTEMPERATUR_NR = (RXBUF_UCHAR(1));
        // Motor temperature status / Status Motortemperatur
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_MOTORTEMPERATUR_NR", STAT_FH_FA_MOTORTEMPERATUR_NR, "\"0-n\"");

    float STAT_FH_FA_AUSSENTEMPERATUR_WERT = (RXBUF_UCHAR(2)/2.0f-40.0);
        // Vehicle outside temperature (via CAN) / Fahrzeugaussentemperatur (über CAN)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_AUSSENTEMPERATUR_WERT", STAT_FH_FA_AUSSENTEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_FH_FA_MT_LIEFERANT_NR = (RXBUF_UCHAR(3));
        // Supplier MT / Lieferant MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_MT_LIEFERANT_NR", STAT_FH_FA_MT_LIEFERANT_NR, "\"0-n\"");

    unsigned long STAT_FH_FA_MT_SW_VERSION_WERT = (RXBUF_UINT32(4));
        // SW version number / SW-Versionsnummer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_MT_SW_VERSION_WERT", STAT_FH_FA_MT_SW_VERSION_WERT, "\"HEX\"");

    unsigned long STAT_FH_FA_MT_PARAMETER_VERSION_WERT = (RXBUF_UINT32(8));
        // Description: Parameter version information / Beschreibung: Parameter-Versionsinfo
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_MT_PARAMETER_VERSION_WERT", STAT_FH_FA_MT_PARAMETER_VERSION_WERT, "\"HEX\"");

    unsigned char STAT_FH_FA_EEPROM_PRUEFSUMME_NR = (RXBUF_UCHAR(12));
        // Status EEPROM checksum / Status EEPROM Checksumme
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_EEPROM_PRUEFSUMME_NR", STAT_FH_FA_EEPROM_PRUEFSUMME_NR, "\"0-n\"");

    unsigned char STAT_FH_FA_STATUS_VON_FAH = (RXBUF_UCHAR(13));
        // Status of other window same side / Status anderes Fenster gleiche Seite
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_STATUS_VON_FAH", STAT_FH_FA_STATUS_VON_FAH, "\"0-n\"");

    unsigned char STAT_FH_FA_WACHHALTEN = (RXBUF_UCHAR(14));
        // Status asleep prevention / Status Einschlaf-Verhinderung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_WACHHALTEN", STAT_FH_FA_WACHHALTEN, "\"0-n\"");

    unsigned char STAT_FH_FA_FZG_GESCHWINDIGKEIT_WERT = (RXBUF_UCHAR(15));
        // Vehicle speed via CAN / Fahrzeuggeschwindigkeit über CAN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_FZG_GESCHWINDIGKEIT_WERT", STAT_FH_FA_FZG_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned long STAT_FH_FA_RELATIVZEIT_WERT = (RXBUF_UINT32(16));
        // Current relative time (as received from the bus) / Aktuelle Relativ-Zeit (wie vom Bus erhalten)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_RELATIVZEIT_WERT", STAT_FH_FA_RELATIVZEIT_WERT, "\"s\"");

    unsigned char STAT_FH_FA_TEMPERATUR_UEBERWACHUNG = (RXBUF_UCHAR(20));
        // Status activation temperature monitoring / Status Aktivierung Temperaturüberwachung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_TEMPERATUR_UEBERWACHUNG", STAT_FH_FA_TEMPERATUR_UEBERWACHUNG, "\"0/1\"");

    unsigned char STAT_FH_FA_EKS_AKTIV = (RXBUF_UCHAR(21));
        // Status activation EKS / Status Aktivierung EKS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_EKS_AKTIV", STAT_FH_FA_EKS_AKTIV, "\"0/1\"");

    unsigned char STAT_FH_FA_SYSTEMTYP = (RXBUF_UCHAR(22));
        // Placeholder for live system / Platzhalter für Stromgeführtes System
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FA_STATUS_DETAIL", "STAT_FH_FA_SYSTEMTYP", STAT_FH_FA_SYSTEMTYP, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BF_STATUS_DETAIL: {                                          // 0xD1B6
    if (datalen < 26) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BF_STATUS_DETAIL", 26);
        break;
    }

    unsigned char STAT_FH_BF_KURZHUB_VORHANDEN = (RXBUF_UCHAR(0));
        // Coding option status / Status der Kodieroption
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_KURZHUB_VORHANDEN", STAT_FH_BF_KURZHUB_VORHANDEN, "\"0-n\"");

    unsigned char STAT_FH_BF_MOTORTEMPERATUR = (RXBUF_UCHAR(1));
        // Motor temperature status / Status Motortemperatur
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_MOTORTEMPERATUR", STAT_FH_BF_MOTORTEMPERATUR, "\"0-n\"");

    float STAT_FH_BF_AUSSENTEMPERATUR_WERT = (RXBUF_UCHAR(2)/2.0f-40.0);
        // Vehicle outside temperature (via CAN) / Fahrzeugaussentemperatur (über CAN)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_AUSSENTEMPERATUR_WERT", STAT_FH_BF_AUSSENTEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_FH_BF_MT_LIEFERANT = (RXBUF_UCHAR(3));
        // Supplier MT / Lieferant MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_MT_LIEFERANT", STAT_FH_BF_MT_LIEFERANT, "\"0-n\"");

    unsigned long STAT_FH_BF_MT_SW_VERSION_WERT = (RXBUF_UINT32(4));
        // SW version number / SW-Versionsnummer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_MT_SW_VERSION_WERT", STAT_FH_BF_MT_SW_VERSION_WERT, "\"HEX\"");

    unsigned long STAT_FH_BF_MT_PARAMETER_VERSION_WERT = (RXBUF_UINT32(8));
        // Description: Parameter version information / Beschreibung: Parameter-Versionsinfo
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_MT_PARAMETER_VERSION_WERT", STAT_FH_BF_MT_PARAMETER_VERSION_WERT, "\"HEX\"");

    unsigned char STAT_FH_BF_EEPROM_PRUEFSUMME_NR = (RXBUF_UCHAR(12));
        // Status EEPROM checksum / Status EEPROM Checksumme
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_EEPROM_PRUEFSUMME_NR", STAT_FH_BF_EEPROM_PRUEFSUMME_NR, "\"0-n\"");

    unsigned char STAT_FH_BF_STATUS_VON_BFH = (RXBUF_UCHAR(13));
        // Status of other window same side / Status anderes Fenster gleiche Seite
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_STATUS_VON_BFH", STAT_FH_BF_STATUS_VON_BFH, "\"0-n\"");

    unsigned char STAT_FH_BF_WACHHALTEN = (RXBUF_UCHAR(14));
        // Status asleep prevention / Status Einschlaf-Verhinderung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_WACHHALTEN", STAT_FH_BF_WACHHALTEN, "\"0-n\"");

    unsigned char STAT_FH_BF_FZG_GESCHWINDIGKEIT_WERT = (RXBUF_UCHAR(15));
        // Vehicle speed via CAN / Fahrzeuggeschwindigkeit über CAN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_FZG_GESCHWINDIGKEIT_WERT", STAT_FH_BF_FZG_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned long STAT_FH_BF_RELATIVZEIT_WERT = (RXBUF_UINT32(16));
        // Current relative time (as received from the bus) / Aktuelle Relativ-Zeit (wie vom Bus erhalten)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_RELATIVZEIT_WERT", STAT_FH_BF_RELATIVZEIT_WERT, "\"s\"");

    unsigned char STAT_FH_BF_TEMPERATUR_UEBERWACHUNG = (RXBUF_UCHAR(20));
        // Status activation temperature monitoring / Status Aktivierung Temperaturüberwachung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_TEMPERATUR_UEBERWACHUNG", STAT_FH_BF_TEMPERATUR_UEBERWACHUNG, "\"0/1\"");

    unsigned char STAT_FH_BF_EKS_AKTIV = (RXBUF_UCHAR(21));
        // Status activation EKS / Status Aktivierung EKS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_EKS_AKTIV", STAT_FH_BF_EKS_AKTIV, "\"0/1\"");

    unsigned char STAT_FH_BF_SYSTEMTYP = (RXBUF_UCHAR(22));
        // Placeholder for live system / Platzhalter für Stromgeführtes System
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BF_STATUS_DETAIL", "STAT_FH_BF_SYSTEMTYP", STAT_FH_BF_SYSTEMTYP, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_FAH_STATUS_DETAIL: {                                         // 0xD1B7
    if (datalen < 26) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_FAH_STATUS_DETAIL", 26);
        break;
    }

    unsigned char STAT_FH_FAH_KURZHUB_VORHANDEN = (RXBUF_UCHAR(0));
        // Coding option status / Status der Kodieroption
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_KURZHUB_VORHANDEN", STAT_FH_FAH_KURZHUB_VORHANDEN, "\"0-n\"");

    unsigned char STAT_FH_FAH_MOTORTEMPERATUR = (RXBUF_UCHAR(1));
        // Motor temperature status / Status Motortemperatur
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_MOTORTEMPERATUR", STAT_FH_FAH_MOTORTEMPERATUR, "\"0-n\"");

    float STAT_FH_FAH_AUSSENTEMPERATUR_WERT = (RXBUF_UCHAR(2)/2.0f-40.0);
        // Vehicle outside temperature (via CAN) / Fahrzeugaussentemperatur (über CAN)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_AUSSENTEMPERATUR_WERT", STAT_FH_FAH_AUSSENTEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_FH_FAH_MT_LIEFERANT = (RXBUF_UCHAR(3));
        // Supplier MT / Lieferant MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_MT_LIEFERANT", STAT_FH_FAH_MT_LIEFERANT, "\"0-n\"");

    unsigned long STAT_FH_FAH_MT_SW_VERSION_WERT = (RXBUF_UINT32(4));
        // SW version number / SW-Versionsnummer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_MT_SW_VERSION_WERT", STAT_FH_FAH_MT_SW_VERSION_WERT, "\"HEX\"");

    unsigned long STAT_FH_FAH_MT_PARAMETER_VERSION_WERT = (RXBUF_UINT32(8));
        // Description: Parameter version information / Beschreibung: Parameter-Versionsinfo
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_MT_PARAMETER_VERSION_WERT", STAT_FH_FAH_MT_PARAMETER_VERSION_WERT, "\"HEX\"");

    unsigned char STAT_FH_FAH_EEPROM_PRUEFSUMME_NR = (RXBUF_UCHAR(12));
        // Status EEPROM checksum / Status EEPROM Checksumme
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_EEPROM_PRUEFSUMME_NR", STAT_FH_FAH_EEPROM_PRUEFSUMME_NR, "\"0-n\"");

    unsigned char STAT_FH_FAH_STATUS_VON_FA = (RXBUF_UCHAR(13));
        // Status of other window same side / Status anderes Fenster gleiche Seite
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_STATUS_VON_FA", STAT_FH_FAH_STATUS_VON_FA, "\"0-n\"");

    unsigned char STAT_FH_FAH_WACHHALTEN = (RXBUF_UCHAR(14));
        // Status asleep prevention / Status Einschlaf-Verhinderung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_WACHHALTEN", STAT_FH_FAH_WACHHALTEN, "\"0-n\"");

    unsigned char STAT_FH_FAH_FZG_GESCHWINDIGKEIT_WERT = (RXBUF_UCHAR(15));
        // Vehicle speed via CAN / Fahrzeuggeschwindigkeit über CAN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_FZG_GESCHWINDIGKEIT_WERT", STAT_FH_FAH_FZG_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned long STAT_FH_FAH_RELATIVZEIT_WERT = (RXBUF_UINT32(16));
        // Current relative time (as received from the bus) / Aktuelle Relativ-Zeit (wie vom Bus erhalten)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_RELATIVZEIT_WERT", STAT_FH_FAH_RELATIVZEIT_WERT, "\"s\"");

    unsigned char STAT_FH_FAH_TEMPERATUR_UEBERWACHUNG = (RXBUF_UCHAR(20));
        // Status activation temperature monitoring / Status Aktivierung Temperaturüberwachung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_TEMPERATUR_UEBERWACHUNG", STAT_FH_FAH_TEMPERATUR_UEBERWACHUNG, "\"0/1\"");

    unsigned char STAT_FH_FAH_EKS_AKTIV = (RXBUF_UCHAR(21));
        // Status activation EKS / Status Aktivierung EKS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_EKS_AKTIV", STAT_FH_FAH_EKS_AKTIV, "\"0/1\"");

    unsigned char STAT_FH_FAH_SYSTEMTYP = (RXBUF_UCHAR(22));
        // Placeholder for live system / Platzhalter für Stromgeführtes System
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_FAH_STATUS_DETAIL", "STAT_FH_FAH_SYSTEMTYP", STAT_FH_FAH_SYSTEMTYP, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FH_BFH_STATUS_DETAIL: {                                         // 0xD1B8
    if (datalen < 26) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FH_BFH_STATUS_DETAIL", 26);
        break;
    }

    unsigned char STAT_FH_BFH_KURZHUB_VORHANDEN = (RXBUF_UCHAR(0));
        // Coding option status / Status der Kodieroption
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_KURZHUB_VORHANDEN", STAT_FH_BFH_KURZHUB_VORHANDEN, "\"0-n\"");

    unsigned char STAT_FH_BFH_MOTORTEMPERATUR = (RXBUF_UCHAR(1));
        // Motor temperature status / Status Motortemperatur
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_MOTORTEMPERATUR", STAT_FH_BFH_MOTORTEMPERATUR, "\"0-n\"");

    float STAT_FH_BFH_AUSSENTEMPERATUR_WERT = (RXBUF_UCHAR(2)/2.0f-40.0);
        // Vehicle outside temperature (via CAN) / Fahrzeugaussentemperatur (über CAN)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_AUSSENTEMPERATUR_WERT", STAT_FH_BFH_AUSSENTEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_FH_BFH_MT_LIEFERANT = (RXBUF_UCHAR(3));
        // Supplier MT / Lieferant MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_MT_LIEFERANT", STAT_FH_BFH_MT_LIEFERANT, "\"0-n\"");

    unsigned long STAT_FH_BFH_MT_SW_VERSION_WERT = (RXBUF_UINT32(4));
        // SW version number / SW-Versionsnummer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_MT_SW_VERSION_WERT", STAT_FH_BFH_MT_SW_VERSION_WERT, "\"HEX\"");

    unsigned long STAT_FH_BFH_MT_PARAMETER_VERSION_WERT = (RXBUF_UINT32(8));
        // Description: Parameter version information / Beschreibung: Parameter-Versionsinfo
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_MT_PARAMETER_VERSION_WERT", STAT_FH_BFH_MT_PARAMETER_VERSION_WERT, "\"HEX\"");

    unsigned char STAT_FH_BFH_EEPROM_PRUEFSUMME_NR = (RXBUF_UCHAR(12));
        // Status EEPROM checksum / Status EEPROM Checksumme
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_EEPROM_PRUEFSUMME_NR", STAT_FH_BFH_EEPROM_PRUEFSUMME_NR, "\"0-n\"");

    unsigned char STAT_FH_BFH_STATUS_VON_BF = (RXBUF_UCHAR(13));
        // Status of other window same side / Status anderes Fenster gleiche Seite
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_STATUS_VON_BF", STAT_FH_BFH_STATUS_VON_BF, "\"0-n\"");

    unsigned char STAT_FH_BFH_WACHHALTEN = (RXBUF_UCHAR(14));
        // Status asleep prevention / Status Einschlaf-Verhinderung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_WACHHALTEN", STAT_FH_BFH_WACHHALTEN, "\"0-n\"");

    unsigned char STAT_FH_BFH_FZG_GESCHWINDIGKEIT_WERT = (RXBUF_UCHAR(15));
        // Vehicle speed via CAN / Fahrzeuggeschwindigkeit über CAN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_FZG_GESCHWINDIGKEIT_WERT", STAT_FH_BFH_FZG_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned long STAT_FH_BFH_RELATIVZEIT_WERT = (RXBUF_UINT32(16));
        // Current relative time (as received from the bus) / Aktuelle Relativ-Zeit (wie vom Bus erhalten)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_RELATIVZEIT_WERT", STAT_FH_BFH_RELATIVZEIT_WERT, "\"s\"");

    unsigned char STAT_FH_BFH_TEMPERATUR_UEBERWACHUNG = (RXBUF_UCHAR(20));
        // Status activation temperature monitoring / Status Aktivierung Temperaturüberwachung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_TEMPERATUR_UEBERWACHUNG", STAT_FH_BFH_TEMPERATUR_UEBERWACHUNG, "\"0/1\"");

    unsigned char STAT_FH_BFH_EKS_AKTIV = (RXBUF_UCHAR(21));
        // Status activation EKS / Status Aktivierung EKS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_EKS_AKTIV", STAT_FH_BFH_EKS_AKTIV, "\"0/1\"");

    unsigned char STAT_FH_BFH_SYSTEMTYP = (RXBUF_UCHAR(22));
        // Placeholder for live system / Platzhalter für Stromgeführtes System
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FH_BFH_STATUS_DETAIL", "STAT_FH_BFH_SYSTEMTYP", STAT_FH_BFH_SYSTEMTYP, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_SITZEXT_TASTEN: {                                        // 0xD1CA
    if (datalen < 12) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_SITZEXT_TASTEN", 12);
        break;
    }

    unsigned char STAT_SITZMEMORY_FA = (RXBUF_UCHAR(0));
        // Transmitted signal value for memory button / Übermittelter Signalwert für Memory-Taster
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_SITZMEMORY_FA", STAT_SITZMEMORY_FA, "\"0-n\"");

    unsigned char STAT_SITZMEMORY_BF = (RXBUF_UCHAR(1));
        // Transmitted signal value for memory button / Übermittelter Signalwert für Memory-Taster
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_SITZMEMORY_BF", STAT_SITZMEMORY_BF, "\"0-n\"");

    unsigned char STAT_SITZMEMORY_FAH = (RXBUF_UCHAR(2));
        // Transmitted signal value for memory button / Übermittelter Signalwert für Memory-Taster
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_SITZMEMORY_FAH", STAT_SITZMEMORY_FAH, "\"0-n\"");

    unsigned char STAT_SITZMEMORY_BFH = (RXBUF_UCHAR(3));
        // Transmitted signal value for memory button / Übermittelter Signalwert für Memory-Taster
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_SITZMEMORY_BFH", STAT_SITZMEMORY_BFH, "\"0-n\"");

    unsigned char STAT_MASSAGE_FA = (RXBUF_UCHAR(4));
        // Transmitted signal value for MASSAGE button / Übermittelter Signalwert für MASSAGE-Taster
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_MASSAGE_FA", STAT_MASSAGE_FA, "\"0-n\"");

    unsigned char STAT_MASSAGE_BF = (RXBUF_UCHAR(5));
        // Transmitted signal value for MASSAGE button / Übermittelter Signalwert für MASSAGE-Taster
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_MASSAGE_BF", STAT_MASSAGE_BF, "\"0-n\"");

    unsigned char STAT_MASSAGE_FAH = (RXBUF_UCHAR(6));
        // Transmitted signal value for MASSAGE button / Übermittelter Signalwert für MASSAGE-Taster
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_MASSAGE_FAH", STAT_MASSAGE_FAH, "\"0-n\"");

    unsigned char STAT_MASSAGE_BFH = (RXBUF_UCHAR(7));
        // Transmitted signal value for MASSAGE button / Übermittelter Signalwert für MASSAGE-Taster
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_MASSAGE_BFH", STAT_MASSAGE_BFH, "\"0-n\"");

    unsigned char STAT_FERNBEDIENUNG_FA = (RXBUF_UCHAR(8));
        // Signal value for remote control button button on driver's door / Signalwert für Fernbedienungstaste-Taste an
        // der Fahrertür
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_FERNBEDIENUNG_FA", STAT_FERNBEDIENUNG_FA, "\"0-n\"");

    unsigned char STAT_RESET_TASTE_BF = (RXBUF_UCHAR(9));
        // Signal value for reset button on BFT / Signalwert für Reset-Taste an BFT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_RESET_TASTE_BF", STAT_RESET_TASTE_BF, "\"0-n\"");

    unsigned char STAT_SCHLAFPOSITION_TASTE_BFTH = (RXBUF_UCHAR(10));
        // Signal value of the sleeping position button on the rear passenger door / Signalwert der Taste Schlafposition
        // an der Beifahrertür Fond
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_SCHLAFPOSITION_TASTE_BFTH", STAT_SCHLAFPOSITION_TASTE_BFTH, "\"0-n\"");

    unsigned char STAT_SITZPOSITION_TASTE_BFTH = (RXBUF_UCHAR(11));
        // Signal value for remote control button button on driver's door / Signalwert für Fernbedienungstaste-Taste an
        // der Fahrertür
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_TASTEN", "STAT_SITZPOSITION_TASTE_BFTH", STAT_SITZPOSITION_TASTE_BFTH, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_SITZEXT_VORHANDEN: {                                     // 0xD1CB
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_SITZEXT_VORHANDEN", 2);
        break;
    }

    unsigned char STAT_VORHANDEN_SITZEXT_VORNE = (RXBUF_UCHAR(0));
        // SB_SitzExt available for FA, BF / SB_SitzExt vorhanden für FA,BF 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_VORHANDEN", "STAT_VORHANDEN_SITZEXT_VORNE", STAT_VORHANDEN_SITZEXT_VORNE, "\"0-n\"");

    unsigned char STAT_VORHANDEN_SITZEXT_HINTEN = (RXBUF_UCHAR(1));
        // SB_SitzExt available for FA, BF / SB_SitzExt vorhanden für FA,BF 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_SITZEXT_VORHANDEN", "STAT_VORHANDEN_SITZEXT_HINTEN", STAT_VORHANDEN_SITZEXT_HINTEN, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_TANK_FUELLSTAND_LINKS: {                                        // 0xD258
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_TANK_FUELLSTAND_LINKS", 2);
        break;
    }

    unsigned short STAT_FUELLSTAND_TANK_LI_WERT = (RXBUF_UINT(0));
        // Returns the level value of the left tank sensor. The work area and IO area must be filled by the developer. /
        // Rückgabe des Füllstandwerts des linken Tanksensor. Arbeitsbereich und IO-Bereich muss vom Entwickler befüllt
        // werden.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "TANK_FUELLSTAND_LINKS", "STAT_FUELLSTAND_TANK_LI_WERT", STAT_FUELLSTAND_TANK_LI_WERT, "\"Ohm\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_TANK_FUELLSTAND_RECHTS: {                                       // 0xD259
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_TANK_FUELLSTAND_RECHTS", 2);
        break;
    }

    unsigned short STAT_FUELLSTAND_TANK_RE_WERT = (RXBUF_UINT(0));
        // Returns the fill level of the right tank sensor. The work area and IO area must be filled by the developer. /
        // Rückgabe des Füllstands des rechten Tanksensors. Arbeitsbereich und IO-Bereich muss vom Entwickler befüllt
        // werden.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "TANK_FUELLSTAND_RECHTS", "STAT_FUELLSTAND_TANK_RE_WERT", STAT_FUELLSTAND_TANK_RE_WERT, "\"Ohm\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HUPE_TASTER: {                                                  // 0xD297
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HUPE_TASTER", 1);
        break;
    }

    char STAT_TASTER_HUPE_EIN = (RXBUF_SCHAR(0));
        // 0 = horn button not actuated 1 = horn button actuated / 0= Taster Hupe nicht betätigt  1= Taster Hupe betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HUPE_TASTER", "STAT_TASTER_HUPE_EIN", STAT_TASTER_HUPE_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSENSPIEGEL_THERMOSCHUTZ: {                                   // 0xD321
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSENSPIEGEL_THERMOSCHUTZ", 2);
        break;
    }

    short STAT_SPIEGEL_THERMOSCHUTZ_AKTIV = (RXBUF_SINT(0));
        // 0: not active 1: active / 0: nicht aktiv 1: aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_THERMOSCHUTZ", "STAT_SPIEGEL_THERMOSCHUTZ_AKTIV", STAT_SPIEGEL_THERMOSCHUTZ_AKTIV, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSENSPIEGEL_LIN: {                                            // 0xD329
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSENSPIEGEL_LIN", 2);
        break;
    }

    short STAT_VORHANDEN_LIN_SPIEGEL_EIN = (RXBUF_SINT(0));
        // 0: No LIN outside mirror 1: LIN outside mirror / 0: Kein LIN-Aussenspiegel  1: LIN-Aussenspiegel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_LIN", "STAT_VORHANDEN_LIN_SPIEGEL_EIN", STAT_VORHANDEN_LIN_SPIEGEL_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSENSPIEGEL_MEM_VORHANDEN: {                                  // 0xD32B
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSENSPIEGEL_MEM_VORHANDEN", 2);
        break;
    }

    short STAT_VORHANDEN_SPIEGEL_MEMORY_EIN = (RXBUF_SINT(0));
        // 0: No memory function 1: Memory function / 0: Keine Memoryfunktion  1: Memoryfunktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_MEM_VORHANDEN", "STAT_VORHANDEN_SPIEGEL_MEMORY_EIN", STAT_VORHANDEN_SPIEGEL_MEMORY_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSENSPIEGEL_HEIZUNG_VERBAUT: {                                // 0xD32E
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSENSPIEGEL_HEIZUNG_VERBAUT", 2);
        break;
    }

    short STAT_VORHANDEN_SPIEGEL_HEIZUNG_EIN = (RXBUF_SINT(0));
        // 0: No mirror heating 1: Mirror heating / 0: Keine Spiegelheizung  1: Spiegelheizung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_HEIZUNG_VERBAUT", "STAT_VORHANDEN_SPIEGEL_HEIZUNG_EIN", STAT_VORHANDEN_SPIEGEL_HEIZUNG_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_EC_SPIEGEL_VORHANDEN: {                                         // 0xD330
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_EC_SPIEGEL_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_EC_SPIEGEL = (RXBUF_UCHAR(0));
        // 0: EC level not available; 1: EC mirror available / 0: EC-Spiegel nicht vorhanden; 1: EC-Spiegel vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "EC_SPIEGEL_VORHANDEN", "STAT_VORHANDEN_EC_SPIEGEL", STAT_VORHANDEN_EC_SPIEGEL, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSENSPIEGEL_TASTER: {                                         // 0xD331
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSENSPIEGEL_TASTER", 14);
        break;
    }

    short STAT_SPIEGEL_BEIKLAPPEN_EIN = (RXBUF_SINT(0));
        // 0: Fold-in mirror button not pressed 1: Fold-in mirror button pressed / 0: Taster Spiegel Beiklappen nicht
        // gedrückt  1: Taster Spiegel Beiklappen gedrückt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_TASTER", "STAT_SPIEGEL_BEIKLAPPEN_EIN", STAT_SPIEGEL_BEIKLAPPEN_EIN, "\"0/1\"");

    short STAT_SPIEGEL_SCHALTER_FA_EIN = (RXBUF_SINT(2));
        // Driver / passenger mirror selection 0: passenger mirror 1: driver mirror / Spiegelauswahl Fahrer / Beifahrer 
        // 0: Beifahrerspiegel  1: Fahrerspiegel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_TASTER", "STAT_SPIEGEL_SCHALTER_FA_EIN", STAT_SPIEGEL_SCHALTER_FA_EIN, "\"0/1\"");

    short STAT_SPIEGEL_TASTER_LINKS_EIN = (RXBUF_SINT(4));
        // 0: button not pressed 1: button pressed / 0: Taster nicht gedrückt  1: Taster gedrückt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_TASTER", "STAT_SPIEGEL_TASTER_LINKS_EIN", STAT_SPIEGEL_TASTER_LINKS_EIN, "\"0/1\"");

    short STAT_SPIEGEL_TASTER_OBEN_EIN = (RXBUF_SINT(6));
        // 0: button not pressed 1: button pressed / 0: Taster nicht gedrückt  1: Taster gedrückt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_TASTER", "STAT_SPIEGEL_TASTER_OBEN_EIN", STAT_SPIEGEL_TASTER_OBEN_EIN, "\"0/1\"");

    short STAT_SPIEGEL_TASTER_RECHTS_EIN = (RXBUF_SINT(8));
        // 0: button not pressed 1: button pressed / 0: Taster nicht gedrückt  1: Taster gedrückt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_TASTER", "STAT_SPIEGEL_TASTER_RECHTS_EIN", STAT_SPIEGEL_TASTER_RECHTS_EIN, "\"0/1\"");

    short STAT_SPIEGEL_TASTER_UNTEN_EIN = (RXBUF_SINT(10));
        // 0: button not pressed 1: button pressed / 0: Taster nicht gedrückt  1: Taster gedrückt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_TASTER", "STAT_SPIEGEL_TASTER_UNTEN_EIN", STAT_SPIEGEL_TASTER_UNTEN_EIN, "\"0/1\"");

    short STAT_SPIEGEL_TASTER_NR = (RXBUF_SINT(12));
        // VS result, see table / VS-Result, siehe Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_TASTER", "STAT_SPIEGEL_TASTER_NR", STAT_SPIEGEL_TASTER_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSENSPIEGEL_KLAPPEN_VORHANDEN: {                              // 0xD332
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSENSPIEGEL_KLAPPEN_VORHANDEN", 2);
        break;
    }

    short STAT_VORHANDEN_SPIEGEL_BEIKLAPPEN_EIN = (RXBUF_SINT(0));
        // 0: No folding in possible 1: Folding in possible / 0: Kein Beiklappen möglich  1: Beiklappne möglich
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_KLAPPEN_VORHANDEN", "STAT_VORHANDEN_SPIEGEL_BEIKLAPPEN_EIN", STAT_VORHANDEN_SPIEGEL_BEIKLAPPEN_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_UGDO_VORHANDEN: {                                               // 0xD33A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_UGDO_VORHANDEN", 2);
        break;
    }

    short STAT_VORHANDEN_UGDO = (RXBUF_SINT(0));
        // 0: UGDO not available; 1: UGDO available / 0: UGDO nicht vorhanden;  1: UGDO vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "UGDO_VORHANDEN", "STAT_VORHANDEN_UGDO", STAT_VORHANDEN_UGDO, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSENSPIEGEL_ABBLENDEN_VORHANDEN: {                            // 0xD33C
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSENSPIEGEL_ABBLENDEN_VORHANDEN", 2);
        break;
    }

    short STAT_VORHANDEN_SPIEGEL_ABBLENDEN_EIN = (RXBUF_SINT(0));
        // Returns whether the exterior mirrors can be dimmed and which ones. See table TAB_AUSSENSPIEGEL_ABBLENDEN /
        // Liefert zurück ob die Außenspiegel abblendbar sind und welche. Siehe Table TAB_AUSSENSPIEGEL_ABBLENDEN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "AUSSENSPIEGEL_ABBLENDEN_VORHANDEN", "STAT_VORHANDEN_SPIEGEL_ABBLENDEN_EIN", STAT_VORHANDEN_SPIEGEL_ABBLENDEN_EIN, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_UGDO_LAND: {                                                    // 0xD33D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_UGDO_LAND", 1);
        break;
    }

    unsigned char STAT_UGDO_LAND_NR = (RXBUF_UCHAR(0));
        // Set country / Eingestelltes Land
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "UGDO_LAND", "STAT_UGDO_LAND_NR", STAT_UGDO_LAND_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_UGDO_MODE: {                                                    // 0xD33E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_UGDO_MODE", 1);
        break;
    }

    unsigned char STAT_UGDO_MODE_NR = (RXBUF_UCHAR(0));
        // Fashion of the UGDO / Mode des UGDO
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "UGDO_MODE", "STAT_UGDO_MODE_NR", STAT_UGDO_MODE_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KOMPASS_SPIEGEL_VORHANDEN: {                                    // 0xD343
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KOMPASS_SPIEGEL_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_KOMPASS_SPIEGEL_VORHANDEN_EIN = (RXBUF_UCHAR(0));
        // 0: Compass mirror not installed 1: Compass mirror installed / 0: Kompass-Spiegel nicht verbaut  1:
        // Kompass-Spiegel verbaut
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KOMPASS_SPIEGEL_VORHANDEN", "STAT_KOMPASS_SPIEGEL_VORHANDEN_EIN", STAT_KOMPASS_SPIEGEL_VORHANDEN_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KOMPASS_SPIEGEL_MAGNET: {                                       // 0xD344
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KOMPASS_SPIEGEL_MAGNET", 1);
        break;
    }

    unsigned char STAT_KOMPASS_SPIEGEL_MAGNET_ZONE_NR = (RXBUF_UCHAR(0));
        // Output magnetic zone (from slave) For a listing, see table TAB_MAGNETZONE / Ausgabe Magnetzone (aus Slave) 
        // Auflistung siehe Tabelle TAB_MAGNETZONE
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KOMPASS_SPIEGEL_MAGNET", "STAT_KOMPASS_SPIEGEL_MAGNET_ZONE_NR", STAT_KOMPASS_SPIEGEL_MAGNET_ZONE_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KOMPASS_SPIEGEL_SPRACHE: {                                      // 0xD345
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KOMPASS_SPIEGEL_SPRACHE", 1);
        break;
    }

    unsigned char STAT_KOMPASS_SPIEGEL_SPRACHE_NR = (RXBUF_UCHAR(0));
        // Coding parameters from the master language setting list see table TAB_KOMPASS_SPRACHE / Codierparameter aus
        // dem Master Spracheinstellung Auflistung siehe Tabelle TAB_KOMPASS_SPRACHE
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KOMPASS_SPIEGEL_SPRACHE", "STAT_KOMPASS_SPIEGEL_SPRACHE_NR", STAT_KOMPASS_SPIEGEL_SPRACHE_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KOMPASS_SPIEGEL_LENKUNG: {                                      // 0xD346
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KOMPASS_SPIEGEL_LENKUNG", 1);
        break;
    }

    unsigned char STAT_KOMPASS_SPIEGEL_LENKUNG_NR = (RXBUF_UCHAR(0));
        // Coding parameters from the master 0: right-hand drive 1: left-hand drive / Codierparameter aus dem Master 0:
        // Rechtslenker  1: Linkslenker
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KOMPASS_SPIEGEL_LENKUNG", "STAT_KOMPASS_SPIEGEL_LENKUNG_NR", STAT_KOMPASS_SPIEGEL_LENKUNG_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_WISCHER_FRONT_MOTOR: {                                          // 0xD351
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_WISCHER_FRONT_MOTOR", 1);
        break;
    }

    unsigned char STAT_MOTOR_FRONTWISCHER_EIN = (RXBUF_UCHAR(0));
        // Supplies the status of the control of the front wiper: 0 = control of the front wiper not active; 1 = control
        // of windscreen wiper active / Liefert den Zustand der Ansteuerung des Frontscheibenwischers:  0= Ansteuerung
        // Frontscheibenwischer nicht aktiv; 1= Ansteuerung Frontscheibenwischer aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WISCHER_FRONT_MOTOR", "STAT_MOTOR_FRONTWISCHER_EIN", STAT_MOTOR_FRONTWISCHER_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_WISCHER_HECK_MOTOR: {                                           // 0xD353
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_WISCHER_HECK_MOTOR", 1);
        break;
    }

    unsigned char STAT_MOTOR_HECKWISCHER_EIN = (RXBUF_UCHAR(0));
        // Returns the status of the activation of the rear window wiper: 0 = activation of the rear window wiper not
        // active; 1 = control of rear window wiper active / Liefert den Zustand der Ansteuerung des
        // Heckscheibenwischers:  0= Ansteuerung Heckscheibenwischer nicht aktiv; 1= Ansteuerung Heckscheibenwischer
        // aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WISCHER_HECK_MOTOR", "STAT_MOTOR_HECKWISCHER_EIN", STAT_MOTOR_HECKWISCHER_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SRA_RELAIS: {                                                   // 0xD354
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SRA_RELAIS", 1);
        break;
    }

    unsigned char STAT_RELAIS_SRA_EIN = (RXBUF_UCHAR(0));
        // Supplies the status of the relay of the headlight cleaning system: 0 = relay headlight cleaning system not
        // active; 1 = Relay headlight cleaning system active / Liefert den Zustand des Relais der
        // Scheinwerferreinigungsanlage:  0= Relais Scheinwerferreinigungsanlage nicht aktiv;  1= Relais
        // Scheinwerferreinigungsanlage aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SRA_RELAIS", "STAT_RELAIS_SRA_EIN", STAT_RELAIS_SRA_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_WASCHWASSERSTAND: {                                             // 0xD357
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_WASCHWASSERSTAND", 3);
        break;
    }

    unsigned char STAT_WASCHWASSERSTAND_EIN = (RXBUF_UCHAR(0));
        // Filling status of the washing water tank: 0 = washing water tank not sufficiently filled; 1 = washing water
        // tank sufficiently filled / Befüllungszustand des  Waschwasserbehälters:  0= Waschwasserbehälter nicht
        // ausreichend befüllt; 1= Waschwasserbehälter ausreichend befüllt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WASCHWASSERSTAND", "STAT_WASCHWASSERSTAND_EIN", STAT_WASCHWASSERSTAND_EIN, "\"0/1\"");

    unsigned short STAT_WASCHWASSERSTAND_WERT = (RXBUF_UINT(1));
        // Specification of the level value in mv. 0xFFFF: invalid value or value not supported / Angabe des Pegelwerts
        // in mv. 0xFFFF: ungültiger Wert oder Wert nicht unterstützt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "WASCHWASSERSTAND", "STAT_WASCHWASSERSTAND_WERT", STAT_WASCHWASSERSTAND_WERT, "\"mV\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_WISCHER_HECK_VORHANDEN: {                                       // 0xD358
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_WISCHER_HECK_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_HECKWISCHER_EIN = (RXBUF_UCHAR(0));
        // 0: rear wiper not coded; 1: Coded rear wiper / 0: Heckwischer nicht codiert;  1: Heckwischer codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WISCHER_HECK_VORHANDEN", "STAT_VORHANDEN_HECKWISCHER_EIN", STAT_VORHANDEN_HECKWISCHER_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SRA_VORHANDEN: {                                                // 0xD359
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SRA_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_SRA = (RXBUF_UCHAR(0));
        // Indicates whether the headlight cleaning system is coded: 0 = headlight cleaning system not coded; 1 = coded
        // headlight cleaning system / Gibt an, ob die Scheinwerferreinigungsanlage codiert ist:  0=
        // Scheinwerferreinigungsanlage nicht codiert;  1= Scheinwerferreinigungsanlage codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SRA_VORHANDEN", "STAT_VORHANDEN_SRA", STAT_VORHANDEN_SRA, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKSTOCK_WISCHER: {                                            // 0xD35B
    if (datalen < 11) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKSTOCK_WISCHER", 11);
        break;
    }

    char STAT_LENKSTOCK_WISCHER_TASTER_AXIAL_EIN = (RXBUF_SCHAR(0));
        // Result not relevant / Ergebnis nicht relevant
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_TASTER_AXIAL_EIN", STAT_LENKSTOCK_WISCHER_TASTER_AXIAL_EIN, "\"0-n\"");

    char STAT_LENKSTOCK_WISCHER_FRONTWASCHEN = (RXBUF_SCHAR(1));
        // 0 = steering column wiper not in front wash position; 1 = steering column wiper in front washing position / 0=
        // Lenkstock Wischer nicht in Stellung Frontwaschen;  1= Lenkstock Wischer in Stellung Frontwaschen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_FRONTWASCHEN", STAT_LENKSTOCK_WISCHER_FRONTWASCHEN, "\"0/1\"");

    char STAT_LENKSTOCK_WISCHER_HECKWASCHEN = (RXBUF_SCHAR(2));
        // 0 = steering column wiper not in rear wash position; 1 = Wiper steering column in rear wash position / 0=
        // Lenkstock Wischer nicht in Stellung Heckwaschen;  1= Lenkstock Wischer in Stellung Heckwaschen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_HECKWASCHEN", STAT_LENKSTOCK_WISCHER_HECKWASCHEN, "\"0/1\"");

    char STAT_LENKSTOCK_WISCHER_HECKWISCHEN = (RXBUF_SCHAR(3));
        // 0 = steering column wiper not in rear wipe position; 1 = Wiper steering column in rear wiping position / 0=
        // Lenkstock Wischer nicht in Stellung Heckwischen;  1= Lenkstock Wischer in Stellung Heckwischen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_HECKWISCHEN", STAT_LENKSTOCK_WISCHER_HECKWISCHEN, "\"0/1\"");

    char STAT_LENKSTOCK_WISCHER_POS_INTERVALL = (RXBUF_SCHAR(4));
        // 0 = steering column wiper not in position interval or automatic; 1 = steering column wiper in position
        // interval or automatic / 0= Lenkstock Wischer nicht in Stellung Intervall oder Automatik; 1= Lenkstock Wischer
        // in Stellung Intervall oder Automatik
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_POS_INTERVALL", STAT_LENKSTOCK_WISCHER_POS_INTERVALL, "\"0/1\"");

    char STAT_LENKSTOCK_WISCHER_NULLSTELLUNG = (RXBUF_SCHAR(5));
        // 0 = steering column wiper not zero position; 1 = steering column wiper zero position; Note: With a switch, the
        // zero position corresponds to the Off stage, with a button, the zero position corresponds to the middle
        // position / 0= Lenkstock Wischer nicht Nullstellung;  1= Lenkstock Wischer Nullstellung;  Hinweis: Bei einem
        // Schalter entspricht die Nullstellung der Stufe Aus, bei einem Taster entspricht die Nullstellung der
        // Mittelstellung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_NULLSTELLUNG", STAT_LENKSTOCK_WISCHER_NULLSTELLUNG, "\"0/1\"");

    char STAT_LENKSTOCK_WISCHER_POS_1 = (RXBUF_SCHAR(6));
        // 0 = steering column wiper not in position 1; 1 = steering column wiper in position 1 / 0= Lenkstock Wischer
        // nicht in Stellung Position 1;  1= Lenkstock Wischer in Position 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_POS_1", STAT_LENKSTOCK_WISCHER_POS_1, "\"0/1\"");

    char STAT_LENKSTOCK_WISCHER_POS_2 = (RXBUF_SCHAR(7));
        // 0 = steering column wiper not in position 2; 1 = steering column wiper in position 2 / 0= Lenkstock Wischer
        // nicht in Stellung Position 2;  1= Lenkstock Wischer in Position 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_POS_2", STAT_LENKSTOCK_WISCHER_POS_2, "\"0/1\"");

    char STAT_LENKSTOCK_WISCHER_RAENDEL_NR = (RXBUF_SCHAR(8));
        // VS-Result steering column wiper; 0 = wiper knurled wheel level 1; 1 = wiper knurled wheel level 2; 2 = wiper
        // knurled wheel level 3; 3 = wiper knurled wheel level 4; 4 = wiper knurled wheel invalid position; Note:
        // Numbering is retained even if one or more functions are omitted / VS-Result Lenkstock Wischer;  0= Wischer
        // Rändelrad Stufe 1;  1= Wischer Rändelrad Stufe 2;  2= Wischer Rändelrad Stufe 3;  3= Wischer Rändelrad Stufe
        // 4;  4= Wischer Rändelrad ungültige Position; Hinweis: Numerierung bleibt erhalten, auch bei Entfall einer oder
        // mehrerer Funktionen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_RAENDEL_NR", STAT_LENKSTOCK_WISCHER_RAENDEL_NR, "\"0-n\"");

    char STAT_LENKSTOCK_WISCHER_TIPPWISCHEN = (RXBUF_SCHAR(9));
        // 0 = steering column wiper not in tip wipe position; 1 = Wiper steering column in tip wipe position / 0=
        // Lenkstock Wischer nicht in Stellung Tippwischen;  1= Lenkstock Wischer in Stellung Tippwischen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_TIPPWISCHEN", STAT_LENKSTOCK_WISCHER_TIPPWISCHEN, "\"0/1\"");

    char STAT_LENKSTOCK_WISCHER_NR = (RXBUF_SCHAR(10));
        // VS-Result steering column wiper; See sub-table / VS-Result Lenkstock Wischer; Siehe Sub-Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_WISCHER", "STAT_LENKSTOCK_WISCHER_NR", STAT_LENKSTOCK_WISCHER_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_WISCHER_FRONT_LIN: {                                            // 0xD35E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_WISCHER_FRONT_LIN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_LIN_FRONTWISCHER = (RXBUF_UCHAR(0));
        // Indicates whether the front wiper is installed as a LIN module: 0 = no LIN front wiper; 1 = LIN front wiper /
        // Gibt an, ob der Frontwischer als LIN-Modul verbaut ist:  0= kein LIN-Frontwischer;  1= LIN-Frontwischer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WISCHER_FRONT_LIN", "STAT_VORHANDEN_LIN_FRONTWISCHER", STAT_VORHANDEN_LIN_FRONTWISCHER, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_REGENSENSOR_VORHANDEN: {                                        // 0xD373
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_REGENSENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_REGENSENSOR_EIN = (RXBUF_UCHAR(0));
        // 0: rain sensor not available / coded; 1: Rain sensor available / coded / 0: Regensensor nicht vorhanden /
        // codiert; 1: Regensensor vorhanden / codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "REGENSENSOR_VORHANDEN", "STAT_VORHANDEN_REGENSENSOR_EIN", STAT_VORHANDEN_REGENSENSOR_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_REGENSENSOR_INIT: {                                             // 0xD375
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_REGENSENSOR_INIT", 1);
        break;
    }

    unsigned char STAT_REGENSENSOR_INIT = (RXBUF_UCHAR(0));
        // 0x00 rain sensor not measured 0x01 rain sensor measured / 0x00 Regensensor nicht eingemessen 0x01 Regensensor
        // eingemessen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "REGENSENSOR_INIT", "STAT_REGENSENSOR_INIT", STAT_REGENSENSOR_INIT, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_REGENSENSOR_INT_WERT: {                                         // 0xD376
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_REGENSENSOR_INT_WERT", 6);
        break;
    }

    float STAT_REGEN_INT_WERT = (RXBUF_SINT(0)/2.0f);
        // Rain intensity in 0 .. 75% / Regenintensität in 0 .. 75 %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "REGENSENSOR_INT_WERT", "STAT_REGEN_INT_WERT", STAT_REGEN_INT_WERT, "\"%\"");

    unsigned long STAT_RESERVE_WERT = (RXBUF_UINT32(2));
        // Reserve for future changes / Reserve für zukünftige Änderungen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "REGENSENSOR_INT_WERT", "STAT_RESERVE_WERT", STAT_RESERVE_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FAHRLICHTSENSOR: {                                              // 0xD3BE
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FAHRLICHTSENSOR", 14);
        break;
    }

    float STAT_FRONTLICHT_WERT = (RXBUF_UINT(0)*6.7f);
        // unfiltered front light value. Is between 0 and 1701.8 mW / m² / ungefilterter Frontlichtwert. Liegt zwischen 0
        // und 1701,8 mW/m²
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "FAHRLICHTSENSOR", "STAT_FRONTLICHT_WERT", STAT_FRONTLICHT_WERT, "\"mW/m²\"");

    float STAT_FRONTLICHT_GEMITTELT_WERT = (RXBUF_UINT(2)*6.7f);
        // averaged front light value. Is between 0 and 1701.7 mW / m² / gemittelter Frontlichtwert. Liegt zwischen 0 und
        // 1701,7  mW/m²
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "FAHRLICHTSENSOR", "STAT_FRONTLICHT_GEMITTELT_WERT", STAT_FRONTLICHT_GEMITTELT_WERT, "\"mW/m²\"");

    float STAT_UMGEBUNGSLICHT_WERT = (RXBUF_SINT(4)*100.0f);
        // unfiltered ambient light. Range 0 to 25500 lux / ungefiltetes Umgebungslicht. Bereich 0 bis 25500 Lux
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "FAHRLICHTSENSOR", "STAT_UMGEBUNGSLICHT_WERT", STAT_UMGEBUNGSLICHT_WERT, "\"Lux\"");

    float STAT_UMGEBUNGSLICHT_GEMITTELT_WERT = (RXBUF_SINT(6)*100.0f);
        // Average value of ambient light. Range 0 to 25500 lux / gemittelter Wert Umgebungslicht. Bereich 0 bis 25500
        // Lux
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "FAHRLICHTSENSOR", "STAT_UMGEBUNGSLICHT_GEMITTELT_WERT", STAT_UMGEBUNGSLICHT_GEMITTELT_WERT, "\"Lux\"");

    short STAT_HUD_WERT = (RXBUF_SINT(8));
        // unfiltered background brightness value. Range 0 to 255 / ungefilterter Wert Hintergrund-Helligkeit. Bereich 0
        // bis 255
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "FAHRLICHTSENSOR", "STAT_HUD_WERT", STAT_HUD_WERT, "\"Digit\"");

    unsigned long STAT_RESERVE_WERT_0XD3BE = (RXBUF_UINT32(10));
        // Reserve for future changes / Reserve für zukünftige Änderungen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "FAHRLICHTSENSOR", "STAT_RESERVE_WERT_0XD3BE", STAT_RESERVE_WERT_0XD3BE, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FAHRLICHTSENSOR_VORHANDEN: {                                    // 0xD3BF
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FAHRLICHTSENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_FAHRLICHTSENSOR = (RXBUF_UCHAR(0));
        // 1: Driving light sensor available / coded / 1:Fahrlichtsensor vorhanden/codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FAHRLICHTSENSOR_VORHANDEN", "STAT_VORHANDEN_FAHRLICHTSENSOR", STAT_VORHANDEN_FAHRLICHTSENSOR, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HOD_LENKRAD: {                                                  // 0xD3F0
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HOD_LENKRAD", 1);
        break;
    }

    unsigned char STAT_HOD_STATUS_NR = (RXBUF_UCHAR(0));
        // Returns the status of the HOD sensor / Liefert den Status des HOD Sensors
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HOD_LENKRAD", "STAT_HOD_STATUS_NR", STAT_HOD_STATUS_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HOD_ZUSTAND_GAP: {                                              // 0xD3F1
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HOD_ZUSTAND_GAP", 1);
        break;
    }

    char STAT_ADC_ROHWERT_WERT = (RXBUF_SCHAR(0));
        // Raw value measured by the A / D converter for the distance or the contact area between hand and steering wheel
        // / Vom A/D-Wandler gemessener Rohwert des Abstands bzw. der Berührungsfläche zwischen Hand und Lenkrad
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HOD_ZUSTAND_GAP", "STAT_ADC_ROHWERT_WERT", STAT_ADC_ROHWERT_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_WISCHER_LIN_DATEN_LESEN: {                                      // 0xD505
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_WISCHER_LIN_DATEN_LESEN", 3);
        break;
    }

    float STAT_ANZAHL_WISCHZYKLEN_WERT = (RXBUF_UINT(0)*100.0f);
        // Number of wiping cycles in steps of 100 / Anzahl der Wischzyklen in 100er Schritten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "WISCHER_LIN_DATEN_LESEN", "STAT_ANZAHL_WISCHZYKLEN_WERT", STAT_ANZAHL_WISCHZYKLEN_WERT, "");

    unsigned char STAT_CARCODE = (RXBUF_UCHAR(2));
        // Provides the carcode of the wiper motor / Liefert den Carcode des Wischermotors
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WISCHER_LIN_DATEN_LESEN", "STAT_CARCODE", STAT_CARCODE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_WISCHER_HECK_MOTOR_2: {                                         // 0xD507
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_WISCHER_HECK_MOTOR_2", 1);
        break;
    }

    unsigned char STAT_MOTOR_HECKWISCHER_2_EIN = (RXBUF_UCHAR(0));
        // Returns the status of the activation of the 2nd rear window wiper: 0 = activation of the 2nd rear window wiper
        // not active; 1 = activation of 2nd rear window wiper active / Liefert den Zustand der Ansteuerung des 2.
        // Heckscheibenwischers:  0= Ansteuerung 2. Heckscheibenwischer nicht aktiv; 1= Ansteuerung 2.
        // Heckscheibenwischer aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "WISCHER_HECK_MOTOR_2", "STAT_MOTOR_HECKWISCHER_2_EIN", STAT_MOTOR_HECKWISCHER_2_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_INNENLICHTEINHEIT_DRITTE_SITZREIHE: {                           // 0xD52C
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_INNENLICHTEINHEIT_DRITTE_SITZREIHE", 7);
        break;
    }

    unsigned char STAT_INNENLICHT = (RXBUF_UCHAR(0));
        // LIN status feedback ILE ¿status interior light Values: 0 - off, 1 - on / LIN Status-Rückmeldung ILE ¿ Status
        // Innenlicht Werte: 0 - Aus, 1 - Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHTEINHEIT_DRITTE_SITZREIHE", "STAT_INNENLICHT", STAT_INNENLICHT, "\"0/1\"");

    unsigned char STAT_LESELICHT_LINKS = (RXBUF_UCHAR(1));
        // LIN status feedback ILE ¿status reading light left Values: 0 - off, 1 - on / LIN Status-Rückmeldung ILE ¿
        // Status Leselicht links Werte: 0 - Aus, 1 - Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHTEINHEIT_DRITTE_SITZREIHE", "STAT_LESELICHT_LINKS", STAT_LESELICHT_LINKS, "\"0/1\"");

    unsigned char STAT_LESELICHT_RECHTS = (RXBUF_UCHAR(2));
        // LIN status feedback ILE ¿status reading light right Values: 0 - off, 1 - on / LIN Status-Rückmeldung ILE ¿
        // Status Leselicht rechts Werte: 0 - Aus, 1 - Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHTEINHEIT_DRITTE_SITZREIHE", "STAT_LESELICHT_RECHTS", STAT_LESELICHT_RECHTS, "\"0/1\"");

    unsigned char STAT_WELCOMELIGHT = (RXBUF_UCHAR(3));
        // LIN status feedback ILE ¿status welcome light Values: 0 - off, 1 - on / LIN Status-Rückmeldung ILE ¿ Status
        // Welcomelight Werte: 0 - Aus, 1 - Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHTEINHEIT_DRITTE_SITZREIHE", "STAT_WELCOMELIGHT", STAT_WELCOMELIGHT, "\"0/1\"");

    unsigned char STAT_AMBIENTELICHT = (RXBUF_UCHAR(4));
        // LIN status feedback ILE ¿Ambient light status Values: 0 - Off, 1 - On / LIN Status-Rückmeldung ILE ¿ Status
        // Ambientelicht Werte: 0 - Aus, 1 - Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHTEINHEIT_DRITTE_SITZREIHE", "STAT_AMBIENTELICHT", STAT_AMBIENTELICHT, "\"0/1\"");

    unsigned char STAT_TASTER_LESELICHT_LINKS = (RXBUF_UCHAR(5));
        // LIN status feedback ILE ¿Status button reading light left Values: 0 - not activated, 1 - activated / LIN
        // Status-Rückmeldung ILE ¿ Status Taster Leselicht links Werte: 0 - nicht betätigt, 1 - betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHTEINHEIT_DRITTE_SITZREIHE", "STAT_TASTER_LESELICHT_LINKS", STAT_TASTER_LESELICHT_LINKS, "\"0/1\"");

    unsigned char STAT_TASTER_LESELICHT_RECHTS = (RXBUF_UCHAR(6));
        // LIN status feedback ILE ¿Status button reading light right Values: 0 - not activated, 1 - activated / LIN
        // Status-Rückmeldung ILE ¿ Status Taster Leselicht rechts Werte: 0 - nicht betätigt, 1 - betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHTEINHEIT_DRITTE_SITZREIHE", "STAT_TASTER_LESELICHT_RECHTS", STAT_TASTER_LESELICHT_RECHTS, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LESELICHT_VORNE: {                                              // 0xD53A
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LESELICHT_VORNE", 4);
        break;
    }

    short STAT_LESELICHT_LINKS_VORNE = (RXBUF_SINT(0));
        // 1: Reading light on front left / 1: Leselicht links vorne ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_VORNE", "STAT_LESELICHT_LINKS_VORNE", STAT_LESELICHT_LINKS_VORNE, "\"0/1\"");

    short STAT_LESELICHT_RECHTS_VORNE = (RXBUF_SINT(2));
        // 1: Reading light on front right / 1: Leselicht rechts vorne ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_VORNE", "STAT_LESELICHT_RECHTS_VORNE", STAT_LESELICHT_RECHTS_VORNE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LICHTSCHALTER_WBL_TASTER_BEL: {                                 // 0xD53D
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LICHTSCHALTER_WBL_TASTER_BEL", 2);
        break;
    }

    short STAT_TASTER_WBL_BEL_EIN = (RXBUF_SINT(0));
        // 0: Bel. Hazard warning lights button off 1: Bel. Hazard warning lights button on / 0: Bel. Taster
        // Warnblinkanlage aus  1: Bel. Taster Warnblinkanlage ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LICHTSCHALTER_WBL_TASTER_BEL", "STAT_TASTER_WBL_BEL_EIN", STAT_TASTER_WBL_BEL_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_RUECKWAERTSGANG_SCHALTER: {                                     // 0xD540
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_RUECKWAERTSGANG_SCHALTER", 2);
        break;
    }

    short STAT_SCHALTER_RUECK_EIN = (RXBUF_SINT(0));
        // 0: not active 1: active / 0: nicht aktiv 1: aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "RUECKWAERTSGANG_SCHALTER", "STAT_SCHALTER_RUECK_EIN", STAT_SCHALTER_RUECK_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SCHEINWERFER_GRUNDSTELLUNG_STATUS: {                            // 0xD541
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SCHEINWERFER_GRUNDSTELLUNG_STATUS", 2);
        break;
    }

    short STAT_GRUNDSTELLUNG_SCHEINWERFER_EIN = (RXBUF_SINT(0));
        // 0: Headlight reacts to normal mechanism (manual LWR: reaction to small wheel automatic / dynamic LWR: reaction
        // to the height sensors 1: Headlights stay in their basic position (can only be canceled by diagnosis or
        // changing clamps) / 0: Scheinwerfer reagiert auf  normalen  Mechanismus (manuelle LWR: Reaktion auf Rädchen
        // automatische / dynamische LWR: Reaktion auf die Höhenstndssenoren  1: Scheinwerfer bleiben in Grundstellung
        // (aufheben nur per Diagnose oder Klemmenwechsel möglich)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "SCHEINWERFER_GRUNDSTELLUNG_STATUS", "STAT_GRUNDSTELLUNG_SCHEINWERFER_EIN", STAT_GRUNDSTELLUNG_SCHEINWERFER_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LESELICHT_VORNE_VORHANDEN: {                                    // 0xD544
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LESELICHT_VORNE_VORHANDEN", 2);
        break;
    }

    short STAT_VORHANDEN_LESELICHT_VORNE = (RXBUF_SINT(0));
        // 0 = front reading light not available, 1 = front reading light available / 0= Leselicht vorn nicht vorhanden,
        // 1= Leselicht vorne vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_VORNE_VORHANDEN", "STAT_VORHANDEN_LESELICHT_VORNE", STAT_VORHANDEN_LESELICHT_VORNE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LESELICHT_HINTEN_VORHANDEN: {                                   // 0xD545
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LESELICHT_HINTEN_VORHANDEN", 2);
        break;
    }

    short STAT_VORHANDEN_LESELICHT_HINTEN = (RXBUF_SINT(0));
        // 0 = rear reading light not available, 1 = rear reading light available / 0= Leselicht hinten nicht vorhanden,
        // 1= Leselicht hinten vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_HINTEN_VORHANDEN", "STAT_VORHANDEN_LESELICHT_HINTEN", STAT_VORHANDEN_LESELICHT_HINTEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LWR_DYNAMISCH_SCHRITTE_REFLAUF: {                               // 0xD548
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LWR_DYNAMISCH_SCHRITTE_REFLAUF", 2);
        break;
    }

    short STAT_VORHANDEN_LWR_SCHRITTE_REF_LAUF_WERT = (RXBUF_SINT(0));
        // Number of steps for the reference run of the headlight range control / Schrittanzahl fuer den Referenzlauf der
        // Leuchtweitenregelung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LWR_DYNAMISCH_SCHRITTE_REFLAUF", "STAT_VORHANDEN_LWR_SCHRITTE_REF_LAUF_WERT", STAT_VORHANDEN_LWR_SCHRITTE_REF_LAUF_WERT, "\"Ink\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_INNENLICHT_HINTEN_TASTER: {                                     // 0xD54B
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_INNENLICHT_HINTEN_TASTER", 1);
        break;
    }

    unsigned char STAT_INNENLICHT_TASTER_HINTEN_EIN = (RXBUF_UCHAR(0));
        // 0: button not pressed 1: button pressed / 0: Taster nicht betätigt 1: Taster betaetigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_HINTEN_TASTER", "STAT_INNENLICHT_TASTER_HINTEN_EIN", STAT_INNENLICHT_TASTER_HINTEN_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_INNENLICHT_VORNE_TASTER: {                                      // 0xD54C
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_INNENLICHT_VORNE_TASTER", 2);
        break;
    }

    unsigned char STAT_INNENLICHT_TASTER_VORNE_EIN = (RXBUF_UCHAR(0));
        // 0: button not pressed 1: button pressed / 0: Taster nicht betätigt 1: Taster betaetigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_VORNE_TASTER", "STAT_INNENLICHT_TASTER_VORNE_EIN", STAT_INNENLICHT_TASTER_VORNE_EIN, "\"0/1\"");

    unsigned char STAT_INNENLICHT_VORNE_DAUER_AUS_AKTIV = (RXBUF_UCHAR(1));
        // 0: permanently off not active 1: permanently off active / 0: Daueraus nicht aktiv 1: Daueraus aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_VORNE_TASTER", "STAT_INNENLICHT_VORNE_DAUER_AUS_AKTIV", STAT_INNENLICHT_VORNE_DAUER_AUS_AKTIV, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BUS_IN_BELADUNGSSENSOR: {                                       // 0xD54D
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BUS_IN_BELADUNGSSENSOR", 4);
        break;
    }

    short STAT_BUS_IN_BELADUNGSSENSOR_VORNE_WERT = (RXBUF_SINT(0));
        // Bus message front load sensor in mm / Busnachricht Beladungssensor vorne in mm
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "BUS_IN_BELADUNGSSENSOR", "STAT_BUS_IN_BELADUNGSSENSOR_VORNE_WERT", STAT_BUS_IN_BELADUNGSSENSOR_VORNE_WERT, "\"mm\"");

    short STAT_BUS_IN_BELADUNGSSENSOR_HINTEN_WERT = (RXBUF_SINT(2));
        // Bus message rear load sensor in mm / Busnachricht Beladungssensor hinten in mm
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "BUS_IN_BELADUNGSSENSOR", "STAT_BUS_IN_BELADUNGSSENSOR_HINTEN_WERT", STAT_BUS_IN_BELADUNGSSENSOR_HINTEN_WERT, "\"mm\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LESELICHT_HINTEN_RECHTS_TASTER: {                               // 0xD54E
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LESELICHT_HINTEN_RECHTS_TASTER", 2);
        break;
    }

    short STAT_TASTER_LESELICHT_HINTEN_RECHTS_EIN = (RXBUF_SINT(0));
        // 0: button not pressed 1: button pressed / 0: Taster nicht betätigt 1: Taster betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_HINTEN_RECHTS_TASTER", "STAT_TASTER_LESELICHT_HINTEN_RECHTS_EIN", STAT_TASTER_LESELICHT_HINTEN_RECHTS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LWR_MANUELL_POTI: {                                             // 0xD54F
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LWR_MANUELL_POTI", 2);
        break;
    }

    short STAT_POTI_MAN_LWR_WERT = (RXBUF_SINT(0));
        // Value of the knurled wheel of the manual LWR 0 - 254 valid value range 255 invalid / Wert des Rändelsrads der
        // manuellen LWR 0 - 254 gültiger Wertebereich  255 ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LWR_MANUELL_POTI", "STAT_POTI_MAN_LWR_WERT", STAT_POTI_MAN_LWR_WERT, "\"Ink\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LICHTSCHALTEREINHEIT: {                                         // 0xD550
    if (datalen < 5) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LICHTSCHALTEREINHEIT", 5);
        break;
    }

    unsigned char STAT_LICHTSCHALTEREINHEIT_AL_EIN = (RXBUF_UCHAR(0));
        // 0: switch not in low beam position 1: switch in low beam position / 0: Schalter nicht in Stellung Abblendlicht
        // 1: Schalter in Stellung Abblendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LICHTSCHALTEREINHEIT", "STAT_LICHTSCHALTEREINHEIT_AL_EIN", STAT_LICHTSCHALTEREINHEIT_AL_EIN, "\"0/1\"");

    unsigned char STAT_LICHTSCHALTEREINHEIT_FLC_EIN = (RXBUF_UCHAR(1));
        // 0: switch not in position driving light control (FLC) 1: switch in position driving light control (FLC) / 0:
        // Schalter nicht in Stellung Fahrlichtkontrolle (FLC) 1: Schalter in Stellung Fahrlichtkontrolle (FLC)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LICHTSCHALTEREINHEIT", "STAT_LICHTSCHALTEREINHEIT_FLC_EIN", STAT_LICHTSCHALTEREINHEIT_FLC_EIN, "\"0/1\"");

    unsigned char STAT_LICHTSCHALTEREINHEIT_NEUTRAL_EIN = (RXBUF_UCHAR(2));
        // 0: Switch not in neutral position 1: Switch in neutral position / 0: Schalter nicht in Stellung Neutral 1:
        // Schalter in Stellung Neutral
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LICHTSCHALTEREINHEIT", "STAT_LICHTSCHALTEREINHEIT_NEUTRAL_EIN", STAT_LICHTSCHALTEREINHEIT_NEUTRAL_EIN, "\"0/1\"");

    unsigned char STAT_LICHTSCHALTEREINHEIT_STL_EIN = (RXBUF_UCHAR(3));
        // 0: switch not in position light 1: switch in position position light / 0: Schalter nicht in Stellung
        // Standlicht 1: Schalter in Stellung Standlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LICHTSCHALTEREINHEIT", "STAT_LICHTSCHALTEREINHEIT_STL_EIN", STAT_LICHTSCHALTEREINHEIT_STL_EIN, "\"0/1\"");

    unsigned char STAT_LICHTSCHALTEREINHEIT_NR = (RXBUF_UCHAR(4));
        // VS result, meaning see table / VS-Result, Bedeutung siehe Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LICHTSCHALTEREINHEIT", "STAT_LICHTSCHALTEREINHEIT_NR", STAT_LICHTSCHALTEREINHEIT_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LICHTSCHALTER_WBL_TASTER: {                                     // 0xD552
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LICHTSCHALTER_WBL_TASTER", 1);
        break;
    }

    unsigned char STAT_TASTER_WBL_EIN = (RXBUF_UCHAR(0));
        // 0: button not pressed 1: button pressed / 0: Taster nicht betätigt  1: Taster betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LICHTSCHALTER_WBL_TASTER", "STAT_TASTER_WBL_EIN", STAT_TASTER_WBL_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LESELICHT_HINTEN: {                                             // 0xD553
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LESELICHT_HINTEN", 4);
        break;
    }

    short STAT_LESELICHT_LINKS_HINTEN = (RXBUF_SINT(0));
        // 1 = rear left reading light on / 1= Leselicht links hinten ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_HINTEN", "STAT_LESELICHT_LINKS_HINTEN", STAT_LESELICHT_LINKS_HINTEN, "\"0/1\"");

    short STAT_LESELICHT_RECHTS_HINTEN = (RXBUF_SINT(2));
        // 1: Reading light at the rear right on / 1: Leselicht rechts hinten ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_HINTEN", "STAT_LESELICHT_RECHTS_HINTEN", STAT_LESELICHT_RECHTS_HINTEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_PIA_FLA_FOLLOW: {                                               // 0xD555
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_PIA_FLA_FOLLOW", 3);
        break;
    }

    unsigned char STAT_PIA_FLA_EIN = (RXBUF_UCHAR(0));
        // PIA high beam assistant 0: Off 1: On / PIA Fernlichtassistent  0: Aus  1: Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_FLA_FOLLOW", "STAT_PIA_FLA_EIN", STAT_PIA_FLA_EIN, "\"0/1\"");

    unsigned char STAT_PIA_FOLLOW_ME_HOME_ZEIT_WERT = (RXBUF_UCHAR(1));
        // Set time for Follow Me Home / Eingestellte Zeit für Follow Me Home
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_FLA_FOLLOW", "STAT_PIA_FOLLOW_ME_HOME_ZEIT_WERT", STAT_PIA_FOLLOW_ME_HOME_ZEIT_WERT, "\"s\"");

    unsigned char STAT_PIA_WELCOMELIGHT_EIN = (RXBUF_UCHAR(2));
        // PIA Welcomelight 0: Off 1: On / PIA Welcomelight  0: Aus  1: Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_FLA_FOLLOW", "STAT_PIA_WELCOMELIGHT_EIN", STAT_PIA_WELCOMELIGHT_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SCHALTERBELEUCHTUNG_RAENDELRAD: {                               // 0xD557
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SCHALTERBELEUCHTUNG_RAENDELRAD", 2);
        break;
    }

    short STAT_POTI_DIMMUNG_WERT = (RXBUF_SINT(0));
        // 0 - 254: valid value range 255 invalid / 0 - 254: gültiger Wertebereich  255 ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "SCHALTERBELEUCHTUNG_RAENDELRAD", "STAT_POTI_DIMMUNG_WERT", STAT_POTI_DIMMUNG_WERT, "\"Ink\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_PIA_ABBIEGELICHT: {                                             // 0xD559
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_PIA_ABBIEGELICHT", 1);
        break;
    }

    unsigned char STAT_PIA_ABBIEGELICHT_PIA_EIN = (RXBUF_UCHAR(0));
        // 0: PIA: turning light currently not active 1: PIA: turning light currently active / 0: PIA: Abbiegelicht
        // momentan nicht aktiv 1: PIA: Abbiegelicht momentan aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_ABBIEGELICHT", "STAT_PIA_ABBIEGELICHT_PIA_EIN", STAT_PIA_ABBIEGELICHT_PIA_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_PIA_TIPPBLINKEN: {                                              // 0xD55E
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_PIA_TIPPBLINKEN", 3);
        break;
    }

    unsigned char STAT_PIA_MIND_ANZAHL_BLINKZYKLEN_BEI_TIPP_WERT = (RXBUF_UCHAR(0));
        // Minimum number of flashing cycles for jog flashing at the moment / Mind.-Anzahl Blinkzyklen bei Tippblinken
        // momentan
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_TIPPBLINKEN", "STAT_PIA_MIND_ANZAHL_BLINKZYKLEN_BEI_TIPP_WERT", STAT_PIA_MIND_ANZAHL_BLINKZYKLEN_BEI_TIPP_WERT, "\"Ink\"");

    unsigned char STAT_PIA_QUITT_BLINK_ENTRIEGELN_EIN = (RXBUF_UCHAR(1));
        // Acknowledgment flashing momentarily when unlocking 0: Off 1: On / Quittierungsblinken bei Entriegeln momentan 
        // 0: Aus  1: Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_TIPPBLINKEN", "STAT_PIA_QUITT_BLINK_ENTRIEGELN_EIN", STAT_PIA_QUITT_BLINK_ENTRIEGELN_EIN, "\"0/1\"");

    unsigned char STAT_PIA_QUITT_BLINK_SICHERN_EIN = (RXBUF_UCHAR(2));
        // Acknowledgment flashing when saving is currently 0: Off 1: On / Quittierungsblinken bei Sichern momentan  0:
        // Aus   1: Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_TIPPBLINKEN", "STAT_PIA_QUITT_BLINK_SICHERN_EIN", STAT_PIA_QUITT_BLINK_SICHERN_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LWR_MANUELL: {                                                  // 0xD55F
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LWR_MANUELL", 8);
        break;
    }

    short STAT_MAN_LWR_MAXPOS_WERT = (RXBUF_SINT(0));
        // Controlled angle value when the LWR knurled wheel is in the MAX position / Angesteuerter Winkelwert bei
        // MAX-Stellung des LWR-Rändelrads
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LWR_MANUELL", "STAT_MAN_LWR_MAXPOS_WERT", STAT_MAN_LWR_MAXPOS_WERT, "\"°\"");

    short STAT_MAN_LWR_MINPOS_WERT = (RXBUF_SINT(2));
        // Controlled angle value with the MIN position of the LWR knurled wheel / Angesteuerter Winkelwert bei
        // MIN-Stellung des LWR-Rändelrads
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LWR_MANUELL", "STAT_MAN_LWR_MINPOS_WERT", STAT_MAN_LWR_MINPOS_WERT, "\"°\"");

    short STAT_MAN_LWR_LINKS_WERT = (RXBUF_SINT(4));
        // Current angle value LWR left / Aktueller Winkelwert LWR links
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LWR_MANUELL", "STAT_MAN_LWR_LINKS_WERT", STAT_MAN_LWR_LINKS_WERT, "\"°\"");

    short STAT_MAN_LWR_RECHTS_WERT = (RXBUF_SINT(6));
        // Current LWR angle value right / Aktueller Winkelwert LWR rechts
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LWR_MANUELL", "STAT_MAN_LWR_RECHTS_WERT", STAT_MAN_LWR_RECHTS_WERT, "\"°\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_PIA_TAGFAHRLICHT: {                                             // 0xD573
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_PIA_TAGFAHRLICHT", 1);
        break;
    }

    unsigned char STAT_PIA_TAGFAHRLICHT_EIN = (RXBUF_UCHAR(0));
        // Daytime running lights momentarily: 0 = OFF; 1 = ON / Tagfahrlicht momentan: 0= AUS; 1= EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "PIA_TAGFAHRLICHT", "STAT_PIA_TAGFAHRLICHT_EIN", STAT_PIA_TAGFAHRLICHT_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_INNENLICHT_HINTEN: {                                            // 0xD57B
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_INNENLICHT_HINTEN", 4);
        break;
    }

    short STAT_INNENLICHT_HINTEN_EIN = (RXBUF_SINT(0));
        // 0: Off 1: On / 0: Aus  1: Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "INNENLICHT_HINTEN", "STAT_INNENLICHT_HINTEN_EIN", STAT_INNENLICHT_HINTEN_EIN, "\"0/1\"");

    short STAT_INNENLICHT_HINTEN_WERT = (RXBUF_SINT(2));
        // Specification of luminosity in% value range 0-100% / Angabe Leuchtkraft in % Wertebereich 0-100%
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "INNENLICHT_HINTEN", "STAT_INNENLICHT_HINTEN_WERT", STAT_INNENLICHT_HINTEN_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LWR_MODUS: {                                                    // 0xD57E
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LWR_MODUS", 4);
        break;
    }

    char STAT_KEINE_LWR_EIN = (RXBUF_SCHAR(0));
        // 0: LWR coded 1: no LWR coded / 0: LWR codiert  1: keine LWR codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LWR_MODUS", "STAT_KEINE_LWR_EIN", STAT_KEINE_LWR_EIN, "\"0/1\"");

    char STAT_MAN_LWR_EIN = (RXBUF_SCHAR(1));
        // 0: manual LWR not coded 1: manual LWR coded / 0: manuelle LWR nicht codiert  1: manuelle LWR codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LWR_MODUS", "STAT_MAN_LWR_EIN", STAT_MAN_LWR_EIN, "\"0/1\"");

    char STAT_AUT_LWR_EIN = (RXBUF_SCHAR(2));
        // 0: automatic LWR not coded 1: automatic LWR coded / 0: automatische LWR nicht codiert  1: automatische LWR
        // codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LWR_MODUS", "STAT_AUT_LWR_EIN", STAT_AUT_LWR_EIN, "\"0/1\"");

    char STAT_DYN_LWR_EIN = (RXBUF_SCHAR(3));
        // 0: dynamic LWR not coded 1: dynamic LWR coded / 0: dynamische LWR nicht codiert  1: dynamische LWR codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LWR_MODUS", "STAT_DYN_LWR_EIN", STAT_DYN_LWR_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_INNENLICHT_KLEMME_VA: {                                         // 0xD57F
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_INNENLICHT_KLEMME_VA", 4);
        break;
    }

    short STAT_INNENLICHT_KLEMME_VA_EIN = (RXBUF_SINT(0));
        // Terminal VA: 0: Off 1: On / Klemme VA:   0: Aus  1: Ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "INNENLICHT_KLEMME_VA", "STAT_INNENLICHT_KLEMME_VA_EIN", STAT_INNENLICHT_KLEMME_VA_EIN, "\"0/1\"");

    float STAT_INNENLICHT_KLEMME_VA_NACHLAUFZEIT_WERT = (RXBUF_SINT(2)/10.0f);
        // Follow-up time in seconds Value range 0-1800 seconds (corresponds to 30 minutes) / Nachlaufzeit in Sekunden
        // Wertebereich 0-1800 Sekunden (entspricht 30 Minuten)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "INNENLICHT_KLEMME_VA", "STAT_INNENLICHT_KLEMME_VA_NACHLAUFZEIT_WERT", STAT_INNENLICHT_KLEMME_VA_NACHLAUFZEIT_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKSTOCK_BLINKER_TASTER_FLA: {                                 // 0xD580
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKSTOCK_BLINKER_TASTER_FLA", 1);
        break;
    }

    char STAT_LENKSTOCK_BLINKER_TASTER_FLA_EIN = (RXBUF_SCHAR(0));
        // 0: steering column indicator, axial button high beam assistant not actuated; 1: Steering column indicator,
        // axial button high beam assistant actuated / 0: Lenkstock Blinker axialer Taster Fernlichtassistent nicht
        // betätigt; 1: Lenkstock Blinker axialer Taster Fernlichtassistent betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_TASTER_FLA", "STAT_LENKSTOCK_BLINKER_TASTER_FLA_EIN", STAT_LENKSTOCK_BLINKER_TASTER_FLA_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKSTOCK_BLINKER_TASTER_BC: {                                  // 0xD581
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKSTOCK_BLINKER_TASTER_BC", 1);
        break;
    }

    char STAT_LENKSTOCK_BLINKER_TASTER_BC_EIN = (RXBUF_SCHAR(0));
        // 0: steering column indicator, axial button on-board computer not activated; 1: Steering column indicator,
        // axial button on-board computer actuated / 0: Lenkstock Blinker axialer Taster Bordcomputer nicht betätigt; 1:
        // Lenkstock Blinker axialer Taster Bordcomputer betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_TASTER_BC", "STAT_LENKSTOCK_BLINKER_TASTER_BC_EIN", STAT_LENKSTOCK_BLINKER_TASTER_BC_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKSTOCK_BLINKER_FRA: {                                        // 0xD582
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKSTOCK_BLINKER_FRA", 6);
        break;
    }

    char STAT_LENKSTOCK_BLINKER_LINKS_EIN = (RXBUF_SCHAR(0));
        // 0: steering column turn signal not in position turn signal tip left; 1: Steering column indicator in left
        // indicator position / 0: Lenkstock Blinker nicht in Stellung Blinker Tipp links; 1: Lenkstock Blinker in
        // Stellung Blinker links
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_FRA", "STAT_LENKSTOCK_BLINKER_LINKS_EIN", STAT_LENKSTOCK_BLINKER_LINKS_EIN, "\"0/1\"");

    char STAT_LENKSTOCK_BLINKER_LINKS_DAUER_EIN = (RXBUF_SCHAR(1));
        // 0: Steering column indicator not in position indicator permanent left; 1: Steering column indicator in
        // position indicator permanent left / 0: Lenkstock Blinker nicht in Stellung Blinker Dauer links; 1: Lenkstock
        // Blinker in Stellung Blinker Dauer links
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_FRA", "STAT_LENKSTOCK_BLINKER_LINKS_DAUER_EIN", STAT_LENKSTOCK_BLINKER_LINKS_DAUER_EIN, "\"0/1\"");

    char STAT_LENKSTOCK_BLINKER_RECHTS_EIN = (RXBUF_SCHAR(2));
        // 0: steering column indicator not in position indicator tip right; 1: Steering column indicator in position
        // indicator right / 0: Lenkstock Blinker nicht in Stellung Blinker Tipp rechts; 1: Lenkstock Blinker in Stellung
        // Blinker rechts
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_FRA", "STAT_LENKSTOCK_BLINKER_RECHTS_EIN", STAT_LENKSTOCK_BLINKER_RECHTS_EIN, "\"0/1\"");

    char STAT_LENKSTOCK_BLINKER_RECHTS_DAUER_EIN = (RXBUF_SCHAR(3));
        // 0: Steering column indicator not in position indicator permanent right; 1: Steering column indicator in
        // position indicator permanent right / 0: Lenkstock Blinker nicht in Stellung Blinker Dauer rechts; 1: Lenkstock
        // Blinker in Stellung Blinker Dauer rechts
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_FRA", "STAT_LENKSTOCK_BLINKER_RECHTS_DAUER_EIN", STAT_LENKSTOCK_BLINKER_RECHTS_DAUER_EIN, "\"0/1\"");

    char STAT_LENKSTOCK_BLINKER_NULLSTELLUNG_EIN = (RXBUF_SCHAR(4));
        // 0: steering column indicator not in neutral position; 1: Steering column turn signal in neutral position / 0:
        // Lenkstock Blinker nicht in Nullstellung; 1: Lenkstock Blinker in Nullstellung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_FRA", "STAT_LENKSTOCK_BLINKER_NULLSTELLUNG_EIN", STAT_LENKSTOCK_BLINKER_NULLSTELLUNG_EIN, "\"0/1\"");

    char STAT_LENKSTOCK_BLINKER_NR = (RXBUF_SCHAR(5));
        // List see sub-table / Auflistung siehe Sub-Tabelle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_FRA", "STAT_LENKSTOCK_BLINKER_NR", STAT_LENKSTOCK_BLINKER_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKSTOCK_BLINKER_LICHTHUPE_FERNLICHT: {                        // 0xD583
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKSTOCK_BLINKER_LICHTHUPE_FERNLICHT", 2);
        break;
    }

    char STAT_LENKSTOCK_BLINKER_FERNLICHT_BETAETIGT = (RXBUF_SCHAR(0));
        // 0: Steering column turn signal button high beam not actuated; 1: Steering column turn signal button high beam
        // not actuated / 0: Lenkstock Blinker Taster Fernlicht nicht betätigt; 1: Lenkstock Blinker Taster Fernlicht
        // nicht betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_LICHTHUPE_FERNLICHT", "STAT_LENKSTOCK_BLINKER_FERNLICHT_BETAETIGT", STAT_LENKSTOCK_BLINKER_FERNLICHT_BETAETIGT, "\"0/1\"");

    char STAT_LENKSTOCK_BLINKER_LICHTHUPE_BETAETIGT = (RXBUF_SCHAR(1));
        // 0: Steering column turn signal button headlight flasher not actuated; 1: Steering column turn signal button
        // headlight flasher actuated / 0: Lenkstock Blinker Taster Lichthupe nicht betätigt; 1: Lenkstock Blinker Taster
        // Lichthupe betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_LICHTHUPE_FERNLICHT", "STAT_LENKSTOCK_BLINKER_LICHTHUPE_BETAETIGT", STAT_LENKSTOCK_BLINKER_LICHTHUPE_BETAETIGT, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKSTOCK_BLINKER_WIPPE: {                                      // 0xD585
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKSTOCK_BLINKER_WIPPE", 4);
        break;
    }

    unsigned char STAT_LENKSTOCK_BLINKER_WIPPE_NACH_OBEN = (RXBUF_UCHAR(0));
        // 0: Steering column turn signal rocker up not actuated; 1: Steering column turn signal rocker operated upwards
        // / 0: Lenkstock Blinker Wippe nach oben nicht betätigt; 1: Lenkstock Blinker Wippe nach oben betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_WIPPE", "STAT_LENKSTOCK_BLINKER_WIPPE_NACH_OBEN", STAT_LENKSTOCK_BLINKER_WIPPE_NACH_OBEN, "\"0/1\"");

    unsigned char STAT_LENKSTOCK_BLINKER_WIPPE_NACH_UNTEN = (RXBUF_UCHAR(1));
        // 0: Steering column turn signal rocker down not activated; 1: Steering column turn signal rocker operated
        // downwards / 0: Lenkstock Blinker Wippe nach unten nicht betätigt; 1: Lenkstock Blinker Wippe nach unten
        // betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_WIPPE", "STAT_LENKSTOCK_BLINKER_WIPPE_NACH_UNTEN", STAT_LENKSTOCK_BLINKER_WIPPE_NACH_UNTEN, "\"0/1\"");

    unsigned char STAT_LENKSTOCK_BLINKER_WIPPE_NULLSTELLUNG = (RXBUF_UCHAR(2));
        // 0: Steering column indicator rocker not in neutral position; 1: Steering column turn signal rocker in neutral
        // position / 0: Lenkstock Blinker Wippe nicht in Nullstellung; 1: Lenkstock Blinker Wippe in Nullstellung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_WIPPE", "STAT_LENKSTOCK_BLINKER_WIPPE_NULLSTELLUNG", STAT_LENKSTOCK_BLINKER_WIPPE_NULLSTELLUNG, "\"0/1\"");

    unsigned char STAT_LENKSTOCK_BLINKER_TASTER_WIPPE_NR = (RXBUF_UCHAR(3));
        // VS-Result 0: Steering column indicator rocker not actuated; 1: Steering column turn signal rocker operated
        // upwards; 2: Steering column turn signal rocker operated downwards / VS-Result 0: Lenkstock Blinker Wippe nicht
        // betätigt; 1: Lenkstock Blinker Wippe nach oben betätigt;  2: Lenkstock Blinker Wippe nach unten betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKSTOCK_BLINKER_WIPPE", "STAT_LENKSTOCK_BLINKER_TASTER_WIPPE_NR", STAT_LENKSTOCK_BLINKER_TASTER_WIPPE_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LESELICHT_HINTEN_LINKS_TASTER: {                                // 0xD587
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LESELICHT_HINTEN_LINKS_TASTER", 2);
        break;
    }

    short STAT_TASTER_LESELICHT_HINTEN_LINKS_EIN = (RXBUF_SINT(0));
        // 0: button not pressed 1: button pressed / 0: Taster nicht betätigt 1: Taster betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_HINTEN_LINKS_TASTER", "STAT_TASTER_LESELICHT_HINTEN_LINKS_EIN", STAT_TASTER_LESELICHT_HINTEN_LINKS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LESELICHT_VORNE_RECHTS_TASTER: {                                // 0xD588
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LESELICHT_VORNE_RECHTS_TASTER", 2);
        break;
    }

    short STAT_TASTER_LESELICHT_VORNE_RECHTS_EIN = (RXBUF_SINT(0));
        // 0: button not pressed 1: button pressed / 0: Taster nicht betätigt 1: Taster betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_VORNE_RECHTS_TASTER", "STAT_TASTER_LESELICHT_VORNE_RECHTS_EIN", STAT_TASTER_LESELICHT_VORNE_RECHTS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LESELICHT_VORNE_LINKS_TASTER: {                                 // 0xD589
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LESELICHT_VORNE_LINKS_TASTER", 2);
        break;
    }

    short STAT_TASTER_LESELICHT_VORNE_LINKS_EIN = (RXBUF_SINT(0));
        // 0: button not pressed 1: button pressed / 0: Taster nicht betätigt 1: Taster betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "LESELICHT_VORNE_LINKS_TASTER", "STAT_TASTER_LESELICHT_VORNE_LINKS_EIN", STAT_TASTER_LESELICHT_VORNE_LINKS_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LWR_POSITION_MIN_MAX: {                                         // 0xD58A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LWR_POSITION_MIN_MAX", 2);
        break;
    }

    unsigned char STAT_LWR_POSITION_MAX_EIN = (RXBUF_UCHAR(0));
        // 0: Knurled wheel not in MAX position 1: Knurled wheel in MAX position / 0: Rändelrad nicht in Stellung MAX  1:
        // Rändelrad in Stellung MAX
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LWR_POSITION_MIN_MAX", "STAT_LWR_POSITION_MAX_EIN", STAT_LWR_POSITION_MAX_EIN, "\"0/1\"");

    unsigned char STAT_LWR_POSITION_MIN_EIN = (RXBUF_UCHAR(1));
        // 0: Knurled wheel not in MIN position 1: Knurled wheel in MIN position / 0: Rändelrad nicht in Stellung MIN 1:
        // Rändelrad in Stellung MIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LWR_POSITION_MIN_MAX", "STAT_LWR_POSITION_MIN_EIN", STAT_LWR_POSITION_MIN_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LICHTSCHALTER_NSW_TASTER: {                                     // 0xD58B
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LICHTSCHALTER_NSW_TASTER", 1);
        break;
    }

    unsigned char STAT_TASTER_NSW_EIN = (RXBUF_UCHAR(0));
        // 0: Fog light button not actuated; 1: Fog light button pressed / 0: Taster Nebelscheinwerfer nicht betätigt; 1:
        // Taster Nebelscheinwerfer betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LICHTSCHALTER_NSW_TASTER", "STAT_TASTER_NSW_EIN", STAT_TASTER_NSW_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LICHTSCHALTER_NSL_TASTER: {                                     // 0xD58C
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LICHTSCHALTER_NSL_TASTER", 1);
        break;
    }

    unsigned char STAT_TASTER_NSL_EIN = (RXBUF_UCHAR(0));
        // 0: Rear fog light button not actuated 1: Rear fog light button actuated / 0: Taster Nebelschlussleuchte nicht
        // betätigt 1: Taster Nebelschlussleuchte betätigt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LICHTSCHALTER_NSL_TASTER", "STAT_TASTER_NSL_EIN", STAT_TASTER_NSL_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AMBIENTE_BELEUCHTUNG: {                                         // 0xD5D3
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AMBIENTE_BELEUCHTUNG", 2);
        break;
    }

    unsigned char STAT_AMBIENTE_EIN = (RXBUF_UCHAR(0));
        // 0 = ambience OFF; 1 = ambience ON / 0= Ambiente AUS; 1= Ambiente EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "AMBIENTE_BELEUCHTUNG", "STAT_AMBIENTE_EIN", STAT_AMBIENTE_EIN, "\"0/1\"");

    unsigned char STAT_AMBIENTE_WERT = (RXBUF_UCHAR(1));
        // Specification of the luminosity in% value range 0-100% / Angabe der Leuchtkraft in % Wertebereich 0-100%
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "AMBIENTE_BELEUCHTUNG", "STAT_AMBIENTE_WERT", STAT_AMBIENTE_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_INNENLICHT_MAPPING: {                                           // 0xD5DE
    if (datalen < 9) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_INNENLICHT_MAPPING", 9);
        break;
    }

    unsigned char STAT_BELEGUNG_LCI_0 = (RXBUF_UCHAR(0));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_0", STAT_BELEGUNG_LCI_0, "\"0-n\"");

    unsigned char STAT_BELEGUNG_LCI_1 = (RXBUF_UCHAR(1));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_1", STAT_BELEGUNG_LCI_1, "\"0-n\"");

    unsigned char STAT_BELEGUNG_LCI_2 = (RXBUF_UCHAR(2));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_2", STAT_BELEGUNG_LCI_2, "\"0-n\"");

    unsigned char STAT_BELEGUNG_LCI_3 = (RXBUF_UCHAR(3));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_3", STAT_BELEGUNG_LCI_3, "\"0-n\"");

    unsigned char STAT_BELEGUNG_LCI_4 = (RXBUF_UCHAR(4));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_4", STAT_BELEGUNG_LCI_4, "\"0-n\"");

    unsigned char STAT_BELEGUNG_LCI_5 = (RXBUF_UCHAR(5));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_5", STAT_BELEGUNG_LCI_5, "\"0-n\"");

    unsigned char STAT_BELEGUNG_LCI_6 = (RXBUF_UCHAR(6));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_6", STAT_BELEGUNG_LCI_6, "\"0-n\"");

    unsigned char STAT_BELEGUNG_LCI_7 = (RXBUF_UCHAR(7));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_7", STAT_BELEGUNG_LCI_7, "\"0-n\"");

    unsigned char STAT_BELEGUNG_LCI_8 = (RXBUF_UCHAR(8));
        // Assignment of PIN to function / Zuordnung PIN zu Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "INNENLICHT_MAPPING", "STAT_BELEGUNG_LCI_8", STAT_BELEGUNG_LCI_8, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AHL_LWR_TMS_ID_LESEN: {                                         // 0xD5E5
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AHL_LWR_TMS_ID_LESEN", 4);
        break;
    }

    unsigned short STAT_TMS_ID_LINKS_WERT = (RXBUF_UINT(0));
        // Coding ID TMS left &lt;&lt;&lt; Details to be filled in by the supplier !!! &gt;&gt;&gt; / Codierkennung TMS
        // links  <<< Details sind vom Lieferanten zu befüllen !!! >>>
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "AHL_LWR_TMS_ID_LESEN", "STAT_TMS_ID_LINKS_WERT", STAT_TMS_ID_LINKS_WERT, "\"HEX\"");

    unsigned short STAT_TMS_ID_RECHTS_WERT = (RXBUF_UINT(2));
        // Coding ID TMS right &lt;&lt;&lt; Details to be filled in by the supplier !!! &gt;&gt;&gt; / Codierkennung TMS
        // rechts <<< Details sind vom Lieferanten zu befüllen !!! >>>
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "AHL_LWR_TMS_ID_LESEN", "STAT_TMS_ID_RECHTS_WERT", STAT_TMS_ID_RECHTS_WERT, "\"HEX\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HOEHENSTAENDE_SENSOREN: {                                       // 0xD601
    if (datalen < 12) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HOEHENSTAENDE_SENSOREN", 12);
        break;
    }

    float STAT_HOEHENSTAND_ROHWERT_VR_WERT = (RXBUF_SINT(0)/1000.0f);
        // Raw signal from the front height sensor. / Rohsignal Sensor Höhenstand vorn.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "HOEHENSTAENDE_SENSOREN", "STAT_HOEHENSTAND_ROHWERT_VR_WERT", STAT_HOEHENSTAND_ROHWERT_VR_WERT, "\"V\"");

    float STAT_HOEHENSTAND_ROHWERT_HR_WERT = (RXBUF_SINT(2)/1000.0f);
        // Raw signal from the rear height sensor. / Rohsignal Sensor Höhenstand hinten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "HOEHENSTAENDE_SENSOREN", "STAT_HOEHENSTAND_ROHWERT_HR_WERT", STAT_HOEHENSTAND_ROHWERT_HR_WERT, "\"V\"");

    short STAT_HOEHENSTAND_SENSOR_VR_NR = (RXBUF_SINT(4));
        // Status query of the front height level sensor. / Zustandsabfrage Höhenstandssensor vorn.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "HOEHENSTAENDE_SENSOREN", "STAT_HOEHENSTAND_SENSOR_VR_NR", STAT_HOEHENSTAND_SENSOR_VR_NR, "\"0-n\"");

    short STAT_HOEHENSTAND_SENSOR_HR_NR = (RXBUF_SINT(6));
        // Status query of the rear height level sensor. / Zustandsabfrage Höhenstandssensor hinten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "HOEHENSTAENDE_SENSOREN", "STAT_HOEHENSTAND_SENSOR_HR_NR", STAT_HOEHENSTAND_SENSOR_HR_NR, "\"0-n\"");

    unsigned char STAT_HOEHENSTAND_VR_NR = (RXBUF_UCHAR(8));
        // Plausibility level offset. / Plausiblilisierung Höhenstandsoffset.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HOEHENSTAENDE_SENSOREN", "STAT_HOEHENSTAND_VR_NR", STAT_HOEHENSTAND_VR_NR, "\"0-n\"");

    unsigned char STAT_HOEHENSTAND_HR_NR = (RXBUF_UCHAR(9));
        // Plausibility level offset. / Plausiblilisierung Höhenstandsoffset.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HOEHENSTAENDE_SENSOREN", "STAT_HOEHENSTAND_HR_NR", STAT_HOEHENSTAND_HR_NR, "\"0-n\"");

    unsigned char STAT_HOEHENSTAND_VR_NR_1 = (RXBUF_UCHAR(10));
        // Plausibility check of altitude gradient / Plausiblilisierung Höhenstandssteigung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HOEHENSTAENDE_SENSOREN", "STAT_HOEHENSTAND_VR_NR_1", STAT_HOEHENSTAND_VR_NR_1, "\"0-n\"");

    unsigned char STAT_HOEHENSTAND_HR_NR_1 = (RXBUF_UCHAR(11));
        // Plausibility check of altitude gradient / Plausiblilisierung Höhenstandssteigung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HOEHENSTAENDE_SENSOREN", "STAT_HOEHENSTAND_HR_NR_1", STAT_HOEHENSTAND_HR_NR_1, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HOEHENSTAENDE_VERSORGUNG: {                                     // 0xD603
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HOEHENSTAENDE_VERSORGUNG", 4);
        break;
    }

    float STAT_HOEHENSTAND_VERSORGUNG_VR_WERT = (RXBUF_SINT(0)/1000.0f);
        // Output of the supply voltage of the front height sensor in mV. / Ausgabe der Versorgungsspannung des Sensor
        // Höhenstand vorn  in mV.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "HOEHENSTAENDE_VERSORGUNG", "STAT_HOEHENSTAND_VERSORGUNG_VR_WERT", STAT_HOEHENSTAND_VERSORGUNG_VR_WERT, "\"V\"");

    float STAT_HOEHENSTAND_VERSORGUNG_HR_WERT = (RXBUF_SINT(2)/1000.0f);
        // Output of the supply voltage of the rear height sensor in mV. / Ausgabe der Versorgungsspannung des Sensor
        // Höhenstand hinten in mV.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "HOEHENSTAENDE_VERSORGUNG", "STAT_HOEHENSTAND_VERSORGUNG_HR_WERT", STAT_HOEHENSTAND_VERSORGUNG_HR_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HOEHENSTAENDE_KALIBRIERUNG_LESEN: {                             // 0xD604
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HOEHENSTAENDE_KALIBRIERUNG_LESEN", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_FES_MODUS: {                                             // 0xD611
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_FES_MODUS", 1);
        break;
    }

    unsigned char STAT_FES_MODUS = (RXBUF_UCHAR(0));
        // current FES mode / aktueller FES Modus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_FES_MODUS", "STAT_FES_MODUS", STAT_FES_MODUS, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_FES_STATISTIK: {                                         // 0xD612
    if (datalen < 12) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_FES_STATISTIK", 12);
        break;
    }

    unsigned long STAT_ECO_GRUPPE_WERT = (RXBUF_UINT32(0));
        // ECO and ECO + / ECO und ECO+
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "STATUS_FES_STATISTIK", "STAT_ECO_GRUPPE_WERT", STAT_ECO_GRUPPE_WERT, "\"s\"");

    unsigned long STAT_COMFORT_GRUPPE_WERT = (RXBUF_UINT32(4));
        // Basis and comfort / Basis und Komfort
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "STATUS_FES_STATISTIK", "STAT_COMFORT_GRUPPE_WERT", STAT_COMFORT_GRUPPE_WERT, "\"s\"");

    unsigned long STAT_SONSTIGE_WERT = (RXBUF_UINT32(8));
        // Other modes / Sonstige Modi
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "STATUS_FES_STATISTIK", "STAT_SONSTIGE_WERT", STAT_SONSTIGE_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SWITCH_BOARD_TASTEN: {                                          // 0xD622
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SWITCH_BOARD_TASTEN", 1);
        break;
    }

    unsigned char RES_0xD622_D = (RXBUF_UCHAR(0));
        // DID for reading out and controlling the switchboard buttons / DID zum Auslesen und Ansteuern der
        // Switchboard-Tasten
            // RES_0xD622_D is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "BDC", "SWITCH_BOARD_TASTEN", "RES_0xD622_D", (unsigned long)RES_0xD622_D, "\"bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_FES_DATEN: {                                             // 0xD625
    if (datalen < 5) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_FES_DATEN", 5);
        break;
    }

    unsigned char STAT_FES_LASTMODE = (RXBUF_UCHAR(0));
        // Start-up mode / Aufstart Modus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_FES_DATEN", "STAT_FES_LASTMODE", STAT_FES_LASTMODE, "\"0-n\"");

    unsigned long STAT_FES_SLEEPTIME_WERT = (RXBUF_UINT32(1));
        // Time off at Kl15 / Zeit bei Kl15 aus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "STATUS_FES_DATEN", "STAT_FES_SLEEPTIME_WERT", STAT_FES_SLEEPTIME_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SWITCHBOARD_TASTE_VERBAU: {                                     // 0xD627
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SWITCHBOARD_TASTE_VERBAU", 6);
        break;
    }

    unsigned char STAT_VERBAU_HDC_TASTE = (RXBUF_UCHAR(0));
        // Information on the installation status of the button: 0 = not available, 1 = available / Angabe Verbauzustand
        // Taste: 0 = nicht vorhanden, 1 = vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SWITCHBOARD_TASTE_VERBAU", "STAT_VERBAU_HDC_TASTE", STAT_VERBAU_HDC_TASTE, "\"0/1\"");

    unsigned char STAT_VERBAU_PDC_TASTE = (RXBUF_UCHAR(1));
        // Status installation PDC button / Status Verbau PDC Taste
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SWITCHBOARD_TASTE_VERBAU", "STAT_VERBAU_PDC_TASTE", STAT_VERBAU_PDC_TASTE, "\"0/1\"");

    unsigned char STAT_VERBAU_SV_TASTE = (RXBUF_UCHAR(2));
        // Status installation SV button / Status Verbau SV Taste
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SWITCHBOARD_TASTE_VERBAU", "STAT_VERBAU_SV_TASTE", STAT_VERBAU_SV_TASTE, "\"0/1\"");

    unsigned char STAT_VERBAU_DSC_TASTE = (RXBUF_UCHAR(3));
        // DSC button installation status / Status Verbau DSC Taste
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SWITCHBOARD_TASTE_VERBAU", "STAT_VERBAU_DSC_TASTE", STAT_VERBAU_DSC_TASTE, "\"0/1\"");

    unsigned char STAT_VERBAU_FES_WIPPE = (RXBUF_UCHAR(4));
        // Indicates whether the FES rocker is installed / Gibt an ob die FES Wippe verbaut ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SWITCHBOARD_TASTE_VERBAU", "STAT_VERBAU_FES_WIPPE", STAT_VERBAU_FES_WIPPE, "\"0/1\"");

    unsigned char STAT_VERBAU_HUD_TASTE = (RXBUF_UCHAR(5));
        // Indicates whether the HUD button is installed / Gibt an ob die HUD Taste verbaut ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SWITCHBOARD_TASTE_VERBAU", "STAT_VERBAU_HUD_TASTE", STAT_VERBAU_HUD_TASTE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUSSTATTUNG_CORONA_LED: {                                       // 0xD62B
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUSSTATTUNG_CORONA_LED", 1);
        break;
    }

    char STAT_VORHANDEN_CORONA_LED = (RXBUF_SCHAR(0));
        // 0: CORONA LED not available; 1: CORONA LED available / 0: CORONA LED nicht vorhanden;  1: CORONA LED vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "AUSSTATTUNG_CORONA_LED", "STAT_VORHANDEN_CORONA_LED", STAT_VORHANDEN_CORONA_LED, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FES_MASTER_SW_FEHLER_INFO: {                                    // 0xD62D
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FES_MASTER_SW_FEHLER_INFO", 4);
        break;
    }

    long STAT_FES_MASTER_SW_FEHLER_INFO_WERT = (RXBUF_SINT32(0));
        // FES Master SW error / FES Master SW Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%ld%s\n", "BDC", "FES_MASTER_SW_FEHLER_INFO", "STAT_FES_MASTER_SW_FEHLER_INFO_WERT", STAT_FES_MASTER_SW_FEHLER_INFO_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SWITCH_BOARD_TASTEN_VERBAU: {                                   // 0xD669
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SWITCH_BOARD_TASTEN_VERBAU", 1);
        break;
    }

    unsigned char RES_0xD669_D = (RXBUF_UCHAR(0));
        // DID for reading out the assembly of individual switchboard buttons / DID zum Auslesen des Verbaus einzelner
        // Switchboard-Tasten
            // RES_0xD669_D is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "BDC", "SWITCH_BOARD_TASTEN_VERBAU", "RES_0xD669_D", (unsigned long)RES_0xD669_D, "\"bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KUEHLMITTELSTAND: {                                             // 0xD672
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KUEHLMITTELSTAND", 3);
        break;
    }

    unsigned char STAT_KUEHLMITTELSTAND_EIN = (RXBUF_UCHAR(0));
        // 0 = coolant tank not sufficiently filled; 1 = coolant tank sufficiently filled / 0= Kühlmittelbehaelter nicht
        // ausreichend befüllt; 1= Kühlmittelbehällter ausreichend befüllt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KUEHLMITTELSTAND", "STAT_KUEHLMITTELSTAND_EIN", STAT_KUEHLMITTELSTAND_EIN, "\"0/1\"");

    unsigned short STAT_KUEHLMITTELSTAND_WERT = (RXBUF_UINT(1));
        // Specification of the level value in mv. 0xFFFF: invalid value or value not supported / Angabe des Pegelwerts
        // in mv. 0xFFFF: ungültiger Wert oder Wert nicht unterstützt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "KUEHLMITTELSTAND", "STAT_KUEHLMITTELSTAND_WERT", STAT_KUEHLMITTELSTAND_WERT, "\"mV\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_GURTZUBRINGER_FA: {                                             // 0xD71A
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_GURTZUBRINGER_FA", 3);
        break;
    }

    unsigned short STAT_GZB_FA_POS_WERT = (RXBUF_UINT(0));
        // Current position of the driver's seat belt feeder / Aktuelle Position Gurtzubringer Fahrer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "GURTZUBRINGER_FA", "STAT_GZB_FA_POS_WERT", STAT_GZB_FA_POS_WERT, "\"Ink\"");

    unsigned char STAT_GZB_FA_ENDLAGE_EIN = (RXBUF_UCHAR(2));
        // Belt feeder driver end position reached / Gurtzubringer Fahrer Endlage erreicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "GURTZUBRINGER_FA", "STAT_GZB_FA_ENDLAGE_EIN", STAT_GZB_FA_ENDLAGE_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_GURTZUBRINGER_BF: {                                             // 0xD71B
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_GURTZUBRINGER_BF", 3);
        break;
    }

    unsigned short STAT_GZB_BF_POS_WERT = (RXBUF_UINT(0));
        // Current position of the passenger seat belt feeder / Aktuelle Position Gurtzubringer Beifahrer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "GURTZUBRINGER_BF", "STAT_GZB_BF_POS_WERT", STAT_GZB_BF_POS_WERT, "\"Ink\"");

    unsigned char STAT_GZB_BF_ENDLAGE_EIN = (RXBUF_UCHAR(2));
        // Belt feeder passenger end position reached / Gurtzubringer Beifahrer Endlage erreicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "GURTZUBRINGER_BF", "STAT_GZB_BF_ENDLAGE_EIN", STAT_GZB_BF_ENDLAGE_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_FA_VORHANDEN: {                                     // 0xD726
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_FA_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_SITZHEIZUNG_FA_VORHANDEN = (RXBUF_UCHAR(0));
        // 0: Seat heating not available 1: Seat heating available / 0: Sitzheizung nicht vorhanden 1: Sitzheizung
        // vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FA_VORHANDEN", "STAT_SITZHEIZUNG_FA_VORHANDEN", STAT_SITZHEIZUNG_FA_VORHANDEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_BF_VORHANDEN: {                                     // 0xD727
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_BF_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_SITZHEIZUNG_BF_VORHANDEN = (RXBUF_UCHAR(0));
        // 0: Seat heating not available 1: Seat heating available / 0: Sitzheizung nicht vorhanden 1: Sitzheizung
        // vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BF_VORHANDEN", "STAT_SITZHEIZUNG_BF_VORHANDEN", STAT_SITZHEIZUNG_BF_VORHANDEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_FAH_VORHANDEN: {                                    // 0xD728
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_FAH_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_SITZHEIZUNG_FAH_VORHANDEN = (RXBUF_UCHAR(0));
        // 0: Seat heating not available 1: Seat heating available / 0: Sitzheizung nicht vorhanden 1: Sitzheizung
        // vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FAH_VORHANDEN", "STAT_SITZHEIZUNG_FAH_VORHANDEN", STAT_SITZHEIZUNG_FAH_VORHANDEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_BFH_VORHANDEN: {                                    // 0xD729
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_BFH_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_SITZHEIZUNG_BFH_VORHANDEN = (RXBUF_UCHAR(0));
        // 0: Seat heating not available 1: Seat heating available / 0: Sitzheizung nicht vorhanden 1: Sitzheizung
        // vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BFH_VORHANDEN", "STAT_SITZHEIZUNG_BFH_VORHANDEN", STAT_SITZHEIZUNG_BFH_VORHANDEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BUS_IN_SITZHEIZUNG_STUFE_BF: {                                  // 0xD72D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BUS_IN_SITZHEIZUNG_STUFE_BF", 1);
        break;
    }

    unsigned char STAT_BUS_IN_SITZHEIZUNG_BF_NR = (RXBUF_UCHAR(0));
        // Bus message level seat heating passenger side, 0: OFF; 1: level 1; 2: level 2; 3: Level 3 / Busnachricht Stufe
        // Sitzheizung Beifahrerseite, 0: AUS; 1: Stufe 1; 2: Stufe 2;  3: Stufe 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_SITZHEIZUNG_STUFE_BF", "STAT_BUS_IN_SITZHEIZUNG_BF_NR", STAT_BUS_IN_SITZHEIZUNG_BF_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_BF: {                                               // 0xD730
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_BF", 4);
        break;
    }

    unsigned char STAT_SITZHEIZUNG_BF_EIN = (RXBUF_UCHAR(0));
        // 0: seat heating off 1: seat heating on / 0: Sitzheizung aus  1: Sitzheizung ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BF", "STAT_SITZHEIZUNG_BF_EIN", STAT_SITZHEIZUNG_BF_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_BF_VERBRAUCHSREDUZIERUNG_EIN = (RXBUF_UCHAR(1));
        // 0: Consumption reduction not active 1: Consumption reduction active / 0: Verbrauchsreduzierung nicht aktiv  1:
        // Verbrauchsreduzierung aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BF", "STAT_SITZHEIZUNG_BF_VERBRAUCHSREDUZIERUNG_EIN", STAT_SITZHEIZUNG_BF_VERBRAUCHSREDUZIERUNG_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_BF_NOTBETRIEB_EIN = (RXBUF_UCHAR(2));
        // 0: Seat heating not in emergency mode 1: Seat heating in emergency mode / 0: Sitzheizung nicht in Notbetrieb 
        // 1: Sitzheizung in Notbetrieb
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BF", "STAT_SITZHEIZUNG_BF_NOTBETRIEB_EIN", STAT_SITZHEIZUNG_BF_NOTBETRIEB_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_BF_TIMEOUT = (RXBUF_UCHAR(3));
        // 0: No off due to time-out 1: Off due to time-out / 0: Kein Aus wegen Time-Out  1: Aus wegen Time-Out
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BF", "STAT_SITZHEIZUNG_BF_TIMEOUT", STAT_SITZHEIZUNG_BF_TIMEOUT, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BUS_IN_SITZHEIZUNG_STUFE_FA: {                                  // 0xD731
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BUS_IN_SITZHEIZUNG_STUFE_FA", 1);
        break;
    }

    unsigned char STAT_BUS_IN_SITZHEIZUNG_FA_NR = (RXBUF_UCHAR(0));
        // Bus message level seat heating driver side, 0: OFF; 1: level 1; 2: level 2; 3: Level 3 / Busnachricht Stufe
        // Sitzheizung Fahrerseite, 0: AUS; 1: Stufe 1; 2: Stufe 2;  3: Stufe 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_SITZHEIZUNG_STUFE_FA", "STAT_BUS_IN_SITZHEIZUNG_FA_NR", STAT_BUS_IN_SITZHEIZUNG_FA_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_VORHANDEN_DRITTE_SITZREIHE_EIN: {                               // 0xD762
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_VORHANDEN_DRITTE_SITZREIHE_EIN", 2);
        break;
    }

    short STAT_VORHANDEN_DRITTE_SITZREIHE_EIN = (RXBUF_SINT(0));
        // Indicates whether the 3rd row of seats is available: 0 = Third row of seats not coded; 1 = third row of seats
        // coded / Gibt an, ob die 3. Sitzreihe vorhanden ist: 0= Dritte Sitzreihe nicht codiert; 1= Dritte Sitzreihe
        // codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "VORHANDEN_DRITTE_SITZREIHE_EIN", "STAT_VORHANDEN_DRITTE_SITZREIHE_EIN", STAT_VORHANDEN_DRITTE_SITZREIHE_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_VERRIEGELUNG_ZWEITE_SITZREIHE: {                                // 0xD763
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_VERRIEGELUNG_ZWEITE_SITZREIHE", 2);
        break;
    }

    short STAT_VERRIEGELUNG_ZWEITE_SITZREIHE_EIN = (RXBUF_SINT(0));
        // 0: Second row of seats not locked; 1: Second row of seats locked / 0: Zweite Sitzreihe nicht verriegelt; 1:
        // Zweite Sitzreihe verriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "VERRIEGELUNG_ZWEITE_SITZREIHE", "STAT_VERRIEGELUNG_ZWEITE_SITZREIHE_EIN", STAT_VERRIEGELUNG_ZWEITE_SITZREIHE_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_FA: {                                               // 0xD771
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_FA", 4);
        break;
    }

    unsigned char STAT_SITZHEIZUNG_FA_EIN = (RXBUF_UCHAR(0));
        // 0: seat heating off 1: seat heating on / 0: Sitzheizung aus  1: Sitzheizung ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FA", "STAT_SITZHEIZUNG_FA_EIN", STAT_SITZHEIZUNG_FA_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_FA_VERBRAUCHSREDUZIERUNG_EIN = (RXBUF_UCHAR(1));
        // 0: Consumption reduction not active 1: Consumption reduction active / 0: Verbrauchsreduzierung nicht aktiv  1:
        // Verbrauchsreduzierung aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FA", "STAT_SITZHEIZUNG_FA_VERBRAUCHSREDUZIERUNG_EIN", STAT_SITZHEIZUNG_FA_VERBRAUCHSREDUZIERUNG_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_FA_NOTBETRIEB_EIN = (RXBUF_UCHAR(2));
        // 0: Seat heating not in emergency mode 1: Seat heating in emergency mode / 0: Sitzheizung nicht in Notbetrieb 
        // 1: Sitzheizung in Notbetrieb
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FA", "STAT_SITZHEIZUNG_FA_NOTBETRIEB_EIN", STAT_SITZHEIZUNG_FA_NOTBETRIEB_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_FA_TIMEOUT = (RXBUF_UCHAR(3));
        // 0: No off due to time-out 1: Off due to time-out / 0: Kein Aus wegen Time-Out  1: Aus wegen Time-Out
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FA", "STAT_SITZHEIZUNG_FA_TIMEOUT", STAT_SITZHEIZUNG_FA_TIMEOUT, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_FAH: {                                              // 0xD7EA
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_FAH", 4);
        break;
    }

    unsigned char STAT_SITZHEIZUNG_FAH_EIN = (RXBUF_UCHAR(0));
        // 0: seat heating off 1: seat heating on / 0: Sitzheizung aus  1: Sitzheizung ein
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FAH", "STAT_SITZHEIZUNG_FAH_EIN", STAT_SITZHEIZUNG_FAH_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_FAH_VERBRAUCHSREDUZIERUNG_EIN = (RXBUF_UCHAR(1));
        // 0: Consumption reduction not active 1: Consumption reduction active / 0: Verbrauchsreduzierung nicht aktiv 1:
        // Verbrauchsreduzierung aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FAH", "STAT_SITZHEIZUNG_FAH_VERBRAUCHSREDUZIERUNG_EIN", STAT_SITZHEIZUNG_FAH_VERBRAUCHSREDUZIERUNG_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_FAH_NOTBETRIEB_EIN = (RXBUF_UCHAR(2));
        // 0: Seat heating not in emergency mode 1: Seat heating in emergency mode / 0: Sitzheizung nicht in Notbetrieb
        // 1: Sitzheizung in Notbetrieb
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FAH", "STAT_SITZHEIZUNG_FAH_NOTBETRIEB_EIN", STAT_SITZHEIZUNG_FAH_NOTBETRIEB_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_FAH_TIMEOUT = (RXBUF_UCHAR(3));
        // 0: No off due to time-out 1: Off due to time-out / 0: Kein Aus wegen Time-Out  1: Aus wegen Time-Out
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_FAH", "STAT_SITZHEIZUNG_FAH_TIMEOUT", STAT_SITZHEIZUNG_FAH_TIMEOUT, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_BFH: {                                              // 0xD7EC
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_BFH", 4);
        break;
    }

    unsigned char STAT_SITZHEIZUNG_BFH_EIN = (RXBUF_UCHAR(0));
        // 0: Seat heating OFF 1: Seat heating ON / 0: Sitzheizung AUS  1: Sitzheizung EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BFH", "STAT_SITZHEIZUNG_BFH_EIN", STAT_SITZHEIZUNG_BFH_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_BFH_VERBRAUCHSREDUZIERUNG_EIN = (RXBUF_UCHAR(1));
        // 0: Consumption reduction not active 1: Consumption reduction active / 0: Verbrauchsreduzierung nicht aktiv 1:
        // Verbrauchsreduzierung aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BFH", "STAT_SITZHEIZUNG_BFH_VERBRAUCHSREDUZIERUNG_EIN", STAT_SITZHEIZUNG_BFH_VERBRAUCHSREDUZIERUNG_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_BFH_NOTBETRIEB_EIN = (RXBUF_UCHAR(2));
        // 0: Seat heating not in emergency mode 1: Seat heating in emergency mode / 0: Sitzheizung nicht in Notbetrieb 
        // 1: Sitzheizung in Notbetrieb
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BFH", "STAT_SITZHEIZUNG_BFH_NOTBETRIEB_EIN", STAT_SITZHEIZUNG_BFH_NOTBETRIEB_EIN, "\"0/1\"");

    unsigned char STAT_SITZHEIZUNG_BFH_TIMEOUT = (RXBUF_UCHAR(3));
        // 0: No off due to time-out 1: Off due to time-out / 0: Kein Aus wegen Time-Out  1: Aus wegen Time-Out
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_BFH", "STAT_SITZHEIZUNG_BFH_TIMEOUT", STAT_SITZHEIZUNG_BFH_TIMEOUT, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SITZHEIZUNG_HINTEN_TASTER_VORHANDEN: {                          // 0xD86C
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SITZHEIZUNG_HINTEN_TASTER_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_SITZHEIZUNG_TASTER_HINTEN = (RXBUF_UCHAR(0));
        // 0 = not available 1 = available / 0=nicht vorhanden 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SITZHEIZUNG_HINTEN_TASTER_VORHANDEN", "STAT_VORHANDEN_SITZHEIZUNG_TASTER_HINTEN", STAT_VORHANDEN_SITZHEIZUNG_TASTER_HINTEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_VORHANDEN_FONDSCHICHTUNG: {                                     // 0xD8AA
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_VORHANDEN_FONDSCHICHTUNG", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_FONDSCHICHTUNGSPOTI = (RXBUF_UCHAR(0));
        // 0 = rear stratification potentiometer not available 1 = rear stratification potentiometer available /
        // 0=Fondschichtungspotentiometer nicht vorhanden 1=Fondschichtungspotentiometer vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "VORHANDEN_FONDSCHICHTUNG", "STAT_VORHANDEN_FONDSCHICHTUNGSPOTI", STAT_VORHANDEN_FONDSCHICHTUNGSPOTI, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SOLARSENSOR_VORHANDEN: {                                        // 0xD8AB
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SOLARSENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_SOLARSENSOR_EIN = (RXBUF_UCHAR(0));
        // Solar sensor: 0 = not available / coded; 1 = present / coded / Solarsensor: 0 = nicht vorhanden / codiert; 1 =
        // vorhanden / codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "SOLARSENSOR_VORHANDEN", "STAT_VORHANDEN_SOLARSENSOR_EIN", STAT_VORHANDEN_SOLARSENSOR_EIN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUC_SENSOR_VORHANDEN: {                                         // 0xD8AC
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUC_SENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_AUC_SENSOR = (RXBUF_UCHAR(0));
        // AUC sensor: 0 = not available; 1 = present / AUC-Sensor: 0 = nicht vorhanden; 1 = vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "AUC_SENSOR_VORHANDEN", "STAT_VORHANDEN_AUC_SENSOR", STAT_VORHANDEN_AUC_SENSOR, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FENSTERHEBER_VORHANDEN: {                                       // 0xD8FE
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FENSTERHEBER_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_ANZAHL_FH_KODIERT = (RXBUF_UCHAR(0));
        // Reading out the number of coded window regulators. / Auslesen der Anzahl von kodierten Fensterheber.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FENSTERHEBER_VORHANDEN", "STAT_ANZAHL_FH_KODIERT", STAT_ANZAHL_FH_KODIERT, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KLIMAKOMPRESSOR: {                                              // 0xD906
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KLIMAKOMPRESSOR", 3);
        break;
    }

    short STAT_KLIMAKOMPRESSOR_EIN = (RXBUF_SINT(0));
        // Air conditioning compressor: 0 = OFF, 1 = ON / Klimakompressor: 0 = AUS, 1 = EIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "KLIMAKOMPRESSOR", "STAT_KLIMAKOMPRESSOR_EIN", STAT_KLIMAKOMPRESSOR_EIN, "\"0/1\"");

    unsigned char STAT_KLIMAKOMPRESSOR_PWM_WERT = (RXBUF_UCHAR(2));
        // Air conditioning compressor: PWM signal in percent / Klimakompressor: PWM-Signal in Prozent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KLIMAKOMPRESSOR", "STAT_KLIMAKOMPRESSOR_PWM_WERT", STAT_KLIMAKOMPRESSOR_PWM_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_VORHANDEN_KOMPRESSORKUPPLUNG: {                                 // 0xD916
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_VORHANDEN_KOMPRESSORKUPPLUNG", 1);
        break;
    }

    unsigned char RES_0xD916_D = (RXBUF_UCHAR(0));
        // Read out whether a compressor clutch is available. In the case of PHEV vehicles, the job returns whether a
        // switching valve is present. / Auslesen ob eine Kompressorkupplung vorhanden ist. Bei PHEV-Fahrzeugen gibt der
        // Job zurück, ob ein Umschaltventil vorhanden ist. 
            // RES_0xD916_D is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "BDC", "VORHANDEN_KOMPRESSORKUPPLUNG", "RES_0xD916_D", (unsigned long)RES_0xD916_D, "\"bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_DRUCKSENSOR_VORHANDEN: {                                        // 0xD959
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_DRUCKSENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_DRUCKSENSOR_VORHANDEN = (RXBUF_UCHAR(0));
        // Indicates whether a pressure sensor is installed for R134A: 0 = not available, 1 = available / Gibt aus, ob
        // ein Drucksensor für R134A verbaut ist: 0 = nicht vorhanden, 1 = vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "DRUCKSENSOR_VORHANDEN", "STAT_DRUCKSENSOR_VORHANDEN", STAT_DRUCKSENSOR_VORHANDEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_VORHANDEN_WASSERVENTIL: {                                       // 0xD95A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_VORHANDEN_WASSERVENTIL", 2);
        break;
    }

    unsigned char STAT_VORHANDEN_WASSERVENTIL_MONO = (RXBUF_UCHAR(0));
        // 0 = not available, 1 = available / 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "VORHANDEN_WASSERVENTIL", "STAT_VORHANDEN_WASSERVENTIL_MONO", STAT_VORHANDEN_WASSERVENTIL_MONO, "\"0/1\"");

    unsigned char STAT_VORHANDEN_WASSERVENTIL_DUO = (RXBUF_UCHAR(1));
        // 0 = not available, 1 = available / 0=nicht vorhanden, 1=vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "VORHANDEN_WASSERVENTIL", "STAT_VORHANDEN_WASSERVENTIL_DUO", STAT_VORHANDEN_WASSERVENTIL_DUO, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SOLARSENSOR: {                                                  // 0xD961
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SOLARSENSOR", 4);
        break;
    }

    float STAT_SOLARSENSOR_FA_WERT = (RXBUF_UINT(0)*4.0158f);
        // Solar sensor, solar value FA. Range 0 to 1020 W / m2 / Solarsensor, Solarwert FA. Bereich 0 bis 1020 W/m2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SOLARSENSOR", "STAT_SOLARSENSOR_FA_WERT", STAT_SOLARSENSOR_FA_WERT, "\"W/m²\"");

    float STAT_SOLARSENSOR_BF_WERT = (RXBUF_UINT(2)*4.0158f);
        // Solar sensor, solar value BF. Range 0 to 1020 W / m2 / Solarsensor, Solarwert BF. Bereich 0 bis 1020 W/m2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SOLARSENSOR", "STAT_SOLARSENSOR_BF_WERT", STAT_SOLARSENSOR_BF_WERT, "\"W/m²\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_AUC_SENSOR: {                                                   // 0xD963
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_AUC_SENSOR", 1);
        break;
    }

    unsigned char STAT_AUC_SENSOR_NR = (RXBUF_UCHAR(0));
        // Indicates which pollutant level the AUC sensor has determined. / Gibt aus, welche Schadstoffstufe der
        // AUC-Sensor ermittelt hat.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "AUC_SENSOR", "STAT_AUC_SENSOR_NR", STAT_AUC_SENSOR_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_DRUCKSENSOR: {                                                  // 0xD967
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_DRUCKSENSOR", 1);
        break;
    }

    unsigned char STAT_R134A_DRUCK_WERT = (RXBUF_UCHAR(0));
        // Output refrigerant pressure in bar. / Ausgabe Kältemitteldruck in bar.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "DRUCKSENSOR", "STAT_R134A_DRUCK_WERT", STAT_R134A_DRUCK_WERT, "\"bar\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BESCHLAGSENSOR: {                                               // 0xD96C
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BESCHLAGSENSOR", 3);
        break;
    }

    float STAT_BESCHLAGSENSOR_WERT = (RXBUF_SINT(0)/2.0f);
        // Indication of relative humidity in percent 0 ... 100% / Angabe relative Feuchte in Prozent 0 ... 100 %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "BESCHLAGSENSOR", "STAT_BESCHLAGSENSOR_WERT", STAT_BESCHLAGSENSOR_WERT, "\"%\"");

    float STAT_BESCHLAGSENSOR_TEMP_WERT = (RXBUF_UCHAR(2)/2.0f-40.0);
        // Measured temperature in ° C -40 ... 85 ° C / Gemessene Temperatur in °C -40 ... 85 °C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "BESCHLAGSENSOR", "STAT_BESCHLAGSENSOR_TEMP_WERT", STAT_BESCHLAGSENSOR_TEMP_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BESCHLAGSENSOR_VORHANDEN: {                                     // 0xD96D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BESCHLAGSENSOR_VORHANDEN", 1);
        break;
    }

    unsigned char STAT_VORHANDEN_BESCHLAGSENSOR = (RXBUF_UCHAR(0));
        // 0: Condensation sensor not available / coded 1: Condensation sensor available / coded / 0: Beschlagsensor
        // nicht vorhanden / codiert   1: Beschlagsensor vorhanden / codiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BESCHLAGSENSOR_VORHANDEN", "STAT_VORHANDEN_BESCHLAGSENSOR", STAT_VORHANDEN_BESCHLAGSENSOR, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_FONDSCHICHTUNGS_POTI: {                                         // 0xD96E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_FONDSCHICHTUNGS_POTI", 1);
        break;
    }

    unsigned char STAT_FONDSCHICHTUNGS_POTI_WERT = (RXBUF_UCHAR(0));
        // Output of the setting of the rear stratification potentiometer: 0-100%, 0xFF: value invalid / Ausgabe der
        // Einstellung des Fond-Schichtungspotentiometer: 0-100 %, 0xFF: Wert ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "FONDSCHICHTUNGS_POTI", "STAT_FONDSCHICHTUNGS_POTI_WERT", STAT_FONDSCHICHTUNGS_POTI_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_DRUCKSENSOR_HOCHAUFLOESEND: {                                   // 0xD9B8
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_DRUCKSENSOR_HOCHAUFLOESEND", 2);
        break;
    }

    float STAT_DRUCK_WERT = (RXBUF_UINT(0)/100.0f);
        // High-resolution refrigerant pressure output: 0.00 - 40.89 bar; 40.90 = short circuit to ground; 40.91 = open
        // circuit or short circuit to battery; 40.92 = not installed; 40.93 = function interface not available; 40.94 =
        // function reporting error; 40.95 = signal unfilled / Ausgabe Kältemitteldruck hochauflösend: 0,00 - 40,89 bar ;
        // 40,90 = Kurzschluss nach Masse;  40,91 = Leitungsunterbrechung oder Kurzschluss nach Batterie;  40,92 = Nicht
        // verbaut;  40,93 = Funktionsschnittstelle nicht verfügbar;  40,94 = Funktion melder Fehler;  40,95 = Signal
        // unbefüllt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "DRUCKSENSOR_HOCHAUFLOESEND", "STAT_DRUCK_WERT", STAT_DRUCK_WERT, "\"bar\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LENKRAD_SCHALTPADDLES: {                                        // 0xDA24
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LENKRAD_SCHALTPADDLES", 3);
        break;
    }

    unsigned char STAT_LENKRAD_SCHALTPADDLE_NR = (RXBUF_UCHAR(0));
        // Status shift paddles / Status Schaltpaddles
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "LENKRAD_SCHALTPADDLES", "STAT_LENKRAD_SCHALTPADDLE_NR", STAT_LENKRAD_SCHALTPADDLE_NR, "\"0-n\"");

    float STAT_SCHALTPADDLES_AD_WERT = (RXBUF_UINT(1)/10.0f);
        // AD value shift paddles / AD-Wert Schaltpaddles
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "LENKRAD_SCHALTPADDLES", "STAT_SCHALTPADDLES_AD_WERT", STAT_SCHALTPADDLES_AD_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_DC_DC_WANDLER_VORHANDEN: {                                      // 0xDA54
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_DC_DC_WANDLER_VORHANDEN", 2);
        break;
    }

    unsigned char STAT_DC_DC_WANDLER_1_VORHANDEN = (RXBUF_UCHAR(0));
        // 0: DC / DC converter 1 not available 1: DC / DC converter 1 available / 0: DC/DC-Wandler 1 nicht vorhanden 1:
        // DC/DC-Wandler 1 vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "DC_DC_WANDLER_VORHANDEN", "STAT_DC_DC_WANDLER_1_VORHANDEN", STAT_DC_DC_WANDLER_1_VORHANDEN, "\"0/1\"");

    unsigned char STAT_DC_DC_WANDLER_2_VORHANDEN = (RXBUF_UCHAR(1));
        // 0: DC / DC converter 2 not available 1: DC / DC converter 2 available / 0: DC/DC-Wandler 2 nicht vorhanden 1:
        // DC/DC-Wandler 2 vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "DC_DC_WANDLER_VORHANDEN", "STAT_DC_DC_WANDLER_2_VORHANDEN", STAT_DC_DC_WANDLER_2_VORHANDEN, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STAT_LIN_LAYERING: {                                            // 0xDA5F
    if (datalen < 260) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STAT_LIN_LAYERING", 260);
        break;
    }

    unsigned char STAT_SLAVE_NAME_1_WERT = (RXBUF_UCHAR(0));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_1_WERT", STAT_SLAVE_NAME_1_WERT, "");

    unsigned char STAT_LED_BLUE_1_WERT = (RXBUF_UCHAR(1));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_1_WERT", STAT_LED_BLUE_1_WERT, "");

    unsigned char STAT_LED_GREEN_1_WERT = (RXBUF_UCHAR(2));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_1_WERT", STAT_LED_GREEN_1_WERT, "");

    unsigned char STAT_LED_RED_1_WERT = (RXBUF_UCHAR(3));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_1_WERT", STAT_LED_RED_1_WERT, "");

    unsigned char STAT_BRIGHTNESS_1_WERT = (RXBUF_UCHAR(4));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_1_WERT", STAT_BRIGHTNESS_1_WERT, "");

    unsigned char STAT_LED_WHITE_1_WERT = (RXBUF_UCHAR(5));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_1_WERT", STAT_LED_WHITE_1_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_1_WERT = (RXBUF_UCHAR(6));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_1_WERT", STAT_FEHLER_KURZSCHLUSS_1_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_1_WERT = (RXBUF_UCHAR(7));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_1_WERT", STAT_FEHLER_OVERTEMP_1_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_1_WERT = (RXBUF_UCHAR(8));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_1_WERT", STAT_FEHLER_OPEN_LOAD_1_WERT, "");

    unsigned char STAT_FEHLER_INTERN_1_WERT = (RXBUF_UCHAR(9));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_1_WERT", STAT_FEHLER_INTERN_1_WERT, "");

    unsigned char STAT_SLAVE_NAME_2_WERT = (RXBUF_UCHAR(10));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_2_WERT", STAT_SLAVE_NAME_2_WERT, "");

    unsigned char STAT_LED_BLUE_2_WERT = (RXBUF_UCHAR(11));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_2_WERT", STAT_LED_BLUE_2_WERT, "");

    unsigned char STAT_LED_GREEN_2_WERT = (RXBUF_UCHAR(12));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_2_WERT", STAT_LED_GREEN_2_WERT, "");

    unsigned char STAT_LED_RED_2_WERT = (RXBUF_UCHAR(13));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_2_WERT", STAT_LED_RED_2_WERT, "");

    unsigned char STAT_BRIGHTNESS_2_WERT = (RXBUF_UCHAR(14));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_2_WERT", STAT_BRIGHTNESS_2_WERT, "");

    unsigned char STAT_LED_WHITE_2_WERT = (RXBUF_UCHAR(15));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_2_WERT", STAT_LED_WHITE_2_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_2_WERT = (RXBUF_UCHAR(16));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_2_WERT", STAT_FEHLER_KURZSCHLUSS_2_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_2_WERT = (RXBUF_UCHAR(17));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_2_WERT", STAT_FEHLER_OVERTEMP_2_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_2_WERT = (RXBUF_UCHAR(18));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_2_WERT", STAT_FEHLER_OPEN_LOAD_2_WERT, "");

    unsigned char STAT_FEHLER_INTERN_2_WERT = (RXBUF_UCHAR(19));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_2_WERT", STAT_FEHLER_INTERN_2_WERT, "");

    unsigned char STAT_SLAVE_NAME_3_WERT = (RXBUF_UCHAR(20));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_3_WERT", STAT_SLAVE_NAME_3_WERT, "");

    unsigned char STAT_LED_BLUE_3_WERT = (RXBUF_UCHAR(21));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_3_WERT", STAT_LED_BLUE_3_WERT, "");

    unsigned char STAT_LED_GREEN_3_WERT = (RXBUF_UCHAR(22));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_3_WERT", STAT_LED_GREEN_3_WERT, "");

    unsigned char STAT_LED_RED_3_WERT = (RXBUF_UCHAR(23));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_3_WERT", STAT_LED_RED_3_WERT, "");

    unsigned char STAT_BRIGHTNESS_3_WERT = (RXBUF_UCHAR(24));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_3_WERT", STAT_BRIGHTNESS_3_WERT, "");

    unsigned char STAT_LED_WHITE_3_WERT = (RXBUF_UCHAR(25));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_3_WERT", STAT_LED_WHITE_3_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_3_WERT = (RXBUF_UCHAR(26));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_3_WERT", STAT_FEHLER_KURZSCHLUSS_3_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_3_WERT = (RXBUF_UCHAR(27));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_3_WERT", STAT_FEHLER_OVERTEMP_3_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_3_WERT = (RXBUF_UCHAR(28));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_3_WERT", STAT_FEHLER_OPEN_LOAD_3_WERT, "");

    unsigned char STAT_FEHLER_INTERN_3_WERT = (RXBUF_UCHAR(29));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_3_WERT", STAT_FEHLER_INTERN_3_WERT, "");

    unsigned char STAT_SLAVE_NAME_4_WERT = (RXBUF_UCHAR(30));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_4_WERT", STAT_SLAVE_NAME_4_WERT, "");

    unsigned char STAT_LED_BLUE_4_WERT = (RXBUF_UCHAR(31));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_4_WERT", STAT_LED_BLUE_4_WERT, "");

    unsigned char STAT_LED_GREEN_4_WERT = (RXBUF_UCHAR(32));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_4_WERT", STAT_LED_GREEN_4_WERT, "");

    unsigned char STAT_LED_RED_4_WERT = (RXBUF_UCHAR(33));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_4_WERT", STAT_LED_RED_4_WERT, "");

    unsigned char STAT_BRIGHTNESS_4_WERT = (RXBUF_UCHAR(34));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_4_WERT", STAT_BRIGHTNESS_4_WERT, "");

    unsigned char STAT_LED_WHITE_4_WERT = (RXBUF_UCHAR(35));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_4_WERT", STAT_LED_WHITE_4_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_4_WERT = (RXBUF_UCHAR(36));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_4_WERT", STAT_FEHLER_KURZSCHLUSS_4_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_4_WERT = (RXBUF_UCHAR(37));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_4_WERT", STAT_FEHLER_OVERTEMP_4_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_4_WERT = (RXBUF_UCHAR(38));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_4_WERT", STAT_FEHLER_OPEN_LOAD_4_WERT, "");

    unsigned char STAT_FEHLER_INTERN_4_WERT = (RXBUF_UCHAR(39));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_4_WERT", STAT_FEHLER_INTERN_4_WERT, "");

    unsigned char STAT_SLAVE_NAME_5_WERT = (RXBUF_UCHAR(40));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_5_WERT", STAT_SLAVE_NAME_5_WERT, "");

    unsigned char STAT_LED_BLUE_5_WERT = (RXBUF_UCHAR(41));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_5_WERT", STAT_LED_BLUE_5_WERT, "");

    unsigned char STAT_LED_GREEN_5_WERT = (RXBUF_UCHAR(42));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_5_WERT", STAT_LED_GREEN_5_WERT, "");

    unsigned char STAT_LED_RED_5_WERT = (RXBUF_UCHAR(43));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_5_WERT", STAT_LED_RED_5_WERT, "");

    unsigned char STAT_BRIGHTNESS_5_WERT = (RXBUF_UCHAR(44));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_5_WERT", STAT_BRIGHTNESS_5_WERT, "");

    unsigned char STAT_LED_WHITE_5_WERT = (RXBUF_UCHAR(45));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_5_WERT", STAT_LED_WHITE_5_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_5_WERT = (RXBUF_UCHAR(46));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_5_WERT", STAT_FEHLER_KURZSCHLUSS_5_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_5_WERT = (RXBUF_UCHAR(47));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_5_WERT", STAT_FEHLER_OVERTEMP_5_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_5_WERT = (RXBUF_UCHAR(48));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_5_WERT", STAT_FEHLER_OPEN_LOAD_5_WERT, "");

    unsigned char STAT_FEHLER_INTERN_5_WERT = (RXBUF_UCHAR(49));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_5_WERT", STAT_FEHLER_INTERN_5_WERT, "");

    unsigned char STAT_SLAVE_NAME_6_WERT = (RXBUF_UCHAR(50));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_6_WERT", STAT_SLAVE_NAME_6_WERT, "");

    unsigned char STAT_LED_BLUE_6_WERT = (RXBUF_UCHAR(51));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_6_WERT", STAT_LED_BLUE_6_WERT, "");

    unsigned char STAT_LED_GREEN_6_WERT = (RXBUF_UCHAR(52));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_6_WERT", STAT_LED_GREEN_6_WERT, "");

    unsigned char STAT_LED_RED_6_WERT = (RXBUF_UCHAR(53));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_6_WERT", STAT_LED_RED_6_WERT, "");

    unsigned char STAT_BRIGHTNESS_6_WERT = (RXBUF_UCHAR(54));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_6_WERT", STAT_BRIGHTNESS_6_WERT, "");

    unsigned char STAT_LED_WHITE_6_WERT = (RXBUF_UCHAR(55));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_6_WERT", STAT_LED_WHITE_6_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_6_WERT = (RXBUF_UCHAR(56));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_6_WERT", STAT_FEHLER_KURZSCHLUSS_6_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_6_WERT = (RXBUF_UCHAR(57));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_6_WERT", STAT_FEHLER_OVERTEMP_6_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_6_WERT = (RXBUF_UCHAR(58));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_6_WERT", STAT_FEHLER_OPEN_LOAD_6_WERT, "");

    unsigned char STAT_FEHLER_INTERN_6_WERT = (RXBUF_UCHAR(59));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_6_WERT", STAT_FEHLER_INTERN_6_WERT, "");

    unsigned char STAT_SLAVE_NAME_7_WERT = (RXBUF_UCHAR(60));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_7_WERT", STAT_SLAVE_NAME_7_WERT, "");

    unsigned char STAT_LED_BLUE_7_WERT = (RXBUF_UCHAR(61));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_7_WERT", STAT_LED_BLUE_7_WERT, "");

    unsigned char STAT_LED_GREEN_7_WERT = (RXBUF_UCHAR(62));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_7_WERT", STAT_LED_GREEN_7_WERT, "");

    unsigned char STAT_LED_RED_7_WERT = (RXBUF_UCHAR(63));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_7_WERT", STAT_LED_RED_7_WERT, "");

    unsigned char STAT_BRIGHTNESS_7_WERT = (RXBUF_UCHAR(64));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_7_WERT", STAT_BRIGHTNESS_7_WERT, "");

    unsigned char STAT_LED_WHITE_7_WERT = (RXBUF_UCHAR(65));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_7_WERT", STAT_LED_WHITE_7_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_7_WERT = (RXBUF_UCHAR(66));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_7_WERT", STAT_FEHLER_KURZSCHLUSS_7_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_7_WERT = (RXBUF_UCHAR(67));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_7_WERT", STAT_FEHLER_OVERTEMP_7_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_7_WERT = (RXBUF_UCHAR(68));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_7_WERT", STAT_FEHLER_OPEN_LOAD_7_WERT, "");

    unsigned char STAT_FEHLER_INTERN_7_WERT = (RXBUF_UCHAR(69));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_7_WERT", STAT_FEHLER_INTERN_7_WERT, "");

    unsigned char STAT_SLAVE_NAME_8_WERT = (RXBUF_UCHAR(70));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_8_WERT", STAT_SLAVE_NAME_8_WERT, "");

    unsigned char STAT_LED_BLUE_8_WERT = (RXBUF_UCHAR(71));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_8_WERT", STAT_LED_BLUE_8_WERT, "");

    unsigned char STAT_LED_GREEN_8_WERT = (RXBUF_UCHAR(72));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_8_WERT", STAT_LED_GREEN_8_WERT, "");

    unsigned char STAT_LED_RED_8_WERT = (RXBUF_UCHAR(73));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_8_WERT", STAT_LED_RED_8_WERT, "");

    unsigned char STAT_BRIGHTNESS_8_WERT = (RXBUF_UCHAR(74));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_8_WERT", STAT_BRIGHTNESS_8_WERT, "");

    unsigned char STAT_LED_WHITE_8_WERT = (RXBUF_UCHAR(75));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_8_WERT", STAT_LED_WHITE_8_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_8_WERT = (RXBUF_UCHAR(76));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_8_WERT", STAT_FEHLER_KURZSCHLUSS_8_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_8_WERT = (RXBUF_UCHAR(77));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_8_WERT", STAT_FEHLER_OVERTEMP_8_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_8_WERT = (RXBUF_UCHAR(78));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_8_WERT", STAT_FEHLER_OPEN_LOAD_8_WERT, "");

    unsigned char STAT_FEHLER_INTERN_8_WERT = (RXBUF_UCHAR(79));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_8_WERT", STAT_FEHLER_INTERN_8_WERT, "");

    unsigned char STAT_SLAVE_NAME_9_WERT = (RXBUF_UCHAR(80));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_9_WERT", STAT_SLAVE_NAME_9_WERT, "");

    unsigned char STAT_LED_BLUE_9_WERT = (RXBUF_UCHAR(81));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_9_WERT", STAT_LED_BLUE_9_WERT, "");

    unsigned char STAT_LED_GREEN_9_WERT = (RXBUF_UCHAR(82));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_9_WERT", STAT_LED_GREEN_9_WERT, "");

    unsigned char STAT_LED_RED_9_WERT = (RXBUF_UCHAR(83));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_9_WERT", STAT_LED_RED_9_WERT, "");

    unsigned char STAT_BRIGHTNESS_9_WERT = (RXBUF_UCHAR(84));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_9_WERT", STAT_BRIGHTNESS_9_WERT, "");

    unsigned char STAT_LED_WHITE_9_WERT = (RXBUF_UCHAR(85));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_9_WERT", STAT_LED_WHITE_9_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_9_WERT = (RXBUF_UCHAR(86));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_9_WERT", STAT_FEHLER_KURZSCHLUSS_9_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_9_WERT = (RXBUF_UCHAR(87));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_9_WERT", STAT_FEHLER_OVERTEMP_9_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_9_WERT = (RXBUF_UCHAR(88));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_9_WERT", STAT_FEHLER_OPEN_LOAD_9_WERT, "");

    unsigned char STAT_FEHLER_INTERN_9_WERT = (RXBUF_UCHAR(89));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_9_WERT", STAT_FEHLER_INTERN_9_WERT, "");

    unsigned char STAT_SLAVE_NAME_10_WERT = (RXBUF_UCHAR(90));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_10_WERT", STAT_SLAVE_NAME_10_WERT, "");

    unsigned char STAT_LED_BLUE_10_WERT = (RXBUF_UCHAR(91));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_10_WERT", STAT_LED_BLUE_10_WERT, "");

    unsigned char STAT_LED_GREEN_10_WERT = (RXBUF_UCHAR(92));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_10_WERT", STAT_LED_GREEN_10_WERT, "");

    unsigned char STAT_LED_RED_10_WERT = (RXBUF_UCHAR(93));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_10_WERT", STAT_LED_RED_10_WERT, "");

    unsigned char STAT_BRIGHTNESS_10_WERT = (RXBUF_UCHAR(94));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_10_WERT", STAT_BRIGHTNESS_10_WERT, "");

    unsigned char STAT_LED_WHITE_10_WERT = (RXBUF_UCHAR(95));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_10_WERT", STAT_LED_WHITE_10_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_10_WERT = (RXBUF_UCHAR(96));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_10_WERT", STAT_FEHLER_KURZSCHLUSS_10_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_10_WERT = (RXBUF_UCHAR(97));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_10_WERT", STAT_FEHLER_OVERTEMP_10_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_10_WERT = (RXBUF_UCHAR(98));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_10_WERT", STAT_FEHLER_OPEN_LOAD_10_WERT, "");

    unsigned char STAT_FEHLER_INTERN_10_WERT = (RXBUF_UCHAR(99));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_10_WERT", STAT_FEHLER_INTERN_10_WERT, "");

    unsigned char STAT_SLAVE_NAME_11_WERT = (RXBUF_UCHAR(100));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_11_WERT", STAT_SLAVE_NAME_11_WERT, "");

    unsigned char STAT_LED_BLUE_11_WERT = (RXBUF_UCHAR(101));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_11_WERT", STAT_LED_BLUE_11_WERT, "");

    unsigned char STAT_LED_GREEN_11_WERT = (RXBUF_UCHAR(102));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_11_WERT", STAT_LED_GREEN_11_WERT, "");

    unsigned char STAT_LED_RED_11_WERT = (RXBUF_UCHAR(103));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_11_WERT", STAT_LED_RED_11_WERT, "");

    unsigned char STAT_BRIGHTNESS_11_WERT = (RXBUF_UCHAR(104));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_11_WERT", STAT_BRIGHTNESS_11_WERT, "");

    unsigned char STAT_LED_WHITE_11_WERT = (RXBUF_UCHAR(105));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_11_WERT", STAT_LED_WHITE_11_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_11_WERT = (RXBUF_UCHAR(106));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_11_WERT", STAT_FEHLER_KURZSCHLUSS_11_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_11_WERT = (RXBUF_UCHAR(107));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_11_WERT", STAT_FEHLER_OVERTEMP_11_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_11_WERT = (RXBUF_UCHAR(108));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_11_WERT", STAT_FEHLER_OPEN_LOAD_11_WERT, "");

    unsigned char STAT_FEHLER_INTERN_11_WERT = (RXBUF_UCHAR(109));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_11_WERT", STAT_FEHLER_INTERN_11_WERT, "");

    unsigned char STAT_SLAVE_NAME_12_WERT = (RXBUF_UCHAR(110));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_12_WERT", STAT_SLAVE_NAME_12_WERT, "");

    unsigned char STAT_LED_BLUE_12_WERT = (RXBUF_UCHAR(111));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_12_WERT", STAT_LED_BLUE_12_WERT, "");

    unsigned char STAT_LED_GREEN_12_WERT = (RXBUF_UCHAR(112));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_12_WERT", STAT_LED_GREEN_12_WERT, "");

    unsigned char STAT_LED_RED_12_WERT = (RXBUF_UCHAR(113));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_12_WERT", STAT_LED_RED_12_WERT, "");

    unsigned char STAT_BRIGHTNESS_12_WERT = (RXBUF_UCHAR(114));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_12_WERT", STAT_BRIGHTNESS_12_WERT, "");

    unsigned char STAT_LED_WHITE_12_WERT = (RXBUF_UCHAR(115));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_12_WERT", STAT_LED_WHITE_12_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_12_WERT = (RXBUF_UCHAR(116));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_12_WERT", STAT_FEHLER_KURZSCHLUSS_12_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_12_WERT = (RXBUF_UCHAR(117));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_12_WERT", STAT_FEHLER_OVERTEMP_12_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_12_WERT = (RXBUF_UCHAR(118));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_12_WERT", STAT_FEHLER_OPEN_LOAD_12_WERT, "");

    unsigned char STAT_FEHLER_INTERN_12_WERT = (RXBUF_UCHAR(119));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_12_WERT", STAT_FEHLER_INTERN_12_WERT, "");

    unsigned char STAT_SLAVE_NAME_13_WERT = (RXBUF_UCHAR(120));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_13_WERT", STAT_SLAVE_NAME_13_WERT, "");

    unsigned char STAT_LED_BLUE_13_WERT = (RXBUF_UCHAR(121));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_13_WERT", STAT_LED_BLUE_13_WERT, "");

    unsigned char STAT_LED_GREEN_13_WERT = (RXBUF_UCHAR(122));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_13_WERT", STAT_LED_GREEN_13_WERT, "");

    unsigned char STAT_LED_RED_13_WERT = (RXBUF_UCHAR(123));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_13_WERT", STAT_LED_RED_13_WERT, "");

    unsigned char STAT_BRIGHTNESS_13_WERT = (RXBUF_UCHAR(124));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_13_WERT", STAT_BRIGHTNESS_13_WERT, "");

    unsigned char STAT_LED_WHITE_13_WERT = (RXBUF_UCHAR(125));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_13_WERT", STAT_LED_WHITE_13_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_13_WERT = (RXBUF_UCHAR(126));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_13_WERT", STAT_FEHLER_KURZSCHLUSS_13_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_13_WERT = (RXBUF_UCHAR(127));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_13_WERT", STAT_FEHLER_OVERTEMP_13_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_13_WERT = (RXBUF_UCHAR(128));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_13_WERT", STAT_FEHLER_OPEN_LOAD_13_WERT, "");

    unsigned char STAT_FEHLER_INTERN_13_WERT = (RXBUF_UCHAR(129));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_13_WERT", STAT_FEHLER_INTERN_13_WERT, "");

    unsigned char STAT_SLAVE_NAME_14_WERT = (RXBUF_UCHAR(130));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_14_WERT", STAT_SLAVE_NAME_14_WERT, "");

    unsigned char STAT_LED_BLUE_14_WERT = (RXBUF_UCHAR(131));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_14_WERT", STAT_LED_BLUE_14_WERT, "");

    unsigned char STAT_LED_GREEN_14_WERT = (RXBUF_UCHAR(132));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_14_WERT", STAT_LED_GREEN_14_WERT, "");

    unsigned char STAT_LED_RED_14_WERT = (RXBUF_UCHAR(133));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_14_WERT", STAT_LED_RED_14_WERT, "");

    unsigned char STAT_BRIGHTNESS_14_WERT = (RXBUF_UCHAR(134));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_14_WERT", STAT_BRIGHTNESS_14_WERT, "");

    unsigned char STAT_LED_WHITE_14_WERT = (RXBUF_UCHAR(135));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_14_WERT", STAT_LED_WHITE_14_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_14_WERT = (RXBUF_UCHAR(136));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_14_WERT", STAT_FEHLER_KURZSCHLUSS_14_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_14_WERT = (RXBUF_UCHAR(137));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_14_WERT", STAT_FEHLER_OVERTEMP_14_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_14_WERT = (RXBUF_UCHAR(138));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_14_WERT", STAT_FEHLER_OPEN_LOAD_14_WERT, "");

    unsigned char STAT_FEHLER_INTERN_14_WERT = (RXBUF_UCHAR(139));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_14_WERT", STAT_FEHLER_INTERN_14_WERT, "");

    unsigned char STAT_SLAVE_NAME_15_WERT = (RXBUF_UCHAR(140));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_15_WERT", STAT_SLAVE_NAME_15_WERT, "");

    unsigned char STAT_LED_BLUE_15_WERT = (RXBUF_UCHAR(141));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_15_WERT", STAT_LED_BLUE_15_WERT, "");

    unsigned char STAT_LED_GREEN_15_WERT = (RXBUF_UCHAR(142));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_15_WERT", STAT_LED_GREEN_15_WERT, "");

    unsigned char STAT_LED_RED_15_WERT = (RXBUF_UCHAR(143));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_15_WERT", STAT_LED_RED_15_WERT, "");

    unsigned char STAT_BRIGHTNESS_15_WERT = (RXBUF_UCHAR(144));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_15_WERT", STAT_BRIGHTNESS_15_WERT, "");

    unsigned char STAT_LED_WHITE_15_WERT = (RXBUF_UCHAR(145));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_15_WERT", STAT_LED_WHITE_15_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_15_WERT = (RXBUF_UCHAR(146));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_15_WERT", STAT_FEHLER_KURZSCHLUSS_15_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_15_WERT = (RXBUF_UCHAR(147));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_15_WERT", STAT_FEHLER_OVERTEMP_15_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_15_WERT = (RXBUF_UCHAR(148));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_15_WERT", STAT_FEHLER_OPEN_LOAD_15_WERT, "");

    unsigned char STAT_FEHLER_INTERN_15_WERT = (RXBUF_UCHAR(149));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_15_WERT", STAT_FEHLER_INTERN_15_WERT, "");

    unsigned char STAT_SLAVE_NAME_16_WERT = (RXBUF_UCHAR(150));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_16_WERT", STAT_SLAVE_NAME_16_WERT, "");

    unsigned char STAT_LED_BLUE_16_WERT = (RXBUF_UCHAR(151));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_16_WERT", STAT_LED_BLUE_16_WERT, "");

    unsigned char STAT_LED_GREEN_16_WERT = (RXBUF_UCHAR(152));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_16_WERT", STAT_LED_GREEN_16_WERT, "");

    unsigned char STAT_LED_RED_16_WERT = (RXBUF_UCHAR(153));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_16_WERT", STAT_LED_RED_16_WERT, "");

    unsigned char STAT_BRIGHTNESS_16_WERT = (RXBUF_UCHAR(154));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_16_WERT", STAT_BRIGHTNESS_16_WERT, "");

    unsigned char STAT_LED_WHITE_16_WERT = (RXBUF_UCHAR(155));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_16_WERT", STAT_LED_WHITE_16_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_16_WERT = (RXBUF_UCHAR(156));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_16_WERT", STAT_FEHLER_KURZSCHLUSS_16_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_16_WERT = (RXBUF_UCHAR(157));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_16_WERT", STAT_FEHLER_OVERTEMP_16_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_16_WERT = (RXBUF_UCHAR(158));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_16_WERT", STAT_FEHLER_OPEN_LOAD_16_WERT, "");

    unsigned char STAT_FEHLER_INTERN_16_WERT = (RXBUF_UCHAR(159));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_16_WERT", STAT_FEHLER_INTERN_16_WERT, "");

    unsigned char STAT_SLAVE_NAME_17_WERT = (RXBUF_UCHAR(160));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_17_WERT", STAT_SLAVE_NAME_17_WERT, "");

    unsigned char STAT_LED_BLUE_17_WERT = (RXBUF_UCHAR(161));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_17_WERT", STAT_LED_BLUE_17_WERT, "");

    unsigned char STAT_LED_GREEN_17_WERT = (RXBUF_UCHAR(162));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_17_WERT", STAT_LED_GREEN_17_WERT, "");

    unsigned char STAT_LED_RED_17_WERT = (RXBUF_UCHAR(163));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_17_WERT", STAT_LED_RED_17_WERT, "");

    unsigned char STAT_BRIGHTNESS_17_WERT = (RXBUF_UCHAR(164));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_17_WERT", STAT_BRIGHTNESS_17_WERT, "");

    unsigned char STAT_LED_WHITE_17_WERT = (RXBUF_UCHAR(165));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_17_WERT", STAT_LED_WHITE_17_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_17_WERT = (RXBUF_UCHAR(166));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_17_WERT", STAT_FEHLER_KURZSCHLUSS_17_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_17_WERT = (RXBUF_UCHAR(167));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_17_WERT", STAT_FEHLER_OVERTEMP_17_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_17_WERT = (RXBUF_UCHAR(168));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_17_WERT", STAT_FEHLER_OPEN_LOAD_17_WERT, "");

    unsigned char STAT_FEHLER_INTERN_17_WERT = (RXBUF_UCHAR(169));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_17_WERT", STAT_FEHLER_INTERN_17_WERT, "");

    unsigned char STAT_SLAVE_NAME_18_WERT = (RXBUF_UCHAR(170));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_18_WERT", STAT_SLAVE_NAME_18_WERT, "");

    unsigned char STAT_LED_BLUE_18_WERT = (RXBUF_UCHAR(171));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_18_WERT", STAT_LED_BLUE_18_WERT, "");

    unsigned char STAT_LED_GREEN_18_WERT = (RXBUF_UCHAR(172));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_18_WERT", STAT_LED_GREEN_18_WERT, "");

    unsigned char STAT_LED_RED_18_WERT = (RXBUF_UCHAR(173));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_18_WERT", STAT_LED_RED_18_WERT, "");

    unsigned char STAT_BRIGHTNESS_18_WERT = (RXBUF_UCHAR(174));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_18_WERT", STAT_BRIGHTNESS_18_WERT, "");

    unsigned char STAT_LED_WHITE_18_WERT = (RXBUF_UCHAR(175));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_18_WERT", STAT_LED_WHITE_18_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_18_WERT = (RXBUF_UCHAR(176));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_18_WERT", STAT_FEHLER_KURZSCHLUSS_18_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_18_WERT = (RXBUF_UCHAR(177));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_18_WERT", STAT_FEHLER_OVERTEMP_18_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_18_WERT = (RXBUF_UCHAR(178));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_18_WERT", STAT_FEHLER_OPEN_LOAD_18_WERT, "");

    unsigned char STAT_FEHLER_INTERN_18_WERT = (RXBUF_UCHAR(179));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_18_WERT", STAT_FEHLER_INTERN_18_WERT, "");

    unsigned char STAT_SLAVE_NAME_19_WERT = (RXBUF_UCHAR(180));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_19_WERT", STAT_SLAVE_NAME_19_WERT, "");

    unsigned char STAT_LED_BLUE_19_WERT = (RXBUF_UCHAR(181));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_19_WERT", STAT_LED_BLUE_19_WERT, "");

    unsigned char STAT_LED_GREEN_19_WERT = (RXBUF_UCHAR(182));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_19_WERT", STAT_LED_GREEN_19_WERT, "");

    unsigned char STAT_LED_RED_19_WERT = (RXBUF_UCHAR(183));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_19_WERT", STAT_LED_RED_19_WERT, "");

    unsigned char STAT_BRIGHTNESS_19_WERT = (RXBUF_UCHAR(184));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_19_WERT", STAT_BRIGHTNESS_19_WERT, "");

    unsigned char STAT_LED_WHITE_19_WERT = (RXBUF_UCHAR(185));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_19_WERT", STAT_LED_WHITE_19_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_19_WERT = (RXBUF_UCHAR(186));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_19_WERT", STAT_FEHLER_KURZSCHLUSS_19_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_19_WERT = (RXBUF_UCHAR(187));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_19_WERT", STAT_FEHLER_OVERTEMP_19_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_19_WERT = (RXBUF_UCHAR(188));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_19_WERT", STAT_FEHLER_OPEN_LOAD_19_WERT, "");

    unsigned char STAT_FEHLER_INTERN_19_WERT = (RXBUF_UCHAR(189));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_19_WERT", STAT_FEHLER_INTERN_19_WERT, "");

    unsigned char STAT_SLAVE_NAME_20_WERT = (RXBUF_UCHAR(190));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_20_WERT", STAT_SLAVE_NAME_20_WERT, "");

    unsigned char STAT_LED_BLUE_20_WERT = (RXBUF_UCHAR(191));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_20_WERT", STAT_LED_BLUE_20_WERT, "");

    unsigned char STAT_LED_GREEN_20_WERT = (RXBUF_UCHAR(192));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_20_WERT", STAT_LED_GREEN_20_WERT, "");

    unsigned char STAT_LED_RED_20_WERT = (RXBUF_UCHAR(193));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_20_WERT", STAT_LED_RED_20_WERT, "");

    unsigned char STAT_BRIGHTNESS_20_WERT = (RXBUF_UCHAR(194));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_20_WERT", STAT_BRIGHTNESS_20_WERT, "");

    unsigned char STAT_LED_WHITE_20_WERT = (RXBUF_UCHAR(195));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_20_WERT", STAT_LED_WHITE_20_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_20_WERT = (RXBUF_UCHAR(196));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_20_WERT", STAT_FEHLER_KURZSCHLUSS_20_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_20_WERT = (RXBUF_UCHAR(197));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_20_WERT", STAT_FEHLER_OVERTEMP_20_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_20_WERT = (RXBUF_UCHAR(198));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_20_WERT", STAT_FEHLER_OPEN_LOAD_20_WERT, "");

    unsigned char STAT_FEHLER_INTERN_20_WERT = (RXBUF_UCHAR(199));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_20_WERT", STAT_FEHLER_INTERN_20_WERT, "");

    unsigned char STAT_SLAVE_NAME_21_WERT = (RXBUF_UCHAR(200));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_21_WERT", STAT_SLAVE_NAME_21_WERT, "");

    unsigned char STAT_LED_BLUE_21_WERT = (RXBUF_UCHAR(201));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_21_WERT", STAT_LED_BLUE_21_WERT, "");

    unsigned char STAT_LED_GREEN_21_WERT = (RXBUF_UCHAR(202));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_21_WERT", STAT_LED_GREEN_21_WERT, "");

    unsigned char STAT_LED_RED_21_WERT = (RXBUF_UCHAR(203));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_21_WERT", STAT_LED_RED_21_WERT, "");

    unsigned char STAT_BRIGHTNESS_21_WERT = (RXBUF_UCHAR(204));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_21_WERT", STAT_BRIGHTNESS_21_WERT, "");

    unsigned char STAT_LED_WHITE_21_WERT = (RXBUF_UCHAR(205));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_21_WERT", STAT_LED_WHITE_21_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_21_WERT = (RXBUF_UCHAR(206));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_21_WERT", STAT_FEHLER_KURZSCHLUSS_21_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_21_WERT = (RXBUF_UCHAR(207));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_21_WERT", STAT_FEHLER_OVERTEMP_21_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_21_WERT = (RXBUF_UCHAR(208));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_21_WERT", STAT_FEHLER_OPEN_LOAD_21_WERT, "");

    unsigned char STAT_FEHLER_INTERN_21_WERT = (RXBUF_UCHAR(209));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_21_WERT", STAT_FEHLER_INTERN_21_WERT, "");

    unsigned char STAT_SLAVE_NAME_22_WERT = (RXBUF_UCHAR(210));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_22_WERT", STAT_SLAVE_NAME_22_WERT, "");

    unsigned char STAT_LED_BLUE_22_WERT = (RXBUF_UCHAR(211));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_22_WERT", STAT_LED_BLUE_22_WERT, "");

    unsigned char STAT_LED_GREEN_22_WERT = (RXBUF_UCHAR(212));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_22_WERT", STAT_LED_GREEN_22_WERT, "");

    unsigned char STAT_LED_RED_22_WERT = (RXBUF_UCHAR(213));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_22_WERT", STAT_LED_RED_22_WERT, "");

    unsigned char STAT_BRIGHTNESS_22_WERT = (RXBUF_UCHAR(214));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_22_WERT", STAT_BRIGHTNESS_22_WERT, "");

    unsigned char STAT_LED_WHITE_22_WERT = (RXBUF_UCHAR(215));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_22_WERT", STAT_LED_WHITE_22_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_22_WERT = (RXBUF_UCHAR(216));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_22_WERT", STAT_FEHLER_KURZSCHLUSS_22_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_22_WERT = (RXBUF_UCHAR(217));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_22_WERT", STAT_FEHLER_OVERTEMP_22_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_22_WERT = (RXBUF_UCHAR(218));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_22_WERT", STAT_FEHLER_OPEN_LOAD_22_WERT, "");

    unsigned char STAT_FEHLER_INTERN_22_WERT = (RXBUF_UCHAR(219));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_22_WERT", STAT_FEHLER_INTERN_22_WERT, "");

    unsigned char STAT_SLAVE_NAME_23_WERT = (RXBUF_UCHAR(220));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_23_WERT", STAT_SLAVE_NAME_23_WERT, "");

    unsigned char STAT_LED_BLUE_23_WERT = (RXBUF_UCHAR(221));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_23_WERT", STAT_LED_BLUE_23_WERT, "");

    unsigned char STAT_LED_GREEN_23_WERT = (RXBUF_UCHAR(222));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_23_WERT", STAT_LED_GREEN_23_WERT, "");

    unsigned char STAT_LED_RED_23_WERT = (RXBUF_UCHAR(223));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_23_WERT", STAT_LED_RED_23_WERT, "");

    unsigned char STAT_BRIGHTNESS_23_WERT = (RXBUF_UCHAR(224));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_23_WERT", STAT_BRIGHTNESS_23_WERT, "");

    unsigned char STAT_LED_WHITE_23_WERT = (RXBUF_UCHAR(225));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_23_WERT", STAT_LED_WHITE_23_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_23_WERT = (RXBUF_UCHAR(226));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_23_WERT", STAT_FEHLER_KURZSCHLUSS_23_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_23_WERT = (RXBUF_UCHAR(227));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_23_WERT", STAT_FEHLER_OVERTEMP_23_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_23_WERT = (RXBUF_UCHAR(228));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_23_WERT", STAT_FEHLER_OPEN_LOAD_23_WERT, "");

    unsigned char STAT_FEHLER_INTERN_23_WERT = (RXBUF_UCHAR(229));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_23_WERT", STAT_FEHLER_INTERN_23_WERT, "");

    unsigned char STAT_SLAVE_NAME_24_WERT = (RXBUF_UCHAR(230));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_24_WERT", STAT_SLAVE_NAME_24_WERT, "");

    unsigned char STAT_LED_BLUE_24_WERT = (RXBUF_UCHAR(231));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_24_WERT", STAT_LED_BLUE_24_WERT, "");

    unsigned char STAT_LED_GREEN_24_WERT = (RXBUF_UCHAR(232));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_24_WERT", STAT_LED_GREEN_24_WERT, "");

    unsigned char STAT_LED_RED_24_WERT = (RXBUF_UCHAR(233));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_24_WERT", STAT_LED_RED_24_WERT, "");

    unsigned char STAT_BRIGHTNESS_24_WERT = (RXBUF_UCHAR(234));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_24_WERT", STAT_BRIGHTNESS_24_WERT, "");

    unsigned char STAT_LED_WHITE_24_WERT = (RXBUF_UCHAR(235));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_24_WERT", STAT_LED_WHITE_24_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_24_WERT = (RXBUF_UCHAR(236));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_24_WERT", STAT_FEHLER_KURZSCHLUSS_24_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_24_WERT = (RXBUF_UCHAR(237));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_24_WERT", STAT_FEHLER_OVERTEMP_24_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_24_WERT = (RXBUF_UCHAR(238));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_24_WERT", STAT_FEHLER_OPEN_LOAD_24_WERT, "");

    unsigned char STAT_FEHLER_INTERN_24_WERT = (RXBUF_UCHAR(239));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_24_WERT", STAT_FEHLER_INTERN_24_WERT, "");

    unsigned char STAT_SLAVE_NAME_25_WERT = (RXBUF_UCHAR(240));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_25_WERT", STAT_SLAVE_NAME_25_WERT, "");

    unsigned char STAT_LED_BLUE_25_WERT = (RXBUF_UCHAR(241));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_25_WERT", STAT_LED_BLUE_25_WERT, "");

    unsigned char STAT_LED_GREEN_25_WERT = (RXBUF_UCHAR(242));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_25_WERT", STAT_LED_GREEN_25_WERT, "");

    unsigned char STAT_LED_RED_25_WERT = (RXBUF_UCHAR(243));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_25_WERT", STAT_LED_RED_25_WERT, "");

    unsigned char STAT_BRIGHTNESS_25_WERT = (RXBUF_UCHAR(244));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_25_WERT", STAT_BRIGHTNESS_25_WERT, "");

    unsigned char STAT_LED_WHITE_25_WERT = (RXBUF_UCHAR(245));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_25_WERT", STAT_LED_WHITE_25_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_25_WERT = (RXBUF_UCHAR(246));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_25_WERT", STAT_FEHLER_KURZSCHLUSS_25_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_25_WERT = (RXBUF_UCHAR(247));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_25_WERT", STAT_FEHLER_OVERTEMP_25_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_25_WERT = (RXBUF_UCHAR(248));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_25_WERT", STAT_FEHLER_OPEN_LOAD_25_WERT, "");

    unsigned char STAT_FEHLER_INTERN_25_WERT = (RXBUF_UCHAR(249));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_25_WERT", STAT_FEHLER_INTERN_25_WERT, "");

    unsigned char STAT_SLAVE_NAME_26_WERT = (RXBUF_UCHAR(250));
        // Lin slave name read from the coding. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT / Lin Slave Name aus der
        // Kodierung ausgelesen. Slave 1 = Status_LRL_1_LIN = RGB_LIN_SLAVE_1_FKT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_SLAVE_NAME_26_WERT", STAT_SLAVE_NAME_26_WERT, "");

    unsigned char STAT_LED_BLUE_26_WERT = (RXBUF_UCHAR(251));
        // Reported status of the blue LED of the LIN slave / Rückgemeldeter Status der Blauen  LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_BLUE_26_WERT", STAT_LED_BLUE_26_WERT, "");

    unsigned char STAT_LED_GREEN_26_WERT = (RXBUF_UCHAR(252));
        // Reported status of the green LED of the LIN slave / Rückgemeldeter Status der grünen LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_GREEN_26_WERT", STAT_LED_GREEN_26_WERT, "");

    unsigned char STAT_LED_RED_26_WERT = (RXBUF_UCHAR(253));
        // Reported status of the red LED of the LIN slave / Rückgemeldeter Status der roten LED des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_RED_26_WERT", STAT_LED_RED_26_WERT, "");

    unsigned char STAT_BRIGHTNESS_26_WERT = (RXBUF_UCHAR(254));
        // Status value brightness of the LIN slave / Statuswert Helligkeit des LIN-Slaves
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_BRIGHTNESS_26_WERT", STAT_BRIGHTNESS_26_WERT, "");

    unsigned char STAT_LED_WHITE_26_WERT = (RXBUF_UCHAR(255));
        // Status of the white footwell LED / Status der weißen Fussraum LED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_LED_WHITE_26_WERT", STAT_LED_WHITE_26_WERT, "");

    unsigned char STAT_FEHLER_KURZSCHLUSS_26_WERT = (RXBUF_UCHAR(256));
        // Reported short circuit fault / Gemeldeter Kurzschlussfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_KURZSCHLUSS_26_WERT", STAT_FEHLER_KURZSCHLUSS_26_WERT, "");

    unsigned char STAT_FEHLER_OVERTEMP_26_WERT = (RXBUF_UCHAR(257));
        // Reported overtemperature error / Gemeldeter Übertemperaturfehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OVERTEMP_26_WERT", STAT_FEHLER_OVERTEMP_26_WERT, "");

    unsigned char STAT_FEHLER_OPEN_LOAD_26_WERT = (RXBUF_UCHAR(258));
        // Reported open load error / Gemeldeter Open Load Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_OPEN_LOAD_26_WERT", STAT_FEHLER_OPEN_LOAD_26_WERT, "");

    unsigned char STAT_FEHLER_INTERN_26_WERT = (RXBUF_UCHAR(259));
        // Reported internal error / Gemeldeter interer Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STAT_LIN_LAYERING", "STAT_FEHLER_INTERN_26_WERT", STAT_FEHLER_INTERN_26_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_CODIERUNG_FAHRZEUGKLAPPEN: {                             // 0xDA61
    if (datalen < 5) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_CODIERUNG_FAHRZEUGKLAPPEN", 5);
        break;
    }

    unsigned char STAT_CODIERUNG_FRONTKLAPPE = (RXBUF_UCHAR(0));
        // The result returns whether the front flap is activated in the coding. 0 = not active 1 = active / Das Ergebnis
        // gibt zurück ob die Frontklappe in den Codierung aktiviert ist. 0 = Nicht aktiv 1 = Aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_CODIERUNG_FAHRZEUGKLAPPEN", "STAT_CODIERUNG_FRONTKLAPPE", STAT_CODIERUNG_FRONTKLAPPE, "\"0/1\"");

    unsigned char STAT_CODIERUNG_HECKKLAPPE = (RXBUF_UCHAR(1));
        // The result returns whether the tailgate is activated in the coding. 0 = not active 1 = active / Das Ergebnis
        // gibt zurück ob die Heckklappe in den Codierung aktiviert ist. 0 = Nicht aktiv 1 = Aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_CODIERUNG_FAHRZEUGKLAPPEN", "STAT_CODIERUNG_HECKKLAPPE", STAT_CODIERUNG_HECKKLAPPE, "\"0/1\"");

    unsigned char STAT_CODIERUNG_HECKSCHEIBE = (RXBUF_UCHAR(2));
        // The result returns whether the rear window is activated in the coding. 0 = not active 1 = active / Das
        // Ergebnis gibt zurück ob die Heckscheibe in den Codierung aktiviert ist. 0 = Nicht aktiv 1 = Aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_CODIERUNG_FAHRZEUGKLAPPEN", "STAT_CODIERUNG_HECKSCHEIBE", STAT_CODIERUNG_HECKSCHEIBE, "\"0/1\"");

    unsigned char STAT_CODIERUNG_MOTORHAUBE = (RXBUF_UCHAR(3));
        // The result returns whether the bonnet is activated in the coding. 0 = not active 1 = active / Das Ergebnis
        // gibt zurück ob die Motorhaube in den Codierung aktiviert ist. 0 = Nicht aktiv 1 = Aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_CODIERUNG_FAHRZEUGKLAPPEN", "STAT_CODIERUNG_MOTORHAUBE", STAT_CODIERUNG_MOTORHAUBE, "\"0/1\"");

    unsigned char STAT_CODIERUNG_SPLITDOORS = (RXBUF_UCHAR(4));
        // The result returns whether the split doors are activated in the coding. 0 = not active 1 = active / Das
        // Ergebnis gibt zurück ob die Split Doors in den Codierung aktiviert sind. 0 = Nicht aktiv 1 = Aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_CODIERUNG_FAHRZEUGKLAPPEN", "STAT_CODIERUNG_SPLITDOORS", STAT_CODIERUNG_SPLITDOORS, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_TUERKONTAKT_BFH_OBEN: {                                         // 0xDA7B
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_TUERKONTAKT_BFH_OBEN", 1);
        break;
    }

    unsigned char STAT_TUERKONTAKT_BFH_OBEN = (RXBUF_UCHAR(0));
        // STAT_TUERKONTAKT_BFH_OBEN / STAT_TUERKONTAKT_BFH_OBEN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "TUERKONTAKT_BFH_OBEN", "STAT_TUERKONTAKT_BFH_OBEN", STAT_TUERKONTAKT_BFH_OBEN, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_TUERKONTAKT_FAH_OBEN: {                                         // 0xDA7E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_TUERKONTAKT_FAH_OBEN", 1);
        break;
    }

    unsigned char STAT_TUERKONTAKT_FA_OBEN = (RXBUF_UCHAR(0));
        // The result contains the current state of the HW input, door contact, driver's door top rear. Note: For value 8
        // = contact not installed, the coding value CLI_REAR_DOOR_CONTACT_TOP_ASSEMBLED must be evaluated. / Das Result
        // enthält den aktuellen Zustand des HW-Eingang Türkontakt Fahrertür hinten oben. Hinweis: Für Wert  8 = Kontakt
        // nicht verbaut  muss der Codierwert CLI_REAR_DOOR_CONTACT_TOP_ASSEMBLED ausgewertet werden.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "TUERKONTAKT_FAH_OBEN", "STAT_TUERKONTAKT_FA_OBEN", STAT_TUERKONTAKT_FA_OBEN, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZV_BEIFAHRER: {                                                 // 0xDA81
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZV_BEIFAHRER", 3);
        break;
    }

    unsigned char STAT_ZV_BF_ENTRIEGELT = (RXBUF_UCHAR(0));
        // 0: Front passenger door lock not unlocked 1: Front passenger door lock unlocked / 0: Schloss Beifahrertuer
        // nicht entriegelt 1: Schloss Beifahrertuer entriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_BEIFAHRER", "STAT_ZV_BF_ENTRIEGELT", STAT_ZV_BF_ENTRIEGELT, "\"0-n\"");

    unsigned char STAT_ZV_BF_VERRIEGELT = (RXBUF_UCHAR(1));
        // 0: Lock front passenger door not locked 1: Lock front passenger door locked / 0: Schloss Beifahrertuer nicht
        // verriegelt 1: Schloss Beifahrertuer verriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_BEIFAHRER", "STAT_ZV_BF_VERRIEGELT", STAT_ZV_BF_VERRIEGELT, "\"0-n\"");

    unsigned char STAT_ZV_BF_GESICHERT = (RXBUF_UCHAR(2));
        // 0: Passenger door lock not secured 1: Passenger door lock secured / 0: Schloss Beifahrertuer nicht gesichert
        // 1: Schloss Beifahrertuer gesichert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_BEIFAHRER", "STAT_ZV_BF_GESICHERT", STAT_ZV_BF_GESICHERT, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZV_BEIFAHRER_HINTEN: {                                          // 0xDA82
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZV_BEIFAHRER_HINTEN", 3);
        break;
    }

    unsigned char STAT_ZV_BFH_ENTRIEGELT = (RXBUF_UCHAR(0));
        // 0: Rear passenger door lock not unlocked 1: Rear passenger door lock unlocked / 0: Schloss Beifahrertuer
        // hinten nicht entriegelt 1: Schloss Beifahrertuer hinten entriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_BEIFAHRER_HINTEN", "STAT_ZV_BFH_ENTRIEGELT", STAT_ZV_BFH_ENTRIEGELT, "\"0-n\"");

    unsigned char STAT_ZV_BFH_VERRIEGELT = (RXBUF_UCHAR(1));
        // 0: Rear passenger door lock not locked 1: Rear passenger door lock locked / 0: Schloss Beifahrertuer hinten
        // nicht verriegelt 1: Schloss Beifahrertuer hinten verriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_BEIFAHRER_HINTEN", "STAT_ZV_BFH_VERRIEGELT", STAT_ZV_BFH_VERRIEGELT, "\"0-n\"");

    unsigned char STAT_ZV_BFH_GESICHERT = (RXBUF_UCHAR(2));
        // 0: Rear passenger door lock not secured 1: Rear passenger door lock secured / 0: Schloss Beifahrertuer hinten
        // nicht gesichert 1: Schloss Beifahrertuer hinten gesichert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_BEIFAHRER_HINTEN", "STAT_ZV_BFH_GESICHERT", STAT_ZV_BFH_GESICHERT, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZV_FAHRER: {                                                    // 0xDA83
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZV_FAHRER", 3);
        break;
    }

    unsigned char STAT_ZV_FA_ENTRIEGELT = (RXBUF_UCHAR(0));
        // 0: Driver's door lock not unlocked 1: Driver's door lock unlocked / 0: Schloss Fahrertuer nicht entriegelt 1:
        // Schloss Fahrertuer entriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_FAHRER", "STAT_ZV_FA_ENTRIEGELT", STAT_ZV_FA_ENTRIEGELT, "\"0-n\"");

    unsigned char STAT_ZV_FA_VERRIEGELT = (RXBUF_UCHAR(1));
        // 0: Driver's door lock not locked 1: Driver's door lock locked / 0: Schloss Fahrertuer nicht verriegelt 1:
        // Schloss Fahrertuer verriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_FAHRER", "STAT_ZV_FA_VERRIEGELT", STAT_ZV_FA_VERRIEGELT, "\"0-n\"");

    unsigned char STAT_ZV_FA_GESICHERT = (RXBUF_UCHAR(2));
        // 0: Driver's door lock not secured 1: Driver's door lock secured / 0: Schloss Fahrertuer nicht gesichert 1:
        // Schloss Fahrertuer gesichert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_FAHRER", "STAT_ZV_FA_GESICHERT", STAT_ZV_FA_GESICHERT, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZV_FAHRER_HINTEN: {                                             // 0xDA84
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZV_FAHRER_HINTEN", 3);
        break;
    }

    unsigned char STAT_ZV_FAH_ENTRIEGELT = (RXBUF_UCHAR(0));
        // 0: Rear driver door lock not unlocked 1: Rear driver door lock unlocked / 0: Schloss Fahrertuer hinten nicht
        // entriegelt 1: Schloss Fahrertuer hinten entriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_FAHRER_HINTEN", "STAT_ZV_FAH_ENTRIEGELT", STAT_ZV_FAH_ENTRIEGELT, "\"0-n\"");

    unsigned char STAT_ZV_FAH_VERRIEGELT = (RXBUF_UCHAR(1));
        // 0: Rear driver door lock not locked 1: Rear driver door lock locked / 0: Schloss Fahrertuer hinten nicht
        // verriegelt 1: Schloss Fahrertuer hinten verriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_FAHRER_HINTEN", "STAT_ZV_FAH_VERRIEGELT", STAT_ZV_FAH_VERRIEGELT, "\"0-n\"");

    unsigned char STAT_ZV_FAH_GESICHERT = (RXBUF_UCHAR(2));
        // 0: Rear driver door lock not secured 1: Rear driver door lock secured / 0: Schloss Fahrertuer hinten nicht
        // gesichert 1: Schloss Fahrertuer hinten gesichert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_FAHRER_HINTEN", "STAT_ZV_FAH_GESICHERT", STAT_ZV_FAH_GESICHERT, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZV_HECKKLAPPE: {                                                // 0xDA85
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZV_HECKKLAPPE", 2);
        break;
    }

    unsigned char STAT_ZV_HECKKLAPPE_ENTRIEGELT_NR = (RXBUF_UCHAR(0));
        // 0: lock is not unlocked (not active); 1: lock is unlocked (active); 255: Signal invalid / implausible / 0:
        // Schloss ist nicht entriegelt (nicht aktiv ); 1: Schloss ist entriegelt (aktiv); 255: Signal ungültig /
        // unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_HECKKLAPPE", "STAT_ZV_HECKKLAPPE_ENTRIEGELT_NR", STAT_ZV_HECKKLAPPE_ENTRIEGELT_NR, "\"0-n\"");

    unsigned char STAT_ZV_HECKKLAPPE_VERRIEGELT_NR = (RXBUF_UCHAR(1));
        // 0: lock is not locked (not active); 1: lock is locked (active); 255: Signal invalid / implausible / 0: Schloss
        // ist nicht verriegelt (nicht aktiv ); 1: Schloss ist verriegelt (aktiv); 255: Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_HECKKLAPPE", "STAT_ZV_HECKKLAPPE_VERRIEGELT_NR", STAT_ZV_HECKKLAPPE_VERRIEGELT_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZV_HECKSCHEIBE: {                                               // 0xDA86
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZV_HECKSCHEIBE", 2);
        break;
    }

    unsigned char STAT_ZV_HECKSCHEIBE_ENTRIEGELT_NR = (RXBUF_UCHAR(0));
        // 0: Rear window lock not unlocked 1: Rear window lock unlocked / 0: Schloss Heckscheibe nicht entriegelt 1:
        // Schloss Heckscheibe entriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_HECKSCHEIBE", "STAT_ZV_HECKSCHEIBE_ENTRIEGELT_NR", STAT_ZV_HECKSCHEIBE_ENTRIEGELT_NR, "\"0-n\"");

    unsigned char STAT_ZV_HECKSCHEIBE_VERRIEGELT_NR = (RXBUF_UCHAR(1));
        // 0: Rear window lock not locked 1: Rear window lock locked / 0: Schloss Heckscheibe nicht verriegelt  1:
        // Schloss Heckscheibe verriegelt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_HECKSCHEIBE", "STAT_ZV_HECKSCHEIBE_VERRIEGELT_NR", STAT_ZV_HECKSCHEIBE_VERRIEGELT_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZV_GESAMT: {                                                    // 0xDA87
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZV_GESAMT", 4);
        break;
    }

    unsigned char STAT_ZV_FA_NR = (RXBUF_UCHAR(0));
        // The result contains the current ZV status of the driver's door. / Das Result enthält den aktuellen ZV-Zustand
        // der Fahrertüre.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_GESAMT", "STAT_ZV_FA_NR", STAT_ZV_FA_NR, "\"0-n\"");

    unsigned char STAT_ZV_BF_NR = (RXBUF_UCHAR(1));
        // The result contains the current ZV status of the passenger door. / Das Result enthält den aktuellen ZV-Zustand
        // der Beifahrertüre.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_GESAMT", "STAT_ZV_BF_NR", STAT_ZV_BF_NR, "\"0-n\"");

    unsigned char STAT_ZV_FAH_NR = (RXBUF_UCHAR(2));
        // The result contains the current ZV status of the rear driver's door. / Das Result enthält den aktuellen
        // ZV-Zustand der Fahrertüre hinten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_GESAMT", "STAT_ZV_FAH_NR", STAT_ZV_FAH_NR, "\"0-n\"");

    unsigned char STAT_ZV_BFH_NR = (RXBUF_UCHAR(3));
        // The result contains the current ZV status of the rear passenger door. / Das Result enthält den aktuellen
        // ZV-Zustand der Beifahrertüre hinten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_GESAMT", "STAT_ZV_BFH_NR", STAT_ZV_BFH_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ZV_KURZSCHLUSSABSCHALTUNG: {                                    // 0xDA95
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ZV_KURZSCHLUSSABSCHALTUNG", 2);
        break;
    }

    unsigned char STAT_HECKKLAPPE_KURZSCHLUSSABSCHALTUNG_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the activation status of the short-circuit shutdown of the tailgate. / Das Result enthält
        // den Aktivierungsstatus der Kurzschlussabschaltung der Heckklappe.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_KURZSCHLUSSABSCHALTUNG", "STAT_HECKKLAPPE_KURZSCHLUSSABSCHALTUNG_AKTIV", STAT_HECKKLAPPE_KURZSCHLUSSABSCHALTUNG_AKTIV, "\"0-n\"");

    unsigned char STAT_HECKSCHEIBE_KURZSCHLUSSABSCHALTUNG_AKTIV = (RXBUF_UCHAR(1));
        // The result contains the activation status of the short-circuit shutdown of the rear window. / Das Result
        // enthält den Aktivierungsstatus der Kurzschlussabschaltung der Heckscheibe.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ZV_KURZSCHLUSSABSCHALTUNG", "STAT_HECKSCHEIBE_KURZSCHLUSSABSCHALTUNG_AKTIV", STAT_HECKSCHEIBE_KURZSCHLUSSABSCHALTUNG_AKTIV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SPANNUNG_KLEMMEN: {                                             // 0xDAB3
    if (datalen < 30) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SPANNUNG_KLEMMEN", 30);
        break;
    }

    float STAT_SPANNUNG_KLEMME_30B_1_WERT = (RXBUF_UINT(0)/1000.0f);
        // The result contains the voltage value of terminal 30B_1. / Das Result enthält den Spannungswert Klemme 30B_1.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_30B_1_WERT", STAT_SPANNUNG_KLEMME_30B_1_WERT, "\"V\"");

    float STAT_SPANNUNG_KLEMME_30B_2_WERT = (RXBUF_UINT(2)/1000.0f);
        // The result contains the voltage value of terminal 30B_2. / Das Result enthält den Spannungswert Klemme 30B_2.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_30B_2_WERT", STAT_SPANNUNG_KLEMME_30B_2_WERT, "\"V\"");

    float STAT_SPANNUNG_KLEMME_30B_3_WERT = (RXBUF_UINT(4)/1000.0f);
        // The result contains the voltage value of terminal 30B_3. / Das Result enthält den Spannungswert Klemme 30B_3.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_30B_3_WERT", STAT_SPANNUNG_KLEMME_30B_3_WERT, "\"V\"");

    unsigned short STAT_SPANNUNG_KLEMME_15WUP = (RXBUF_UINT(6));
        // The result contains the voltage value of terminal 15_WUP at the FEM output. Possible values: 1 = active, 0 =
        // not active / Das Result enthält den Spannungswert Klemme 15_WUP am FEM Ausgang. Mögliche Werte: 1 = Aktiv, 0 =
        // nicht aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_15WUP", STAT_SPANNUNG_KLEMME_15WUP, "\"0/1\"");

    float STAT_SPANNUNG_KLEMME_15N1_WERT = (RXBUF_UINT(8)/1000.0f);
        // The result contains the voltage value of terminal 15_N1 at the FEM output. / Das Result enthält den
        // Spannungswert Klemme 15_N1 am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_15N1_WERT", STAT_SPANNUNG_KLEMME_15N1_WERT, "\"V\"");

    float STAT_SPANNUNG_KLEMME_15N2_WERT = (RXBUF_UINT(10)/1000.0f);
        // The result contains the voltage value of terminal 15_N2 at the FEM output. / Das Result enthält den
        // Spannungswert Klemme 15_N2 am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_15N2_WERT", STAT_SPANNUNG_KLEMME_15N2_WERT, "\"V\"");

    float STAT_SPANNUNG_KLEMME_15_WERT = (RXBUF_UINT(12)/1000.0f);
        // The result contains the voltage value at terminal 15 at the FEM output. / Das Result enthält den Spannungswert
        // Klemme 15 am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_15_WERT", STAT_SPANNUNG_KLEMME_15_WERT, "\"V\"");

    float STAT_STROM_KLEMME_15_50_WERT = (RXBUF_UINT(14)/1000.0f);
        // The result contains the current value at terminals 15 and 50 at the FEM output. / Das Result enthält den
        // Stromwert an Klemme 15 und 50 am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_STROM_KLEMME_15_50_WERT", STAT_STROM_KLEMME_15_50_WERT, "\"A\"");

    float STAT_SPANNUNG_KLEMME_50_WERT = (RXBUF_UINT(16)/1000.0f);
        // The result contains the voltage value at terminal 50 at the FEM output. / Das Result enthält den Spannungswert
        // Klemme 50  am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_50_WERT", STAT_SPANNUNG_KLEMME_50_WERT, "\"V\"");

    float STAT_SPANNUNG_KLEMME_50MSA_WERT = (RXBUF_UINT(18)/1000.0f);
        // The result contains the voltage value of terminal 50_MSA at the FEM output. / Das Result enthält den
        // Spannungswert Klemme 50_MSA am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_50MSA_WERT", STAT_SPANNUNG_KLEMME_50MSA_WERT, "\"V\"");

    float STAT_STROM_LF_WERT = (RXBUF_UINT(20)/1000.0f);
        // The result contains the current value at LF (CA antennas) at the FEM output. / Das Result enthält den
        // Stromwert an LF (CA-Antennen) am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_STROM_LF_WERT", STAT_STROM_LF_WERT, "\"A\"");

    float STAT_DIAG_LF_WERT = (RXBUF_UINT(22)/1000.0f);
        // The result contains the voltage value at the LF (CA antennas) at the FEM output. / Das Result enthält den
        // Spannungswert an LF (CA-Antennen) am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_DIAG_LF_WERT", STAT_DIAG_LF_WERT, "\"V\"");

    float STAT_SPANNUNG_KLEMME_31ELV_WERT = (RXBUF_UINT(24)/1000.0f);
        // The result contains the voltage value at terminal 31ELV at the FEM output. / Das Result enthält den
        // Spannungswert Klemme 31ELV am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_31ELV_WERT", STAT_SPANNUNG_KLEMME_31ELV_WERT, "\"V\"");

    float STAT_SPANNUNG_KLEMME_30ELV_WERT = (RXBUF_UINT(26)/1000.0f);
        // The result contains the voltage value at terminal 30ELV at the FEM output. / Das Result enthält den
        // Spannungswert Klemme 30ELV am FEM Ausgang.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_KLEMME_30ELV_WERT", STAT_SPANNUNG_KLEMME_30ELV_WERT, "\"V\"");

    float STAT_SPANNUNG_INNENTEMPERATUR_WERT = (RXBUF_UINT(28)/1000.0f);
        // The result contains the voltage value at the PTC / NTC in the control unit to determine the internal
        // temperature. / Das Result enthält den Spannungswert am PTC/NTC im Steuergerät zur Ermittlung der
        // Innentemperatur.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMMEN", "STAT_SPANNUNG_INNENTEMPERATUR_WERT", STAT_SPANNUNG_INNENTEMPERATUR_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KEY_VALID_NR_AKTUELL: {                                         // 0xDAB4
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KEY_VALID_NR_AKTUELL", 1);
        break;
    }

    unsigned char STAT_KEY_VAILD_NR_AKTUELL = (RXBUF_UCHAR(0));
        // The result contains the number (according to the transponder table) of the currently valid key. Values: 0-19
        // key number, 255 currently not a valid key. / Das Result enthält die Nummer (gemäß Transpondertabelle) des
        // aktuell gültigen Schlüssel. Werte: 0-19 Schlüsselnummer, 255 momentan kein gültiger Schlüssel.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KEY_VALID_NR_AKTUELL", "STAT_KEY_VAILD_NR_AKTUELL", STAT_KEY_VAILD_NR_AKTUELL, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_CA_TAGE_ER_LEITUNG: {                                           // 0xDAB5
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_CA_TAGE_ER_LEITUNG", 4);
        break;
    }

    unsigned char STAT_TAGE_ER_FT = (RXBUF_UCHAR(0));
        // The result contains the status of the line between the ZSG and the CA button / TAGE in the driver's door.
        // Notes: - Assignment via table TAB_CAS_CA_TAGE_ER_LEITUNG. / Das Result enthält den Status der Leitung zwischen
        // ZSG und CA-Taster/TAGE in der  Fahrertür. Hinweise: - Zuordnung über Tabelle TAB_CAS_CA_TAGE_ER_LEITUNG.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "CA_TAGE_ER_LEITUNG", "STAT_TAGE_ER_FT", STAT_TAGE_ER_FT, "\"0-n\"");

    unsigned char STAT_TAGE_ER_BFT = (RXBUF_UCHAR(1));
        // The result contains the status of the line between the ZSG and the CA button / TAGE in the passenger door.
        // Notes: - Allocation via table TAB_CAS_CA_TAGE_ER_LEITUNG. / Das Result enthält den Status der Leitung zwischen
        // ZSG und CA-Taster/TAGE in der  Beifahrertür.. Hinweise: - Zuordnung über Tabelle TAB_CAS_CA_TAGE_ER_LEITUNG.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "CA_TAGE_ER_LEITUNG", "STAT_TAGE_ER_BFT", STAT_TAGE_ER_BFT, "\"0-n\"");

    unsigned char STAT_TAGE_ER_FTH = (RXBUF_UCHAR(2));
        // The result contains the status of the line between the ZSG and the CA button / TAGE in the rear driver's door.
        // Notes: - Assignment via table TAB_CAS_CA_TAGE_ER_LEITUNG. / Das Result enthält den Status der Leitung zwischen
        // ZSG und CA-Taster/TAGE in der  Fahrertür hinten. Hinweise: - Zuordnung über Tabelle
        // TAB_CAS_CA_TAGE_ER_LEITUNG.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "CA_TAGE_ER_LEITUNG", "STAT_TAGE_ER_FTH", STAT_TAGE_ER_FTH, "\"0-n\"");

    unsigned char STAT_TAGE_ER_BFTH = (RXBUF_UCHAR(3));
        // The result contains the status of the line between the ZSG and the CA button / TAGE in the rear passenger
        // door. Notes: - Assignment via table TAB_CAS_CA_TAGE_ER_LEITUNG. / Das Result enthält den Status der Leitung
        // zwischen ZSG und CA-Taster/TAGE in der  Beifahrertür hinten. Hinweise: - Zuordnung über Tabelle
        // TAB_CAS_CA_TAGE_ER_LEITUNG.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "CA_TAGE_ER_LEITUNG", "STAT_TAGE_ER_BFTH", STAT_TAGE_ER_BFTH, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_START_STOP_TASTER: {                                            // 0xDAB6
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_START_STOP_TASTER", 1);
        break;
    }

    unsigned char STAT_TASTER_SST_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the current logical state of the start / stop button. / Das Result enthält den aktuellen
        // logischen Zustand des Start-Stopp-Tasters.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "START_STOP_TASTER", "STAT_TASTER_SST_AKTIV", STAT_TASTER_SST_AKTIV, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_KLEMMEN_VERHINDERER: {                                   // 0xDABA
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_KLEMMEN_VERHINDERER", 3);
        break;
    }

    unsigned char STAT_KL15_EIN_VERHINDERER = (RXBUF_UCHAR(0));
        // The result contains the cause that currently prevents the KL15 from being switched on if a terminal change to
        // KL15 is requested via the StartStop button (SST) or via diagnosis. Notes: - Allocation takes place in
        // accordance with table 0 = No obstacle present 1 = Current key not valid 14 = ELV locked / Das Result enthält
        // die Ursache, die momentan ein Einschalten der KL15 verhindert, wenn eine Klemmenänderung zu KL15 über
        // StartStop-Taster (SST) oder über Diagnose angefordert würde. Hinweise: - Zuordnung erfolgt gemäß Tabelle 0 =
        // Kein Hinderungsgrund vorliegend  1 = Aktueller Schlüssel nicht gültig 14 = ELV verriegelt  
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KLEMMEN_VERHINDERER", "STAT_KL15_EIN_VERHINDERER", STAT_KL15_EIN_VERHINDERER, "\"0-n\"");

    unsigned char STAT_KL15_AUS_VERHINDERER = (RXBUF_UCHAR(1));
        // The result contains the cause that currently prevents the KL15 from switching off if a terminal change is
        // requested via the StartStop button (SST) or via diagnosis. Notes: - Allocation takes place according to table
        // 0 = No reason for hindrance present 3 = Speed of travel detected 4 = Speed signal invalid / Das Result enthält
        // die Ursache, die momentan ein Ausschalten der KL15 verhindert, wenn eine Klemmenänderung über StartStop-Taster
        // (SST) oder über Diagnose angefordert würde. Hinweise: - Zuordnung erfolgt gemäß Tabelle 0 = Kein
        // Hinderungsgrund vorliegend  3 = Geschwindigkeit Fahrt erkannt  4 = Geschwindigkeitsignal ungültig 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KLEMMEN_VERHINDERER", "STAT_KL15_AUS_VERHINDERER", STAT_KL15_AUS_VERHINDERER, "\"0-n\"");

    unsigned char STAT_KL50_EIN_VERHINDERER = (RXBUF_UCHAR(2));
        // The result contains the cause that currently prevents activation of the KL50 if a terminal change is requested
        // via the StartStop button (SST), Telestart hand transmitter or via diagnosis. Notes: - Allocation takes place
        // according to table 0 = No obstacle present 1 = No valid key 5 = Brake not pressed 6 = Brake implausible 7 =
        // Clutch not pressed 8 = Clutch implausible 9 = Abort DME / DDE (engine running detected / no engine start
        // allowed via CAN ) 10 = frictional connection detected (P or N not inserted) 13 = assembly mode KL50 14 = ELV
        // locked / Das Result enthält die Ursache, die momentan ein Ansteuern der KL50 verhindert, wenn eine
        // Klemmenänderung über StartStop-Taster (SST), Telestarthandsender oder über Diagnose angefordert würde.
        // Hinweise: - Zuordnung erfolgt gemäß Tabelle 0 = Kein Hinderungsgrund vorliegend  1 = Kein gültiger Schlüssel 
        // 5 = Bremse nicht gedrückt  6 = Bremse unplausibel 7 = Kupplung nicht gedrückt  8 = Kupplung unplausibel  9 =
        // Abbruch DME/DDE (Motorlauf erkannt/Kein Motorstart erlaubt über CAN) 10 = Kraftschluss erkannt (P oder N nicht
        // eingelegt) 13 = Montagmodus KL50  14 = ELV verriegelt  
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KLEMMEN_VERHINDERER", "STAT_KL50_EIN_VERHINDERER", STAT_KL50_EIN_VERHINDERER, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BUS_IN_DATUM_ZEIT: {                                            // 0xDABB
    if (datalen < 12) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BUS_IN_DATUM_ZEIT", 12);
        break;
    }

    unsigned char STAT_BUS_IN_ZEIT_STUNDEN_WERT = (RXBUF_UCHAR(0));
        // Hours: 0-23; 253 corresponds to -; 254 No answer; 255 signal invalid / Stunden: 0 - 23; 253 entspricht --; 254
        // Keine Angabe; 255 Signal ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DATUM_ZEIT", "STAT_BUS_IN_ZEIT_STUNDEN_WERT", STAT_BUS_IN_ZEIT_STUNDEN_WERT, "");

    unsigned char STAT_BUS_IN_ZEIT_MINUTEN_WERT = (RXBUF_UCHAR(1));
        // Minutes: 0 - 59; 253 corresponds to -; 254 No answer; 255 signal invalid / Minuten: 0 - 59; 253 entspricht --;
        // 254 Keine Angabe; 255 Signal ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DATUM_ZEIT", "STAT_BUS_IN_ZEIT_MINUTEN_WERT", STAT_BUS_IN_ZEIT_MINUTEN_WERT, "");

    unsigned char STAT_BUS_IN_DATUM_TAG_WERT = (RXBUF_UCHAR(2));
        // Day: 0 - 31; 255 signal invalid / Tag: 0 - 31; 255 Signal ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DATUM_ZEIT", "STAT_BUS_IN_DATUM_TAG_WERT", STAT_BUS_IN_DATUM_TAG_WERT, "");

    unsigned char STAT_BUS_IN_DATUM_MONAT_WERT = (RXBUF_UCHAR(3));
        // Month: 1 - 12; 255 signal invalid / Monat: 1 - 12; 255 Signal ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DATUM_ZEIT", "STAT_BUS_IN_DATUM_MONAT_WERT", STAT_BUS_IN_DATUM_MONAT_WERT, "");

    unsigned short STAT_BUS_IN_DATUM_JAHR_WERT = (RXBUF_UINT(4));
        // Year: 2000 - 9999; 65535 Signal invalid / Jahr: 2000 - 9999; 65535 Signal ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "BUS_IN_DATUM_ZEIT", "STAT_BUS_IN_DATUM_JAHR_WERT", STAT_BUS_IN_DATUM_JAHR_WERT, "");

    unsigned long STAT_BUS_IN_ZEIT_RELATIV_WERT = (RXBUF_UINT32(6));
        // Current relative time in seconds since 01/01/2000, seconds: 0 - 4.2 billion, 4294967295 invalid / Aktuelle
        // Relative Zeit in Sekunden seit 01.01.2000, Sekunden: 0 - 4,2 Millarden, 4294967295 ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "BUS_IN_DATUM_ZEIT", "STAT_BUS_IN_ZEIT_RELATIV_WERT", STAT_BUS_IN_ZEIT_RELATIV_WERT, "\"s\"");

    unsigned short STAT_BUS_IN_ZEIT_TAGE_RELATIV_WERT = (RXBUF_UINT(10));
        // Current relative time in days since 01.01.2000; Days: 1 corresponds to 01/01/2000, 65535 corresponds to
        // invalid. / Aktuelle Relative Zeit in Tagen seit 01.01.2000; Tage: 1 entspricht 01.01.2000, 65535 entspricht
        // ungültig.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "BUS_IN_DATUM_ZEIT", "STAT_BUS_IN_ZEIT_TAGE_RELATIV_WERT", STAT_BUS_IN_ZEIT_TAGE_RELATIV_WERT, "\"d\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BUS_IN_DME1: {                                                  // 0xDABC
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BUS_IN_DME1", 7);
        break;
    }

    unsigned char STAT_BUS_IN_GANG = (RXBUF_UCHAR(0));
        // The result contains the current value for the gear (received via CAN). Notes: - The value is determined from
        // the CAN signal ST_GRSEL_DRV. - Allocation takes place according to table TAB_CAS_GANG. / Das Result enthält
        // den aktuellen Wert für den Gang (über CAN empfangen). Hinweise:  - Der Wert wird aus CAN-Signal ST_GRSEL_DRV
        // ermittelt. - Zuordnung erfolgt gemäß Tabelle TAB_CAS_GANG.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DME1", "STAT_BUS_IN_GANG", STAT_BUS_IN_GANG, "\"0-n\"");

    unsigned char STAT_BUS_IN_MOTOR_LAEUFT = (RXBUF_UCHAR(1));
        // The result contains the current value (received via CAN) for engine running. Notes: - The value is determined
        // from bit 0 & 1 of the CAN signal ST_DRV_VEH. - Allocation takes place according to table TAB_CAS_MOTOR_STATUS
        // / Das Result enthält den aktuellen Wert (über CAN empfangen) für Motor läuft. Hinweise: - Der Wert wird
        // ermittelt aus Bit 0 & 1 des CAN-Signals ST_DRV_VEH. - Zuordnung erfolgt gemäß Tabelle TAB_CAS_MOTOR_STATUS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DME1", "STAT_BUS_IN_MOTOR_LAEUFT", STAT_BUS_IN_MOTOR_LAEUFT, "\"0-n\"");

    unsigned char STAT_BUS_IN_MOTOR_FREIGABE = (RXBUF_UCHAR(2));
        // The result contains the current value (received via CAN) for the motor enable. Note: - The value is determined
        // from the CAN signal RLS_ENGSTA. - Allocation takes place according to table TAB_CAS_MOTORSTART_FREIGABE / Das
        // Result enthält den aktuellen Wert (über CAN empfangen) für die Motor Freigabe. Hinweis: - Der Wert wird
        // ermittelt aus CAN-Signal RLS_ENGSTA. - Zuordnung erfolgt gemäß Tabelle TAB_CAS_MOTORSTART_FREIGABE
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DME1", "STAT_BUS_IN_MOTOR_FREIGABE", STAT_BUS_IN_MOTOR_FREIGABE, "\"0-n\"");

    unsigned char STAT_BUS_IN_ANLASSER_SPERRE = (RXBUF_UCHAR(3));
        // The result contains the current value (received via CAN) for the starter lock. Note: - The value is determined
        // from the CAN signal ST_ILK_STRT_DRV. - Allocation takes place according to table TAB_CAS_MOTOR_ANLASSERSPERRE
        // / Das Result enthält den aktuellen Wert (über CAN empfangen) für die Anlassersperre. Hinweis: - Der Wert wird
        // ermittelt aus CAN-Signal ST_ILK_STRT_DRV. - Zuordnung erfolgt gemäß Tabelle TAB_CAS_MOTOR_ANLASSERSPERRE
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DME1", "STAT_BUS_IN_ANLASSER_SPERRE", STAT_BUS_IN_ANLASSER_SPERRE, "\"0-n\"");

    unsigned char STAT_BUS_IN_KUPPLUNG = (RXBUF_UCHAR(4));
        // The result contains the current value (received via CAN) for the clutch. Notes: - The value is determined from
        // the CAN signal ST_SW_CLT_DRV. - Allocation takes place according to table TAB_CAS_DIGITAL_EINGANG. Only the
        // values 0, 1 and 255 are returned. / Das Result enthält den aktuellen Wert (über CAN empfangen) für die
        // Kupplung. Hinweise: - Der Wert wird ermittelt aus CAN-Signal ST_SW_CLT_DRV. - Zuordnung erfolgt gemäß Tabelle
        // TAB_CAS_DIGITAL_EINGANG. Nur die Werte 0, 1 und 255 werden zurückgeliefert.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DME1", "STAT_BUS_IN_KUPPLUNG", STAT_BUS_IN_KUPPLUNG, "\"0-n\"");

    float STAT_BUS_IN_DREHZAHL_WERT = (RXBUF_UINT(5)/4.0f);
        // The result contains the current value (received via CAN) for the speed. Notes: - The value is determined from
        // the CAN signal AVL_RPM_ENG_CRSH. - The SGBD divides the value from the telegram by 4, since the
        // AVL_RPM_ENG_CRSH signal is accurate to a quarter of a turn. / Das Result enthält den aktuellen Wert (über CAN
        // empfangen) für die Drehzahl. Hinweise: - Der Wert wird ermittelt aus CAN-Signal AVL_RPM_ENG_CRSH. - Der Wert
        // aus dem Telegramm wird von der SGBD durch 4 geteilt, da das Signal AVL_RPM_ENG_CRSH Viertel-Umdrehungs-genau
        // ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "BUS_IN_DME1", "STAT_BUS_IN_DREHZAHL_WERT", STAT_BUS_IN_DREHZAHL_WERT, "\"1/min\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BUS_IN_DSC: {                                                   // 0xDABD
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BUS_IN_DSC", 4);
        break;
    }

    float STAT_BUS_IN_GESCHW_WERT = (RXBUF_UINT(0)/64.0f);
        // The result contains the current value (received via CAN) for the speed. Notes: - The value is determined from
        // the signal V_VEH_COG. - Value range 0-350, Invalid 1023 - The raw value is divided by 64 by the SGBD, since
        // the V_VEH_COG signal is accurate to 64. / Das Result enthält den aktuellen Wert (über CAN empfangen) für die
        // Geschwindigkeit. Hinweise: - Der Wert wird ermittelt aus dem Signal V_VEH_COG. - Wertebereich 0-350, Ungültig
        // 1023 - Der Rohwert wird von der SGBD durch 64 geteilt, da das Signal V_VEH_COG 64-tel-genau ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "BUS_IN_DSC", "STAT_BUS_IN_GESCHW_WERT", STAT_BUS_IN_GESCHW_WERT, "\"km/h\"");

    unsigned char STAT_BUS_IN_GESCHW_STATUS = (RXBUF_UCHAR(2));
        // The result contains the current value (received via CAN) for the speed as status. Notes: - Allocation takes
        // place according to table TAB_CAS_GESCHW_STATUS - The value is determined from the signal DVCO_VEH. / Das
        // Result enthält den aktuellen Wert (über CAN empfangen) für die Geschwindigkeit als Status Hinweise: -
        // Zuordnung erfolgt gemäß Tabelle TAB_CAS_GESCHW_STATUS - Der Wert wird ermittelt aus dem Signal DVCO_VEH.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DSC", "STAT_BUS_IN_GESCHW_STATUS", STAT_BUS_IN_GESCHW_STATUS, "\"0-n\"");

    unsigned char STAT_BUS_IN_BREMSPEDAL = (RXBUF_UCHAR(3));
        // The result contains the current value (received via CAN) for the position of the brake pedal. Notes: - CAN
        // signal Status_Bremsung_Fahrer (ST_BRG_DV), evaluation of the bit coding Activation_Bremssystem_Fahrer + total
        // signal invalid must take place in the CAS. - Allocation takes place according to table TAB_CAS_DIGITAL_EINGANG
        // / Das Result enthält den aktuellen Wert (über CAN empfangen) für die Stellung des Bremspedals. Hinweise: -
        // CAN-Signal Status_Bremsung_Fahrer (ST_BRG_DV), Auswertung der Bit-Kodierung Betätigung_Bremssystem_Fahrer +
        // Gesamtsignal ungültig muss im CAS erfolgen. - Zuordnung erfolgt gemäß Tabelle TAB_CAS_DIGITAL_EINGANG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_DSC", "STAT_BUS_IN_BREMSPEDAL", STAT_BUS_IN_BREMSPEDAL, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BUS_IN_FH: {                                                    // 0xDABF
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BUS_IN_FH", 4);
        break;
    }

    unsigned char STAT_BUS_IN_FH_FT = (RXBUF_UCHAR(0));
        // CAN signal for the driver's door window regulator status. Notes: - The content comes from the CAN signal
        // ST_PO_WRG_DRD. - Allocation takes place according to table TAB_CAS_FH_STATUS. / CAN-Signal Status Fensterheber
        // Fahrertür. Hinweise:  - Inhalt stammt aus CAN-Signal ST_PO_WRG_DRD. - Zuordnung erfolgt gemäß Tabelle
        // TAB_CAS_FH_STATUS.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_FH", "STAT_BUS_IN_FH_FT", STAT_BUS_IN_FH_FT, "\"0-n\"");

    unsigned char STAT_BUS_IN_FH_BFT = (RXBUF_UCHAR(1));
        // CAN signal for the status of the passenger door window regulator. Notes: - Content from the CAN signal
        // ST_PO_WRG_PSD. - Allocation takes place according to table TAB_CAS_FH_STATUS. / CAN-Signal Status Fensterheber
        // Beifahrertür. Hinweise:  - Inhalt aus dem CAN-Signal ST_PO_WRG_PSD. - Zuordnung erfolgt gemäß Tabelle
        // TAB_CAS_FH_STATUS.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_FH", "STAT_BUS_IN_FH_BFT", STAT_BUS_IN_FH_BFT, "\"0-n\"");

    unsigned char STAT_BUS_IN_FH_FTH = (RXBUF_UCHAR(2));
        // CAN signal for the status of the rear window regulator in the driver's door. Notes: - Content from the CAN
        // signal ST_PO_WRG_DVDR. - Allocation takes place according to table TAB_CAS_FH_STATUS. / CAN-Signal Status
        // Fensterheber Fahrertür hinten. Hinweise:  - Inhalt aus dem CAN-Signal ST_PO_WRG_DVDR. - Zuordnung erfolgt
        // gemäß Tabelle TAB_CAS_FH_STATUS.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_FH", "STAT_BUS_IN_FH_FTH", STAT_BUS_IN_FH_FTH, "\"0-n\"");

    unsigned char STAT_BUS_IN_FH_BFTH = (RXBUF_UCHAR(3));
        // CAN signal for the status of the window lifter, rear passenger door. Notes: - Content from the CAN signal
        // ST_PO_WRG_PSDR. - Allocation takes place according to table TAB_CAS_FH_STATUS. / CAN-Signal Status
        // Fensterheber Beifahrertür hinten. Hinweise: - Inhalt aus dem CAN-Signal ST_PO_WRG_PSDR. - Zuordnung erfolgt
        // gemäß Tabelle TAB_CAS_FH_STATUS.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BUS_IN_FH", "STAT_BUS_IN_FH_BFTH", STAT_BUS_IN_FH_BFTH, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_CA_TAGE_STATUS: {                                               // 0xDACA
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_CA_TAGE_STATUS", 4);
        break;
    }

    unsigned char STAT_TAGE_FT = (RXBUF_UCHAR(0));
        // The result contains the status of the CA button or the TAGE driver's door. Notes: - The assignment is made via
        // table TAB_CAS_CA_TAGE_STATUS / Das Result enthält den Status des CA-Tasters oder der TAGE Fahrertüre..
        // Hinweise: - Die Zuordnung erfolgt über Tabelle TAB_CAS_CA_TAGE_STATUS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "CA_TAGE_STATUS", "STAT_TAGE_FT", STAT_TAGE_FT, "\"0-n\"");

    unsigned char STAT_TAGE_BFT = (RXBUF_UCHAR(1));
        // The result contains the status of the CA button or the TAGE passenger door. Notes: - The assignment is made
        // via table TAB_CAS_CA_TAGE_STATUS / Das Result enthält den Status des CA-Tasters oder der TAGE Beifahrertüre..
        // Hinweise: - Die Zuordnung erfolgt über Tabelle TAB_CAS_CA_TAGE_STATUS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "CA_TAGE_STATUS", "STAT_TAGE_BFT", STAT_TAGE_BFT, "\"0-n\"");

    unsigned char STAT_TAGE_FTH = (RXBUF_UCHAR(2));
        // The result contains the status of the CA button or the TAGE back door on the driver's side. Notes: - The
        // assignment is made via table TAB_CAS_CA_TAGE_STATUS / Das Result enthält den Status des CA-Tasters oder der
        // TAGE Hintertüre Fahrerseite.. Hinweise: - Die Zuordnung erfolgt über Tabelle TAB_CAS_CA_TAGE_STATUS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "CA_TAGE_STATUS", "STAT_TAGE_FTH", STAT_TAGE_FTH, "\"0-n\"");

    unsigned char STAT_TAGE_BFTH = (RXBUF_UCHAR(3));
        // The result contains the status of the CA button or the TAGE back door on the passenger side. Notes: - The
        // assignment is made via table TAB_CAS_CA_TAGE_STATUS / Das Result enthält den Status des CA-Tasters oder der
        // TAGE Hintertüre Beifahrerseite. Hinweise: - Die Zuordnung erfolgt über Tabelle TAB_CAS_CA_TAGE_STATUS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "CA_TAGE_STATUS", "STAT_TAGE_BFTH", STAT_TAGE_BFTH, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SPANNUNG_KLEMME_30L1: {                                         // 0xDAD6
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SPANNUNG_KLEMME_30L1", 2);
        break;
    }

    float STAT_SPANNUNG_KLEMME_30L1_WERT = (RXBUF_SINT(0)/10.0f);
        // Voltage value at the control unit at terminal 30L (to one decimal place) Notes: - The SGBD divides the value
        // supplied by the control unit by 10 (one decimal place). / Spannungswert am Steuergerät an Klemme 30L (auf eine
        // Nachkommastelle genau) Hinweise: - Der vom Steuergerät gelieferte Wert wird von der SGBD durch 10 geteilt
        // (eine Nachkommastelle).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMME_30L1", "STAT_SPANNUNG_KLEMME_30L1_WERT", STAT_SPANNUNG_KLEMME_30L1_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_SPANNUNG_KLEMME_30L2: {                                         // 0xDAD7
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_SPANNUNG_KLEMME_30L2", 2);
        break;
    }

    float STAT_SPANNUNG_KLEMME_30L2_WERT = (RXBUF_SINT(0)/10.0f);
        // Voltage value at the control unit at terminal 30L (to one decimal place) Notes: - The SGBD divides the value
        // supplied by the control unit by 10 (one decimal place). / Spannungswert am Steuergerät an Klemme 30L (auf eine
        // Nachkommastelle genau) Hinweise: - Der vom Steuergerät gelieferte Wert wird von der SGBD durch 10 geteilt
        // (eine Nachkommastelle).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "SPANNUNG_KLEMME_30L2", "STAT_SPANNUNG_KLEMME_30L2_WERT", STAT_SPANNUNG_KLEMME_30L2_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG: {                      // 0xDB12
    if (datalen < 5) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG", 5);
        break;
    }

    unsigned char STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_15N1_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the activation status of the short-circuit shutdown of the HW driver KL15N1. / Das Result
        // enthält den Aktivierungsstatus der Kurzschlussabschaltung des HW-Treiber KL15N1.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG", "STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_15N1_AKTIV", STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_15N1_AKTIV, "\"0-n\"");

    unsigned char STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_15N2_AKTIV = (RXBUF_UCHAR(1));
        // The result contains the activation status of the short-circuit shutdown of the HW driver KL15N2. / Das Result
        // enthält den Aktivierungsstatus der Kurzschlussabschaltung des HW-Treiber KL15N2.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG", "STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_15N2_AKTIV", STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_15N2_AKTIV, "\"0-n\"");

    unsigned char STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL30BACSM_AKTIV = (RXBUF_UCHAR(2));
        // The result contains the activation status of the short-circuit shutdown of the HW driver KL30B-ACSM. / Das
        // Result enthält den Aktivierungsstatus der Kurzschlussabschaltung des HW-Treiber KL30B-ACSM.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG", "STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL30BACSM_AKTIV", STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL30BACSM_AKTIV, "\"0-n\"");

    unsigned char STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL301_AKTIV = (RXBUF_UCHAR(3));
        // The result contains the activation status of the short-circuit shutdown of the KL30B1 HW driver. / Das Result
        // enthält den Aktivierungsstatus der Kurzschlussabschaltung des HW-Treiber KL30B1.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG", "STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL301_AKTIV", STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL301_AKTIV, "\"0-n\"");

    unsigned char STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL302_AKTIV = (RXBUF_UCHAR(4));
        // The result contains the activation status of the short-circuit shutdown of the KL30B2 HW driver. / Das Result
        // enthält den Aktivierungsstatus der Kurzschlussabschaltung des HW-Treiber KL30B2.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG", "STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL302_AKTIV", STAT_KURZSCHLUSSABSCHALTUNG_TREIBER_KL302_AKTIV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HECKKLAPPENSENSOR: {                                            // 0xDB16
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HECKKLAPPENSENSOR", 1);
        break;
    }

    unsigned char STAT_HECKKLAPPENSENSOR = (RXBUF_UCHAR(0));
        // Current status of the tailgate sensor / Aktueller Zustand des Heckklappensensors
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HECKKLAPPENSENSOR", "STAT_HECKKLAPPENSENSOR", STAT_HECKKLAPPENSENSOR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_NACHLAUFZEIT_KLEMME_15N: {                                      // 0xDB2D
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_NACHLAUFZEIT_KLEMME_15N", 2);
        break;
    }

    unsigned short STAT_NACHLAUFZEIT_KLEMME_15N_WERT = (RXBUF_UINT(0));
        // The result contains the follow-up time of terminal 15N in seconds. / Das Result enthält die Nachlaufzeit der
        // Klemme 15N in Sekunden.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "NACHLAUFZEIT_KLEMME_15N", "STAT_NACHLAUFZEIT_KLEMME_15N_WERT", STAT_NACHLAUFZEIT_KLEMME_15N_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_NACHLAUFZEIT_KLEMME_30B: {                                      // 0xDB2E
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_NACHLAUFZEIT_KLEMME_30B", 2);
        break;
    }

    unsigned short STAT_NACHLAUFZEIT_KLEMME_30B_WERT = (RXBUF_UINT(0));
        // The result contains the delay time of terminal 30B in seconds. / Das Result enthält die Nachlaufzeit der
        // Klemme 30B in Sekunden.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "NACHLAUFZEIT_KLEMME_30B", "STAT_NACHLAUFZEIT_KLEMME_30B_WERT", STAT_NACHLAUFZEIT_KLEMME_30B_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_KLEMMEN: {                                               // 0xDC56
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_KLEMMEN", 1);
        break;
    }

    unsigned char STAT_KLEMMENSTATUS = (RXBUF_UCHAR(0));
        // The result contains the status of the terminals in the CAS control unit. Notes: - Allocation takes place
        // according to table TAB_CAS_KLEMMENSTATUS. / Das Result enthält den Status der Klemmen im CAS-Steuergerät.
        // Hinweise: - Zuordnung erfolgt gemäß Tabelle TAB_CAS_KLEMMENSTATUS.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KLEMMEN", "STAT_KLEMMENSTATUS", STAT_KLEMMENSTATUS, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_STATUS_KL15_ABSCHALTUNG: {                                      // 0xDC57
    if (datalen < 23) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_STATUS_KL15_ABSCHALTUNG", 23);
        break;
    }

    unsigned char STAT_CODIERUNG_KL15_ABSCHALTUNG = (RXBUF_UCHAR(0));
        // The result indicates whether shutdown is enabled by coding. Notes: - 0 = not active, 1 = active / Das Result
        // gibt an, ob Abschaltung per Codierung freigeschaltet ist. Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_CODIERUNG_KL15_ABSCHALTUNG", STAT_CODIERUNG_KL15_ABSCHALTUNG, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_OBDKOMMUNIKATION_AKTIV = (RXBUF_UCHAR(1));
        // The result indicates whether the switch-off preventer OBD communication (OBD-relevant diagnostic communication
        // via D-CAN) is currently active. Notes: - 0 = not active, 1 = active / Das Result gibt an, ob der
        // Abschaltverhinderer OBD-Kommunikation (OBD-relevante Diagnosekommunikation über D-CAN) gerade aktiv ist.
        // Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_OBDKOMMUNIKATION_AKTIV", STAT_ABSCHALTVERHINDERER_OBDKOMMUNIKATION_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_BREMSE_AKTIV = (RXBUF_UCHAR(2));
        // The result indicates whether the switch-off preventer brake pedal is currently active. Notes: - 0 = not
        // active, 1 = active / Das Result gibt an, ob der Abschaltverhinderer Bremspedal betätigt ist gerade aktiv.
        // Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_BREMSE_AKTIV", STAT_ABSCHALTVERHINDERER_BREMSE_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_MOTORLAUF_AKTIV = (RXBUF_UCHAR(3));
        // The result indicates whether the shutdown preventer motor run is currently active. Note: - 0 = not active, 1 =
        // active / Das Result gibt an, ob der Abschaltverhinderer Motorlauf gerade aktiv ist. Hinweis: - 0=nicht aktiv,
        // 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_MOTORLAUF_AKTIV", STAT_ABSCHALTVERHINDERER_MOTORLAUF_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_KUPPLUNG_AKTIV = (RXBUF_UCHAR(4));
        // The result indicates whether the switch-off preventer clutch pedal is currently active. Notes: - 0 = not
        // active, 1 = active / Das Result gibt an, ob der Abschaltverhinderer Kupplungspedal betätigt gerade aktiv ist.
        // Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_KUPPLUNG_AKTIV", STAT_ABSCHALTVERHINDERER_KUPPLUNG_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_ENERGIESPARMODE_AKTIV = (RXBUF_UCHAR(5));
        // The result indicates whether the switch-off preventer energy mode active (FETRAFLA) is currently active. Note:
        // The KL15 shutdown is deactivated here due to the energy manager in the FEM. / Das Result gibt an, ob der
        // Abschaltverhinderer Energiemode aktiv(FETRAFLA) gerade aktiv ist. Hinweis: Die KL15-Abschaltung ist hier
        // aufgrund des Energymanager im FEM deaktiviert.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_ENERGIESPARMODE_AKTIV", STAT_ABSCHALTVERHINDERER_ENERGIESPARMODE_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_GESCHWINDIGKEIT_AKTIV = (RXBUF_UCHAR(6));
        // The result indicates whether the speed switch-off preventer is currently active. Notes: - 0 = not active, 1 =
        // active / Das Result gibt an, ob der Abschaltverhinderer Geschwindigkeit gerade aktiv ist. Hinweise: - 0=nicht
        // aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_GESCHWINDIGKEIT_AKTIV", STAT_ABSCHALTVERHINDERER_GESCHWINDIGKEIT_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_MSA_AKTIV = (RXBUF_UCHAR(7));
        // MSA is currently (L6, L7) no switch-off preventer for the KL15. This result is only available as a lead and is
        // always filled with ¿0¿. / MSA ist aktuell (L6,L7) kein Abschaltverhinderer für die KL15. Dieses Result ist nur
        // als Vorhalt vorhanden und wird immer mit ¿0¿ befüllt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_MSA_AKTIV", STAT_ABSCHALTVERHINDERER_MSA_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_ABBLENDLICHT_AKTIV = (RXBUF_UCHAR(8));
        // The result indicates whether the switch-off preventer dipped beam is currently active. Notes: - 0 = not
        // active, 1 = active / Das Result gibt an, ob der Abschaltverhinderer Abblendlicht gerade aktiv ist. Hinweise: -
        // 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_ABBLENDLICHT_AKTIV", STAT_ABSCHALTVERHINDERER_ABBLENDLICHT_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_WAEHLHEBEL_IN_N_AKTIV = (RXBUF_UCHAR(9));
        // The result indicates whether the switch-off preventer selector lever in N is currently active (car wash
        // function). Notes: - 0 = not active, 1 = active / Das Result gibt an, ob der Abschaltverhinderer Wählhebel in N
        // gerade aktiv ist (Waschstrassen-Funktion). Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_WAEHLHEBEL_IN_N_AKTIV", STAT_ABSCHALTVERHINDERER_WAEHLHEBEL_IN_N_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_DIAGNOSE_AKTIV = (RXBUF_UCHAR(10));
        // The result indicates whether the shutdown prevention diagnosis (speed threshold set) is currently active.
        // Notes: - 0 = not active, 1 = active / Das Result gibt an, ob der Abschaltverhinderer Diagnose
        // (Geschwindigkeitsschwelle gesetzt) gerade aktiv ist. Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_DIAGNOSE_AKTIV", STAT_ABSCHALTVERHINDERER_DIAGNOSE_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_FLA_MODE = (RXBUF_UCHAR(11));
        // This result is only available as a lead and is always filled with 0. / Dieses Result ist nur als Vorhalt
        // vorhanden und wird immer mit 0 befüllt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_FLA_MODE", STAT_ABSCHALTVERHINDERER_FLA_MODE, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_AKTIV = (RXBUF_UCHAR(12));
        // The result indicates whether at least one switch-off preventer is currently active. Notes: - 0 = no switch-off
        // preventer active - 1 = at least one switch-off preventer active / Das Result gibt an, ob mindestens ein
        // Abschaltverhinderer gerade aktiv ist. Hinweise: - 0=kein Abschaltverhinderer aktiv - 1=mindestens ein
        // Abschaltverhinderer aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_AKTIV", STAT_ABSCHALTVERHINDERER_AKTIV, "\"0/1\"");

    unsigned char STAT_AUTOMATISCHE_ABSCHALTUNG_DURCHGEFUEHRT = (RXBUF_UCHAR(13));
        // The result indicates whether the last KL15 shutdown was an automatic KL15 shutdown or not. Notes: - The value
        // is set to active as soon as an autom. KL15 shutdown has been carried out. - The value is reset to not active
        // as soon as a non-automatic KL15 switch-off (e.g. via SST) has been carried out. 0 = automatic KL15 switch-off
        // was not carried out 1 = automatic KL15 switch-off was carried out / Das Result gibt an, ob die letzte
        // KL15-Abschaltung  eine automatische KL15-Abschaltung war oder nicht. Hinweise: - Der Wert wird auf aktiv
        // gesetzt, sobald eine autom. KL15-Abschaltung durchgeführt wurde. - Der Wert wird auf nicht aktiv rückgesetzt,
        // sobald eine nicht-automatische KL15-Abschaltung (z.B. per SST) durchgeführt wurde. 0 = automatische
        // KL15-Abschaltung wurde nicht durchgeführt 1 = automatische KL15-Abschaltung wurde durchgeführt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_AUTOMATISCHE_ABSCHALTUNG_DURCHGEFUEHRT", STAT_AUTOMATISCHE_ABSCHALTUNG_DURCHGEFUEHRT, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_PRAESENTATIONSMODUS_AKTIV = (RXBUF_UCHAR(14));
        // The result indicates whether the shutdown preventer presentation mode (CAS assembly mode) is currently active.
        // Notes: - 0 = not active, 1 = active / Das Result gibt an, ob der Abschaltverhinderer
        // Präsentationsmodus(CAS-Montagemodus) gerade aktiv ist. Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_PRAESENTATIONSMODUS_AKTIV", STAT_ABSCHALTVERHINDERER_PRAESENTATIONSMODUS_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_GESCHWINDIGKEIT_UNPLAUSIBEL_AKTIV = (RXBUF_UCHAR(15));
        // The result indicates whether the speed implausible switch-off preventer (CAS has received an implausible speed
        // value via both the HW input and CAN) is currently active. Notes: - 0 = not active, 1 = active / Das Result
        // gibt an, ob der Abschaltverhinderer Geschwindigkeit unplausibel (CAS hat sowohl über HW-Eingang als auch CAN
        // einen unplausiblen Geschwindigkeitswert erhalten) gerade aktiv ist. Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_GESCHWINDIGKEIT_UNPLAUSIBEL_AKTIV", STAT_ABSCHALTVERHINDERER_GESCHWINDIGKEIT_UNPLAUSIBEL_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_FREMDLADUNG_HYBRID_AKTIV = (RXBUF_UCHAR(16));
        // The result indicates whether the switch-off preventer for external charging is currently active in hybrid
        // vehicles. Notes: - 0 = not active, 1 = active / Das Result gibt an, ob der Abschaltverhinderer Fremdladung bei
        // Hybridfahrzeugen gerade aktiv ist. Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_FREMDLADUNG_HYBRID_AKTIV", STAT_ABSCHALTVERHINDERER_FREMDLADUNG_HYBRID_AKTIV, "\"0/1\"");

    unsigned char STAT_ABSCHALTVERHINDERER_GURT_FAHRER_GESTECKT_AKTIV = (RXBUF_UCHAR(17));
        // The result indicates whether the switch-off preventer seat belt driver is currently active. Notes: - 0 = no
        // shutdown performed, 1 = shutdown performed. / Das Result gibt an, ob der Abschaltverhinderer Gurt Fahrer
        // gesteckt gerade aktiv ist. Hinweise: - 0=keine Abschaltung durchgeführt, 1=Abschaltung durchgeführt.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_ABSCHALTVERHINDERER_GURT_FAHRER_GESTECKT_AKTIV", STAT_ABSCHALTVERHINDERER_GURT_FAHRER_GESTECKT_AKTIV, "\"0/1\"");

    unsigned char STAT_CODIERUNG_KL15_ABSCHALTUNG_GURT_AKTIV = (RXBUF_UCHAR(18));
        // The result indicates whether the KL15 is switched off by opening the driver's seat belt by coding. / Das
        // Result gibt an, ob Abschaltung der KL15 durch Öffnen Fahrergurt per Codierung freigeschaltet ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_CODIERUNG_KL15_ABSCHALTUNG_GURT_AKTIV", STAT_CODIERUNG_KL15_ABSCHALTUNG_GURT_AKTIV, "\"0/1\"");

    unsigned char STAT_CODIERUNG_KL15_ABSCHALTUNG_KLAPPENWECHSEL_AKTIV = (RXBUF_UCHAR(19));
        // The result indicates whether shutdown of the KL15 by opening / closing the door is enabled by coding. / Das
        // Result gibt an, ob Abschaltung der KL15 durch Tür auf/zu per Codierung freigeschaltet ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_CODIERUNG_KL15_ABSCHALTUNG_KLAPPENWECHSEL_AKTIV", STAT_CODIERUNG_KL15_ABSCHALTUNG_KLAPPENWECHSEL_AKTIV, "\"0/1\"");

    unsigned char STAT_CODIERUNG_KL15_ABSCHALTUNG_OSFG_ERREICHT_AKTIV = (RXBUF_UCHAR(20));
        // The result indicates whether shutdown of KL15 by reaching the OSFG (upper startability limit) is enabled by
        // coding. / Das Result gibt an, ob Abschaltung der KL15 durch Erreichen der OSFG (Obere Startfähigkeitsgrenze)
        // per Codierung freigeschaltet ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_CODIERUNG_KL15_ABSCHALTUNG_OSFG_ERREICHT_AKTIV", STAT_CODIERUNG_KL15_ABSCHALTUNG_OSFG_ERREICHT_AKTIV, "\"0/1\"");

    unsigned char STAT_CODIERUNG_KL15_ABSCHALTUNG_TIMEOUT_OSFG_AKTIV = (RXBUF_UCHAR(21));
        // The result indicates whether shutdown of the KL15 is enabled by coding due to OSFG with or without timeout. /
        // Das Result gibt an, ob Abschaltung der KL15 wegen OSFG mit oder ohne Timeout per Codierung freigeschaltet ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_CODIERUNG_KL15_ABSCHALTUNG_TIMEOUT_OSFG_AKTIV", STAT_CODIERUNG_KL15_ABSCHALTUNG_TIMEOUT_OSFG_AKTIV, "\"0/1\"");

    unsigned char STAT_CODIERUNG_KL15_ABSCHALTUNG_ZV_SICHERN_AKTIV = (RXBUF_UCHAR(22));
        // The result indicates whether shutdown of the KL15 is enabled by ZV Secure by coding. Notes: - 0 = not active,
        // 1 = active / Das Result gibt an, ob Abschaltung der KL15 durch ZV Sichern per Codierung freigeschaltet ist.
        // Hinweise: - 0=nicht aktiv, 1=aktiv
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "STATUS_KL15_ABSCHALTUNG", "STAT_CODIERUNG_KL15_ABSCHALTUNG_ZV_SICHERN_AKTIV", STAT_CODIERUNG_KL15_ABSCHALTUNG_ZV_SICHERN_AKTIV, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_ANSTEUERUNG_KL30F_HINTEN: {                                     // 0xDC5A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_ANSTEUERUNG_KL30F_HINTEN", 2);
        break;
    }

    unsigned char STAT_KL30F_HINTEN_AN = (RXBUF_UCHAR(0));
        // The result contains the current state of the HW output for switching on the KL30F rear. / Das Result enthält
        // den aktuellen Zustand des HW-Ausgangs zum Einschalten der KL30F hinten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ANSTEUERUNG_KL30F_HINTEN", "STAT_KL30F_HINTEN_AN", STAT_KL30F_HINTEN_AN, "\"0-n\"");

    unsigned char STAT_KL30F_HINTEN_AUS = (RXBUF_UCHAR(1));
        // The result contains the current state of the HW output for switching off the KL30F rear. / Das Result enthält
        // den aktuellen Zustand des HW-Ausgangs zum Ausschalten der KL30F hinten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "ANSTEUERUNG_KL30F_HINTEN", "STAT_KL30F_HINTEN_AUS", STAT_KL30F_HINTEN_AUS, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_BREMSLICHT_SCHALTER: {                                          // 0xDC61
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_BREMSLICHT_SCHALTER", 1);
        break;
    }

    unsigned char STAT_SCHALTER_BREMSLICHT_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the current status of the brake light switch / Das Result enthält den aktuellen Zustand
        // des Bremslichtschalters
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "BREMSLICHT_SCHALTER", "STAT_SCHALTER_BREMSLICHT_AKTIV", STAT_SCHALTER_BREMSLICHT_AKTIV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_KUPPL_PN_SCHALTER: {                                            // 0xDC63
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_KUPPL_PN_SCHALTER", 1);
        break;
    }

    unsigned char STAT_SCHALTER_KUPPL_PN_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the current status of the clutch switch (manual gearbox) or PN signal (automatic gearbox)
        // from the EGS. Notes: - Allocation takes place according to table TAB_CAS_DIGITAL_EINGANG. / Das Result enthält
        // den aktuellen Zustand des Kupplungsschalters (Manuelles Getriebe) oder PN-Signal (Automatikgetriebe) vom EGS.
        // Hinweise: - Zuordnung erfolgt gemäß Tabelle TAB_CAS_DIGITAL_EINGANG.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "KUPPL_PN_SCHALTER", "STAT_SCHALTER_KUPPL_PN_AKTIV", STAT_SCHALTER_KUPPL_PN_AKTIV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_MOTORHAUBE_SCHALTER: {                                          // 0xDC65
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_MOTORHAUBE_SCHALTER", 1);
        break;
    }

    unsigned char STAT_SCHALTER_MOTORHAUBE_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the current status of the engine hood contact input. Notes: - Allocation takes place
        // according to table TAB_CAS_DIGITAL_EINGANG. / Das Result enthält den aktuellen Zustand des Eingangs
        // Motorhaubenkontakt. Hinweise: - Zuordnung erfolgt gemäß Tabelle TAB_CAS_DIGITAL_EINGANG.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "MOTORHAUBE_SCHALTER", "STAT_SCHALTER_MOTORHAUBE_AKTIV", STAT_SCHALTER_MOTORHAUBE_AKTIV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HOTEL_SCHALTER: {                                               // 0xDC66
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HOTEL_SCHALTER", 1);
        break;
    }

    unsigned char STAT_SCHALTER_HOTEL_AKTIV = (RXBUF_UCHAR(0));
        // The result contains the current status of the HOTEL switch input. Note: - Allocation takes place according to
        // table TAB_CAS_DIGITAL_EINGANG. / Das Result enthält den aktuellen Zustand des Eingangs HOTEL-Schalters.
        // Hinweis: - Zuordnung erfolgt gemäß Tabelle TAB_CAS_DIGITAL_EINGANG.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "HOTEL_SCHALTER", "STAT_SCHALTER_HOTEL_AKTIV", STAT_SCHALTER_HOTEL_AKTIV, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_READHWMODIFICATIONINDEX: {                                      // 0xF152
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_READHWMODIFICATIONINDEX", 2);
        break;
    }

    unsigned char STAT_HW_MODIFICATION_INDEX_WERT = (RXBUF_UCHAR(0));
        // Index of hardware modification: FF: Not supported index / Index of hardware modification:  FF: Not supported
        // index
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "READHWMODIFICATIONINDEX", "STAT_HW_MODIFICATION_INDEX_WERT", STAT_HW_MODIFICATION_INDEX_WERT, "\"HEX\"");

    unsigned char BF_22_F152_SUPPLIERINFO = (RXBUF_UCHAR(1));
        // Supplier info tab / Tab Supplierinfo
        // BF_22_F152_SUPPLIERINFO is a BITFIELD of size unsigned char.  We don't yet generate definitions for each bit, we treat as the host data type
            // STAT_HWMODEL: Mask: 0xC0 - hardware model
            // STAT_SUPPLIERINFOFIELD: Mask: 0x3F - supplierInfo
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "BDC", "READHWMODIFICATIONINDEX", "BF_22_F152_SUPPLIERINFO", (unsigned long)BF_22_F152_SUPPLIERINFO, "\"Bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_LWR_STATISTIK: {                                                // 0x2302
    if (datalen < 60) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_LWR_STATISTIK", 60);
        break;
    }

    unsigned long STAT_BETRIEBSMINUTEN_AL_AKTIV_WERT = (RXBUF_UINT32(0));
        // Total system time with active low beam / Gesamtsystemzeit mit aktivem Abblendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_AL_AKTIV_WERT", STAT_BETRIEBSMINUTEN_AL_AKTIV_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_0000_WERT = (RXBUF_UINT(4));
        // Only driver + low beam / Nur Fahrer + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_0000_WERT", STAT_BETRIEBSMINUTEN_0000_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_0001_WERT = (RXBUF_UINT(6));
        // Driver with trailer + low beam / Fahrer mit Anhänger + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_0001_WERT", STAT_BETRIEBSMINUTEN_0001_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_1000_WERT = (RXBUF_UINT(8));
        // Driver and passenger + low beam / Fahrer und Beifahrer + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_1000_WERT", STAT_BETRIEBSMINUTEN_1000_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_1001_WERT = (RXBUF_UINT(10));
        // Driver and passenger with trailer + low beam / Fahrer und Beifahrer mit Anhänger + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_1001_WERT", STAT_BETRIEBSMINUTEN_1001_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_1010_WERT = (RXBUF_UINT(12));
        // Driver, co-driver, 1 person in the rear + vent light / Fahrer, Beifahrer, 1 Pers in Fond + Ablentlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_1010_WERT", STAT_BETRIEBSMINUTEN_1010_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_1100_WERT = (RXBUF_UINT(14));
        // Driver, passenger, 2 people in the rear + low beam / Fahrer, Beifahrer, 2 Pers in Fond + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_1100_WERT", STAT_BETRIEBSMINUTEN_1100_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_1110_WERT = (RXBUF_UINT(16));
        // Driver, passenger, 3 people in the rear + low beam / Fahrer, Beifahrer, 3 Pers in Fond + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_1110_WERT", STAT_BETRIEBSMINUTEN_1110_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_1011_WERT = (RXBUF_UINT(18));
        // Driver, passenger, 1 person in the rear with trailer + low beam / Fahrer, Beifahrer, 1 Pers in Fond mit
        // Anhänger + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_1011_WERT", STAT_BETRIEBSMINUTEN_1011_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_1101_WERT = (RXBUF_UINT(20));
        // Driver, passenger, 2 people in the rear with trailer + low beam / Fahrer, Beifahrer, 2 Pers in Fond mit
        // Anhänger + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_1101_WERT", STAT_BETRIEBSMINUTEN_1101_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_1111_WERT = (RXBUF_UINT(22));
        // Driver, co-driver, 3 people in the rear with trailer + low beam / Fahrer, Beifahrer, 3 Pers in Fond mit
        // Anhänger + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_1111_WERT", STAT_BETRIEBSMINUTEN_1111_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_0010_WERT = (RXBUF_UINT(24));
        // Driver, 1 person in the rear + vent / Fahrer, 1 Pers in Fond + Ablentlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_0010_WERT", STAT_BETRIEBSMINUTEN_0010_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_0100_WERT = (RXBUF_UINT(26));
        // Driver, 2 people in the rear + low beam / Fahrer, 2 Pers in Fond + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_0100_WERT", STAT_BETRIEBSMINUTEN_0100_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_0110_WERT = (RXBUF_UINT(28));
        // Driver, 3 people in the rear + low beam / Fahrer, 3 Pers in Fond + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_0110_WERT", STAT_BETRIEBSMINUTEN_0110_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_0011_WERT = (RXBUF_UINT(30));
        // Driver, 1 person in the rear with trailer + vent / Fahrer, 1 Pers in Fond mit Anhänger + Ablentlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_0011_WERT", STAT_BETRIEBSMINUTEN_0011_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_0101_WERT = (RXBUF_UINT(32));
        // Driver, 2 people in the rear with trailer + low beam / Fahrer, 2 Pers in Fond mit Anhänger + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_0101_WERT", STAT_BETRIEBSMINUTEN_0101_WERT, "");

    unsigned short STAT_BETRIEBSMINUTEN_0111_WERT = (RXBUF_UINT(34));
        // Driver, 3 people in the rear with trailer + low beam / Fahrer, 3 Pers in Fond mit Anhänger + Ablendlicht
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_BETRIEBSMINUTEN_0111_WERT", STAT_BETRIEBSMINUTEN_0111_WERT, "");

    unsigned long STAT_ANZAHL_GES_WERT = (RXBUF_UINT32(36));
        // Total situation counter / Gesamt Situationszähler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_GES_WERT", STAT_ANZAHL_GES_WERT, "");

    unsigned short STAT_ANZAHL_GES_KL_20_WERT = (RXBUF_UINT(40));
        // No matter or under -20m / Leuchtweite egal oder unter -20m
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_GES_KL_20_WERT", STAT_ANZAHL_GES_KL_20_WERT, "");

    unsigned short STAT_ANZAHL_GES_KL_10_WERT = (RXBUF_UINT(42));
        // Lighting range between -20m and -10m (included) / Leuchtweite zwischen -20m und -10m (inklusive)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_GES_KL_10_WERT", STAT_ANZAHL_GES_KL_10_WERT, "");

    unsigned short STAT_ANZAHL_GES_GR_10_WERT = (RXBUF_UINT(44));
        // Lighting range between 10m (included) and 20m. / Leuchtweite zwischen 10m (inklusive) und 20m.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_GES_GR_10_WERT", STAT_ANZAHL_GES_GR_10_WERT, "");

    unsigned short STAT_ANZAHL_GES_GR_20_WERT = (RXBUF_UINT(46));
        // Lighting range higher or no matter than 20m. / Leuchtweite höher oder egal als 20m.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_GES_GR_20_WERT", STAT_ANZAHL_GES_GR_20_WERT, "");

    unsigned long STAT_ANZAHL_AL_WERT = (RXBUF_UINT32(48));
        // Night situation counter / Nacht Situationszähler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_AL_WERT", STAT_ANZAHL_AL_WERT, "");

    unsigned short STAT_ANZAHL_AL_KL_20_WERT = (RXBUF_UINT(52));
        // No matter or under -20m / Leuchtweite egal oder unter -20m
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_AL_KL_20_WERT", STAT_ANZAHL_AL_KL_20_WERT, "");

    unsigned short STAT_ANZAHL_AL_KL_10_WERT = (RXBUF_UINT(54));
        // Lighting range between -20m and -10m (included) / Leuchtweite zwischen -20m und -10m (inklusive)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_AL_KL_10_WERT", STAT_ANZAHL_AL_KL_10_WERT, "");

    unsigned short STAT_ANZAHL_AL_GR_10_WERT = (RXBUF_UINT(56));
        // Lighting range between 10m (included) and 20m. / Leuchtweite zwischen 10m (inklusive) und 20m.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_AL_GR_10_WERT", STAT_ANZAHL_AL_GR_10_WERT, "");

    unsigned short STAT_ANZAHL_AL_GR_20_WERT = (RXBUF_UINT(58));
        // Lighting range higher or no matter than 20m. / Leuchtweite höher oder egal als 20m.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "LWR_STATISTIK", "STAT_ANZAHL_AL_GR_20_WERT", STAT_ANZAHL_AL_GR_20_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_COUNT_NSC_MIRRORHEATING_ACTIVATIONS: {                          // 0x2303
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_COUNT_NSC_MIRRORHEATING_ACTIVATIONS", 2);
        break;
    }

    unsigned short STAT_ANZAHL_AKTIVIERUNGEN_ASP_NSC_WERT = (RXBUF_UINT(0));
        // Number of activations of ASP heating due to NSC / Anzahl der Aktivierungen der ASP-Heizung aufgrund NSC
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "COUNT_NSC_MIRRORHEATING_ACTIVATIONS", "STAT_ANZAHL_AKTIVIERUNGEN_ASP_NSC_WERT", STAT_ANZAHL_AKTIVIERUNGEN_ASP_NSC_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__LWR_DIAG: {                                                    // 0x4507
    if (datalen < 13) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__LWR_DIAG", 13);
        break;
    }

    unsigned char STAT_LWR_ENABLE = (RXBUF_UCHAR(0));
        // LWR activated / deactivated / LWR aktiviert / deaktiviert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_ENABLE", STAT_LWR_ENABLE, "\"0/1\"");

    unsigned char STAT_LWR_SPUL_ERR_STOP = (RXBUF_UCHAR(1));
        // no motor stop in case of problems with the coil test / kein Motorstop bei Problemen mit der Spulenprüfung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_SPUL_ERR_STOP", STAT_LWR_SPUL_ERR_STOP, "\"0/1\"");

    unsigned char STAT_LWR_SPUL_EINTR = (RXBUF_UCHAR(2));
        // no error entry in case of problems with the coil test / kein Fehlereintrag bei Problemen mit der Spulenprüfung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_SPUL_EINTR", STAT_LWR_SPUL_EINTR, "\"0/1\"");

    unsigned char STAT_SP_PRUEF_AKTIV = (RXBUF_UCHAR(3));
        // Coil check activated / Spulenprüfung aktiviert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_LWR_DIAG", "STAT_SP_PRUEF_AKTIV", STAT_SP_PRUEF_AKTIV, "\"0/1\"");

    unsigned char STAT_LWR_DIAGNOSE_PARAM_WERT = (RXBUF_UCHAR(4));
        // Coil test: Limit value characteristic offset / Spulenprüfung: Grenzwertkennlinie  Offset 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_DIAGNOSE_PARAM_WERT", STAT_LWR_DIAGNOSE_PARAM_WERT, "");

    unsigned char STAT_LWR_DIAGNOSE_PARAM_A_WERT = (RXBUF_UCHAR(5));
        // Coil test: Limit value characteristic slope / Spulenprüfung: Grenzwertkennlinie  Steigung 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_DIAGNOSE_PARAM_A_WERT", STAT_LWR_DIAGNOSE_PARAM_A_WERT, "");

    float STAT_LWR_CHECKGRENZE_WERT = (RXBUF_UCHAR(6)/10.0f);
        // LWR test limit / LWR-Prüfgrenze
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_CHECKGRENZE_WERT", STAT_LWR_CHECKGRENZE_WERT, "\"V\"");

    float STAT_LWR_PRUEF_SPANNUNG_WERT = (RXBUF_UCHAR(7)/10.0f);
        // Diagnosis of LWR coil test: measured value voltage / Diagnose LWR Spulenprüfung: Messwert Spannung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_PRUEF_SPANNUNG_WERT", STAT_LWR_PRUEF_SPANNUNG_WERT, "\"V\"");

    float STAT_LWR_DIAG_HEAT_TIME_WERT = (RXBUF_UCHAR(8)*512.0f);
        // Lwr-Diag-Heat-Time / Lwr-Diag-Heat-Time
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_DIAG_HEAT_TIME_WERT", STAT_LWR_DIAG_HEAT_TIME_WERT, "\"s\"");

    float STAT_LWR_DIAG_COOL_TIME_WERT = (RXBUF_UCHAR(9)*512.0f);
        // Lwr-Diag-Cool-Time / Lwr-Diag-Cool-Time
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_DIAG_COOL_TIME_WERT", STAT_LWR_DIAG_COOL_TIME_WERT, "\"s\"");

    unsigned char STAT_LWR_FRONT_LIGHT_HOT = (RXBUF_UCHAR(10));
        // Status detection headlights: hot = 1, cold = 0 / Zustandserkennung Scheinwerfer: hot = 1, cold  = 0
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_FRONT_LIGHT_HOT", STAT_LWR_FRONT_LIGHT_HOT, "\"0/1\"");

    float STAT_LWR_FRONT_LIGHT_THERMO_TIMER_WERT = (RXBUF_UINT(11)/2.0f);
        // Timer headlight thermal model / Timer Scheinwerfer Thermomodell
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "_LWR_DIAG", "STAT_LWR_FRONT_LIGHT_THERMO_TIMER_WERT", STAT_LWR_FRONT_LIGHT_THERMO_TIMER_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__LICHT_UEBERSPANNUNGSCOUNTER: {                                 // 0x4508
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__LICHT_UEBERSPANNUNGSCOUNTER", 2);
        break;
    }

    unsigned short STAT_LICHT_UESPANNUNG_COUNTER_WERT = (RXBUF_UINT(0));
        // Total number of light overvoltage counter activations / Anzahl Licht Überspannungscounter Aktivierungen
        // insgesamt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_LICHT_UEBERSPANNUNGSCOUNTER", "STAT_LICHT_UESPANNUNG_COUNTER_WERT", STAT_LICHT_UESPANNUNG_COUNTER_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER: {                           // 0x4700
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", 14);
        break;
    }

    unsigned long STAT_HECKKLAPPE_ZAEHLER_COUNT_MAX_WERT = (RXBUF_UINT32(0));
        // The result contains the current count for the short-circuits to ground detected so far. Valid values: 0 -
        // 100000 = current counter value for the restart attempts FFFFFFFFh = signal invalid / implausible / Das Result
        // enthält den aktuellen Zählerstand für die  bisher erkannten Kurzschlüsse gegen Masse. Gültige Werte: 0 -
        // 100000 = Aktueller Zählerwert für die Wiedereinschaltversuche FFFFFFFFh = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_HECKKLAPPE_ZAEHLER_COUNT_MAX_WERT", STAT_HECKKLAPPE_ZAEHLER_COUNT_MAX_WERT, "");

    unsigned char STAT_HECKKLAPPE_ZAEHLER_KS_RESTARTS_WERT = (RXBUF_UCHAR(4));
        // The result contains the number of reconnection attempts carried out so far in cycle KL15 on -> KL15 off Valid
        // values: 0 - 254 = current counter value for reclosing attempts 255 = signal invalid / implausible / Das Result
        // enthält die Anzahl der bisher durchgeführten Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus Gültige
        // Werte: 0 - 254 = Aktueller Zählerwert für die Wiedereinschaltversuche 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_HECKKLAPPE_ZAEHLER_KS_RESTARTS_WERT", STAT_HECKKLAPPE_ZAEHLER_KS_RESTARTS_WERT, "");

    unsigned char STAT_HECKKLAPPE_ZAEHLER_KS_KL15_CYCLES_WERT = (RXBUF_UCHAR(5));
        // The result contains the current number of resets that have already been carried out for short-circuit shutdown
        // by KL15. Valid values: 0 - 254 = current counter value for the number of resets already carried out for
        // short-circuit shutdown 255 = signal invalid / implausible / Das Result enthält den aktuelle Anzahl an bereits
        // durchgeführten Resets des Kurzschlussabschaltung durch KL15 ein. Gültige Werte: 0 - 254 = Aktueller Zählerwert
        // für die Anzahl an bereits durchgeführten Resets der Kurzschlussabschaltung 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_HECKKLAPPE_ZAEHLER_KS_KL15_CYCLES_WERT", STAT_HECKKLAPPE_ZAEHLER_KS_KL15_CYCLES_WERT, "");

    unsigned long STAT_HECKSCHEIBE_ZAEHLER_COUNT_MAX_WERT = (RXBUF_UINT32(6));
        // The result contains the current count for the short-circuits to ground detected so far. Valid values: ¿0 -
        // 100000 = current counter value for the restart attempts FFFFFFFFh = signal invalid / implausible / Das Result
        // enthält den aktuellen Zählerstand für die  bisher erkannten Kurzschlüsse gegen Masse. Gültige Werte: ¿  0 -
        // 100000 =Aktueller Zählerwert für die Wiedereinschaltversuche FFFFFFFFh = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_HECKSCHEIBE_ZAEHLER_COUNT_MAX_WERT", STAT_HECKSCHEIBE_ZAEHLER_COUNT_MAX_WERT, "");

    unsigned char STAT_HECKSCHEIBE_ZAEHLER_KS_RESTARTS_WERT = (RXBUF_UCHAR(10));
        // The result contains the number of reconnection attempts carried out so far in cycle KL15 on -> KL15 off Valid
        // values: 0 - 254 = current counter value for reclosing attempts 255 = signal invalid / implausible / Das Result
        // enthält die Anzahl der bisher durchgeführten Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus Gültige
        // Werte: 0 - 254 = Aktueller Zählerwert für die Wiedereinschaltversuche 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_HECKSCHEIBE_ZAEHLER_KS_RESTARTS_WERT", STAT_HECKSCHEIBE_ZAEHLER_KS_RESTARTS_WERT, "");

    unsigned char STAT_HECKSCHEIBE_ZAEHLER_KS_KL15_CYCLES_WERT = (RXBUF_UCHAR(11));
        // The result contains the current number of resets that have already been carried out for short-circuit shutdown
        // by KL15. Valid values: 0 - 254 = current counter value for the number of resets already carried out for
        // short-circuit shutdown 255 = signal invalid / implausible / Das Result enthält den aktuelle Anzahl an bereits
        // durchgeführten Resets des Kurzschlussabschaltung durch KL15 ein. Gültige Werte: 0 - 254 = Aktueller Zählerwert
        // für die Anzahl an bereits durchgeführten Resets der Kurzschlussabschaltung 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_HECKSCHEIBE_ZAEHLER_KS_KL15_CYCLES_WERT", STAT_HECKSCHEIBE_ZAEHLER_KS_KL15_CYCLES_WERT, "");

    unsigned char STAT_KODIERUNG_RESTARTS_WERT = (RXBUF_UCHAR(12));
        // The result contains the maximum value that can be coded for restart attempts in cycle KL15 on -> KL15 off ->
        // KL15 on. Valid values: 0 - 254 = maximum value for the restart attempts 255 = signal invalid / implausible /
        // Das Result enthält den codierbaren maximalen Wert an Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus ->
        // KL15 ein. Gültige Werte: 0 - 254 = maximaler Wert für die Wiedereinschaltversuche 255 = Signal ungültig /
        // unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_KODIERUNG_RESTARTS_WERT", STAT_KODIERUNG_RESTARTS_WERT, "");

    unsigned char STAT_KODIERUNG_KL15_CYCLES_WERT = (RXBUF_UCHAR(13));
        // The result contains the codable maximum value of resets of the short-circuit shutdown by KL15. Valid values: 0
        // - 254 = maximum value for the resets of the short-circuit disconnection 255 = invalid / implausible / Das
        // Result enthält den codierbaren maximalen Wert an Resets des Kurzschlussabschaltung durch KL15 ein. Gültige
        // Werte: 0 - 254 = maximaler Wert für die Resets der Kurzschlussabschaltung 255 = Ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ZV_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_KODIERUNG_KL15_CYCLES_WERT", STAT_KODIERUNG_KL15_CYCLES_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__INNENBELEUCHTUNG_DAUERAUS: {                                   // 0x4801
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__INNENBELEUCHTUNG_DAUERAUS", 1);
        break;
    }

    unsigned char STAT_INNENLICHT_IB_1_DAUER_AUS = (RXBUF_UCHAR(0));
        // STAT_INNENLICHT_IB_1_DAUER_AUS / STAT_INNENLICHT_IB_1_DAUER_AUS
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_INNENBELEUCHTUNG_DAUERAUS", "STAT_INNENLICHT_IB_1_DAUER_AUS", STAT_INNENLICHT_IB_1_DAUER_AUS, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__SARAH_STATISTIK: {                                             // 0x4910
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__SARAH_STATISTIK", 20);
        break;
    }

    float STAT_FAHRDAUER_WERT = (RXBUF_UINT(0)*10.0f/60.0f);
        // Accumulated driving time (trips <10 min are discarded) / Akkumulierte Fahrzeit (Fahrten < 10 min werden
        // verworfen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "BDC", "_SARAH_STATISTIK", "STAT_FAHRDAUER_WERT", STAT_FAHRDAUER_WERT, "\"h\"");

    unsigned short STAT_FAHRZYKLEN_WERT = (RXBUF_UINT(2));
        // Number of driving cycles> 10 min / Anzahl der Fahrzyklen > 10 min
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_SARAH_STATISTIK", "STAT_FAHRZYKLEN_WERT", STAT_FAHRZYKLEN_WERT, "\"Counts\"");

    unsigned short STAT_SARAH_TASTER_WERT = (RXBUF_UINT(4));
        // Number of SARAH key presses / Anzahl SARAH Tastendrücke
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_SARAH_STATISTIK", "STAT_SARAH_TASTER_WERT", STAT_SARAH_TASTER_WERT, "\"Counts\"");

    unsigned short STAT_SARAH_CONFIG_WERT = (RXBUF_UINT(6));
        // Number of SARAH configurations / Anzahl der SARAH Konfigurationen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_SARAH_STATISTIK", "STAT_SARAH_CONFIG_WERT", STAT_SARAH_CONFIG_WERT, "\"Counts\"");

    unsigned char STAT_SARAH_CONFIG_DIREKT_WERT = (RXBUF_UCHAR(8));
        // Number of SARAH configurations via the settings menu (last key operation more than 5 minutes ago) / Anzahl der
        // SARAH Konfigurationen über Einstellungsmenu (letzte Tastenbedienung mehr als 5 min zurückliegend)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_SARAH_STATISTIK", "STAT_SARAH_CONFIG_DIREKT_WERT", STAT_SARAH_CONFIG_DIREKT_WERT, "\"Counts\"");

    unsigned char STAT_RESERVE1_WERT = (RXBUF_UCHAR(9));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_SARAH_STATISTIK", "STAT_RESERVE1_WERT", STAT_RESERVE1_WERT, "");

    unsigned short STAT_RESERVE2_WERT = (RXBUF_UINT(10));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_SARAH_STATISTIK", "STAT_RESERVE2_WERT", STAT_RESERVE2_WERT, "");

    unsigned short STAT_RESERVE3_WERT = (RXBUF_UINT(12));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_SARAH_STATISTIK", "STAT_RESERVE3_WERT", STAT_RESERVE3_WERT, "");

    unsigned short STAT_RESERVE4_WERT = (RXBUF_UINT(14));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_SARAH_STATISTIK", "STAT_RESERVE4_WERT", STAT_RESERVE4_WERT, "");

    unsigned short STAT_RESERVE5_WERT = (RXBUF_UINT(16));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_SARAH_STATISTIK", "STAT_RESERVE5_WERT", STAT_RESERVE5_WERT, "");

    unsigned short STAT_RESERVE6_WERT = (RXBUF_UINT(18));
        // reserve / Reserve
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_SARAH_STATISTIK", "STAT_RESERVE6_WERT", STAT_RESERVE6_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__STATUS_BASESTATION: {                                          // 0x4E07
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__STATUS_BASESTATION", 6);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_IBS_WAKEUP_GRUND: {                                             // 0x4F0E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_IBS_WAKEUP_GRUND", 1);
        break;
    }

    unsigned char STAT_IBS_WAKEUP = (RXBUF_UCHAR(0));
        // The result contains the last wake-up reason from the IBS stored in the FEM. / Das Result enthält den im FEM
        // gespeicherten letzten Wakeupgrund vom IBS.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "IBS_WAKEUP_GRUND", "STAT_IBS_WAKEUP", STAT_IBS_WAKEUP, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__STATUS_DFZ_SK: {                                               // 0x5001
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__STATUS_DFZ_SK", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__STATUS_DFZ_GUELTIGKEIT: {                                      // 0x5003
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__STATUS_DFZ_GUELTIGKEIT", 1);
        break;
    }

    unsigned char STAT_DFZ_GUELTIGKEITSZAEHLER_WERT = (RXBUF_UCHAR(0));
        // The result contains the value of the DFZ validity counter. 0-255 / Das Result enthält den Wert des DFZ
        // Gültigkeitszählers. 0-255
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_STATUS_DFZ_GUELTIGKEIT", "STAT_DFZ_GUELTIGKEITSZAEHLER_WERT", STAT_DFZ_GUELTIGKEITSZAEHLER_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER: {             // 0x5020
    if (datalen < 32) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", 32);
        break;
    }

    unsigned long STAT_TREIBER_15N1_ZAEHLER_COUNT_MAX_WERT = (RXBUF_UINT32(0));
        // The result contains the current count for the previously detected short circuits to ground of the KL15N1
        // driver. Note: ¿The start value is 100000 and is decremented by 1 for each SW or HW-related short circuit
        // detected (see also request ZSG_BF_13075). If the value 0 is reached, the output is permanently deactivated and
        // cannot be reset using terminal switching or a diagnostic job. -> SG exchange necessary. 0 - 100000 = current
        // counter value for the restart attempts FFFFFFFFh = signal invalid / implausible / Das Result enthält den
        // aktuellen Zählerstand für die  bisher erkannten Kurzschlüsse gegen Masse des Treibers KL15N1. Hinweis:  ¿  
        // Startwert ist 100000 und wird pro SW- oder HW-mäßigem erkanntem Kurzschluss um 1 dekrementiert (Siehe hierzu
        // auch Anforderung ZSG_BF_13075).Wird der Wert 0 erreicht, so wird der Ausgang dauerhaft deaktiviert kann weder
        // mittels Klemmenschalten noch per Diagnosejob zurückgesetzt werden. -> SG-Tausch nötig.  0 - 100000 =Aktueller
        // Zählerwert für die Wiedereinschaltversuche FFFFFFFFh = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_15N1_ZAEHLER_COUNT_MAX_WERT", STAT_TREIBER_15N1_ZAEHLER_COUNT_MAX_WERT, "");

    unsigned char STAT_TREIBER_15N1_ZAEHLER_KS_RESTARTS_WERT = (RXBUF_UCHAR(4));
        // The result contains the number of reconnection attempts carried out so far in cycle KL15 on -> KL15 off of
        // driver KL15N1. Note: After a short circuit is detected (on the software or hardware side), the driver is
        // reactivated as often as the maximum defined by the coding. Afterwards, a terminal change KL15 off -> KL15 on
        // is necessary in order to restart the restart attempts (see requirements ZSG_BF_13096 and ZSG_BF_13097) 0 - 254
        // = current counter value for the restart attempts 255 = signal invalid / implausible / Das Result enthält die
        // Anzahl der bisher durchgeführten Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus des Treibers KL15N1. 
        // Hinweis:  Nach erkanntem Kurzschluss (SW- oder HW-seitig) wird der Treiber so oft wieder aktiviert, wie
        // maximal per Codierung definiert. Danach ist ein Klemmenwechsel KL15 aus -> KL15 ein nötig, um die
        // Wiedereinschaltversuche erneut zu starten (Siehe hierzu Anfoderungen ZSG_BF_13096 und ZSG_BF_13097) 0 - 254 =
        // Aktueller Zählerwert für die Wiedereinschaltversuche 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_15N1_ZAEHLER_KS_RESTARTS_WERT", STAT_TREIBER_15N1_ZAEHLER_KS_RESTARTS_WERT, "");

    unsigned char STAT_TREIBER_15N1_ZAEHLER_KS_KL15_CYCLES_WERT = (RXBUF_UCHAR(5));
        // The result contains the current number of already performed resets of the short-circuit shutdown by KL15 on of
        // the driver KL15N1. Note: The coding defines how often the short-circuit switch-off can be reset by switching
        // terminal 15. (See requirements ZSG_BF_13098) 0 - 254 = Current counter value for the number of resets already
        // carried out for short-circuit shutdown 255 = Signal invalid / implausible / Das Result enthält den aktuelle
        // Anzahl an bereits durchgeführten Resets des Kurzschlussabschaltung durch KL15 ein des Treibers KL15N1. 
        // Hinweis:  Per Kodierung ist festgelegt wie oft die Kurzschlussabschaltung durch Schalten der Klemme 15
        // zurückgesetzt werden kann. (Siehe hierzu Anfoderungen ZSG_BF_13098) 0 - 254 = Aktueller Zählerwert für die
        // Anzahl an bereits durchgeführten Resets der Kurzschlussabschaltung 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_15N1_ZAEHLER_KS_KL15_CYCLES_WERT", STAT_TREIBER_15N1_ZAEHLER_KS_KL15_CYCLES_WERT, "");

    unsigned long STAT_TREIBER_15N2_ZAEHLER_COUNT_MAX_WERT = (RXBUF_UINT32(6));
        // The result contains the current counter status for the previously detected short circuits to ground of the
        // KL15N2 driver. Note: The start value is 100000 and is decremented by 1 for each SW or HW-related short circuit
        // detected (see also requirement ZSG_BF_13075). If the value 0 is reached, the output is permanently deactivated
        // and cannot be reset using terminal switching or a diagnostic job. -> SG exchange necessary. 0 - 100000 =
        // current counter value for the restart attempts FFFFFFFFh = signal invalid / implausible / Das Result enthält
        // den aktuellen Zählerstand für die  bisher erkannten Kurzschlüsse gegen Masse des Treibers KL15N2. Hinweis:  
        // Startwert ist 100000 und wird pro SW- oder HW-mäßigem erkanntem Kurzschluss um 1 dekrementiert (Siehe hierzu
        // auch Anforderung ZSG_BF_13075).Wird der Wert 0 erreicht, so wird der Ausgang dauerhaft deaktiviert kann weder
        // mittels Klemmenschalten noch per Diagnosejob zurückgesetzt werden. -> SG-Tausch nötig. 0 - 100000 =Aktueller
        // Zählerwert für die Wiedereinschaltversuche FFFFFFFFh = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_15N2_ZAEHLER_COUNT_MAX_WERT", STAT_TREIBER_15N2_ZAEHLER_COUNT_MAX_WERT, "");

    unsigned char STAT_TREIBER_15N2_ZAEHLER_KS_RESTARTS_WERT = (RXBUF_UCHAR(10));
        // The result contains the number of reconnection attempts carried out so far in cycle KL15 on -> KL15 off of
        // driver KL15N2. Note: After a short circuit is detected (on the software or hardware side), the driver is
        // reactivated as often as the maximum defined by the coding. Afterwards, a terminal change KL15 off -> KL15 on
        // is necessary in order to restart the restart attempts (see requirements ZSG_BF_13096 and ZSG_BF_13097) 0 - 254
        // = current counter value for the restart attempts 255 = signal invalid / implausible / Das Result enthält die
        // Anzahl der bisher durchgeführten Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus des Treibers KL15N2. 
        // Hinweis:  Nach erkanntem Kurzschluss (SW- oder HW-seitig) wird der Treiber so oft wieder aktiviert, wie
        // maximal per Codierung definiert. Danach ist ein Klemmenwechsel KL15 aus -> KL15 ein nötig, um die
        // Wiedereinschaltversuche erneut zu starten (Siehe hierzu Anfoderungen ZSG_BF_13096 und ZSG_BF_13097) 0 - 254 =
        // Aktueller Zählerwert für die Wiedereinschaltversuche 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_15N2_ZAEHLER_KS_RESTARTS_WERT", STAT_TREIBER_15N2_ZAEHLER_KS_RESTARTS_WERT, "");

    unsigned char STAT_TREIBER_15N2_ZAEHLER_KS_KL15_CYCLES_WERT = (RXBUF_UCHAR(11));
        // The result contains the current number of already performed resets of the short-circuit shutdown by KL15 on of
        // the driver KL15N2. Note: The coding defines how often the short-circuit switch-off can be reset by switching
        // terminal 15. (See requirements ZSG_BF_13098) 0 - 254 = Current counter value for the number of resets already
        // carried out for short-circuit shutdown 255 = Signal invalid / implausible / Das Result enthält den aktuelle
        // Anzahl an bereits durchgeführten Resets des Kurzschlussabschaltung durch KL15 ein des Treibers KL15N2. 
        // Hinweis:  Per Kodierung ist festgelegt wie oft die Kurzschlussabschaltung durch Schalten der Klemme 15
        // zurückgesetzt werden kann. (Siehe hierzu Anfoderungen ZSG_BF_13098) 0 - 254 = Aktueller Zählerwert für die
        // Anzahl an bereits durchgeführten Resets der Kurzschlussabschaltung 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_15N2_ZAEHLER_KS_KL15_CYCLES_WERT", STAT_TREIBER_15N2_ZAEHLER_KS_KL15_CYCLES_WERT, "");

    unsigned long STAT_TREIBER_KL30BACSM_ZAEHLER_COUNT_MAX_WERT = (RXBUF_UINT32(12));
        // The result contains the current counter status for the previously detected short circuits to ground of the
        // KL30B-ACSM driver. Note: ¿The start value is 100000 and is decremented by 1 for each SW or HW-related short
        // circuit detected (see also request ZSG_BF_13075). If the value 0 is reached, the output is permanently
        // deactivated and cannot be reset using terminal switching or a diagnostic job. -> SG exchange necessary. 0 -
        // 100000 = current counter value for the restart attempts FFFFFFFFh = signal invalid / implausible / Das Result
        // enthält den aktuellen Zählerstand für die bisher erkannten Kurzschlüsse gegen Masse des Treibers KL30B-ACSM.
        // Hinweis:  ¿   Startwert ist 100000 und wird pro SW- oder HW-mäßigem erkanntem Kurzschluss um 1 dekrementiert
        // (Siehe hierzu auch Anforderung ZSG_BF_13075).Wird der Wert 0 erreicht, so wird der Ausgang dauerhaft
        // deaktiviert kann weder mittels Klemmenschalten noch per Diagnosejob zurückgesetzt werden. -> SG-Tausch nötig.
        // 0 - 100000 =Aktueller Zählerwert für die Wiedereinschaltversuche FFFFFFFFh = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30BACSM_ZAEHLER_COUNT_MAX_WERT", STAT_TREIBER_KL30BACSM_ZAEHLER_COUNT_MAX_WERT, "");

    unsigned char STAT_TREIBER_KL30BACSM_ZAEHLER_KS_RESTARTS_WERT = (RXBUF_UCHAR(16));
        // The result contains the number of reconnection attempts carried out so far in cycle KL15 on -> KL15 off of the
        // KL30B-ACSM driver. Note: After a short circuit is detected (on the software or hardware side), the driver is
        // reactivated as often as the maximum defined by the coding. Afterwards, a terminal change KL15 off -> KL15 on
        // is necessary in order to restart the restart attempts (see requirements ZSG_BF_13096 and ZSG_BF_13097). 0 -
        // 254 = current counter value for the restart attempts 255 = signal invalid / implausible / Das Result enthält
        // die Anzahl der bisher durchgeführten Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus des Treibers
        // KL30B-ACSM.  Hinweis:  Nach erkanntem Kurzschluss (SW- oder HW-seitig) wird der Treiber so oft wieder
        // aktiviert, wie maximal per Codierung definiert. Danach ist ein Klemmenwechsel KL15 aus -> KL15 ein nötig, um
        // die Wiedereinschaltversuche erneut zu starten (Siehe hierzu Anfoderungen ZSG_BF_13096 und ZSG_BF_13097). 0 -
        // 254 = Aktueller Zählerwert für die Wiedereinschaltversuche 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30BACSM_ZAEHLER_KS_RESTARTS_WERT", STAT_TREIBER_KL30BACSM_ZAEHLER_KS_RESTARTS_WERT, "");

    unsigned char STAT_TREIBER_KL30BACSM_ZAEHLER_KS_KL15_CYCLES_WERT = (RXBUF_UCHAR(17));
        // The result contains the current number of already performed resets of the short-circuit shutdown by KL15 on
        // the KL30B-ACSM driver. Note: The coding defines how often the short-circuit switch-off can be reset by
        // switching terminal 15. (See requirements ZSG_BF_13098) 0 - 254 = Current counter value for the number of
        // resets already carried out for short-circuit shutdown 255 = Signal invalid / implausible / Das Result enthält
        // den aktuelle Anzahl an bereits durchgeführten Resets des Kurzschlussabschaltung durch KL15 ein des Treibers
        // KL30B-ACSM.  Hinweis:  Per Kodierung ist festgelegt wie oft die Kurzschlussabschaltung durch Schalten der
        // Klemme 15 zurückgesetzt werden kann. (Siehe hierzu Anfoderungen ZSG_BF_13098) 0 - 254 = Aktueller Zählerwert
        // für die Anzahl an bereits durchgeführten Resets der Kurzschlussabschaltung 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30BACSM_ZAEHLER_KS_KL15_CYCLES_WERT", STAT_TREIBER_KL30BACSM_ZAEHLER_KS_KL15_CYCLES_WERT, "");

    unsigned long STAT_TREIBER_KL30B1_ZAEHLER_COUNT_MAX_WERT = (RXBUF_UINT32(18));
        // The result contains the current counter status for the previously recognized short circuits to ground of the
        // KL30B-1 driver. Note: The start value is 100000 and is decremented by 1 for each SW or HW-related short
        // circuit detected (see also requirement ZSG_BF_13075). If the value 0 is reached, the output is permanently
        // deactivated and cannot be reset using terminal switching or a diagnostic job. -> SG exchange necessary. 0 -
        // 100000 = current counter value for the restart attempts FFFFFFFFh = signal invalid / implausible / Das Result
        // enthält den aktuellen Zählerstand für die  bisher erkannten Kurzschlüsse gegen Masse des Treibers KL30B-1.
        // Hinweis:   Startwert ist 100000 und wird pro SW- oder HW-mäßigem erkanntem Kurzschluss um 1 dekrementiert
        // (Siehe hierzu auch Anforderung ZSG_BF_13075).Wird der Wert 0 erreicht, so wird der Ausgang dauerhaft
        // deaktiviert kann weder mittels Klemmenschalten noch per Diagnosejob zurückgesetzt werden. -> SG-Tausch nötig.
        // 0 - 100000 =Aktueller Zählerwert für die Wiedereinschaltversuche FFFFFFFFh = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30B1_ZAEHLER_COUNT_MAX_WERT", STAT_TREIBER_KL30B1_ZAEHLER_COUNT_MAX_WERT, "");

    unsigned char STAT_TREIBER_KL30B1_ZAEHLER_KS_RESTARTS_WERT = (RXBUF_UCHAR(22));
        // The result contains the number of reconnection attempts carried out so far in cycle KL15 on -> KL15 off of
        // driver KL30B-1. Note: After a short circuit is detected (on the software or hardware side), the driver is
        // reactivated as often as the maximum defined by the coding. Afterwards, a terminal change KL15 off -> KL15 on
        // is necessary in order to restart the restart attempts (see requirements ZSG_BF_13096 and ZSG_BF_13097) 0 - 254
        // = current counter value for the restart attempts 255 = signal invalid / implausible / Das Result enthält die
        // Anzahl der bisher durchgeführten Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus des Treibers KL30B-1. 
        // Hinweis:  Nach erkanntem Kurzschluss (SW- oder HW-seitig) wird der Treiber so oft wieder aktiviert, wie
        // maximal per Codierung definiert. Danach ist ein Klemmenwechsel KL15 aus -> KL15 ein nötig, um die
        // Wiedereinschaltversuche erneut zu starten (Siehe hierzu Anfoderungen ZSG_BF_13096 und ZSG_BF_13097) 0 - 254 =
        // Aktueller Zählerwert für die Wiedereinschaltversuche 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30B1_ZAEHLER_KS_RESTARTS_WERT", STAT_TREIBER_KL30B1_ZAEHLER_KS_RESTARTS_WERT, "");

    unsigned char STAT_TREIBER_KL30B1_ZAEHLER_KS_KL15_CYCLES_WERT = (RXBUF_UCHAR(23));
        // The result contains the current number of already performed resets of the short-circuit shutdown by KL15 on of
        // the KL30B-1 driver. Note: The coding defines how often the short-circuit switch-off can be reset by switching
        // terminal 15. (See requirements ZSG_BF_13098) 0 - 254 = Current counter value for the number of resets already
        // carried out for short-circuit shutdown 255 = Signal invalid / implausible / Das Result enthält den aktuelle
        // Anzahl an bereits durchgeführten Resets des Kurzschlussabschaltung durch KL15 ein des Treibers KL30B-1. 
        // Hinweis:  Per Kodierung ist festgelegt wie oft die Kurzschlussabschaltung durch Schalten der Klemme 15
        // zurückgesetzt werden kann. (Siehe hierzu Anfoderungen ZSG_BF_13098) 0 - 254 = Aktueller Zählerwert für die
        // Anzahl an bereits durchgeführten Resets der Kurzschlussabschaltung 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30B1_ZAEHLER_KS_KL15_CYCLES_WERT", STAT_TREIBER_KL30B1_ZAEHLER_KS_KL15_CYCLES_WERT, "");

    unsigned long STAT_TREIBER_KL30B2_ZAEHLER_COUNT_MAX_WERT = (RXBUF_UINT32(24));
        // The result contains the current counter status for the previously recognized short circuits to ground of the
        // KL30B-2 driver. Note: The start value is 100000 and is decremented by 1 for each SW or HW-related short
        // circuit detected (see also requirement ZSG_BF_13075). If the value 0 is reached, the output is permanently
        // deactivated and cannot be reset using terminal switching or a diagnostic job. -> SG exchange necessary. 0 -
        // 100000 = current counter value for the restart attempts FFFFFFFFh = signal invalid / implausible / Das Result
        // enthält den aktuellen Zählerstand für die  bisher erkannten Kurzschlüsse gegen Masse des Treibers KL30B-2.
        // Hinweis:   Startwert ist 100000 und wird pro SW- oder HW-mäßigem erkanntem Kurzschluss um 1 dekrementiert
        // (Siehe hierzu auch Anforderung ZSG_BF_13075).Wird der Wert 0 erreicht, so wird der Ausgang dauerhaft
        // deaktiviert kann weder mittels Klemmenschalten noch per Diagnosejob zurückgesetzt werden. -> SG-Tausch nötig.
        // 0 - 100000 =Aktueller Zählerwert für die Wiedereinschaltversuche FFFFFFFFh = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30B2_ZAEHLER_COUNT_MAX_WERT", STAT_TREIBER_KL30B2_ZAEHLER_COUNT_MAX_WERT, "");

    unsigned char STAT_TREIBER_KL30B2_ZAEHLER_KS_RESTARTS_WERT = (RXBUF_UCHAR(28));
        // The result contains the number of reconnection attempts carried out in cycle KL15 on -> KL15 off of driver
        // KL30B-2. Note: After a short circuit is detected (on the software or hardware side), the driver is reactivated
        // as often as the maximum defined by the coding. Afterwards, a terminal change KL15 off -> KL15 on is necessary
        // in order to restart the restart attempts (see requirements ZSG_BF_13096 and ZSG_BF_13097) 0 - 254 = current
        // counter value for the restart attempts 255 = signal invalid / implausible / Das Result enthält die Anzahl der
        // bisher durchgeführten Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus des Treibers KL30B-2.  Hinweis: 
        // Nach erkanntem Kurzschluss (SW- oder HW-seitig) wird der Treiber so oft wieder aktiviert, wie maximal per
        // Codierung definiert. Danach ist ein Klemmenwechsel KL15 aus -> KL15 ein nötig, um die Wiedereinschaltversuche
        // erneut zu starten (Siehe hierzu Anfoderungen ZSG_BF_13096 und ZSG_BF_13097) 0 - 254 = Aktueller Zählerwert für
        // die Wiedereinschaltversuche 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30B2_ZAEHLER_KS_RESTARTS_WERT", STAT_TREIBER_KL30B2_ZAEHLER_KS_RESTARTS_WERT, "");

    unsigned char STAT_TREIBER_KL30B2_ZAEHLER_KS_KL15_CYCLES_WERT = (RXBUF_UCHAR(29));
        // The result contains the current number of already performed resets of the short-circuit shutdown by KL15 on
        // the KL30B-2 driver. Note: The coding defines how often the short-circuit switch-off can be reset by switching
        // terminal 15. (See requirements ZSG_BF_13098) 0 - 254 = Current counter value for the number of resets already
        // carried out for short-circuit shutdown 255 = Signal invalid / implausible / Das Result enthält den aktuelle
        // Anzahl an bereits durchgeführten Resets des Kurzschlussabschaltung durch KL15 ein des Treibers KL30B-2. 
        // Hinweis:  Per Kodierung ist festgelegt wie oft die Kurzschlussabschaltung durch Schalten der Klemme 15
        // zurückgesetzt werden kann. (Siehe hierzu Anfoderungen ZSG_BF_13098) 0 - 254 = Aktueller Zählerwert für die
        // Anzahl an bereits durchgeführten Resets der Kurzschlussabschaltung 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_TREIBER_KL30B2_ZAEHLER_KS_KL15_CYCLES_WERT", STAT_TREIBER_KL30B2_ZAEHLER_KS_KL15_CYCLES_WERT, "");

    unsigned char STAT_KODIERUNG_RESTARTS_WERT_0X5020 = (RXBUF_UCHAR(30));
        // The result contains the maximum value that can be coded for restart attempts in cycle KL15 on -> KL15 off ->
        // KL15 on. Note: The content corresponds to the coding SCD_RESTART (see requirements ZSG_BF_13073) 0 - 254 =
        // maximum value for the restart attempts 255 = signal invalid / implausible / Das Result enthält den codierbaren
        // maximalen Wert an Wiedereinschaltversuche im Zyklus KL15 ein -> KL15 aus -> KL15 ein.  Hinweis: Inhalt
        // entspricht der Codierung SCD_RESTART (Siehe hierzu Anfoderungen ZSG_BF_13073) 0 - 254 = maximaler Wert für die
        // Wiedereinschaltversuche 255 = Signal ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_KODIERUNG_RESTARTS_WERT_0X5020", STAT_KODIERUNG_RESTARTS_WERT_0X5020, "");

    unsigned char STAT_KODIERUNG_KL15_CYCLES_WERT_0X5020 = (RXBUF_UCHAR(31));
        // The result contains the codable maximum value of resets of the short-circuit shutdown by KL15. Note: The
        // content corresponds to the coding SCD_KL15_CYCLES (see requirements ZSG_BF_13073) 0 - 254 = maximum value for
        // the resets of the short-circuit shutdown 255 = invalid / implausible / Das Result enthält den codierbaren
        // maximalen Wert an Resets des Kurzschlussabschaltung durch KL15 ein.  Hinweis: Inhalt entspricht der Codierung
        // SCD_KL15_CYCLES (Siehe hierzu Anfoderungen ZSG_BF_13073) 0 - 254 = maximaler Wert für die Resets der
        // Kurzschlussabschaltung 255 = Ungültig / unplausibel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_KLEMMENSTEUERUNG_KURZSCHLUSSABSCHALTUNG_ZAEHLER", "STAT_KODIERUNG_KL15_CYCLES_WERT_0X5020", STAT_KODIERUNG_KL15_CYCLES_WERT_0X5020, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__ECUMA_INTERN: {                                                // 0x5101
    if (datalen < 13) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__ECUMA_INTERN", 13);
        break;
    }

    unsigned long STAT_ECUMA_LAST_HW_WAKEUP_ID_WERT = (RXBUF_UINT32(0));
        // ECUMA_LAST_HW_WAKEUP_ID / ECUMA_LAST_HW_WAKEUP_ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_ECUMA_INTERN", "STAT_ECUMA_LAST_HW_WAKEUP_ID_WERT", STAT_ECUMA_LAST_HW_WAKEUP_ID_WERT, "");

    unsigned char STAT_ECUMA_LAST_SW_WAKEUP_ID = (RXBUF_UCHAR(4));
        // ECUMA_LAST_SW_WAKEUP_ID / ECUMA_LAST_SW_WAKEUP_ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ECUMA_INTERN", "STAT_ECUMA_LAST_SW_WAKEUP_ID", STAT_ECUMA_LAST_SW_WAKEUP_ID, "\"0-n\"");

    unsigned char STAT_ECUMA_LAST_BUS_WAKEUP_ID = (RXBUF_UCHAR(5));
        // ECUMA_LAST_BUS_WAKEUP_ID / ECUMA_LAST_BUS_WAKEUP_ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ECUMA_INTERN", "STAT_ECUMA_LAST_BUS_WAKEUP_ID", STAT_ECUMA_LAST_BUS_WAKEUP_ID, "\"0-n\"");

    unsigned char STAT_ECUMA_LAST_RESET_ID = (RXBUF_UCHAR(6));
        // ECUMA_LAST_RESET_ID / ECUMA_LAST_RESET_ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ECUMA_INTERN", "STAT_ECUMA_LAST_RESET_ID", STAT_ECUMA_LAST_RESET_ID, "\"0-n\"");

    unsigned short STAT_ECUMA_CAN_WAKEUP_ID_WERT = (RXBUF_UINT(7));
        // ECUMA_CAN_WAKEUP_ID / ECUMA_CAN_WAKEUP_ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_ECUMA_INTERN", "STAT_ECUMA_CAN_WAKEUP_ID_WERT", STAT_ECUMA_CAN_WAKEUP_ID_WERT, "");

    unsigned long STAT_RESERVED_WERT = (RXBUF_UINT32(9));
        // RESERVED / RESERVED
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_ECUMA_INTERN", "STAT_RESERVED_WERT", STAT_RESERVED_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__ECUMA_SLEEP_MODE_NRC: {                                        // 0x5109
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__ECUMA_SLEEP_MODE_NRC", 1);
        break;
    }

    unsigned char STAT_SLEEP_MODE_NRC = (RXBUF_UCHAR(0));
        // contains the response to sleep mode / beinhaltet den Response auf Sleep Mode
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_ECUMA_SLEEP_MODE_NRC", "STAT_SLEEP_MODE_NRC", STAT_SLEEP_MODE_NRC, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_HW_INFO_PROVIDER: {                                             // 0x510A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_HW_INFO_PROVIDER", 2);
        break;
    }

    unsigned short STAT_HW_VERSION = (RXBUF_UINT(0));
        // Hardware code / Hardware Code
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "HW_INFO_PROVIDER", "STAT_HW_VERSION", STAT_HW_VERSION, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__JTAGLOCK: {                                                    // 0x510B
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__JTAGLOCK", 2);
        break;
    }

    unsigned char STAT_NORMAL_LOCK_STATE = (RXBUF_UCHAR(0));
        // Jtag normal lock status. (0x00 ¿jtag is unlocked; 0x01 ¿jtag is locked) / Jtag normal lock status. (0x00 ¿
        // jtag is unlocked; 0x01 ¿ jtag is locked)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_JTAGLOCK", "STAT_NORMAL_LOCK_STATE", STAT_NORMAL_LOCK_STATE, "\"0/1\"");

    unsigned char STAT_PERMANENT_LOCK_STATE = (RXBUF_UCHAR(1));
        // Jtag permanent lock status. (0x00 ¿permanent lock not done; 0x01 ¿permanent lock done) / Jtag permanent lock
        // status. (0x00 ¿ permanent lock not done; 0x01 ¿ permanent lock done)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_JTAGLOCK", "STAT_PERMANENT_LOCK_STATE", STAT_PERMANENT_LOCK_STATE, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_READ_PULLUP_REF_RESFUEL_TANK_0: {                               // 0x5DBE
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_READ_PULLUP_REF_RESFUEL_TANK_0", 2);
        break;
    }

    unsigned short STAT_PULLUP_REF_RESFUEL_TANK_LEFT_WERT = (RXBUF_UINT(0));
        // represents resistance value for tank left / represents resistance value for tank left
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "READ_PULLUP_REF_RESFUEL_TANK_0", "STAT_PULLUP_REF_RESFUEL_TANK_LEFT_WERT", STAT_PULLUP_REF_RESFUEL_TANK_LEFT_WERT, "\"Ohm\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC_READ_PULLUP_REF_RESFUEL_TANK_1: {                               // 0x5DBF
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC_READ_PULLUP_REF_RESFUEL_TANK_1", 2);
        break;
    }

    unsigned short STAT_PULLUP_REF_RESFUEL_TANK_RIGHT_WERT = (RXBUF_UINT(0));
        // represents resistance value for tank right / represents resistance value for tank right
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "READ_PULLUP_REF_RESFUEL_TANK_1", "STAT_PULLUP_REF_RESFUEL_TANK_RIGHT_WERT", STAT_PULLUP_REF_RESFUEL_TANK_RIGHT_WERT, "\"Ohm\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_FA_STATISTIKZAEHLER_LESEN: {                                // 0x6020
    if (datalen < 64) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_FA_STATISTIKZAEHLER_LESEN", 64);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_BF_STATISTIKZAEHLER_LESEN: {                                // 0x6021
    if (datalen < 64) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_BF_STATISTIKZAEHLER_LESEN", 64);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_FAH_STATISTIKZAEHLER_LESEN: {                               // 0x6022
    if (datalen < 64) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_FAH_STATISTIKZAEHLER_LESEN", 64);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_BFH_STATISTIKZAEHLER_LESEN: {                               // 0x6023
    if (datalen < 64) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_BFH_STATISTIKZAEHLER_LESEN", 64);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_DENORMIERUNGS_LOGGER_LESEN_FRONT: {                         // 0x603A
    if (datalen < 92) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", 92);
        break;
    }

    unsigned char STAT_FA_DENORM_ZAEHLER_WERT = (RXBUF_UCHAR(0));
        // The denormalization frequency is incremented with each denormalization / Die Denormierh¿ufigkeit wird bei
        // jeder Denormierung inkrementiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_ZAEHLER_WERT", STAT_FA_DENORM_ZAEHLER_WERT, "\"Ink\"");

    unsigned char STAT_FA_DENORM_1_URSACHE_NR = (RXBUF_UCHAR(1));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_1_URSACHE_NR", STAT_FA_DENORM_1_URSACHE_NR, "\"0-n\"");

    short STAT_FA_DENORM_1_POS_HALL_WERT = (RXBUF_SINT(2));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_1_POS_HALL_WERT", STAT_FA_DENORM_1_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_DENORM_1_KM_WERT = (RXBUF_UINT32(4));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_1_KM_WERT", STAT_FA_DENORM_1_KM_WERT, "\"Ink\"");

    unsigned short STAT_FA_RESERVED_1_WERT = (RXBUF_UINT(8));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_RESERVED_1_WERT", STAT_FA_RESERVED_1_WERT, "");

    unsigned char STAT_FA_DENORM_2_URSACHE_NR = (RXBUF_UCHAR(10));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_2_URSACHE_NR", STAT_FA_DENORM_2_URSACHE_NR, "\"0-n\"");

    short STAT_FA_DENORM_2_POS_HALL_WERT = (RXBUF_SINT(11));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_2_POS_HALL_WERT", STAT_FA_DENORM_2_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_DENORM_2_KM_WERT = (RXBUF_UINT32(13));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_2_KM_WERT", STAT_FA_DENORM_2_KM_WERT, "\"Ink\"");

    unsigned short STAT_FA_RESERVED_2_WERT = (RXBUF_UINT(17));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_RESERVED_2_WERT", STAT_FA_RESERVED_2_WERT, "");

    unsigned char STAT_FA_DENORM_3_URSACHE_NR = (RXBUF_UCHAR(19));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_3_URSACHE_NR", STAT_FA_DENORM_3_URSACHE_NR, "\"0-n\"");

    short STAT_FA_DENORM_3_POS_HALL_WERT = (RXBUF_SINT(20));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_3_POS_HALL_WERT", STAT_FA_DENORM_3_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_DENORM_3_KM_WERT = (RXBUF_UINT32(22));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_3_KM_WERT", STAT_FA_DENORM_3_KM_WERT, "\"Ink\"");

    unsigned short STAT_FA_RESERVED_3_WERT = (RXBUF_UINT(26));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_RESERVED_3_WERT", STAT_FA_RESERVED_3_WERT, "");

    unsigned char STAT_FA_DENORM_4_URSACHE_NR = (RXBUF_UCHAR(28));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_4_URSACHE_NR", STAT_FA_DENORM_4_URSACHE_NR, "\"0-n\"");

    short STAT_FA_DENORM_4_POS_HALL_WERT = (RXBUF_SINT(29));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_4_POS_HALL_WERT", STAT_FA_DENORM_4_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_DENORM_4_KM_WERT = (RXBUF_UINT32(31));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_4_KM_WERT", STAT_FA_DENORM_4_KM_WERT, "\"Ink\"");

    unsigned short STAT_FA_RESERVED_4_WERT = (RXBUF_UINT(35));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_RESERVED_4_WERT", STAT_FA_RESERVED_4_WERT, "");

    unsigned char STAT_FA_DENORM_5_URSACHE_NR = (RXBUF_UCHAR(37));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_5_URSACHE_NR", STAT_FA_DENORM_5_URSACHE_NR, "\"0-n\"");

    short STAT_FA_DENORM_5_POS_HALL_WERT = (RXBUF_SINT(38));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_5_POS_HALL_WERT", STAT_FA_DENORM_5_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_DENORM_5_KM_WERT = (RXBUF_UINT32(40));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_DENORM_5_KM_WERT", STAT_FA_DENORM_5_KM_WERT, "\"Ink\"");

    unsigned short STAT_FA_RESERVED_5_WERT = (RXBUF_UINT(44));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_FA_RESERVED_5_WERT", STAT_FA_RESERVED_5_WERT, "");

    unsigned char STAT_BF_DENORM_ZAEHLER_WERT = (RXBUF_UCHAR(46));
        // The denormalization frequency is incremented with each denormalization / Die Denormierh¿ufigkeit wird bei
        // jeder Denormierung inkrementiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_ZAEHLER_WERT", STAT_BF_DENORM_ZAEHLER_WERT, "\"Ink\"");

    unsigned char STAT_BF_DENORM_1_URSACHE_NR = (RXBUF_UCHAR(47));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_1_URSACHE_NR", STAT_BF_DENORM_1_URSACHE_NR, "\"0-n\"");

    short STAT_BF_DENORM_1_POS_HALL_WERT = (RXBUF_SINT(48));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_1_POS_HALL_WERT", STAT_BF_DENORM_1_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_DENORM_1_KM_WERT = (RXBUF_UINT32(50));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_1_KM_WERT", STAT_BF_DENORM_1_KM_WERT, "\"Ink\"");

    unsigned short STAT_BF_RESERVED_1_WERT = (RXBUF_UINT(54));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_RESERVED_1_WERT", STAT_BF_RESERVED_1_WERT, "");

    unsigned char STAT_BF_DENORM_2_URSACHE_NR = (RXBUF_UCHAR(56));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_2_URSACHE_NR", STAT_BF_DENORM_2_URSACHE_NR, "\"0-n\"");

    short STAT_BF_DENORM_2_POS_HALL_WERT = (RXBUF_SINT(57));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_2_POS_HALL_WERT", STAT_BF_DENORM_2_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_DENORM_2_KM_WERT = (RXBUF_UINT32(59));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_2_KM_WERT", STAT_BF_DENORM_2_KM_WERT, "\"Ink\"");

    unsigned short STAT_BF_RESERVED_2_WERT = (RXBUF_UINT(63));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_RESERVED_2_WERT", STAT_BF_RESERVED_2_WERT, "");

    unsigned char STAT_BF_DENORM_3_URSACHE_NR = (RXBUF_UCHAR(65));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_3_URSACHE_NR", STAT_BF_DENORM_3_URSACHE_NR, "\"0-n\"");

    short STAT_BF_DENORM_3_POS_HALL_WERT = (RXBUF_SINT(66));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_3_POS_HALL_WERT", STAT_BF_DENORM_3_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_DENORM_3_KM_WERT = (RXBUF_UINT32(68));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_3_KM_WERT", STAT_BF_DENORM_3_KM_WERT, "\"Ink\"");

    unsigned short STAT_BF_RESERVED_3_WERT = (RXBUF_UINT(72));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_RESERVED_3_WERT", STAT_BF_RESERVED_3_WERT, "");

    unsigned char STAT_BF_DENORM_4_URSACHE_NR = (RXBUF_UCHAR(74));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_4_URSACHE_NR", STAT_BF_DENORM_4_URSACHE_NR, "\"0-n\"");

    short STAT_BF_DENORM_4_POS_HALL_WERT = (RXBUF_SINT(75));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_4_POS_HALL_WERT", STAT_BF_DENORM_4_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_DENORM_4_KM_WERT = (RXBUF_UINT32(77));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_4_KM_WERT", STAT_BF_DENORM_4_KM_WERT, "\"Ink\"");

    unsigned short STAT_BF_RESERVED_4_WERT = (RXBUF_UINT(81));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_RESERVED_4_WERT", STAT_BF_RESERVED_4_WERT, "");

    unsigned char STAT_BF_DENORM_5_URSACHE_NR = (RXBUF_UCHAR(83));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_5_URSACHE_NR", STAT_BF_DENORM_5_URSACHE_NR, "\"0-n\"");

    short STAT_BF_DENORM_5_POS_HALL_WERT = (RXBUF_SINT(84));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_5_POS_HALL_WERT", STAT_BF_DENORM_5_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_DENORM_5_KM_WERT = (RXBUF_UINT32(86));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_DENORM_5_KM_WERT", STAT_BF_DENORM_5_KM_WERT, "\"Ink\"");

    unsigned short STAT_BF_RESERVED_5_WERT = (RXBUF_UINT(90));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_FRONT", "STAT_BF_RESERVED_5_WERT", STAT_BF_RESERVED_5_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_DENORMIERUNGS_LOGGER_LESEN_REAR: {                          // 0x603B
    if (datalen < 92) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_DENORMIERUNGS_LOGGER_LESEN_REAR", 92);
        break;
    }

    unsigned char STAT_FAH_DENORM_ZAEHLER_WERT = (RXBUF_UCHAR(0));
        // The denormalization frequency is incremented with each denormalization / Die Denormierh¿ufigkeit wird bei
        // jeder Denormierung inkrementiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_ZAEHLER_WERT", STAT_FAH_DENORM_ZAEHLER_WERT, "\"Ink\"");

    unsigned char STAT_FAH_DENORM_1_URSACHE_NR = (RXBUF_UCHAR(1));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_1_URSACHE_NR", STAT_FAH_DENORM_1_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_DENORM_1_POS_HALL_WERT = (RXBUF_SINT(2));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_1_POS_HALL_WERT", STAT_FAH_DENORM_1_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_DENORM_1_KM_WERT = (RXBUF_UINT32(4));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_1_KM_WERT", STAT_FAH_DENORM_1_KM_WERT, "\"Ink\"");

    unsigned short STAT_FAH_RESERVED_1_WERT = (RXBUF_UINT(8));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_RESERVED_1_WERT", STAT_FAH_RESERVED_1_WERT, "");

    unsigned char STAT_FAH_DENORM_2_URSACHE_NR = (RXBUF_UCHAR(10));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_2_URSACHE_NR", STAT_FAH_DENORM_2_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_DENORM_2_POS_HALL_WERT = (RXBUF_SINT(11));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_2_POS_HALL_WERT", STAT_FAH_DENORM_2_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_DENORM_2_KM_WERT = (RXBUF_UINT32(13));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_2_KM_WERT", STAT_FAH_DENORM_2_KM_WERT, "\"Ink\"");

    unsigned short STAT_FAH_RESERVED_2_WERT = (RXBUF_UINT(17));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_RESERVED_2_WERT", STAT_FAH_RESERVED_2_WERT, "");

    unsigned char STAT_FAH_DENORM_3_URSACHE_NR = (RXBUF_UCHAR(19));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_3_URSACHE_NR", STAT_FAH_DENORM_3_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_DENORM_3_POS_HALL_WERT = (RXBUF_SINT(20));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_3_POS_HALL_WERT", STAT_FAH_DENORM_3_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_DENORM_3_KM_WERT = (RXBUF_UINT32(22));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_3_KM_WERT", STAT_FAH_DENORM_3_KM_WERT, "\"Ink\"");

    unsigned short STAT_FAH_RESERVED_3_WERT = (RXBUF_UINT(26));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_RESERVED_3_WERT", STAT_FAH_RESERVED_3_WERT, "");

    unsigned char STAT_FAH_DENORM_4_URSACHE_NR = (RXBUF_UCHAR(28));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_4_URSACHE_NR", STAT_FAH_DENORM_4_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_DENORM_4_POS_HALL_WERT = (RXBUF_SINT(29));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_4_POS_HALL_WERT", STAT_FAH_DENORM_4_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_DENORM_4_KM_WERT = (RXBUF_UINT32(31));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_4_KM_WERT", STAT_FAH_DENORM_4_KM_WERT, "\"Ink\"");

    unsigned short STAT_FAH_RESERVED_4_WERT = (RXBUF_UINT(35));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_RESERVED_4_WERT", STAT_FAH_RESERVED_4_WERT, "");

    unsigned char STAT_FAH_DENORM_5_URSACHE_NR = (RXBUF_UCHAR(37));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_5_URSACHE_NR", STAT_FAH_DENORM_5_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_DENORM_5_POS_HALL_WERT = (RXBUF_SINT(38));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_5_POS_HALL_WERT", STAT_FAH_DENORM_5_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_DENORM_5_KM_WERT = (RXBUF_UINT32(40));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_DENORM_5_KM_WERT", STAT_FAH_DENORM_5_KM_WERT, "\"Ink\"");

    unsigned short STAT_FAH_RESERVED_5_WERT = (RXBUF_UINT(44));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_FAH_RESERVED_5_WERT", STAT_FAH_RESERVED_5_WERT, "");

    unsigned char STAT_BFH_DENORM_ZAEHLER_WERT = (RXBUF_UCHAR(46));
        // The denormalization frequency is incremented with each denormalization / Die Denormierh¿ufigkeit wird bei
        // jeder Denormierung inkrementiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_ZAEHLER_WERT", STAT_BFH_DENORM_ZAEHLER_WERT, "\"Ink\"");

    unsigned char STAT_BFH_DENORM_1_URSACHE_NR = (RXBUF_UCHAR(47));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_1_URSACHE_NR", STAT_BFH_DENORM_1_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_DENORM_1_POS_HALL_WERT = (RXBUF_SINT(48));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_1_POS_HALL_WERT", STAT_BFH_DENORM_1_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_DENORM_1_KM_WERT = (RXBUF_UINT32(50));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_1_KM_WERT", STAT_BFH_DENORM_1_KM_WERT, "\"Ink\"");

    unsigned short STAT_BFH_RESERVED_1_WERT = (RXBUF_UINT(54));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_RESERVED_1_WERT", STAT_BFH_RESERVED_1_WERT, "");

    unsigned char STAT_BFH_DENORM_2_URSACHE_NR = (RXBUF_UCHAR(56));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_2_URSACHE_NR", STAT_BFH_DENORM_2_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_DENORM_2_POS_HALL_WERT = (RXBUF_SINT(57));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_2_POS_HALL_WERT", STAT_BFH_DENORM_2_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_DENORM_2_KM_WERT = (RXBUF_UINT32(59));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_2_KM_WERT", STAT_BFH_DENORM_2_KM_WERT, "\"Ink\"");

    unsigned short STAT_BFH_RESERVED_2_WERT = (RXBUF_UINT(63));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_RESERVED_2_WERT", STAT_BFH_RESERVED_2_WERT, "");

    unsigned char STAT_BFH_DENORM_3_URSACHE_NR = (RXBUF_UCHAR(65));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_3_URSACHE_NR", STAT_BFH_DENORM_3_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_DENORM_3_POS_HALL_WERT = (RXBUF_SINT(66));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_3_POS_HALL_WERT", STAT_BFH_DENORM_3_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_DENORM_3_KM_WERT = (RXBUF_UINT32(68));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_3_KM_WERT", STAT_BFH_DENORM_3_KM_WERT, "\"Ink\"");

    unsigned short STAT_BFH_RESERVED_3_WERT = (RXBUF_UINT(72));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_RESERVED_3_WERT", STAT_BFH_RESERVED_3_WERT, "");

    unsigned char STAT_BFH_DENORM_4_URSACHE_NR = (RXBUF_UCHAR(74));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_4_URSACHE_NR", STAT_BFH_DENORM_4_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_DENORM_4_POS_HALL_WERT = (RXBUF_SINT(75));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_4_POS_HALL_WERT", STAT_BFH_DENORM_4_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_DENORM_4_KM_WERT = (RXBUF_UINT32(77));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_4_KM_WERT", STAT_BFH_DENORM_4_KM_WERT, "\"Ink\"");

    unsigned short STAT_BFH_RESERVED_4_WERT = (RXBUF_UINT(81));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_RESERVED_4_WERT", STAT_BFH_RESERVED_4_WERT, "");

    unsigned char STAT_BFH_DENORM_5_URSACHE_NR = (RXBUF_UCHAR(83));
        // Cause of denormalization. / Ursache der Denormierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_5_URSACHE_NR", STAT_BFH_DENORM_5_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_DENORM_5_POS_HALL_WERT = (RXBUF_SINT(84));
        // Specification of the hall increments (2-byte) / Angabe der Hallinkremente (2-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_5_POS_HALL_WERT", STAT_BFH_DENORM_5_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_DENORM_5_KM_WERT = (RXBUF_UINT32(86));
        // Mileage (3-byte) / Kilometerstand (3-Byte)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_DENORM_5_KM_WERT", STAT_BFH_DENORM_5_KM_WERT, "\"Ink\"");

    unsigned short STAT_BFH_RESERVED_5_WERT = (RXBUF_UINT(90));
        // Implementation in the SW-C MT / Umsetzung in der SW-C MT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_DENORMIERUNGS_LOGGER_LESEN_REAR", "STAT_BFH_RESERVED_5_WERT", STAT_BFH_RESERVED_5_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_REVERSIER_LOGGER_LESEN_FRONT: {                             // 0x603E
    if (datalen < 112) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_REVERSIER_LOGGER_LESEN_FRONT", 112);
        break;
    }

    unsigned char STAT_FA_REVERSIEREN_ZAEHLER_WERT = (RXBUF_UCHAR(0));
        // The reversing frequency is incremented with each reversing / Die Reversierhaeufigkeit wird bei jedem Reversier
        // inkrementiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_ZAEHLER_WERT", STAT_FA_REVERSIEREN_ZAEHLER_WERT, "\"Ink\"");

    unsigned char STAT_FA_REVERSIEREN_1_URSACHE_NR = (RXBUF_UCHAR(1));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_1_URSACHE_NR", STAT_FA_REVERSIEREN_1_URSACHE_NR, "\"0-n\"");

    short STAT_FA_REVERSIEREN_1_POS_HALL_WERT = (RXBUF_SINT(2));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_1_POS_HALL_WERT", STAT_FA_REVERSIEREN_1_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_REVERSIEREN_1_KM_WERT = (RXBUF_UINT32(4));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_1_KM_WERT", STAT_FA_REVERSIEREN_1_KM_WERT, "\"km\"");

    char STAT_FA_REVERSIEREN_1_ATEMP_WERT = (RXBUF_SCHAR(8));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_1_ATEMP_WERT", STAT_FA_REVERSIEREN_1_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FA_REVERSIEREN_1_SPANNUNG_WERT = (RXBUF_UCHAR(9));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_1_SPANNUNG_WERT", STAT_FA_REVERSIEREN_1_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FA_REVERSIEREN_1_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(10));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_1_GESCHWINDIGKEIT_WERT", STAT_FA_REVERSIEREN_1_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_FA_REVERSIEREN_2_URSACHE_NR = (RXBUF_UCHAR(12));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_2_URSACHE_NR", STAT_FA_REVERSIEREN_2_URSACHE_NR, "\"0-n\"");

    short STAT_FA_REVERSIEREN_2_POS_HALL_WERT = (RXBUF_SINT(13));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_2_POS_HALL_WERT", STAT_FA_REVERSIEREN_2_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_REVERSIEREN_2_KM_WERT = (RXBUF_UINT32(15));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_2_KM_WERT", STAT_FA_REVERSIEREN_2_KM_WERT, "\"km\"");

    char STAT_FA_REVERSIEREN_2_ATEMP_WERT = (RXBUF_SCHAR(19));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_2_ATEMP_WERT", STAT_FA_REVERSIEREN_2_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FA_REVERSIEREN_2_SPANNUNG_WERT = (RXBUF_UCHAR(20));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_2_SPANNUNG_WERT", STAT_FA_REVERSIEREN_2_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FA_REVERSIEREN_2_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(21));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_2_GESCHWINDIGKEIT_WERT", STAT_FA_REVERSIEREN_2_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_FA_REVERSIEREN_3_URSACHE_NR = (RXBUF_UCHAR(23));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_3_URSACHE_NR", STAT_FA_REVERSIEREN_3_URSACHE_NR, "\"0-n\"");

    short STAT_FA_REVERSIEREN_3_POS_HALL_WERT = (RXBUF_SINT(24));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_3_POS_HALL_WERT", STAT_FA_REVERSIEREN_3_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_REVERSIEREN_3_KM_WERT = (RXBUF_UINT32(26));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_3_KM_WERT", STAT_FA_REVERSIEREN_3_KM_WERT, "\"km\"");

    char STAT_FA_REVERSIEREN_3_ATEMP_WERT = (RXBUF_SCHAR(30));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_3_ATEMP_WERT", STAT_FA_REVERSIEREN_3_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FA_REVERSIEREN_3_SPANNUNG_WERT = (RXBUF_UCHAR(31));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_3_SPANNUNG_WERT", STAT_FA_REVERSIEREN_3_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FA_REVERSIEREN_3_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(32));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_3_GESCHWINDIGKEIT_WERT", STAT_FA_REVERSIEREN_3_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_FA_REVERSIEREN_4_URSACHE_NR = (RXBUF_UCHAR(34));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_4_URSACHE_NR", STAT_FA_REVERSIEREN_4_URSACHE_NR, "\"0-n\"");

    short STAT_FA_REVERSIEREN_4_POS_HALL_WERT = (RXBUF_SINT(35));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_4_POS_HALL_WERT", STAT_FA_REVERSIEREN_4_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_REVERSIEREN_4_KM_WERT = (RXBUF_UINT32(37));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_4_KM_WERT", STAT_FA_REVERSIEREN_4_KM_WERT, "\"km\"");

    char STAT_FA_REVERSIEREN_4_ATEMP_WERT = (RXBUF_SCHAR(41));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_4_ATEMP_WERT", STAT_FA_REVERSIEREN_4_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FA_REVERSIEREN_4_SPANNUNG_WERT = (RXBUF_UCHAR(42));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_4_SPANNUNG_WERT", STAT_FA_REVERSIEREN_4_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FA_REVERSIEREN_4_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(43));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_4_GESCHWINDIGKEIT_WERT", STAT_FA_REVERSIEREN_4_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_FA_REVERSIEREN_5_URSACHE_NR = (RXBUF_UCHAR(45));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_5_URSACHE_NR", STAT_FA_REVERSIEREN_5_URSACHE_NR, "\"0-n\"");

    short STAT_FA_REVERSIEREN_5_POS_HALL_WERT = (RXBUF_SINT(46));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_5_POS_HALL_WERT", STAT_FA_REVERSIEREN_5_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FA_REVERSIEREN_5_KM_WERT = (RXBUF_UINT32(48));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_5_KM_WERT", STAT_FA_REVERSIEREN_5_KM_WERT, "\"km\"");

    char STAT_FA_REVERSIEREN_5_ATEMP_WERT = (RXBUF_SCHAR(52));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_5_ATEMP_WERT", STAT_FA_REVERSIEREN_5_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FA_REVERSIEREN_5_SPANNUNG_WERT = (RXBUF_UCHAR(53));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_5_SPANNUNG_WERT", STAT_FA_REVERSIEREN_5_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FA_REVERSIEREN_5_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(54));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_FA_REVERSIEREN_5_GESCHWINDIGKEIT_WERT", STAT_FA_REVERSIEREN_5_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BF_REVERSIEREN_ZAEHLER_WERT = (RXBUF_UCHAR(56));
        // The reversing frequency is incremented with each reversing / Die Reversierhaeufigkeit wird bei jedem Reversier
        // inkrementiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_ZAEHLER_WERT", STAT_BF_REVERSIEREN_ZAEHLER_WERT, "\"Ink\"");

    unsigned char STAT_BF_REVERSIEREN_1_URSACHE_NR = (RXBUF_UCHAR(57));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_1_URSACHE_NR", STAT_BF_REVERSIEREN_1_URSACHE_NR, "\"0-n\"");

    short STAT_BF_REVERSIEREN_1_POS_HALL_WERT = (RXBUF_SINT(58));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_1_POS_HALL_WERT", STAT_BF_REVERSIEREN_1_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_REVERSIEREN_1_KM_WERT = (RXBUF_UINT32(60));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_1_KM_WERT", STAT_BF_REVERSIEREN_1_KM_WERT, "\"km\"");

    char STAT_BF_REVERSIEREN_1_ATEMP_WERT = (RXBUF_SCHAR(64));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_1_ATEMP_WERT", STAT_BF_REVERSIEREN_1_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BF_REVERSIEREN_1_SPANNUNG_WERT = (RXBUF_UCHAR(65));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_1_SPANNUNG_WERT", STAT_BF_REVERSIEREN_1_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BF_REVERSIEREN_1_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(66));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_1_GESCHWINDIGKEIT_WERT", STAT_BF_REVERSIEREN_1_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BF_REVERSIEREN_2_URSACHE_NR = (RXBUF_UCHAR(68));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_2_URSACHE_NR", STAT_BF_REVERSIEREN_2_URSACHE_NR, "\"0-n\"");

    short STAT_BF_REVERSIEREN_2_POS_HALL_WERT = (RXBUF_SINT(69));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_2_POS_HALL_WERT", STAT_BF_REVERSIEREN_2_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_REVERSIEREN_2_KM_WERT = (RXBUF_UINT32(71));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_2_KM_WERT", STAT_BF_REVERSIEREN_2_KM_WERT, "\"km\"");

    char STAT_BF_REVERSIEREN_2_ATEMP_WERT = (RXBUF_SCHAR(75));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_2_ATEMP_WERT", STAT_BF_REVERSIEREN_2_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BF_REVERSIEREN_2_SPANNUNG_WERT = (RXBUF_UCHAR(76));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_2_SPANNUNG_WERT", STAT_BF_REVERSIEREN_2_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BF_REVERSIEREN_2_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(77));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_2_GESCHWINDIGKEIT_WERT", STAT_BF_REVERSIEREN_2_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BF_REVERSIEREN_3_URSACHE_NR = (RXBUF_UCHAR(79));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_3_URSACHE_NR", STAT_BF_REVERSIEREN_3_URSACHE_NR, "\"0-n\"");

    short STAT_BF_REVERSIEREN_3_POS_HALL_WERT = (RXBUF_SINT(80));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_3_POS_HALL_WERT", STAT_BF_REVERSIEREN_3_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_REVERSIEREN_3_KM_WERT = (RXBUF_UINT32(82));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_3_KM_WERT", STAT_BF_REVERSIEREN_3_KM_WERT, "\"km\"");

    char STAT_BF_REVERSIEREN_3_ATEMP_WERT = (RXBUF_SCHAR(86));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_3_ATEMP_WERT", STAT_BF_REVERSIEREN_3_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BF_REVERSIEREN_3_SPANNUNG_WERT = (RXBUF_UCHAR(87));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_3_SPANNUNG_WERT", STAT_BF_REVERSIEREN_3_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BF_REVERSIEREN_3_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(88));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_3_GESCHWINDIGKEIT_WERT", STAT_BF_REVERSIEREN_3_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BF_REVERSIEREN_4_URSACHE_NR = (RXBUF_UCHAR(90));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_4_URSACHE_NR", STAT_BF_REVERSIEREN_4_URSACHE_NR, "\"0-n\"");

    short STAT_BF_REVERSIEREN_4_POS_HALL_WERT = (RXBUF_SINT(91));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_4_POS_HALL_WERT", STAT_BF_REVERSIEREN_4_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_REVERSIEREN_4_KM_WERT = (RXBUF_UINT32(93));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_4_KM_WERT", STAT_BF_REVERSIEREN_4_KM_WERT, "\"km\"");

    char STAT_BF_REVERSIEREN_4_ATEMP_WERT = (RXBUF_SCHAR(97));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_4_ATEMP_WERT", STAT_BF_REVERSIEREN_4_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BF_REVERSIEREN_4_SPANNUNG_WERT = (RXBUF_UCHAR(98));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_4_SPANNUNG_WERT", STAT_BF_REVERSIEREN_4_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BF_REVERSIEREN_4_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(99));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_4_GESCHWINDIGKEIT_WERT", STAT_BF_REVERSIEREN_4_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BF_REVERSIEREN_5_URSACHE_NR = (RXBUF_UCHAR(101));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_5_URSACHE_NR", STAT_BF_REVERSIEREN_5_URSACHE_NR, "\"0-n\"");

    short STAT_BF_REVERSIEREN_5_POS_HALL_WERT = (RXBUF_SINT(102));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_5_POS_HALL_WERT", STAT_BF_REVERSIEREN_5_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BF_REVERSIEREN_5_KM_WERT = (RXBUF_UINT32(104));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_5_KM_WERT", STAT_BF_REVERSIEREN_5_KM_WERT, "\"km\"");

    char STAT_BF_REVERSIEREN_5_ATEMP_WERT = (RXBUF_SCHAR(108));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_5_ATEMP_WERT", STAT_BF_REVERSIEREN_5_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BF_REVERSIEREN_5_SPANNUNG_WERT = (RXBUF_UCHAR(109));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_5_SPANNUNG_WERT", STAT_BF_REVERSIEREN_5_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BF_REVERSIEREN_5_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(110));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_FRONT", "STAT_BF_REVERSIEREN_5_GESCHWINDIGKEIT_WERT", STAT_BF_REVERSIEREN_5_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_REVERSIER_LOGGER_LESEN_REAR: {                              // 0x603F
    if (datalen < 112) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_REVERSIER_LOGGER_LESEN_REAR", 112);
        break;
    }

    unsigned char STAT_FAH_REVERSIEREN_ZAEHLER_WERT = (RXBUF_UCHAR(0));
        // The reversing frequency is incremented with each reversing / Die Reversierhaeufigkeit wird bei jedem Reversier
        // inkrementiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_ZAEHLER_WERT", STAT_FAH_REVERSIEREN_ZAEHLER_WERT, "\"Ink\"");

    unsigned char STAT_FAH_REVERSIEREN_1_URSACHE_NR = (RXBUF_UCHAR(1));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_1_URSACHE_NR", STAT_FAH_REVERSIEREN_1_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_REVERSIEREN_1_POS_HALL_WERT = (RXBUF_SINT(2));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_1_POS_HALL_WERT", STAT_FAH_REVERSIEREN_1_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_REVERSIEREN_1_KM_WERT = (RXBUF_UINT32(4));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_1_KM_WERT", STAT_FAH_REVERSIEREN_1_KM_WERT, "\"km\"");

    char STAT_FAH_REVERSIEREN_1_ATEMP_WERT = (RXBUF_SCHAR(8));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_1_ATEMP_WERT", STAT_FAH_REVERSIEREN_1_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FAH_REVERSIEREN_1_SPANNUNG_WERT = (RXBUF_UCHAR(9));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_1_SPANNUNG_WERT", STAT_FAH_REVERSIEREN_1_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FAH_REVERSIEREN_1_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(10));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_1_GESCHWINDIGKEIT_WERT", STAT_FAH_REVERSIEREN_1_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_FAH_REVERSIEREN_2_URSACHE_NR = (RXBUF_UCHAR(12));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_2_URSACHE_NR", STAT_FAH_REVERSIEREN_2_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_REVERSIEREN_2_POS_HALL_WERT = (RXBUF_SINT(13));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_2_POS_HALL_WERT", STAT_FAH_REVERSIEREN_2_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_REVERSIEREN_2_KM_WERT = (RXBUF_UINT32(15));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_2_KM_WERT", STAT_FAH_REVERSIEREN_2_KM_WERT, "\"km\"");

    char STAT_FAH_REVERSIEREN_2_ATEMP_WERT = (RXBUF_SCHAR(19));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_2_ATEMP_WERT", STAT_FAH_REVERSIEREN_2_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FAH_REVERSIEREN_2_SPANNUNG_WERT = (RXBUF_UCHAR(20));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_2_SPANNUNG_WERT", STAT_FAH_REVERSIEREN_2_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FAH_REVERSIEREN_2_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(21));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_2_GESCHWINDIGKEIT_WERT", STAT_FAH_REVERSIEREN_2_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_FAH_REVERSIEREN_3_URSACHE_NR = (RXBUF_UCHAR(23));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_3_URSACHE_NR", STAT_FAH_REVERSIEREN_3_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_REVERSIEREN_3_POS_HALL_WERT = (RXBUF_SINT(24));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_3_POS_HALL_WERT", STAT_FAH_REVERSIEREN_3_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_REVERSIEREN_3_KM_WERT = (RXBUF_UINT32(26));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_3_KM_WERT", STAT_FAH_REVERSIEREN_3_KM_WERT, "\"km\"");

    char STAT_FAH_REVERSIEREN_3_ATEMP_WERT = (RXBUF_SCHAR(30));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_3_ATEMP_WERT", STAT_FAH_REVERSIEREN_3_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FAH_REVERSIEREN_3_SPANNUNG_WERT = (RXBUF_UCHAR(31));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_3_SPANNUNG_WERT", STAT_FAH_REVERSIEREN_3_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FAH_REVERSIEREN_3_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(32));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_3_GESCHWINDIGKEIT_WERT", STAT_FAH_REVERSIEREN_3_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_FAH_REVERSIEREN_4_URSACHE_NR = (RXBUF_UCHAR(34));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_4_URSACHE_NR", STAT_FAH_REVERSIEREN_4_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_REVERSIEREN_4_POS_HALL_WERT = (RXBUF_SINT(35));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_4_POS_HALL_WERT", STAT_FAH_REVERSIEREN_4_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_REVERSIEREN_4_KM_WERT = (RXBUF_UINT32(37));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_4_KM_WERT", STAT_FAH_REVERSIEREN_4_KM_WERT, "\"km\"");

    char STAT_FAH_REVERSIEREN_4_ATEMP_WERT = (RXBUF_SCHAR(41));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_4_ATEMP_WERT", STAT_FAH_REVERSIEREN_4_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FAH_REVERSIEREN_4_SPANNUNG_WERT = (RXBUF_UCHAR(42));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_4_SPANNUNG_WERT", STAT_FAH_REVERSIEREN_4_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FAH_REVERSIEREN_4_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(43));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_4_GESCHWINDIGKEIT_WERT", STAT_FAH_REVERSIEREN_4_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_FAH_REVERSIEREN_5_URSACHE_NR = (RXBUF_UCHAR(45));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_5_URSACHE_NR", STAT_FAH_REVERSIEREN_5_URSACHE_NR, "\"0-n\"");

    short STAT_FAH_REVERSIEREN_5_POS_HALL_WERT = (RXBUF_SINT(46));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_5_POS_HALL_WERT", STAT_FAH_REVERSIEREN_5_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_FAH_REVERSIEREN_5_KM_WERT = (RXBUF_UINT32(48));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_5_KM_WERT", STAT_FAH_REVERSIEREN_5_KM_WERT, "\"km\"");

    char STAT_FAH_REVERSIEREN_5_ATEMP_WERT = (RXBUF_SCHAR(52));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_5_ATEMP_WERT", STAT_FAH_REVERSIEREN_5_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_FAH_REVERSIEREN_5_SPANNUNG_WERT = (RXBUF_UCHAR(53));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_5_SPANNUNG_WERT", STAT_FAH_REVERSIEREN_5_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_FAH_REVERSIEREN_5_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(54));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_FAH_REVERSIEREN_5_GESCHWINDIGKEIT_WERT", STAT_FAH_REVERSIEREN_5_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BFH_REVERSIEREN_ZAEHLER_WERT = (RXBUF_UCHAR(56));
        // The reversing frequency is incremented with each reversing / Die Reversierhaeufigkeit wird bei jedem Reversier
        // inkrementiert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_ZAEHLER_WERT", STAT_BFH_REVERSIEREN_ZAEHLER_WERT, "\"Ink\"");

    unsigned char STAT_BFH_REVERSIEREN_1_URSACHE_NR = (RXBUF_UCHAR(57));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_1_URSACHE_NR", STAT_BFH_REVERSIEREN_1_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_REVERSIEREN_1_POS_HALL_WERT = (RXBUF_SINT(58));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_1_POS_HALL_WERT", STAT_BFH_REVERSIEREN_1_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_REVERSIEREN_1_KM_WERT = (RXBUF_UINT32(60));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_1_KM_WERT", STAT_BFH_REVERSIEREN_1_KM_WERT, "\"km\"");

    char STAT_BFH_REVERSIEREN_1_ATEMP_WERT = (RXBUF_SCHAR(64));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_1_ATEMP_WERT", STAT_BFH_REVERSIEREN_1_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BFH_REVERSIEREN_1_SPANNUNG_WERT = (RXBUF_UCHAR(65));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_1_SPANNUNG_WERT", STAT_BFH_REVERSIEREN_1_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BFH_REVERSIEREN_1_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(66));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_1_GESCHWINDIGKEIT_WERT", STAT_BFH_REVERSIEREN_1_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BFH_REVERSIEREN_2_URSACHE_NR = (RXBUF_UCHAR(68));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_2_URSACHE_NR", STAT_BFH_REVERSIEREN_2_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_REVERSIEREN_2_POS_HALL_WERT = (RXBUF_SINT(69));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_2_POS_HALL_WERT", STAT_BFH_REVERSIEREN_2_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_REVERSIEREN_2_KM_WERT = (RXBUF_UINT32(71));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_2_KM_WERT", STAT_BFH_REVERSIEREN_2_KM_WERT, "\"km\"");

    char STAT_BFH_REVERSIEREN_2_ATEMP_WERT = (RXBUF_SCHAR(75));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_2_ATEMP_WERT", STAT_BFH_REVERSIEREN_2_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BFH_REVERSIEREN_2_SPANNUNG_WERT = (RXBUF_UCHAR(76));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_2_SPANNUNG_WERT", STAT_BFH_REVERSIEREN_2_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BFH_REVERSIEREN_2_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(77));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_2_GESCHWINDIGKEIT_WERT", STAT_BFH_REVERSIEREN_2_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BFH_REVERSIEREN_3_URSACHE_NR = (RXBUF_UCHAR(79));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_3_URSACHE_NR", STAT_BFH_REVERSIEREN_3_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_REVERSIEREN_3_POS_HALL_WERT = (RXBUF_SINT(80));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_3_POS_HALL_WERT", STAT_BFH_REVERSIEREN_3_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_REVERSIEREN_3_KM_WERT = (RXBUF_UINT32(82));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_3_KM_WERT", STAT_BFH_REVERSIEREN_3_KM_WERT, "\"km\"");

    char STAT_BFH_REVERSIEREN_3_ATEMP_WERT = (RXBUF_SCHAR(86));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_3_ATEMP_WERT", STAT_BFH_REVERSIEREN_3_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BFH_REVERSIEREN_3_SPANNUNG_WERT = (RXBUF_UCHAR(87));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_3_SPANNUNG_WERT", STAT_BFH_REVERSIEREN_3_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BFH_REVERSIEREN_3_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(88));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_3_GESCHWINDIGKEIT_WERT", STAT_BFH_REVERSIEREN_3_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BFH_REVERSIEREN_4_URSACHE_NR = (RXBUF_UCHAR(90));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_4_URSACHE_NR", STAT_BFH_REVERSIEREN_4_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_REVERSIEREN_4_POS_HALL_WERT = (RXBUF_SINT(91));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_4_POS_HALL_WERT", STAT_BFH_REVERSIEREN_4_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_REVERSIEREN_4_KM_WERT = (RXBUF_UINT32(93));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_4_KM_WERT", STAT_BFH_REVERSIEREN_4_KM_WERT, "\"km\"");

    char STAT_BFH_REVERSIEREN_4_ATEMP_WERT = (RXBUF_SCHAR(97));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_4_ATEMP_WERT", STAT_BFH_REVERSIEREN_4_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BFH_REVERSIEREN_4_SPANNUNG_WERT = (RXBUF_UCHAR(98));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_4_SPANNUNG_WERT", STAT_BFH_REVERSIEREN_4_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BFH_REVERSIEREN_4_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(99));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_4_GESCHWINDIGKEIT_WERT", STAT_BFH_REVERSIEREN_4_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    unsigned char STAT_BFH_REVERSIEREN_5_URSACHE_NR = (RXBUF_UCHAR(101));
        // Reversal cause (1 byte); Create a list with standardized values and then an area that can be occupied by the
        // supplier. / Reversier-Ursache (1Byte); Liste erstellen mit vereinheitlichten Werten und nachfolgend einem
        // Bereich der vom Lieferanten belegt werden kann.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_5_URSACHE_NR", STAT_BFH_REVERSIEREN_5_URSACHE_NR, "\"0-n\"");

    short STAT_BFH_REVERSIEREN_5_POS_HALL_WERT = (RXBUF_SINT(102));
        // Specification of hall increments / Angabe Hallinkremente
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_5_POS_HALL_WERT", STAT_BFH_REVERSIEREN_5_POS_HALL_WERT, "\"Ink\"");

    unsigned long STAT_BFH_REVERSIEREN_5_KM_WERT = (RXBUF_UINT32(104));
        // Indication of mileage / Angabe Kilometerstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_5_KM_WERT", STAT_BFH_REVERSIEREN_5_KM_WERT, "\"km\"");

    char STAT_BFH_REVERSIEREN_5_ATEMP_WERT = (RXBUF_SCHAR(108));
        // Outside temperature (from CAN signal) / Aussentemperatur (aus CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_5_ATEMP_WERT", STAT_BFH_REVERSIEREN_5_ATEMP_WERT, "\"°C\"");

    unsigned char STAT_BFH_REVERSIEREN_5_SPANNUNG_WERT = (RXBUF_UCHAR(109));
        // Operating voltage (output to FH drive) / Betriebsspannung (Ausgang zu FH-Antrieb)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_5_SPANNUNG_WERT", STAT_BFH_REVERSIEREN_5_SPANNUNG_WERT, "\"V\"");

    unsigned short STAT_BFH_REVERSIEREN_5_GESCHWINDIGKEIT_WERT = (RXBUF_UINT(110));
        // Vehicle speed (coding analogue to CAN signal) / Fahrzeuggeschwindigkeit (Codierung analog CAN-Signal)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "BDC", "_FH_REVERSIER_LOGGER_LESEN_REAR", "STAT_BFH_REVERSIEREN_5_GESCHWINDIGKEIT_WERT", STAT_BFH_REVERSIEREN_5_GESCHWINDIGKEIT_WERT, "\"km/h\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_MOTORSTOP_LOGGER_LESEN_FRONT: {                             // 0x6042
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_MOTORSTOP_LOGGER_LESEN_FRONT", 20);
        break;
    }

    unsigned char STAT_FA_STOPREASON_1_NR = (RXBUF_UCHAR(0));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_1_NR", STAT_FA_STOPREASON_1_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_2_NR = (RXBUF_UCHAR(1));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_2_NR", STAT_FA_STOPREASON_2_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_3_NR = (RXBUF_UCHAR(2));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_3_NR", STAT_FA_STOPREASON_3_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_4_NR = (RXBUF_UCHAR(3));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_4_NR", STAT_FA_STOPREASON_4_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_5_NR = (RXBUF_UCHAR(4));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_5_NR", STAT_FA_STOPREASON_5_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_6_NR = (RXBUF_UCHAR(5));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_6_NR", STAT_FA_STOPREASON_6_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_7_NR = (RXBUF_UCHAR(6));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_7_NR", STAT_FA_STOPREASON_7_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_8_NR = (RXBUF_UCHAR(7));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_8_NR", STAT_FA_STOPREASON_8_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_9_NR = (RXBUF_UCHAR(8));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_9_NR", STAT_FA_STOPREASON_9_NR, "\"0-n\"");

    unsigned char STAT_FA_STOPREASON_10_NR = (RXBUF_UCHAR(9));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_FA_STOPREASON_10_NR", STAT_FA_STOPREASON_10_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_1_NR = (RXBUF_UCHAR(10));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_1_NR", STAT_BF_STOPREASON_1_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_2_NR = (RXBUF_UCHAR(11));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_2_NR", STAT_BF_STOPREASON_2_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_3_NR = (RXBUF_UCHAR(12));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_3_NR", STAT_BF_STOPREASON_3_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_4_NR = (RXBUF_UCHAR(13));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_4_NR", STAT_BF_STOPREASON_4_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_5_NR = (RXBUF_UCHAR(14));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_5_NR", STAT_BF_STOPREASON_5_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_6_NR = (RXBUF_UCHAR(15));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_6_NR", STAT_BF_STOPREASON_6_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_7_NR = (RXBUF_UCHAR(16));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_7_NR", STAT_BF_STOPREASON_7_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_8_NR = (RXBUF_UCHAR(17));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_8_NR", STAT_BF_STOPREASON_8_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_9_NR = (RXBUF_UCHAR(18));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_9_NR", STAT_BF_STOPREASON_9_NR, "\"0-n\"");

    unsigned char STAT_BF_STOPREASON_10_NR = (RXBUF_UCHAR(19));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_FRONT", "STAT_BF_STOPREASON_10_NR", STAT_BF_STOPREASON_10_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__FH_MOTORSTOP_LOGGER_LESEN_REAR: {                              // 0x6043
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_BDC__FH_MOTORSTOP_LOGGER_LESEN_REAR", 20);
        break;
    }

    unsigned char STAT_FAH_STOPREASON_1_NR = (RXBUF_UCHAR(0));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_1_NR", STAT_FAH_STOPREASON_1_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_2_NR = (RXBUF_UCHAR(1));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_2_NR", STAT_FAH_STOPREASON_2_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_3_NR = (RXBUF_UCHAR(2));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_3_NR", STAT_FAH_STOPREASON_3_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_4_NR = (RXBUF_UCHAR(3));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_4_NR", STAT_FAH_STOPREASON_4_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_5_NR = (RXBUF_UCHAR(4));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_5_NR", STAT_FAH_STOPREASON_5_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_6_NR = (RXBUF_UCHAR(5));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_6_NR", STAT_FAH_STOPREASON_6_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_7_NR = (RXBUF_UCHAR(6));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_7_NR", STAT_FAH_STOPREASON_7_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_8_NR = (RXBUF_UCHAR(7));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_8_NR", STAT_FAH_STOPREASON_8_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_9_NR = (RXBUF_UCHAR(8));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_9_NR", STAT_FAH_STOPREASON_9_NR, "\"0-n\"");

    unsigned char STAT_FAH_STOPREASON_10_NR = (RXBUF_UCHAR(9));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_FAH_STOPREASON_10_NR", STAT_FAH_STOPREASON_10_NR, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_1 = (RXBUF_UCHAR(10));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_1", STAT_BFH_STOPREASON_1, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_2 = (RXBUF_UCHAR(11));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_2", STAT_BFH_STOPREASON_2, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_3_NR = (RXBUF_UCHAR(12));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_3_NR", STAT_BFH_STOPREASON_3_NR, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_4_NR = (RXBUF_UCHAR(13));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_4_NR", STAT_BFH_STOPREASON_4_NR, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_5_NR = (RXBUF_UCHAR(14));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_5_NR", STAT_BFH_STOPREASON_5_NR, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_6_NR = (RXBUF_UCHAR(15));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_6_NR", STAT_BFH_STOPREASON_6_NR, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_7_NR = (RXBUF_UCHAR(16));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_7_NR", STAT_BFH_STOPREASON_7_NR, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_8_NR = (RXBUF_UCHAR(17));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_8_NR", STAT_BFH_STOPREASON_8_NR, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_9_NR = (RXBUF_UCHAR(18));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_9_NR", STAT_BFH_STOPREASON_9_NR, "\"0-n\"");

    unsigned char STAT_BFH_STOPREASON_10_NR = (RXBUF_UCHAR(19));
        // Reason for the engine stop / Grund des Motorstops
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "BDC", "_FH_MOTORSTOP_LOGGER_LESEN_REAR", "STAT_BFH_STOPREASON_10_NR", STAT_BFH_STOPREASON_10_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__STEUERN_DFZ_VERBINDUNGSENDE: {                                 // 0xF003
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__ECU_HW_RESET: {                                                // 0xF005
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_BDC__LWR_STATISTIK_RESET: {                                         // 0xF105
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }
