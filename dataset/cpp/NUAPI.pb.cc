// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NUAPI.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "NUAPI.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace API {

namespace {

const ::google::protobuf::Descriptor* Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Message_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Message_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Image_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_reflection_ = NULL;
const ::google::protobuf::Descriptor* VisionFieldObject_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VisionFieldObject_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* VisionFieldObject_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* VisionClassifiedSegment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VisionClassifiedSegment_reflection_ = NULL;
const ::google::protobuf::Descriptor* VisionClassifiedImage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VisionClassifiedImage_reflection_ = NULL;
const ::google::protobuf::Descriptor* Vision_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vision_reflection_ = NULL;
const ::google::protobuf::Descriptor* Motor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Motor_reflection_ = NULL;
const ::google::protobuf::Descriptor* SensorData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SensorData_reflection_ = NULL;
const ::google::protobuf::Descriptor* LocalisationFieldObject_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LocalisationFieldObject_reflection_ = NULL;
const ::google::protobuf::Descriptor* Localisation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Localisation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Vector_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vector_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_NUAPI_2eproto() {
  protobuf_AddDesc_NUAPI_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "NUAPI.proto");
  GOOGLE_CHECK(file != NULL);
  Message_descriptor_ = file->message_type(0);
  static const int Message_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, utc_timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, sensor_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, vision_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, localisation_),
  };
  Message_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Message_descriptor_,
      Message::default_instance_,
      Message_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Message));
  Message_Type_descriptor_ = Message_descriptor_->enum_type(0);
  Image_descriptor_ = file->message_type(1);
  static const int Image_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, data_),
  };
  Image_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Image_descriptor_,
      Image::default_instance_,
      Image_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Image));
  VisionFieldObject_descriptor_ = file->message_type(2);
  static const int VisionFieldObject_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, visible_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, screen_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, screen_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, rotation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, points_),
  };
  VisionFieldObject_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VisionFieldObject_descriptor_,
      VisionFieldObject::default_instance_,
      VisionFieldObject_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionFieldObject, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VisionFieldObject));
  VisionFieldObject_Type_descriptor_ = VisionFieldObject_descriptor_->enum_type(0);
  VisionClassifiedSegment_descriptor_ = file->message_type(3);
  static const int VisionClassifiedSegment_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedSegment, start_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedSegment, start_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedSegment, end_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedSegment, end_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedSegment, colour_),
  };
  VisionClassifiedSegment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VisionClassifiedSegment_descriptor_,
      VisionClassifiedSegment::default_instance_,
      VisionClassifiedSegment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedSegment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedSegment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VisionClassifiedSegment));
  VisionClassifiedImage_descriptor_ = file->message_type(4);
  static const int VisionClassifiedImage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedImage, num_segments_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedImage, segment_),
  };
  VisionClassifiedImage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VisionClassifiedImage_descriptor_,
      VisionClassifiedImage::default_instance_,
      VisionClassifiedImage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedImage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisionClassifiedImage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VisionClassifiedImage));
  Vision_descriptor_ = file->message_type(5);
  static const int Vision_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vision, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vision, field_object_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vision, classified_image_),
  };
  Vision_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Vision_descriptor_,
      Vision::default_instance_,
      Vision_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vision, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vision, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Vision));
  Motor_descriptor_ = file->message_type(6);
  static const int Motor_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, acceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, target_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, stiffness_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, current_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, torque_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, temperature_),
  };
  Motor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Motor_descriptor_,
      Motor::default_instance_,
      Motor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Motor));
  SensorData_descriptor_ = file->message_type(7);
  static const int SensorData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorData, motor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorData, accelerometer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorData, gyro_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorData, orientation_),
  };
  SensorData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SensorData_descriptor_,
      SensorData::default_instance_,
      SensorData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SensorData));
  LocalisationFieldObject_descriptor_ = file->message_type(8);
  static const int LocalisationFieldObject_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, wm_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, wm_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, sd_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, sd_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, sr_xx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, sr_xy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, sr_yy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, heading_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, sd_heading_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, lost_),
  };
  LocalisationFieldObject_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LocalisationFieldObject_descriptor_,
      LocalisationFieldObject::default_instance_,
      LocalisationFieldObject_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocalisationFieldObject, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LocalisationFieldObject));
  Localisation_descriptor_ = file->message_type(9);
  static const int Localisation_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Localisation, field_object_),
  };
  Localisation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Localisation_descriptor_,
      Localisation::default_instance_,
      Localisation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Localisation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Localisation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Localisation));
  Vector_descriptor_ = file->message_type(10);
  static const int Vector_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, float_value_),
  };
  Vector_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Vector_descriptor_,
      Vector::default_instance_,
      Vector_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Vector));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_NUAPI_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Message_descriptor_, &Message::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Image_descriptor_, &Image::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VisionFieldObject_descriptor_, &VisionFieldObject::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VisionClassifiedSegment_descriptor_, &VisionClassifiedSegment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VisionClassifiedImage_descriptor_, &VisionClassifiedImage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Vision_descriptor_, &Vision::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Motor_descriptor_, &Motor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SensorData_descriptor_, &SensorData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LocalisationFieldObject_descriptor_, &LocalisationFieldObject::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Localisation_descriptor_, &Localisation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Vector_descriptor_, &Vector::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_NUAPI_2eproto() {
  delete Message::default_instance_;
  delete Message_reflection_;
  delete Image::default_instance_;
  delete Image_reflection_;
  delete VisionFieldObject::default_instance_;
  delete VisionFieldObject_reflection_;
  delete VisionClassifiedSegment::default_instance_;
  delete VisionClassifiedSegment_reflection_;
  delete VisionClassifiedImage::default_instance_;
  delete VisionClassifiedImage_reflection_;
  delete Vision::default_instance_;
  delete Vision_reflection_;
  delete Motor::default_instance_;
  delete Motor_reflection_;
  delete SensorData::default_instance_;
  delete SensorData_reflection_;
  delete LocalisationFieldObject::default_instance_;
  delete LocalisationFieldObject_reflection_;
  delete Localisation::default_instance_;
  delete Localisation_reflection_;
  delete Vector::default_instance_;
  delete Vector_reflection_;
}

void protobuf_AddDesc_NUAPI_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013NUAPI.proto\022\003API\"\344\001\n\007Message\022\037\n\004type\030\001"
    " \002(\0162\021.API.Message.Type\022\025\n\rutc_timestamp"
    "\030\002 \002(\004\022$\n\013sensor_data\030\003 \001(\0132\017.API.Sensor"
    "Data\022\033\n\006vision\030\004 \001(\0132\013.API.Vision\022\'\n\014loc"
    "alisation\030\005 \001(\0132\021.API.Localisation\"5\n\004Ty"
    "pe\022\017\n\013SENSOR_DATA\020\001\022\n\n\006VISION\020\002\022\020\n\014LOCAL"
    "ISATION\020\003\"4\n\005Image\022\r\n\005width\030\001 \001(\r\022\016\n\006hei"
    "ght\030\002 \001(\r\022\014\n\004data\030\003 \001(\014\"\233\002\n\021VisionFieldO"
    "bject\022)\n\004type\030\001 \001(\0162\033.API.VisionFieldObj"
    "ect.Type\022\n\n\002id\030\002 \001(\r\022\014\n\004name\030\003 \001(\t\022\017\n\007vi"
    "sible\030\004 \001(\010\022\020\n\010screen_x\030\005 \001(\002\022\020\n\010screen_"
    "y\030\006 \001(\002\022\020\n\010rotation\030\007 \001(\002\022\016\n\006radius\030\010 \001("
    "\r\022\r\n\005width\030\t \001(\r\022\016\n\006height\030\n \001(\r\022\016\n\006poin"
    "ts\030\013 \003(\r\";\n\004Type\022\n\n\006CIRCLE\020\001\022\r\n\tRECTANGL"
    "E\020\002\022\013\n\007POLYGON\020\003\022\013\n\007UNKNOWN\020\004\"i\n\027VisionC"
    "lassifiedSegment\022\017\n\007start_x\030\001 \001(\r\022\017\n\007sta"
    "rt_y\030\002 \001(\r\022\r\n\005end_x\030\003 \001(\r\022\r\n\005end_y\030\004 \001(\r"
    "\022\016\n\006colour\030\005 \001(\r\"\\\n\025VisionClassifiedImag"
    "e\022\024\n\014num_segments\030\001 \001(\r\022-\n\007segment\030\002 \003(\013"
    "2\034.API.VisionClassifiedSegment\"\207\001\n\006Visio"
    "n\022\031\n\005image\030\001 \001(\0132\n.API.Image\022,\n\014field_ob"
    "ject\030\002 \003(\0132\026.API.VisionFieldObject\0224\n\020cl"
    "assified_image\030\003 \001(\0132\032.API.VisionClassif"
    "iedImage\"\250\001\n\005Motor\022\014\n\004name\030\001 \001(\t\022\020\n\010posi"
    "tion\030\002 \001(\002\022\020\n\010velocity\030\003 \001(\002\022\024\n\014accelera"
    "tion\030\004 \001(\002\022\016\n\006target\030\005 \001(\002\022\021\n\tstiffness\030"
    "\006 \001(\002\022\017\n\007current\030\007 \001(\002\022\016\n\006torque\030\010 \001(\002\022\023"
    "\n\013temperature\030\t \001(\002\"\210\001\n\nSensorData\022\031\n\005mo"
    "tor\030\001 \003(\0132\n.API.Motor\022\"\n\raccelerometer\030\002"
    " \001(\0132\013.API.Vector\022\031\n\004gyro\030\003 \001(\0132\013.API.Ve"
    "ctor\022 \n\013orientation\030\004 \001(\0132\013.API.Vector\"\277"
    "\001\n\027LocalisationFieldObject\022\014\n\004name\030\001 \001(\t"
    "\022\014\n\004wm_x\030\002 \001(\002\022\014\n\004wm_y\030\003 \001(\002\022\014\n\004sd_x\030\004 \001"
    "(\002\022\014\n\004sd_y\030\005 \001(\002\022\r\n\005sr_xx\030\006 \001(\002\022\r\n\005sr_xy"
    "\030\007 \001(\002\022\r\n\005sr_yy\030\010 \001(\002\022\017\n\007heading\030\t \001(\002\022\022"
    "\n\nsd_heading\030\n \001(\002\022\014\n\004lost\030\013 \001(\010\"B\n\014Loca"
    "lisation\0222\n\014field_object\030\001 \003(\0132\034.API.Loc"
    "alisationFieldObject\"\035\n\006Vector\022\023\n\013float_"
    "value\030\001 \003(\002", 1531);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "NUAPI.proto", &protobuf_RegisterTypes);
  Message::default_instance_ = new Message();
  Image::default_instance_ = new Image();
  VisionFieldObject::default_instance_ = new VisionFieldObject();
  VisionClassifiedSegment::default_instance_ = new VisionClassifiedSegment();
  VisionClassifiedImage::default_instance_ = new VisionClassifiedImage();
  Vision::default_instance_ = new Vision();
  Motor::default_instance_ = new Motor();
  SensorData::default_instance_ = new SensorData();
  LocalisationFieldObject::default_instance_ = new LocalisationFieldObject();
  Localisation::default_instance_ = new Localisation();
  Vector::default_instance_ = new Vector();
  Message::default_instance_->InitAsDefaultInstance();
  Image::default_instance_->InitAsDefaultInstance();
  VisionFieldObject::default_instance_->InitAsDefaultInstance();
  VisionClassifiedSegment::default_instance_->InitAsDefaultInstance();
  VisionClassifiedImage::default_instance_->InitAsDefaultInstance();
  Vision::default_instance_->InitAsDefaultInstance();
  Motor::default_instance_->InitAsDefaultInstance();
  SensorData::default_instance_->InitAsDefaultInstance();
  LocalisationFieldObject::default_instance_->InitAsDefaultInstance();
  Localisation::default_instance_->InitAsDefaultInstance();
  Vector::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_NUAPI_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_NUAPI_2eproto {
  StaticDescriptorInitializer_NUAPI_2eproto() {
    protobuf_AddDesc_NUAPI_2eproto();
  }
} static_descriptor_initializer_NUAPI_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_Type_descriptor_;
}
bool Message_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Message_Type Message::SENSOR_DATA;
const Message_Type Message::VISION;
const Message_Type Message::LOCALISATION;
const Message_Type Message::Type_MIN;
const Message_Type Message::Type_MAX;
const int Message::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Message::kTypeFieldNumber;
const int Message::kUtcTimestampFieldNumber;
const int Message::kSensorDataFieldNumber;
const int Message::kVisionFieldNumber;
const int Message::kLocalisationFieldNumber;
#endif  // !_MSC_VER

Message::Message()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Message::InitAsDefaultInstance() {
  sensor_data_ = const_cast< ::API::SensorData*>(&::API::SensorData::default_instance());
  vision_ = const_cast< ::API::Vision*>(&::API::Vision::default_instance());
  localisation_ = const_cast< ::API::Localisation*>(&::API::Localisation::default_instance());
}

Message::Message(const Message& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Message::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  utc_timestamp_ = GOOGLE_ULONGLONG(0);
  sensor_data_ = NULL;
  vision_ = NULL;
  localisation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Message::~Message() {
  SharedDtor();
}

void Message::SharedDtor() {
  if (this != default_instance_) {
    delete sensor_data_;
    delete vision_;
    delete localisation_;
  }
}

void Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_descriptor_;
}

const Message& Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

Message* Message::default_instance_ = NULL;

Message* Message::New() const {
  return new Message;
}

void Message::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    utc_timestamp_ = GOOGLE_ULONGLONG(0);
    if (has_sensor_data()) {
      if (sensor_data_ != NULL) sensor_data_->::API::SensorData::Clear();
    }
    if (has_vision()) {
      if (vision_ != NULL) vision_->::API::Vision::Clear();
    }
    if (has_localisation()) {
      if (localisation_ != NULL) localisation_->::API::Localisation::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .API.Message.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::API::Message_Type_IsValid(value)) {
            set_type(static_cast< ::API::Message_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_utc_timestamp;
        break;
      }

      // required uint64 utc_timestamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_utc_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &utc_timestamp_)));
          set_has_utc_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sensor_data;
        break;
      }

      // optional .API.SensorData sensor_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sensor_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sensor_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_vision;
        break;
      }

      // optional .API.Vision vision = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vision:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vision()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_localisation;
        break;
      }

      // optional .API.Localisation localisation = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_localisation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_localisation()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .API.Message.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required uint64 utc_timestamp = 2;
  if (has_utc_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->utc_timestamp(), output);
  }

  // optional .API.SensorData sensor_data = 3;
  if (has_sensor_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->sensor_data(), output);
  }

  // optional .API.Vision vision = 4;
  if (has_vision()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->vision(), output);
  }

  // optional .API.Localisation localisation = 5;
  if (has_localisation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->localisation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Message::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .API.Message.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required uint64 utc_timestamp = 2;
  if (has_utc_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->utc_timestamp(), target);
  }

  // optional .API.SensorData sensor_data = 3;
  if (has_sensor_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->sensor_data(), target);
  }

  // optional .API.Vision vision = 4;
  if (has_vision()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->vision(), target);
  }

  // optional .API.Localisation localisation = 5;
  if (has_localisation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->localisation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Message::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .API.Message.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required uint64 utc_timestamp = 2;
    if (has_utc_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->utc_timestamp());
    }

    // optional .API.SensorData sensor_data = 3;
    if (has_sensor_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sensor_data());
    }

    // optional .API.Vision vision = 4;
    if (has_vision()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vision());
    }

    // optional .API.Localisation localisation = 5;
    if (has_localisation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->localisation());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Message::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Message* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Message*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Message::MergeFrom(const Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_utc_timestamp()) {
      set_utc_timestamp(from.utc_timestamp());
    }
    if (from.has_sensor_data()) {
      mutable_sensor_data()->::API::SensorData::MergeFrom(from.sensor_data());
    }
    if (from.has_vision()) {
      mutable_vision()->::API::Vision::MergeFrom(from.vision());
    }
    if (from.has_localisation()) {
      mutable_localisation()->::API::Localisation::MergeFrom(from.localisation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Message::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Message::CopyFrom(const Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Message::Swap(Message* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(utc_timestamp_, other->utc_timestamp_);
    std::swap(sensor_data_, other->sensor_data_);
    std::swap(vision_, other->vision_);
    std::swap(localisation_, other->localisation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Message_descriptor_;
  metadata.reflection = Message_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Image::kWidthFieldNumber;
const int Image::kHeightFieldNumber;
const int Image::kDataFieldNumber;
#endif  // !_MSC_VER

Image::Image()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Image::InitAsDefaultInstance() {
}

Image::Image(const Image& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Image::SharedCtor() {
  _cached_size_ = 0;
  width_ = 0u;
  height_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image::~Image() {
  SharedDtor();
}

void Image::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_descriptor_;
}

const Image& Image::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New() const {
  return new Image;
}

void Image::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    width_ = 0u;
    height_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 width = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // optional uint32 height = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // optional bytes data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 width = 1;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->width(), output);
  }

  // optional uint32 height = 2;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->height(), output);
  }

  // optional bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Image::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 width = 1;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->width(), target);
  }

  // optional uint32 height = 2;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->height(), target);
  }

  // optional bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Image::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 width = 1;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->width());
    }

    // optional uint32 height = 2;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->height());
    }

    // optional bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Image* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Image*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Image::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {

  return true;
}

void Image::Swap(Image* other) {
  if (other != this) {
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Image::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_descriptor_;
  metadata.reflection = Image_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* VisionFieldObject_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VisionFieldObject_Type_descriptor_;
}
bool VisionFieldObject_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const VisionFieldObject_Type VisionFieldObject::CIRCLE;
const VisionFieldObject_Type VisionFieldObject::RECTANGLE;
const VisionFieldObject_Type VisionFieldObject::POLYGON;
const VisionFieldObject_Type VisionFieldObject::UNKNOWN;
const VisionFieldObject_Type VisionFieldObject::Type_MIN;
const VisionFieldObject_Type VisionFieldObject::Type_MAX;
const int VisionFieldObject::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int VisionFieldObject::kTypeFieldNumber;
const int VisionFieldObject::kIdFieldNumber;
const int VisionFieldObject::kNameFieldNumber;
const int VisionFieldObject::kVisibleFieldNumber;
const int VisionFieldObject::kScreenXFieldNumber;
const int VisionFieldObject::kScreenYFieldNumber;
const int VisionFieldObject::kRotationFieldNumber;
const int VisionFieldObject::kRadiusFieldNumber;
const int VisionFieldObject::kWidthFieldNumber;
const int VisionFieldObject::kHeightFieldNumber;
const int VisionFieldObject::kPointsFieldNumber;
#endif  // !_MSC_VER

VisionFieldObject::VisionFieldObject()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VisionFieldObject::InitAsDefaultInstance() {
}

VisionFieldObject::VisionFieldObject(const VisionFieldObject& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VisionFieldObject::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  id_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  visible_ = false;
  screen_x_ = 0;
  screen_y_ = 0;
  rotation_ = 0;
  radius_ = 0u;
  width_ = 0u;
  height_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VisionFieldObject::~VisionFieldObject() {
  SharedDtor();
}

void VisionFieldObject::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void VisionFieldObject::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VisionFieldObject::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VisionFieldObject_descriptor_;
}

const VisionFieldObject& VisionFieldObject::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

VisionFieldObject* VisionFieldObject::default_instance_ = NULL;

VisionFieldObject* VisionFieldObject::New() const {
  return new VisionFieldObject;
}

void VisionFieldObject::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    id_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    visible_ = false;
    screen_x_ = 0;
    screen_y_ = 0;
    rotation_ = 0;
    radius_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    width_ = 0u;
    height_ = 0u;
  }
  points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VisionFieldObject::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .API.VisionFieldObject.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::API::VisionFieldObject_Type_IsValid(value)) {
            set_type(static_cast< ::API::VisionFieldObject_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional uint32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional string name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_visible;
        break;
      }

      // optional bool visible = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_visible:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &visible_)));
          set_has_visible();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_screen_x;
        break;
      }

      // optional float screen_x = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_screen_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &screen_x_)));
          set_has_screen_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_screen_y;
        break;
      }

      // optional float screen_y = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_screen_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &screen_y_)));
          set_has_screen_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_rotation;
        break;
      }

      // optional float rotation = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotation_)));
          set_has_rotation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_radius;
        break;
      }

      // optional uint32 radius = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_width;
        break;
      }

      // optional uint32 width = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_height;
        break;
      }

      // optional uint32 height = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_points;
        break;
      }

      // repeated uint32 points = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_points:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 88, input, this->mutable_points())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_points())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_points;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VisionFieldObject::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .API.VisionFieldObject.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->name(), output);
  }

  // optional bool visible = 4;
  if (has_visible()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->visible(), output);
  }

  // optional float screen_x = 5;
  if (has_screen_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->screen_x(), output);
  }

  // optional float screen_y = 6;
  if (has_screen_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->screen_y(), output);
  }

  // optional float rotation = 7;
  if (has_rotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->rotation(), output);
  }

  // optional uint32 radius = 8;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->radius(), output);
  }

  // optional uint32 width = 9;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->width(), output);
  }

  // optional uint32 height = 10;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->height(), output);
  }

  // repeated uint32 points = 11;
  for (int i = 0; i < this->points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      11, this->points(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VisionFieldObject::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .API.VisionFieldObject.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional uint32 id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->id(), target);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // optional bool visible = 4;
  if (has_visible()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->visible(), target);
  }

  // optional float screen_x = 5;
  if (has_screen_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->screen_x(), target);
  }

  // optional float screen_y = 6;
  if (has_screen_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->screen_y(), target);
  }

  // optional float rotation = 7;
  if (has_rotation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->rotation(), target);
  }

  // optional uint32 radius = 8;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->radius(), target);
  }

  // optional uint32 width = 9;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->width(), target);
  }

  // optional uint32 height = 10;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->height(), target);
  }

  // repeated uint32 points = 11;
  for (int i = 0; i < this->points_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(11, this->points(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VisionFieldObject::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .API.VisionFieldObject.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bool visible = 4;
    if (has_visible()) {
      total_size += 1 + 1;
    }

    // optional float screen_x = 5;
    if (has_screen_x()) {
      total_size += 1 + 4;
    }

    // optional float screen_y = 6;
    if (has_screen_y()) {
      total_size += 1 + 4;
    }

    // optional float rotation = 7;
    if (has_rotation()) {
      total_size += 1 + 4;
    }

    // optional uint32 radius = 8;
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->radius());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 width = 9;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->width());
    }

    // optional uint32 height = 10;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->height());
    }

  }
  // repeated uint32 points = 11;
  {
    int data_size = 0;
    for (int i = 0; i < this->points_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->points(i));
    }
    total_size += 1 * this->points_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VisionFieldObject::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VisionFieldObject* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VisionFieldObject*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VisionFieldObject::MergeFrom(const VisionFieldObject& from) {
  GOOGLE_CHECK_NE(&from, this);
  points_.MergeFrom(from.points_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_visible()) {
      set_visible(from.visible());
    }
    if (from.has_screen_x()) {
      set_screen_x(from.screen_x());
    }
    if (from.has_screen_y()) {
      set_screen_y(from.screen_y());
    }
    if (from.has_rotation()) {
      set_rotation(from.rotation());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VisionFieldObject::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VisionFieldObject::CopyFrom(const VisionFieldObject& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisionFieldObject::IsInitialized() const {

  return true;
}

void VisionFieldObject::Swap(VisionFieldObject* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(visible_, other->visible_);
    std::swap(screen_x_, other->screen_x_);
    std::swap(screen_y_, other->screen_y_);
    std::swap(rotation_, other->rotation_);
    std::swap(radius_, other->radius_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    points_.Swap(&other->points_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VisionFieldObject::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VisionFieldObject_descriptor_;
  metadata.reflection = VisionFieldObject_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VisionClassifiedSegment::kStartXFieldNumber;
const int VisionClassifiedSegment::kStartYFieldNumber;
const int VisionClassifiedSegment::kEndXFieldNumber;
const int VisionClassifiedSegment::kEndYFieldNumber;
const int VisionClassifiedSegment::kColourFieldNumber;
#endif  // !_MSC_VER

VisionClassifiedSegment::VisionClassifiedSegment()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VisionClassifiedSegment::InitAsDefaultInstance() {
}

VisionClassifiedSegment::VisionClassifiedSegment(const VisionClassifiedSegment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VisionClassifiedSegment::SharedCtor() {
  _cached_size_ = 0;
  start_x_ = 0u;
  start_y_ = 0u;
  end_x_ = 0u;
  end_y_ = 0u;
  colour_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VisionClassifiedSegment::~VisionClassifiedSegment() {
  SharedDtor();
}

void VisionClassifiedSegment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VisionClassifiedSegment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VisionClassifiedSegment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VisionClassifiedSegment_descriptor_;
}

const VisionClassifiedSegment& VisionClassifiedSegment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

VisionClassifiedSegment* VisionClassifiedSegment::default_instance_ = NULL;

VisionClassifiedSegment* VisionClassifiedSegment::New() const {
  return new VisionClassifiedSegment;
}

void VisionClassifiedSegment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_x_ = 0u;
    start_y_ = 0u;
    end_x_ = 0u;
    end_y_ = 0u;
    colour_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VisionClassifiedSegment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 start_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_x_)));
          set_has_start_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_start_y;
        break;
      }

      // optional uint32 start_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_y_)));
          set_has_start_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_end_x;
        break;
      }

      // optional uint32 end_x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_x_)));
          set_has_end_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_end_y;
        break;
      }

      // optional uint32 end_y = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_y_)));
          set_has_end_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_colour;
        break;
      }

      // optional uint32 colour = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_colour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &colour_)));
          set_has_colour();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VisionClassifiedSegment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 start_x = 1;
  if (has_start_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->start_x(), output);
  }

  // optional uint32 start_y = 2;
  if (has_start_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->start_y(), output);
  }

  // optional uint32 end_x = 3;
  if (has_end_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->end_x(), output);
  }

  // optional uint32 end_y = 4;
  if (has_end_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->end_y(), output);
  }

  // optional uint32 colour = 5;
  if (has_colour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->colour(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VisionClassifiedSegment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 start_x = 1;
  if (has_start_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->start_x(), target);
  }

  // optional uint32 start_y = 2;
  if (has_start_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->start_y(), target);
  }

  // optional uint32 end_x = 3;
  if (has_end_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->end_x(), target);
  }

  // optional uint32 end_y = 4;
  if (has_end_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->end_y(), target);
  }

  // optional uint32 colour = 5;
  if (has_colour()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->colour(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VisionClassifiedSegment::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 start_x = 1;
    if (has_start_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->start_x());
    }

    // optional uint32 start_y = 2;
    if (has_start_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->start_y());
    }

    // optional uint32 end_x = 3;
    if (has_end_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_x());
    }

    // optional uint32 end_y = 4;
    if (has_end_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_y());
    }

    // optional uint32 colour = 5;
    if (has_colour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->colour());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VisionClassifiedSegment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VisionClassifiedSegment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VisionClassifiedSegment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VisionClassifiedSegment::MergeFrom(const VisionClassifiedSegment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_x()) {
      set_start_x(from.start_x());
    }
    if (from.has_start_y()) {
      set_start_y(from.start_y());
    }
    if (from.has_end_x()) {
      set_end_x(from.end_x());
    }
    if (from.has_end_y()) {
      set_end_y(from.end_y());
    }
    if (from.has_colour()) {
      set_colour(from.colour());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VisionClassifiedSegment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VisionClassifiedSegment::CopyFrom(const VisionClassifiedSegment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisionClassifiedSegment::IsInitialized() const {

  return true;
}

void VisionClassifiedSegment::Swap(VisionClassifiedSegment* other) {
  if (other != this) {
    std::swap(start_x_, other->start_x_);
    std::swap(start_y_, other->start_y_);
    std::swap(end_x_, other->end_x_);
    std::swap(end_y_, other->end_y_);
    std::swap(colour_, other->colour_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VisionClassifiedSegment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VisionClassifiedSegment_descriptor_;
  metadata.reflection = VisionClassifiedSegment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VisionClassifiedImage::kNumSegmentsFieldNumber;
const int VisionClassifiedImage::kSegmentFieldNumber;
#endif  // !_MSC_VER

VisionClassifiedImage::VisionClassifiedImage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VisionClassifiedImage::InitAsDefaultInstance() {
}

VisionClassifiedImage::VisionClassifiedImage(const VisionClassifiedImage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VisionClassifiedImage::SharedCtor() {
  _cached_size_ = 0;
  num_segments_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VisionClassifiedImage::~VisionClassifiedImage() {
  SharedDtor();
}

void VisionClassifiedImage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VisionClassifiedImage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VisionClassifiedImage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VisionClassifiedImage_descriptor_;
}

const VisionClassifiedImage& VisionClassifiedImage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

VisionClassifiedImage* VisionClassifiedImage::default_instance_ = NULL;

VisionClassifiedImage* VisionClassifiedImage::New() const {
  return new VisionClassifiedImage;
}

void VisionClassifiedImage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    num_segments_ = 0u;
  }
  segment_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VisionClassifiedImage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 num_segments = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_segments_)));
          set_has_num_segments();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_segment;
        break;
      }

      // repeated .API.VisionClassifiedSegment segment = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_segment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_segment()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_segment;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VisionClassifiedImage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 num_segments = 1;
  if (has_num_segments()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->num_segments(), output);
  }

  // repeated .API.VisionClassifiedSegment segment = 2;
  for (int i = 0; i < this->segment_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->segment(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VisionClassifiedImage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 num_segments = 1;
  if (has_num_segments()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->num_segments(), target);
  }

  // repeated .API.VisionClassifiedSegment segment = 2;
  for (int i = 0; i < this->segment_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->segment(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VisionClassifiedImage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 num_segments = 1;
    if (has_num_segments()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_segments());
    }

  }
  // repeated .API.VisionClassifiedSegment segment = 2;
  total_size += 1 * this->segment_size();
  for (int i = 0; i < this->segment_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->segment(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VisionClassifiedImage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VisionClassifiedImage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VisionClassifiedImage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VisionClassifiedImage::MergeFrom(const VisionClassifiedImage& from) {
  GOOGLE_CHECK_NE(&from, this);
  segment_.MergeFrom(from.segment_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num_segments()) {
      set_num_segments(from.num_segments());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VisionClassifiedImage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VisionClassifiedImage::CopyFrom(const VisionClassifiedImage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisionClassifiedImage::IsInitialized() const {

  return true;
}

void VisionClassifiedImage::Swap(VisionClassifiedImage* other) {
  if (other != this) {
    std::swap(num_segments_, other->num_segments_);
    segment_.Swap(&other->segment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VisionClassifiedImage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VisionClassifiedImage_descriptor_;
  metadata.reflection = VisionClassifiedImage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Vision::kImageFieldNumber;
const int Vision::kFieldObjectFieldNumber;
const int Vision::kClassifiedImageFieldNumber;
#endif  // !_MSC_VER

Vision::Vision()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Vision::InitAsDefaultInstance() {
  image_ = const_cast< ::API::Image*>(&::API::Image::default_instance());
  classified_image_ = const_cast< ::API::VisionClassifiedImage*>(&::API::VisionClassifiedImage::default_instance());
}

Vision::Vision(const Vision& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Vision::SharedCtor() {
  _cached_size_ = 0;
  image_ = NULL;
  classified_image_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vision::~Vision() {
  SharedDtor();
}

void Vision::SharedDtor() {
  if (this != default_instance_) {
    delete image_;
    delete classified_image_;
  }
}

void Vision::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vision::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vision_descriptor_;
}

const Vision& Vision::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

Vision* Vision::default_instance_ = NULL;

Vision* Vision::New() const {
  return new Vision;
}

void Vision::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_image()) {
      if (image_ != NULL) image_->::API::Image::Clear();
    }
    if (has_classified_image()) {
      if (classified_image_ != NULL) classified_image_->::API::VisionClassifiedImage::Clear();
    }
  }
  field_object_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Vision::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .API.Image image = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_field_object;
        break;
      }

      // repeated .API.VisionFieldObject field_object = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_field_object:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_field_object()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_field_object;
        if (input->ExpectTag(26)) goto parse_classified_image;
        break;
      }

      // optional .API.VisionClassifiedImage classified_image = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_classified_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_classified_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Vision::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .API.Image image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->image(), output);
  }

  // repeated .API.VisionFieldObject field_object = 2;
  for (int i = 0; i < this->field_object_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->field_object(i), output);
  }

  // optional .API.VisionClassifiedImage classified_image = 3;
  if (has_classified_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->classified_image(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Vision::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .API.Image image = 1;
  if (has_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->image(), target);
  }

  // repeated .API.VisionFieldObject field_object = 2;
  for (int i = 0; i < this->field_object_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->field_object(i), target);
  }

  // optional .API.VisionClassifiedImage classified_image = 3;
  if (has_classified_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->classified_image(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Vision::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .API.Image image = 1;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->image());
    }

    // optional .API.VisionClassifiedImage classified_image = 3;
    if (has_classified_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->classified_image());
    }

  }
  // repeated .API.VisionFieldObject field_object = 2;
  total_size += 1 * this->field_object_size();
  for (int i = 0; i < this->field_object_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->field_object(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vision::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Vision* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Vision*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vision::MergeFrom(const Vision& from) {
  GOOGLE_CHECK_NE(&from, this);
  field_object_.MergeFrom(from.field_object_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_image()) {
      mutable_image()->::API::Image::MergeFrom(from.image());
    }
    if (from.has_classified_image()) {
      mutable_classified_image()->::API::VisionClassifiedImage::MergeFrom(from.classified_image());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Vision::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vision::CopyFrom(const Vision& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vision::IsInitialized() const {

  return true;
}

void Vision::Swap(Vision* other) {
  if (other != this) {
    std::swap(image_, other->image_);
    field_object_.Swap(&other->field_object_);
    std::swap(classified_image_, other->classified_image_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Vision::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vision_descriptor_;
  metadata.reflection = Vision_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Motor::kNameFieldNumber;
const int Motor::kPositionFieldNumber;
const int Motor::kVelocityFieldNumber;
const int Motor::kAccelerationFieldNumber;
const int Motor::kTargetFieldNumber;
const int Motor::kStiffnessFieldNumber;
const int Motor::kCurrentFieldNumber;
const int Motor::kTorqueFieldNumber;
const int Motor::kTemperatureFieldNumber;
#endif  // !_MSC_VER

Motor::Motor()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Motor::InitAsDefaultInstance() {
}

Motor::Motor(const Motor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Motor::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  position_ = 0;
  velocity_ = 0;
  acceleration_ = 0;
  target_ = 0;
  stiffness_ = 0;
  current_ = 0;
  torque_ = 0;
  temperature_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Motor::~Motor() {
  SharedDtor();
}

void Motor::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Motor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Motor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Motor_descriptor_;
}

const Motor& Motor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

Motor* Motor::default_instance_ = NULL;

Motor* Motor::New() const {
  return new Motor;
}

void Motor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    position_ = 0;
    velocity_ = 0;
    acceleration_ = 0;
    target_ = 0;
    stiffness_ = 0;
    current_ = 0;
    torque_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    temperature_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Motor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_position;
        break;
      }

      // optional float position = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_position:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_velocity;
        break;
      }

      // optional float velocity = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_)));
          set_has_velocity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_acceleration;
        break;
      }

      // optional float acceleration = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_acceleration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acceleration_)));
          set_has_acceleration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_target;
        break;
      }

      // optional float target = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_target:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &target_)));
          set_has_target();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_stiffness;
        break;
      }

      // optional float stiffness = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_stiffness:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &stiffness_)));
          set_has_stiffness();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_current;
        break;
      }

      // optional float current = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_current:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &current_)));
          set_has_current();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_torque;
        break;
      }

      // optional float torque = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_torque:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &torque_)));
          set_has_torque();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_temperature;
        break;
      }

      // optional float temperature = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &temperature_)));
          set_has_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Motor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional float position = 2;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->position(), output);
  }

  // optional float velocity = 3;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->velocity(), output);
  }

  // optional float acceleration = 4;
  if (has_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->acceleration(), output);
  }

  // optional float target = 5;
  if (has_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->target(), output);
  }

  // optional float stiffness = 6;
  if (has_stiffness()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->stiffness(), output);
  }

  // optional float current = 7;
  if (has_current()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->current(), output);
  }

  // optional float torque = 8;
  if (has_torque()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->torque(), output);
  }

  // optional float temperature = 9;
  if (has_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->temperature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Motor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional float position = 2;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->position(), target);
  }

  // optional float velocity = 3;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->velocity(), target);
  }

  // optional float acceleration = 4;
  if (has_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->acceleration(), target);
  }

  // optional float target = 5;
  if (has_target()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->target(), target);
  }

  // optional float stiffness = 6;
  if (has_stiffness()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->stiffness(), target);
  }

  // optional float current = 7;
  if (has_current()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->current(), target);
  }

  // optional float torque = 8;
  if (has_torque()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->torque(), target);
  }

  // optional float temperature = 9;
  if (has_temperature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->temperature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Motor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional float position = 2;
    if (has_position()) {
      total_size += 1 + 4;
    }

    // optional float velocity = 3;
    if (has_velocity()) {
      total_size += 1 + 4;
    }

    // optional float acceleration = 4;
    if (has_acceleration()) {
      total_size += 1 + 4;
    }

    // optional float target = 5;
    if (has_target()) {
      total_size += 1 + 4;
    }

    // optional float stiffness = 6;
    if (has_stiffness()) {
      total_size += 1 + 4;
    }

    // optional float current = 7;
    if (has_current()) {
      total_size += 1 + 4;
    }

    // optional float torque = 8;
    if (has_torque()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float temperature = 9;
    if (has_temperature()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Motor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Motor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Motor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Motor::MergeFrom(const Motor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_position()) {
      set_position(from.position());
    }
    if (from.has_velocity()) {
      set_velocity(from.velocity());
    }
    if (from.has_acceleration()) {
      set_acceleration(from.acceleration());
    }
    if (from.has_target()) {
      set_target(from.target());
    }
    if (from.has_stiffness()) {
      set_stiffness(from.stiffness());
    }
    if (from.has_current()) {
      set_current(from.current());
    }
    if (from.has_torque()) {
      set_torque(from.torque());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_temperature()) {
      set_temperature(from.temperature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Motor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Motor::CopyFrom(const Motor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Motor::IsInitialized() const {

  return true;
}

void Motor::Swap(Motor* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(position_, other->position_);
    std::swap(velocity_, other->velocity_);
    std::swap(acceleration_, other->acceleration_);
    std::swap(target_, other->target_);
    std::swap(stiffness_, other->stiffness_);
    std::swap(current_, other->current_);
    std::swap(torque_, other->torque_);
    std::swap(temperature_, other->temperature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Motor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Motor_descriptor_;
  metadata.reflection = Motor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SensorData::kMotorFieldNumber;
const int SensorData::kAccelerometerFieldNumber;
const int SensorData::kGyroFieldNumber;
const int SensorData::kOrientationFieldNumber;
#endif  // !_MSC_VER

SensorData::SensorData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SensorData::InitAsDefaultInstance() {
  accelerometer_ = const_cast< ::API::Vector*>(&::API::Vector::default_instance());
  gyro_ = const_cast< ::API::Vector*>(&::API::Vector::default_instance());
  orientation_ = const_cast< ::API::Vector*>(&::API::Vector::default_instance());
}

SensorData::SensorData(const SensorData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SensorData::SharedCtor() {
  _cached_size_ = 0;
  accelerometer_ = NULL;
  gyro_ = NULL;
  orientation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SensorData::~SensorData() {
  SharedDtor();
}

void SensorData::SharedDtor() {
  if (this != default_instance_) {
    delete accelerometer_;
    delete gyro_;
    delete orientation_;
  }
}

void SensorData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SensorData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SensorData_descriptor_;
}

const SensorData& SensorData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

SensorData* SensorData::default_instance_ = NULL;

SensorData* SensorData::New() const {
  return new SensorData;
}

void SensorData::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_accelerometer()) {
      if (accelerometer_ != NULL) accelerometer_->::API::Vector::Clear();
    }
    if (has_gyro()) {
      if (gyro_ != NULL) gyro_->::API::Vector::Clear();
    }
    if (has_orientation()) {
      if (orientation_ != NULL) orientation_->::API::Vector::Clear();
    }
  }
  motor_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SensorData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .API.Motor motor = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_motor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_motor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_motor;
        if (input->ExpectTag(18)) goto parse_accelerometer;
        break;
      }

      // optional .API.Vector accelerometer = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_accelerometer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_accelerometer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_gyro;
        break;
      }

      // optional .API.Vector gyro = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gyro:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gyro()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_orientation;
        break;
      }

      // optional .API.Vector orientation = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_orientation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orientation()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SensorData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .API.Motor motor = 1;
  for (int i = 0; i < this->motor_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->motor(i), output);
  }

  // optional .API.Vector accelerometer = 2;
  if (has_accelerometer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->accelerometer(), output);
  }

  // optional .API.Vector gyro = 3;
  if (has_gyro()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->gyro(), output);
  }

  // optional .API.Vector orientation = 4;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->orientation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SensorData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .API.Motor motor = 1;
  for (int i = 0; i < this->motor_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->motor(i), target);
  }

  // optional .API.Vector accelerometer = 2;
  if (has_accelerometer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->accelerometer(), target);
  }

  // optional .API.Vector gyro = 3;
  if (has_gyro()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->gyro(), target);
  }

  // optional .API.Vector orientation = 4;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->orientation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SensorData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .API.Vector accelerometer = 2;
    if (has_accelerometer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->accelerometer());
    }

    // optional .API.Vector gyro = 3;
    if (has_gyro()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gyro());
    }

    // optional .API.Vector orientation = 4;
    if (has_orientation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->orientation());
    }

  }
  // repeated .API.Motor motor = 1;
  total_size += 1 * this->motor_size();
  for (int i = 0; i < this->motor_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->motor(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SensorData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SensorData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SensorData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SensorData::MergeFrom(const SensorData& from) {
  GOOGLE_CHECK_NE(&from, this);
  motor_.MergeFrom(from.motor_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_accelerometer()) {
      mutable_accelerometer()->::API::Vector::MergeFrom(from.accelerometer());
    }
    if (from.has_gyro()) {
      mutable_gyro()->::API::Vector::MergeFrom(from.gyro());
    }
    if (from.has_orientation()) {
      mutable_orientation()->::API::Vector::MergeFrom(from.orientation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SensorData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorData::CopyFrom(const SensorData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorData::IsInitialized() const {

  return true;
}

void SensorData::Swap(SensorData* other) {
  if (other != this) {
    motor_.Swap(&other->motor_);
    std::swap(accelerometer_, other->accelerometer_);
    std::swap(gyro_, other->gyro_);
    std::swap(orientation_, other->orientation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SensorData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SensorData_descriptor_;
  metadata.reflection = SensorData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LocalisationFieldObject::kNameFieldNumber;
const int LocalisationFieldObject::kWmXFieldNumber;
const int LocalisationFieldObject::kWmYFieldNumber;
const int LocalisationFieldObject::kSdXFieldNumber;
const int LocalisationFieldObject::kSdYFieldNumber;
const int LocalisationFieldObject::kSrXxFieldNumber;
const int LocalisationFieldObject::kSrXyFieldNumber;
const int LocalisationFieldObject::kSrYyFieldNumber;
const int LocalisationFieldObject::kHeadingFieldNumber;
const int LocalisationFieldObject::kSdHeadingFieldNumber;
const int LocalisationFieldObject::kLostFieldNumber;
#endif  // !_MSC_VER

LocalisationFieldObject::LocalisationFieldObject()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LocalisationFieldObject::InitAsDefaultInstance() {
}

LocalisationFieldObject::LocalisationFieldObject(const LocalisationFieldObject& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LocalisationFieldObject::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  wm_x_ = 0;
  wm_y_ = 0;
  sd_x_ = 0;
  sd_y_ = 0;
  sr_xx_ = 0;
  sr_xy_ = 0;
  sr_yy_ = 0;
  heading_ = 0;
  sd_heading_ = 0;
  lost_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LocalisationFieldObject::~LocalisationFieldObject() {
  SharedDtor();
}

void LocalisationFieldObject::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void LocalisationFieldObject::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LocalisationFieldObject::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LocalisationFieldObject_descriptor_;
}

const LocalisationFieldObject& LocalisationFieldObject::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

LocalisationFieldObject* LocalisationFieldObject::default_instance_ = NULL;

LocalisationFieldObject* LocalisationFieldObject::New() const {
  return new LocalisationFieldObject;
}

void LocalisationFieldObject::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    wm_x_ = 0;
    wm_y_ = 0;
    sd_x_ = 0;
    sd_y_ = 0;
    sr_xx_ = 0;
    sr_xy_ = 0;
    sr_yy_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    heading_ = 0;
    sd_heading_ = 0;
    lost_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LocalisationFieldObject::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_wm_x;
        break;
      }

      // optional float wm_x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_wm_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &wm_x_)));
          set_has_wm_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_wm_y;
        break;
      }

      // optional float wm_y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_wm_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &wm_y_)));
          set_has_wm_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_sd_x;
        break;
      }

      // optional float sd_x = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sd_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sd_x_)));
          set_has_sd_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_sd_y;
        break;
      }

      // optional float sd_y = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sd_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sd_y_)));
          set_has_sd_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_sr_xx;
        break;
      }

      // optional float sr_xx = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sr_xx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sr_xx_)));
          set_has_sr_xx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_sr_xy;
        break;
      }

      // optional float sr_xy = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sr_xy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sr_xy_)));
          set_has_sr_xy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_sr_yy;
        break;
      }

      // optional float sr_yy = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sr_yy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sr_yy_)));
          set_has_sr_yy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_heading;
        break;
      }

      // optional float heading = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &heading_)));
          set_has_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_sd_heading;
        break;
      }

      // optional float sd_heading = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sd_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sd_heading_)));
          set_has_sd_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_lost;
        break;
      }

      // optional bool lost = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lost_)));
          set_has_lost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LocalisationFieldObject::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional float wm_x = 2;
  if (has_wm_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->wm_x(), output);
  }

  // optional float wm_y = 3;
  if (has_wm_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->wm_y(), output);
  }

  // optional float sd_x = 4;
  if (has_sd_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->sd_x(), output);
  }

  // optional float sd_y = 5;
  if (has_sd_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->sd_y(), output);
  }

  // optional float sr_xx = 6;
  if (has_sr_xx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->sr_xx(), output);
  }

  // optional float sr_xy = 7;
  if (has_sr_xy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->sr_xy(), output);
  }

  // optional float sr_yy = 8;
  if (has_sr_yy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->sr_yy(), output);
  }

  // optional float heading = 9;
  if (has_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->heading(), output);
  }

  // optional float sd_heading = 10;
  if (has_sd_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->sd_heading(), output);
  }

  // optional bool lost = 11;
  if (has_lost()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->lost(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LocalisationFieldObject::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional float wm_x = 2;
  if (has_wm_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->wm_x(), target);
  }

  // optional float wm_y = 3;
  if (has_wm_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->wm_y(), target);
  }

  // optional float sd_x = 4;
  if (has_sd_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->sd_x(), target);
  }

  // optional float sd_y = 5;
  if (has_sd_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->sd_y(), target);
  }

  // optional float sr_xx = 6;
  if (has_sr_xx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->sr_xx(), target);
  }

  // optional float sr_xy = 7;
  if (has_sr_xy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->sr_xy(), target);
  }

  // optional float sr_yy = 8;
  if (has_sr_yy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->sr_yy(), target);
  }

  // optional float heading = 9;
  if (has_heading()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->heading(), target);
  }

  // optional float sd_heading = 10;
  if (has_sd_heading()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->sd_heading(), target);
  }

  // optional bool lost = 11;
  if (has_lost()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->lost(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LocalisationFieldObject::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional float wm_x = 2;
    if (has_wm_x()) {
      total_size += 1 + 4;
    }

    // optional float wm_y = 3;
    if (has_wm_y()) {
      total_size += 1 + 4;
    }

    // optional float sd_x = 4;
    if (has_sd_x()) {
      total_size += 1 + 4;
    }

    // optional float sd_y = 5;
    if (has_sd_y()) {
      total_size += 1 + 4;
    }

    // optional float sr_xx = 6;
    if (has_sr_xx()) {
      total_size += 1 + 4;
    }

    // optional float sr_xy = 7;
    if (has_sr_xy()) {
      total_size += 1 + 4;
    }

    // optional float sr_yy = 8;
    if (has_sr_yy()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float heading = 9;
    if (has_heading()) {
      total_size += 1 + 4;
    }

    // optional float sd_heading = 10;
    if (has_sd_heading()) {
      total_size += 1 + 4;
    }

    // optional bool lost = 11;
    if (has_lost()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LocalisationFieldObject::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LocalisationFieldObject* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LocalisationFieldObject*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LocalisationFieldObject::MergeFrom(const LocalisationFieldObject& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_wm_x()) {
      set_wm_x(from.wm_x());
    }
    if (from.has_wm_y()) {
      set_wm_y(from.wm_y());
    }
    if (from.has_sd_x()) {
      set_sd_x(from.sd_x());
    }
    if (from.has_sd_y()) {
      set_sd_y(from.sd_y());
    }
    if (from.has_sr_xx()) {
      set_sr_xx(from.sr_xx());
    }
    if (from.has_sr_xy()) {
      set_sr_xy(from.sr_xy());
    }
    if (from.has_sr_yy()) {
      set_sr_yy(from.sr_yy());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_heading()) {
      set_heading(from.heading());
    }
    if (from.has_sd_heading()) {
      set_sd_heading(from.sd_heading());
    }
    if (from.has_lost()) {
      set_lost(from.lost());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LocalisationFieldObject::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LocalisationFieldObject::CopyFrom(const LocalisationFieldObject& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalisationFieldObject::IsInitialized() const {

  return true;
}

void LocalisationFieldObject::Swap(LocalisationFieldObject* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(wm_x_, other->wm_x_);
    std::swap(wm_y_, other->wm_y_);
    std::swap(sd_x_, other->sd_x_);
    std::swap(sd_y_, other->sd_y_);
    std::swap(sr_xx_, other->sr_xx_);
    std::swap(sr_xy_, other->sr_xy_);
    std::swap(sr_yy_, other->sr_yy_);
    std::swap(heading_, other->heading_);
    std::swap(sd_heading_, other->sd_heading_);
    std::swap(lost_, other->lost_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LocalisationFieldObject::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LocalisationFieldObject_descriptor_;
  metadata.reflection = LocalisationFieldObject_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Localisation::kFieldObjectFieldNumber;
#endif  // !_MSC_VER

Localisation::Localisation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Localisation::InitAsDefaultInstance() {
}

Localisation::Localisation(const Localisation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Localisation::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Localisation::~Localisation() {
  SharedDtor();
}

void Localisation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Localisation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Localisation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Localisation_descriptor_;
}

const Localisation& Localisation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

Localisation* Localisation::default_instance_ = NULL;

Localisation* Localisation::New() const {
  return new Localisation;
}

void Localisation::Clear() {
  field_object_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Localisation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .API.LocalisationFieldObject field_object = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_field_object:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_field_object()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_field_object;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Localisation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .API.LocalisationFieldObject field_object = 1;
  for (int i = 0; i < this->field_object_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->field_object(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Localisation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .API.LocalisationFieldObject field_object = 1;
  for (int i = 0; i < this->field_object_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->field_object(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Localisation::ByteSize() const {
  int total_size = 0;

  // repeated .API.LocalisationFieldObject field_object = 1;
  total_size += 1 * this->field_object_size();
  for (int i = 0; i < this->field_object_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->field_object(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Localisation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Localisation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Localisation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Localisation::MergeFrom(const Localisation& from) {
  GOOGLE_CHECK_NE(&from, this);
  field_object_.MergeFrom(from.field_object_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Localisation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Localisation::CopyFrom(const Localisation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Localisation::IsInitialized() const {

  return true;
}

void Localisation::Swap(Localisation* other) {
  if (other != this) {
    field_object_.Swap(&other->field_object_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Localisation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Localisation_descriptor_;
  metadata.reflection = Localisation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Vector::kFloatValueFieldNumber;
#endif  // !_MSC_VER

Vector::Vector()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Vector::InitAsDefaultInstance() {
}

Vector::Vector(const Vector& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Vector::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vector::~Vector() {
  SharedDtor();
}

void Vector::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vector::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vector_descriptor_;
}

const Vector& Vector::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NUAPI_2eproto();
  return *default_instance_;
}

Vector* Vector::default_instance_ = NULL;

Vector* Vector::New() const {
  return new Vector;
}

void Vector::Clear() {
  float_value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Vector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float float_value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_float_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_float_value())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_float_value())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(13)) goto parse_float_value;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Vector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated float float_value = 1;
  for (int i = 0; i < this->float_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->float_value(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Vector::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated float float_value = 1;
  for (int i = 0; i < this->float_value_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->float_value(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Vector::ByteSize() const {
  int total_size = 0;

  // repeated float float_value = 1;
  {
    int data_size = 0;
    data_size = 4 * this->float_value_size();
    total_size += 1 * this->float_value_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vector::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Vector* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Vector*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vector::MergeFrom(const Vector& from) {
  GOOGLE_CHECK_NE(&from, this);
  float_value_.MergeFrom(from.float_value_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Vector::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vector::CopyFrom(const Vector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector::IsInitialized() const {

  return true;
}

void Vector::Swap(Vector* other) {
  if (other != this) {
    float_value_.Swap(&other->float_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Vector::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vector_descriptor_;
  metadata.reflection = Vector_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace API

// @@protoc_insertion_point(global_scope)
