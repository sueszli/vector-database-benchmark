'''
This script takes a set of DPM outputs for cars detected and runs them through a CNN that classifies the
detected cars by their viewpoint / angle and outputs that data to a CSV.
'''
import cv2
import os
import sys
import scipy.io as sio
from keras.models import load_model
import numpy as np
from scipy.misc import imsave, imread
import csv

# Set paths

# Detections in .mat format from DPM / matlab
DETECTIONS_DIR = '/Users/B-1P/Downloads/data_road/detections'
# Image Files for the detections - must have the same basename
IMAGES_DIR = '/Users/B-1P/Downloads/data_road/testing/image_2'
# Path to output everything to
OUTPUT_DIR = ''

# Get filepaths for images
image_files = [os.path.join(IMAGES_DIR, f) for f in os.listdir(IMAGES_DIR) if os.path.isfile(os.path.join(IMAGES_DIR, f))]

# Get filepaths for detections
detection_files = [os.path.join(DETECTIONS_DIR, f) for f in os.listdir(DETECTIONS_DIR) if os.path.isfile(os.path.join(DETECTIONS_DIR, f))]

# Sort them so that they're in the same order
image_files.sort()
detection_files.sort()

# Load CNN model generated by object_classify.py
model = load_model('object_classifierfit2.h5')


def filter_detections(mat,threshold=-0.7):
	'''
	Filter DPM detections by threshold and return them as a list of lists.
	'''
	detections = []
	for m in mat['ds']:
		if m[5] > threshold:
			detections.append(m)
	return detections

# Iterate through images and dpm detections
for i,d in zip(image_files, detection_files):
	# Output array
	angles = []

	print(i,d)
	# Filter detections
	filtered = filter_detections(sio.loadmat(d))
	# Load image
	image = imread(i)
	# ITerate through all detected objects
	for d in filtered:
		#xleft; ytop; xright; ybottom;
		print(d)
		print(image.shape)
		# Cut out the detected object using its bounding box coordinates.
		segment = image[d[1]:d[3],d[0]:d[2],:]
		if(segment.shape[0]==0 or segment.shape[1]==0):
			continue
		# Resize the segment to 128x128 because thats what the neural network takes.
		segment = cv2.resize(segment, (128,128))
		segment = np.array([segment])
		# Normalize the segment.
		segment = segment / 255.
		# Generate a prediction
		preditction = model.predict(segment)
		print("Prediction", preditction)
		# Convert the prediction to angles and append it to the original array containing the DPM bounding boxes etc.
		angle = (np.argmax(preditction, axis=1))*30-180
		print("Angle:",angle)
		# d.append(angle)
		x = d.tolist() 
		x.append(angle[0])
		angles.append(x)
	# Output the detections w/ angles to a CSV.
	with open(os.path.basename(i).split('.')[0]+".csv",'w') as f:
		w = csv.writer(f)
		w.writerows(angles)

