"""Implements a parser for a subset of the regular expressions grammar
        The parser returns a generator for all the strings recognized
        by a given regular expression.
The grammar parsed is as follows:
expr := orexpr EOF
orexpr := word (OR word)*
word := quantchar(quantchar)*
quantchar := (char|digit)quant?
char := CHAR | (LPARENS orexpr RPARENS) | (LCHOOSE orexpr RCHOOSE)
digit := 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
quant := PLUS | TIMES | QUESTION | CURLYQUANT
where
    LPARENS = (
    RPARENS = )
    LCHOOSE = [
    RCHOOSE = ]
    PLUS = +
    TIMES = *
    QUESTION = ?
    CURLYQUANT = {NUM:NUM}
        and NUM is a non-negative integer
    OR = |
    EOF represents end-of-file
    CHAR is any other character other than the ones with special meaning above
For each production rule R, a function parse_R has been implemented,
    which receives a stream of tokens and
    returns the subtree generated by parsing such rule
        and the remaining tokens
"""

from enum import Enum

class Token(Enum):
    # enumerator quantifiers
    TIMES = "*"
    PLUS = "+"
    QUESTION = "?"
    LCURLY = "{"
    RCURLY = "}"
    CURLYQUANT = "curlyquant"
    
    LPARENS = "("
    RPARENS = ")"
    LCHOOSE = "["
    RCHOOSE = "]"
    OR = "|"
    COLON = ":"

    DIGIT = "digit"
    CHARACTER = "character"
    EOF = "eof"

class TreeNode(object):
    def __init__(self, token, value, next_node):
        self.token = token
        self.value = value
        self.next_node = next_node

    def print(self):
        raise NotImplementedError("This should be overriden in subclasses")

class LiteralNode(TreeNode):
    def __init__(self, token, value, quantifier, next_node):
        TreeNode.__init__(self, token, value, next_node)
        self.quantifier = quantifier

    def print(self):
        printer = self.quantifier.get_printer(self.value)
        for value in printer():
            for sub in self.next_node.print():
                yield value+sub

class ChooseNode(TreeNode):
    def __init__(self, token, value, quantifier, value_range, next_node):
        TreeNode.__init__(self, token, value, next_node)
        self.quantifier = quantifier
        self.value_range = value_range
    
    def print(self):
        printer = self.quantifier.get_printer(self.value_range)
        for value in printer():
            for sub in self.next_node.print():
                yield value+sub

class OrNode(TreeNode):
    def __init__(self, token, value, children, quantifier, next_node):
        TreeNode.__init__(self, token, value, next_node)
        self.children = children
        self.quantifier = quantifier

    def print(self):
        temp = [c for child in self.children for c in child.print()]
        printer = self.quantifier.get_printer(temp)
        for child_print in printer():
            for sub in self.next_node.print():
                yield child_print+sub

class NoQuantifierNode(TreeNode):
    def __init__(self):
        TreeNode.__init__(self, None, None, None)

    def get_printer(self, values):
        def printer():
            for value in values:
                yield value
        return printer

class QuantifierNode(TreeNode):
    def __init__(self, token, value):
        TreeNode.__init__(self, token, value, None)

    def get_printer(self, values):
        if self.token == Token.QUESTION:
            temp = [""] + [v for v in values]
            ss = sorted(temp)
        elif self.token in (Token.TIMES, Token.PLUS):
            sub_result = [v for v in values]
            temp = sub_result[::]
            sub_result = [v+sub for v in values for sub in sub_result]
            temp += sub_result
            temp += (self.token == Token.TIMES)*[""]
            ss = sorted(temp)
            if isinstance(values, list) or len(values) > 1:
                ss += ["[...]"]
            else:
                ss += [values+"..."+values]
                
        else:                
            try:
                l, r = self.value
            except:
                raise ValueError("Was expecting a curly quantifier")
            sub_result = [""]
            temp = []
            for i in range(1, r+1):
                sub_result = [v+sub for v in values for sub in sub_result]
                if i >= l:
                    temp += sub_result
            ss = sorted(temp)
        def printer():
            for s in ss:
                yield s
        return printer

class EOFNode(TreeNode):
    def __init__(self):
        TreeNode.__init__(self, None, None, None)

    def print(self):
        yield ""

def tokenize(s):
    tokens = []
    for char in s:
        for token in Token:
            if char == token.value:
                tokens.append((token, char))
                break
        else:
            if char in "0123456789":
                tokens.append((Token.DIGIT, char))
            else:
                tokens.append((Token.CHARACTER, char))
    tokens.append((Token.EOF, "eof"))

    i = 0
    while i < len(tokens):
        if tokens[i][0] == Token.LCURLY:
            l, r, j = 0, 0, i+1
            acc = ""
            while j < len(tokens) and tokens[j][0] == Token.DIGIT:
                acc += tokens[j][1]
                tokens = tokens[:j] + tokens[j+1:]
            try:
                l = int(acc)
            except ValueError:
                raise SyntaxError("Curly quantifier with no left integer")
            if j >= len(tokens) or tokens[j][0] != Token.COLON:
                raise SyntaxError("Could not tokenize the expression")
            tokens = tokens[:j] + tokens[j+1:]
            acc = ""
            while j < len(tokens) and tokens[j][0] == Token.DIGIT:
                acc += tokens[j][1]
                tokens = tokens[:j] + tokens[j+1:]
            try:
                r = int(acc)
            except ValueError:
                raise SyntaxError("Curly quantifier with no right integer")
            if j >= len(tokens) or tokens[j][0] != Token.RCURLY:
                raise SyntaxError("Could not tokenize the expression")
            tokens = tokens[:j] + tokens[j+1:]
            tokens[i] = (Token.CURLYQUANT, (l,r))
        i += 1

    return tokens

def printRegex(r):
    return parse_expr(tokenize(r))

def parse_expr(tokens):
    tree, tokens = parse_orexpr(tokens)
    if tokens[0][0] == Token.EOF:
        tree.next_node = EOFNode()
        return tree
    else:
        raise SyntaxError("expected eof!")

def parse_orexpr(tokens):
    temp, tokens = parse_word(tokens)
    topOrNode = OrNode(Token.OR, Token.OR.value, [temp], NoQuantifierNode(), EOFNode())
    ornode = topOrNode
    while tokens[0][0] == Token.OR:
        temp, tokens = parse_word(tokens[1:])
        if temp is not None:
            topOrNode.children.append(temp)
    return topOrNode, tokens

def parse_word(tokens):
    topnode, tokens = parse_quantchar(tokens)
    if topnode is None:
        raise SyntaxError("Empty word :/")
    sub = node = topnode
    # while the next token could start a quantified character, grab it
    while tokens[0][0] in (Token.CHARACTER, Token.DIGIT, Token.LPARENS, Token.LCHOOSE):
        sub, tokens = parse_quantchar(tokens)
        node.next_node = sub
        node = sub
    return topnode, tokens

def parse_quantchar(tokens):
    if tokens[0][0] == Token.DIGIT:
        node, tokens = parse_digit(tokens)
    else:
        node, tokens = parse_char(tokens)
        if node is None:
            return None, tokens
    quant, tokens = parse_quant(tokens)
    node.quantifier = quant
    return node, tokens

def parse_char(tokens):
    if tokens[0][0] == Token.CHARACTER:
        return LiteralNode(tokens[0][0], tokens[0][1], NoQuantifierNode(), EOFNode()), tokens[1:]
    elif tokens[0][0] == Token.LPARENS:
        node, temptokens = parse_orexpr(tokens[1:])
        if temptokens[0][0] == Token.RPARENS:
            return node, temptokens[1:]
        else:
            raise SyntaxError("Could not parse parenthesized expression")
    elif tokens[0][0] == Token.LCHOOSE:
        i = 1
        value_range = ""
        while i < len(tokens) and tokens[i][0] != Token.RCHOOSE:
            value_range += tokens[i][1]
            i += 1
        if i >= len(tokens):
            raise SyntaxError("Could not close CHOOSE section")
        else:
            tokens = tokens[i+1:]
        return ChooseNode(Token.LCHOOSE, Token.LCHOOSE.value, NoQuantifierNode(), value_range, EOFNode()), tokens

def parse_quant(tokens):
    if tokens[0][0] in (Token.PLUS, Token.TIMES, Token.QUESTION, Token.CURLYQUANT):
        return QuantifierNode(tokens[0][0], tokens[0][1]), tokens[1:]
    else:
        return NoQuantifierNode(), tokens

def parse_digit(tokens):
    if tokens[0][0] == Token.DIGIT:
        return LiteralNode(tokens[0][0], tokens[0][1], NoQuantifierNode(), EOFNode()), tokens[1:]
    else:
        return None, tokens

if __name__ == "__main__":
    print("regexPrinter: a printer of regular expressions")
    print("\tjust write a regex to get all its matches printed")
    print("\tto exit just hit Enter in the prompt")
    while True:
        s = input(" >> ")
        if not s:
            break
        i = 1
        for v in printRegex(s).print():
            print("{}: {}".format(i, v))
            i += 1