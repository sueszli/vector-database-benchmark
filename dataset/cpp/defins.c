   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*             CLIPS Version 6.24  06/02/06            */
   /*                                                     */
   /*                  DEFINSTANCES MODULE                */
   /*******************************************************/

/*************************************************************/
/* Purpose: Kernel definstances interface commands           */
/*              and routines                                 */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Contributing Programmer(s):                               */
/*                                                           */
/*                                                           */
/* Revision History:                                         */
/*      6.23: Correction for FalseSymbol/TrueSymbol. DR0859  */
/*                                                           */
/*            Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*            Changed name of variable exp to theExp         */
/*            because of Unix compiler warnings of shadowed  */
/*            definitions.                                   */
/*                                                           */
/*      6.24: Converted INSTANCE_PATTERN_MATCHING to         */
/*            DEFRULE_CONSTRUCT.                             */
/*                                                           */
/*            Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*************************************************************/

/* =========================================
   *****************************************
               EXTERNAL DEFINITIONS
   =========================================
   ***************************************** */
#include "setup.h"

#if DEFINSTANCES_CONSTRUCT

#if BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE
#include "bload.h"
#include "dfinsbin.h"
#endif

#if CONSTRUCT_COMPILER && (! RUN_TIME)
#include "dfinscmp.h"
#endif

#include "argacces.h"
#include "classcom.h"
#include "classfun.h"
#include "cstrccom.h"
#include "cstrcpsr.h"
#include "constant.h"
#include "constrct.h"
#include "envrnmnt.h"
#include "evaluatn.h"
#include "extnfunc.h"
#include "insfun.h"
#include "inspsr.h"
#include "memalloc.h"
#include "modulpsr.h"
#include "router.h"
#include "scanner.h"
#include "symbol.h"
#include "utility.h"

#define _DEFINS_SOURCE_
#include "defins.h"

/* =========================================
   *****************************************
                   CONSTANTS
   =========================================
   ***************************************** */
#define ACTIVE_RLN "active"

/* =========================================
   *****************************************
      INTERNALLY VISIBLE FUNCTION HEADERS
   =========================================
   ***************************************** */

#if (! BLOAD_ONLY) && (! RUN_TIME)
static int ParseDefinstances(void *,EXEC_STATUS,char *);
static SYMBOL_HN *ParseDefinstancesName(void *,EXEC_STATUS,char *,int *);
static void RemoveDefinstances(void *,EXEC_STATUS,void *);
static void SaveDefinstances(void *,EXEC_STATUS,void *,char *);
static intBool RemoveAllDefinstances(void *,EXEC_STATUS);
static void DefinstancesDeleteError(void *,EXEC_STATUS,char *);

#if DEFRULE_CONSTRUCT
static void CreateInitialDefinstances(void *,EXEC_STATUS);
#endif
#endif

#if ! RUN_TIME
static void *AllocateModule(void *,EXEC_STATUS);
static void  ReturnModule(void *,EXEC_STATUS,void *);
static intBool ClearDefinstancesReady(void *,EXEC_STATUS);
static void CheckDefinstancesBusy(void *,EXEC_STATUS,struct constructHeader *,void *);
static void DestroyDefinstancesAction(void *,EXEC_STATUS,struct constructHeader *,void *);
#endif

static void ResetDefinstances(void *,EXEC_STATUS);
static void ResetDefinstancesAction(void *,EXEC_STATUS,struct constructHeader *,void *);
static void DeallocateDefinstancesData(void *,EXEC_STATUS);

/* =========================================
   *****************************************
          EXTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

/***************************************************
  NAME         : SetupDefinstances
  DESCRIPTION  : Adds the definstance support routines
                   to the Kernel
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Appropriate function lists modified
  NOTES        : None
 ***************************************************/
globle void SetupDefinstances(
  void *theEnv,
  EXEC_STATUS)
  {
   AllocateEnvironmentData(theEnv,execStatus,DEFINSTANCES_DATA,sizeof(struct definstancesData),DeallocateDefinstancesData);

   DefinstancesData(theEnv,execStatus)->DefinstancesModuleIndex =
                RegisterModuleItem(theEnv,execStatus,"definstances",
#if (! RUN_TIME)
                                    AllocateModule,ReturnModule,
#else
                                    NULL,NULL,
#endif
#if BLOAD_AND_BSAVE || BLOAD || BLOAD_ONLY
                                    BloadDefinstancesModuleRef,
#else
                                    NULL,
#endif
#if CONSTRUCT_COMPILER && (! RUN_TIME)
                                    DefinstancesCModuleReference,
#else
                                    NULL,
#endif
                                    EnvFindDefinstances);

   DefinstancesData(theEnv,execStatus)->DefinstancesConstruct =
      AddConstruct(theEnv,execStatus,"definstances","definstances",
#if (! BLOAD_ONLY) && (! RUN_TIME)
                   ParseDefinstances,
#else
                   NULL,
#endif
                   EnvFindDefinstances,
                   GetConstructNamePointer,GetConstructPPForm,
                   GetConstructModuleItem,EnvGetNextDefinstances,SetNextConstruct,
                   EnvIsDefinstancesDeletable,EnvUndefinstances,
#if (! BLOAD_ONLY) && (! RUN_TIME)
                   RemoveDefinstances
#else
                   NULL
#endif
                   );

#if ! RUN_TIME
   AddClearReadyFunction(theEnv,execStatus,"definstances",ClearDefinstancesReady,0);

#if ! BLOAD_ONLY
   EnvDefineFunction2(theEnv,execStatus,"undefinstances",'v',PTIEF UndefinstancesCommand,"UndefinstancesCommand","11w");
   AddSaveFunction(theEnv,execStatus,"definstances",SaveDefinstances,0);

#if DEFRULE_CONSTRUCT
   EnvAddClearFunction(theEnv,execStatus,"definstances",CreateInitialDefinstances,-1000);
#endif

#endif

#if DEBUGGING_FUNCTIONS
   EnvDefineFunction2(theEnv,execStatus,"ppdefinstances",'v',PTIEF PPDefinstancesCommand ,"PPDefinstancesCommand","11w");
   EnvDefineFunction2(theEnv,execStatus,"list-definstances",'v',PTIEF ListDefinstancesCommand,"ListDefinstancesCommand","01");
#endif

   EnvDefineFunction2(theEnv,execStatus,"get-definstances-list",'m',PTIEF GetDefinstancesListFunction,
                   "GetDefinstancesListFunction","01");
   EnvDefineFunction2(theEnv,execStatus,"definstances-module",'w',PTIEF GetDefinstancesModuleCommand,
                   "GetDefinstancesModuleCommand","11w");

#endif
   EnvAddResetFunction(theEnv,execStatus,"definstances",(void (*)(void *,EXEC_STATUS)) ResetDefinstances,0);

#if BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE
   SetupDefinstancesBload(theEnv,execStatus);
#endif

#if CONSTRUCT_COMPILER && (! RUN_TIME)
   SetupDefinstancesCompiler(theEnv,execStatus);
#endif
  }
  
/*******************************************************/
/* DeallocateDefinstancesData: Deallocates environment */
/*    data for the definstances construct.             */
/*******************************************************/
static void DeallocateDefinstancesData(
  void *theEnv,
  EXEC_STATUS)
  {
#if ! RUN_TIME
   struct definstancesModule *theModuleItem;
   void *theModule;
   
#if BLOAD || BLOAD_AND_BSAVE
   if (Bloaded(theEnv,execStatus)) return;
#endif
   
   DoForAllConstructs(theEnv,execStatus,DestroyDefinstancesAction,DefinstancesData(theEnv,execStatus)->DefinstancesModuleIndex,FALSE,NULL); 
   
   for (theModule = EnvGetNextDefmodule(theEnv,execStatus,NULL);
        theModule != NULL;
        theModule = EnvGetNextDefmodule(theEnv,execStatus,theModule))
     {
      theModuleItem = (struct definstancesModule *)
                      GetModuleItem(theEnv,execStatus,(struct defmodule *) theModule,
                                    DefinstancesData(theEnv,execStatus)->DefinstancesModuleIndex);
      rtn_struct(theEnv,execStatus,definstancesModule,theModuleItem);
     }
#else
#if MAC_MCW || WIN_MCW || MAC_XCD
#pragma unused(theEnv,execStatus)
#endif
#endif
  }

#if ! RUN_TIME  
/*****************************************************/
/* DestroyDefinstancesAction: Action used to remove  */
/*   definstances as a result of DestroyEnvironment. */
/*****************************************************/
#if WIN_BTC
#pragma argsused
#endif
static void DestroyDefinstancesAction(
  void *theEnv,
  EXEC_STATUS,
  struct constructHeader *theConstruct,
  void *buffer)
  {
#if MAC_MCW || WIN_MCW || MAC_XCD
#pragma unused(buffer)
#endif
#if (! BLOAD_ONLY) && (! RUN_TIME)
   struct definstances *theDefinstances = (struct definstances *) theConstruct;
   
   if (theDefinstances == NULL) return;
   
   ReturnPackedExpression(theEnv,execStatus,theDefinstances->mkinstance);
   
   DestroyConstructHeader(theEnv,execStatus,&theDefinstances->header);

   rtn_struct(theEnv,execStatus,definstances,theDefinstances);
#else
#if MAC_MCW || WIN_MCW || MAC_XCD
#pragma unused(theConstruct,theEnv)
#endif
#endif
  }
#endif

/***********************************************************
  NAME         : EnvGetNextDefinstances
  DESCRIPTION  : Finds first or next definstances
  INPUTS       : The address of the current definstances
  RETURNS      : The address of the next definstances
                   (NULL if none)
  SIDE EFFECTS : None
  NOTES        : If ptr == NULL, the first definstances
                    is returned.
 ***********************************************************/
globle void *EnvGetNextDefinstances(
  void *theEnv,
  EXEC_STATUS,
  void *ptr)
  {
   return((void *) GetNextConstructItem(theEnv,execStatus,(struct constructHeader *) ptr,
                                        DefinstancesData(theEnv,execStatus)->DefinstancesModuleIndex));
  }

/***************************************************
  NAME         : EnvFindDefinstances
  DESCRIPTION  : Looks up a definstance construct
                   by name-string
  INPUTS       : The symbolic name
  RETURNS      : The definstance address, or NULL
                    if not found
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
globle void *EnvFindDefinstances(
  void *theEnv,
  EXEC_STATUS,
  char *name)
  {
   return(FindNamedConstruct(theEnv,execStatus,name,DefinstancesData(theEnv,execStatus)->DefinstancesConstruct));
  }

/***************************************************
  NAME         : EnvIsDefinstancesDeletable
  DESCRIPTION  : Determines if a definstances
                   can be deleted
  INPUTS       : Address of the definstances
  RETURNS      : TRUE if deletable, FALSE otherwise
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
globle int EnvIsDefinstancesDeletable(
  void *theEnv,
  EXEC_STATUS,
  void *ptr)
  {
   if (! ConstructsDeletable(theEnv,execStatus))
     { return FALSE; }

   return((((DEFINSTANCES *) ptr)->busy == 0) ? TRUE : FALSE);
  }

/***********************************************************
  NAME         : UndefinstancesCommand
  DESCRIPTION  : Removes a definstance
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Definstance deallocated
  NOTES        : H/L Syntax : (undefinstances <name> | *)
 ***********************************************************/
globle void UndefinstancesCommand(
  void *theEnv,
  EXEC_STATUS)
  {
   UndefconstructCommand(theEnv,execStatus,"undefinstances",DefinstancesData(theEnv,execStatus)->DefinstancesConstruct);
  }

/*****************************************************************
  NAME         : GetDefinstancesModuleCommand
  DESCRIPTION  : Determines to which module a definstances belongs
  INPUTS       : None
  RETURNS      : The symbolic name of the module
  SIDE EFFECTS : None
  NOTES        : H/L Syntax: (definstances-module <defins-name>)
 *****************************************************************/
globle void *GetDefinstancesModuleCommand(
  void *theEnv,
  EXEC_STATUS)
  {
   return(GetConstructModuleCommand(theEnv,execStatus,"definstances-module",DefinstancesData(theEnv,execStatus)->DefinstancesConstruct));
  }

/***********************************************************
  NAME         : EnvUndefinstances
  DESCRIPTION  : Removes a definstance
  INPUTS       : Address of definstances to remove
  RETURNS      : TRUE if successful,
                 FALSE otherwise
  SIDE EFFECTS : Definstance deallocated
  NOTES        : None
 ***********************************************************/
globle intBool EnvUndefinstances(
  void *theEnv,
  EXEC_STATUS,
  void *vptr)
  {
#if RUN_TIME || BLOAD_ONLY
#if MAC_MCW || WIN_MCW || MAC_XCD
#pragma unused(theEnv,execStatus,vptr)
#endif
   return(FALSE);
#else
   DEFINSTANCES *dptr;

   dptr = (DEFINSTANCES *) vptr;

#if BLOAD || BLOAD_AND_BSAVE
   if (Bloaded(theEnv,execStatus))
     return(FALSE);
#endif
   if (dptr == NULL)
     return(RemoveAllDefinstances(theEnv,execStatus));
   if (EnvIsDefinstancesDeletable(theEnv,execStatus,vptr) == FALSE)
     return(FALSE);
   RemoveConstructFromModule(theEnv,execStatus,(struct constructHeader *) vptr);
   RemoveDefinstances(theEnv,execStatus,(void *) dptr);
   return(TRUE);
#endif
  }

#if DEBUGGING_FUNCTIONS

/***************************************************************
  NAME         : PPDefinstancesCommand
  DESCRIPTION  : Prints out the pretty-print form of a definstance
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : H/L Syntax : (ppdefinstances <name>)
 ***************************************************************/
globle void PPDefinstancesCommand(
  void *theEnv,
  EXEC_STATUS)
  {
   PPConstructCommand(theEnv,execStatus,"ppdefinstances",DefinstancesData(theEnv,execStatus)->DefinstancesConstruct);
  }

/***************************************************
  NAME         : ListDefinstancesCommand
  DESCRIPTION  : Displays all definstances names
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Definstances name sprinted
  NOTES        : H/L Interface
 ***************************************************/
globle void ListDefinstancesCommand(
  void *theEnv,
  EXEC_STATUS)
  {
   ListConstructCommand(theEnv,execStatus,"list-definstances",DefinstancesData(theEnv,execStatus)->DefinstancesConstruct);
  }

/***************************************************
  NAME         : EnvListDefinstances
  DESCRIPTION  : Displays all definstances names
  INPUTS       : 1) The logical name of the output
                 2) The module
  RETURNS      : Nothing useful
  SIDE EFFECTS : Definstances names printed
  NOTES        : C Interface
 ***************************************************/
globle void EnvListDefinstances(
  void *theEnv,
  EXEC_STATUS,
  char *logicalName,
  struct defmodule *theModule)
  {
   ListConstruct(theEnv,execStatus,DefinstancesData(theEnv,execStatus)->DefinstancesConstruct,logicalName,theModule);
  }

#endif

/****************************************************************
  NAME         : GetDefinstancesListFunction
  DESCRIPTION  : Groups all definstances names into
                 a multifield list
  INPUTS       : A data object buffer to hold
                 the multifield result
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield allocated and filled
  NOTES        : H/L Syntax: (get-definstances-list [<module>])
 ****************************************************************/
globle void GetDefinstancesListFunction(
  void *theEnv,
  EXEC_STATUS,
  DATA_OBJECT*returnValue)
  {
   GetConstructListFunction(theEnv,execStatus,"get-definstances-list",returnValue,DefinstancesData(theEnv,execStatus)->DefinstancesConstruct);
  }

/***************************************************************
  NAME         : EnvGetDefinstancesList
  DESCRIPTION  : Groups all definstances names into
                 a multifield list
  INPUTS       : 1) A data object buffer to hold
                    the multifield result
                 2) The module from which to obtain definstances
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield allocated and filled
  NOTES        : External C access
 ***************************************************************/
globle void EnvGetDefinstancesList(
  void *theEnv,
  EXEC_STATUS,
  DATA_OBJECT *returnValue,
  struct defmodule *theModule)
  {
   GetConstructList(theEnv,execStatus,returnValue,DefinstancesData(theEnv,execStatus)->DefinstancesConstruct,theModule);
  }

/* =========================================
   *****************************************
          INTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

#if (! BLOAD_ONLY) && (! RUN_TIME)

/*********************************************************************
  NAME         : ParseDefinstances
  DESCRIPTION  : Parses and allocates a definstances construct
  INPUTS       : The logical name of the input source
  RETURNS      : FALSE if no errors, TRUE otherwise
  SIDE EFFECTS : Definstances parsed and created
  NOTES        : H/L Syntax :

                 (definstances  <name> [active] [<comment>]
                    <instance-definition>+)

                 <instance-definition> ::=
                    (<instance-name> of <class-name> <slot-override>*)

                 <slot-override> ::= (<slot-name> <value-expression>*)
 *********************************************************************/
static int ParseDefinstances(
  void *theEnv,
  EXEC_STATUS,
  char *readSource)
  {
   SYMBOL_HN *dname;
   void *mkinsfcall;
   EXPRESSION *mkinstance,*mkbot = NULL;
   DEFINSTANCES *dobj;
   int active;

   SetPPBufferStatus(theEnv,execStatus,ON);
   FlushPPBuffer(theEnv,execStatus);
   SetIndentDepth(theEnv,execStatus,3);
   SavePPBuffer(theEnv,execStatus,"(definstances ");

#if BLOAD || BLOAD_AND_BSAVE
   if ((Bloaded(theEnv,execStatus)) && (! ConstructData(theEnv,execStatus)->CheckSyntaxMode))
     {
      CannotLoadWithBloadMessage(theEnv,execStatus,"definstances");
      return(TRUE);
     }
#endif
   dname = ParseDefinstancesName(theEnv,execStatus,readSource,&active);
   if (dname == NULL)
     return(TRUE);

   dobj = get_struct(theEnv,execStatus,definstances);
   InitializeConstructHeader(theEnv,execStatus,"definstances",(struct constructHeader *) dobj,dname);
   dobj->busy = 0;
   dobj->mkinstance = NULL;
#if DEFRULE_CONSTRUCT
   if (active)
     mkinsfcall = (void *) FindFunction(theEnv,execStatus,"active-make-instance");
   else
     mkinsfcall = (void *) FindFunction(theEnv,execStatus,"make-instance");
#else
   mkinsfcall = (void *) FindFunction(theEnv,execStatus,"make-instance");
#endif
   while (GetType(DefclassData(theEnv,execStatus)->ObjectParseToken) == LPAREN)
     {
      mkinstance = GenConstant(theEnv,execStatus,UNKNOWN_VALUE,mkinsfcall);
      mkinstance = ParseInitializeInstance(theEnv,execStatus,mkinstance,readSource);
      if (mkinstance == NULL)
        {
         ReturnExpression(theEnv,execStatus,dobj->mkinstance);
         rtn_struct(theEnv,execStatus,definstances,dobj);
         return(TRUE);
        }
      if (ExpressionContainsVariables(mkinstance,FALSE) == TRUE)
        {
         LocalVariableErrorMessage(theEnv,execStatus,"definstances");
         ReturnExpression(theEnv,execStatus,mkinstance);
         ReturnExpression(theEnv,execStatus,dobj->mkinstance);
         rtn_struct(theEnv,execStatus,definstances,dobj);
         return(TRUE);
        }
      if (mkbot == NULL)
        dobj->mkinstance = mkinstance;
      else
        GetNextArgument(mkbot) = mkinstance;
      mkbot = mkinstance;
      GetToken(theEnv,execStatus,readSource,&DefclassData(theEnv,execStatus)->ObjectParseToken);
      PPBackup(theEnv,execStatus);
      PPCRAndIndent(theEnv,execStatus);
      SavePPBuffer(theEnv,execStatus,DefclassData(theEnv,execStatus)->ObjectParseToken.printForm);
     }

   if (GetType(DefclassData(theEnv,execStatus)->ObjectParseToken) != RPAREN)
     {
      ReturnExpression(theEnv,execStatus,dobj->mkinstance);
      rtn_struct(theEnv,execStatus,definstances,dobj);
      SyntaxErrorMessage(theEnv,execStatus,"definstances");
      return(TRUE);
     }
   else
     {
      if (ConstructData(theEnv,execStatus)->CheckSyntaxMode)
        {
         ReturnExpression(theEnv,execStatus,dobj->mkinstance);
         rtn_struct(theEnv,execStatus,definstances,dobj);
         return(FALSE);
        }
#if DEBUGGING_FUNCTIONS
      if (EnvGetConserveMemory(theEnv,execStatus) == FALSE)
        {
         if (dobj->mkinstance != NULL)
           PPBackup(theEnv,execStatus);
         PPBackup(theEnv,execStatus);
         SavePPBuffer(theEnv,execStatus,")\n");
         SetDefinstancesPPForm((void *) dobj,CopyPPBuffer(theEnv,execStatus));
        }
#endif
      mkinstance = dobj->mkinstance;
      dobj->mkinstance = PackExpression(theEnv,execStatus,mkinstance);
      ReturnExpression(theEnv,execStatus,mkinstance);
      IncrementSymbolCount(GetDefinstancesNamePointer((void *) dobj));
      ExpressionInstall(theEnv,execStatus,dobj->mkinstance);
     }

   AddConstructToModule((struct constructHeader *) dobj);
   return(FALSE);
  }

/*************************************************************
  NAME         : ParseDefinstancesName
  DESCRIPTION  : Parses definstance name and optional comment
                 and optional "active" keyword
  INPUTS       : 1) The logical name of the input source
                 2) Buffer to hold flag indicating if
                    definstances should cause pattern-matching
                    to occur during slot-overrides
  RETURNS      : Address of name symbol, or
                   NULL if there was an error
  SIDE EFFECTS : Token after name or comment is scanned
  NOTES        : Assumes "(definstances" has already
                   been scanned.
 *************************************************************/
static SYMBOL_HN *ParseDefinstancesName(
  void *theEnv,
  EXEC_STATUS,
  char *readSource,
  int *active)
  {
   SYMBOL_HN *dname;

   *active = FALSE;
   dname = GetConstructNameAndComment(theEnv,execStatus,readSource,&DefclassData(theEnv,execStatus)->ObjectParseToken,"definstances",
                                      EnvFindDefinstances,EnvUndefinstances,"@",
                                      TRUE,FALSE,TRUE);
   if (dname == NULL)
     return(NULL);

#if DEFRULE_CONSTRUCT
   if ((GetType(DefclassData(theEnv,execStatus)->ObjectParseToken) != SYMBOL) ? FALSE :
       (strcmp(ValueToString(GetValue(DefclassData(theEnv,execStatus)->ObjectParseToken)),ACTIVE_RLN) == 0))
     {
      PPBackup(theEnv,execStatus);
      PPBackup(theEnv,execStatus);
      SavePPBuffer(theEnv,execStatus," ");
      SavePPBuffer(theEnv,execStatus,DefclassData(theEnv,execStatus)->ObjectParseToken.printForm);
      PPCRAndIndent(theEnv,execStatus);
      GetToken(theEnv,execStatus,readSource,&DefclassData(theEnv,execStatus)->ObjectParseToken);
      *active = TRUE;
     }
#endif
   if (GetType(DefclassData(theEnv,execStatus)->ObjectParseToken) == STRING)
     {
      PPBackup(theEnv,execStatus);
      PPBackup(theEnv,execStatus);
      SavePPBuffer(theEnv,execStatus," ");
      SavePPBuffer(theEnv,execStatus,DefclassData(theEnv,execStatus)->ObjectParseToken.printForm);
      PPCRAndIndent(theEnv,execStatus);
      GetToken(theEnv,execStatus,readSource,&DefclassData(theEnv,execStatus)->ObjectParseToken);
     }
   return(dname);
  }

/**************************************************************
  NAME         : RemoveDefinstances
  DESCRIPTION  : Deallocates and removes a definstance construct
  INPUTS       : The definstance address
  RETURNS      : Nothing useful
  SIDE EFFECTS : Existing definstance construct deleted
  NOTES        : Assumes busy count of definstance is 0
 **************************************************************/
static void RemoveDefinstances(
  void *theEnv,
  EXEC_STATUS,
  void *vdptr)
  {
   DEFINSTANCES *dptr = (DEFINSTANCES *) vdptr;

   DecrementSymbolCount(theEnv,execStatus,GetDefinstancesNamePointer((void *) dptr));
   ExpressionDeinstall(theEnv,execStatus,dptr->mkinstance);
   ReturnPackedExpression(theEnv,execStatus,dptr->mkinstance);
   SetDefinstancesPPForm((void *) dptr,NULL);
   ClearUserDataList(theEnv,execStatus,dptr->header.usrData);
   rtn_struct(theEnv,execStatus,definstances,dptr);
  }

/***************************************************
  NAME         : SaveDefinstances
  DESCRIPTION  : Prints pretty print form of
                   definstances to specified output
  INPUTS       : The logical name of the output
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
static void SaveDefinstances(
  void *theEnv,
  EXEC_STATUS,
  void *theModule,
  char *logName)
  {
   SaveConstruct(theEnv,execStatus,theModule,logName,DefinstancesData(theEnv,execStatus)->DefinstancesConstruct);
  }

/***************************************************
  NAME         : RemoveAllDefinstances
  DESCRIPTION  : Removes all definstances constructs
  INPUTS       : None
  RETURNS      : TRUE if successful,
                 FALSE otherwise
  SIDE EFFECTS : All definstances deallocated
  NOTES        : None
 ***************************************************/
static intBool RemoveAllDefinstances(
  void *theEnv,
  EXEC_STATUS)
  {
   DEFINSTANCES *dptr,*dhead;
   int success = TRUE;

#if BLOAD || BLOAD_AND_BSAVE

   if (Bloaded(theEnv,execStatus))
     return(FALSE);
#endif
  dhead = (DEFINSTANCES *) EnvGetNextDefinstances(theEnv,execStatus,NULL);
  while (dhead != NULL)
    {
     dptr = dhead;
     dhead = (DEFINSTANCES *) EnvGetNextDefinstances(theEnv,execStatus,(void *) dhead);
     if (EnvIsDefinstancesDeletable(theEnv,execStatus,(void *) dptr))
       {
        RemoveConstructFromModule(theEnv,execStatus,(struct constructHeader *) dptr);
        RemoveDefinstances(theEnv,execStatus,(void *) dptr);
       }
     else
       {
        DefinstancesDeleteError(theEnv,execStatus,EnvGetDefinstancesName(theEnv,execStatus,(void *) dptr));
        success = FALSE;
       }
    }
   return(success);
  }

/***************************************************
  NAME         : DefinstancesDeleteError
  DESCRIPTION  : Prints an error message for
                 unsuccessful definstances
                 deletion attempts
  INPUTS       : The name of the definstances
  RETURNS      : Nothing useful
  SIDE EFFECTS : Error message printed
  NOTES        : None
 ***************************************************/
static void DefinstancesDeleteError(
  void *theEnv,
  EXEC_STATUS,
  char *dname)
  {
   CantDeleteItemErrorMessage(theEnv,execStatus,"definstances",dname);
  }

#if DEFRULE_CONSTRUCT

/********************************************************
  NAME         : CreateInitialDefinstances
  DESCRIPTION  : Makes the initial-object definstances
                 structure for creating an initial-object
                 which will match default object patterns
                 in defrules
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : initial-object definstances created
  NOTES        : None
 ********************************************************/
static void CreateInitialDefinstances(
  void *theEnv,
  EXEC_STATUS)
  {
   EXPRESSION *tmp;
   DEFINSTANCES *theDefinstances;

   theDefinstances = get_struct(theEnv,execStatus,definstances);
   InitializeConstructHeader(theEnv,execStatus,"definstances",(struct constructHeader *) theDefinstances,
                             DefclassData(theEnv,execStatus)->INITIAL_OBJECT_SYMBOL);
   theDefinstances->busy = 0;
   tmp = GenConstant(theEnv,execStatus,FCALL,(void *) FindFunction(theEnv,execStatus,"make-instance"));
   tmp->argList = GenConstant(theEnv,execStatus,INSTANCE_NAME,(void *) DefclassData(theEnv,execStatus)->INITIAL_OBJECT_SYMBOL);
   tmp->argList->nextArg =
       GenConstant(theEnv,execStatus,DEFCLASS_PTR,(void *) LookupDefclassInScope(theEnv,execStatus,INITIAL_OBJECT_CLASS_NAME));
   theDefinstances->mkinstance = PackExpression(theEnv,execStatus,tmp);
   ReturnExpression(theEnv,execStatus,tmp);
   IncrementSymbolCount(GetDefinstancesNamePointer((void *) theDefinstances));
   ExpressionInstall(theEnv,execStatus,theDefinstances->mkinstance);
   AddConstructToModule((struct constructHeader *) theDefinstances);
  }

#endif

#endif

#if ! RUN_TIME

/*****************************************************
  NAME         : AllocateModule
  DESCRIPTION  : Creates and initializes a
                 list of definstances for a new module
  INPUTS       : None
  RETURNS      : The new definstances module
  SIDE EFFECTS : Definstances module created
  NOTES        : None
 *****************************************************/
static void *AllocateModule(
  void *theEnv,
  EXEC_STATUS)
  {
   return((void *) get_struct(theEnv,execStatus,definstancesModule));
  }

/***************************************************
  NAME         : ReturnModule
  DESCRIPTION  : Removes a definstances module and
                 all associated definstances
  INPUTS       : The definstances module
  RETURNS      : Nothing useful
  SIDE EFFECTS : Module and definstances deleted
  NOTES        : None
 ***************************************************/
static void ReturnModule(
  void *theEnv,
  EXEC_STATUS,
  void *theItem)
  {
#if (! BLOAD_ONLY)
   FreeConstructHeaderModule(theEnv,execStatus,(struct defmoduleItemHeader *) theItem,DefinstancesData(theEnv,execStatus)->DefinstancesConstruct);
#endif
   rtn_struct(theEnv,execStatus,definstancesModule,theItem);
  }

/***************************************************
  NAME         : ClearDefinstancesReady
  DESCRIPTION  : Determines if it is safe to
                 remove all definstances
                 Assumes *all* constructs will be
                 deleted
  INPUTS       : None
  RETURNS      : TRUE if all definstances can
                 be deleted, FALSE otherwise
  SIDE EFFECTS : None
  NOTES        : Used by (clear) and (bload)
 ***************************************************/
static intBool ClearDefinstancesReady(
  void *theEnv,
  EXEC_STATUS)
  {
   int flagBuffer = TRUE;

   DoForAllConstructs(theEnv,execStatus,CheckDefinstancesBusy,DefinstancesData(theEnv,execStatus)->DefinstancesModuleIndex,
                      FALSE,(void *) &flagBuffer);
   return(flagBuffer);
  }

/***************************************************
  NAME         : CheckDefinstancesBusy
  DESCRIPTION  : Determines if a definstances is
                 in use or not
  INPUTS       : 1) The definstances
                 2) A buffer to set to 0 if the
                    the definstances is busy
  RETURNS      : Nothing useful
  SIDE EFFECTS : Buffer set to 0 if definstances
                 busy
  NOTES        : The flag buffer is not modified
                 if definstances is not busy
                 (assumed to be initialized to 1)
 ***************************************************/
#if WIN_BTC
#pragma argsused
#endif
static void CheckDefinstancesBusy(
  void *theEnv,
  EXEC_STATUS,
  struct constructHeader *theDefinstances,
  void *userBuffer)
  {
#if MAC_MCW || WIN_MCW || MAC_XCD
#pragma unused(theEnv,execStatus)
#endif

   if (((DEFINSTANCES *) theDefinstances)->busy > 0)
     * (int *) userBuffer = FALSE;
  }

#endif

/***************************************************
  NAME         : ResetDefinstances
  DESCRIPTION  : Calls EvaluateExpression for each of
                   the make-instance calls in all
                   of the definstances constructs
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : All instances in the definstances
                   are evaluated (and created if
                   there are no errors)
                 Any previously existing instances
                 are deleted first.
  NOTES        : None
 ***************************************************/
static void ResetDefinstances(
  void *theEnv,
  EXEC_STATUS)
  {
   DoForAllConstructs(theEnv,execStatus,ResetDefinstancesAction,DefinstancesData(theEnv,execStatus)->DefinstancesModuleIndex,TRUE,NULL);
  }

/***************************************************
  NAME         : ResetDefinstancesAction
  DESCRIPTION  : Performs all the make-instance
                 calls in a definstances
  INPUTS       : 1) The definstances
                 2) User data buffer (ignored)
  RETURNS      : Nothing useful
  SIDE EFFECTS : Instances created
  NOTES        : None
 ***************************************************/
#if WIN_BTC
#pragma argsused
#endif
static void ResetDefinstancesAction(
  void *theEnv,
  EXEC_STATUS,
  struct constructHeader *vDefinstances,
  void *userBuffer)
  {
#if MAC_MCW || WIN_MCW || MAC_XCD
#pragma unused(userBuffer)
#endif
   DEFINSTANCES *theDefinstances = (DEFINSTANCES *) vDefinstances;
   EXPRESSION *theExp;
   DATA_OBJECT temp;

   SaveCurrentModule(theEnv,execStatus);
   EnvSetCurrentModule(theEnv,execStatus,(void *) vDefinstances->whichModule->theModule);
   theDefinstances->busy++;
   for (theExp = theDefinstances->mkinstance ;
        theExp != NULL ;
        theExp = GetNextArgument(theExp))
     {
      EvaluateExpression(theEnv,execStatus,theExp,&temp);
      if (execStatus->HaltExecution ||
          ((GetType(temp) == SYMBOL) &&
           (GetValue(temp) == EnvFalseSymbol(theEnv,execStatus))))
        {
         RestoreCurrentModule(theEnv,execStatus);
         theDefinstances->busy--;
         return;
        }
     }
   theDefinstances->busy--;
   RestoreCurrentModule(theEnv,execStatus);
  }

#endif


