/*---------------------------------------------------------- -*- Mode: C -*-----
 * $Id$
 *
 * Created 2010/07/24
 * Author: Dan Adkins
 *
 * Copyright 2010-2012,2016 Quantcast Corporation. All rights reserved.
 *
 * This file is part of Kosmos File System (KFS).
 *
 * Licensed under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * \file mktable.c
 * \brief Table generator for Reed Solomon decoder.
 *
 *------------------------------------------------------------------------------
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "rs.h"

uint8_t pow2[256];
uint8_t inv[256];
uint8_t mlo[256][16];
uint8_t mhi[256][16];
uint16_t r2map[RS_LIB_MAX_DATA_BLOCKS][RS_LIB_MAX_DATA_BLOCKS];
uint16_t r3map[RS_LIB_MAX_DATA_BLOCKS][RS_LIB_MAX_DATA_BLOCKS][RS_LIB_MAX_DATA_BLOCKS];

static char *header =
    "/* GENERATED BY mktable; DO NOT EDIT.\n"
    " * mktable >rs_table.c\n"
    " */"
    "\n"
    "#include \"rs_table.h\"\n"
    "\n";

static uint8_t
mul2(uint8_t x)
{
    return (x << 1) ^ ((x & 0x80) ? 0x1d : 0);
}

static uint8_t
mul(uint8_t x, uint8_t y)
{
    uint8_t z;

    z = 0;
    while (x != 0) {
        if (x & 1)
            z ^= y;
        x >>= 1;
        y = mul2(y);
    }
    return z;
}

int main(int argc, char **argv)
{
    if (argc > 1 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help"))) {
        printf("This is the table generator for Reed Solomon decoder.\n");
        exit(0);
    }

    int i, j, x, y, z, n;
    uint8_t m[9];
    uint8_t det;
    const int N = RS_LIB_MAX_DATA_BLOCKS;

    printf("%s", header);

    /* Powers of 2 */
    x = 1;
    for (i = 0; i < 256; i++) {
        pow2[i] = x;
        x = mul2(x);
    }
    assert(pow2[1] == 2);
    assert(pow2[255] == 1);

    /* Inverses */
    for (i = 0; i < 255; i++)
        inv[pow2[i]] = pow2[255-i];
    for (x = 1; x < 256; x++)
        assert(mul(x, inv[x]) == 1);

    /* Generate nibble tables */
    for (i = 0; i < 256; i++)
        for (j = 0; j < 16; j++) {
            mlo[i][j] = mul(i, j);
            mhi[i][j] = mul(i, j<<4);
        }
    for (i = 0; i < 256; i++)
        for (j = 0; j < 256; j++)
            assert(mul(i, j) == (mlo[i][j&0x0f] ^ mhi[i][j>>4]));

    printf("const rs_nibtab rs_nibmul[256] = {\n");
    for (i = 0; i < 256; i++) {
        printf("\t{ { ");
        for (j = 0; j < 16; j++)
            printf("0x%02x,", mlo[i][j]);
        printf(" },\n\t  { ");
        for (j = 0; j < 16; j++)
            printf("0x%02x,", mhi[i][j]);
        printf(" } },\n");
    }
    printf("};\n");

    /* Generating 1x1 recovery matrices... */
    printf("const uint8_t rs_r1P[] = {\n\t");
    for (x = 0; x < N; x++)
        printf("0x%02x,", 1);
    printf("\n};\n");

    printf("const uint8_t rs_r1Q[] = {\n\t");
    for (x = 0; x < N; x++)
        printf("0x%02x,", pow2[255 - x]);
    printf("\n};\n");

    printf("const uint8_t rs_r1R[] = {\n\t");
    for (x = 0; x < N; x++)
        printf("0x%02x,", pow2[255 - 2*x]);
    printf("\n};\n");

    /* Generating 2x2 recovery matrices... */
    printf("const uint8_t rs_r2PQ[][4] = {\n");
    for (x = 0; x < N; x++)
        for (y = x + 1; y < N; y++) {
            z = inv[pow2[x] ^ pow2[y]];
            printf("\t{ 0x%02x, 0x%02x, 0x%02x, 0x%02x },\n",
                   mul(z, pow2[y]), z,
                   mul(z, pow2[x]), z);
        }
    printf("};\n");

    printf("const uint8_t rs_r2PR[][4] = {\n");
    for (x = 0; x < N; x++)
        for (y = x + 1; y < N; y++) {
            z = inv[pow2[2*x] ^ pow2[2*y]];
            printf("\t{ 0x%02x, 0x%02x, 0x%02x, 0x%02x },\n",
                   mul(z, pow2[2*y]), z,
                   mul(z, pow2[2*x]), z);
        }
    printf("};\n");

    printf("const uint8_t rs_r2QR[][4] = {\n");
    for (x = 0; x < N; x++)
        for (y = x + 1; y < N; y++) {
            z = inv[pow2[x] ^ pow2[y]];
            printf("\t{ 0x%02x, 0x%02x, 0x%02x, 0x%02x },\n",
                   mul(z, pow2[y-x]),       mul(z, pow2[255-x]),
                   mul(z, pow2[255+(x-y)]), mul(z, pow2[255-y]));
        }
    printf("};\n");

    /* Generate map (x,y) -> canonical index */
    memset(r2map, -1, sizeof(r2map));
    n = 0;
    for (x = 0; x < N; x++)
        for (y = x + 1; y < N; y++)
            r2map[x][y] = r2map[y][x] = n++;
    assert(n <= (1<<16));

    printf("const uint16_t rs_r2map[RS_LIB_MAX_DATA_BLOCKS][RS_LIB_MAX_DATA_BLOCKS] = {\n");
    for (x = 0; x < N; x++) {
        printf("\t{ ");
        for (y = 0; y < N; y++)
            printf("%2d, ", r2map[x][y]);
        printf("},\n");
    }
    printf("};\n");

    /* Generating 3x3 recovery matrices... */
    printf("const uint8_t rs_r3[][9] = {\n");
    for (x = 0; x < N; x++)
        for (y = x + 1; y < N; y++)
            for (z = y + 1; z < N; z++) {
                det = mul(pow2[x] ^ pow2[y], mul(pow2[x] ^ pow2[z], pow2[y] ^ pow2[z]));
                m[0] = mul(inv[det], pow2[y + 2*z] ^ pow2[z + 2*y]);
                m[1] = mul(inv[det], pow2[2*y] ^ pow2[2*z]);
                m[2] = mul(inv[det], pow2[y] ^ pow2[z]);
                m[3] = mul(inv[det], pow2[x + 2*z] ^ pow2[z + 2*x]);
                m[4] = mul(inv[det], pow2[2*x] ^ pow2[2*z]);
                m[5] = mul(inv[det], pow2[x] ^ pow2[z]);
                m[6] = mul(inv[det], pow2[x + 2*y] ^ pow2[y + 2*x]);
                m[7] = mul(inv[det], pow2[2*x] ^ pow2[2*y]);
                m[8] = mul(inv[det], pow2[x] ^ pow2[y]);
                printf("\t{ ");
                for (i = 0; i < 9; i++)
                    printf("0x%02x, ", m[i]);
                printf("},\n");
            }
    printf("};\n");

    /* Generate map (x,y,z) -> canonical index */
    memset(r3map, 0xFF, sizeof(r3map));
    n = 0;
    for (x = 0; x < N; x++)
        for (y = x + 1; y < N; y++)
            for (z = y + 1; z < N; z++) {
                r3map[x][y][z] = n;
                r3map[x][z][y] = n;
                r3map[y][x][z] = n;
                r3map[y][z][x] = n;
                r3map[z][x][y] = n;
                r3map[z][y][x] = n++;
            }
    assert(n <= (1<<16));

    printf("const uint16_t rs_r3map[RS_LIB_MAX_DATA_BLOCKS][RS_LIB_MAX_DATA_BLOCKS\n"
        "][RS_LIB_MAX_DATA_BLOCKS] = {\n");
    for (x = 0; x < N; x++) {
        printf("\t{ ");
        for (y = 0; y < N; y++) {
            printf("{ ");
            for (z = 0; z < N; z++)
                printf("%2d, ", r3map[x][y][z]);
            printf("},");
            if (y == N-1)
                printf(" },\n");
            else
                printf("\n\t  ");
        }
    }
    printf("};\n");

    return 0;
}
