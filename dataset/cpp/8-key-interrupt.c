/*
 * 基于MSP430G2553简单的多按键中断例程
 * 硬件描述：Launchpad G2553开发板上P2.2\P2.3\P2.4\P2.5分别接四个按钮
 * P1.0\P1.1\P1.2\P1.2分别接四个LED灯
 * 功能描述：按键按下的瞬间，相对于的LED灯亮，其他的灯灭
 *  Created on: 2015-4-3
 *  Author: 万有文
 */

#include "MSP430G2553.h"
//-----在main函数前提前申明函数-----
void P2_IODect();                      //时间检测函数
void P22_Onclick();                    //中断函数1
void P23_Onclick();                    //中断函数2
void P24_Onclick();                    //中断函数3
void P25_Onclick();                    //中断函数4
void GPIO_init();                      //端口初始化函数

void main(void)

{
	WDTCTL = WDTPW + WDTHOLD;	//关狗
	GPIO_init();				//IO初始化
	_enable_interrupts();		//使能总中断
	_bis_SR_register(LPM3_bits);//休眠
}

/******************************************************************************************************
 * 名       称：GPIO_Init()
 * 功       能：设定按键和LED控制IO的方向，启用按键IO的上拉电阻
 * 入口参数：无
 * 出口参数：无
 * 说       明：无
 * 范       例：无
 ******************************************************************************************************/
void GPIO_init()
{
	//-----设定P1.0和P1.6的输出初始值-----
	//P1DIR |= BIT0+BIT1+BIT2+BIT3;  //设定P1.0和P1.3为输出
	//P1OUT &= ~(BIT0+BIT1+BIT2+BIT3); //设定P1.0初值
	//-----配合机械按键，启用内部上拉电阻-----
	P2REN |= BIT2+BIT3+BIT4+BIT5;  //启用P2.2...内部上下拉电阻
	P2OUT |= BIT2+BIT3+BIT4+BIT5;  //将电阻设置为上拉
	//-----配置P1.3中断参数-----
	P2DIR &= ~(BIT2+BIT3+BIT4+BIT5); // P2.2....设为输入(可省略)
	P2IES |= BIT2+BIT3+BIT4+BIT5;    // P2.2....设为下降沿中断
	P2IE  |= BIT2+BIT3+BIT4+BIT5;    // 允许P2.2..中断
}
/******************************************************************************************************
 * 名       称：PORT1_ISR()
 * 功       能：响应P1口的外部中断服务
 * 入口参数：无
 * 出口参数：无
 * 说       明：P1.0~P1.8共用了PORT1中断，所以在PORT1_ISR()中必须查询标志位P1IFG才能知道
 * 					 具体是哪个IO引发了外部中断。P1IFG必须手动清除，否则将持续引发PORT1中断。
 * 范       例：无
 ******************************************************************************************************/
#pragma vector = PORT2_VECTOR                      //端口2的中断向量
__interrupt void PORT2_ISR(void)
{
	//-----启用Port1事件检测函数-----
	P2_IODect();			    //检测通过，则会调用事件处理函数
   	P2IFG=0;                   //退出中断前必须手动清除IO口中断标志
}

/******************************************************************************************************
 * 名       称：P1_IODect()
 * 功       能：判断具体引发中断的IO，并调用相应IO的中断事件处理函数
 * 入口参数：无
 * 出口参数：无
 * 说       明：该函数兼容所有8个IO的检测，请根据实际输入IO激活“检测代码”。
 * 					 本例中，仅有P1.3被用作输入IO，所以其他7个IO的“检测代码”没有被“激活”。
 * 范       例：无
 ******************************************************************************************************/
void P2_IODect()
{
	unsigned int Push_Key=0;
	//-----排除输出IO的干扰后，锁定唯一被触发的中断标志位-----
	Push_Key=P2IFG&(~P2DIR);
	//-----延时一段时间，避开机械抖动区域-----
	__delay_cycles(10000);			//消抖延时
	//----判断按键状态是否与延时前一致-----
	if((P2IN&Push_Key)==0) 	        //如果该次按键确实有效
   {
	 //----判断具体哪个IO被按下，调用该IO的事件处理函数-----
	  switch(Push_Key){
//	 case BIT0:	P10_Onclick();		break;
//	 case BIT1: 	P11_Onclick();		break;
	 case BIT2: 	P22_Onclick();		break;
	 case BIT3: 	P23_Onclick();		break;
	 case BIT4: 	P24_Onclick();		break;
	 case BIT5: 	P25_Onclick();		break;
//	 case BIT6: 	P16_Onclick();		break;
//	 case BIT7: 	P17_Onclick();		break;
	 default:							break;		//任何情况下均加上default
	 }
   }
}
/******************************************************************************************************
 * 名       称：P13_Onclick()
 * 功       能：P1.3的中断事件处理函数，即当P1.3键被按下后，下一步干什么
 * 入口参数：无
 * 出口参数：无
 * 说       明：使用事件处理函数的形式，可以增强代码的移植性和可读性
 * 范       例：无
 ******************************************************************************************************/
void P22_Onclick()                               //可换作用户执行的相应函数
{
    P1DIR |= BIT0;
	//-----翻转IO电平-----
	P1OUT ^= BIT0;

	P1OUT &= ~(BIT1+BIT2+BIT3);
	}

void P23_Onclick()                                //可换作用户执行的相应函数
{
	 P1DIR |= BIT1;
	//-----翻转IO电平-----
	P1OUT ^= BIT1;
	P1OUT &= ~(BIT0+BIT2+BIT3);
	}

void P24_Onclick()                                //可换作用户执行的相应函数
{
	 P1DIR |= BIT2;
	//-----翻转IO电平-----
	P1OUT ^= BIT2;
	P1OUT &= ~(BIT0+BIT1+BIT3);
	}

void P25_Onclick()                                //可换作用户执行的相应函数
{
	 P1DIR |= BIT3;
	//-----翻转IO电平-----
	P1OUT ^= BIT3;
	P1OUT &= ~(BIT0+BIT1+BIT2);
	}
