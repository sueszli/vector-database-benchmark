
//
// Warning: don't edit - generated by generate_ecu_code.pl processing ../dev/ucx2_i01.json: KLE 15: Convenience charging electronics
// This generated code  makes it easier to process CANBUS messages from the KLE ecu in a BMW i3
//

  case I3_PID_KLE_FLASH_DSPS: {                                                   // 0xAF43
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_FLASH_DSPS", 1);
        break;
    }

    unsigned char STAT_DSP_FLASHING = (RXBUF_UCHAR(0));
        // DSP programming status. / Status der DSP-Programmierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "FLASH_DSPS", "STAT_DSP_FLASHING", STAT_DSP_FLASHING, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_BETRIEBSZUSTAND_LADEGERAET: {                                   // 0xDE84
    if (datalen < 16) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_BETRIEBSZUSTAND_LADEGERAET", 16);
        break;
    }

    float STAT_NETZFREQUENZ_PHASE_1_WERT = (RXBUF_UCHAR(0)/4.0f);
        // Current grid frequency phase 1 / Aktuelle Netzfrequenz Phase 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "STAT_NETZFREQUENZ_PHASE_1_WERT", STAT_NETZFREQUENZ_PHASE_1_WERT, "\"Hz\"");

    unsigned char BF_LADEGERAET_DERATING = (RXBUF_UCHAR(1));
        // Reason for derating / Grund für Derating
        // BF_LADEGERAET_DERATING is a BITFIELD of size unsigned char.  We don't yet generate definitions for each bit, we treat as the host data type
            // STAT_DERATING_BIT0: Mask: 0x01 - Overtemperature: 0 = not active; 1 = active
            // STAT_DERATING_BIT1: Mask: 0x02 - Mains frequency too low: 0 = not active; 1 = active
            // STAT_DERATING_BIT2: Mask: 0x04 - Failure of a charging module: 0 = not active; 1 = active
            // STAT_DERATING_BIT3: Mask: 0x08 - DC current limitation: 0 = not active; 1 = active
            // STAT_DERATING_BIT4: Mask: 0x10 - Network available power of lower nominal power: 0 = not active; 1 = active
            // STAT_DERATING_BIT5: Mask: 0x20 - Reserved
            // STAT_DERATING_BIT6: Mask: 0x40 - Reserved
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "BF_LADEGERAET_DERATING", (unsigned long)BF_LADEGERAET_DERATING, "\"Bit\"");

    float STAT_LEISTUNG_DERATING_WERT = (RXBUF_UINT(2)*10.0f);
        // Derating performance / Derating Leistung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "STAT_LEISTUNG_DERATING_WERT", STAT_LEISTUNG_DERATING_WERT, "\"W\"");

    unsigned char STAT_DERATING_WERT = (RXBUF_UCHAR(4));
        // Derating / Derating
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "STAT_DERATING_WERT", STAT_DERATING_WERT, "\"%\"");

    unsigned char BF_LADEGERAET_FEHLERZUSTAND_UCXII = (RXBUF_UCHAR(5));
        // Charger fault conditions / Ladegerät Fehlerzustände 
        // BF_LADEGERAET_FEHLERZUSTAND_UCXII is a BITFIELD of size unsigned char.  We don't yet generate definitions for each bit, we treat as the host data type
            // STAT_FEHLERZUSTAND_BIT0: Mask: 0x01 - Derating: 0 = not active; 1 = active
            // STAT_FEHLERZUSTAND_BIT1: Mask: 0x02 - Charge interruption: 0 = not active; 1 = active
            // STAT_FEHLERZUSTAND_BIT2: Mask: 0x04 - Failsafe: 0 = not active; 1 = active
            // STAT_FEHLERZUSTAND_BIT3: Mask: 0x08 - Communication failure: 0 = not active; 1 = active
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "BF_LADEGERAET_FEHLERZUSTAND_UCXII", (unsigned long)BF_LADEGERAET_FEHLERZUSTAND_UCXII, "\"Bit\"");

    unsigned short BF_AUSLOESER_FAILSAFE_UCXII = (RXBUF_UINT(6));
        // Failsafe trigger / Auslöser Failsafe
        // BF_AUSLOESER_FAILSAFE_UCXII is a BITFIELD of size unsigned int.  We don't yet generate definitions for each bit, we treat as the host data type
            // STAT_AUSLOESER_FAILSAFE_BIT0: Mask: 0x001 - Hardware error: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT1: Mask: 0x002 - Undervoltage AC: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT2: Mask: 0x004 - Overvoltage AC: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT3: Mask: 0x008 - Overcurrent AC: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT4: Mask: 0x010 - Undervoltage DC: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT5: Mask: 0x020 - Overvoltage DC: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT6: Mask: 0x040 - Overcurrent DC: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT7: Mask: 0x080 - Temperature: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT8: Mask: 0x100 - Communication error: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT9: Mask: 0x200 - Load initialization timeout: 0 = not active; 1 = active
            // STAT_AUSLOESER_FAILSAFE_BIT10: Mask: 0x400 - Controller undervoltage: 0 = not active; 1 = active
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "BF_AUSLOESER_FAILSAFE_UCXII", (unsigned long)BF_AUSLOESER_FAILSAFE_UCXII, "\"Bit\"");

    unsigned char BF_LADEGERAET_URSACHE_LADEUNTERBRECHUNG = (RXBUF_UCHAR(8));
        // Cause of charging interruption / Ursache für Ladeunterbrechung
        // BF_LADEGERAET_URSACHE_LADEUNTERBRECHUNG is a BITFIELD of size unsigned char.  We don't yet generate definitions for each bit, we treat as the host data type
            // STAT_URSACHE_LADEUNTERBRECHUNG_BIT0: Mask: 0x01 - Forced separation of the plug: 0 = not active; 1 = active
            // STAT_URSACHE_LADEUNTERBRECHUNG_BIT1: Mask: 0x02 - AC voltage missing or grid connection unstable: 0 = not active; 1 = active
            // STAT_URSACHE_LADEUNTERBRECHUNG_BIT2: Mask: 0x04 - Connector not locked: 0 = not active; 1 = active
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "BF_LADEGERAET_URSACHE_LADEUNTERBRECHUNG", (unsigned long)BF_LADEGERAET_URSACHE_LADEUNTERBRECHUNG, "\"Bit\"");

    unsigned char STAT_BETRIEBSART_NR = (RXBUF_UCHAR(9));
        // Operating mode / Betriebsart
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "STAT_BETRIEBSART_NR", STAT_BETRIEBSART_NR, "\"0-n\"");

    float STAT_NETZFREQUENZ_PHASE_2_WERT = (RXBUF_UCHAR(10)/4.0f);
        // Current grid frequency phase 2 / Aktuelle Netzfrequenz Phase 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "STAT_NETZFREQUENZ_PHASE_2_WERT", STAT_NETZFREQUENZ_PHASE_2_WERT, "\"Hz\"");

    float STAT_NETZFREQUENZ_PHASE_3_WERT = (RXBUF_UCHAR(11)/4.0f);
        // Current grid frequency phase 3 / Aktuelle Netzfrequenz Phase 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "STAT_NETZFREQUENZ_PHASE_3_WERT", STAT_NETZFREQUENZ_PHASE_3_WERT, "\"Hz\"");

    unsigned long BF_MOD_ERR = (RXBUF_UINT32(12));
        // Error states load module / Fehlerzustände Lademodul
        // BF_MOD_ERR is a BITFIELD of size unsigned long.  We don't yet generate definitions for each bit, we treat as the host data type
            // STAT_BF_DSP_ERR_HVDCV_OORL: Mask: 0x00000001 - PM HVDC voltage sensor outside lower threshold: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_HVDCV_OORH: Mask: 0x00000002 - PM HVDC voltage sensor outside upper threshold: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_HVDCI_OORH: Mask: 0x00000004 - PM HVDC current sensor outside upper threshold value: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_IRES_OORH: Mask: 0x00000008 - PM sensor resonance current outside the upper threshold value: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_VBUS_OORL: Mask: 0x00000010 - PM sensor bus voltage outside the lower threshold value: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_VBUS_OORH: Mask: 0x00000020 - PM sensor bus voltage outside the upper threshold value: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_OVERTEMPERATURE: Mask: 0x00000040 - PM temperature sensor outside upper threshold value: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_UNDERTEMPERATURE: Mask: 0x00000080 - PM temperature sensor outside lower threshold: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_HVDCV_SHGND: Mask: 0x00000100 - PM HVDC voltage sensor short circuit to ground: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_HVDCI_SHGND: Mask: 0x00000200 - PM HVDC current sensor short circuit to ground: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_AC_I_OORH: Mask: 0x00000400 - PM AC current sensor outside upper threshold: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_AC_I_SHGND: Mask: 0x00000800 - PM AC current sensor short circuit to ground: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_VAC_LX_SHBATT: Mask: 0x00001000 - PM AC Lx current sensor short circuit to positive: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_VAC_LX_SHGND: Mask: 0x00002000 - PM AC Lx current sensor short circuit to ground: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_IRES_SHBATT: Mask: 0x00004000 - PM sensor resonance current short circuit to plus: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_IRES_SHGND: Mask: 0x00008000 - PM sensor resonance current short circuit to ground: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_CAN_ALIVE: Mask: 0x00010000 - PM error test ALIVE: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_CAN_MSG401_TOUT: Mask: 0x00020000 - PM error timeout telegram 0x401: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_CAN_MSG300_TOUT: Mask: 0x00040000 - PM error timeout telegram 0x300: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_SPI_PROTOCOL: Mask: 0x00080000 - PM error SPI protocol: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_SPI_WIPER0_MISMATCH: Mask: 0x00100000 - PM error SPI Wiper0 discrepancy: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_SPI_WIPER1_MISMATCH: Mask: 0x00200000 - PM error SPI Wiper1 discrepancy: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_RAM: Mask: 0x00400000 - PM error RAM: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_WATCHDOG: Mask: 0x00800000 - PM watchdog error: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_STACKOVFL: Mask: 0x01000000 - PM stack overflow: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_DATA_INTEGRITY: Mask: 0x02000000 - PM data integrity: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_CLOCK: Mask: 0x04000000 - PM clock: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_CRC_CALIBRATION: Mask: 0x08000000 - PM CRC calibration: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_VAC_LY_SHBATT: Mask: 0x10000000 - PM AC Ly voltage sensor short circuit to plus: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_VAC_LY_SHGND: Mask: 0x20000000 - PM AC Ly voltage sensor short circuit to ground: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_VAC_LX_OORH: Mask: 0x40000000 - PM AC Lx voltage sensor outside upper threshold value: 0 = not active; 1 = active
            // STAT_BF_DSP_ERR_VAC_LY_OORH: Mask: 0x80000000 - PM AC Ly voltage sensor outside upper threshold: 0 = not active; 1 = active
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET", "BF_MOD_ERR", (unsigned long)BF_MOD_ERR, "\"Bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_LEISTUNG: {                                          // 0xDE85
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_LEISTUNG", 4);
        break;
    }

    unsigned char STAT_WIRKUNGSGRAD_LADEZYKLUS_WERT = (RXBUF_UCHAR(0));
        // Charge cycle efficiency / Wirkungsgrad Ladezyklus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_LEISTUNG", "STAT_WIRKUNGSGRAD_LADEZYKLUS_WERT", STAT_WIRKUNGSGRAD_LADEZYKLUS_WERT, "\"%\"");

    unsigned char STAT_WIRKUNGSGRAD_DC_WERT = (RXBUF_UCHAR(1));
        // Efficiency DC / Wirkungsgrad DC
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_LEISTUNG", "STAT_WIRKUNGSGRAD_DC_WERT", STAT_WIRKUNGSGRAD_DC_WERT, "\"%\"");

    unsigned short STAT_LADEGERAET_DC_HV_LEISTUNG_WERT = (RXBUF_UINT(2));
        // Instantaneous power output in the intermediate circuit / Abgegebende Momentanleistung in den Zwischenkreis
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_LEISTUNG", "STAT_LADEGERAET_DC_HV_LEISTUNG_WERT", STAT_LADEGERAET_DC_HV_LEISTUNG_WERT, "\"W\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_SPANNUNG: {                                          // 0xDE86
    if (datalen < 12) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_SPANNUNG", 12);
        break;
    }

    unsigned short STAT_SPANNUNG_RMS_AC_PHASE_1_WERT = (RXBUF_UINT(0));
        // RMS values of the AC conductor voltages (phase 1) / Effektivwerte der AC Leiterspannungen (Phase1)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_SPANNUNG", "STAT_SPANNUNG_RMS_AC_PHASE_1_WERT", STAT_SPANNUNG_RMS_AC_PHASE_1_WERT, "\"V\"");

    float STAT_SPANNUNG_DC_HV_OBERGRENZE_WERT = (RXBUF_UINT(2)/10.0f);
        // HV DC voltage upper limit / HV DC Spannungsobergrenze
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_SPANNUNG", "STAT_SPANNUNG_DC_HV_OBERGRENZE_WERT", STAT_SPANNUNG_DC_HV_OBERGRENZE_WERT, "\"V\"");

    float STAT_SPANNUNG_DC_HV_WERT = (RXBUF_UINT(4)/10.0f);
        // HV DC voltage / HV DC Spannung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_SPANNUNG", "STAT_SPANNUNG_DC_HV_WERT", STAT_SPANNUNG_DC_HV_WERT, "\"V\"");

    float STAT_SPANNUNG_KL30_WERT = (RXBUF_UCHAR(6)/10.0f);
        // KL30 voltage / KL30 Spannung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_SPANNUNG", "STAT_SPANNUNG_KL30_WERT", STAT_SPANNUNG_KL30_WERT, "\"V\"");

    float STAT_SPANNUNG_KL30C_WERT = (RXBUF_UCHAR(7)/10.0f);
        // KL30C voltage / KL30C Spannung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_SPANNUNG", "STAT_SPANNUNG_KL30C_WERT", STAT_SPANNUNG_KL30C_WERT, "\"V\"");

    unsigned short STAT_SPANNUNG_RMS_AC_PHASE_2_WERT = (RXBUF_UINT(8));
        // RMS values of the AC conductor voltages (phase 2) / Effektivwerte der AC Leiterspannungen (Phase 2)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_SPANNUNG", "STAT_SPANNUNG_RMS_AC_PHASE_2_WERT", STAT_SPANNUNG_RMS_AC_PHASE_2_WERT, "\"V\"");

    unsigned short STAT_SPANNUNG_RMS_AC_PHASE_3_WERT = (RXBUF_UINT(10));
        // RMS values of the AC conductor voltages (phase 3) / Effektivwerte der AC Leiterspannungen (Phase 3)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_SPANNUNG", "STAT_SPANNUNG_RMS_AC_PHASE_3_WERT", STAT_SPANNUNG_RMS_AC_PHASE_3_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_STROM: {                                             // 0xDE87
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_STROM", 14);
        break;
    }

    float STAT_STROM_AC_PHASE_1_WERT = (RXBUF_UINT(0)/10.0f);
        // AC current phase 1 / AC Strom Phase 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM", "STAT_STROM_AC_PHASE_1_WERT", STAT_STROM_AC_PHASE_1_WERT, "\"A\"");

    float STAT_STROM_AC_MAX_GESPEICHERT_WERT = (RXBUF_UINT(2)/10.0f);
        // Maximum stored AC current / Maximal gespeicherter AC Strom
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM", "STAT_STROM_AC_MAX_GESPEICHERT_WERT", STAT_STROM_AC_MAX_GESPEICHERT_WERT, "\"A\"");

    float STAT_STROM_HV_DC_WERT = (RXBUF_UINT(4)/10.0f-204.7);
        // HV DC electricity / HV DC Strom
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM", "STAT_STROM_HV_DC_WERT", STAT_STROM_HV_DC_WERT, "\"A\"");

    float STAT_STROM_HV_DC_MAX_LIMIT_WERT = (RXBUF_UINT(6)/10.0f);
        // Maximum permitted HV DC current / Maximal erlaubter HV DC Strom
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM", "STAT_STROM_HV_DC_MAX_LIMIT_WERT", STAT_STROM_HV_DC_MAX_LIMIT_WERT, "\"A\"");

    float STAT_STROM_HV_DC_MAX_GESPEICHERT_WERT = (RXBUF_UINT(8)/10.0f-204.7);
        // Maximum stored DC current / Maximal gespeicherter DC Strom
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM", "STAT_STROM_HV_DC_MAX_GESPEICHERT_WERT", STAT_STROM_HV_DC_MAX_GESPEICHERT_WERT, "\"A\"");

    float STAT_STROM_AC_PHASE_2_WERT = (RXBUF_UINT(10)/10.0f);
        // AC current phase 2 / AC Strom Phase 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM", "STAT_STROM_AC_PHASE_2_WERT", STAT_STROM_AC_PHASE_2_WERT, "\"A\"");

    float STAT_STROM_AC_PHASE_3_WERT = (RXBUF_UINT(12)/10.0f);
        // AC current phase 3 / AC Strom Phase 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM", "STAT_STROM_AC_PHASE_3_WERT", STAT_STROM_AC_PHASE_3_WERT, "\"A\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_AC_PHASENANZAHL: {                                              // 0xDF25
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_AC_PHASENANZAHL", 1);
        break;
    }

    unsigned char STAT_AC_PHASENANZAHL_WERT = (RXBUF_UCHAR(0));
        // Status of the number of AC phases / Status AC-Phasenanzahl
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "AC_PHASENANZAHL", "STAT_AC_PHASENANZAHL_WERT", STAT_AC_PHASENANZAHL_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_LADEDAUER: {                                         // 0xDFB0
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_LADEDAUER", 8);
        break;
    }

    unsigned long STAT_MINUTEN_LADEZYKLUS_WERT = (RXBUF_UINT32(0));
        // Charging time in minutes / Ladezeit in Minuten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADEDAUER", "STAT_MINUTEN_LADEZYKLUS_WERT", STAT_MINUTEN_LADEZYKLUS_WERT, "\"min\"");

    unsigned short STAT_SEKUNDEN_LADEZYKLUS_WERT = (RXBUF_UINT(4));
        // Loading time in seconds / Ladezeit in Sekunden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_LADEDAUER", "STAT_SEKUNDEN_LADEZYKLUS_WERT", STAT_SEKUNDEN_LADEZYKLUS_WERT, "\"s\"");

    unsigned short STAT_LADEZYKLEN_WERT = (RXBUF_UINT(6));
        // Number of charging cycles / Anzahl der Ladezyklen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_LADEDAUER", "STAT_LADEZYKLEN_WERT", STAT_LADEZYKLEN_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_TEMPERATUREN: {                                      // 0xDFB1
    if (datalen < 10) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_TEMPERATUREN", 10);
        break;
    }

    unsigned char STAT_NTC1_TEMPERATUR_WERT = (RXBUF_UCHAR(0)-75.0);
        // internal temperature (temperature sensor 1) / interne Temperatur (Temperatursensor 1)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC1_TEMPERATUR_WERT", STAT_NTC1_TEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_NTC2_TEMPERATUR_WERT = (RXBUF_UCHAR(1)-75.0);
        // internal temperature (temperature sensor 2) / interne Temperatur (Temperatursensor 2)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC2_TEMPERATUR_WERT", STAT_NTC2_TEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_NTC3_TEMPERATUR_WERT = (RXBUF_UCHAR(2)-75.0);
        // internal temperature (temperature sensor 3) / interne Temperatur (Temperatursensor 3)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC3_TEMPERATUR_WERT", STAT_NTC3_TEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_NTC4_TEMPERATUR_WERT = (RXBUF_UCHAR(3)-75.0);
        // internal temperature (temperature sensor 4) / interne Temperatur (Temperatursensor 4)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC4_TEMPERATUR_WERT", STAT_NTC4_TEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_NTC5_TEMPERATUR_WERT = (RXBUF_UCHAR(4)-75.0);
        // internal temperature (temperature sensor 5) / interne Temperatur (Temperatursensor 5)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC5_TEMPERATUR_WERT", STAT_NTC5_TEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_NTC6_TEMPERATUR_WERT = (RXBUF_UCHAR(5)-75.0);
        // internal temperature (temperature sensor 6) / interne Temperatur (Temperatursensor 6)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC6_TEMPERATUR_WERT", STAT_NTC6_TEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_NTC7_TEMPERAUTR_WERT = (RXBUF_UCHAR(6)-75.0);
        // internal temperature (temperature sensor 7) / interne Temperatur (Temperatursensor 7)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC7_TEMPERAUTR_WERT", STAT_NTC7_TEMPERAUTR_WERT, "\"°C\"");

    unsigned char STAT_NTC8_TEMPERATUR_WERT = (RXBUF_UCHAR(7)-75.0);
        // internal temperature (temperature sensor 8) / interne Tempeartur (Temperatursensor 8)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC8_TEMPERATUR_WERT", STAT_NTC8_TEMPERATUR_WERT, "\"°C\"");

    unsigned char STAT_NTC9_TEMPEARTUR_WERT = (RXBUF_UCHAR(8)-75.0);
        // internal temperature (temperature sensor 9) / interne Temperatur (Temperatursensor 9)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC9_TEMPEARTUR_WERT", STAT_NTC9_TEMPEARTUR_WERT, "\"°C\"");

    unsigned char STAT_NTC10_TEMPEARTUR_WERT = (RXBUF_UCHAR(9)-75.0);
        // internal temperature (temperature sensor 10) / interne Temperatur (Temperatursensor 10)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_TEMPERATUREN", "STAT_NTC10_TEMPEARTUR_WERT", STAT_NTC10_TEMPEARTUR_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_LEISTUNG2: {                                         // 0xDFB4
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_LEISTUNG2", 4);
        break;
    }

    unsigned char STAT_WIRKUNGSGRAD_LADEZYKLUS_WERT_0XDFB4 = (RXBUF_UCHAR(0));
        // Charge cycle efficiency / Wirkungsgrad Ladezyklus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_LEISTUNG2", "STAT_WIRKUNGSGRAD_LADEZYKLUS_WERT_0XDFB4", STAT_WIRKUNGSGRAD_LADEZYKLUS_WERT_0XDFB4, "\"%\"");

    unsigned char STAT_WIRKUNGSGRAD_DC_WERT_0XDFB4 = (RXBUF_UCHAR(1));
        // Efficiency DC / Wirkungsgrad DC
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "LADEGERAET_LEISTUNG2", "STAT_WIRKUNGSGRAD_DC_WERT_0XDFB4", STAT_WIRKUNGSGRAD_DC_WERT_0XDFB4, "\"%\"");

    unsigned short STAT_LADEGERAET_DC_HV_LEISTUNG_WERT_0XDFB4 = (RXBUF_UINT(2));
        // Instantaneous power output in the intermediate circuit / Abgegebende Momentanleistung in den Zwischenkreis
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_LEISTUNG2", "STAT_LADEGERAET_DC_HV_LEISTUNG_WERT_0XDFB4", STAT_LADEGERAET_DC_HV_LEISTUNG_WERT_0XDFB4, "\"W\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_LADE_HISTOGRAMM: {                                   // 0xDFB6
    if (datalen < 40) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_LADE_HISTOGRAMM", 40);
        break;
    }

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_1_WERT = (RXBUF_UINT32(0));
        // Seconds at temperature below 0 ° C / Sekunden bei Temperatur unter 0°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_1_WERT", STAT_SEKUNDEN_TEMPERATUR_BEREICH_1_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_2_WERT = (RXBUF_UINT32(4));
        // Seconds at a temperature between 0 ° C and 45 ° C / Sekunden bei Temperatur zwischen 0°C und 45°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_2_WERT", STAT_SEKUNDEN_TEMPERATUR_BEREICH_2_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_3_WERT = (RXBUF_UINT32(8));
        // Seconds at a temperature between 46 ° C and 60 ° C / Sekunden bei Temperatur zwischen 46°C und 60°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_3_WERT", STAT_SEKUNDEN_TEMPERATUR_BEREICH_3_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_4_WERT = (RXBUF_UINT32(12));
        // Seconds in the temperature range between 61 ° C and 70 ° C / Sekunden im Temperaturbereich zwischen 61°C und
        // 70°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_4_WERT", STAT_SEKUNDEN_TEMPERATUR_BEREICH_4_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_5_WERT = (RXBUF_UINT32(16));
        // Seconds at a temperature between 71 ° C and 85 ° C / Sekunden bei Temperatur zwischen 71°C und 85°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_5_WERT", STAT_SEKUNDEN_TEMPERATUR_BEREICH_5_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_6_WERT = (RXBUF_UINT32(20));
        // Seconds at temperatures above 85 ° C / Sekunden bei Temperatur über 85°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_6_WERT", STAT_SEKUNDEN_TEMPERATUR_BEREICH_6_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_LEISTUNG_BEREICH_1_WERT = (RXBUF_UINT32(24));
        // Seconds at power below 1000W / Sekunden bei Leistung unter 1000W
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_LEISTUNG_BEREICH_1_WERT", STAT_SEKUNDEN_LEISTUNG_BEREICH_1_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_LEISTUNG_BEREICH_2_WERT = (RXBUF_UINT32(28));
        // Seconds at power between 1001W and 2000W / Sekunden bei Leistung zwischen 1001W und 2000W
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_LEISTUNG_BEREICH_2_WERT", STAT_SEKUNDEN_LEISTUNG_BEREICH_2_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_LEISTUNG_BEREICH_3_WERT = (RXBUF_UINT32(32));
        // Seconds at power between 2001W and 3000W / Sekunden bei Leistung zwischen 2001W und 3000W
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_LEISTUNG_BEREICH_3_WERT", STAT_SEKUNDEN_LEISTUNG_BEREICH_3_WERT, "\"s\"");

    unsigned long STAT_SEKUNDEN_LEISTUNG_BEREICH_4_WERT = (RXBUF_UINT32(36));
        // Seconds at power over 3000W / Sekunden bei Leistung über 3000W
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM", "STAT_SEKUNDEN_LEISTUNG_BEREICH_4_WERT", STAT_SEKUNDEN_LEISTUNG_BEREICH_4_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_LADE_HISTOGRAMM2: {                                  // 0xDFB7
    if (datalen < 40) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_LADE_HISTOGRAMM2", 40);
        break;
    }

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_1_WERT_0XDFB7 = (RXBUF_UINT32(0));
        // Seconds at temperature below 0 ° C / Sekunden bei Temperatur unter 0°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_1_WERT_0XDFB7", STAT_SEKUNDEN_TEMPERATUR_BEREICH_1_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_2_WERT_0XDFB7 = (RXBUF_UINT32(4));
        // Seconds at a temperature between 0 ° C and 45 ° C / Sekunden bei Temperatur zwischen 0°C und 45°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_2_WERT_0XDFB7", STAT_SEKUNDEN_TEMPERATUR_BEREICH_2_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_3_WERT_0XDFB7 = (RXBUF_UINT32(8));
        // Seconds at a temperature between 46 ° C and 60 ° C / Sekunden bei Temperatur zwischen 46°C und 60°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_3_WERT_0XDFB7", STAT_SEKUNDEN_TEMPERATUR_BEREICH_3_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_4_WERT_0XDFB7 = (RXBUF_UINT32(12));
        // Seconds in the temperature range between 61 ° C and 70 ° C / Sekunden im Temperaturbereich zwischen 61°C und
        // 70°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_4_WERT_0XDFB7", STAT_SEKUNDEN_TEMPERATUR_BEREICH_4_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_5_WERT_0XDFB7 = (RXBUF_UINT32(16));
        // Seconds at a temperature between 71 ° C and 85 ° C / Sekunden bei Temperatur zwischen 71°C und 85°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_5_WERT_0XDFB7", STAT_SEKUNDEN_TEMPERATUR_BEREICH_5_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_TEMPERATUR_BEREICH_6_WERT_0XDFB7 = (RXBUF_UINT32(20));
        // Seconds at temperatures above 85 ° C / Sekunden bei Temperatur über 85°C
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_TEMPERATUR_BEREICH_6_WERT_0XDFB7", STAT_SEKUNDEN_TEMPERATUR_BEREICH_6_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_LEISTUNG_BEREICH_1_WERT_0XDFB7 = (RXBUF_UINT32(24));
        // Seconds at power below 1000W / Sekunden bei Leistung unter 1000W
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_LEISTUNG_BEREICH_1_WERT_0XDFB7", STAT_SEKUNDEN_LEISTUNG_BEREICH_1_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_LEISTUNG_BEREICH_2_WERT_0XDFB7 = (RXBUF_UINT32(28));
        // Seconds at power between 1001W and 2000W / Sekunden bei Leistung zwischen 1001W und 2000W
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_LEISTUNG_BEREICH_2_WERT_0XDFB7", STAT_SEKUNDEN_LEISTUNG_BEREICH_2_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_LEISTUNG_BEREICH_3_WERT_0XDFB7 = (RXBUF_UINT32(32));
        // Seconds at power between 2001W and 3000W / Sekunden bei Leistung zwischen 2001W und 3000W
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_LEISTUNG_BEREICH_3_WERT_0XDFB7", STAT_SEKUNDEN_LEISTUNG_BEREICH_3_WERT_0XDFB7, "\"s\"");

    unsigned long STAT_SEKUNDEN_LEISTUNG_BEREICH_4_WERT_0XDFB7 = (RXBUF_UINT32(36));
        // Seconds at power over 3000W / Sekunden bei Leistung über 3000W
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADE_HISTOGRAMM2", "STAT_SEKUNDEN_LEISTUNG_BEREICH_4_WERT_0XDFB7", STAT_SEKUNDEN_LEISTUNG_BEREICH_4_WERT_0XDFB7, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_LADEDAUER2: {                                        // 0xDFB8
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_LADEDAUER2", 8);
        break;
    }

    unsigned long STAT_MINUTEN_LADEZYKLUS_WERT_0XDFB8 = (RXBUF_UINT32(0));
        // Charging time in minutes / Ladezeit in Minuten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEGERAET_LADEDAUER2", "STAT_MINUTEN_LADEZYKLUS_WERT_0XDFB8", STAT_MINUTEN_LADEZYKLUS_WERT_0XDFB8, "\"min\"");

    unsigned short STAT_SEKUNDEN_LADEZYKLUS_WERT_0XDFB8 = (RXBUF_UINT(4));
        // Loading time in seconds / Ladezeit in Sekunden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_LADEDAUER2", "STAT_SEKUNDEN_LADEZYKLUS_WERT_0XDFB8", STAT_SEKUNDEN_LADEZYKLUS_WERT_0XDFB8, "\"s\"");

    unsigned short STAT_LADEZYKLEN_WERT_0XDFB8 = (RXBUF_UINT(6));
        // Number of charging cycles / Anzahl der Ladezyklen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_LADEDAUER2", "STAT_LADEZYKLEN_WERT_0XDFB8", STAT_LADEZYKLEN_WERT_0XDFB8, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_UMSCHALTMATRIX: {                                               // 0xDFB9
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_UMSCHALTMATRIX", 20);
        break;
    }

    unsigned long STAT_SCHALTER1_SCHALTZYKLEN_ANZAHL_WERT = (RXBUF_UINT32(0));
        // Number of switching cycles for switch 1 (multi-phase charging: phase 1) / Anzahl von Schaltzyklen für Schalter
        // 1 (mehrphasiges Laden: Phase 1)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "UMSCHALTMATRIX", "STAT_SCHALTER1_SCHALTZYKLEN_ANZAHL_WERT", STAT_SCHALTER1_SCHALTZYKLEN_ANZAHL_WERT, "");

    unsigned long STAT_SCHALTER2_SCHALTZYKLEN_ANZAHL_WERT = (RXBUF_UINT32(4));
        // Number of switching cycles for switch 2 (multi-phase charging: phase 2) / Anzahl von Schaltzyklen für Schalter
        // 2 (mehrphasiges Laden: Phase 2)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "UMSCHALTMATRIX", "STAT_SCHALTER2_SCHALTZYKLEN_ANZAHL_WERT", STAT_SCHALTER2_SCHALTZYKLEN_ANZAHL_WERT, "");

    unsigned long STAT_SCHALTER3_SCHALTZYKLEN_ANZAHL_WERT = (RXBUF_UINT32(8));
        // Number of switching cycles for switch 3 (multi-phase charging: phase 3) / Anzahl von Schaltzyklen für Schalter
        // 3 (mehrphasiges Laden: Phase 3)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "UMSCHALTMATRIX", "STAT_SCHALTER3_SCHALTZYKLEN_ANZAHL_WERT", STAT_SCHALTER3_SCHALTZYKLEN_ANZAHL_WERT, "");

    unsigned long STAT_SCHALTER4_SCHALTZYKLEN_ANZAHL_WERT = (RXBUF_UINT32(12));
        // Number of switching cycles for switch 4 (multi-phase charging: changeover) / Anzahl von Schaltzyklen für
        // Schalter 4 (mehrphasiges Laden: Umschaltung)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "UMSCHALTMATRIX", "STAT_SCHALTER4_SCHALTZYKLEN_ANZAHL_WERT", STAT_SCHALTER4_SCHALTZYKLEN_ANZAHL_WERT, "");

    unsigned char STAT_SCHALTER1 = (RXBUF_UCHAR(16));
        // State of switch 1 (0 = open, 1 = closed) / Zustand vom Schalter 1 (0= offen, 1=geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "UMSCHALTMATRIX", "STAT_SCHALTER1", STAT_SCHALTER1, "\"0/1\"");

    unsigned char STAT_SCHALTER2 = (RXBUF_UCHAR(17));
        // State of switch 2 (0 = open, 1 = closed) / Zustand vom Schalter 2 (0= offen, 1=geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "UMSCHALTMATRIX", "STAT_SCHALTER2", STAT_SCHALTER2, "\"0/1\"");

    unsigned char STAT_SCHALTER3 = (RXBUF_UCHAR(18));
        // State of switch 3 (0 = open, 1 = closed) / Zustand vom Schalter 3 (0= offen, 1=geschlossen)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "UMSCHALTMATRIX", "STAT_SCHALTER3", STAT_SCHALTER3, "\"0/1\"");

    unsigned char STAT_SCHALTER4 = (RXBUF_UCHAR(19));
        // State of switch 4 (0 = charger 1, 1 = charger 2) / Zustand vom Schalter 4 (0= Ladegerät 1, 1=Ladegerät 2)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "UMSCHALTMATRIX", "STAT_SCHALTER4", STAT_SCHALTER4, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_SPANNUNG2: {                                         // 0xDFBA
    if (datalen < 12) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_SPANNUNG2", 12);
        break;
    }

    unsigned short STAT_SPANNUNG_RMS_AC_PHASE_1_WERT_0XDFBA = (RXBUF_UINT(0));
        // RMS values of the AC conductor voltages (phase 1) / Effektivwerte der AC Leiterspannungen (Phase1)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_SPANNUNG2", "STAT_SPANNUNG_RMS_AC_PHASE_1_WERT_0XDFBA", STAT_SPANNUNG_RMS_AC_PHASE_1_WERT_0XDFBA, "\"V\"");

    float STAT_SPANNUNG_DC_HV_OBERGRENZE_WERT_0XDFBA = (RXBUF_UINT(2)/10.0f);
        // HV DC voltage upper limit / HV DC Spannungsobergrenze
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_SPANNUNG2", "STAT_SPANNUNG_DC_HV_OBERGRENZE_WERT_0XDFBA", STAT_SPANNUNG_DC_HV_OBERGRENZE_WERT_0XDFBA, "\"V\"");

    float STAT_SPANNUNG_DC_HV_WERT_0XDFBA = (RXBUF_UINT(4)/10.0f);
        // HV DC voltage / HV DC Spannung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_SPANNUNG2", "STAT_SPANNUNG_DC_HV_WERT_0XDFBA", STAT_SPANNUNG_DC_HV_WERT_0XDFBA, "\"V\"");

    float STAT_SPANNUNG_KL30_WERT_0XDFBA = (RXBUF_UCHAR(6)/10.0f);
        // KL30 voltage / KL30 Spannung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_SPANNUNG2", "STAT_SPANNUNG_KL30_WERT_0XDFBA", STAT_SPANNUNG_KL30_WERT_0XDFBA, "\"V\"");

    float STAT_SPANNUNG_KL30C_WERT_0XDFBA = (RXBUF_UCHAR(7)/10.0f);
        // KL30C voltage / KL30C Spannung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_SPANNUNG2", "STAT_SPANNUNG_KL30C_WERT_0XDFBA", STAT_SPANNUNG_KL30C_WERT_0XDFBA, "\"V\"");

    unsigned short STAT_SPANNUNG_RMS_AC_PHASE_2_WERT_0XDFBA = (RXBUF_UINT(8));
        // RMS values of the AC conductor voltages (phase 2) / Effektivwerte der AC Leiterspannungen (Phase 2)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_SPANNUNG2", "STAT_SPANNUNG_RMS_AC_PHASE_2_WERT_0XDFBA", STAT_SPANNUNG_RMS_AC_PHASE_2_WERT_0XDFBA, "\"V\"");

    unsigned short STAT_SPANNUNG_RMS_AC_PHASE_3_WERT_0XDFBA = (RXBUF_UINT(10));
        // RMS values of the AC conductor voltages (phase 3) / Effektivwerte der AC Leiterspannungen (Phase 3)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEGERAET_SPANNUNG2", "STAT_SPANNUNG_RMS_AC_PHASE_3_WERT_0XDFBA", STAT_SPANNUNG_RMS_AC_PHASE_3_WERT_0XDFBA, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEGERAET_STROM2: {                                            // 0xDFBB
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEGERAET_STROM2", 14);
        break;
    }

    float STAT_STROM_AC_PHASE_1_WERT_0XDFBB = (RXBUF_UINT(0)/10.0f);
        // AC current phase 1 / AC Strom Phase 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM2", "STAT_STROM_AC_PHASE_1_WERT_0XDFBB", STAT_STROM_AC_PHASE_1_WERT_0XDFBB, "\"A\"");

    float STAT_STROM_AC_MAX_GESPEICHERT_WERT_0XDFBB = (RXBUF_UINT(2)/10.0f);
        // Maximum stored AC current / Maximal gespeicherter AC Strom
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM2", "STAT_STROM_AC_MAX_GESPEICHERT_WERT_0XDFBB", STAT_STROM_AC_MAX_GESPEICHERT_WERT_0XDFBB, "\"A\"");

    float STAT_STROM_HV_DC_WERT_0XDFBB = (RXBUF_UINT(4)/10.0f-204.7);
        // HV DC electricity / HV DC Strom
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM2", "STAT_STROM_HV_DC_WERT_0XDFBB", STAT_STROM_HV_DC_WERT_0XDFBB, "\"A\"");

    float STAT_STROM_HV_DC_MAX_LIMIT_WERT_0XDFBB = (RXBUF_UINT(6)/10.0f);
        // Maximum permitted HV DC current / Maximal erlaubter HV DC Strom
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM2", "STAT_STROM_HV_DC_MAX_LIMIT_WERT_0XDFBB", STAT_STROM_HV_DC_MAX_LIMIT_WERT_0XDFBB, "\"A\"");

    float STAT_STROM_HV_DC_MAX_GESPEICHERT_WERT_0XDFBB = (RXBUF_UINT(8)/10.0f-204.7);
        // Maximum stored DC current / Maximal gespeicherter DC Strom
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM2", "STAT_STROM_HV_DC_MAX_GESPEICHERT_WERT_0XDFBB", STAT_STROM_HV_DC_MAX_GESPEICHERT_WERT_0XDFBB, "\"A\"");

    float STAT_STROM_AC_PHASE_2_WERT_0XDFBB = (RXBUF_UINT(10)/10.0f);
        // AC current phase 2 / AC Strom Phase 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM2", "STAT_STROM_AC_PHASE_2_WERT_0XDFBB", STAT_STROM_AC_PHASE_2_WERT_0XDFBB, "\"A\"");

    float STAT_STROM_AC_PHASE_3_WERT_0XDFBB = (RXBUF_UINT(12)/10.0f);
        // AC current phase 3 / AC Strom Phase 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "LADEGERAET_STROM2", "STAT_STROM_AC_PHASE_3_WERT_0XDFBB", STAT_STROM_AC_PHASE_3_WERT_0XDFBB, "\"A\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_BETRIEBSZUSTAND_LADEGERAET2: {                                  // 0xDFBC
    if (datalen < 12) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_BETRIEBSZUSTAND_LADEGERAET2", 12);
        break;
    }

    float STAT_NETZFREQUENZ_PHASE_1_WERT_0XDFBC = (RXBUF_UCHAR(0)/4.0f);
        // Current grid frequency phase 1 / Aktuelle Netzfrequenz Phase 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "STAT_NETZFREQUENZ_PHASE_1_WERT_0XDFBC", STAT_NETZFREQUENZ_PHASE_1_WERT_0XDFBC, "\"Hz\"");

    unsigned char BF_LADEGERAET_DERATING_0XDFBC = (RXBUF_UCHAR(1));
        // Reason for derating / Grund für Derating
            // BF_LADEGERAET_DERATING_0XDFBC is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "BF_LADEGERAET_DERATING_0XDFBC", (unsigned long)BF_LADEGERAET_DERATING_0XDFBC, "\"Bit\"");

    float STAT_LEISTUNG_DERATING_WERT_0XDFBC = (RXBUF_UINT(2)*10.0f);
        // Derating performance / Derating Leistung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "STAT_LEISTUNG_DERATING_WERT_0XDFBC", STAT_LEISTUNG_DERATING_WERT_0XDFBC, "\"W\"");

    unsigned char STAT_DERATING_WERT_0XDFBC = (RXBUF_UCHAR(4));
        // Derating / Derating
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "STAT_DERATING_WERT_0XDFBC", STAT_DERATING_WERT_0XDFBC, "\"%\"");

    unsigned char BF_LADEGERAET_FEHLERZUSTAND_UCXII_0XDFBC = (RXBUF_UCHAR(5));
        // Charger fault conditions / Ladegerät Fehlerzustände
            // BF_LADEGERAET_FEHLERZUSTAND_UCXII_0XDFBC is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "BF_LADEGERAET_FEHLERZUSTAND_UCXII_0XDFBC", (unsigned long)BF_LADEGERAET_FEHLERZUSTAND_UCXII_0XDFBC, "\"Bit\"");

    unsigned char BF_AUSLOESER_FAILSAFE_UCXII_0XDFBC = (RXBUF_UCHAR(6));
        // Failsafe trigger / Auslöser Failsafe
            // BF_AUSLOESER_FAILSAFE_UCXII_0XDFBC is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "BF_AUSLOESER_FAILSAFE_UCXII_0XDFBC", (unsigned long)BF_AUSLOESER_FAILSAFE_UCXII_0XDFBC, "\"Bit\"");

    unsigned char BF_LADEGERAET_URSACHE_LADEUNTERBRECHUNG_0XDFBC = (RXBUF_UCHAR(7));
        // Cause of charging interruption / Ursache für Ladeunterbrechung
            // BF_LADEGERAET_URSACHE_LADEUNTERBRECHUNG_0XDFBC is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "BF_LADEGERAET_URSACHE_LADEUNTERBRECHUNG_0XDFBC", (unsigned long)BF_LADEGERAET_URSACHE_LADEUNTERBRECHUNG_0XDFBC, "\"Bit\"");

    unsigned char STAT_BETRIEBSART_NR_0XDFBC = (RXBUF_UCHAR(8));
        // Operating mode / Betriebsart
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "STAT_BETRIEBSART_NR_0XDFBC", STAT_BETRIEBSART_NR_0XDFBC, "\"0-n\"");

    float STAT_NETZFREQUENZ_PHASE_2_WERT_0XDFBC = (RXBUF_UCHAR(9)/4.0f);
        // Current grid frequency phase 2 / Aktuelle Netzfrequenz Phase 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "STAT_NETZFREQUENZ_PHASE_2_WERT_0XDFBC", STAT_NETZFREQUENZ_PHASE_2_WERT_0XDFBC, "\"Hz\"");

    float STAT_NETZFREQUENZ_PHASE_3_WERT_0XDFBC = (RXBUF_UCHAR(10)/4.0f);
        // Current grid frequency phase 3 / Aktuelle Netzfrequenz Phase 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "STAT_NETZFREQUENZ_PHASE_3_WERT_0XDFBC", STAT_NETZFREQUENZ_PHASE_3_WERT_0XDFBC, "\"Hz\"");

    unsigned char BF_MOD_ERR_0XDFBC = (RXBUF_UCHAR(11));
        // Error states load module / Fehlerzustände Lademodul
            // BF_MOD_ERR_0XDFBC is a BITFIELD of unknown size.  We don't have definitions for each bit, and we GUESSED it is one byte ***
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "KLE", "BETRIEBSZUSTAND_LADEGERAET2", "BF_MOD_ERR_0XDFBC", (unsigned long)BF_MOD_ERR_0XDFBC, "\"Bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_LADEDAUER_LADEART: {                                            // 0xDFBD
    if (datalen < 16) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_LADEDAUER_LADEART", 16);
        break;
    }

    unsigned long STAT_MINUTEN_LADEZYKLUS_1PH_WERT = (RXBUF_UINT32(0));
        // Charging time in minutes for single-phase charging / Ladezeit in Minuten für einphasiges Laden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEDAUER_LADEART", "STAT_MINUTEN_LADEZYKLUS_1PH_WERT", STAT_MINUTEN_LADEZYKLUS_1PH_WERT, "\"min\"");

    unsigned short STAT_SEKUNDEN_LADEZYKLUS_1PH_WERT = (RXBUF_UINT(4));
        // Charging time in seconds for single-phase charging / Ladezeit in Sekunden für einphasiges Laden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEDAUER_LADEART", "STAT_SEKUNDEN_LADEZYKLUS_1PH_WERT", STAT_SEKUNDEN_LADEZYKLUS_1PH_WERT, "\"s\"");

    unsigned short STAT_LADEZYKLUS_1PH_WERT = (RXBUF_UINT(6));
        // Number of charging cycles, single-phase charging / Anzahl Ladezyklus einphasiges Laden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEDAUER_LADEART", "STAT_LADEZYKLUS_1PH_WERT", STAT_LADEZYKLUS_1PH_WERT, "");

    unsigned long STAT_MINUTEN_LADEZYKLUS_3PH_WERT = (RXBUF_UINT32(8));
        // Charging time in minutes for multi-phase charging / Ladezeit in Minuten für mehrphasiges Laden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KLE", "LADEDAUER_LADEART", "STAT_MINUTEN_LADEZYKLUS_3PH_WERT", STAT_MINUTEN_LADEZYKLUS_3PH_WERT, "\"min\"");

    unsigned short STAT_SEKUNDEN_LADEZYKLUS_3PH_WERT = (RXBUF_UINT(12));
        // Charging time in seconds for multi-phase charging / Ladezeit in Sekunden für mehrphasiges Laden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEDAUER_LADEART", "STAT_SEKUNDEN_LADEZYKLUS_3PH_WERT", STAT_SEKUNDEN_LADEZYKLUS_3PH_WERT, "\"s\"");

    unsigned short STAT_LADEZYKLUS_3PH_WERT = (RXBUF_UINT(14));
        // Number of charging cycles, multi-phase charging / Anzahl Ladezyklus mehrphasiges Laden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KLE", "LADEDAUER_LADEART", "STAT_LADEZYKLUS_3PH_WERT", STAT_LADEZYKLUS_3PH_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KLE_FLASH_DSPS_0XF000: {                                            // 0xF000
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KLE_FLASH_DSPS_0XF000", 1);
        break;
    }

    unsigned char STAT_DSP_FLASHING_0XF000 = (RXBUF_UCHAR(0));
        // DSP programming status. / Status der DSP-Programmierung.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KLE", "FLASH_DSPS_0XF000", "STAT_DSP_FLASHING_0XF000", STAT_DSP_FLASHING_0XF000, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }
