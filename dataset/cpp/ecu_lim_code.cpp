
//
// Warning: don't edit - generated by generate_ecu_code.pl processing ../dev/lim_i1.json: LIM 14: Charging interface module
// This generated code  makes it easier to process CANBUS messages from the LIM ecu in a BMW i3
//

  case I3_PID_LIM_STATUS_CALCVN: {                                                // 0x2541
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_STATUS_CALCVN", 20);
        break;
    }

    unsigned long STAT_CVN_WERT = (RXBUF_UINT32(16));
        // Read out CVN (here the CVN must be output as in mode $ 09 (PID $ 06)) / CVN auslesen (hier muss die CVN wie
        // bei Mode $09 (PID $06) ausgegeben werden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "LIM", "STATUS_CALCVN", "STAT_CVN_WERT", STAT_CVN_WERT, "\"HEX\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_LIM_LADESTECKDOSE_TEMPERATUR: {                                     // 0xDB0F
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_LADESTECKDOSE_TEMPERATUR", 2);
        break;
    }

    float STAT_LADESTECKDOSE_TEMP_WERT = (RXBUF_UINT(0)/10.0f-40.0);
        // Temperature of the DC charging connection in ° C (China) / Temperatur der DC-Ladeanschluss in °C (China)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "LIM", "LADESTECKDOSE_TEMPERATUR", "STAT_LADESTECKDOSE_TEMP_WERT", STAT_LADESTECKDOSE_TEMP_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_LIM_LADEBEREITSCHAFT_LIM: {                                         // 0xDEF2
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_LADEBEREITSCHAFT_LIM", 1);
        break;
    }

    unsigned char STAT_LADEBEREITSCHAFT_LIM = (RXBUF_UCHAR(0));
        // Ready to charge (HW line), (1 = yes, 0 = no) sent from LIM to SLE / Ladebereitschaft (HW-Leitung), (1 = ja, 0
        // = nein) vom LIM an SLE gesendet
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "LADEBEREITSCHAFT_LIM", "STAT_LADEBEREITSCHAFT_LIM", STAT_LADEBEREITSCHAFT_LIM, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_LIM_PROXIMITY: {                                                    // 0xDEF5
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_PROXIMITY", 2);
        break;
    }

    unsigned char STAT_STECKER_NR = (RXBUF_UCHAR(0));
        // Condition of the plug / Zustand des Steckers
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "PROXIMITY", "STAT_STECKER_NR", STAT_STECKER_NR, "\"0-n\"");

    unsigned char STAT_STROMTRAGFAEHIGKEIT_WERT = (RXBUF_UCHAR(1));
        // Current carrying capacity of the connected cable / Stromtragfähigkeit des angeschlossenen Kabels
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "PROXIMITY", "STAT_STROMTRAGFAEHIGKEIT_WERT", STAT_STROMTRAGFAEHIGKEIT_WERT, "\"A\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_LIM_PILOTSIGNAL: {                                                  // 0xDEF6
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_PILOTSIGNAL", 7);
        break;
    }

    unsigned char STAT_PILOT_AKTIV = (RXBUF_UCHAR(0));
        // State of the pilot signal (0 = not active, 1 = active) / Zustand des Pilotsignals (0 = nicht aktiv, 1 = aktiv)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "PILOTSIGNAL", "STAT_PILOT_AKTIV", STAT_PILOT_AKTIV, "\"0/1\"");

    unsigned char STAT_PILOT_PWM_DUTYCYCLE_WERT = (RXBUF_UCHAR(1));
        // Pulse duty factor PWM pilot signal / Tastverhältnis PWM Pilotsignal
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "PILOTSIGNAL", "STAT_PILOT_PWM_DUTYCYCLE_WERT", STAT_PILOT_PWM_DUTYCYCLE_WERT, "\"%\"");

    unsigned char STAT_PILOT_CURRENT_WERT = (RXBUF_UCHAR(2));
        // Current value calculated from the pilot signal / Errechneter Stromwert aus Pilotsignal
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "PILOTSIGNAL", "STAT_PILOT_CURRENT_WERT", STAT_PILOT_CURRENT_WERT, "\"A\"");

    unsigned char STAT_PILOT_LADEBEREIT = (RXBUF_UCHAR(3));
        // Vehicle ready to charge state (0 = not ready to charge, 1 = ready to charge) / Zustand Ladebereitschaft
        // Fahrzeug (0 = nicht ladebereit, 1 = ladebereit)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "PILOTSIGNAL", "STAT_PILOT_LADEBEREIT", STAT_PILOT_LADEBEREIT, "\"0/1\"");

    unsigned short STAT_PILOT_FREQUENZ_WERT = (RXBUF_UINT(4));
        // Frequency of the pilot signal / Frequenz des Pilotsignals
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "LIM", "PILOTSIGNAL", "STAT_PILOT_FREQUENZ_WERT", STAT_PILOT_FREQUENZ_WERT, "\"Hz\"");

    float STAT_PILOT_PEGEL_WERT = (RXBUF_UCHAR(6)/10.0f);
        // Pilot signal level / Pegel des Pilotsignals
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "LIM", "PILOTSIGNAL", "STAT_PILOT_PEGEL_WERT", STAT_PILOT_PEGEL_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_LIM_LADESCHNITTSTELLE_DC_TEPCO: {                                   // 0xDEF7
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_LADESCHNITTSTELLE_DC_TEPCO", 4);
        break;
    }

    unsigned char STAT_CHARGE_CONTROL_1 = (RXBUF_UCHAR(0));
        // Charge control status 1 line (0 = not active, 1 = active) / Zustand Charge control 1 Leitung (0 = nicht aktiv,
        // 1 = aktiv)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "LADESCHNITTSTELLE_DC_TEPCO", "STAT_CHARGE_CONTROL_1", STAT_CHARGE_CONTROL_1, "\"0/1\"");

    unsigned char STAT_CHARGE_CONTROL_2 = (RXBUF_UCHAR(1));
        // Charge control status 2 line (0 = not active, 1 = active) / Zustand Charge control 2 Leitung (0 = nicht aktiv,
        // 1 = aktiv)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "LADESCHNITTSTELLE_DC_TEPCO", "STAT_CHARGE_CONTROL_2", STAT_CHARGE_CONTROL_2, "\"0/1\"");

    unsigned char STAT_CHARGE_PERMISSION = (RXBUF_UCHAR(2));
        // Charge permission line status (0 = not active, 1 = active) / Zustand Charge Permission Leitung (0 = nicht
        // aktiv, 1 = aktiv)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "LADESCHNITTSTELLE_DC_TEPCO", "STAT_CHARGE_PERMISSION", STAT_CHARGE_PERMISSION, "\"0/1\"");

    unsigned char STAT_LADESTECKER = (RXBUF_UCHAR(3));
        // State of charging plug (0 = not plugged in, 1 = plugged in) / Zustand Ladestecker (0 = nicht gesteckt, 1 =
        // gesteckt)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "LADESCHNITTSTELLE_DC_TEPCO", "STAT_LADESTECKER", STAT_LADESTECKER, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_LIM_DC_SCHUETZ_SCHALTER: {                                          // 0xDEF8
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_DC_SCHUETZ_SCHALTER", 1);
        break;
    }

    unsigned char STAT_DC_SCHUETZ_SCHALTER = (RXBUF_UCHAR(0));
        // Contactor switch status (DC charging) / Status Schützschalter (DC-Laden)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "DC_SCHUETZ_SCHALTER", "STAT_DC_SCHUETZ_SCHALTER", STAT_DC_SCHUETZ_SCHALTER, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_LIM_DC_SCHUETZ_SPANNUNG_EINGANG: {                                  // 0xDEF9
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_DC_SCHUETZ_SPANNUNG_EINGANG", 3);
        break;
    }

    unsigned short STAT_DC_SCHUETZ_SPANNUNG_EINGANG_WERT = (RXBUF_UINT(0));
        // Voltage at the input of the relay box (contactors) for DC charging / Spannung am Eingang der Relaisbox
        // (Schaltschütze) für DC-Laden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "LIM", "DC_SCHUETZ_SPANNUNG_EINGANG", "STAT_DC_SCHUETZ_SPANNUNG_EINGANG_WERT", STAT_DC_SCHUETZ_SPANNUNG_EINGANG_WERT, "\"V\"");

    unsigned char STAT_DC_SCHUETZ_SPANNUNG_NEGATIV = (RXBUF_UCHAR(2));
        // Detection of a negative voltage (0 = no or positive voltage / 1 = negative voltage) / Erkennung einer
        // negativen Spannung (0 = keine oder positive Spannung / 1 = negative Spannung)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "DC_SCHUETZ_SPANNUNG_EINGANG", "STAT_DC_SCHUETZ_SPANNUNG_NEGATIV", STAT_DC_SCHUETZ_SPANNUNG_NEGATIV, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_LIM_DC_PINABDECKUNG_COMBO: {                                        // 0xDEFA
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_LIM_DC_PINABDECKUNG_COMBO", 1);
        break;
    }

    unsigned char STAT_DC_PINABDECKUNG = (RXBUF_UCHAR(0));
        // State of the DC pin cover for combo socket (0 = closed, 1 = open) / Zustand der DC Pinabdeckung bei
        // Combo-Steckdose (0 = geschlossen, 1 = geöffnet)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "LIM", "DC_PINABDECKUNG_COMBO", "STAT_DC_PINABDECKUNG", STAT_DC_PINABDECKUNG, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }
