/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/runtime/populate_hbruntime.C $                        */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016,2023                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

/**
 *  @file populate_runtime.C
 *
 *  @brief Populate HDAT Area for Host runtime data
 */

#include <kernel/vmmmgr.H>
#include <sys/misc.h>
#include <trace/interface.H>
#include <errl/errlentry.H>
#include <initservice/initserviceif.H>
#include <targeting/common/target.H>
#include <targeting/common/targetservice.H>
#include <targeting/common/utilFilter.H>
#include <targeting/common/entitypath.H>
#include <targeting/common/commontargeting.H>
#include <targeting/common/mfgFlagAccessors.H>
#include <targeting/targplatutil.H>
#include <runtime/runtime_reasoncodes.H>
#include <runtime/runtime.H>
#include "hdatstructs.H"
#include <mbox/ipc_msg_types.H>
#include <sys/task.h>
#include <intr/interrupt.H>
#include <errl/errlmanager.H>
#include <sys/internode.h>
#include <vpd/vpd_if.H>
#include <pnor/pnorif.H>
#include <targeting/attrrp.H>
#include <sys/mm.h>
#include <util/align.H>
#include <secureboot/trustedbootif.H>
#include <secureboot/service.H>
#include <secureboot/key_clear_if.H>
#include <pldm/base/hb_bios_attrs_if.H>
#include <hdat/hdat.H>
#include "../hdat/hdattpmdata.H"
#include "../hdat/hdatpcrd.H"
#include "../secureboot/trusted/tpmLogMgr.H"
#include "../secureboot/trusted/trustedboot.H"
#include <targeting/common/attributeTank.H>
#include <runtime/interface.h>
#include <targeting/attrPlatOverride.H>
#include <sbeio/sbeioif.H>
#include <sbeio/sbe_psudd.H>
#include <sbeio/runtime/sbe_msg_passing.H>
#include <kernel/bltohbdatamgr.H>
#include <util/utilrsvdmem.H>
#include <util/utillidpnor.H>
#include <stdio.h>
#include <runtime/populate_hbruntime.H>
#include <runtime/preverifiedlidmgr.H>
#include <util/utilmclmgr.H>
#include <pnor/pnor_reasoncodes.H>
#include <runtime/common/runtime_utils.H>
#include <limits.h>
#include <errno.h>
#include <vmmconst.h>
#include <runtime/customize_attrs_for_payload.H>
#include <isteps/mem_utils.H>
#include <secureboot/smf_utils.H>
#include <secureboot/smf.H>
#include <isteps/istep_reasoncodes.H>
#include <dump/dumpif.H>
#include <hdatpcrd.H>

trace_desc_t *g_trac_runtime = nullptr;
TRAC_INIT(&g_trac_runtime, RUNTIME_COMP_NAME, KILOBYTE);

namespace RUNTIME
{

mutex_t g_rhbMutex = MUTEX_INITIALIZER;

// used for populating the TPM required bit in HDAT
const uint16_t TPM_REQUIRED_BIT = 0x8000; //leftmost bit of uint16_t set to 1

const uint8_t BITS_PER_BYTE = 8;

const uint8_t HDAT_INVALID_NODE = 0xFF;




//
uint16_t calculateNodeInstance(const uint8_t i_node,
                               const uint8_t i_hb_images)
{

    // initalizing instance to -1 here will make the loop below simpler
    // because the first functional node represented in hb_images should be
    // counted as instance 0
    uint16_t instance = -1;

    // if hb_images is empty, then we only have a single node
    if( i_hb_images )
    {
        // leftmost position indicates node 0
        uint8_t l_mask =
            0x1 << (sizeof(i_hb_images)*BITS_PER_BYTE-1);

        uint16_t i = 0;

        while( i <= i_node )
        {
            // see if this node is valid
            if( i_hb_images & l_mask )
            {
                instance++;
            }
            l_mask = l_mask >> 1;
            i++;
        }
        // make sure our node is really active
        if(!( (0x80 >> i_node) & i_hb_images))
        {
            instance = HDAT_INVALID_NODE;
        }
    }
    else
    {
        // if we only have a single node, its instance
        // should be zero
        instance = 0;
    }

    return instance;
}


// Helper function to get the instance number from the
// node number. The instance is derived from the hb_images
// attribute, instance 0 will be the first active drawer
// in the sytem, if hb_images is zero this function will
// also return zero.
/**
 *  @brief Get the nodes instance from its node number
 *
 *  @param[out] instance - the nodes instance
 *  @return Error handle if error
 */

uint16_t getHdatNodeInstance(void)
{
    TARGETING::Target* sys = nullptr;
    TARGETING::targetService().getTopLevelTarget( sys );
    assert(sys != nullptr,
            "getHdatNodeInstance() - Could not obtain top level target");

    // This attribute will be non-zero only if there is more than one
    // functional node in the system
    const auto hb_images = sys->getAttr<TARGETING::ATTR_HB_EXISTING_IMAGE>();

    // get the node id
    const auto l_node = TARGETING::UTIL::getCurrentNodePhysId();

    uint16_t instance = calculateNodeInstance(l_node, hb_images);

    TRACFCOMP( g_trac_runtime,"node %d is hdat instance %d hb_images 0x%x",
            l_node, instance, hb_images);

    return instance;
}
/**
 *  @brief Get a pointer to the next available
 *          HDAT HB Reserved Memory entry
 *  @param[out] o_rngPtr Pointer to the addr range entry
 *  @return Error handle if error
 */
errlHndl_t getNextRhbAddrRange(hdatMsVpdRhbAddrRange_t* & o_rngPtr)
{
    errlHndl_t l_elog = nullptr;

    mutex_lock( &g_rhbMutex );

    do {

        TARGETING::Target * l_sys = nullptr;
        TARGETING::targetService().getTopLevelTarget( l_sys );
        assert(l_sys != nullptr,"getNextRhbAddrRange:top level target nullptr");


        uint32_t l_nextSection =
            l_sys->getAttr<TARGETING::ATTR_HB_RSV_MEM_NEXT_SECTION>();

        uint64_t l_rsvMemDataAddr = 0;
        uint64_t l_rsvMemDataSizeMax = 0;

        // there are 50 reserved memory spots per node,
        // use the node instance to index into the hb reserved mem pointers
        // for this node. HB_RSV_MEM_NUM_PTRS is defined as the number
        // of usable pointers - see runtime.H for some background
        uint16_t l_nodeInstance = getHdatNodeInstance();

        // if l_nodeInstance is not a valid node id, then there is a good
        // chance hb_images is not correct for some reason -
        assert((l_nodeInstance != HDAT_INVALID_NODE),
                "Invalid node instance returned from getHdatNodeInstance()")

        uint32_t instance = l_nextSection +
            (HB_RSV_MEM_NUM_PTRS * l_nodeInstance);

        // Get the address of the next section
        l_elog = RUNTIME::get_host_data_section( RUNTIME::RESERVED_MEM,
                instance,
                l_rsvMemDataAddr,
                l_rsvMemDataSizeMax );
        if(l_elog != nullptr)
        {
            TRACFCOMP( g_trac_runtime,
                    "getNextRhbAddrRange fail get_host_data_section %d",
                    l_nextSection );
            break;
        }

        o_rngPtr =
            reinterpret_cast<hdatMsVpdRhbAddrRange_t *>(l_rsvMemDataAddr);

        l_nextSection++;
        l_sys->setAttr
            <TARGETING::ATTR_HB_RSV_MEM_NEXT_SECTION>(l_nextSection);

    } while(0);

    mutex_unlock( &g_rhbMutex );

    return(l_elog);
}

errlHndl_t mapPhysAddr(uint64_t i_addr,
                       size_t i_size,
                       uint64_t& o_addr)
{
    errlHndl_t l_elog = nullptr;

    o_addr = reinterpret_cast<uint64_t>(mm_block_map(
                reinterpret_cast<void*>(i_addr), i_size));

    // Check if address returned from the block map is NULL
    if(o_addr == 0)
    {
        TRACFCOMP( g_trac_runtime,
                   "mapPhysAddr fail to map physical addr %p, size %lx",
                   reinterpret_cast<void*>(i_addr), i_size );

        /*@ errorlog tag
         * @errortype       ERRORLOG::ERRL_SEV_UNRECOVERABLE
         * @moduleid        RUNTIME::MOD_MAP_PHYS_ADDR
         * @reasoncode      RUNTIME::RC_CANNOT_MAP_MEMORY
         * @userdata1       Phys address we are trying to map
         * @userdata2       Size of memory we are trying to map
         *
         * @devdesc         Error mapping a virtual memory map
         * @custdesc        Kernel failed to map memory
         */
        l_elog = new ERRORLOG::ErrlEntry(
                            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                            RUNTIME::MOD_MAP_PHYS_ADDR,
                            RUNTIME::RC_CANNOT_MAP_MEMORY,
                            i_addr,
                            i_size,
                            true);
        l_elog->collectTrace(RUNTIME_COMP_NAME);
    }

    return l_elog;
}

errlHndl_t unmapVirtAddr(uint64_t i_addr)
{
    errlHndl_t l_elog = nullptr;

    int l_rc = mm_block_unmap(reinterpret_cast<void*>(i_addr));

    if(l_rc)
    {
        TRACFCOMP( g_trac_runtime,
                   "unmapVirtAddr fail to unmap virt addr %p",
                   reinterpret_cast<void*>(i_addr));
        /*@ errorlog tag
         * @errortype       ERRORLOG::ERRL_SEV_UNRECOVERABLE
         * @moduleid        RUNTIME::MOD_UNMAP_VIRT_ADDR
         * @reasoncode      RUNTIME::RC_UNMAP_FAIL
         * @userdata1       Virtual address we are trying to unmap
         * @userdata2       0
         * @devdesc         Error unmapping a virtual memory map
         * @custdesc        Kernel failed to unmap memory
         */
        l_elog = new ERRORLOG::ErrlEntry(
                            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                            RUNTIME::MOD_UNMAP_VIRT_ADDR,
                            RUNTIME::RC_UNMAP_FAIL,
                            i_addr,
                            0,
                            true);
        l_elog->collectTrace(RUNTIME_COMP_NAME);
    }

    return l_elog;
}


void traceHbRsvMemRange(hdatMsVpdRhbAddrRange_t* & i_rngPtr )
{
    TRACFCOMP(g_trac_runtime,
              "Setting HDAT HB Reserved Memory Range: "
              "%s RangeType 0x%X RangeId 0x%X "
              "StartAddress 0x%16llX EndAddress 0x%16llX Permissions 0x%.2X",
              i_rngPtr->hdatRhbLabelString,
              i_rngPtr->hdatRhbRngType,
              i_rngPtr->hdatRhbRngId,
              i_rngPtr->hdatRhbAddrRngStrAddr,
              i_rngPtr->hdatRhbAddrRngEndAddr,
              i_rngPtr->hdatRhbPermission);
}

errlHndl_t checkHbResMemLimit(const uint64_t i_addr, const uint64_t i_size)
{
    errlHndl_t l_errl = nullptr;

    // Find the start of HB addr space , which will be
    // the node base + the hostboot base addr
    uint64_t l_hostboot_base_addr = RUNTIME::getHbBaseAddrWithNodeOffset();

    // Address limits
    uint64_t l_lowerLimit = l_hostboot_base_addr + RESERVED_MEM_START_OFFSET;
    uint64_t l_upperLimit = l_hostboot_base_addr + RESERVED_MEM_END_OFFSET;

    TRACDCOMP(g_trac_runtime,
              "l_hostboot_base_addr 0x%.16llX, i_addr 0x%.16llX, l_lowerLimit 0x%.16llX",
              l_hostboot_base_addr, i_addr, l_lowerLimit);
    TRACDCOMP(g_trac_runtime, "i_size = 0x%.16llX, l_upperLimit = 0x%.16llX",
              i_size, l_upperLimit);

    // Only check if PHYP is running or if running in standalone.
    if(TARGETING::is_phyp_load() || TARGETING::is_no_load())
    {
        if( (i_addr < l_lowerLimit) ||
            ((i_addr + i_size - 1) > l_upperLimit) )
        {
            TRACFCOMP(g_trac_runtime, "checkHbResMemLimit> Attempt to write"
            " to hostboot reserved memory outside of allowed hostboot address"
            " range. Start addresss - 0x%08x end address - 0x%08x;"
            " bottom limit - 0x%08x top limit - 0x%08x.",
            i_addr, i_addr + i_size - 1, l_lowerLimit, l_upperLimit);

            /*@
             * @errortype
             * @moduleid     RUNTIME::MOD_CHECK_HB_RES_MEM_LIMIT
             * @reasoncode   RUNTIME::RC_HB_RES_MEM_EXCEEDED
             * @userdata1    Starting address
             * @userdata2    Size of the section
             * @devdesc      Hostboot attempted to reserve memory past allowed
             *               range. Bottom limit = Hostboot HRMOR + 64M, top
             *               limit = 256M - 4K.
             * @custdesc     Hostboot attempted to reserve memory outside of
             *               allowed range.
             */
            l_errl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                         RUNTIME::MOD_CHECK_HB_RES_MEM_LIMIT,
                                         RUNTIME::RC_HB_RES_MEM_EXCEEDED,
                                         i_addr,
                                         i_size,
                                         true /*Add HB Software Callout*/);
            l_errl->collectTrace(RUNTIME_COMP_NAME,KILOBYTE);
        }
    }
    return l_errl;
}

errlHndl_t setNextHbRsvMemEntry(const HDAT::hdatMsVpdRhbAddrRangeType i_type,
                                const uint16_t i_rangeId,
                                const uint64_t i_startAddr,
                                const uint64_t i_size,
                                const char* i_label,
                                const HDAT::hdatRhbPermType i_permission,
                                const bool i_checkMemoryLimit,
                                const bool i_skipHDAT)
{
    errlHndl_t l_elog = nullptr;

    do {
    // Check whether hostboot is trying to access memory outside of its allowed
    // range.
    if(i_checkMemoryLimit)
    {
        l_elog = checkHbResMemLimit(i_startAddr, i_size);
        if(l_elog)
        {
            break;
        }
    }

    // Skip HDAT lookup and manipulation
    if( i_skipHDAT )
    {
        TRACFCOMP(g_trac_runtime,
                  "Defining HB Reserved Memory Range: %s"
                  "RangeType 0x%X RangeId 0x%X "
                  "StartAddress 0x%16llX Size 0x%16llX",
                  i_label,
                  i_type,
                  i_rangeId,
                  i_startAddr,
                  i_size);
        break;
    }

    // Get a pointer to the next available HDAT HB Rsv Mem entry
    hdatMsVpdRhbAddrRange_t* l_rngPtr = nullptr;
    l_elog = getNextRhbAddrRange(l_rngPtr);
    if(l_elog)
    {
        break;
    }

    assert(l_rngPtr != nullptr, "getNextRhbAddrRange returned nullptr");

    // Determine starting address
    // Logical OR starting address with enum FORCE_PHYS_ADDR to
    //        ignore the HRMOR bit
    uint64_t l_startAddr = i_startAddr | VmmManager::FORCE_PHYS_ADDR;

    // Fill in the entry
    l_rngPtr->set(i_type, i_rangeId, l_startAddr, i_size, i_label,
                  i_permission);
    traceHbRsvMemRange(l_rngPtr);

    } while(0);

    return l_elog;
}

/**
 *  @brief Load the HB_DATA section for reserved memory
 *
 *  -----  HB Data Layout -------
 * io_start_address
 *    -- HB Table of Contents
 *    -- ATTR Override Data (optional)
 *    -- ATTR Data
 *    -- VPD
 *    -- HYPCOMM
 *    -- VPD Overrides
 *    -- HBRT Trace Area (master node only)
 *    -- Padding
 * io_end_address
 *
 * Either pass in a low starting physical address (io_start_address) or
 * a high ending physical address (io_end_address).
 * The function will then calculate the size of data and
 * determine the opposite address.
 * Set i_startAddressValid to true, if you set io_start_address.
 * Set i_startAddressValid to false, if you set io_end_address.
 *
 *  @param[in/out]  io_start_address where to start loading data
 *  @param[in/out]  io_end_address   where to stop loading data
 *  @param[in]      i_startAddressValid Is io_start_address valid?
 *  @param[out]     io_size if not zero, maxSize in bytes allowed
 *                          returns Total 64kb aligned size for all the data
 *  @param[in]      i_master_node = true if we are the master hb instance
 *  @return Error handle if error
 */
errlHndl_t fill_RsvMem_hbData(uint64_t & io_start_address,
                              uint64_t & io_end_address,
                              bool i_startAddressValid,
                              uint64_t & io_size,
                              bool i_master_node)
{
    TRACFCOMP( g_trac_runtime, ENTER_MRK"fill_RsvMem_hbData> io_start_address=0x%.16llX,io_end_address=0x%.16llX,startAddressValid=%d",
                io_start_address, io_end_address, i_startAddressValid?1:0 );

    errlHndl_t l_elog = nullptr;

    uint64_t l_vAddr = 0x0;
    uint64_t l_prevDataAddr = 0;
    uint64_t l_prevDataSize = 0;

    // TOC to be filled in and added to beginning of HB Data section
    Util::hbrtTableOfContents_t l_hbTOC;
    strcpy(l_hbTOC.toc_header, "Hostboot Table of Contents");
    l_hbTOC.toc_version = Util::HBRT_TOC_VERSION_1;
    l_hbTOC.total_entries = 0;

    /////////////////////////////////////////////////////////////
    // Figure out the total size needed so we can place the TOC
    // at the beginning
    /////////////////////////////////////////////////////////////
    uint64_t l_totalSectionSize = 0;

    // Begin with ATTROVER

    // default to the minimum space we have to allocate anyway
    size_t l_attrOverMaxSize = HBRT_RSVD_MEM_OPAL_ALIGN;

    // copy overrides into local buffer
    uint8_t* l_overrideData =
      reinterpret_cast<uint8_t*>(malloc(l_attrOverMaxSize));
    size_t l_actualSize = l_attrOverMaxSize;
    l_elog = TARGETING::AttrRP::saveOverrides( l_overrideData,
                                               l_actualSize );
    if( l_elog )
    {
        // check if the issue was a lack of space (unlikely)
        if( unlikely( l_actualSize > 0 ) )
        {
            TRACFCOMP( g_trac_runtime, "Expanding override section to %d", l_actualSize );
            free(l_overrideData);
            l_overrideData =
              reinterpret_cast<uint8_t*>(malloc(l_actualSize));
            l_elog = TARGETING::AttrRP::saveOverrides( l_overrideData,
                                                       l_actualSize );
        }

        // overrides are not critical so just commit this
        //  and keep going without any
        if( l_elog )
        {
            TRACFCOMP( g_trac_runtime, "Errors applying overrides, just skipping" );
            errlCommit( l_elog, RUNTIME_COMP_ID );
            l_elog = NULL;
            l_actualSize = 0;
        }
    }

    // Should we create an ATTROVER section?
    if (l_actualSize > 0)
    {
        l_hbTOC.entry[l_hbTOC.total_entries].label =
                                                Util::HBRT_MEM_LABEL_ATTROVER;
        l_hbTOC.entry[l_hbTOC.total_entries].offset = 0;
        l_hbTOC.entry[l_hbTOC.total_entries].size = l_actualSize;
        l_totalSectionSize += ALIGN_PAGE(l_actualSize);
        l_hbTOC.total_entries++;
    }

    // Now calculate ATTR size
    l_hbTOC.entry[l_hbTOC.total_entries].label = Util::HBRT_MEM_LABEL_ATTR;
    l_hbTOC.entry[l_hbTOC.total_entries].offset = 0;
    uint64_t l_attrSize = TARGETING::AttrRP::maxSize();
    // add 10% more extra space to account for a concurrent update
    //  that adds more attributes
    l_attrSize = ((l_attrSize*110)/100);
    l_hbTOC.entry[l_hbTOC.total_entries].size = l_attrSize;
    l_totalSectionSize +=
        ALIGN_PAGE(l_hbTOC.entry[l_hbTOC.total_entries].size);
    l_hbTOC.total_entries++;

#ifdef CONFIG_FSP_BUILD
    // Fill in VPD size (only on FSP machines)
    l_hbTOC.entry[l_hbTOC.total_entries].label = Util::HBRT_MEM_LABEL_VPD;
    l_hbTOC.entry[l_hbTOC.total_entries].offset = 0;
    l_hbTOC.entry[l_hbTOC.total_entries].size = VMM_RT_VPD_SIZE;
    l_totalSectionSize +=
        ALIGN_PAGE(l_hbTOC.entry[l_hbTOC.total_entries].size);
    l_hbTOC.total_entries++;
#endif

    // Fill in VPD_XXXX sizes (if there are any)
    VPD::OverrideRsvMemMap_t l_vpdOverrides;
    VPD::getListOfOverrideSections( l_vpdOverrides );
    for( auto l_over : l_vpdOverrides )
    {
        // Or in the specific label with the "VPD_" prefix
        l_hbTOC.entry[l_hbTOC.total_entries].label =
          Util::HBRT_MEM_LABEL_VPD_XXXX | l_over.first;
        l_hbTOC.entry[l_hbTOC.total_entries].offset = 0;
        l_hbTOC.entry[l_hbTOC.total_entries].size = l_over.second.size;
        l_totalSectionSize +=
          ALIGN_PAGE(l_hbTOC.entry[l_hbTOC.total_entries].size);
        l_hbTOC.total_entries++;
    }

    // Fill in the TRACEBUF & HYPCOMM only for Master Node
    if(i_master_node == true )
    {
        // Fill in TRACEBUF size
        l_hbTOC.entry[l_hbTOC.total_entries].label = Util::HBRT_MEM_LABEL_TRACEBUF;
        l_hbTOC.entry[l_hbTOC.total_entries].offset = 0;
        l_hbTOC.entry[l_hbTOC.total_entries].size = Util::HBRT_RSVD_TRACEBUF_SIZE;
        l_totalSectionSize +=
            ALIGN_PAGE(l_hbTOC.entry[l_hbTOC.total_entries].size);
        l_hbTOC.total_entries++;

        // Fill in HYPCOMM size
        l_hbTOC.entry[l_hbTOC.total_entries].label = Util::HBRT_MEM_LABEL_HYPCOMM;
        l_hbTOC.entry[l_hbTOC.total_entries].offset = 0;
        l_hbTOC.entry[l_hbTOC.total_entries].size = sizeof(hbHypCommArea_t);
        l_totalSectionSize +=
            ALIGN_PAGE(l_hbTOC.entry[l_hbTOC.total_entries].size);
        l_hbTOC.total_entries++;
    }
    l_totalSectionSize += sizeof(l_hbTOC);  // Add 4KB Table of Contents

    // Fill in PADDING size
    // Now calculate how much padding is needed for OPAL alignment
    // of the whole data section
    size_t l_totalSizeAligned = ALIGN_X( l_totalSectionSize,
                                         HBRT_RSVD_MEM_OPAL_ALIGN );

    // l_actualSizeAligned will bring section to OPAL alignment
    uint64_t l_actualSizeAligned = l_totalSizeAligned - l_totalSectionSize;

    // Do we need a Padding section?
    if (l_actualSizeAligned > 0)
    {
        // Add padding section
        l_hbTOC.entry[l_hbTOC.total_entries].label =
                                                Util::HBRT_MEM_LABEL_PADDING;
        l_hbTOC.entry[l_hbTOC.total_entries].offset = 0;
        l_hbTOC.entry[l_hbTOC.total_entries].size = l_actualSizeAligned;
        l_hbTOC.total_entries++;
    }

    // Set total_size to the 64k aligned size
    l_hbTOC.total_size = l_totalSizeAligned;

    do {

        if ((io_size != 0) && (io_size < l_totalSizeAligned))
        {
            // create an error
            TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData - Will exceed max allowed size %lld, need %lld",
                   io_size, l_totalSizeAligned);

            /*@ errorlog tag
             * @errortype       ERRORLOG::ERRL_SEV_UNRECOVERABLE
             * @moduleid        RUNTIME::MOD_FILL_RSVMEM_HBDATA
             * @reasoncode      RUNTIME::RC_EXCEEDED_MEMORY
             * @userdata1       Total size needed
             * @userdata2       Size allowed
             *
             * @devdesc         Unable to fill in HB data memory
             */
            l_elog = new ERRORLOG::ErrlEntry(
                                ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                RUNTIME::MOD_FILL_RSVMEM_HBDATA,
                                RUNTIME::RC_EXCEEDED_MEMORY,
                                l_totalSizeAligned,
                                io_size,
                                true);
            l_elog->collectTrace(RUNTIME_COMP_NAME);
            break;
        }

        // update return size to amount filled in
        io_size = l_totalSizeAligned;


        // Figure out the start and end addresses
        if (i_startAddressValid)
        {
            io_end_address = io_start_address + l_totalSizeAligned;
        }
        else
        {
            io_start_address = io_end_address - l_totalSizeAligned;
        }


        TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> mapping 0x%.16llX address, size %lld",
                io_start_address, l_totalSizeAligned );

        // Grab the virtual address for the entire HB Data section
        l_elog = mapPhysAddr(io_start_address, l_totalSizeAligned, l_vAddr);
        if(l_elog)
        {
            break;
        }

        TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> virtual start address: %p", l_vAddr);

        // Skip TOC at the beginning, pretend it was added
        l_prevDataAddr = l_vAddr;
        l_prevDataSize = sizeof(l_hbTOC);
        uint64_t l_offset = 0;

        int i = 0;
        while ( i < l_hbTOC.total_entries )
        {
            uint64_t actual_size = l_hbTOC.entry[i].size;
            uint64_t aligned_size = ALIGN_PAGE(actual_size);

            l_offset += l_prevDataSize;

            // update offset to current data section
            l_hbTOC.entry[i].offset = l_offset;

            l_prevDataAddr += l_prevDataSize;
            l_prevDataSize = aligned_size;

            switch ( l_hbTOC.entry[i].label )
            {
                case Util::HBRT_MEM_LABEL_ATTROVER:
                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> ATTROVER  v address 0x%.16llX, size: %lld", l_prevDataAddr, aligned_size);
                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> memcpy %d size", actual_size);
                    memcpy( reinterpret_cast<void*>(l_prevDataAddr),
                            l_overrideData,
                            actual_size);
                    break;
                case Util::HBRT_MEM_LABEL_ATTR:
                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> ATTR v address 0x%.16llX, size: %lld", l_prevDataAddr, aligned_size);
                    l_elog = TARGETING::AttrRP::save(
                                reinterpret_cast<uint8_t*>(l_prevDataAddr),
                                aligned_size);
                    if(l_elog)
                    {
                        TRACFCOMP( g_trac_runtime,
                                   "fill_RsvMem_hbData fail ATTR save call" );
                        break;
                    }
                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> TARGETING::AttrRP::save(0x%.16llX) done", l_prevDataAddr);
                    break;
                case Util::HBRT_MEM_LABEL_VPD:
                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> VPD v address 0x%.16llX, size: %lld", l_prevDataAddr, aligned_size);
                    l_elog = VPD::vpd_load_rt_image(l_prevDataAddr);
                    if(l_elog)
                    {
                        TRACFCOMP( g_trac_runtime,
                                   "fill_RsvMem_hbData> failed VPD call" );
                        break;
                    }
                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> VPD v address 0x%.16llX, size: %lld done", l_prevDataAddr, aligned_size);
                    break;
                case Util::HBRT_MEM_LABEL_HYPCOMM:
                {
                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> HYPCOMM v address 0x%.16llX, size: %lld", l_prevDataAddr, aligned_size);
                    //This will call default contructor setting up the version and magic number,
                    // and zero'ing out the data area
                    TARGETING::Target * sys = NULL;
                    TARGETING::targetService().getTopLevelTarget( sys );
                    assert(sys != NULL);

                    // Figure out what kind of payload we have
                    TARGETING::PAYLOAD_KIND payload_kind
                        = sys->getAttr<TARGETING::ATTR_PAYLOAD_KIND>();

                    hbHypCommArea_t l_hbCommArea;
                    static_assert((sizeof(hbHypCommArea_t) % 8) == 0,
                                  "hbHypCommArea_t's size must be 8 byte aligned");
                    uint64_t l_hdatPtrToHrmorStashAddr = 0;
                    size_t   l_hdatPtrHrmorStashSize   = 0;
                    uint64_t * l_pHdatPtrToHrmorStashAddr;
                    // memcpy a copy of the hbHypCommArea struct into the reserved mem area
                    memcpy( reinterpret_cast<void*>(l_prevDataAddr),
                            reinterpret_cast<void*>(&l_hbCommArea),
                            sizeof(hbHypCommArea_t));

                    if(payload_kind != TARGETING::PAYLOAD_KIND_NONE)
                    {
                        //Find the v addr in hdat that the hypervisor will look
                        //at to determine where to write HRMOR and possibly in
                        //the future information in hostboot's reserved memory section.
                        l_elog = RUNTIME::get_host_data_section( RUNTIME::HRMOR_STASH,
                                                                0,
                                                                l_hdatPtrToHrmorStashAddr,
                                                                l_hdatPtrHrmorStashSize );
                        if(l_elog)
                        {
                            TRACFCOMP( g_trac_runtime,
                                    "fill_RsvMem_hbData> failed to find HRMOR stash address in HDAT" );
                            break;
                        }

                        //This should always return a size of 8 as this is a 64 bit address
                        assert(l_hdatPtrHrmorStashSize == sizeof(uint64_t),
                               "The size of the HRMOR_STASH area should always be %d bytes,  not %d",
                               sizeof(uint64_t), l_hdatPtrHrmorStashSize);

                        //Cast the value returned from get_host_data_section to a uint64_t pointer
                        l_pHdatPtrToHrmorStashAddr = reinterpret_cast<uint64_t *>(l_hdatPtrToHrmorStashAddr);

                        //Set the value of the pointer to be the physical address
                        //of the hrmor stash in the hb-hyp communication area
                        *l_pHdatPtrToHrmorStashAddr = io_start_address + l_hbTOC.entry[i].offset + HYPCOMM_STRUCT_HRMOR_OFFSET;
                        //PHYP expects the value to be a physical address to set the upper bit
                        *l_pHdatPtrToHrmorStashAddr |= VmmManager::FORCE_PHYS_ADDR;

                        TRACFCOMP( g_trac_runtime,
                                  "fill_RsvMem_hbData> HYPCOMM v address 0x%.16llX, size: %lld done",
                                  l_prevDataAddr, aligned_size);
                    }
                    else
                    {
                        TRACFCOMP( g_trac_runtime,
                                  "fill_RsvMem_hbData> Payload kind was determined to be NONE, skipping setting up HYP comm");
                    }
                    break;
                }

                case Util::HBRT_MEM_LABEL_TRACEBUF:

                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> TRACEBUF v address 0x%.16llX, size: %lld", l_prevDataAddr, aligned_size);
                    //Nothing much to do here, except zero-ing the memory
                    memset(reinterpret_cast<uint8_t*>(l_prevDataAddr),0,aligned_size);
                    break;

                case(Util::HBRT_MEM_LABEL_PADDING):
                    // NOOP
                    break;

                default:
                    TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> Unrecognized label 0x%.ll16X", l_hbTOC.entry[i].label );
                    /*@
                     * @errortype       ERRORLOG::ERRL_SEV_UNRECOVERABLE
                     * @moduleid        RUNTIME::MOD_FILL_RSVMEM_HBDATA
                     * @reasoncode      RUNTIME::RC_UNKNOWN_LABEL
                     * @userdata1       Unknown Label
                     * @userdata2       <unused>
                     *
                     * @devdesc         Unknown reserved memory label attempted
                     * @custdesc        Firmware error initializing system
                     *                  data structures during boot
                     */
                    l_elog = new ERRORLOG::ErrlEntry(
                                  ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                  RUNTIME::MOD_FILL_RSVMEM_HBDATA,
                                  RUNTIME::RC_UNKNOWN_LABEL,
                                  l_hbTOC.entry[i].label,
                                  0,
                                  ERRORLOG::ErrlEntry::ADD_SW_CALLOUT );
                    l_elog->collectTrace(RUNTIME_COMP_NAME);
                    break;
            }
            // break out of for-loop if
            if(l_elog)
            {
                break;
            }
            i++;
        }

        // break out of do-while if we hit an error
        if(l_elog)
        {
            break;
        }

        TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> TOC address 0x%.16llX, size: %lld", l_vAddr, sizeof(l_hbTOC));

        // Now copy the TOC at the head of the HB Data section
        memcpy( reinterpret_cast<void*>(l_vAddr),
                &l_hbTOC,
                sizeof(l_hbTOC));
    } while (0);

    if (l_vAddr != 0)
    {
        // release the virtual address
        errlHndl_t l_errl = unmapVirtAddr(l_vAddr);
        if (l_errl)
        {
            TRACFCOMP( g_trac_runtime, "fill_RsvMem_hbData> unmap %p failed", l_vAddr );
            if (l_elog)
            {
                // Already have an error log so just commit this new one
                errlCommit(l_errl, RUNTIME_COMP_ID);
            }
            else
            {
                l_elog = l_errl;
            }
        }
        l_vAddr = 0;
    }

    // free ATTR_OVERRIDE memory
    free(l_overrideData);

    TRACFCOMP( g_trac_runtime,EXIT_MRK"fill_RsvMem_hbData> io_start_address=0x%.16llX,io_end_address=0x%.16llX,size=%lld",
                io_start_address, io_end_address, io_size );

    return l_elog;
}

errlHndl_t hbResvLoadSecureSection (const PNOR::SectionId i_sec,
                                    const bool i_secHdrExpected)
{
    TRACFCOMP( g_trac_runtime,ENTER_MRK"hbResvloadSecureSection() sec %s",
              PNOR::SectionIdToString(i_sec));

    errlHndl_t l_elog = nullptr;
    PNOR::SectionId shadow_i_sec = i_sec;

#ifdef CONFIG_SECUREBOOT
        auto l_sectionSecurelyLoaded = false;
#endif

    do {

        if (i_sec == PNOR::HCODE)
        {
            shadow_i_sec = PNOR::HCODE_LID;
            TRACFCOMP( g_trac_runtime, "hbResvLoadSecureSection HCODE_LID shadow_i_sec %s",
                PNOR::SectionIdToString(shadow_i_sec));
        }
        // Check for inhibited sections
        if(PNOR::isInhibitedSection(shadow_i_sec))
        {
            TRACFCOMP( g_trac_runtime, INFO_MRK"hbResvloadSecureSection() Skipping - Cannot load inhibited section %s",
                      PNOR::SectionIdToString(shadow_i_sec));
            break;
        }

        PNOR::SectionInfo_t l_info;
        l_elog = PNOR::getSectionInfo( shadow_i_sec, l_info );
        if(l_elog)
        {
            //No need to commit error here, it gets handled later
            //just break out to escape this function
            TRACFCOMP( g_trac_runtime, ERR_MRK"hbResvloadSecureSection() getSectionInfo failed");
            break;
        }

#ifdef CONFIG_SECUREBOOT
        // Skip verification if a section does not have a Secureboot Header
        if (l_info.secure)
        {
            // Securely Load PNOR section
            l_elog = loadSecureSection(shadow_i_sec);
            if (l_elog)
            {
                TRACFCOMP( g_trac_runtime,
                           ERR_MRK"hbResvloadSecureSection() - Error from "
                           "loadSecureSection(%s)", PNOR::SectionIdToString(shadow_i_sec));
                break;
            }
            l_sectionSecurelyLoaded = true;
        }
#endif

        auto l_pnorVaddr = l_info.vaddr;
        auto l_imgSize = l_info.size;

        // Check if the section is expected to have a secure header regardless
        // of compile options
#ifdef CONFIG_SECUREBOOT
        if (i_secHdrExpected)
        {
            // If section is signed, only the protected size was loaded into memory
            if (!l_info.hasHashTable)
            {
                l_imgSize = l_info.secureProtectedPayloadSize;
            }
            else
            {
                // Need to expose header and hash table
                l_pnorVaddr -= l_info.secureProtectedPayloadSize;
                l_imgSize += l_info.secureProtectedPayloadSize;
            }
            // Include secure header
            // NOTE: we do not preserve the header in virtual memory when SB
            // is compiled out. So "-PAGESIZE" only works when SB is compiled in
            l_pnorVaddr -= PAGESIZE;
        }
#endif
        // Add size for secure header, as a header is REQUIRED for lid load
        // from hostboot reserved memory to work in every scenario.
        // NOTE: if SB compiled out or a header is never added, one will be
        // injected later with min information. So preserve space for the header.
        l_imgSize += PAGESIZE;

        // Load Pnor section into HB reserved memory
        l_elog = PreVerifiedLidMgr::loadFromPnor(shadow_i_sec, l_pnorVaddr, l_imgSize);
        if(l_elog)
        {
            break;
        }
    } while(0);


#ifdef CONFIG_SECUREBOOT
    // Skip unload if a section was not securely loaded in the first place
    if (l_sectionSecurelyLoaded )
    {
        // Unload Secure PNOR section
        auto l_unloadErrlog = unloadSecureSection(shadow_i_sec);
        if (l_unloadErrlog)
        {
            TRACFCOMP( g_trac_runtime,
                       ERR_MRK"hbResvloadSecureSection() - Error from "
                       "unloadSecureSection(%s)", PNOR::SectionIdToString(shadow_i_sec));
            // Link unload error log to existing errorlog plid and commit error
            if(l_elog)
            {
                l_unloadErrlog->plid(l_elog->plid());
                ERRORLOG::errlCommit(l_unloadErrlog, RUNTIME_COMP_ID);
            }
            // This is the only error so return that.
            else
            {
                l_elog = l_unloadErrlog;
                l_unloadErrlog = nullptr;
            }
        }
    }
#endif

    return l_elog;
}

/**
 *  @brief Load the HDAT HB Reserved Memory
 *         address range structures on given node
 */
errlHndl_t populate_HbRsvMem(uint64_t i_nodeId,
                             bool i_master_node,
                             bool i_skipHDAT)
{
    TRACFCOMP( g_trac_runtime, ENTER_MRK"populate_HbRsvMem> i_nodeId=%d, i_master_node=%d, i_skipHDAT=%d",
               i_nodeId, i_master_node, i_skipHDAT );
    errlHndl_t l_elog = nullptr;

#ifdef CONFIG_SECUREBOOT
    auto l_hbrtSecurelyLoaded = false;
#endif

    do
    {
        TARGETING::Target* l_sys = nullptr;
        TARGETING::targetService().getTopLevelTarget(l_sys);
        assert(l_sys != nullptr,
               "populate_HbRsvMem: top level target nullptr" );

        // Wipe out our cache of the NACA/SPIRA pointers
        RUNTIME::rediscover_hdat();

        if( (i_master_node == true) && !i_skipHDAT )
        {
            // Wipe out all HB reserved memory sections
            l_elog = RUNTIME::clear_host_data_section(RUNTIME::RESERVED_MEM);

            if( l_elog )
            {
                TRACFCOMP( g_trac_runtime, ERR_MRK
                        "populate_HbRsvMem> i_nodeId=%d"
                        " call to clear_host_data_section() returned error",
                        i_nodeId );
                break;
            }
        }

        uint64_t l_topMemAddr = 0x0;
        uint64_t l_vAddr = 0x0;

        // Get list of processor chips
        TARGETING::TargetHandleList l_procChips;
        getAllChips( l_procChips,
                TARGETING::TYPE_PROC,
                true);

        ////////////////////////////////////////////////////////////////////
        // HRMOR Calculation on OPAL and PhyP systems
        // For PhyP and OPAL systems, HRMOR is set to 4GB-256MB, which is
        // calculated following PowerISA Doc:
        // "The supported HRMOR values are the non-negative multiples of
        // 2 to the power of r, where r is an implementation-dependent value
        // and 12 <= r <= 26."
        // Setting r to 26 sets the offset granularity to 64MB.
        // 64MB * 60 = 3840MB, which is equal to 4GB-256MB.
        ////////////////////////////////////////////////////////////////////
        uint64_t l_hbAddr = RUNTIME::getHbBaseAddrWithNodeOffset();

        /* The primary reserved section should encompass the entirety of the
         * Hostboot local memory space.  This data will be preserved across
         * MPIPLs since the Hypervisor/OS will not touch it. */
        l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_PRIMARY,
                                      i_nodeId,
                                      l_hbAddr,
                                      VMM_HB_RSV_MEM_SIZE,
                                      HBRT_RSVD_MEM__PRIMARY,
                                      HDAT::RHB_READ_WRITE,
                                      false,
                                      i_skipHDAT);

        if(l_elog != nullptr)
        {
            break;
        }
        TRACFCOMP(g_trac_runtime,
                  "RHB_TYPE_PRIMARY @ %.8X for %.8X",
                  l_hbAddr,VMM_HB_RSV_MEM_SIZE )

        if(TARGETING::is_sapphire_load())
        {
            // Opal data goes at top_of_mem
            l_topMemAddr = ISTEP::get_top_homer_mem_addr();
            assert (l_topMemAddr != 0,
                    "populate_HbRsvMem: Top of memory was 0!");

            // Opal HB reserved memory data
            // -----TOP_OF_MEM-------
            // -----OCC Common-------
            // -----HOMER_N----------
            // -----...--------------
            // -----HOMER_0----------
            // -----Arch_dump_area---
            // -----HB Data ---------
            //   -- VPD
            //   -- ATTR Data
            //   -- ATTR Override Data
            //   -- HB TOC
            // -----HBRT Image-------
            // -----SBE Comm---------
            // -----SBE FFDC---------
            // -----Secureboot cryptographic algorithms code---------
            // -----Verified Images---------
            //   -- OCC
            //   -- WOFDATA
            //   -- HCODE

            // First opal entries are for the HOMERs
            uint64_t l_homerAddr = l_topMemAddr;

            // Loop through all functional Procs
            for (const auto & l_procChip: l_procChips)
            {

                l_homerAddr = l_procChip->getAttr
                    <TARGETING::ATTR_HOMER_PHYS_ADDR>();
                // Note: the instance we use to retrieve the data must
                //   match the value we used to populate HDAT originally
                l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_HOMER_OCC,
                        l_procChip->getAttr<TARGETING::ATTR_HBRT_HYP_ID>(),
                        l_homerAddr,
                        VMM_HOMER_INSTANCE_SIZE,
                        HBRT_RSVD_MEM__HOMER);
                if(l_elog)
                {
                    break;
                }
            }

            if(l_elog)
            {
                break;
            }

#ifdef CONFIG_START_OCC_DURING_BOOT
            ///////////////////////////////////////////////////
            // OCC Common entry
            ///////////////////////////////////////////////////
            TARGETING::Target * l_sys = nullptr;
            TARGETING::targetService().getTopLevelTarget( l_sys );
            assert( l_sys != nullptr,
                    "populate_HbRsvMem:CONFIG_START_OCC_DURING_BOOT - "
                    "top level target nullptr" );
            uint64_t l_occCommonAddr = l_sys->getAttr
              <TARGETING::ATTR_OCC_COMMON_AREA_PHYS_ADDR>();
            l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_HOMER_OCC,
                                          i_nodeId,
                                          l_occCommonAddr,
                                          VMM_OCC_COMMON_SIZE,
                                          HBRT_RSVD_MEM__OCC_COMMON);
            if(l_elog)
            {
                break;
            }
#endif
        }

        ///////////////////////////////////////////////////
        // Set the SBE Architected Dump area
        // Note that this is right after HOMER areas
        // PHYP goes up, OPAL goes down.  Save this away
        // Into targeting so dumpCollect can find later
        // on the MPIPL
        //
        // Note that this works for PHYP multinode (as it
        // grabs location from HRMOR), but OPAL only
        // supports a single node style system (absolute
        // address)
        //////////////////////////////////////////////////
        uint64_t l_archAddr = 0;
        if(TARGETING::is_phyp_load())
        {
            l_archAddr = RUNTIME::getHbBaseAddrWithNodeOffset() +
                         VMM_ARCH_REG_DATA_START_OFFSET;
        }
        else if(TARGETING::is_sapphire_load())
        {
            l_archAddr = l_topMemAddr
                        - VMM_ALL_HOMER_OCC_MEMORY_SIZE
                        - VMM_INTERNODE_PRESERVED_MEMORY_SIZE
                        - VMM_ARCH_REG_DATA_SIZE_ALL_PROC;
        }
        l_sys->setAttr<TARGETING::ATTR_SBE_ARCH_DUMP_ADDR>(l_archAddr);

        // SBE Architected Dump area is a single chunk of data
        // to OPAL/PHYP -- so reserve once, but need to inform
        // individual SBEs of their location
        if( !i_skipHDAT )
        {
        l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_HBRT,
                                      i_nodeId,
                                      l_archAddr,
                                      VMM_ARCH_REG_DATA_SIZE_ALL_PROC,
                                      HBRT_RSVD_MEM__ARCH_REG,
                                      HDAT::RHB_READ_WRITE,
                                      false);
        if(l_elog)
        {
            break;
        }

        // Loop through all functional Procs
        uint32_t l_procNum = 0;
        uint64_t l_pcrdAddr = 0;
        uint64_t l_pcrdSizeMax = 0;
        uint64_t l_numInstances = 0;
        l_elog = RUNTIME::get_instance_count(RUNTIME::PCRD, l_numInstances);
        if(l_elog)
        {
            TRACFCOMP( g_trac_runtime,"Failed in get_instance_count() to obtain PCRD instances");
            break;
        }
        for (const auto & l_procChip: l_procChips)
        {
            uint64_t l_addr = l_archAddr +
              (l_procNum * VMM_ARCH_REG_DATA_PER_PROC_SIZE);

            //Update the MPIPL Dump metadata structure for particular Proc
            uint64_t l_vAddr = 0x0;
            l_elog = mapPhysAddr(l_addr, sizeof(DUMP::sbeArchHWDumpMetaData_t), l_vAddr);
            if(l_elog)
            {
                TRACFCOMP( g_trac_runtime,"Faled in mapPhysAddr() for address:0x%.16llx",
                           l_addr);
                break;
            }
            DUMP::sbeArchHWDumpMetaData_t metadata;
            metadata.init();
            metadata.archDataMemoryAddr = l_addr +sizeof(DUMP::sbeArchHWDumpMetaData_t);
            metadata.archDataMemAllocSize = VMM_ARCH_REG_DATA_PER_PROC_SIZE;
            memcpy(reinterpret_cast<void*>(l_vAddr),
                   reinterpret_cast<void*>(&metadata),
                   sizeof(DUMP::sbeArchHWDumpMetaData_t));
            l_elog = unmapVirtAddr(l_vAddr);
            if(l_elog)
            {
                TRACFCOMP( g_trac_runtime,"Faled in unmapVirtAddr() to unmap address:0x%.16llx",
                           l_vAddr);
                break;
            }

            //Pass start address down to SBE via chipop
            l_elog = SBEIO::sendPsuStashKeyAddrRequest(
                                                      SBEIO::ARCH_REG_DATA_ADDR,
                                                      l_addr,
                                                      l_procChip);
            if (l_elog)
            {
                TRACFCOMP( g_trac_runtime, "Arch dump sendPsuStashKeyAddrRequest "
                       "failed for target: %x",TARGETING::get_huid(l_procChip));
                break;
            }

            TARGETING::ATTR_ORDINAL_ID_type l_procOrdinalId =
                                            l_procChip->getAttr<TARGETING::ATTR_ORDINAL_ID>();
            //Update proc specific metadata address into the PCRD table
            for (uint64_t l_pcrdInstance = 0;
                 l_pcrdInstance < l_numInstances;++l_pcrdInstance)
            {
                //Update proc specific metadata address into the PCRD table
                l_elog = RUNTIME::get_host_data_section(RUNTIME::PCRD,
                         l_pcrdInstance,l_pcrdAddr,l_pcrdSizeMax);
                if(l_elog)
                {
                    TRACFCOMP(g_trac_runtime, ERR_MRK"Failed in obtaining the PCRD section for instance :%d",
                            l_procNum);
                    break;
                }

                HDAT::hdatSpPcrd_t *l_pcrd = nullptr;
                l_pcrd = reinterpret_cast<HDAT::hdatSpPcrd_t*>(l_pcrdAddr);

                if(l_pcrd->hdatChipData.hdatPcrdProcChipId != l_procOrdinalId)
                {
                    TRACFCOMP(g_trac_runtime, ERR_MRK" l_pcrdInstance=%d hdatPcrdProcChipId=0x%.8x and ORDINAL_ID=%d",
                              l_pcrdInstance,l_pcrd->hdatChipData.hdatPcrdProcChipId,l_procOrdinalId);
                    continue;
                }

                TRACDCOMP(g_trac_runtime, " l_pcrdInstance=%d hdatPcrdProcChipId=0x%.8x and ORDINAL_ID=%d",
                          l_pcrdInstance,l_pcrd->hdatChipData.hdatPcrdProcChipId,l_procOrdinalId);

                TRACDCOMP(g_trac_runtime, " get_host_data_section():PCRD Instance=%d  l_pcrdAddr=0x%.16llx"
                "after mm_virt_to_phys()=0x%.16llx() and l_pcrdSizeMax=0x%.16llx " l_procNum,l_pcrdAddr,
                mm_virt_to_phys( reinterpret_cast<void*>(l_pcrdAddr)),l_pcrdSizeMax);

                l_pcrd->hdatChipData.hdatPcrdMPIPLMetadataAddr = l_addr;

                TRACDCOMP(g_trac_runtime," PCRD table with hdatPcrdProcChipId=0x%.8x hdatPcrdFabTopologyId=0x%.8x "
                "and hdatPcrdMPIPLMetadataAddr=0x%.16llx", (uint32_t)l_pcrd->hdatChipData.hdatPcrdProcChipId,
                (uint32_t)l_pcrd->hdatChipData.hdatPcrdFabTopologyId,(uint64_t)l_pcrd->hdatChipData.hdatPcrdMPIPLMetadataAddr);

                TRACDCOMP(g_trac_runtime," Address of l_pcrd->hdatChipData.hdatPcrdProcChipId=0x%.16llx : "
                "after mm_virt_to_phys()=0x%.16llx", &(l_pcrd->hdatChipData.hdatPcrdProcChipId),
                mm_virt_to_phys( reinterpret_cast<void*>(&(l_pcrd->hdatChipData.hdatPcrdProcChipId))));

                TRACFCOMP(g_trac_runtime," Address of l_pcrd->hdatChipData.hdatPcrdMPIPLMetadataAddr=0x%.16llx "
                ": after mm_virt_to_phys()=0x%.16llx ",  &(l_pcrd->hdatChipData.hdatPcrdMPIPLMetadataAddr),
                mm_virt_to_phys( reinterpret_cast<void*>(&(l_pcrd->hdatChipData.hdatPcrdMPIPLMetadataAddr))));

                break;//Break out of the for loop as match was found and metadata was updated
            }
            if(l_elog)
            {
                break;
            }
            l_procNum++;
        }
        if(l_elog)
        {
            break;
        }
        } //!i_skipHDAT

        ////////////////////////////////////////////////////
        // HB Data area
        ////////////////////////////////////////////////////

        //====================
        // Note that for PHYP we build up starting at the end of the
        //  previously allocated HOMER/OCC areas, for OPAL we build
        //  downwards from the top of memory where the HOMER/OCC
        //  areas were placed
        uint64_t l_startAddr = 0;
        uint64_t l_endAddr = 0;
        uint64_t l_totalSizeAligned = 0;
        bool startAddressValid = true;

        if(TARGETING::is_phyp_load() || TARGETING::is_no_load())
        {
            l_startAddr = RUNTIME::getHbBaseAddrWithNodeOffset() +
                          VMM_HB_DATA_TOC_START_OFFSET;
        }
        else if(TARGETING::is_sapphire_load())
        {
            l_endAddr = l_topMemAddr
                        - VMM_ALL_HOMER_OCC_MEMORY_SIZE
                        - VMM_INTERNODE_PRESERVED_MEMORY_SIZE
                        - VMM_ARCH_REG_DATA_SIZE_ALL_PROC;
            startAddressValid = false;
        }

        // fills in the reserved memory with HB Data and
        // will update addresses and totalSize
        l_elog = fill_RsvMem_hbData(l_startAddr, l_endAddr,
                startAddressValid, l_totalSizeAligned,i_master_node);

        if (l_elog)
        {
            break;
        }

        // NOTE : Any attribute changes after this point will NOT be
        //        available to HBRT.

        // Loop through all functional Procs
        for (const auto & l_procChip: l_procChips)
        {
            //Pass start address down to SBE via chipop
            l_elog = SBEIO::sendPsuStashKeyAddrRequest(SBEIO::RSV_MEM_ATTR_ADDR,
                    l_startAddr,
                    l_procChip);
            if (l_elog)
            {
                TRACFCOMP( g_trac_runtime, "sendPsuStashKeyAddrRequest failed for target: %x",
                        TARGETING::get_huid(l_procChip) );
                break;
            }
        }

        if (l_elog)
        {
            break;
        }

        l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_HBRT,
                i_nodeId,
                l_startAddr,
                l_totalSizeAligned,
                HBRT_RSVD_MEM__DATA,
                HDAT::RHB_READ_WRITE,
                true,
                i_skipHDAT);
        if(l_elog)
        {
            break;
        }

        // Establish a couple variables to keep track of where the
        // next section lands as we deal with the less statically
        // sized areas.  These values must always remain 64KB
        // aligned
        uint64_t l_prevDataAddr = l_startAddr;
        uint64_t l_prevDataSize = l_totalSizeAligned;

        //////////////////////////////////////////////////////////
        // HBRT image entry
        //   OPAL w/ FSP could get the hbrt image from the LID
        //   Include hbrt_code_image here to be consistent with P8
        if(TARGETING::is_sapphire_load())
        {
            uint64_t l_hbrtImageAddr = 0x0;
#ifdef CONFIG_SECUREBOOT
            l_elog = loadSecureSection(PNOR::HB_RUNTIME);
            if(l_elog)
            {
                break;
            }
            l_hbrtSecurelyLoaded = true;
#endif
            PNOR::SectionInfo_t l_pnorInfo;
            l_elog = getSectionInfo( PNOR::HB_RUNTIME , l_pnorInfo);
            if (l_elog)
            {
                break;
            }

            // Find start of image.
            //     For Secureboot we might need to deal with the header but
            //     for now that is hidden by the PNOR-RP.
            uint64_t l_imageStart = l_pnorInfo.vaddr;

            // The "VFS_LAST_ADDRESS" variable is 2 pages in.
            uint64_t l_vfsLastAddress =
                *reinterpret_cast<uint64_t*>(l_imageStart + 2*PAGE_SIZE);

            // At the end of the image are the relocations, get the number.
            uint64_t l_relocateCount =
                *reinterpret_cast<uint64_t*>
                (l_imageStart + l_vfsLastAddress);

            // Sum up the total size.
            uint64_t l_imageSize = l_vfsLastAddress +
                (l_relocateCount+1)*sizeof(uint64_t);

            // Set the image address, align down for OPAL
            l_hbrtImageAddr = ALIGN_PAGE_DOWN(l_prevDataAddr);
            l_hbrtImageAddr = ALIGN_PAGE_DOWN(l_hbrtImageAddr - l_imageSize);
            l_hbrtImageAddr = ALIGN_DOWN_X(l_hbrtImageAddr,
                    HBRT_RSVD_MEM_OPAL_ALIGN);
            size_t l_hbrtImageSizeAligned = ALIGN_X( l_imageSize,
                    HBRT_RSVD_MEM_OPAL_ALIGN);

            l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_HBRT,
                    i_nodeId,
                    l_hbrtImageAddr,
                    l_hbrtImageSizeAligned,
                    HBRT_RSVD_MEM__CODE);
            if(l_elog)
            {
                break;
            }

            l_prevDataAddr = l_hbrtImageAddr;
            l_prevDataSize = l_hbrtImageSizeAligned;

            // Load the HBRT image into memory
            l_elog = mapPhysAddr(l_hbrtImageAddr, l_imageSize, l_vAddr);
            if(l_elog)
            {
                break;
            }

            memcpy(reinterpret_cast<void*>(l_vAddr),
                    reinterpret_cast<void*>(l_imageStart),
                    l_imageSize);

            l_elog = unmapVirtAddr(l_vAddr);
            if(l_elog)
            {
                break;
            }
        }

        ///////////////////////////////////////////////////
        // SBE Communications buffer entry
        // SBE FFDC entry
        uint64_t l_sbeCommAddr = 0x0;
        uint64_t l_sbeCommSize = SBE_MSG::SBE_COMM_BUFFER_SIZE;

        uint64_t l_sbeffdcAddr = 0x0;
        uint64_t l_sbeffdcSize =
            SBEIO::SbePsu::getTheInstance().getSbeFFDCBufferSize();

        // Align size for OPAL
        size_t l_sbeCommSizeAligned = ALIGN_X( l_sbeCommSize,
                HBRT_RSVD_MEM_OPAL_ALIGN );
        size_t l_sbeffdcSizeAligned = ALIGN_X( l_sbeffdcSize,
                HBRT_RSVD_MEM_OPAL_ALIGN );

        // Loop through all functional Procs
        for (const auto & l_procChip: l_procChips)
        {
            // Note: the instance we use to retrieve the data must
            //   match the value we used to populate HDAT originally
            uint32_t l_id = l_procChip->getAttr<TARGETING::ATTR_HBRT_HYP_ID>();

            // -- SBE Communications buffer entry
            if(TARGETING::is_phyp_load() ||  TARGETING::is_no_load())
            {
                l_sbeCommAddr = l_prevDataAddr + l_prevDataSize;
            }
            else if(TARGETING::is_sapphire_load())
            {
                l_sbeCommAddr = l_prevDataAddr - l_sbeCommSizeAligned;
            }

            l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_HBRT,
                    l_id,
                    l_sbeCommAddr,
                    l_sbeCommSizeAligned,
                    HBRT_RSVD_MEM__SBE_COMM,
                    HDAT::RHB_READ_WRITE,
                    true,
                    i_skipHDAT);
            if(l_elog)
            {
                break;
            }

            l_prevDataAddr = l_sbeCommAddr;
            l_prevDataSize = l_sbeCommSizeAligned;

            // Save SBE Communication buffer address to attribute
            l_procChip->setAttr<TARGETING::ATTR_SBE_COMM_ADDR>(l_sbeCommAddr);

            // -- SBE FFDC entry

            if(TARGETING::is_phyp_load() || TARGETING::is_no_load())
            {
                l_sbeffdcAddr = l_prevDataAddr + l_prevDataSize;
            }
            else if(TARGETING::is_sapphire_load())
            {
                l_sbeffdcAddr = l_prevDataAddr - l_sbeffdcSizeAligned;
            }

            l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_HBRT,
                    l_id,
                    l_sbeffdcAddr,
                    l_sbeffdcSizeAligned,
                    HBRT_RSVD_MEM__SBE_FFDC,
                    HDAT::RHB_READ_WRITE,
                    true,
                    i_skipHDAT);
            if(l_elog)
            {
                break;
            }

            l_prevDataAddr = l_sbeffdcAddr;
            l_prevDataSize = l_sbeffdcSizeAligned;

            // Save SBE FFDC address to attribute
            l_procChip->setAttr<TARGETING::ATTR_SBE_FFDC_ADDR>(l_sbeffdcAddr);

            // Open Unsecure Memory Region for SBE FFDC Section
            l_elog = SBEIO::openUnsecureMemRegion(l_sbeffdcAddr,
                    l_sbeffdcSize,
                    false, //Read-Only
                    l_procChip);

            if(l_elog)
            {
                TRACFCOMP( g_trac_runtime,
                        "populate_HbRsvMem: openUnsecureMemRegion failed");

                break;
            }


            // Send Set FFDC Address, tell SBE where to write FFDC and messages
            l_elog = SBEIO::sendSetFFDCAddr(l_sbeffdcSize,
                    l_sbeCommSize,
                    l_sbeffdcAddr,
                    l_sbeCommAddr,
                    l_procChip);

            if(l_elog)
            {
                TRACFCOMP( g_trac_runtime,
                        "populate_HbRsvMem: sendSetFFDCAddr failed");

                break;
            }
        }

        // Allocate physical storage for HBRT to use for SBE PSU operations
        //  We are only going to allocate a single buffer for all chips to
        //  share since we will never have multiple outstanding messages.
        if( i_master_node == true )
        {
            uint64_t l_hbrtPsuAddr = 0x0;
            if(TARGETING::is_phyp_load() || TARGETING::is_no_load())
            {
                l_hbrtPsuAddr = l_prevDataAddr + l_prevDataSize;
            }
            else if(TARGETING::is_sapphire_load())
            {
                l_hbrtPsuAddr = l_prevDataAddr
                                - SBEIO::SbePsu::MAX_HBRT_PSU_OP_SIZE_BYTES;
            }

            l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_HBRT,
                                          0,
                                          l_hbrtPsuAddr,
                                          SBEIO::SbePsu::MAX_HBRT_PSU_OP_SIZE_BYTES,
                                          HBRT_RSVD_MEM__SBE_PSU,
                                          HDAT::RHB_READ_WRITE,
                                          true,
                                          i_skipHDAT);
            if(l_elog)
            {
                break;
            }

            TARGETING::UTIL::assertGetToplevelTarget()
              ->setAttr<ATTR_SBE_HBRT_PSU_PHYS_ADDR>(l_hbrtPsuAddr);

            l_prevDataAddr = l_hbrtPsuAddr;
            l_prevDataSize = SBEIO::SbePsu::MAX_HBRT_PSU_OP_SIZE_BYTES;
        }

        // just load this stuff once
        if( i_master_node == true && !i_skipHDAT )
        {
            ///////////////////////////////////////////////////
            // -- Secureboot cryptographic algorithms code
            //    Only add if SecureROM is available and valid.
            if (g_BlToHbDataManager.isValid())
            {
                size_t l_secureRomSize = g_BlToHbDataManager.getSecureRomSize();
                // Align size for OPAL
                size_t l_secRomSizeAligned = ALIGN_X(l_secureRomSize,
                        HBRT_RSVD_MEM_OPAL_ALIGN);
                // @TODO: RTC:183697 determine if OPAL can also use the
                // actual size and remove the need for l_hdatEntrySize
                // Size to add to HDAT entry
                size_t l_hdatEntrySize = l_secRomSizeAligned;

                uint64_t l_secureRomAddr = 0x0;
                if(TARGETING::is_phyp_load() || TARGETING::is_no_load())
                {
                    l_secureRomAddr = l_prevDataAddr + l_prevDataSize;
                    // Specify actual size in HDAT entry for POWERVM
                    l_hdatEntrySize = l_secureRomSize;
                }
                else if(TARGETING::is_sapphire_load())
                {
                    l_secureRomAddr = l_prevDataAddr - l_secRomSizeAligned;
                }

                l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_SECUREBOOT,
                        i_nodeId,
                        l_secureRomAddr,
                        l_hdatEntrySize,
                        HBRT_RSVD_MEM__SECUREBOOT);
                if(l_elog)
                {
                    break;
                }

                l_prevDataAddr = l_secureRomAddr;
                l_prevDataSize = l_secRomSizeAligned;

                // Load the Cached SecureROM into memory
                l_elog = mapPhysAddr(l_secureRomAddr, l_secureRomSize, l_vAddr);
                if(l_elog)
                {
                    break;
                }

                memcpy(reinterpret_cast<void*>(l_vAddr),
                        g_BlToHbDataManager.getSecureRom(),
                        l_secureRomSize);

                l_elog = unmapVirtAddr(l_vAddr);
                if(l_elog)
                {
                    break;
                }
            }

            // Initialize Pre-Verified Lid Manager, which is required
            // to process the MCL, then process the MCL and unlock the Pre-Verified
            // Lid Manager.
            if(TARGETING::is_phyp_load())
            {
                PreVerifiedLidMgr::initLock(l_prevDataAddr, l_prevDataSize,i_nodeId);
                MCL::MasterContainerLidMgr l_mcl;
                l_elog = l_mcl.processComponents();
                PreVerifiedLidMgr::unlock();
                if(l_elog)
                {
                    break;
                }
            }

            if(SECUREBOOT::SMF::isSmfEnabled())
            {
                // The address of unsecure HOMER is the same among all the
                // procs, so we can just fetch it from the master proc.
                TARGETING::Target* l_masterProc = nullptr;
                l_elog = TARGETING::targetService()
                                 .queryMasterProcChipTargetHandle(l_masterProc);
                if(l_elog)
                {
                    break;
                }

                const auto l_unsecureHomerSize
                    = l_masterProc->getAttr<TARGETING::ATTR_UNSECURE_HOMER_SIZE>();

                auto l_unsecureHomerAddr = l_masterProc->
                              getAttr<TARGETING::ATTR_UNSECURE_HOMER_ADDRESS>();
                assert(l_unsecureHomerAddr,
                       "populate_HbRsvMem: Unsecure HOMER address is 0");
                assert(l_unsecureHomerSize <= MAX_UNSECURE_HOMER_SIZE,
                       "populate_HbRsvMem: Unsecure HOMER size is bigger than 0x%x", MAX_UNSECURE_HOMER_SIZE);

                l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_UNSECURE_HOMER,
                                              i_nodeId,
                                              l_unsecureHomerAddr,
                                              l_unsecureHomerSize,
                                              HBRT_RSVD_MEM__UNSEC_HOMER);
                if(l_elog)
                {
                    break;
                }

                // Now get the UVBWLIST from the SBE
                uint64_t l_uvbwlistAddr =
                            PreVerifiedLidMgr::getNextResMemAddr(UVBWLIST_SIZE);
                assert(l_uvbwlistAddr,
                       "populate_HbRsvMem: Ultravisor XSCOM white/blacklist address is 0");
                TRACFCOMP(g_trac_runtime,
                          "populate_HbRsvMem: Ultravisor XSCOM white/blacklist address = 0x%.16llX",
                          l_uvbwlistAddr);
                l_elog =SBEIO::sendPsuSecurityListBinDumpRequest(l_uvbwlistAddr,
                                                                  l_masterProc);
                if(l_elog)
                {
                    break;
                }

                l_elog = setNextHbRsvMemEntry(HDAT::RHB_TYPE_UVBWLIST,
                                              i_nodeId,
                                              l_uvbwlistAddr,
                                              UVBWLIST_SIZE,
                                              HBRT_RSVD_MEM__UVBWLIST);
                if(l_elog)
                {
                    break;
                }
            }
        } //if( i_master_node == true && !i_skipHDAT )
    } while(0);

#ifdef CONFIG_SECUREBOOT
    // Skip unload if a section was not securely loaded in the first place
    if (l_hbrtSecurelyLoaded )
    {
        // Unload HBRT PNOR section
        auto l_unloadErrlog = unloadSecureSection(PNOR::HB_RUNTIME);
        if (l_unloadErrlog)
        {
            TRACFCOMP( g_trac_runtime,
                       ERR_MRK"hbResvloadSecureSection() - Error from "
                       "unloadSecureSection(%s)", PNOR::SectionIdToString(PNOR::HB_RUNTIME));
            // Link unload error log to existing errorlog plid and commit error
            if(l_elog)
            {
                l_unloadErrlog->plid(l_elog->plid());
                ERRORLOG::errlCommit(l_unloadErrlog, RUNTIME_COMP_ID);
            }
            // This is the only error so return that.
            else
            {
                l_elog = l_unloadErrlog;
                l_unloadErrlog = nullptr;
            }
        }
    }
#endif

    TRACFCOMP( g_trac_runtime, EXIT_MRK"populate_HbRsvMem> l_elog=%.8X", ERRL_GETRC_SAFE(l_elog) );
    return(l_elog);
} // end populate_HbRsvMem

errlHndl_t populate_hbSecurebootData ( void )
{
    using namespace TARGETING;

    errlHndl_t l_elog = nullptr;

    do {
        // pass 0 since sys parms has only one record
        const uint64_t l_instance = 0;
        uint64_t l_hbrtDataAddr = 0;
        uint64_t l_hbrtDataSizeMax = 0;
        l_elog = RUNTIME::get_host_data_section(RUNTIME::IPLPARMS_SYSTEM,
                l_instance,
                l_hbrtDataAddr,
                l_hbrtDataSizeMax);
        if(l_elog != nullptr)
        {
            TRACFCOMP( g_trac_runtime, ERR_MRK "populate_hbSecurebootData: "
                    "get_host_data_section() failed for system IPL parameters section");
            break;
        }

        hdatSysParms_t* const l_sysParmsPtr
            = reinterpret_cast<hdatSysParms_t*>(l_hbrtDataAddr);

        // populate system security settings in hdat
        SysSecSets* const l_sysSecSets =
            reinterpret_cast<SysSecSets*>(&l_sysParmsPtr->hdatSysSecuritySetting);

        // populate secure setting for trusted boot
        bool trusted = false;
#ifdef CONFIG_TPMDD
        l_elog = TRUSTEDBOOT::anyFunctionalPrimaryTpmExists(trusted);
        if (l_elog)
        {
            TRACFCOMP(g_trac_runtime, ERR_MRK"populate_hbSecurebootData: "
                "anyFunctionalPrimaryTpmExists returned error");
            break;
        }
#endif
        l_sysSecSets->trustedboot = trusted? 1: 0;

        // populate secure setting for secureboot
        bool secure = false;
#ifdef CONFIG_SECUREBOOT
        secure = SECUREBOOT::enabled();
#endif
        l_sysSecSets->secureboot = secure? 1: 0;

        // populate security override setting
        auto sbe_security_backdoor = SECUREBOOT::getSbeSecurityBackdoor();
        l_sysSecSets->sbeSecBackdoor = sbe_security_backdoor;

        // populate "System Physical Presence has been asserted"
        Target* nodeTgt = UTIL::getCurrentNodeTarget();

        auto phys_pres_asserted = 0;
#ifdef CONFIG_PHYS_PRES_PWR_BUTTON
        phys_pres_asserted = nodeTgt->getAttr<TARGETING::ATTR_PHYS_PRES_ASSERTED>();
#endif
        l_sysSecSets->physicalPresenceAsserted = phys_pres_asserted;

        // populate TPM config bits in hdat
        bool tpmRequired = false;
#ifdef CONFIG_TPMDD
        tpmRequired = TRUSTEDBOOT::isTpmRequired();
#endif

        l_sysParmsPtr->hdatTpmConfBits = tpmRequired? TPM_REQUIRED_BIT: 0;

        // get max # of TPMs per drawer and populate hdat with it
        uint8_t l_maxTpms = HDAT::hdatCalcMaxTpmsPerNode();

        l_sysParmsPtr->hdatTpmDrawer = l_maxTpms;
        TRACFCOMP(g_trac_runtime,"Max TPMs = 0x%04X", l_maxTpms);

        // Populate HW Keys' Hash size + value in HDAT
        l_sysParmsPtr->hdatHwKeyHashSize =
            sizeof(l_sysParmsPtr->hdatHwKeyHashValue);
        TRACFCOMP(g_trac_runtime,"HW Keys' Hash Size = %d",
                l_sysParmsPtr->hdatHwKeyHashSize);

#ifdef CONFIG_SECUREBOOT
        auto hash = l_sysParmsPtr->hdatHwKeyHashValue;
        SECUREBOOT::getHwKeyHash(hash);
#else
        memset(l_sysParmsPtr->hdatHwKeyHashValue,0,
                sizeof(l_sysParmsPtr->hdatHwKeyHashValue));
#endif

        // Populate Minimum FW Secure Version
        l_sysParmsPtr->hdatFwSecureVersion = g_BlToHbDataManager.getMinimumSecureVersion();
        TRACFCOMP(g_trac_runtime, INFO_MRK"populate_hbSecurebootData: "
                  "Setting hdatFwSecureVersion to 0x%.2X",
                  l_sysParmsPtr->hdatFwSecureVersion);

        // Populate "Host FW key clear requests" section
        // NOTE: KEY_CLEAR_REQUEST enum should sync with expected bits
        // in HDAT spec; this enum is used for both ATTR_KEY_CLEAR_REQUEST
        // and ATTR_KEY_CLEAR_REQUEST_HB
        auto key_clear_request =
            nodeTgt->getAttr<TARGETING::ATTR_KEY_CLEAR_REQUEST_HB>();

#ifdef CONFIG_KEY_CLEAR
        // If Physical Presence was not asserted, then mask off all bits
        // except for Mfg bits in case of imprint drivers or is security is diabled
        // NOTE: Using the presence of a backdoor to assert we have an
        // imprint/development driver
        if ((phys_pres_asserted == 0) &&
            (key_clear_request != KEY_CLEAR_REQUEST_NONE))
        {
            if (((sbe_security_backdoor != 0) || !secure) &&
                ((key_clear_request & KEY_CLEAR_REQUEST_MFG) ||
                 (key_clear_request & KEY_CLEAR_REQUEST_MFG_ALL)))
            {
                auto tmp_request = key_clear_request;
                tmp_request &= (KEY_CLEAR_REQUEST_MFG |
                                KEY_CLEAR_REQUEST_MFG_ALL);

                TRACFCOMP(g_trac_runtime, INFO_MRK"populate_hbSecurebootData: "
                          "Physical Presence not asserted, but "
                          "KEY_CLEAR_REQUEST_MFG(_ALL) bit(s) is set for "
                          "imprint driver or security is disabled. Updating "
                          "key_clear_request from 0x%.4X to 0x%.4X",
                          key_clear_request, tmp_request);
                key_clear_request = tmp_request;
            }
            else
            {
                TRACFCOMP(g_trac_runtime, INFO_MRK"populate_hbSecurebootData: "
                          "Physical Presence not asserted. Updating "
                          "key_clear_request from 0x%.4X to 0x%.4X",
                          key_clear_request, KEY_CLEAR_REQUEST_NONE);

                key_clear_request = KEY_CLEAR_REQUEST_NONE;
            }
        }
        // Must mask off KEY_CLEAR_REQUEST_MFG for non-imprint drivers with security enabled
        else if ((phys_pres_asserted != 0) &&
                 (sbe_security_backdoor == 0) &&
                 (secure) &&
                 (key_clear_request &
                   (KEY_CLEAR_REQUEST_MFG | KEY_CLEAR_REQUEST_MFG_ALL)))
        {
            auto temp_key_clear_request =
                   static_cast<ATTR_KEY_CLEAR_REQUEST_type>(
                     key_clear_request &
                       ~(KEY_CLEAR_REQUEST_MFG | KEY_CLEAR_REQUEST_MFG_ALL));

            TRACFCOMP(g_trac_runtime, INFO_MRK"populate_hbSecurebootData: "
                      "Physical Presence asserted on production driver with security enabled "
                      "KEY_CLEAR_REQUEST_MFG bit (0x%.4X) or "
                      "KEY_CLEAR_REQUEST_MFG_ALL bit (0x%.4X) set. "
                      "Updating key_clear_request from 0x%.4X to 0x%.4X",
                      KEY_CLEAR_REQUEST_MFG, KEY_CLEAR_REQUEST_MFG_ALL,
                      key_clear_request, temp_key_clear_request);

            key_clear_request = temp_key_clear_request;
        }

        TRACFCOMP(g_trac_runtime, INFO_MRK"populate_hbSecurebootData: "
                  "Setting key_clear_request in HDAT to 0x%.4X before clearing "
                  "ATTR_KEY_CLEAR_REQUEST_HB",
                  key_clear_request);
        l_sysParmsPtr->hdatKeyClearRequest = key_clear_request;

        // Clear the Key Clear Requests
        key_clear_request = KEY_CLEAR_REQUEST_NONE;
        nodeTgt->setAttr<TARGETING::ATTR_KEY_CLEAR_REQUEST_HB>(key_clear_request);
#ifdef CONFIG_PLDM
        l_elog = PLDM::clearKeyClearRequest();
        if(l_elog != nullptr)
        {
            l_elog->setSev(ERRORLOG::ERRL_SEV_INFORMATIONAL);
            TRACFCOMP(g_trac_runtime, ERR_MRK "populate_hbSecurebootData: "
                      "PLDM::clearKeyClearRequest() failed. "
                      "Setting ERR to informational and committing here. "
                      "Don't want this fail to halt the IPL: "
                      TRACE_ERR_FMT,
                      TRACE_ERR_ARGS(l_elog));
            l_elog->collectTrace(SECURE_COMP_NAME);
            l_elog->collectTrace(RUNTIME_COMP_NAME);
            errlCommit(l_elog, RUNTIME_COMP_ID);
            l_elog = nullptr;
            // no "break;" - just continue
        }
#endif

#else // CONFIG_KEY_CLEAR is NOT defined
        key_clear_request = KEY_CLEAR_REQUEST_NONE;
        TRACFCOMP(g_trac_runtime, INFO_MRK"populate_hbSecurebootData: "
                  "KEY CLEAR Support is not enabled in hostboot so setting key_clear_request "
                  "in HDAT to 0x%.4X (KEY_CLEAR_REQUEST_NONE)",
                  key_clear_request);
        l_sysParmsPtr->hdatKeyClearRequest = key_clear_request;
#endif // CONFIG_KEY_CLEAR

    } while(0);

    return (l_elog);
} // end populate_hbRuntime

errlHndl_t populate_TpmInfoByNode(const uint64_t i_instance)
{
    errlHndl_t l_elog = nullptr;
    do {

    uint64_t l_baseAddr = 0;
    uint64_t l_dataSizeMax = 0;

    TRACFCOMP( g_trac_runtime, ENTER_MRK "populate_TpmInfoByNode: "
            "calling get_host_data_section() to populate instance %d",i_instance);

    l_elog = RUNTIME::get_host_data_section(RUNTIME::NODE_TPM_RELATED,
            i_instance,
            l_baseAddr,
            l_dataSizeMax);
    if(l_elog)
    {
        TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: "
                "get_host_data_section() failed for Node TPM-related Data section");
        break;
    }

    // obtain the node target, used later to populate fields
    TARGETING::Target* mproc = nullptr;
    l_elog = TARGETING::targetService().queryMasterProcChipTargetHandle(mproc);
    if(l_elog)
    {
        TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: "
                "could not obtain the master processor from targeting");
        break;
    }
    auto targetType = TARGETING::TYPE_NODE;
    const TARGETING::Target* l_node = getParent(mproc, targetType);
    assert(l_node != nullptr, "Bug! getParent on master proc returned null.");

    // this will additively keep track of the next available offset
    // as we fill the section
    uint32_t l_currOffset = 0;

    ////////////////////////////////////////////////////////////////////////
    // Section Node Secure and Trusted boot Related Data
    ////////////////////////////////////////////////////////////////////////

    auto const l_hdatTpmData
        = reinterpret_cast<HDAT::hdatTpmData_t*>(l_baseAddr);

    // make sure we have enough room
    auto const l_tpmDataCalculatedMax = HDAT::hdatTpmDataCalcInstanceSize();
    if(l_dataSizeMax < l_tpmDataCalculatedMax)
    {

        TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: The TPM data hdat section doesn't have enough space");

        /*@
         * @errortype
         * @severity      ERRL_SEV_UNRECOVERABLE
         * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
         * @reasoncode    RUNTIME::RC_TPM_HDAT_OUT_OF_SPACE
         * @userdata1     Size of hdat data struct
         * @userdata2     Max size of hdat data struct
         * @devdesc       The TPM data hdat section doesn't have enough space
         * @custdesc      Platform security problem detected
         */
        l_elog = new ERRORLOG::ErrlEntry(
                ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                RUNTIME::RC_TPM_HDAT_OUT_OF_SPACE,
                l_dataSizeMax,
                l_tpmDataCalculatedMax,
                true);
        l_elog->collectTrace(RUNTIME_COMP_NAME);
        break;
    }

    // check that hdat structure format and eye catch were filled out
    if(l_hdatTpmData->hdatHdr.hdatStructId != HDAT::HDAT_HDIF_STRUCT_ID)
    {
        TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: The TPM data hdat struct format value doesn't match");

        /*@
         * @errortype
         * @severity      ERRL_SEV_UNRECOVERABLE
         * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
         * @reasoncode    RUNTIME::RC_TPM_HDAT_ID_MISMATCH
         * @userdata1     hdat struct format value
         * @userdata2     Expected hdat struct format value
         * @devdesc       TPM data hdat struct format value doesn't match
         * @custdesc      Platform security problem detected
         */
        l_elog = new ERRORLOG::ErrlEntry(
                ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                RUNTIME::RC_TPM_HDAT_ID_MISMATCH,
                l_hdatTpmData->hdatHdr.hdatStructId,
                HDAT::HDAT_HDIF_STRUCT_ID,
                true);
        l_elog->collectTrace(RUNTIME_COMP_NAME);
        break;
    }

    auto l_eyeCatchLen = strlen(HDAT::g_hdatTpmDataEyeCatch);
    if(memcmp(l_hdatTpmData->hdatHdr.hdatStructName,
                HDAT::g_hdatTpmDataEyeCatch,
                l_eyeCatchLen) != 0)
    {

        // Convert char strings to uin64_t for errorlogs
        uint64_t l_eyeCatch = 0;
        memcpy(&l_eyeCatch,
                l_hdatTpmData->hdatHdr.hdatStructName,
                strnlen(l_hdatTpmData->hdatHdr.hdatStructName,sizeof(uint64_t)));
        uint64_t l_expectedEyeCatch = 0;
        memcpy(&l_expectedEyeCatch,
                HDAT::g_hdatTpmDataEyeCatch,
                strnlen(HDAT::g_hdatTpmDataEyeCatch, sizeof(uint64_t)));

        TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: The TPM data hdat struct name eye catcher (0x%X) doesn't match expected value (0x%X",
                l_eyeCatch, l_expectedEyeCatch);

        /*@
         * @errortype
         * @severity      ERRL_SEV_UNRECOVERABLE
         * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
         * @reasoncode    RUNTIME::RC_TPM_HDAT_EYE_CATCH_MISMATCH
         * @userdata1     hdat struct name eye catcher
         * @userdata2     Expected hdat eye catch
         * @devdesc       TPM data hdat struct name eye catcher doesn't match
         * @custdesc      Platform security problem detected
         */
        l_elog = new ERRORLOG::ErrlEntry(
                ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                RUNTIME::RC_TPM_HDAT_EYE_CATCH_MISMATCH,
                l_eyeCatch,
                l_expectedEyeCatch,
                true);
        l_elog->collectTrace(RUNTIME_COMP_NAME);
        break;
    }

    l_hdatTpmData->hdatHdr.hdatInstance = HDAT::TpmDataInstance;
    l_hdatTpmData->hdatHdr.hdatVersion = HDAT::TpmDataVersion;
    l_hdatTpmData->hdatHdr.hdatHdrSize = HDAT::TpmDataHdrSize;
    l_hdatTpmData->hdatHdr.hdatDataPtrOffset = HDAT::TpmDataPtrOffset;
    l_hdatTpmData->hdatHdr.hdatDataPtrCnt = HDAT::TpmDataPtrCnt;
    l_hdatTpmData->hdatHdr.hdatChildStrCnt = HDAT::TpmDataChildStrCnt;
    l_hdatTpmData->hdatHdr.hdatChildStrOffset = HDAT::TpmDataChildStrOffset;

    TRACFCOMP(g_trac_runtime,"populate_TpmInfoByNode: "
        "HDAT TPM Data successfully read. Struct Format:0x%X",
        l_hdatTpmData->hdatHdr.hdatStructId);
    TRACFBIN(g_trac_runtime, "populate_TpmInfoByNode - EyeCatch: ",
         l_hdatTpmData->hdatHdr.hdatStructName, l_eyeCatchLen);

    // go past the end of the first struct to get to the next one
    l_currOffset += sizeof(*l_hdatTpmData);

    ////////////////////////////////////////////////////////////////////////////
    // Section Secure Boot and Trusted boot info array
    ////////////////////////////////////////////////////////////////////////////

    // populate first part of pointer pair for secure boot TPM info
    l_hdatTpmData->hdatSbTpmInfo.hdatOffset = l_currOffset;

    // the second part of the pointer pair for secure boot TPM info will be
    // populated using the following start offset
    auto l_sbTpmInfoStart = l_currOffset;

    auto const l_hdatSbTpmInfo = reinterpret_cast<HDAT::hdatHDIFDataArray_t*>
                                                    (l_baseAddr + l_currOffset);

    TARGETING::TargetHandleList tpmList;
    TRUSTEDBOOT::getTPMs(tpmList, TRUSTEDBOOT::TPM_FILTER::ALL_FUNCTIONAL);

    // Put the primary TPM first in the list of TPMs to simplify alignment of
    // trusted boot enabled bits across the nodes.
    std::sort(tpmList.begin(), tpmList.end(),
              [](TARGETING::TargetHandle_t lhs, TARGETING::TargetHandle_t rhs)
              {
                return (lhs->getAttr<TARGETING::ATTR_TPM_ROLE>() ==
                        TARGETING::TPM_ROLE_TPM_PRIMARY);
              });

    TARGETING::TargetHandleList l_procList;

    getAllChips(l_procList,TARGETING::TYPE_PROC,false);

    auto const l_numTpms = tpmList.size();

    // fill in the values for the Secure Boot TPM Info Array Header
    l_hdatSbTpmInfo->hdatOffset = sizeof(*l_hdatSbTpmInfo);
    l_hdatSbTpmInfo->hdatArrayCnt = l_numTpms;
    l_hdatSbTpmInfo->hdatAllocSize = sizeof(HDAT::hdatSbTpmInstInfo_t);
    l_hdatSbTpmInfo->hdatActSize = l_hdatSbTpmInfo->hdatAllocSize;

    // advance current offset to after the Secure Boot TPM info array header
    l_currOffset += sizeof(*l_hdatSbTpmInfo);

    ////////////////////////////////////////////////////////////////////////////
    // Section Secure Boot and TPM Instance Info
    ////////////////////////////////////////////////////////////////////////////

    // save off a list of TPM / Instance Info pairs to fix up in a second pass
    std::vector<std::pair<TARGETING::Target*,
                          HDAT::hdatSbTpmInstInfo_t*> > fixList;

    // Calculate the SRTM log offset
    auto l_srtmLogOffset = 0;

    // Number of PCRD instances to be used later
    uint64_t l_numInstances = 0;
    l_elog = RUNTIME::get_instance_count(RUNTIME::PCRD, l_numInstances);
    if (l_elog)
    {
        TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: get_instance_count() failed for PCRD HDAT section");
        break;
    }

    // A collection of PCRD Instance Headers to be populated and used later
    std::vector<HDAT::hdatSpPcrd_t const *> l_pcrdInstances;
    std::vector<SPI::spiSlaveDevice> l_allTpmsDevInfo;
    // Populate the list of all TPMs from the MRW so that we can detect if there is a mismatch between what's listed
    // in the PCRD versus the MRW.
    //
    // Despite the tpmList only collecting ALL_FUNCTIONAL tpms, this list will be more complete than just a single TPM
    // in the loop to fill in the instance info below. Historically, tpmList would collect ALL_IN_BLUEPRINT which would
    // be all the TPMs specified by the MRW. However, due to some limitations on FSP side and descrepancies in the HDAT
    // spec suggesting that non-installed procs should have their data undefined the change to ALL_FUNCTIONAL became
    // necessary.
    for (auto pTpm : tpmList)
    {
        SPI::getSpiDeviceInfo(l_allTpmsDevInfo, pTpm);
    }

    // fill in the values for each Secure Boot TPM Instance Info in the array
    for (auto pTpm : tpmList)
    {
        auto l_tpmInstInfo = reinterpret_cast<HDAT::hdatSbTpmInstInfo_t*>
                                                    (l_baseAddr + l_currOffset);

        // save for second pass SRTM/DRTM log offset fixups
        fixList.push_back(std::make_pair(pTpm, l_tpmInstInfo));

        auto l_tpmInfo = pTpm->getAttr<TARGETING::ATTR_SPI_TPM_INFO>();

        TARGETING::PredicateAttrVal<TARGETING::ATTR_PHYS_PATH>
                                      hasSameSpiController(l_tpmInfo.spiMasterPath);

        auto itr = std::find_if(l_procList.begin(),l_procList.end(),
                                [&hasSameSpiController](const TARGETING::TargetHandle_t & t)
                                {
                                    return hasSameSpiController(t);
                                });

        if(itr == l_procList.end())
        {
            TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: TPM does not have a processor.");

            /*@
             * @errortype
             * @severity      ERRL_SEV_UNRECOVERABLE
             * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
             * @reasoncode    RUNTIME::RC_TPM_MISSING_PROC
             * @userdata1     Number of processors
             * @userdata2     0
             * @devdesc       TPM does not have a processor
             * @custdesc      Platform security problem detected
             */
            l_elog = new ERRORLOG::ErrlEntry(
                ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                RUNTIME::RC_TPM_MISSING_PROC,
                l_procList.size(),
                0,
                true);
            l_elog->collectTrace(RUNTIME_COMP_NAME);
            break;
        }

        // Start with an empty list of spi device ids from PCRD
        std::vector<HDAT::spiDeviceId_t> l_PcrdSpiDeviceIds;

        // Gather a list of SPI devices for this chip.
        std::vector<SPI::spiSlaveDevice> l_tpmSpiDevice;
        SPI::getSpiDeviceInfo(l_tpmSpiDevice,
                              pTpm);

        assert(l_tpmSpiDevice.size() == 1,
              "Duplicate entries for this TPM in MRW: %d",
              l_tpmSpiDevice.size());

        uint64_t l_pcrdAddr = 0;
        uint64_t l_pcrdSizeMax = 0;

        // Start with an invalid SPI Device Id for this TPM
        l_tpmInstInfo->hdatSpiDeviceId = HDAT::SPI_DEVICE_ID::INVALID_SPI_DEVICE_ID;

        TRACFCOMP(g_trac_runtime, "populate_TpmInfoByNode: "
                                  "Searching PCRD instances for TPM SPI Device with ID=0x%.8X, "
                                  "E=0x%X, P=0x%X, DevType=0x%X, DevPurp=0x%X",
                                  l_tpmSpiDevice[0].deviceId.word,
                                  l_tpmSpiDevice[0].masterEngine,
                                  l_tpmSpiDevice[0].masterPort,
                                  l_tpmSpiDevice[0].deviceType,
                                  l_tpmSpiDevice[0].devicePurpose);

        // Iterate through each Processor Chip Related Data (PCRD) instance to find this TPM in it.
        // There is additional processing to cache all the pointers for each PCRD instance to avoid
        // unnecessary lookups on subsequent searches of the PCRD for SPI and I2C info. There is
        // also checking to ensure duplicates and other oddities are not in the PCRD as it is
        // coming from a potentially untrusted source (FSP).
        for (uint64_t l_pcrdInstance = 0;
                l_pcrdInstance < l_numInstances;
                ++l_pcrdInstance)
        {
            // a pointer to the PCRD header
            HDAT::hdatSpPcrd_t const * l_pcrd = nullptr;

            // Populate the list of PCRD instances for use in below section "User physical interaction mechanism
            // information" and subsequent executions of this logic on other TPMs.
            // Avoid over populating this list after the first TPM
            if (l_pcrdInstances.size() < l_numInstances)
            {

                l_elog = RUNTIME::get_host_data_section(RUNTIME::PCRD,
                        l_pcrdInstance,
                        l_pcrdAddr,
                        l_pcrdSizeMax);
                if(l_elog)
                {
                    TRACFCOMP(g_trac_runtime, ERR_MRK"populate_TpmInfoByNode:"
                              " get_host_data_section() failed for PCRD HDAT section, instance %d",
                              l_pcrdInstance);
                    break;
                }

                // Get a pointer to the PCRD header
                l_pcrd = reinterpret_cast<const HDAT::hdatSpPcrd_t*>(l_pcrdAddr);

                l_pcrdInstances.push_back(l_pcrd);

                // Check the version of the PCRD section header
                if(l_pcrd->hdatHdr.hdatVersion < HDAT::TpmDataMinRqrdPcrdVersion)
                {
                    TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: "
                              "Bad PCRD section version 0x%X - must be 0x%X or greater",
                              l_pcrd->hdatHdr.hdatVersion,
                              HDAT::TpmDataMinRqrdPcrdVersion);

                    /*@
                     * @errortype
                     * @severity      ERRL_SEV_UNRECOVERABLE
                     * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                     * @reasoncode    RUNTIME::RC_TPM_HDAT_BAD_VERSION
                     * @userdata1     hdat version
                     * @userdata2     Expected support version
                     * @devdesc       Bad PCRD section version
                     * @custdesc      Platform security problem detected
                     */
                    l_elog = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                     RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                                                     RUNTIME::RC_TPM_HDAT_BAD_VERSION,
                                                     l_pcrd->hdatHdr.hdatVersion,
                                                     HDAT::TpmDataMinRqrdPcrdVersion,
                                                     ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
                    l_elog->collectTrace(RUNTIME_COMP_NAME);
                    break;
                }
            }
            else
            {
                TRACDCOMP(g_trac_runtime, INFO_MRK"populate_TpmInfoByNode: "
                          "Using stored PCRD pointer for instance %d", l_pcrdInstance);
                l_pcrd = l_pcrdInstances[l_pcrdInstance];
            }

            assert(l_pcrd != nullptr, "l_pcrd was nullptr and that shouldn't happen!");

            // Get offset for the SPI array header
            auto spiArrayOffset = l_pcrd->hdatPcrdIntData[HDAT::HDAT_PCRD_DA_HOST_SPI].hdatOffset;

            TRACDCOMP(g_trac_runtime, INFO_MRK "populate_TpmInfoByNode: "
                      "spiArrayOffset 0x%x; PCRD Instance = %d", spiArrayOffset, l_pcrdInstance);

            // If pointer pair's offset value is 0, advance to next PCRD instance
            // as this one has no SPI Devices
            if(!spiArrayOffset)
            {
                continue;
            }

            // Convert SPI array header offset to a pointer to the SPI array header
            const auto l_pHostSpiPcrdHeader =
                reinterpret_cast<HDAT::hdatHDIFDataArray_t*>(reinterpret_cast<uint64_t>(l_pcrd) + spiArrayOffset);

            // make sure the array count is within reasonable limits
            if(l_pHostSpiPcrdHeader->hdatArrayCnt > HDAT_PCRD_MAX_SPI_DEV)
            {
                TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: "
                          "HDAT PCRD reported more than the max number of SPI devices! Count:%d",
                          l_pHostSpiPcrdHeader->hdatArrayCnt);

                /*@
                 * @errortype
                 * @severity      ERRL_SEV_UNRECOVERABLE
                 * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                 * @reasoncode    RUNTIME::RC_TPM_HDAT_BAD_NUM_SPI
                 * @userdata1     hdat array count
                 * @userdata2     max number of SPI devices
                 * @devdesc       HDAT PCRD reported more than the max number of SPI devices
                 * @custdesc      Platform security problem detected
                 */
                l_elog = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                 RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                                                 RUNTIME::RC_TPM_HDAT_BAD_NUM_SPI,
                                                 l_pHostSpiPcrdHeader->hdatArrayCnt,
                                                 HDAT_PCRD_MAX_SPI_DEV,
                                                 ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
                l_elog->collectTrace(RUNTIME_COMP_NAME);
                break;
            }

            // Get the pointer to the first element in the SPI array
            // This is the address of the header plus the offset given in the header
            auto l_spiDevStart = reinterpret_cast<const uint8_t*>(l_pHostSpiPcrdHeader)
                               + l_pHostSpiPcrdHeader->hdatOffset;

            // Calculate the stop pointer
            auto l_spiDevStop = l_spiDevStart + (l_pHostSpiPcrdHeader->hdatArrayCnt
                              * l_pHostSpiPcrdHeader->hdatAllocSize);

            // for each SPI Device in the PCRD
            for (auto l_cur = l_spiDevStart;
                    l_cur != l_spiDevStop;
                    l_cur += l_pHostSpiPcrdHeader->hdatAllocSize )
            {
                // reinterpret the byte pointer as a struct pointer
                auto l_pcrdSpiDevice = reinterpret_cast<const HDAT::hdatSpiDevData_t*>(l_cur);

                // if we've seen it already
                auto it = std::find(l_PcrdSpiDeviceIds.begin(),
                                    l_PcrdSpiDeviceIds.end(),
                                    l_pcrdSpiDevice->hdatSpiDevId);
                if (it != l_PcrdSpiDeviceIds.end())
                {
                    const auto l_spiDeviceId = *it;
                    TRACFCOMP(g_trac_runtime,
                            "populate_TpmInfoByNode: A duplicate SPI Device Id was found in HDAT PCRD Section: 0x%.8X",
                            l_spiDeviceId);

                    // terminate the boot due to an integrity violation
                    /*@
                     * @errortype
                     * @reasoncode    RUNTIME::RC_DUPLICATE_SPI_DEV_IDS
                     * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                     * @severity      ERRL_SEV_UNRECOVERABLE
                     * @userdata1     SPI Device ID
                     * @userdata1     [0:3] Byte 0: System Level Node Ordinal ID
                     * @userdata1     [4:7] Byte 1: Node Level Processor Sequence ID
                     * @userdata1     [8:15] Byte 2-3: Running number for each SPI device entry in this array
                     * @devdesc       Found duplicate SPI Device IDs in PCRD section
                     *                of HDAT. System security cannot be guaranteed.
                     * @custdesc      Platform security problem detected
                     */
                    l_elog = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                     RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                                                     RUNTIME::RC_DUPLICATE_SPI_DEV_IDS,
                                                     l_spiDeviceId,
                                                     0,
                                                     ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
                    l_elog->collectTrace(RUNTIME_COMP_NAME);
                    break;
                }
                else
                {
                    // add it to a known list to make sure we don't see it again
                    l_PcrdSpiDeviceIds.push_back(l_pcrdSpiDevice->hdatSpiDevId);
                }

                if (l_pcrdSpiDevice->hdatSpiDevPurp != static_cast<uint8_t>(spiSlaveDevice::slaveDevicePurpose_t::TPM))
                {
                    // Only searching for TPM SPI Devices at this point.
                    continue;
                }

                // Now make sure we have a match in the mrw.
                // l_tpmSpiDevice only holds the current TPM not all TPMs so use the full list l_allTpmsDevInfo.
                SPI::CompareSlaveDevice isSame(l_pcrdSpiDevice);
                auto itr = std::find_if(l_allTpmsDevInfo.begin(),
                                        l_allTpmsDevInfo.end(),
                                        isSame);

                if (itr == l_allTpmsDevInfo.end())
                {
                    // Couldn't find a match
                    TRACFCOMP(g_trac_runtime, "populate_TpmInfoByNode: "
                              "SPI Device in the PCRD with Spi Device ID 0x%.8X does not have a match in the MRW",
                              l_pcrdSpiDevice->hdatSpiDevId);
                    /*@
                     * @errortype
                     * @reasoncode   RUNTIME::RC_SPI_DEVICE_NOT_IN_MRW
                     * @moduleid     RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                     * @severity     ERRL_SEV_INFORMATIONAL
                     * @userdata1    [0:7] SPI Controller Engine
                     * @userdata1    [8:15] SPI Controller Port
                     * @userdata1    [16:23] SPI Receiver Device Type
                     * @userdata1    [24:31] SPI Receiver Device Purpose
                     * @userdata1    [32:63] SPI Device Id
                     * @userdata1    [32:35] Byte 0: System Level Node Ordinal ID
                     * @userdata1    [35:39] Byte 1: Node Level Processor Sequence ID
                     * @userdata1    [39:47] Byte 2-3: Running number for each SPI device entry in this array
                     * @devdesc      A SPI device in the PCRD does not have a match
                     *               in the MRW.
                     * @custdesc     Platform security problem detected
                     */
                    l_elog = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_INFORMATIONAL,
                                                     RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                                                     RUNTIME::RC_SPI_DEVICE_NOT_IN_MRW,
                                                     TWO_UINT32_TO_UINT64(
                                                         FOUR_UINT8_TO_UINT32(
                                                             l_pcrdSpiDevice->hdatSpiMasterEngine,
                                                             l_pcrdSpiDevice->hdatSpiMasterPort,
                                                             l_pcrdSpiDevice->hdatSpiSlaveDevType,
                                                             l_pcrdSpiDevice->hdatSpiDevPurp),
                                                         l_pcrdSpiDevice->hdatSpiDevId),
                                                     0,
                                                     ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
                    l_elog->collectTrace(RUNTIME_COMP_NAME);
                    errlCommit(l_elog, RUNTIME_COMP_ID);
                }
                else
                {
                    // A matching TPM was found in the PCRD, check if its the one we're trying to fill the info in for.
                    if (l_tpmSpiDevice.empty() || !isSame(l_tpmSpiDevice[0]))
                    {
                        // This is not the SPI device we are looking for, move along.
                        continue;
                    }

                    // Make sure the TPM we're matched against hasn't already been filled in.
                    if (l_tpmInstInfo->hdatSpiDeviceId != HDAT::SPI_DEVICE_ID::INVALID_SPI_DEVICE_ID)
                    {
                        // Found a duplicate SPI Device ID match indicating that there was an error in the model
                        TRACFCOMP(g_trac_runtime, "populate_TpmInfoByNode: "
                                  "SPI device in the PCRD with Spi Device ID 0x%.8X has a duplicate match in the MRW",
                                  l_pcrdSpiDevice->hdatSpiDevId);
                        /*@
                         * @errortype
                         * @reasoncode   RUNTIME::RC_SPI_DEVICE_DUPLICATE_IN_MRW
                         * @moduleid     RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                         * @severity     ERRL_SEV_UNRECOVERABLE
                         * @userdata1    [0:7] SPI Controller Engine
                         * @userdata1    [8:15] SPI Controller Port
                         * @userdata1    [16:23] SPI Receiver Device Type
                         * @userdata1    [24:31] SPI Receiver Device Purpose
                         * @userdata1    [32:63] SPI Device Id
                         * @userdata1    [32:35] Byte 0: System Level Node Ordinal ID
                         * @userdata1    [35:39] Byte 1: Node Level Processor Sequence ID
                         * @userdata1    [39:47] Byte 2-3: Running number for each SPI device entry in this array
                         * @devdesc      An SPI device in the PCRD has a duplicate
                         *               match in the MRW.
                         * @custdesc     Platform security problem detected
                         */
                        l_elog = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                         RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                                                         RUNTIME::RC_SPI_DEVICE_DUPLICATE_IN_MRW,
                                                         TWO_UINT32_TO_UINT64(
                                                             FOUR_UINT8_TO_UINT32(
                                                                 l_pcrdSpiDevice->hdatSpiMasterEngine,
                                                                 l_pcrdSpiDevice->hdatSpiMasterPort,
                                                                 l_pcrdSpiDevice->hdatSpiSlaveDevType,
                                                                 l_pcrdSpiDevice->hdatSpiDevPurp),
                                                             l_pcrdSpiDevice->hdatSpiDevId),
                                                         0,
                                                         ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
                        l_elog->collectTrace(RUNTIME_COMP_NAME);
                        break;
                    }
                    else // found a match
                    {
                        // Double check the engine and port are correct.
                        const uint8_t SPI_ENGINE_TPM = 4;
                        const uint8_t SPI_CONTROLLER_SELECT = 0;
                        if ((l_pcrdSpiDevice->hdatSpiMasterEngine == SPI_ENGINE_TPM) &&
                            (l_pcrdSpiDevice->hdatSpiMasterPort == SPI_CONTROLLER_SELECT))
                        {
                            l_tpmInstInfo->hdatSpiDeviceId = l_pcrdSpiDevice->hdatSpiDevId;
                            // Only holds the current TPM entry which was just found. Erase it so we don't erroneously
                            // think we found a duplicate later when checking if the other MRW TPM is presesnt in the
                            // PCRD.
                            l_tpmSpiDevice.clear();
                            TRACFCOMP(g_trac_runtime, "populate_TpmInfoByNode: "
                                                      "PCRD TPM SPI Device has a match in the MRW: "
                                                      "E=0x%X, P=0x%X, DevType=0x%X, DevPurp=0x%X",
                                                      l_pcrdSpiDevice->hdatSpiMasterEngine,
                                                      l_pcrdSpiDevice->hdatSpiMasterPort,
                                                      l_pcrdSpiDevice->hdatSpiSlaveDevType,
                                                      l_pcrdSpiDevice->hdatSpiDevPurp);
                        }
                        else
                        {
                            TRACFCOMP(g_trac_runtime, ERR_MRK"populate_TpmInfoByNode: "
                                      "SPI device in the PCRD with Spi Device ID 0x%.8X has a "
                                      "bad engine 0x%X and/or port 0x%X",
                                      l_pcrdSpiDevice->hdatSpiDevId,
                                      l_pcrdSpiDevice->hdatSpiMasterEngine,
                                      l_pcrdSpiDevice->hdatSpiMasterPort);
                            /*@
                             * @errortype
                             * @reasoncode   RUNTIME::RC_INVALID_SPI_DEVICE
                             * @moduleid     RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                             * @severity     ERRL_SEV_UNRECOVERABLE
                             * @userdata1    [0:7] SPI Controller Engine
                             * @userdata1    [8:15] SPI Controller Port
                             * @userdata1    [16:23] SPI Receiver Device Type
                             * @userdata1    [24:31] SPI Receiver Device Purpose
                             * @userdata1    [32:63] SPI Device Id
                             * @userdata1    [32:35] Byte 0: System Level Node Ordinal ID
                             * @userdata1    [35:39] Byte 1: Node Level Processor Sequence ID
                             * @userdata1    [39:47] Byte 2-3: Running number for each SPI device entry in this array
                             * @devdesc      An SPI device in the PCRD has an invalid engine and/or port.
                             * @custdesc     Platform security problem detected
                             */
                            l_elog = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                             RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                                                             RUNTIME::RC_INVALID_SPI_DEVICE,
                                                             TWO_UINT32_TO_UINT64(
                                                                 FOUR_UINT8_TO_UINT32(
                                                                     l_pcrdSpiDevice->hdatSpiMasterEngine,
                                                                     l_pcrdSpiDevice->hdatSpiMasterPort,
                                                                     l_pcrdSpiDevice->hdatSpiSlaveDevType,
                                                                     l_pcrdSpiDevice->hdatSpiDevPurp),
                                                                 l_pcrdSpiDevice->hdatSpiDevId),
                                                             0,
                                                             ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
                            l_elog->collectTrace(RUNTIME_COMP_NAME);
                            break;
                        }
                    }
                }
            } // for each spi device in the current PCRD instance
            if (l_elog)
            {
                break;
            }
        } // for each PCRD instance
        if (l_elog)
        {
            break;
        }

        if (!l_tpmSpiDevice.empty())
        {
            size_t i = 0;
            for (const auto& spiDev : l_tpmSpiDevice)
            {
                TRACFCOMP(g_trac_runtime, "populate_TpmInfoByNode: "
                          "A SPI device in the MRW was not found in the PCRD. "
                          "SPI Device ID: 0x%.8X; engine: 0x%X; masterport: 0x%X; "
                          "devicetype: 0x%X; devicepurpose: 0x%X; ",
                          spiDev.deviceId.word,
                          spiDev.masterEngine,
                          spiDev.masterPort,
                          spiDev.deviceType,
                          spiDev.devicePurpose);
                /*@
                 * @errortype
                 * @reasoncode   RUNTIME::RC_EXTRA_SPI_DEVICE_IN_MRW
                 * @moduleid     RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                 * @severity     ERRL_SEV_UNRECOVERABLE
                 * @userdata1    [0:7] SPI Controller Engine
                 * @userdata1    [8:15] SPI Controller Port
                 * @userdata1    [16:23] SPI Receiver Device Type
                 * @userdata1    [24:31] SPI Receiver Device Purpose
                 * @userdata1    [32:63] SPI Device Id
                 * @userdata1    [32:35] Byte 0: System Level Node Ordinal ID
                 * @userdata1    [35:39] Byte 1: Node Level Processor Sequence ID
                 * @userdata1    [39:47] Byte 2-3: Running number for each SPI device entry in this array
                 * @devdesc      An SPI device in the MRW has no match
                 *               in the PCRD.
                 * @custdesc     Platform security problem detected
                 */
                l_elog = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                 RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                                                 RUNTIME::RC_EXTRA_SPI_DEVICE_IN_MRW,
                                                 TWO_UINT32_TO_UINT64(
                                                     FOUR_UINT8_TO_UINT32(spiDev.masterEngine,
                                                         spiDev.masterPort,
                                                         spiDev.deviceType,
                                                         spiDev.devicePurpose),
                                                     spiDev.deviceId.word),
                                                 0,
                                                 ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
                l_elog->collectTrace(RUNTIME_COMP_NAME);
                if (++i >= l_tpmSpiDevice.size())
                {
                    // This error will be returned
                    break;
                }
                else
                {
                    // Commit this error and create another
                    errlCommit(l_elog, RUNTIME_COMP_ID);
                    // l_elog is now nullptr
                }
            }
        }
        if (l_elog)
        {
            break;
        }

        // Reserved space was previously used for "Drawer/Book/Octant/Blade"-id
        // and TPM locality values
        l_tpmInstInfo->reserved_0x0004 = 0x0;
        l_tpmInstInfo->reserved_0x0008 = 0x0;
        l_tpmInstInfo->reserved_0x0009 = 0x0;
        l_tpmInstInfo->reserved_0x000A = 0x0;
        l_tpmInstInfo->reserved_0x000B = 0x0;

        auto hwasState = pTpm->getAttr<TARGETING::ATTR_HWAS_STATE>();

        // When building HDAT, it is safe to assume that all functional backup
        // TPMs in the system have been poisoned by the SBE.  The poisoned flag
        // is applicable only when a TPM is functional (otherwise, it defaults
        // to 0 and should be ignored by any consumer of HDAT).
        uint8_t poisonedFlag = 0;

        const auto tpmRole = pTpm->getAttr<TARGETING::ATTR_TPM_ROLE>();
        if (hwasState.functional && hwasState.present)
        {
            // present and functional
            l_tpmInstInfo->hdatFunctionalStatus = HDAT::TpmPresentAndFunctional;

            if(tpmRole == TARGETING::TPM_ROLE_TPM_PRIMARY)
            {
                poisonedFlag = pTpm->getAttr<TARGETING::ATTR_TPM_POISONED>();
            }
            else
            {
                poisonedFlag = true;
            }
        }
        else if (hwasState.present)
        {
            // present and not functional
            l_tpmInstInfo->hdatFunctionalStatus = HDAT::TpmPresentNonFunctional;
        }
        else
        {
            // not present
            l_tpmInstInfo->hdatFunctionalStatus = HDAT::TpmNonPresent;
        }

        // Set TPM configuration flag
        l_tpmInstInfo->hdatTpmConfigFlags.pcrPoisonedFlag = poisonedFlag;

        // Set TPM role flag
        l_tpmInstInfo->hdatTpmConfigFlags.tpmRole = tpmRole;

        // advance the current offset to account for this tpm instance info
        l_currOffset += sizeof(*l_tpmInstInfo);

        // advance the SRTM log offset to account for this tpm instance info
        l_srtmLogOffset += sizeof(*l_tpmInstInfo);

    }

    if (l_elog)
    {
        break;
    }

    for (auto tpmInstPair : fixList)
    {
        const auto pTpm = tpmInstPair.first;
        const auto l_tpmInstInfo = tpmInstPair.second;

        ////////////////////////////////////////////////////////////////////////
        // Section Secure Boot TPM Event Log
        ////////////////////////////////////////////////////////////////////////

        // The SRTM offset we had been tallying in the previous loop happens to
        // be the offset from the first TPM Instance Info to the first SRTM log
        l_tpmInstInfo->hdatTpmSrtmEventLogOffset = l_srtmLogOffset;

        // As we go through the list we remove a TPM instance info length and
        // add an SRTM log length to the previous offset. The reason is b/c a
        // TPM Instance info's log offset is counted from the start of the
        // that instance info. We subtract an instance info length from the
        // previous offset to account for that difference. We also add a log max
        // to account for the previous instance info's log.
        l_srtmLogOffset += (TPM_SRTM_EVENT_LOG_MAX - sizeof(*l_tpmInstInfo));

        // copy the contents of the SRTM event log into HDAT picking the
        // min of log size and log max (to make sure log size never goes
        // over the max)
        auto * const pLogMgr = TRUSTEDBOOT::getTpmLogMgr(pTpm);
        size_t logSize = 0;
        if(pLogMgr != nullptr)
        {
            #ifdef CONFIG_TPMDD

            // The log size always has to be specified to the max
            //  this is because after HDAT is populated additional
            //  entries can be posted to the log to cause it to
            //  grow beyond its current size
            logSize = TPM_SRTM_EVENT_LOG_MAX;

            // Although the TPM log's physical memory is currently memory mapped
            // to a virtual address range, said range will go out of scope when
            // processing other HDAT sections.  Therefore, for every TPM log,
            // open a secondary and persistent virtual memory window to it, so
            // that the TPM log manager will have a consistent
            // virtual-to-physical address mapping to write its log data to.
            // Hostboot will keep this range open since TPM extensions
            // happen up until invoking the payload.
            const uint64_t tpmLogVirtAddr = l_baseAddr + l_currOffset;
            const auto tpmLogPhysAddr =
                mm_virt_to_phys(reinterpret_cast<void*>(tpmLogVirtAddr));
            if(static_cast<int64_t>(tpmLogPhysAddr) == -EFAULT)
            {
                TRACFCOMP(g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: "
                    "Failed in call to mm_virt_to_phys() with virtual address "
                    "0x%016llX",
                    tpmLogVirtAddr);
                /*@
                 * @errortype
                 * @severity   ERRL_SEV_UNRECOVERABLE
                 * @moduleid   RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                 * @reasoncode RUNTIME::RC_TPM_HDAT_VIRT_TO_PHYS_ERR
                 * @userdata1  Requested virtual address to convert
                 * @devdesc    Failed to convert virtual address to physical
                 *             address
                 * @custdesc   Firmware encountered an internal error
                 */
                l_elog = new ERRORLOG::ErrlEntry(
                    ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                    RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                    RUNTIME::RC_TPM_HDAT_VIRT_TO_PHYS_ERR,
                    tpmLogVirtAddr,
                    0,
                    true);
                l_elog->collectTrace(RUNTIME_COMP_NAME);
                break;
            }

            decltype(tpmLogPhysAddr) tpmLogAlignedPhysAddr
                = ALIGN_PAGE_DOWN(tpmLogPhysAddr);
            decltype(logSize) diff = tpmLogPhysAddr-tpmLogAlignedPhysAddr;
            decltype(logSize) tpmLogAlignedSize
                = ALIGN_PAGE(diff + logSize);

            auto tpmLogNewVirtAddr =
                mm_block_map(reinterpret_cast<void*>(tpmLogAlignedPhysAddr),
                             tpmLogAlignedSize);
            if(tpmLogNewVirtAddr == nullptr)
            {
                TRACFCOMP(g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: "
                    "Failed in call to mm_block_map with aligned physical "
                    "address 0x%016llX and aligned size 0x%016llX",
                    tpmLogAlignedPhysAddr,tpmLogAlignedSize);

                /*@
                 * @errortype
                 * @severity   ERRL_SEV_UNRECOVERABLE
                 * @moduleid   RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                 * @reasoncode RUNTIME::RC_TPM_HDAT_MAP_BLOCK_ERR
                 * @userdata1  Aligned physical address to map
                 * @userdata2  Aligned size or region to map
                 * @devdesc    Failed to map physical memory to virtual memory
                 * @custdesc   Firmware encountered an internal error
                 */
                l_elog = new ERRORLOG::ErrlEntry(
                    ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                    RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                    RUNTIME::RC_TPM_HDAT_MAP_BLOCK_ERR,
                    tpmLogAlignedPhysAddr,
                    tpmLogAlignedSize,
                    true);
                l_elog->collectTrace(RUNTIME_COMP_NAME);
                break;
            }
            tpmLogNewVirtAddr=
                reinterpret_cast<void*>(
                    diff+reinterpret_cast<uint8_t*>(tpmLogNewVirtAddr));

            TRACFCOMP(g_trac_runtime, INFO_MRK "Moving TPM log; "
                "Current virtual address = 0x%016llX, "
                "Current log size = 0x%016llX, "
                "Current physical address = 0x%016llX, "
                "Aligned physical address = 0x%016llX, "
                "Aligned log size = 0x%016llX, "
                "New virtual address = 0x%016llX.",
                tpmLogVirtAddr,
                logSize,
                tpmLogPhysAddr,
                tpmLogAlignedPhysAddr,
                tpmLogAlignedSize,
                tpmLogNewVirtAddr);

            // Move TPM log to the new virtual memory mapping
            TRUSTEDBOOT::TpmLogMgr_relocateTpmLog(pLogMgr,
                          reinterpret_cast<uint8_t*>(tpmLogNewVirtAddr),
                          logSize);
            #endif
        }
        else
        {
            TRACFCOMP( g_trac_runtime, INFO_MRK "populate_TpmInfoByNode: "
                "No static log available to propagate for TPM with HUID of "
                "0x%08X",TARGETING::get_huid(pTpm));
        }

        // set the size value for the data that was copied
        l_tpmInstInfo->hdatTpmSrtmEventLogEntrySize = logSize;

        // advance the current offset to account for the SRTM event log
        l_currOffset += TPM_SRTM_EVENT_LOG_MAX;

        // set the DRTM offset to zero as it is not yet supported
        l_tpmInstInfo->hdatTpmDrtmEventLogOffset = 0;

        // set the DRTM event log size to zero as it is not yet supported
        l_tpmInstInfo->hdatTpmDrtmEventLogEntrySize = 0;

        // Note: We don't advance the current offset, because the size of the
        // DRTM event log is zero
    }
    if (l_elog)
    {
        break;
    }

    // populate second part of pointer pair for secure boot TPM info
    l_hdatTpmData->hdatSbTpmInfo.hdatSize = l_currOffset - l_sbTpmInfoStart;

    ////////////////////////////////////////////////////////////////////////////
    // Section User physical interaction mechanism information
    ////////////////////////////////////////////////////////////////////////////

    // the current offset now corresponds to the physical interaction mechanism
    // info array header
    auto l_physInter = reinterpret_cast<HDAT::hdatPhysInterMechInfo_t*>
                                                    (l_baseAddr + l_currOffset);

    // populate the first part of pointer pair from earlier to point here
    l_hdatTpmData->hdatPhysInter.hdatOffset = l_currOffset;

    // the following will be used to calculate the second part of pointer pair
    auto l_physInterStart = l_currOffset;

    // start with an empty list of link IDs
    std::vector<HDAT::i2cLinkId_t> l_linkIds;

    // obtain a list of i2c targets
    std::list<I2C::DeviceInfo_t> l_i2cTargetList;
    I2C::getDeviceInfo(mproc, l_i2cTargetList);
    auto i2cDevItr = l_i2cTargetList.begin();
    while(i2cDevItr != l_i2cTargetList.end())
    {
        switch((*i2cDevItr).devicePurpose)
        {
        case TARGETING::HDAT_I2C_DEVICE_PURPOSE_WINDOW_OPEN:
        case TARGETING::HDAT_I2C_DEVICE_PURPOSE_PHYSICAL_PRESENCE:
            // keep devices with these two purposes
            ++i2cDevItr;
            break;
        default:
            // remove devices with any other purpose
            i2cDevItr = l_i2cTargetList.erase(i2cDevItr);
            break;
        }
    }

    // Initialize i2cLinkIds to NA before attempting populate
    l_physInter->i2cLinkIdPhysicalPresence = HDAT::I2C_LINK_ID::NOT_APPLICABLE;
    l_physInter->i2cLinkIdWindowOpen = HDAT::I2C_LINK_ID::NOT_APPLICABLE;

    for (const auto& l_pcrd : l_pcrdInstances)
    {

        // Get offset for the i2c array header
        auto i2cAryOff =
            l_pcrd->hdatPcrdIntData[HDAT::HDAT_PCRD_DA_HOST_I2C].hdatOffset;

        // If pointer pair's offset value is 0, advance to next PCRD instance
        // as this one has no I2C links
        if(!i2cAryOff)
        {
            continue;
        }

        // Convert i2c array header offset to a pointer to the i2c array header
        const auto l_hostI2cPcrdHdrPtr =
           reinterpret_cast<HDAT::hdatHDIFDataArray_t*>(reinterpret_cast<uint64_t>(l_pcrd) + i2cAryOff);

        // make sure the array count is within reasonable limits
        if(l_hostI2cPcrdHdrPtr->hdatArrayCnt > HDAT_PCRD_MAX_I2C_DEV)
        {
            TRACFCOMP( g_trac_runtime, ERR_MRK "populate_TpmInfoByNode: HDAT PCRD reported more than the max number of i2c devices! Count:%d",
                       l_hostI2cPcrdHdrPtr->hdatArrayCnt);

            /*@
             * @errortype
             * @severity      ERRL_SEV_UNRECOVERABLE
             * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
             * @reasoncode    RUNTIME::RC_TPM_HDAT_BAD_NUM_I2C
             * @userdata1     hdat array count
             * @userdata2     max number of i2c devices
             * @devdesc       HDAT PCRD reported more than the max number of i2c devices
             * @custdesc      Platform security problem detected
             */
            l_elog = new ERRORLOG::ErrlEntry(
                ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                RUNTIME::RC_TPM_HDAT_BAD_NUM_I2C,
                l_hostI2cPcrdHdrPtr->hdatArrayCnt,
                HDAT_PCRD_MAX_I2C_DEV,
                true);
            l_elog->collectTrace(RUNTIME_COMP_NAME);
            break;
        }

        // Get the pointer to the first element in the i2c array
        // This is the address of the header plus the offset given in the header
        auto l_i2cDevStart =
            reinterpret_cast<const uint8_t*>(l_hostI2cPcrdHdrPtr)
            + l_hostI2cPcrdHdrPtr->hdatOffset;

        // Calculate the stop pointer
        auto l_i2cDevStop = l_i2cDevStart + (l_hostI2cPcrdHdrPtr->hdatArrayCnt *
                                           l_hostI2cPcrdHdrPtr->hdatAllocSize);

        // for each link ID in the PCRD
        for (auto l_cur = l_i2cDevStart;
             l_cur != l_i2cDevStop;
             l_cur += l_hostI2cPcrdHdrPtr->hdatAllocSize )
        {
            // reinterpret the byte pointer as a struct pointer
            auto l_i2cDev = reinterpret_cast<const HDAT::hdatI2cData_t*>(l_cur);

            // if we've seen it already
            auto it = std::find(l_linkIds.begin(),
                            l_linkIds.end(),
                            l_i2cDev->hdatI2cLinkId);
            if (it != l_linkIds.end())
            {
                const auto l_linkId = *it;
                TRACFCOMP(g_trac_runtime,
                    "populate_TpmInfoByNode: A duplicate link Id was found. %d",
                    l_linkId);

                // terminate the boot due to an integrity violation
                /*@
                 * @errortype
                 * @reasoncode    RUNTIME::RC_DUPLICATE_I2C_LINK_IDS
                 * @moduleid      RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                 * @severity      ERRL_SEV_UNRECOVERABLE
                 * @userdata1     I2C Link ID
                 * @devdesc       Found duplicate I2C link IDs in PCRD section
                 *                of HDAT. System security cannot be guaranteed.
                 * @custdesc      Platform security problem detected
                 */
                auto err = new ERRORLOG::ErrlEntry(
                    ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                    RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                    RUNTIME::RC_DUPLICATE_I2C_LINK_IDS,
                    l_linkId,
                    0,
                    true);
                err->collectTrace(RUNTIME_COMP_NAME);
                SECUREBOOT::handleSecurebootFailure(err);

                assert(false,"Bug! handleSecurebootFailure shouldn't return!");
            }
            else
            {
                // add it to a known list to make sure we don't see it again
                l_linkIds.push_back(l_i2cDev->hdatI2cLinkId);
            }
            // use this pointer to avoid having to repeat the switch statement
            // later
            HDAT::i2cLinkId_t* l_pLinkId = nullptr;

            switch(l_i2cDev->hdatI2cSlaveDevPurp)
            {
            case TARGETING::HDAT_I2C_DEVICE_PURPOSE_WINDOW_OPEN:

                l_pLinkId = &l_physInter->i2cLinkIdWindowOpen;
                break;

            case TARGETING::HDAT_I2C_DEVICE_PURPOSE_PHYSICAL_PRESENCE:

                l_pLinkId = &l_physInter->i2cLinkIdPhysicalPresence;
                break;

            default:
                // Physical Presence Info not supported for this I2c device
                // purpose.  This device will not be referred to by the Node TPM
                // Related Info Section, but we still ensure uniqueness of all
                // link IDs in the I2c device list from the PCRD.
            continue;
            }

            // now make sure we have a match in the mrw
            auto itr = std::find_if(l_i2cTargetList.begin(),
                                    l_i2cTargetList.end(),

            [&l_i2cDev,&l_pcrd](const I2C::DeviceInfo_t & i_i2cDevMrw)
            {
                return
                    i_i2cDevMrw.masterChip->getAttr<
                        TARGETING::ATTR_ORDINAL_ID>() ==
                            l_pcrd->hdatChipData.hdatPcrdProcChipId &&
                    l_i2cDev->hdatI2cEngine == i_i2cDevMrw.engine &&
                    l_i2cDev->hdatI2cMasterPort == i_i2cDevMrw.masterPort &&
                    l_i2cDev->hdatI2cBusSpeed == i_i2cDevMrw.busFreqKhz &&
                    l_i2cDev->hdatI2cSlaveDevType == i_i2cDevMrw.deviceType &&
                    l_i2cDev->hdatI2cSlaveDevAddr == i_i2cDevMrw.addr &&
                    l_i2cDev->hdatI2cSlavePort == i_i2cDevMrw.slavePort &&
                    l_i2cDev->hdatI2cSlaveDevPurp == i_i2cDevMrw.devicePurpose
                    &&
                    !strcmp(l_i2cDev->hdatI2cLabel, i_i2cDevMrw.deviceLabel);
            });

            if (itr == l_i2cTargetList.end())
            {
                // couldn't find it, physical presence will not be available
                TRACFCOMP(g_trac_runtime,
                    "populate_TpmInfoByNode: I2c device in the PCRD with link ID %d does not have a match in the MRW",
                    l_i2cDev->hdatI2cLinkId);
                /*@
                 * @errortype
                 * @reasoncode   RUNTIME::RC_I2C_DEVICE_NOT_IN_MRW
                 * @moduleid     RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                 * @severity     ERRL_SEV_INFORMATIONAL
                 * @userdata1    I2C Link ID
                 * @devdesc      An I2C device in the PCRD does not have a match
                 *               in the MRW. Physical presence detection
                 *               will not be available.
                 * @custdesc     Platform security problem detected
                 */
                auto err = new ERRORLOG::ErrlEntry(
                    ERRORLOG::ERRL_SEV_INFORMATIONAL,
                    RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                    RUNTIME::RC_I2C_DEVICE_NOT_IN_MRW,
                    l_i2cDev->hdatI2cLinkId,
                    0,
                    true);
                err->collectTrace(RUNTIME_COMP_NAME);
                ERRORLOG::errlCommit(err, RUNTIME_COMP_ID);
            }
            else
            {
                if (*l_pLinkId != HDAT::I2C_LINK_ID::NOT_APPLICABLE)
                {
                    // found a duplicate link id match indicating that there
                    // was an error in the model
                    TRACFCOMP(g_trac_runtime,
                        "populate_TpmInfoByNode: I2c device in the PCRD with link ID %d has a duplicate match in the MRW",
                        l_i2cDev->hdatI2cLinkId);
                    /*@
                     * @errortype
                     * @reasoncode   RUNTIME::RC_I2C_DEVICE_DUPLICATE_IN_MRW
                     * @moduleid     RUNTIME::MOD_POPULATE_TPMINFOBYNODE
                     * @severity     ERRL_SEV_INFORMATIONAL
                     * @userdata1    I2C Link ID
                     * @devdesc      An I2C device in the PCRD has a duplicate
                     *               match in the MRW. Physical presence
                     *               detection will still be available.
                     * @custdesc     Platform security problem detected
                     */
                    auto err = new ERRORLOG::ErrlEntry(
                        ERRORLOG::ERRL_SEV_INFORMATIONAL,
                        RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                        RUNTIME::RC_I2C_DEVICE_DUPLICATE_IN_MRW,
                        l_i2cDev->hdatI2cLinkId,
                        0,
                        true);
                    err->collectTrace(RUNTIME_COMP_NAME);
                    ERRORLOG::errlCommit(err, RUNTIME_COMP_ID);
                }
                else // found a match
                {
                    *l_pLinkId = l_i2cDev->hdatI2cLinkId;
                    l_i2cTargetList.erase(itr);
                }
            }

        } // for each link ID in the current PCRD instance

    } // for each instance
    if (l_elog)
    {
        break;
    }

    if (!l_i2cTargetList.empty())
    {
        for (auto i2cDev : l_i2cTargetList)
        {
            TRACFCOMP(g_trac_runtime,
                "populate_TpmInfoByNode: I2c device in the MRW was not found in the PCRD having engine: 0x%X masterport: 0x%X devicetype: 0x%X address: 0x%X slaveport: 0x%X devicepurpose: 0x%X master HUID: %X",
                i2cDev.engine,
                i2cDev.masterPort,
                i2cDev.deviceType,
                i2cDev.addr,
                i2cDev.slavePort,
                i2cDev.devicePurpose,
                TARGETING::get_huid(i2cDev.masterChip));
           /*@
            * @errortype
            * @reasoncode   RUNTIME::RC_EXTRA_I2C_DEVICE_IN_MRW
            * @moduleid     RUNTIME::MOD_POPULATE_TPMINFOBYNODE
            * @severity     ERRL_SEV_UNRECOVERABLE
            * @userdata1    [0:7] I2C engine
            * @userdata1    [8:15] I2C masterPort
            * @userdata1    [16:23] I2C slave deviceType
            * @userdata1    [24:31] I2C slave address
            * @userdata1    [32:39] I2C slave port
            * @userdata1    [40:47] I2C device purpose
            * @userdata1    [48:63] Bus speed in KHz
            * @userdata2    master chip HUID
            * @devdesc      An I2C device in the MRW has no match
            *               in the PCRD.
            * @custdesc     Platform security problem detected
            */
            auto err = new ERRORLOG::ErrlEntry(
                ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                RUNTIME::MOD_POPULATE_TPMINFOBYNODE,
                RUNTIME::RC_EXTRA_I2C_DEVICE_IN_MRW,
                TWO_UINT32_TO_UINT64(
                    FOUR_UINT8_TO_UINT32(i2cDev.engine,
                                     i2cDev.masterPort,
                                     i2cDev.deviceType,
                                     i2cDev.addr),
                    TWO_UINT16_TO_UINT32(
                        TWO_UINT8_TO_UINT16(i2cDev.slavePort,
                                        i2cDev.devicePurpose),
                        i2cDev.busFreqKhz)
                ),
                TARGETING::get_huid(i2cDev.masterChip),
                true);
            err->collectTrace(RUNTIME_COMP_NAME);
            ERRORLOG::errlCommit(err, RUNTIME_COMP_ID);
        }
    }

    // advance the current offset to account for the physical
    // interaction mechanism info struct
    l_currOffset += sizeof(*l_physInter);

    // populate the second part of the pointer pair from earlier
    l_hdatTpmData->hdatPhysInter.hdatSize = l_currOffset - l_physInterStart;

    ////////////////////////////////////////////////////////////////////////////
    // Section Hash and Verification Function offsets array
    ////////////////////////////////////////////////////////////////////////////

    // Only add if SecureROM is available and valid.
    if (g_BlToHbDataManager.isValid())
    {
        // populate the first part of pointer pair from earlier to point here
        l_hdatTpmData->hdatHashVerifyFunc.hdatOffset = l_currOffset;

        // the following will be used to calculate the second part of pointer pair
        auto l_hdatHashVerifyStart = l_currOffset;

        // the current offset now corresponds to the hash and verification function
        // info array header
        auto const l_hdatHashVerifyFunc = reinterpret_cast<
                            HDAT::hdatHDIFDataArray_t*>(l_baseAddr + l_currOffset);

        // fill in the values for the Secure Boot TPM Info Array Header
        l_hdatHashVerifyFunc->hdatOffset = sizeof(*l_hdatHashVerifyFunc);

        // Assert the number of function types does not exceed the HDAT spec
        assert(SecRomFuncTypes.size() <= SB_FUNC_TYPES::MAX_TYPES, "Number entries per node exceeds HDAT spec");
        l_hdatHashVerifyFunc->hdatArrayCnt = SecRomFuncTypes.size();
        l_hdatHashVerifyFunc->hdatAllocSize = sizeof(HDAT::hdatHashVerifyFunc_t);
        l_hdatHashVerifyFunc->hdatActSize = sizeof(HDAT::hdatHashVerifyFunc_t);

        // advance current offset to after the Hash and Verification Function
        // offsets array header
        l_currOffset += sizeof(*l_hdatHashVerifyFunc);

        // Iterate through all function types available and obtain their current
        // version and offset
        for (auto const &funcType : SecRomFuncTypes)
        {
            auto l_hdatHashVerifyInfo =
                reinterpret_cast<HDAT::hdatHashVerifyFunc_t*>(l_baseAddr +
                                                              l_currOffset);

            // Set Function type
            l_hdatHashVerifyInfo->sbFuncType = funcType;

            // Get version of function currently selected
            l_hdatHashVerifyInfo->sbFuncVer =
                                         SECUREBOOT::getSecRomFuncVersion(funcType);

            // Set DbobID
            l_hdatHashVerifyInfo->dbobId = l_node->getAttr<
                                                      TARGETING::ATTR_ORDINAL_ID>();

            // Obtain function offset based on the current version
            l_hdatHashVerifyInfo->sbFuncOffset =
                                         SECUREBOOT::getSecRomFuncOffset(funcType);

            // advance the current offset and instance pointer
            l_currOffset += sizeof(*l_hdatHashVerifyInfo);
        }

        // populate the second part of the pointer pair from earlier
        l_hdatTpmData->hdatHashVerifyFunc.hdatSize = l_currOffset -
                                                     l_hdatHashVerifyStart;
    }
    else
    {
        // SecureROM not available or valid set pointer pair to 0's
        l_hdatTpmData->hdatHashVerifyFunc.hdatOffset = 0;
        l_hdatTpmData->hdatHashVerifyFunc.hdatSize = 0;
    }

    // set the total structure length to the current offset
    l_hdatTpmData->hdatHdr.hdatSize = l_currOffset;

    } while (0);

    return (l_elog);
}

errlHndl_t populate_hbTpmInfo()
{
    errlHndl_t l_elog = nullptr;

    do {

        TRACFCOMP(g_trac_runtime, "Running populate_hbTpmInfo");

        TARGETING::Target* sys = nullptr;
        TARGETING::targetService().getTopLevelTarget( sys );
        assert(sys != nullptr,
            "populate_hbTpmInfo: Bug! Could not obtain top level target");

        // This attribute is only set on a multi-node system.
        // We will use it below to detect a multi-node scenario
        auto hb_images = sys->getAttr<TARGETING::ATTR_HB_EXISTING_IMAGE>();

        // if single node system
        if (!hb_images)
        {
            TRACDCOMP( g_trac_runtime, "populate_hbTpmInfo: Single node system");
            l_elog = populate_TpmInfoByNode(0); // 0 for single node
            if(l_elog != nullptr)
            {
                TRACFCOMP( g_trac_runtime, "populate_hbTpmInfo: "
                    "populate_TpmInfoByNode failed" );
            }
            break;
        }
        // multinode system / grab payload base to give to the nodes
        uint64_t payloadBase = sys->getAttr<TARGETING::ATTR_PAYLOAD_BASE>();

        // get the node id for the master chip
        const auto l_masterNode = TARGETING::UTIL::getCurrentNodePhysId();


        // start the 1 in the mask at leftmost position
        decltype(hb_images) l_mask = 0x1 << (sizeof(hb_images)*BITS_PER_BYTE-1);

        TRACDCOMP( g_trac_runtime, "populate_hbTpmInfo: l_mask 0x%.16llX hb_images 0x%.16llX",l_mask,hb_images);

        // start at node 0, iterates thru all nodes in blueprint
        uint32_t l_node = 0;

        // As the master node we assign instances to each node for them to
        // write their HDAT TPM instance info to.
        // start node instance at 0, counts only present/functional nodes
        uint32_t l_instance = 0;

        // create a message queue for receipt of responses from nodes
        msg_q_t msgQ = msg_q_create();
        l_elog = MBOX::msgq_register(MBOX::HB_POP_TPM_INFO_MSGQ, msgQ);

        if(l_elog)
        {
            TRACFCOMP( g_trac_runtime, "populate_hbTpmInfo: MBOX::msgq_register failed!" );
            break;
        }

        // keep track of the number of messages we send so we know how
        // many responses to expect
        int msg_count = 0;

        // while the one in the mask hasn't shifted out
        while (l_mask)
        {
            // if this node is present
            if(l_mask & hb_images)
            {
                TRACFCOMP( g_trac_runtime, "populate_hbTpmInfo: "
                    "MsgToNode (instance) %d for HBRT TPM Info",
                           l_node );

                // Send message to the current node
                msg_t* msg = msg_allocate();
                msg->type = IPC::IPC_POPULATE_TPM_INFO_BY_NODE;
                msg->data[0] = l_instance;   // instance number
                msg->data[1] = l_masterNode; // respond to this node
                msg->extra_data = reinterpret_cast<uint64_t*>(payloadBase);

                l_elog = MBOX::send(MBOX::HB_IPC_MSGQ, msg, l_node);

                if (l_elog)
                {
                    TRACFCOMP( g_trac_runtime, "MBOX::send to node %d from node %d failed",
                               l_node, l_masterNode);
                    msg_free(msg);
                    break;
                }
                msg_count++;
                l_instance++;
            }
            l_mask >>= 1; // shift to the right for the next node
            l_node++; // go to the next node
        }

        if (l_elog == nullptr)
        {
            msg_t* l_response = nullptr;
            // TODO RTC:189356 - need timeout here
            while (msg_count)
            {
                l_response = msg_wait(msgQ);
                TRACFCOMP(g_trac_runtime,
                    "populate_hbTpmInfo: drawer %d completed",
                    l_response->data[0]);
                msg_free(l_response);
                msg_count--;
            }
        }

        MBOX::msgq_unregister(MBOX::HB_POP_TPM_INFO_MSGQ);
        msg_q_destroy(msgQ);

    } while(0);

    return (l_elog);
} // end populate_hbTpmInfo

//******************************************************************************
//sendSBEsystemConfig_timer function
//Used inside the sendSBEsystemConfig() to wait for responses from other nodes
//******************************************************************************
void* sendSBEsystemConfig_timer(void* i_msgQPtr)

{
    int rc=0;

    msg_t* msg = msg_allocate();
    msg->type = HB_SBE_SYSCONFIG_TIMER_MSG;
    uint32_t l_time_ms =0;

    msg_q_t* msgQ = static_cast<msg_q_t*>(i_msgQPtr);


    //this loop will be broken when the main thread receives
    //all the messages and the timer thread receives the
    //HB_SBE_MSG_DONE message

    do
    {
        if (l_time_ms < MAX_TIME_ALLOWED_MS)
        {
            msg->data[1] = CONTINUE_WAIT_FOR_MSGS;
        }
        else
        {
            // HB_SBE_SYSCONFIG_TIMER_MSG is sent to the main thread indicating
            // timer expired so the main thread responds back with HB_SBE_MSG_DONE
            // indicating the timer is not needed and exit the loop
            msg->data[1]=TIME_EXPIRED;
        }

        rc= msg_sendrecv(*msgQ, msg);
        if (rc)
        {
            TRACFCOMP( g_trac_runtime,
                        "sendSBEsystemConfig timer failed msg sendrecv %d",rc);
        }
        if (msg->data[1] == HB_SBE_MSG_DONE)
        {
            TRACFCOMP( g_trac_runtime,
                        "sendSBEsystemConfig timer not needed.");
            break;
        }

        nanosleep(0,NS_PER_MSEC);
        l_time_ms++;

    }while(1);

    msg_free(msg);

    return NULL;
}

//******************************************************************************
//collectRespFromAllDrawers function
//Used inside the sendSBEsystemConfig() to wait and collect responses from
//all other drawers
//******************************************************************************
errlHndl_t collectRespFromAllDrawers( void* i_msgQPtr, uint64_t i_msgCount,
                                      uint32_t i_msgType,
                                      uint64_t& i_systemFabricConfigurationMap )
{
    errlHndl_t  l_elog = nullptr;
    uint64_t msg_count = i_msgCount;
    msg_q_t* msgQ = static_cast<msg_q_t*>(i_msgQPtr);

    //wait for all hb images to respond
    //want to spawn a timer thread
    tid_t l_progTid = task_create(
               RUNTIME::sendSBEsystemConfig_timer,msgQ);
    assert( l_progTid > 0 ,"sendSBEsystemConfig_timer failed");
    while(msg_count)
    {
        msg_t* response = msg_wait(*msgQ);

        if (response->type == HB_SBE_SYSCONFIG_TIMER_MSG)
        {
            if (response->data[1] == TIME_EXPIRED)
            {
                //timer has expired
                TRACFCOMP( g_trac_runtime,
                        "collectRespFromAllDrawers failed to "
                        "receive messages from all hb images in time" );
                //tell the timer thread to exit
                response->data[1] = HB_SBE_MSG_DONE;
                msg_respond(*msgQ,response);

                //generate an errorlog
                /*@
                 *  @errortype      ERRL_SEV_CRITICAL_SYS_TERM
                 *  @moduleid       RUNTIME::MOD_SEND_SBE_SYSCONFIG,
                 *  @reasoncode     RUNTIME::RC_SEND_SBE_TIMER_EXPIRED,
                 *  @userdata1      Message Type IPC_QUERY_CHIPINFO or
                 *                               IPC_SET_SBE_CHIPINFO
                 *  @userdata2      Number of nodes that have not
                 *                  responded
                 *
                 *  @devdesc        messages from other nodes have
                 *                  not returned in time
                 */
                l_elog = new ERRORLOG::ErrlEntry(
                                ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
                                RUNTIME::MOD_SEND_SBE_SYSCONFIG,
                                RUNTIME::RC_SEND_SBE_TIMER_EXPIRED,
                                i_msgType,
                                msg_count   );
                l_elog->collectTrace(RUNTIME_COMP_NAME);
                l_elog->collectTrace("IPC");
                l_elog->collectTrace("MBOXMSG");
                //Commit the Error log
                errlCommit(l_elog,RUNTIME_COMP_ID);
                // Break the While loop and wait for the child thread to exit
                break;

            }
            else if( response->data[1] == CONTINUE_WAIT_FOR_MSGS)
            {
                TRACFCOMP( g_trac_runtime,
                    "collectRespFromAllDrawers timer continue waiting message.");
                response->data[1] =HB_SBE_WAITING_FOR_MSG;
                msg_respond(*msgQ,response);
            }
        }
        else if (response->type == IPC::IPC_QUERY_CHIPINFO)
        {
            uint64_t l_nodeInfo =
                  reinterpret_cast<uint64_t>(response->extra_data);


            //Process msg, if we are waiting for IPC_QUERY_CHIPINFO response.
            if (i_msgType == IPC::IPC_QUERY_CHIPINFO)
            {
                TRACFCOMP(g_trac_runtime,
                    "IPC_QUERY_CHIPINFO : drawer %d completed info 0x%lx",
                    response->data[0], l_nodeInfo);
                //Apend the nodeInfo to be used in sendSBESystemConfig
                i_systemFabricConfigurationMap |= l_nodeInfo;
                --msg_count;
            }
            else
            {
                TRACFCOMP(g_trac_runtime,
                    "IPC_QUERY_CHIPINFO : unexpected message from drawer %d ",
                    response->data[0]);
            }

            msg_free(response);

        }
        else if (response->type == IPC::IPC_SET_SBE_CHIPINFO)
        {
            //Process msg, if we are waiting for IPC_SET_SBE_CHIPINFO response.
            if (i_msgType == IPC::IPC_SET_SBE_CHIPINFO)
            {
                TRACFCOMP(g_trac_runtime,
                  "IPC_SET_SBE_CHIPINFO : drawer %d completed",
                  response->data[0]);
                --msg_count;
            }
            else
            {
                TRACFCOMP(g_trac_runtime,
                    "IPC_SET_SBE_CHIPINFO : unexpected message from drawer %d ",
                    response->data[0]);
            }

            msg_free(response);
        }
    }

    //the msg_count should be 0 at this point to have
    //exited from the loop above.  If the msg count
    //is not zero then the timer must have expired
    //and the code would have asserted
    //Now need to tell the child timer thread to exit

    //tell the child timer thread to exit if didn't
    //already timeout
    if (msg_count ==0)
    {
        msg_t* response = msg_wait(*msgQ);
        if (response->type == HB_SBE_SYSCONFIG_TIMER_MSG)
        {
            TRACFCOMP( g_trac_runtime,
                    "collectRespFromAllDrawers received all hb "
                    "images in time for message type %d",i_msgType);

            response->data[1] = HB_SBE_MSG_DONE;
            msg_respond(*msgQ,response);
        }
    }

    //wait for the child thread to end
    int l_childsts =0;
    void* l_childrc = NULL;
    tid_t l_tidretrc = task_wait_tid(l_progTid,&l_childsts,&l_childrc);
    if ((static_cast<int16_t>(l_tidretrc) < 0)
        || (l_childsts != TASK_STATUS_EXITED_CLEAN ))
    {
        // the launched task failed or crashed,
        TRACFCOMP( g_trac_runtime,
            "task_wait_tid failed; l_tidretrc=0x%x, l_childsts=0x%x",
            l_tidretrc, l_childsts);

                //generate an errorlog
                /*@
                 *  @errortype      ERRL_SEV_CRITICAL_SYS_TERM
                 *  @moduleid       RUNTIME::MOD_SEND_SBE_SYSCONFIG,
                 *  @reasoncode     RUNTIME::RC_HOST_TIMER_THREAD_FAIL,,
                 *  @userdata1      l_tidretrc,
                 *  @userdata2      l_childsts,
                 *
                 *  @devdesc        sendSBESystemConfig timer thread
                 *                  failed
                 */
                l_elog = new ERRORLOG::ErrlEntry(
                                ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
                                RUNTIME::MOD_SEND_SBE_SYSCONFIG,
                                RUNTIME::RC_HOST_TIMER_THREAD_FAIL,
                                l_tidretrc,
                                l_childsts);

                l_elog->collectTrace(RUNTIME_COMP_NAME);
                return l_elog;
    }

    return(l_elog);

}
// Sends the chip config down to the SBEs
// Determines the system wide chip information to send to
// the SBE so it knows which chips are present for syncing with in MPIPL.
// Uses IPC to communication between HB instances if multinode
errlHndl_t sendSBESystemConfig( void )
{
    errlHndl_t  l_elog = nullptr;
    uint64_t l_systemFabricConfigurationMap = 0x0;
    const uint64_t l_u64_1  = 0x0000000000000001;
    const uint64_t l_u64_63 = 0x000000000000003F;

    do {

        TARGETING::Target * sys = nullptr;
        TARGETING::targetService().getTopLevelTarget( sys );
        assert(sys != nullptr);

        // Figure out which node we are running on
        TARGETING::Target* mproc = nullptr;
        TARGETING::targetService().masterProcChipTargetHandle(mproc);
        TARGETING::EntityPath epath = mproc->getAttr<TARGETING::ATTR_PHYS_PATH>();
        const TARGETING::EntityPath::PathElement pe =
          epath.pathElementOfType(TARGETING::TYPE_NODE);
        uint64_t nodeid = pe.instance;


        //Determine this HB Instance SBE config.
        TARGETING::TargetHandleList l_procChips;
        getAllChips( l_procChips, TARGETING::TYPE_PROC , true);
        for(auto l_proc : l_procChips)
        {
            // Get fabric info from proc
            uint8_t l_fabricTopoId =
              l_proc->getAttr<TARGETING::ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID>();

            // Take topology ID X and set the Xth bit in a 16 bit integer
            // and shift it over by 48 bits to fit 64 bits
            // Math turns out to be shifting left by 63 - topology id
            uint64_t tmp = l_fabricTopoId;

            l_systemFabricConfigurationMap |= (l_u64_1 << (l_u64_63 - tmp));

            TRACDCOMP( g_trac_runtime,"sendSBESystemConfig: proc 0x%.08X: "
                       "l_fabricTopoId=0x%.02X, l_systemFabricConfigurationMap=0x%.16llX",
                       TARGETING::get_huid(l_proc), l_fabricTopoId, l_systemFabricConfigurationMap);
        }

        // ATTR_HB_EXISTING_IMAGE only gets set on a multi-drawer system.
        // Currently set up in host_sys_fab_iovalid_processing() which only
        // gets called if there are multiple physical nodes.   It eventually
        // needs to be setup by a hb routine that snoops for multiple nodes.
        TARGETING::ATTR_HB_EXISTING_IMAGE_type hb_images =
          sys->getAttr<TARGETING::ATTR_HB_EXISTING_IMAGE>();
        TRACFCOMP( g_trac_runtime, "hb_images = 0x%x, nodeid = 0x%x", hb_images, nodeid);

        if (0 != hb_images)  //Multi-node
        {

            // multi-node system
            // This msgQ catches the node responses from the commands
            msg_q_t msgQ = msg_q_create();
            l_elog = MBOX::msgq_register(MBOX::HB_SBE_SYSCONFIG_MSGQ,msgQ);
            if(l_elog)
            {
                TRACFCOMP( g_trac_runtime, "MBOX::msgq_register failed!" );
                break;
            }

            // keep track of the number of messages we send so we
            // know how many responses to expect
            uint64_t msg_count = 0;

            // loop thru rest all nodes -- sending msg to each
            TARGETING::ATTR_HB_EXISTING_IMAGE_type mask = 0x1 <<
              ((sizeof(TARGETING::ATTR_HB_EXISTING_IMAGE_type) * 8) -1);
            for (uint64_t l_node=0; (l_node < MAX_NODES_PER_SYS); l_node++ )
            {
                // skip sending to ourselves, we did our construction above
                if(l_node == nodeid)
                    continue;

                if( 0 != ((mask >> l_node) & hb_images ) )
                {
                    TRACFCOMP( g_trac_runtime, "send IPC_QUERY_CHIPINFO "
                               "message to node %d",l_node );

                    msg_t * msg = msg_allocate();
                    msg->type = IPC::IPC_QUERY_CHIPINFO;
                    msg->data[0] = l_node;      // destination node
                    msg->data[1] = nodeid;      // respond to this node

                    // send the message to the slave hb instance
                    l_elog = MBOX::send(MBOX::HB_IPC_MSGQ, msg, l_node);
                    if( l_elog )
                    {
                        TRACFCOMP( g_trac_runtime, "MBOX::send to node %d"
                                   " failed", l_node);
                        break;
                    }

                    ++msg_count;

                } // end if node to process
            } // end for loop on nodes

            // wait for a response to each message we sent
            if( l_elog == nullptr )
            {
                l_elog = collectRespFromAllDrawers( &msgQ, msg_count, IPC::IPC_QUERY_CHIPINFO, l_systemFabricConfigurationMap);
            }

            //////////////////////////////////////////////////////////////////////
            // Now send each HB instance the full info to write to the SBEs
            ////////////////////////////
            if( l_elog == nullptr )
            {
                msg_count = 0;
                for (uint64_t l_node=0; (l_node < MAX_NODES_PER_SYS); l_node++ )
                {
                    // skip sending to ourselves, we will do our set below
                    if(l_node == nodeid)
                        continue;

                    if( 0 != ((mask >> l_node) & hb_images ) )
                    {
                        TRACFCOMP( g_trac_runtime, "send IPC_SET_SBE_CHIPINFO "
                                   "message to node %d",l_node );

                        msg_t * msg = msg_allocate();
                        msg->type = IPC::IPC_SET_SBE_CHIPINFO;
                        msg->data[0] = l_node;      // destination node
                        msg->data[1] = nodeid;      // respond to this node
                        msg->extra_data = reinterpret_cast<uint64_t*>(l_systemFabricConfigurationMap);

                        // send the message to the slave hb instance
                        l_elog = MBOX::send(MBOX::HB_IPC_MSGQ, msg, l_node);
                        if( l_elog )
                        {
                            TRACFCOMP( g_trac_runtime, "MBOX::send to node %d"
                                       " failed", l_node);
                            break;
                        }

                        ++msg_count;

                    } // end if node to process
                } // end for loop on nodes
            }

            // wait for a response to each message we sent
            if( l_elog == nullptr )
            {
                l_elog = collectRespFromAllDrawers( &msgQ, msg_count, IPC::IPC_SET_SBE_CHIPINFO, l_systemFabricConfigurationMap);
            }

            MBOX::msgq_unregister(MBOX::HB_SBE_SYSCONFIG_MSGQ);
            msg_q_destroy(msgQ);
        }

        //Now do this HB instance
        if( l_elog == nullptr )
        {
            for(auto l_proc : l_procChips)
            {
                TRACDCOMP( g_trac_runtime,
                           "calling sendSystemConfig on proc 0x%.08X: "
                           "l_systemFabricConfigurationMap=0x%.16llX",
                           TARGETING::get_huid(l_proc), l_systemFabricConfigurationMap);
                l_elog = SBEIO::sendSystemConfig(l_systemFabricConfigurationMap,
                                                l_proc);
                if ( l_elog )
                {
                    TRACFCOMP( g_trac_runtime,
                               "sendSystemConfig ERROR : Error sending sbe chip-op to proc 0x%.8X. Returning errorlog, reason=0x%x",
                               TARGETING::get_huid(l_proc),
                               l_elog->reasonCode() );
                    break;
                }
            }

            // Push out the Topology ID Table
            l_elog = SBEIO::psuSendTopologyIdTable();
            if( l_elog )
            {
                break;
            }
        }

    } while(0);

    return(l_elog);

} // end sendSBESystemConfig


// populate the hostboot runtime data section for the system
// will send msg to slave nodes in multinode system
errlHndl_t populate_hbRuntimeData( void )
{
    errlHndl_t  l_elog = nullptr;

    do {
        TRACFCOMP(g_trac_runtime, "Running populate_hbRuntimeData");

        // Figure out which node we are running on
        TARGETING::Target* mproc = nullptr;
        TARGETING::targetService().masterProcChipTargetHandle(mproc);

        TARGETING::EntityPath epath =
            mproc->getAttr<TARGETING::ATTR_PHYS_PATH>();

        const TARGETING::EntityPath::PathElement pe =
            epath.pathElementOfType(TARGETING::TYPE_NODE);

        uint64_t l_masterNodeId = pe.instance;

        TRACFCOMP( g_trac_runtime, "Master node nodeid = %x",
                   l_masterNodeId);

        // ATTR_HB_EXISTING_IMAGE only gets set on a multi-drawer system.
        // Currently set up in host_sys_fab_iovalid_processing() which only
        // gets called if there are multiple physical nodes.   It eventually
        // needs to be setup by a hb routine that snoops for multiple nodes.
        TARGETING::Target * sys = nullptr;
        TARGETING::targetService().getTopLevelTarget( sys );
        assert(sys != nullptr);

        TARGETING::ATTR_HB_EXISTING_IMAGE_type hb_images =
            sys->getAttr<TARGETING::ATTR_HB_EXISTING_IMAGE>();

        TRACFCOMP( g_trac_runtime, "ATTR_HB_EXISTING_IMAGE (hb_images) = %x",
                hb_images);

        if (0 == hb_images)  //Single-node
        {
            if( !TARGETING::is_no_load() )
            {
                l_elog = populate_HbRsvMem(l_masterNodeId,true);
                if(l_elog != nullptr)
                {
                    TRACFCOMP( g_trac_runtime, "populate_HbRsvMem failed" );
                }
            }
            else
            {
                // still fill in all of the reserved memory that we need for
                //  runtime testcases using the same space we reserve in
                //  PHYP mode, but skip all of the HDAT manipulation
                l_elog = populate_HbRsvMem(l_masterNodeId,true,true);
                if(l_elog != nullptr)
                {
                    TRACFCOMP( g_trac_runtime, "populate_HbRsvMem failed" );
                    break;
                }
            }
        }
        else
        {
            // multi-node system
            uint64_t payloadBase = sys->getAttr<TARGETING::ATTR_PAYLOAD_BASE>();

            // populate our own node specific data + the common stuff
            l_elog = populate_HbRsvMem(l_masterNodeId,true);

            if(l_elog != nullptr)
            {
                TRACFCOMP( g_trac_runtime, "populate_HbRsvMem failed" );
                break;
            }

            // This msgQ catches the node responses from the commands
            msg_q_t msgQ = msg_q_create();
            l_elog = MBOX::msgq_register(MBOX::HB_POP_ATTR_MSGQ,msgQ);

            if(l_elog)
            {
                TRACFCOMP( g_trac_runtime, "MBOX::msgq_register failed!" );
                break;
            }

            // keep track of the number of messages we send so we
            // know how many responses to expect
            uint64_t msg_count = 0;

            // loop thru rest all nodes -- sending msg to each
            TARGETING::ATTR_HB_EXISTING_IMAGE_type mask = 0x1 <<
                ((sizeof(TARGETING::ATTR_HB_EXISTING_IMAGE_type) * 8) -1);

            TRACFCOMP( g_trac_runtime, "HB_EXISTING_IMAGE (mask) = %x",
                    mask);

            for (uint64_t l_node=0; (l_node < MAX_NODES_PER_SYS); l_node++ )
            {
                // skip sending to ourselves, we did our construction above
                if(l_node == l_masterNodeId)
                    continue;

                if( 0 != ((mask >> l_node) & hb_images ) )
                {
                    TRACFCOMP( g_trac_runtime, "send IPC_POPULATE_ATTRIBUTES "
                            "message to node %d",
                            l_node );

                    msg_t * msg = msg_allocate();
                    msg->type = IPC::IPC_POPULATE_ATTRIBUTES;
                    msg->data[0] = l_node;      // destination node
                    msg->data[1] = l_masterNodeId; // respond to this node
                    msg->extra_data = reinterpret_cast<uint64_t*>(payloadBase);

                    // send the message to the slave hb instance
                    l_elog = MBOX::send(MBOX::HB_IPC_MSGQ, msg, l_node);

                    if( l_elog )
                    {
                        TRACFCOMP( g_trac_runtime, "MBOX::send to node %d"
                                " failed", l_node);
                        break;
                    }

                    ++msg_count;

                } // end if node to process
            } // end for loop on nodes

            // wait for a response to each message we sent
            if( l_elog == nullptr )
            {
                //$TODO RTC:189356 - need timeout here
                while(msg_count)
                {
                    msg_t * response = msg_wait(msgQ);
                    TRACFCOMP(g_trac_runtime,
                            "IPC_POPULATE_ATTRIBUTES : drawer %d completed",
                            response->data[0]);
                    msg_free(response);
                    --msg_count;
                }
            }

            MBOX::msgq_unregister(MBOX::HB_POP_ATTR_MSGQ);
            msg_q_destroy(msgQ);
        }

    } while(0);

    return(l_elog);

} // end populate_hbRuntimeData


errlHndl_t persistent_rwAttrRuntimeCheck( void )
{
    errlHndl_t l_err = nullptr;
    // For security purposes make R/W attribute memory pages non-ejectable
    // and of these, verify the persistent attributes. If all goes well,
    // we can hand these over to runtime with added confidence of their
    // validity, otherwise we stop the IPL.
    msg_q_t l_msgQ = msg_q_resolve(TARGETING::ATTRRP_MSG_Q);

    assert(l_msgQ != nullptr, "Bug! Message queue did not resolve properly!");

    msg_t* l_msg = msg_allocate();

    assert(l_msg != nullptr, "Bug! Message allocation failed!");

    l_msg->type = TARGETING::AttrRP::MSG_MM_RP_RUNTIME_PREP;

    l_msg->data[0] = TARGETING::AttrRP::MSG_MM_RP_RUNTIME_PREP_BEGIN;

    int rc = msg_sendrecv(l_msgQ, l_msg);

    if (rc != 0 || l_msg->data[1])
    {
        uint64_t l_rc = l_msg->data[1];

        TRACFCOMP( g_trac_runtime,
            "persistent_rwAttrRuntimeCheck: failed to pin attribute memory. "
            "Message rc: %llX msg_sendrecv rc:%i", l_rc, rc);

        /*@
         * @errortype
         * @reasoncode RUNTIME::RC_UNABLE_TO_PIN_ATTR_MEM
         * @moduleid   RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL
         * @userdata1  Message return code from message handler
         * @userdata2  Return code from msg_sendrecv function
         * @devdesc    Unable to pin read/write attribute memory
         * @custdesc   Internal system error occured
         */
        l_err = new ERRORLOG::ErrlEntry(
                        ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
                        RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL,
                        RUNTIME::RC_UNABLE_TO_PIN_ATTR_MEM,
                        l_rc,
                        rc,
                        true /* Add HB Software Callout */);
        l_err->collectTrace(RUNTIME_COMP_NAME);
    }
    else
    {
         TARGETING::TargetRangeFilter targets(
            TARGETING::targetService().begin(),
            TARGETING::targetService().end());
        for ( ; targets; ++targets)
        {
            validateAllRwNvAttr( *targets );
        }

        l_msg->type = TARGETING::AttrRP::MSG_MM_RP_RUNTIME_PREP;
        l_msg->data[0] = TARGETING::AttrRP::MSG_MM_RP_RUNTIME_PREP_END;

        int rc = msg_sendrecv(l_msgQ, l_msg);

        if (rc != 0 || l_msg->data[1])
        {
            uint64_t l_rc = l_msg->data[1];

            TRACFCOMP( g_trac_runtime, "persistent_rwAttrRuntimeCheck:"
                " failed to unpin attribute memory. "
                "Message rc: %llX msg_sendrecv rc:%i", l_rc, rc);

            /*@
             * @errortype
             * @reasoncode RUNTIME::RC_UNABLE_TO_UNPIN_ATTR_MEM
             * @moduleid   RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL
             * @userdata1  Message return code from message handler
             * @userdata2  Return code from msg_sendrecv function
             * @devdesc    Unable to unpin read/write attribute memory
             * @custdesc   Internal system error occured
             */
            l_err = new ERRORLOG::ErrlEntry(
                        ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
                        RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL,
                        RUNTIME::RC_UNABLE_TO_UNPIN_ATTR_MEM,
                        l_rc,
                        rc,
                        true /* Add HB Software Callout */);
            l_err->collectTrace(RUNTIME_COMP_NAME);
        }
    }

    // Always free the message since send/recv implies ownership
    msg_free(l_msg);
    l_msg=nullptr;

    return l_err;
} // end persistent_rwAttrRuntimeCheck

errlHndl_t openUntrustedSpCommArea(const uint64_t i_commBase)
{
    TRACFCOMP( g_trac_runtime, ENTER_MRK "openUntrustedSpCommArea()");
    errlHndl_t l_err = nullptr;

    do {
    TARGETING::Target * l_sys = nullptr;
    TARGETING::targetService().getTopLevelTarget(l_sys);
    assert(l_sys != nullptr, "openUntrustedSpCommArea: top level target nullptr");

    // Get Payload HRMOR
    uint64_t l_hrmor = l_sys->getAttr<TARGETING::ATTR_PAYLOAD_BASE>() * MEGABYTE;

    // pass 0 since there is only one record
    const uint64_t l_instance = 0;
    uint64_t l_cpuCtrlDataAddr = 0;
    size_t l_cpuCtrlDataSizeMax = 0;

    // Get the address of the Spira-H CPU control section
    l_err = RUNTIME::get_host_data_section( RUNTIME::CPU_CTRL,
                                            l_instance,
                                            l_cpuCtrlDataAddr,
                                            l_cpuCtrlDataSizeMax);
    if(l_err != nullptr)
    {
        TRACFCOMP( g_trac_runtime, ERR_MRK "openUntrustedSpCommArea(): get_host_data_section() failed for CPU_CTRL HDAT section");
        break;
    }

    // Traverse CPU Controls Header Area pointer to find CPU Controls Structure
    auto const l_pCpuCtrlHdr =
        reinterpret_cast<hdatHDIF_t*>(l_cpuCtrlDataAddr);
    auto const l_pCpuDataPointer =
        reinterpret_cast<hdatHDIFDataHdr_t*>(l_cpuCtrlDataAddr +
                                             l_pCpuCtrlHdr->hdatDataPtrOffset);
    auto const l_pCpuCtrlInfo =
        reinterpret_cast<hdatCpuCtrlInfo_t*>(l_cpuCtrlDataAddr +
                                             l_pCpuDataPointer->hdatOffset);

    // Get Address of First SP ATTN area and size of both SP ATTN areas
    // Add HRMOR to address as it's relative to the HRMOR
    uint64_t l_spAttnStartAddr = l_pCpuCtrlInfo->spAttnArea1.address + l_hrmor;
    size_t l_spAttnCombinedSize = l_pCpuCtrlInfo->spAttnArea1.size +
                                  l_pCpuCtrlInfo->spAttnArea2.size;

    TRACFCOMP( g_trac_runtime, "openUntrustedSpCommArea() SP ATTN addr = 0x%016llx combined size 0x%X",
               l_spAttnStartAddr,
               l_spAttnCombinedSize);

    // If in phyp mode and the master then update SP ATTN area values in HDAT
    if (TARGETING::is_phyp_load() && TARGETING::UTIL::isCurrentMasterNode())
    {
        // make sure ATTN area never grows beyond the SP/PHyp untrusted region
        if (l_spAttnCombinedSize > SP_HOST_ATTN_SIZE_LIMIT)
        {
            TRACFCOMP( g_trac_runtime,
                       ERR_MRK"openUntrustedSpCommArea(): Combined sizes of SP ATTN area 1 and area 2 are larger than 0x%.16llX. ATTN1 sz: 0x%.16llX, ATTN2 sz: 0x%.16llX",
                       SP_HOST_ATTN_SIZE_LIMIT,
                       l_pCpuCtrlInfo->spAttnArea1.size,
                       l_pCpuCtrlInfo->spAttnArea2.size);

            /*@
             * @errortype
             * @moduleid        RUNTIME::MOD_OPEN_UNTRUSTED_SP_AREAS
             * @reasoncode      RUNTIME::RC_SP_ATTN_AREA_OVERFLOW
             * @userdata1       SP ATTN Area total size
             * @userdata2       SP ATTN Area start address
             * @devdesc         SP ATTN Areas attempting to allocate past valid
             *                  memory range.
             * @custdesc        Failure in the security subsystem.
             */
            l_err = new ERRORLOG::ErrlEntry(
                            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                            RUNTIME::MOD_OPEN_UNTRUSTED_SP_AREAS,
                            RUNTIME::RC_SP_ATTN_AREA_OVERFLOW,
                            l_spAttnCombinedSize,
                            l_spAttnStartAddr,
                            true);
            l_err->collectTrace(RUNTIME_COMP_NAME);
            break;
        }
        // Make sure our intended ATTN area 1 size is not smaller than the ATTN
        // area 1 size reported in HDAT
        if (PHYP_ATTN_AREA_1_SIZE < l_pCpuCtrlInfo->spAttnArea1.size)
        {
            TRACFCOMP( g_trac_runtime,
                       ERR_MRK"openUntrustedSpCommArea(): Hostboot's proposed SP ATTN area 1 size is smaller than what is reported in HDAT. Proposed ATTN1 sz: 0x%.16llX, HDAT ATTN1 sz: 0x%.16llX",
                       PHYP_ATTN_AREA_1_SIZE,
                       l_pCpuCtrlInfo->spAttnArea1.size);

            /*@
             * @errortype
             * @moduleid        RUNTIME::MOD_OPEN_UNTRUSTED_SP_AREAS
             * @reasoncode      RUNTIME::RC_SP_ATTN_AREA1_SIZE_OVERFLOW
             * @userdata1       SP ATTN Area 1 size proposed by hostboot
             * @userdata2       SP ATTN Area 1 size reported in HDAT
             * @devdesc         SP ATTN Area 1 size exceeds the maximum.
             * @custdesc        Failure in the security subsystem.
             */
            l_err = new ERRORLOG::ErrlEntry(
                            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                            RUNTIME::MOD_OPEN_UNTRUSTED_SP_AREAS,
                            RUNTIME::RC_SP_ATTN_AREA1_SIZE_OVERFLOW,
                            PHYP_ATTN_AREA_1_SIZE,
                            l_pCpuCtrlInfo->spAttnArea1.size,
                            true);
            l_err->collectTrace(RUNTIME_COMP_NAME);
            break;
        }

        // calculate absolute address for PHYP SP ATTN areas
        auto l_abs = RUNTIME::calcSpAttnAreaStart();

        l_pCpuCtrlInfo->spAttnArea1.address = l_abs;
        l_pCpuCtrlInfo->spAttnArea2.address = l_abs + PHYP_ATTN_AREA_1_SIZE;
    }

    // Open unsecure SBE memory regions
    // Loop through all functional Procs
    TARGETING::TargetHandleList l_procChips;
    getAllChips(l_procChips, TARGETING::TYPE_PROC);
    for (const auto & l_procChip : l_procChips)
    {
        // Get HUID of proc for trace
        auto l_id = TARGETING::get_huid(l_procChip);

        // Open SP ATTN region
        l_err = SBEIO::openUnsecureMemRegion(l_spAttnStartAddr,
                                             l_spAttnCombinedSize,
                                             true, //true=Read-Write
                                             l_procChip);
        if (l_err)
        {
            TRACFCOMP( g_trac_runtime, ERR_MRK "openUntrustedSpCommArea(): openUnsecureMemRegion() failed proc = 0x%X addr = 0x%016llx size = 0x%X",
                      l_id,
                      l_spAttnStartAddr,
                      l_spAttnCombinedSize);
            break;
        }

        // Only open additional SBE window in PHYP mode
        if(TARGETING::is_phyp_load())
        {
            l_err = SBEIO::openUnsecureMemRegion(
                                        i_commBase,
                                        RUNTIME::SP_HOST_UNTRUSTED_COMM_AREA_SIZE,
                                        true, //true=Read-Write
                                        l_procChip);
            if (l_err)
            {
                TRACFCOMP(g_trac_runtime, ERR_MRK "openUntrustedSpCommArea(): openUnsecureMemRegion() failed proc = 0x%X addr = 0x%016llx size = 0x%X",
                          l_id,
                          i_commBase,
                          RUNTIME::SP_HOST_UNTRUSTED_COMM_AREA_SIZE);
                break;
            }
        }

        // Open Unsecure Memory Region for SBE FFDC Section
        uint64_t l_sbeffdcAddr =
            l_procChip->getAttr<TARGETING::ATTR_SBE_FFDC_ADDR>();
        uint64_t l_sbeffdcSize =
            SBEIO::SbePsu::getTheInstance().getSbeFFDCBufferSize();

        // Open Unsecure Memory Region for SBE FFDC Section
        l_err = SBEIO::openUnsecureMemRegion(l_sbeffdcAddr,
                                             l_sbeffdcSize,
                                             false, //Read-Only
                                             l_procChip);
        if(l_err)
        {
            TRACFCOMP( g_trac_runtime, ERR_MRK "openUntrustedSpCommArea(): openUnsecureMemRegion() failed proc = 0x%X addr = 0x%016llx size = 0x%X",
                      l_id,
                      l_sbeffdcAddr,
                      l_sbeffdcSize);

            break;
        }

        if (TARGETING::is_sapphire_load())
        {
            // Open Unsecure Memory Region for OPAL trace
            l_err = SBEIO::openUnsecureMemRegion(
                                            SP_HOST_UNTRUSTED_OPAL_TRACE_ADDR,
                                            SP_HOST_UNTRUSTED_OPAL_TRACE_SIZE,
                                            false, //Read-Only
                                            l_procChip);
            if(l_err)
            {
                TRACFCOMP( g_trac_runtime, ERR_MRK "openUntrustedSpCommArea(): openUnsecureMemRegion() for OPAL trace failed proc = 0x%X addr = 0x%016llx size = 0x%X",
                      l_id,
                      SP_HOST_UNTRUSTED_OPAL_TRACE_ADDR,
                      SP_HOST_UNTRUSTED_OPAL_TRACE_SIZE);

                break;
            }
        }

        // Open Unsecure Memory Region for HBRT Rsvd Mem Trace Section
        uint64_t l_RsvdMemRtTraceAddr = 0;
        uint64_t l_RsvdMemRtTraceSize = 0;

        //get the HBRT Rsvd Mem Trace Section addr and size
        l_err = getRsvdMemTraceBuf(l_RsvdMemRtTraceAddr,l_RsvdMemRtTraceSize);

        if(l_err)
        {
            TRACFCOMP( g_trac_runtime, ERR_MRK "openUntrustedSpCommArea(): getRsvdMemTraceBuf() failed proc = 0x%X",
                  l_id);

            break;
        }

        if((l_RsvdMemRtTraceAddr != 0) && (l_RsvdMemRtTraceSize != 0))
        {
            // Open Unsecure Memory Region for HBRT Rsvd Mem Trace Section
            l_err = SBEIO::openUnsecureMemRegion(l_RsvdMemRtTraceAddr,
                                                 l_RsvdMemRtTraceSize,
                                                 false, //Read-Only
                                                 l_procChip);
            if(l_err)
            {
                TRACFCOMP( g_trac_runtime, ERR_MRK "openUntrustedSpCommArea(): openUnsecureMemRegion() failed proc = 0x%X addr = 0x%016llx size = 0x%X",
                          l_id,
                          l_RsvdMemRtTraceAddr,
                          l_RsvdMemRtTraceSize);

                break;
            }

        }

    }
    if(l_err)
    {
        break;
    }

    } while(0);

    TRACFCOMP( g_trac_runtime, EXIT_MRK"openUntrustedSpCommArea()");

    return l_err;
}

void setPayloadBaseAddress(uint64_t i_payloadAddress)
{
    TARGETING::Target * sys = NULL;
    TARGETING::targetService().getTopLevelTarget( sys );
    sys->setAttr<TARGETING::ATTR_PAYLOAD_BASE>(i_payloadAddress);
}

errlHndl_t getRsvdMemTraceBuf(uint64_t& o_RsvdMemAddress, uint64_t& o_size)
{
    errlHndl_t l_elog = nullptr;

    uint64_t l_rsvMemDataAddr = 0;
    uint64_t l_rsvMemDataSize = 0;
    hdatMsVpdRhbAddrRange_t* l_rngPtr = nullptr;
    Util::hbrtTableOfContents_t * l_hbTOC = nullptr;

    do{
        // We have only one HBRT_MEM_LABEL_TRACEBUF section across the system.
        // Loop through all RESERVED_MEM sections in the system (of all nodes),
        // and find out the section with label HBRT_MEM_LABEL_TRACEBUF
        uint64_t l_StartInstance = 0;  //start from 0
        uint64_t l_EndInstance = 0;

        l_elog = RUNTIME::get_instance_count(RUNTIME::RESERVED_MEM,l_EndInstance);
        if(l_elog != nullptr)
        {
            TRACFCOMP( g_trac_runtime,
                        "getRsvdMemTraceBuf() fail get_instance_count");
            break;
        }


        for (uint64_t l_instance = l_StartInstance ; l_instance < l_EndInstance; l_instance++)
        {

            // Get the address of the section
            l_elog = RUNTIME::get_host_data_section( RUNTIME::RESERVED_MEM,
                    l_instance,
                    l_rsvMemDataAddr,
                    l_rsvMemDataSize );
            if(l_elog != nullptr)
            {
                TRACFCOMP( g_trac_runtime,
                        "getRsvdMemTraceBuf fail get_host_data_section instance = %d",
                        l_instance);
                break;
            }

            l_rngPtr = reinterpret_cast<hdatMsVpdRhbAddrRange_t *>(l_rsvMemDataAddr);

            assert(l_rngPtr != nullptr, "get_host_data_section returned nullptr");

            const char* l_region = reinterpret_cast<const char *>(l_rngPtr->hdatRhbLabelString);

            if (strcmp(l_region,"HBRT_RSVD_MEM__DATA")== 0)
            {
                TRACFCOMP( g_trac_runtime,
                        "getRsvdMemTraceBuf() Found HBRT_RSVD_MEM__DATA section");

                 l_hbTOC = reinterpret_cast<Util::hbrtTableOfContents_t *>(
                            l_rngPtr->hdatRhbAddrRngStrAddr);
                o_RsvdMemAddress = Util::hb_find_rsvd_mem_label(Util::HBRT_MEM_LABEL_TRACEBUF,
                                                                         l_hbTOC,
                                                                         o_size);
                if((o_RsvdMemAddress != 0)  && (o_size != 0))
                {
                    TRACFCOMP( g_trac_runtime,
                            "getRsvdMemTraceBuf() Found HBRT_MEM_LABEL_TRACEBUF section 0x%016llx size = 0x%X",
                            o_RsvdMemAddress,o_size);
                    break;
                }
            }

        }

    }while(0);

    return l_elog;

}

errlHndl_t getPayloadAttnAreaAddr(uint64_t& o_payloadTiAddr)
{
    errlHndl_t l_errl = nullptr;
    TARGETING::Target* l_sys = TARGETING::UTIL::assertGetToplevelTarget();
    uint64_t l_payloadHrmor = l_sys->getAttr<TARGETING::ATTR_PAYLOAD_BASE>() *
                              MEGABYTE;
    const uint64_t l_instance = 0; // there is only one record
    uint64_t l_cpuCtrlDataAddr = 0;
    size_t l_cpuCtrlDataSizeMax = 0;

    do {
    l_errl = RUNTIME::get_host_data_section(RUNTIME::CPU_CTRL,
                                            l_instance,
                                            l_cpuCtrlDataAddr,
                                            l_cpuCtrlDataSizeMax);
    if(l_errl)
    {
        TRACFCOMP(g_trac_runtime, ERR_MRK"getPayloadAttnAreaAddr: could not get CPU_CTRL HDAT section!");
        break;
    }

    // calculate absolute address for PHYP SP ATTN area 1
    if(TARGETING::is_phyp_load())
    {
        o_payloadTiAddr = RUNTIME::calcSpAttnAreaStart();
        break;
    }

    // Fetch the SP ATTN area from HDAT for non-PHYP load
    // Traverse CPU Controls Header Area pointer to find CPU Controls Structure
    auto const l_pCpuCtrlHdr =
        reinterpret_cast<hdatHDIF_t*>(l_cpuCtrlDataAddr);
    auto const l_pCpuDataPointer =
        reinterpret_cast<hdatHDIFDataHdr_t*>(l_cpuCtrlDataAddr +
                                             l_pCpuCtrlHdr->hdatDataPtrOffset);
    auto const l_pCpuCtrlInfo =
        reinterpret_cast<hdatCpuCtrlInfo_t*>(l_cpuCtrlDataAddr +
                                             l_pCpuDataPointer->hdatOffset);

    // Get the address of the first SP ATTN. It is relative to HRMOR
    o_payloadTiAddr = l_pCpuCtrlInfo->spAttnArea1.address + l_payloadHrmor;

    }while(0);

    if(l_errl)
    {
        o_payloadTiAddr = 0;
    }

    TRACFCOMP(g_trac_runtime, "getPayloadAreaAddr SP ATTN addr = 0x%016llx",
              o_payloadTiAddr);
    return l_errl;
}

errlHndl_t verifyAndMovePayload(const bool i_payloadAlreadyVerified)
{
    TRACFCOMP( g_trac_runtime,
               ENTER_MRK"verifyAndMovePayload() i_payloadAlreadyVerified=%d", i_payloadAlreadyVerified);

    errlHndl_t l_err = nullptr;
    void * payload_tmp_virt_addr = nullptr;
    void * payloadBase_virt_addr = nullptr;
    void * hdat_tmp_virt_addr = nullptr;
    void * hdat_final_virt_addr = nullptr;

    enum Map_FailLocs_t {
        NO_MAP_FAIL             = 0x0,
        PAYLOAD_TMP_MAP_FAIL    = 0x1, // payload_tmp_virt_addr
        PAYLOAD_BASE_MAP_FAIL   = 0x2, // payloadBase_virt_addr
        HDAT_TMP_MAP_FAIL       = 0x3, // hdat_tmp_virt_addr
        HDAT_FINAL_MAP_FAIL     = 0x4, // hdat_final_virt_addr

        PAYLOAD_TMP_UNMAP_FAIL  = 0x5, // payload_tmp_virt_addr
        PAYLOAD_BASE_UNMAP_FAIL = 0x6, // payloadBase_virt_addr
        HDAT_TMP_UNMAP_FAIL     = 0x7, // hdat_tmp_virt_addr
        HDAT_FINAL_UNMAP_FAIL   = 0x8, // hdat_final_virt_addr
    };

    Map_FailLocs_t blockMapFail = NO_MAP_FAIL;

    // Make sure these constants are page-aligned, as they are used below for
    // mm_block_map:
    static_assert((MCL_TMP_ADDR % PAGESIZE) == 0, "verifyAndMovePayload() MCL_TMP_ADDR isn't page-aligned");
    static_assert((MCL_TMP_SIZE % PAGESIZE) == 0, "verifyAndMovePayload() MCL_TMP_SIZE isn't page-aligned");
    static_assert((HDAT_TMP_ADDR % PAGESIZE) == 0, "verifyAndMovePayload() HDAT_TMP_ADDR isn't page-aligned");

    do{

    if (TARGETING::is_sapphire_load() && !INITSERVICE::spBaseServicesEnabled())
    {
        // OPAL load on BMC, no need to verify and move
        break;
    }

    TARGETING::ATTR_PAYLOAD_KIND_type payload_kind =
      TARGETING::PAYLOAD_KIND_NONE;
    bool is_phyp = TARGETING::is_phyp_load(&payload_kind);

    // Only Supporting PHYP/POWERVM and SAPPHIRE/OPAL at this time
    // @TODO RTC 183831 in case we ever need to support Payload AVPS
    if( !(TARGETING::PAYLOAD_KIND_PHYP == payload_kind ) &&
        !(TARGETING::PAYLOAD_KIND_SAPPHIRE == payload_kind ) )
    {
        break;
    }

    // Setup componend IDs and strings
    const MCL::ComponentID l_compId = is_phyp ? MCL::g_PowervmCompId
                                              : MCL::g_OpalCompId;
    MCL::CompIdString l_IdStr = {};
    MCL::compIdToString(l_compId, l_IdStr);

    // Get Temporary Virtual Address To Payload
    // - Need to make Memory spaces HRMOR-relative
    uint64_t hostboot_base_addr = RUNTIME::getHbBaseAddrWithNodeOffset();
    uint64_t payload_tmp_phys_addr = hostboot_base_addr + MCL_TMP_ADDR;
    uint64_t payload_size          = MCL_TMP_SIZE;

    payload_tmp_virt_addr = mm_block_map(
                             reinterpret_cast<void*>(payload_tmp_phys_addr),
                             payload_size);

    // Check for nullptr being returned
    if (payload_tmp_virt_addr == nullptr)
    {
        blockMapFail = PAYLOAD_TMP_MAP_FAIL;
        TRACFCOMP( g_trac_runtime,
                   ERR_MRK"verifyAndMovePayload(): Fail to mm_block_map "
                   "payload_tmp_virt_addr (loc=0x%X)",
                   blockMapFail);
        // Error log created outside of do-while loop
        break;
    }

    TRACFCOMP( g_trac_runtime,"verifyAndMovePayload() "
               "Processing PAYLOAD_KIND = %d (Id='%s') (is_phyp=%d): "
               "physAddr=0x%.16llX, virtAddr=0x%.16llX",
               payload_kind, l_IdStr, is_phyp, payload_tmp_phys_addr,
               payload_tmp_virt_addr );


    // Parse Container Header
    SECUREBOOT::ContainerHeader l_conHdr;
    l_err = l_conHdr.setHeader(payload_tmp_virt_addr);
    if (l_err)
    {
        TRACFCOMP( g_trac_runtime,
                   ERR_MRK"verifyAndMovePayload(): Fail to parse container "
                   "header at payload_tmp_virt_addr = 0x%.16llX",
                   payload_tmp_virt_addr);
        break;
    }

    // If in Secure Mode Verify Payload at Temporary TCE-related Memory Location
    if (SECUREBOOT::enabled())
    {
        if(i_payloadAlreadyVerified)
        {
            TRACFCOMP(g_trac_runtime,"verifyAndMovePayload(): "
                      "Payload already verified, not verifying again");
        }
        else
        {
            TRACFCOMP( g_trac_runtime,"verifyAndMovePayload() "
                    "Verifying PAYLOAD: physAddr=0x%.16llX, virtAddr=0x%.16llX",
                    payload_tmp_phys_addr, payload_tmp_virt_addr );

            // Verify Container
            // payload_tmp_virt_addr is the hostboot MCL_TMP_ADDR space which is untouched
            // by the manageSingleComponent decompression data management
            l_err = SECUREBOOT::verifyContainer(payload_tmp_virt_addr);
            if (l_err)
            {
                TRACFCOMP( g_trac_runtime,
                    "verifyAndMovePayload(): failed verifyContainer");
                l_err->collectTrace("",256);
                SECUREBOOT::handleSecurebootFailure(l_err);
                assert(false,"Bug! handleSecurebootFailure shouldn't return!");
            }

            // Get PAYLOAD size from verified Header
            payload_size = l_conHdr.payloadTextSize() + PAGESIZE;
            assert(payload_size <= MCL_TMP_SIZE, "verifyAndMovePayload payload_size 0x%X must be <= MCL_TMP_SIZE (0x%X)", payload_size, MCL_TMP_SIZE );

            // Verify ASCII Component Id in the Secure Header matches expected value
            l_err = SECUREBOOT::verifyComponentId(l_conHdr, l_IdStr);
            if (l_err)
            {
                TRACFCOMP( g_trac_runtime,
                        ERR_MRK"verifyAndMovePayload(): Fail to verify component"
                        "Id %s in header at payload_tmp_virt_addr = 0x%.16llX",
                        l_IdStr, payload_tmp_virt_addr);
                break;
            }
        }
    }

    if(is_phyp)
    {
        MCL::MasterContainerLidMgr::cachePhypHeader(
            reinterpret_cast<uint8_t*>(payload_tmp_virt_addr));
    }

    // Extend PAYLOAD
    l_err = MCL::MasterContainerLidMgr::tpmExtend(l_compId, l_conHdr);
    if (l_err)
    {
        TRACFCOMP( g_trac_runtime,
                   ERR_MRK"verifyAndMovePayload(): Fail to tpmExend "
                   "Id %s in header at payload_tmp_virt_addr = 0x%.16llX",
                   l_IdStr, payload_tmp_virt_addr);
        break;
    }

    const auto sys = TARGETING::UTIL::assertGetToplevelTarget();

    // Move PAYLOAD to Final Location
    // Get Target Service, and the system target.
    uint64_t payloadBase = sys->getAttr<TARGETING::ATTR_PAYLOAD_BASE>();

    payloadBase = payloadBase * MEGABYTE;

    // Move virtual address past payload header for memcpy below
    payload_tmp_virt_addr = reinterpret_cast<void*>(
                              reinterpret_cast<uint64_t>(
                                payload_tmp_virt_addr) +
                                PAGESIZE);
    payload_size -= PAGESIZE;

    // Determine the size of the mapped area (mapSize) for PHYP + HDAT
    // Limit this to the minimum of either the LMB size or the VMM cap:
    // If LMB Size is < VMM cap, then use the LMB size
    // If LMB Size is >= VMM cap, then just use the VMM cap
    // Additionally, ensure that mapSize is at least equal to the payload_size
    const uint64_t lmb_size = getLMBSizeInMB() * MEGABYTE;
    const uint64_t lmbCapMb = VMM::BLOCK_MAP_CAP_MB;
    const uint64_t mapSize = std::max( std::min(lmb_size, lmbCapMb),
                                       payload_size);

    TRACFCOMP(g_trac_runtime,
              "verifyAndMovePayload(): mapSize=0x%.16llX, lmb_size=0x%.16llX, "
              "payload_size=0x%.16llX (lmbCapMb=0x%.16llX",
              mapSize, lmb_size, payload_size, lmbCapMb);


    payloadBase_virt_addr = mm_block_map(
                               reinterpret_cast<void*>(payloadBase),
                               mapSize);

    // Check for nullptr being returned
    if (payloadBase_virt_addr == nullptr)
    {
        blockMapFail = PAYLOAD_BASE_MAP_FAIL;
        TRACFCOMP( g_trac_runtime,
                   ERR_MRK"verifyAndMovePayload(): Fail to mm_block_map "
                   "payloadBase_virt_addr (loc=0x%X)",
                   blockMapFail);
        // Error log created outside of do-while loop
        break;
    }

    // For eBMC manageSingleComponent decompresses and moves PHYP lids
    // to PHYP mainstore in host_load_payload
    // So only move the PHYP PAYLOAD here if not eBMC

    if(INITSERVICE::spBaseServicesEnabled())
    {
        TRACFCOMP( g_trac_runtime,
                    "verifyAndMovePayload(): Copy PAYLOAD from 0x%.16llX (va="
                    "0x%llX) to PAYLOAD_BASE = 0x%.16llX (va=0x%llX), size=0x%llX",
                    payload_tmp_phys_addr, payload_tmp_virt_addr, payloadBase,
                    payloadBase_virt_addr, payload_size);

        memcpy (payloadBase_virt_addr,
                payload_tmp_virt_addr,
                payload_size);
    }
    else
    {
        TRACFCOMP(g_trac_runtime, "verifyAndMovePayload(): eBMC PAYLOAD moved previously");
    }

    // Do not zero out first LMB on MPIPL or it will mess up PHYP.
    // This is generally done to clean up after any memory encryption
    // enablement which is not done on the MPIPL path
    if (!sys->getAttr<TARGETING::ATTR_IS_MPIPL_HB>() && mapSize > payload_size)
    {
        const auto payloadBase_virt_addr_ptr = static_cast<uint8_t*>(payloadBase_virt_addr);

        TRACFCOMP(g_trac_runtime,
                  "verifyAndMovePayload(): Zeroing rest of mapped area of PAYLOAD from 0x%.16llX "
                  "(va=0x%llX) to 0x%.16llX (va=0x%llX)",
                  payloadBase + payload_size, payloadBase_virt_addr_ptr + payload_size,
                  payloadBase + mapSize, payloadBase_virt_addr_ptr + mapSize);

        memset(payloadBase_virt_addr_ptr + payload_size,
               0,
               mapSize - payload_size);
    }

    // No need to move HDAT on eBMC, since at the time of the execution of this
    // function, it would not have been built yet.
    if(!INITSERVICE::spBaseServicesEnabled())
    {
        break;
    }

    uint64_t payloadBase_va = reinterpret_cast<uint64_t>(payloadBase_virt_addr);

    // Move HDAT into its proper place after it was temporarily put into
    // HDAT_TMP_ADDR-relative-to-HRMOR (HDAT_TMP_SIZE) by the FSP via TCEs
    uint64_t hdat_tmp_phys_addr = hostboot_base_addr + HDAT_TMP_ADDR;

    hdat_tmp_virt_addr = mm_block_map(
                            reinterpret_cast<void*>(hdat_tmp_phys_addr),
                            HDAT_TMP_SIZE);

    // Check for nullptr being returned
    if (hdat_tmp_virt_addr == nullptr)
    {
        blockMapFail = HDAT_TMP_MAP_FAIL;
        TRACFCOMP( g_trac_runtime,
                   ERR_MRK"verifyAndMovePayload(): Fail to mm_block_map "
                   "hdat_tmp_virt_addr (loc=0x%X)",
                   blockMapFail);
        // Error log created outside of do-while loop
        break;
    }

    // Determine location and size of HDAT from NACA section of PAYLOAD
    uint64_t hdat_cpy_offset = 0;
    size_t   hdat_cpy_size   = 0;

    RUNTIME::findHdatLocation(payloadBase_va, hdat_cpy_offset, hdat_cpy_size);


    // Check that the size PAYLOAD allocated for HDAT is less than
    // temporary HDAT space
    if ( hdat_cpy_size > HDAT_TMP_SIZE)
    {
       TRACFCOMP( g_trac_runtime,ERR_MRK
                  "verifyAndMovePayload(): PAYLOAD's allocated HDAT size 0x%X "
                  "Exceeds Maximum Temporary HDAT Size 0x%X",
                  hdat_cpy_size, HDAT_TMP_SIZE);

        /*@
         * @errortype
         * @reasoncode       ISTEP::RC_HDAT_SIZE_CHECK_FAILED
         * @severity         ERRL_SEV_UNRECOVERABLE
         * @moduleid         MOD_VERIFY_AND_MOVE_PAYLOAD
         * @userdata1        Allocated HDAT size from PAYLOAD
         * @userdata2        Temporary HDAT size
         * @devdesc          PAYLOAD allocated more HDAT space than temporary
         *                   space that Hostboot uses
         * @custdesc         A problem occurred during the IPL
         *                   of the system.
         */
        l_err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                              MOD_VERIFY_AND_MOVE_PAYLOAD,
                              ISTEP::RC_HDAT_SIZE_CHECK_FAILED,
                              hdat_cpy_size,
                              HDAT_TMP_SIZE,
                              true /*Add HB SW Callout*/);
        l_err ->collectTrace("",256);
        break;
    }

    TRACFCOMP( g_trac_runtime,
               "verifyAndMovePayload(): hdat_copy_offset = 0x%X and size=0x%X",
               hdat_cpy_offset, hdat_cpy_size);

    hdat_final_virt_addr = mm_block_map(
                              reinterpret_cast<void*>(payloadBase +
                                                      hdat_cpy_offset),
                              hdat_cpy_size);

    // Check for nullptr being returned
    if (hdat_final_virt_addr == nullptr)
    {
        blockMapFail = HDAT_FINAL_MAP_FAIL;
        TRACFCOMP( g_trac_runtime,
                   ERR_MRK"verifyAndMovePayload(): Fail to mm_block_map "
                   "hdat_final_virt_addr (loc=0x%X)",
                   blockMapFail);
        // Error log created outside of do-while loop
        break;
    }

    TRACFCOMP( g_trac_runtime,
                "verifyAndMovePayload(): Copy HDAT from 0x%.16llX (va="
                "0x%llX) to HDAT_FINAL = 0x%.16llX (va=0x%llX), size=0x%llX",
                hdat_tmp_phys_addr, hdat_tmp_virt_addr,
                payloadBase+hdat_cpy_offset, hdat_final_virt_addr,
                hdat_cpy_size);

    memcpy(hdat_final_virt_addr,
           hdat_tmp_virt_addr,
           hdat_cpy_size);

    } while(0);

    // Handle Possible mm_block_map fails here
    if (blockMapFail != NO_MAP_FAIL)
    {
        // Trace done above. Just create error log here.

        /*@
         * @errortype
         * @reasoncode       ISTEP::RC_MM_MAP_ERR
         * @severity         ERRL_SEV_UNRECOVERABLE
         * @moduleid         MOD_VERIFY_AND_MOVE_PAYLOAD
         * @userdata1        Map Fail Location
         * @userdata2        <UNUSED>
         * @devdesc          mm_block_map failed and returned nullptr
         * @custdesc         A problem occurred during the IPL
         *                   of the system.
         */
        errlHndl_t map_err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                           MOD_VERIFY_AND_MOVE_PAYLOAD,
                                           ISTEP::RC_MM_MAP_ERR,
                                           blockMapFail,
                                           0x0,
                                           true /*Add HB SW Callout*/);
        map_err->collectTrace("",256);

        // if l_err already exists just commit this log; otherwise set to l_err
        if (l_err == nullptr)
        {
            l_err = map_err;
            map_err = nullptr;
        }
        else
        {
            errlCommit(map_err, ISTEP_COMP_ID);
        }
    }

    // Cleanup/Unmap Memory Blocks
    std::map<void*,Map_FailLocs_t> ptrs_to_unmap =
    {
        { payload_tmp_virt_addr, PAYLOAD_TMP_UNMAP_FAIL },
        { payloadBase_virt_addr, PAYLOAD_BASE_UNMAP_FAIL },
        { hdat_tmp_virt_addr,    HDAT_TMP_UNMAP_FAIL },
        { hdat_final_virt_addr,  HDAT_FINAL_UNMAP_FAIL },
    };

    for ( auto ptr : ptrs_to_unmap )
    {
        if (ptr.first == nullptr)
        {
            continue;
        }

        int rc = mm_block_unmap(ptr.first);

        if (rc != 0)
        {
            TRACFCOMP( g_trac_runtime,
                       ERR_MRK"verifyAndMovePayload(): Failed to unmap "
                       "0x%.16llX (loc=0x%X)",
                       ptr.first, ptr.second);

            /*@
             * @errortype
             * @reasoncode       ISTEP::RC_MM_UNMAP_ERR
             * @severity         ERRL_SEV_UNRECOVERABLE
             * @moduleid         MOD_VERIFY_AND_MOVE_PAYLOAD
             * @userdata1        Map Fail Location
             * @userdata2        Return code from mm_block_unmap
             * @devdesc          mm_block_unmap failed and returned nullptr
             * @custdesc         A problem occurred during the IPL
             *                   of the system.
             */
            errlHndl_t unmap_err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                 MOD_VERIFY_AND_MOVE_PAYLOAD,
                                                 ISTEP::RC_MM_UNMAP_ERR,
                                                 ptr.second,
                                                 rc,
                                                 true /*Add HB SW Callout*/);
            unmap_err->collectTrace("",256);

            // if l_err already exists just commit this log;
            // otherwise set to l_err
            if (l_err == nullptr)
            {
                l_err = unmap_err;
                unmap_err = nullptr;
            }
            else
            {
                errlCommit(unmap_err, ISTEP_COMP_ID);
            }
        }
    }

    TRACFCOMP( g_trac_runtime,
               EXIT_MRK"verifyAndMovePayload(): l_err rc = 0x%X",
               ERRL_GETRC_SAFE(l_err) );

    return l_err;
}

} //namespace RUNTIME
