
//
// Warning: don't edit - generated by generate_ecu_code.pl processing ../dev/nbtevo.json: NBT 63: Headunit high
// This generated code  makes it easier to process CANBUS messages from the NBT ecu in a BMW i3
//

  case I3_PID_NBT_RESET_AKTIVIERUNGSLEITUNG: {                                    // 0x1024
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ETH_PHY_SWITCH_ENGINE_RESET: {                                  // 0x1044
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_ETH_PHY_SWITCH_ENGINE_RESET", 1);
        break;
    }

    unsigned char STAT_PHY_STOPPED_FOR_T_WERT = (RXBUF_UCHAR(0));
        // Remaining duration in seconds during which the given PHY is still inactive. Value range: 0 seconds - 255
        // seconds / Verbleibende Dauer in Sekunden, in denen der gegebene PHY noch inaktiv ist.  Wertebereich: 0
        // Sekunden - 255 Sekunden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ETH_PHY_SWITCH_ENGINE_RESET", "STAT_PHY_STOPPED_FOR_T_WERT", STAT_PHY_STOPPED_FOR_T_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ETH_RESET_PORT_CONFIGURATION: {                                 // 0x104A
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ETH_RESET_PORT_TX_RX_STATS: {                                   // 0x104B
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_LIFECYCLE: {                                             // 0x1735
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_LIFECYCLE", 1);
        break;
    }

    unsigned char STAT_LIFECYCLE = (RXBUF_UCHAR(0));
        // Status lifecycle / Status Lifecycle
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_LIFECYCLE", "STAT_LIFECYCLE", STAT_LIFECYCLE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ETH_GET_NUMBER_OF_PORTS: {                                      // 0x1800
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_ETH_GET_NUMBER_OF_PORTS", 1);
        break;
    }

    unsigned char STAT_NUM_PORTS_WERT = (RXBUF_UCHAR(0));
        // Number of ports / Anzahl der Ports
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ETH_GET_NUMBER_OF_PORTS", "STAT_NUM_PORTS_WERT", STAT_NUM_PORTS_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ETH_PHY_LINK_STATE: {                                           // 0x1802
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_ETH_PHY_LINK_STATE", 3);
        break;
    }

    unsigned char STAT_NUM_OF_PORTS_WERT = (RXBUF_UCHAR(0));
        // Number of physical ports. / Anzahl der physikalischen Ports. 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ETH_PHY_LINK_STATE", "STAT_NUM_OF_PORTS_WERT", STAT_NUM_OF_PORTS_WERT, "");

    unsigned short BF_PHY_LINK_STATE_BTFLD = (RXBUF_UINT(1));
        // Link status of all ports. / Linkstatus aller Port.
        // BF_PHY_LINK_STATE_BTFLD is a BITFIELD of size unsigned int.  We don't yet generate definitions for each bit, we treat as the host data type
            // STAT_PHY_LINK_STATE_PORT_00: Mask: 0x0001 - Link status for port 0
            // STAT_PHY_LINK_STATE_PORT_01: Mask: 0x0002 - Link status for port 1
            // STAT_PHY_LINK_STATE_PORT_02: Mask: 0x0004 - Link status for port 2
            // STAT_PHY_LINK_STATE_PORT_03: Mask: 0x0008 - Link status for port 3
            // STAT_PHY_LINK_STATE_PORT_04: Mask: 0x0010 - Link status for port 4
            // STAT_PHY_LINK_STATE_PORT_05: Mask: 0x0020 - Link status for port 5
            // STAT_PHY_LINK_STATE_PORT_06: Mask: 0x0040 - Link status for port 6
            // STAT_PHY_LINK_STATE_PORT_07: Mask: 0x0080 - Link status for port 7
            // STAT_PHY_LINK_STATE_PORT_08: Mask: 0x0100 - Link status for port 8
            // STAT_PHY_LINK_STATE_PORT_09: Mask: 0x0200 - Link status for port 9
            // STAT_PHY_LINK_STATE_PORT_10: Mask: 0x0400 - Link status for port 10
            // STAT_PHY_LINK_STATE_PORT_11: Mask: 0x0800 - Link status for port 11
            // STAT_PHY_LINK_STATE_PORT_12: Mask: 0x1000 - Link status for port 12
            // STAT_PHY_LINK_STATE_PORT_13: Mask: 0x2000 - Link status for port 13
            // STAT_PHY_LINK_STATE_PORT_14: Mask: 0x4000 - Link status for port 14
            // STAT_PHY_LINK_STATE_PORT_15: Mask: 0x8000 - Link status for port 15
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "NBT", "ETH_PHY_LINK_STATE", "BF_PHY_LINK_STATE_BTFLD", (unsigned long)BF_PHY_LINK_STATE_BTFLD, "\"Bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ETH_LEARN_PORT_CONFIGURATION: {                                 // 0x1803
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_ETH_LEARN_PORT_CONFIGURATION", 3);
        break;
    }

    unsigned char STAT_LEARN_PORT_CONFIGURATION = (RXBUF_UCHAR(0));
        // 0: Learning successful 1: Learning not successful or not yet learned / 0: Lernen erfolgreich 1: Lernen nicht
        // erfolgreich oder noch nicht gelernt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ETH_LEARN_PORT_CONFIGURATION", "STAT_LEARN_PORT_CONFIGURATION", STAT_LEARN_PORT_CONFIGURATION, "\"0-n\"");

    unsigned short BF_ETH_PORT_CONFIGURATION = (RXBUF_UINT(1));
        // 1 bit per port, which indicates whether LinkUp (1) or no link (0) is present. / Pro Port 1Bit, das angibt ob
        // LinkUp(1) oder kein Link (0) vorliegt.
        // BF_ETH_PORT_CONFIGURATION is a BITFIELD of size unsigned int.  We don't yet generate definitions for each bit, we treat as the host data type
            // STAT_PORT_00: Mask: 0x0001 - Port status port 00
            // STAT_PORT_01: Mask: 0x0002 - Port status port 01
            // STAT_PORT_02: Mask: 0x0004 - Port status port 02
            // STAT_PORT_03: Mask: 0x0008 - Port status port 03
            // STAT_PORT_04: Mask: 0x0010 - Port status port 04
            // STAT_PORT_05: Mask: 0x0020 - Port status port 05
            // STAT_PORT_06: Mask: 0x0040 - Port status port 06
            // STAT_PORT_07: Mask: 0x0080 - Port status port 07
            // STAT_PORT_08: Mask: 0x0100 - Port status port 08
            // STAT_PORT_09: Mask: 0x0200 - Port status port 09
            // STAT_PORT_10: Mask: 0x0400 - Port status port 10
            // STAT_PORT_11: Mask: 0x0800 - Port status port 11
            // STAT_PORT_12: Mask: 0x1000 - Port status port 12
            // STAT_PORT_13: Mask: 0x2000 - Port status port 13
            // STAT_PORT_14: Mask: 0x4000 - Port status port 14
            // STAT_PORT_15: Mask: 0x8000 - Port status port 15
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lx%s\n", "NBT", "ETH_LEARN_PORT_CONFIGURATION", "BF_ETH_PORT_CONFIGURATION", (unsigned long)BF_ETH_PORT_CONFIGURATION, "\"Bit\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STEUERN_VOLUMEAUDIO_DEFAULT: {                                  // 0xA002
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STEUERN_LINEAR: {                                               // 0xA004
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_FIND_BEST_STATION: {                                            // 0xA00A
    if (datalen < 13) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_FIND_BEST_STATION", 13);
        break;
    }

    unsigned char STAT_SEARCHING_PROCESS = (RXBUF_UCHAR(0));
        // This status must be reinitialised to 0 when the head unit starts up (normal wake up, reset). / This status
        // must be reinitialised to 0 when the Head-Unit starts up (normal wake up, reset).
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "FIND_BEST_STATION", "STAT_SEARCHING_PROCESS", STAT_SEARCHING_PROCESS, "\"0-n\"");

    unsigned short STAT_PI_WERT = (RXBUF_UINT(9));
        // Program identification of the best station / Program Identification of the best station
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "FIND_BEST_STATION", "STAT_PI_WERT", STAT_PI_WERT, "");

    unsigned char STAT_FIELDSTRENGTH_WERT = (RXBUF_UCHAR(11));
        // Field strength of the best station / Fieldstrength of the best station
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "FIND_BEST_STATION", "STAT_FIELDSTRENGTH_WERT", STAT_FIELDSTRENGTH_WERT, "");

    unsigned char STAT_QUALITY_WERT = (RXBUF_UCHAR(12));
        // Quality of the best station / Quality of the best station
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "FIND_BEST_STATION", "STAT_QUALITY_WERT", STAT_QUALITY_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STEUERN_INTERNAL_RESET: {                                       // 0xA023
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_PROVISIONING: {                                                 // 0xA02F
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_PROVISIONING", 1);
        break;
    }

    unsigned char STAT_PROVISIONING = (RXBUF_UCHAR(0));
        // Status of the provisioning process, values according to table TProvisioningStatus / Status des
        // Provisionierungsprozess, Werte gemäß Tabelle TProvisioningStatus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "PROVISIONING", "STAT_PROVISIONING", STAT_PROVISIONING, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STEUERN_DELETE_COOKIES: {                                       // 0xA030
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STEUERN_RESCUE_MODE: {                                          // 0xA03B
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_SDARS_FACTORY_DEFAULTS: {                                       // 0xA03D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_SDARS_FACTORY_DEFAULTS", 1);
        break;
    }

    unsigned char STAT_SDARS_FACTORY_DEFAULTS = (RXBUF_UCHAR(0));
        // SDARS factory defaults / SDARS Factory Defaults
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "SDARS_FACTORY_DEFAULTS", "STAT_SDARS_FACTORY_DEFAULTS", STAT_SDARS_FACTORY_DEFAULTS, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_FIND_BEST_STATION_DAB: {                                        // 0xA03F
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_FIND_BEST_STATION_DAB", 3);
        break;
    }

    unsigned char STAT_SEARCHING_PROCESS_STATUS_DAB = (RXBUF_UCHAR(0));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "FIND_BEST_STATION_DAB", "STAT_SEARCHING_PROCESS_STATUS_DAB", STAT_SEARCHING_PROCESS_STATUS_DAB, "\"0-n\"");

    unsigned short STAT_ENSEMBLE_BER_WERT = (RXBUF_UINT(1));
        // Bit error rate of active ensemble / Bit Error Rate of active ensemble
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "FIND_BEST_STATION_DAB", "STAT_ENSEMBLE_BER_WERT", STAT_ENSEMBLE_BER_WERT, "\"HEX\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_FIND_BEST_TMC_STATION: {                                        // 0xA045
    if (datalen < 5) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_FIND_BEST_TMC_STATION", 5);
        break;
    }

    unsigned char STAT_SEARCHING_PROCESS_STATUS = (RXBUF_UCHAR(0));
        // TSearchingProcess table / Tabelle TSearchingProcess
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "FIND_BEST_TMC_STATION", "STAT_SEARCHING_PROCESS_STATUS", STAT_SEARCHING_PROCESS_STATUS, "\"0-n\"");

    unsigned short STAT_PI_WERT_0XA045 = (RXBUF_UINT(1));
        // Program identification of the best station / Program Identification of the best station
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "FIND_BEST_TMC_STATION", "STAT_PI_WERT_0XA045", STAT_PI_WERT_0XA045, "");

    unsigned char STAT_FIELDSTRENGTH_WERT_0XA045 = (RXBUF_UCHAR(3));
        // Field strength of the best station: Range: 0 & 255 / Fieldstrength of the best station: Range: 0&255
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "FIND_BEST_TMC_STATION", "STAT_FIELDSTRENGTH_WERT_0XA045", STAT_FIELDSTRENGTH_WERT_0XA045, "");

    unsigned char STAT_QUALITY_WERT_0XA045 = (RXBUF_UCHAR(4));
        // Quality of the best station: Range: 0 & 255 / Quality of the best station: Range: 0&255
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "FIND_BEST_TMC_STATION", "STAT_QUALITY_WERT_0XA045", STAT_QUALITY_WERT_0XA045, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STEUERN_BT_DELETE_ALL_PHONE_ID: {                               // 0xA04B
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_INITIALISATION_COUNTER_REGION_CODE_DVD: {                       // 0xA04D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_INITIALISATION_COUNTER_REGION_CODE_DVD", 1);
        break;
    }

    unsigned char STAT_INITIALISATION_COUNTER_REGION_CODE_DVD_WERT = (RXBUF_UCHAR(0));
        // Value change counter DVD country code / Wert ÄnderugszählerDVDLändercode
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "INITIALISATION_COUNTER_REGION_CODE_DVD", "STAT_INITIALISATION_COUNTER_REGION_CODE_DVD_WERT", STAT_INITIALISATION_COUNTER_REGION_CODE_DVD_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_SWUP_REMOVE_CUSTOMER_UPDATES: {                                 // 0xA05A
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_SWUP_REMOVE_CUSTOMER_UPDATES", 1);
        break;
    }

    unsigned char STAT_REMOVE_CUSTOMER_UPDATES = (RXBUF_UCHAR(0));
        // Remove all user updates / Entfernen aller Benutzer Updates
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "SWUP_REMOVE_CUSTOMER_UPDATES", "STAT_REMOVE_CUSTOMER_UPDATES", STAT_REMOVE_CUSTOMER_UPDATES, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STEUERN_CLEAR_FAULT_TRACKING: {                                 // 0xA085
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_TDA_AKTIVIERUNG: {                                              // 0xA0A8
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_UPDATE_ZERTIFIKATE: {                                           // 0xA0A9
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_TELNET_ZUGANG_AUS: {                                            // 0xA0B0
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_TELNET_ZUGANG_AUS", 1);
        break;
    }

    unsigned char STAT_TELNET_ZUGANG = (RXBUF_UCHAR(0));
        // Status of the telnet access of the HU or the RSE. / Status des Telnetzugangs der HU oder des RSE.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "TELNET_ZUGANG_AUS", "STAT_TELNET_ZUGANG", STAT_TELNET_ZUGANG, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_WLAN_WPS_PUSH_BUTTON: {                                         // 0xA0BB
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_HU_VIN_PROTECTION: {                                            // 0xA0F6
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_HU_VIN_PROTECTION", 1);
        break;
    }

    unsigned char STAT_HU_VIN_PROTECTION = (RXBUF_UCHAR(0));
        // reads the status of the VIN reading / liest den Status des Auslesens der VIN
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "HU_VIN_PROTECTION", "STAT_HU_VIN_PROTECTION", STAT_HU_VIN_PROTECTION, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_HU_FSC_REFURBISH_UI: {                                          // 0xA0F7
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_HU_FSC_REFURBISH_UI", 2);
        break;
    }

    unsigned short STAT_HU_FSC_REFURBISH_UI_WERT = (RXBUF_UINT(0));
        // Value of the required index that is stored in the HU / Wert des nötigen Index, der in der HU gespeichert ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "HU_FSC_REFURBISH_UI", "STAT_HU_FSC_REFURBISH_UI_WERT", STAT_HU_FSC_REFURBISH_UI_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_HU_FSC_REFURBISH_VIN: {                                         // 0xA0FB
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_HU_FSC_REFURBISH_VIN", 7);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_HU_VIN_PROTECTION_ENFORCE_CYCLIC: {                             // 0xA109
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_LESEN_SYSTEMAUDIO: {                                     // 0xD002
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_LESEN_SYSTEMAUDIO", 1);
        break;
    }

    unsigned char STAT_AUDIO_SYSTEM = (RXBUF_UCHAR(0));
        // refers to the speaker system / bezeichnet das Lautsprechersystem
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_LESEN_SYSTEMAUDIO", "STAT_AUDIO_SYSTEM", STAT_AUDIO_SYSTEM, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_INITIALISIERUNG: {                                              // 0xD004
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_INITIALISIERUNG", 1);
        break;
    }

    unsigned char STAT_INITIALISIERUNG = (RXBUF_UCHAR(0));
        // Initialization status / Initialisierungsstatus
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "INITIALISIERUNG", "STAT_INITIALISIERUNG", STAT_INITIALISIERUNG, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_DRIVE_HDD: {                                             // 0xD007
    if (datalen < 85) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_DRIVE_HDD", 85);
        break;
    }

    unsigned char STAT_FREE_DISKSPACE_HDD_PERCENT_WERT = (RXBUF_UCHAR(0));
        // Free HDD space in% / Freier Speicherplatz HDD in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_HDD_PERCENT_WERT", STAT_FREE_DISKSPACE_HDD_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_HDD_MBYTE_WERT = (RXBUF_UINT32(1));
        // Free HDD space in MByte / Freier Speicherplatz HDD in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_HDD_MBYTE_WERT", STAT_FREE_DISKSPACE_HDD_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION1_PERCENT_WERT = (RXBUF_UCHAR(5));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION1_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION1_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION1_MBYTE_WERT = (RXBUF_UINT32(6));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION1_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION1_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION2_PERCENT_WERT = (RXBUF_UCHAR(10));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION2_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION2_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION2_MBYTE_WERT = (RXBUF_UINT32(11));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION2_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION2_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION3_PERCENT_WERT = (RXBUF_UCHAR(15));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION3_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION3_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION3_MBYTE_WERT = (RXBUF_UINT32(16));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION3_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION3_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION4_PERCENT_WERT = (RXBUF_UCHAR(20));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION4_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION4_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION4_MBYTE_WERT = (RXBUF_UINT32(21));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION4_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION4_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION5_PERCENT_WERT = (RXBUF_UCHAR(25));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION5_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION5_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION5_MBYTE_WERT = (RXBUF_UINT32(26));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION5_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION5_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION6_PERCENT_WERT = (RXBUF_UCHAR(30));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION6_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION6_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION6_MBYTE_WERT = (RXBUF_UINT32(31));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION6_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION6_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION7_PERCENT_WERT = (RXBUF_UCHAR(35));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION7_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION7_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION7_MBYTE_WERT = (RXBUF_UINT32(36));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION7_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION7_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION8_PERCENT_WERT = (RXBUF_UCHAR(40));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION8_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION8_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION8_MBYTE_WERT = (RXBUF_UINT32(41));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION8_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION8_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION9_PERCENT_WERT = (RXBUF_UCHAR(45));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION9_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION9_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION9_MBYTE_WERT = (RXBUF_UINT32(46));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION9_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION9_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION10_PERCENT_WERT = (RXBUF_UCHAR(50));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION10_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION10_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION10_MBYTE_WERT = (RXBUF_UINT32(51));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION10_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION10_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION11_PERCENT_WERT = (RXBUF_UCHAR(55));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION11_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION11_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION11_MBYTE_WERT = (RXBUF_UINT32(56));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION11_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION11_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION12_PERCENT_WERT = (RXBUF_UCHAR(60));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION12_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION12_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION12_MBYTE_WERT = (RXBUF_UINT32(61));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION12_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION12_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION13_PERCENT_WERT = (RXBUF_UCHAR(65));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION13_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION13_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION13_MBYTE_WERT = (RXBUF_UINT32(66));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION13_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION13_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION14_PERCENT_WERT = (RXBUF_UCHAR(70));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION14_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION14_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION14_MBYTE_WERT = (RXBUF_UINT32(71));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION14_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION14_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION15_PERCENT_WERT = (RXBUF_UCHAR(75));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION15_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION15_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION15_MBYTE_WERT = (RXBUF_UINT32(76));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION15_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION15_MBYTE_WERT, "");

    unsigned char STAT_FREE_DISKSPACE_PARTITION16_PERCENT_WERT = (RXBUF_UCHAR(80));
        // Free space on partition X in% / Freier Speicherplatz Partition X in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION16_PERCENT_WERT", STAT_FREE_DISKSPACE_PARTITION16_PERCENT_WERT, "\"%\"");

    unsigned long STAT_FREE_DISKSPACE_PARTITION16_MBYTE_WERT = (RXBUF_UINT32(81));
        // Free space in partition X in Mbytes / Freier Speicherplatz Partition X in MByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_DRIVE_HDD", "STAT_FREE_DISKSPACE_PARTITION16_MBYTE_WERT", STAT_FREE_DISKSPACE_PARTITION16_MBYTE_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_MEMORY_USAGE: {                                          // 0xD00A
    if (datalen < 18) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_MEMORY_USAGE", 18);
        break;
    }

    unsigned long STAT_MEMORYSPACE_FLASH_KBYTE_WERT = (RXBUF_UINT32(0));
        // Flash memory in kByte / Flashspeicher in kByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_MEMORY_USAGE", "STAT_MEMORYSPACE_FLASH_KBYTE_WERT", STAT_MEMORYSPACE_FLASH_KBYTE_WERT, "");

    unsigned long STAT_FREE_MEMORYSPACE_FLASH_KBYTE_WERT = (RXBUF_UINT32(4));
        // free flash memory / freier Flashspeicher
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_MEMORY_USAGE", "STAT_FREE_MEMORYSPACE_FLASH_KBYTE_WERT", STAT_FREE_MEMORYSPACE_FLASH_KBYTE_WERT, "");

    unsigned char STAT_FREE_MEMORYSPACE_FLASH_PERCENT_WERT = (RXBUF_UCHAR(8));
        // free flash memory in% / freier Flashspeicher in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_MEMORY_USAGE", "STAT_FREE_MEMORYSPACE_FLASH_PERCENT_WERT", STAT_FREE_MEMORYSPACE_FLASH_PERCENT_WERT, "\"%\"");

    unsigned long STAT_MEMORYSPACE_RAM_KBYTE_WERT = (RXBUF_UINT32(9));
        // RAM memory in kByte / RAM Speicher in kByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_MEMORY_USAGE", "STAT_MEMORYSPACE_RAM_KBYTE_WERT", STAT_MEMORYSPACE_RAM_KBYTE_WERT, "");

    unsigned long STAT_FREE_MEMORYSPACE_RAM_KBYTE_WERT = (RXBUF_UINT32(13));
        // free RAM memory in kByte / freier RAM Speicher in kByte
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_MEMORY_USAGE", "STAT_FREE_MEMORYSPACE_RAM_KBYTE_WERT", STAT_FREE_MEMORYSPACE_RAM_KBYTE_WERT, "");

    unsigned char STAT_FREE_MEMORYSPACE_RAM_PERCENT_WERT = (RXBUF_UCHAR(17));
        // free RAM memory in% / freier RAM Speicher in %
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_MEMORY_USAGE", "STAT_FREE_MEMORYSPACE_RAM_PERCENT_WERT", STAT_FREE_MEMORYSPACE_RAM_PERCENT_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_VERSION_ID_LESEN: {                                      // 0xD00B
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_VERSION_ID_LESEN", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_LESEN_LAUFWERK: {                                        // 0xD00C
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_LESEN_LAUFWERK", 2);
        break;
    }

    unsigned short STAT_VERBAUTE_LAUFWERKE = (RXBUF_UINT(0));
        // Reads out which drives are installed. / Liest aus, welche Laufwerke verbaut sind.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_LESEN_LAUFWERK", "STAT_VERBAUTE_LAUFWERKE", STAT_VERBAUTE_LAUFWERKE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_ANT_QFS: {                                               // 0xD010
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_ANT_QFS", 8);
        break;
    }

    unsigned char STAT_QUALITY_WERT_0XD010 = (RXBUF_UCHAR(0));
        // Values between 0..15 This is the value used for AF tracking, where 15 corresponds to the best quality. / Werte
        // zwischen 0..15 Dies ist der für AF-Tracking verwendete Wert, wobei 15 bester Qualität entspricht.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANT_QFS", "STAT_QUALITY_WERT_0XD010", STAT_QUALITY_WERT_0XD010, "");

    unsigned char STAT_FIELDSTRENGTH_WERT_0XD010 = (RXBUF_UCHAR(1));
        // Values between 0..15 This corresponds to 0..60 dBµV in steps of 4dB. / Werte zwischen 0..15 Dies entspricht
        // 0..60 dBµV in Schritten von 4dB.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANT_QFS", "STAT_FIELDSTRENGTH_WERT_0XD010", STAT_FIELDSTRENGTH_WERT_0XD010, "");

    unsigned char STAT_ANT_PW = (RXBUF_UCHAR(2));
        // indicates the status of the antenna power supply. / gibt den Status der Antennenstromversorgung wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANT_QFS", "STAT_ANT_PW", STAT_ANT_PW, "\"0-n\"");

    unsigned char STAT_FIELDSTRENGTH_EXACT_WERT = (RXBUF_UCHAR(3));
        // Values between 0..60 This corresponds to 0..60 dBµV in steps of 1dB. Return of 255 if no measurement possible.
        // / Werte zwischen 0..60 Dies entspricht 0..60 dBµV in Schritten von 1dB. Rückgabe von 255, wenn keine Messung
        // möglich.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANT_QFS", "STAT_FIELDSTRENGTH_EXACT_WERT", STAT_FIELDSTRENGTH_EXACT_WERT, "\"dBµV\"");

    unsigned long STAT_FREQUENZ_WERT = (RXBUF_UINT32(4));
        // The currently set frequency in the range 150 - 108000 [kHz] / Die derzeit eingestellte Frequenz im Bereich 150
        // - 108000 [kHz]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_ANT_QFS", "STAT_FREQUENZ_WERT", STAT_FREQUENZ_WERT, "\"kHz\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SGBMID_NAVIMAP: {                                        // 0xD012
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SGBMID_NAVIMAP", 8);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_SER_NR_DOM_LESEN: {                                             // 0xD019
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_SER_NR_DOM_LESEN", 14);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_BT_GEKOPPELTE_GERAETE_LESEN: {                           // 0xD01D
    if (datalen < 24) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_BT_GEKOPPELTE_GERAETE_LESEN", 24);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SWUP_INSTALLATION_HISTORY: {                             // 0xD01E
    if (datalen < 80) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SWUP_INSTALLATION_HISTORY", 80);
        break;
    }

    unsigned long STAT_HISTORY_1_KILOMETER_WERT = (RXBUF_UINT32(0));
        // Mileage in operation 1. History entry 0xFFFFFFFF is invalid / Kilometerstand bei der Operation 1.
        // Historyeintrag  0xFFFFFFFF für ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_1_KILOMETER_WERT", STAT_HISTORY_1_KILOMETER_WERT, "\"km\"");

    unsigned char STAT_HISTORY_1_TYP = (RXBUF_UCHAR(4));
        // Type of operation 1. History entry / Typ der Operation 1. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_1_TYP", STAT_HISTORY_1_TYP, "\"0-n\"");

    unsigned long STAT_HISTORY_1_FLASHSPEICHER_WERT = (RXBUF_UINT32(5));
        // Free flash memory that is available for updates after the update (0xff ff ff ff if unknown) 1. History entry
        // Unit: kBytes / Freier Flashspeicher, der für Updates nach dem Update zur Verfügung steht (0xff ff ff ff wenn
        // unbekannt) 1. Historyeintrag  Einheit: kBytes
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_1_FLASHSPEICHER_WERT", STAT_HISTORY_1_FLASHSPEICHER_WERT, "\"kBytes\"");

    unsigned char STAT_HISTORY_1_ERROR_CODE = (RXBUF_UCHAR(9));
        // Software update error code 1. History entry / Software Update Fehlercode 1. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_1_ERROR_CODE", STAT_HISTORY_1_ERROR_CODE, "\"0-n\"");

    unsigned long STAT_HISTORY_2_KILOMETER_WERT = (RXBUF_UINT32(10));
        // Mileage in operation 2. History entry 0xFFFFFFFF is invalid / Kilometerstand bei der Operation 2.
        // Historyeintrag  0xFFFFFFFF für ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_2_KILOMETER_WERT", STAT_HISTORY_2_KILOMETER_WERT, "\"km\"");

    unsigned char STAT_HISTORY_2_TYP = (RXBUF_UCHAR(14));
        // Type of operation 2. History entry / Typ der Operation 2. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_2_TYP", STAT_HISTORY_2_TYP, "\"0-n\"");

    unsigned long STAT_HISTORY_2_FLASHSPEICHER_WERT = (RXBUF_UINT32(15));
        // Free flash memory which is available for updates after the update (0xff ff ff ff if unknown) 2. History entry
        // Unit: kBytes / Freier Flashspeicher, der für Updates nach dem Update zur Verfügung steht (0xff ff ff ff wenn
        // unbekannt) 2. Historyeintrag  Einheit: kBytes
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_2_FLASHSPEICHER_WERT", STAT_HISTORY_2_FLASHSPEICHER_WERT, "\"kBytes\"");

    unsigned char STAT_HISTORY_2_ERROR_CODE = (RXBUF_UCHAR(19));
        // Software update error code 2. History entry / Software Update Fehlercode 2. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_2_ERROR_CODE", STAT_HISTORY_2_ERROR_CODE, "\"0-n\"");

    unsigned long STAT_HISTORY_3_KILOMETER_WERT = (RXBUF_UINT32(20));
        // Mileage in operation 3. History entry 0xFFFFFFFF is invalid / Kilometerstand bei der Operation 3.
        // Historyeintrag  0xFFFFFFFF für ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_3_KILOMETER_WERT", STAT_HISTORY_3_KILOMETER_WERT, "\"km\"");

    unsigned char STAT_HISTORY_3_TYP = (RXBUF_UCHAR(24));
        // Type of operation 3. History entry / Typ der Operation 3. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_3_TYP", STAT_HISTORY_3_TYP, "\"0-n\"");

    unsigned long STAT_HISTORY_3_FLASHSPEICHER_WERT = (RXBUF_UINT32(25));
        // Free flash memory that is available for updates after the update (0xff ff ff ff if unknown) 3. History entry
        // Unit: kBytes / Freier Flashspeicher, der für Updates nach dem Update zur Verfügung steht (0xff ff ff ff wenn
        // unbekannt) 3. Historyeintrag  Einheit: kBytes
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_3_FLASHSPEICHER_WERT", STAT_HISTORY_3_FLASHSPEICHER_WERT, "\"kBytes\"");

    unsigned char STAT_HISTORY_3_ERROR_CODE = (RXBUF_UCHAR(29));
        // Software update error code 3. History entry / Software Update Fehlercode 3. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_3_ERROR_CODE", STAT_HISTORY_3_ERROR_CODE, "\"0-n\"");

    unsigned long STAT_HISTORY_4_KILOMETER_WERT = (RXBUF_UINT32(30));
        // Mileage during operation 4. History entry 0xFFFFFFFF is invalid / Kilometerstand bei der Operation 4.
        // Historyeintrag  0xFFFFFFFF für ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_4_KILOMETER_WERT", STAT_HISTORY_4_KILOMETER_WERT, "\"km\"");

    unsigned char STAT_HISTORY_4_TYP = (RXBUF_UCHAR(34));
        // Type of operation 4. History entry / Typ der Operation 4. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_4_TYP", STAT_HISTORY_4_TYP, "\"0-n\"");

    unsigned long STAT_HISTORY_4_FLASHSPEICHER_WERT = (RXBUF_UINT32(35));
        // Free flash memory that is available for updates after the update (0xff ff ff ff if unknown) 4. History entry
        // Unit: kBytes / Freier Flashspeicher, der für Updates nach dem Update zur Verfügung steht (0xff ff ff ff wenn
        // unbekannt) 4. Historyeintrag  Einheit: kBytes
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_4_FLASHSPEICHER_WERT", STAT_HISTORY_4_FLASHSPEICHER_WERT, "\"kBytes\"");

    unsigned char STAT_HISTORY_4_ERROR_CODE = (RXBUF_UCHAR(39));
        // Software update error code 4. History entry / Software Update Fehlercode 4. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_4_ERROR_CODE", STAT_HISTORY_4_ERROR_CODE, "\"0-n\"");

    unsigned long STAT_HISTORY_5_KILOMETER_WERT = (RXBUF_UINT32(40));
        // Mileage in operation 5. History entry 0xFFFFFFFF is invalid / Kilometerstand bei der Operation 5.
        // Historyeintrag  0xFFFFFFFF für ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_5_KILOMETER_WERT", STAT_HISTORY_5_KILOMETER_WERT, "\"km\"");

    unsigned char STAT_HISTORY_5_TYP = (RXBUF_UCHAR(44));
        // Type of operation 5. History entry / Typ der Operation 5. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_5_TYP", STAT_HISTORY_5_TYP, "\"0-n\"");

    unsigned long STAT_HISTORY_5_FLASHSPEICHER_WERT = (RXBUF_UINT32(45));
        // Free flash memory that is available for updates after the update (0xff ff ff ff if unknown) 5. History entry
        // Unit: kBytes / Freier Flashspeicher, der für Updates nach dem Update zur Verfügung steht (0xff ff ff ff wenn
        // unbekannt) 5. Historyeintrag  Einheit: kBytes
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_5_FLASHSPEICHER_WERT", STAT_HISTORY_5_FLASHSPEICHER_WERT, "\"kBytes\"");

    unsigned char STAT_HISTORY_5_ERROR_CODE = (RXBUF_UCHAR(49));
        // Software update error code 5. History entry / Software Update Fehlercode 5. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_5_ERROR_CODE", STAT_HISTORY_5_ERROR_CODE, "\"0-n\"");

    unsigned long STAT_HISTORY_6_KILOMETER_WERT = (RXBUF_UINT32(50));
        // Mileage in operation 6. History entry 0xFFFFFFFF is invalid / Kilometerstand bei der Operation 6.
        // Historyeintrag  0xFFFFFFFF für ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_6_KILOMETER_WERT", STAT_HISTORY_6_KILOMETER_WERT, "\"km\"");

    unsigned char STAT_HISTORY_6_TYP = (RXBUF_UCHAR(54));
        // Type of operation 6. History entry / Typ der Operation 6. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_6_TYP", STAT_HISTORY_6_TYP, "\"0-n\"");

    unsigned long STAT_HISTORY_6_FLASHSPEICHER_WERT = (RXBUF_UINT32(55));
        // Free flash memory that is available for updates after the update (0xff ff ff ff if unknown) 6. History entry
        // Unit: kBytes / Freier Flashspeicher, der für Updates nach dem Update zur Verfügung steht (0xff ff ff ff wenn
        // unbekannt) 6. Historyeintrag  Einheit: kBytes
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_6_FLASHSPEICHER_WERT", STAT_HISTORY_6_FLASHSPEICHER_WERT, "\"kBytes\"");

    unsigned char STAT_HISTORY_6_ERROR_CODE = (RXBUF_UCHAR(59));
        // Software update error code 6. History entry / Software Update Fehlercode 6. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_6_ERROR_CODE", STAT_HISTORY_6_ERROR_CODE, "\"0-n\"");

    unsigned long STAT_HISTORY_7_KILOMETER_WERT = (RXBUF_UINT32(60));
        // Mileage in operation 7. History entry 0xFFFFFFFF is invalid / Kilometerstand bei der Operation 7.
        // Historyeintrag  0xFFFFFFFF für ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_7_KILOMETER_WERT", STAT_HISTORY_7_KILOMETER_WERT, "\"km\"");

    unsigned char STAT_HISTORY_7_TYP = (RXBUF_UCHAR(64));
        // Type of operation 7. History entry / Typ der Operation 7. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_7_TYP", STAT_HISTORY_7_TYP, "\"0-n\"");

    unsigned long STAT_HISTORY_7_FLASHSPEICHER_WERT = (RXBUF_UINT32(65));
        // Free flash memory that is available for updates after the update (0xff ff ff ff if unknown) 7. History entry
        // Unit: kBytes / Freier Flashspeicher, der für Updates nach dem Update zur Verfügung steht (0xff ff ff ff wenn
        // unbekannt) 7. Historyeintrag  Einheit: kBytes
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_7_FLASHSPEICHER_WERT", STAT_HISTORY_7_FLASHSPEICHER_WERT, "\"kBytes\"");

    unsigned char STAT_HISTORY_7_ERROR_CODE = (RXBUF_UCHAR(69));
        // Software update error code 7. History entry / Software Update Fehlercode 7. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_7_ERROR_CODE", STAT_HISTORY_7_ERROR_CODE, "\"0-n\"");

    unsigned long STAT_HISTORY_8_KILOMETER_WERT = (RXBUF_UINT32(70));
        // Mileage in operation 8. History entry 0xFFFFFFFF is invalid / Kilometerstand bei der Operation 8.
        // Historyeintrag  0xFFFFFFFF für ungültig
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_8_KILOMETER_WERT", STAT_HISTORY_8_KILOMETER_WERT, "\"km\"");

    unsigned char STAT_HISTORY_8_TYP = (RXBUF_UCHAR(74));
        // Type of operation 8. History entry / Typ der Operation 8. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_8_TYP", STAT_HISTORY_8_TYP, "\"0-n\"");

    unsigned long STAT_HISTORY_8_FLASHSPEICHER_WERT = (RXBUF_UINT32(75));
        // Free flash memory which is available for updates after the update (0xff ff ff ff if unknown) 8. History entry
        // Unit: kBytes / Freier Flashspeicher, der für Updates nach dem Update zur Verfügung steht (0xff ff ff ff wenn
        // unbekannt) 8. Historyeintrag  Einheit: kBytes
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_8_FLASHSPEICHER_WERT", STAT_HISTORY_8_FLASHSPEICHER_WERT, "\"kBytes\"");

    unsigned char STAT_HISTORY_8_ERROR_CODE = (RXBUF_UCHAR(79));
        // Software update error code 8. History entry / Software Update Fehlercode 8. Historyeintrag
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SWUP_INSTALLATION_HISTORY", "STAT_HISTORY_8_ERROR_CODE", STAT_HISTORY_8_ERROR_CODE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_LOGISTIC_NR: {                                                  // 0xD020
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_LOGISTIC_NR", 7);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_APPLICATION: {                                                  // 0xD021
    if (datalen < 54) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_APPLICATION", 54);
        break;
    }

    unsigned char STAT_APPL_1 = (RXBUF_UCHAR(0));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_1", STAT_APPL_1, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_1 = (RXBUF_UCHAR(1));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_1", STAT_APPL_ENABLED_1, "\"0-n\"");

    unsigned char STAT_APPL_CODED_1 = (RXBUF_UCHAR(2));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_1", STAT_APPL_CODED_1, "\"0-n\"");

    unsigned char STAT_APPL_2 = (RXBUF_UCHAR(3));
        // Output for each application X: Name from the TApplication table. / Ausgabe für jede Applikation X: Name aus
        // der Tabelle TApplication.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_2", STAT_APPL_2, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_2 = (RXBUF_UCHAR(4));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_2", STAT_APPL_ENABLED_2, "\"0-n\"");

    unsigned char STAT_APPL_CODED_2 = (RXBUF_UCHAR(5));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_2", STAT_APPL_CODED_2, "\"0-n\"");

    unsigned char STAT_APPL_3 = (RXBUF_UCHAR(6));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_3", STAT_APPL_3, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_3 = (RXBUF_UCHAR(7));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_3", STAT_APPL_ENABLED_3, "\"0-n\"");

    unsigned char STAT_APPL_CODED_3 = (RXBUF_UCHAR(8));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_3", STAT_APPL_CODED_3, "\"0-n\"");

    unsigned char STAT_APPL_4 = (RXBUF_UCHAR(9));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_4", STAT_APPL_4, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_4 = (RXBUF_UCHAR(10));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_4", STAT_APPL_ENABLED_4, "\"0-n\"");

    unsigned char STAT_APPL_CODED_4 = (RXBUF_UCHAR(11));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_4", STAT_APPL_CODED_4, "\"0-n\"");

    unsigned char STAT_APPL_5 = (RXBUF_UCHAR(12));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_5", STAT_APPL_5, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_5 = (RXBUF_UCHAR(13));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_5", STAT_APPL_ENABLED_5, "\"0-n\"");

    unsigned char STAT_APPL_CODED_5 = (RXBUF_UCHAR(14));
        // v indicates for each application X whether it is activated. / vgibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_5", STAT_APPL_CODED_5, "\"0-n\"");

    unsigned char STAT_APPL_6 = (RXBUF_UCHAR(15));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_6", STAT_APPL_6, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_6 = (RXBUF_UCHAR(16));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_6", STAT_APPL_ENABLED_6, "\"0-n\"");

    unsigned char STAT_APPL_CODED_6 = (RXBUF_UCHAR(17));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_6", STAT_APPL_CODED_6, "\"0-n\"");

    unsigned char STAT_APPL_7 = (RXBUF_UCHAR(18));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_7", STAT_APPL_7, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_7 = (RXBUF_UCHAR(19));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_7", STAT_APPL_ENABLED_7, "\"0-n\"");

    unsigned char STAT_APPL_CODED_7 = (RXBUF_UCHAR(20));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_7", STAT_APPL_CODED_7, "\"0-n\"");

    unsigned char STAT_APPL_8 = (RXBUF_UCHAR(21));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_8", STAT_APPL_8, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_8 = (RXBUF_UCHAR(22));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_8", STAT_APPL_ENABLED_8, "\"0-n\"");

    unsigned char STAT_APPL_CODED_8 = (RXBUF_UCHAR(23));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_8", STAT_APPL_CODED_8, "\"0-n\"");

    unsigned char STAT_APPL_9 = (RXBUF_UCHAR(24));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_9", STAT_APPL_9, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_9 = (RXBUF_UCHAR(25));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_9", STAT_APPL_ENABLED_9, "\"0-n\"");

    unsigned char STAT_APPL_CODED_9 = (RXBUF_UCHAR(26));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_9", STAT_APPL_CODED_9, "\"0-n\"");

    unsigned char STAT_APPL_10 = (RXBUF_UCHAR(27));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_10", STAT_APPL_10, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_10 = (RXBUF_UCHAR(28));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_10", STAT_APPL_ENABLED_10, "\"0-n\"");

    unsigned char STAT_APPL_CODED_10 = (RXBUF_UCHAR(29));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_10", STAT_APPL_CODED_10, "\"0-n\"");

    unsigned char STAT_APPL_11 = (RXBUF_UCHAR(30));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_11", STAT_APPL_11, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_11 = (RXBUF_UCHAR(31));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_11", STAT_APPL_ENABLED_11, "\"0-n\"");

    unsigned char STAT_APPL_CODED_11 = (RXBUF_UCHAR(32));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_11", STAT_APPL_CODED_11, "\"0-n\"");

    unsigned char STAT_APPL_12 = (RXBUF_UCHAR(33));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_12", STAT_APPL_12, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_12 = (RXBUF_UCHAR(34));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_12", STAT_APPL_ENABLED_12, "\"0-n\"");

    unsigned char STAT_APPL_CODED_12 = (RXBUF_UCHAR(35));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_12", STAT_APPL_CODED_12, "\"0-n\"");

    unsigned char STAT_APPL_13 = (RXBUF_UCHAR(36));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_13", STAT_APPL_13, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_13 = (RXBUF_UCHAR(37));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_13", STAT_APPL_ENABLED_13, "\"0-n\"");

    unsigned char STAT_APPL_CODED_13 = (RXBUF_UCHAR(38));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_13", STAT_APPL_CODED_13, "\"0-n\"");

    unsigned char STAT_APPL_14 = (RXBUF_UCHAR(39));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_14", STAT_APPL_14, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_14 = (RXBUF_UCHAR(40));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_14", STAT_APPL_ENABLED_14, "\"0-n\"");

    unsigned char STAT_APPL_CODED_14 = (RXBUF_UCHAR(41));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_14", STAT_APPL_CODED_14, "\"0-n\"");

    unsigned char STAT_APPL_15 = (RXBUF_UCHAR(42));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_15", STAT_APPL_15, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_15 = (RXBUF_UCHAR(43));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_15", STAT_APPL_ENABLED_15, "\"0-n\"");

    unsigned char STAT_APPL_CODED_15 = (RXBUF_UCHAR(44));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_15", STAT_APPL_CODED_15, "\"0-n\"");

    unsigned char STAT_APPL_16 = (RXBUF_UCHAR(45));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_16", STAT_APPL_16, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_16 = (RXBUF_UCHAR(46));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_16", STAT_APPL_ENABLED_16, "\"0-n\"");

    unsigned char STAT_APPL_CODED_16 = (RXBUF_UCHAR(47));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_16", STAT_APPL_CODED_16, "\"0-n\"");

    unsigned char STAT_APPL_17 = (RXBUF_UCHAR(48));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_17", STAT_APPL_17, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_17 = (RXBUF_UCHAR(49));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_17", STAT_APPL_ENABLED_17, "\"0-n\"");

    unsigned char STAT_APPL_CODED_17 = (RXBUF_UCHAR(50));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_17", STAT_APPL_CODED_17, "\"0-n\"");

    unsigned char STAT_APPL_18 = (RXBUF_UCHAR(51));
        // returns the names of each application X from the TApplication table. / gibt für jede Applikation X deren Namen
        // aus der Tabelle TApplication wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_18", STAT_APPL_18, "\"0-n\"");

    unsigned char STAT_APPL_ENABLED_18 = (RXBUF_UCHAR(52));
        // shows for each application X whether it is currently running. / gibt für jede Applikation X wieder, ob sie
        // gerade läuft.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_ENABLED_18", STAT_APPL_ENABLED_18, "\"0-n\"");

    unsigned char STAT_APPL_CODED_18 = (RXBUF_UCHAR(53));
        // indicates for each application X whether it is activated. / gibt für jede Applikation X wieder, ob sie
        // aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "APPLICATION", "STAT_APPL_CODED_18", STAT_APPL_CODED_18, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_ANALOG_TEMPERATUR: {                                     // 0xD026
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_ANALOG_TEMPERATUR", 7);
        break;
    }

    char STAT_TEMP_FOT_WERT = (RXBUF_SCHAR(0));
        // provides the temperature of the Fiber Optical Transceiver (FOT). Range: -127, &, 127 / liefert die Temperatur
        // des Fibre Optical Transceivers (FOT). Bereich: -127,&,127
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANALOG_TEMPERATUR", "STAT_TEMP_FOT_WERT", STAT_TEMP_FOT_WERT, "\"°C\"");

    short STAT_TEMP_ENDSTU_WERT = (RXBUF_SINT(1));
        // supplies the temperature of the output stage. Range: -32767, &, 32767 / liefert die Temperatur der Endstufe.
        // Bereich: -32767,&, 32767
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_ANALOG_TEMPERATUR", "STAT_TEMP_ENDSTU_WERT", STAT_TEMP_ENDSTU_WERT, "\"°C\"");

    char STAT_TEMP_GYRO_WERT = (RXBUF_SCHAR(3));
        // provides the temperature of the gyro. Range: -127, &, 127 / liefert die Temperatur des Gyro. Bereich:
        // -127,&,127
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANALOG_TEMPERATUR", "STAT_TEMP_GYRO_WERT", STAT_TEMP_GYRO_WERT, "\"°C\"");

    char STAT_TEMP_MOD_WERT = (RXBUF_SCHAR(4));
        // supplies the temperature of the module (usually close to the processor). Range: -127, &, 127 / liefert die
        // Temperatur des Moduls (normalerweise prozessornah). Bereich: -127,&,127
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANALOG_TEMPERATUR", "STAT_TEMP_MOD_WERT", STAT_TEMP_MOD_WERT, "\"°C\"");

    char STAT_TEMP_HDD_WERT = (RXBUF_SCHAR(5));
        // provides the temperature of the HDD drive. Range: -127, &, 127 / liefert die Temperatur des HDD-Laufwerks.
        // Bereich: -127,&,127
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANALOG_TEMPERATUR", "STAT_TEMP_HDD_WERT", STAT_TEMP_HDD_WERT, "\"°C\"");

    char STAT_TEMP_DVD_WERT = (RXBUF_SCHAR(6));
        // provides the temperature of the DVD drive. Range: -127, &, 127 / liefert die Temperatur des DVD-Laufwerks.
        // Bereich: -127,&,127
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANALOG_TEMPERATUR", "STAT_TEMP_DVD_WERT", STAT_TEMP_DVD_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_CD_MD_CDC: {                                             // 0xD02C
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_CD_MD_CDC", 1);
        break;
    }

    unsigned char STAT_DIGITAL_PLAYBACK_QUALITY_WERT = (RXBUF_UCHAR(0));
        // Quality of the digital recording: Range: 0-15 0-1: Medium not readable (drive not ok) 2-8: Distortion / mute
        // parts audible (drive not ok) 9-14: Medium readable, no distortion audible (drive ok) 15: Medium quality 100%,
        // e.g. BLER 0 (drive ok) / Qualität der digitalen Aufnahme: Bereich: 0-15 0-1: Medium nicht lesbar (drive not
        // ok) 2-8: Verzerrung / Stumm Stellen hörbar (drive not ok) 9-14: Medium lesbar, keine Verzerrung hörbar (drive
        // ok) 15: Medium Qualität 100%, z.B. BLER 0 (drive ok)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_CD_MD_CDC", "STAT_DIGITAL_PLAYBACK_QUALITY_WERT", STAT_DIGITAL_PLAYBACK_QUALITY_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SPEED: {                                                 // 0xD030
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SPEED", 14);
        break;
    }

    short STAT_WHEEL1_SENSOR_SPEED_WERT = (RXBUF_SINT(0));
        // Speed on bike 1 / Geschwindigkeit am Rad 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_SPEED", "STAT_WHEEL1_SENSOR_SPEED_WERT", STAT_WHEEL1_SENSOR_SPEED_WERT, "\"km/h\"");

    short STAT_WHEEL2_SENSOR_SPEED_WERT = (RXBUF_SINT(2));
        // Speed on bike 2 / Geschwindigkeit am Rad 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_SPEED", "STAT_WHEEL2_SENSOR_SPEED_WERT", STAT_WHEEL2_SENSOR_SPEED_WERT, "\"km/h\"");

    short STAT_WHEEL3_SENSOR_SPEED_WERT = (RXBUF_SINT(4));
        // Speed on the bike 3 / Geschwindigkeit am Rad 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_SPEED", "STAT_WHEEL3_SENSOR_SPEED_WERT", STAT_WHEEL3_SENSOR_SPEED_WERT, "\"km/h\"");

    short STAT_WHEEL4_SENSOR_SPEED_WERT = (RXBUF_SINT(6));
        // Speed on the bike 4 / Geschwindigkeit am Rad 4
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_SPEED", "STAT_WHEEL4_SENSOR_SPEED_WERT", STAT_WHEEL4_SENSOR_SPEED_WERT, "\"km/h\"");

    short STAT_COMBINED_SENSOR_SPEED_WERT = (RXBUF_SINT(8));
        // Combined speed of the wheel sensors / Kombinierte Geschwindigkeit der Radsensoren
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_SPEED", "STAT_COMBINED_SENSOR_SPEED_WERT", STAT_COMBINED_SENSOR_SPEED_WERT, "\"km/h\"");

    short STAT_GPS_SPEED_WERT = (RXBUF_SINT(10));
        // Speed based on the GPS signal. / Geschwindigkeit basierend auf das GPS-Signal.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_SPEED", "STAT_GPS_SPEED_WERT", STAT_GPS_SPEED_WERT, "\"km/h\"");

    unsigned short STAT_SPEED_DIFFERENCE_PERCENT_WERT = (RXBUF_UINT(12));
        // Difference in percent between the speeds recorded with the wheel sensors or GPS / Abweichung in Prozent
        // zwischen den Geschwindigkeiten, die mit den Radsensoren bzw. mittels GPS erfasst wurden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_SPEED", "STAT_SPEED_DIFFERENCE_PERCENT_WERT", STAT_SPEED_DIFFERENCE_PERCENT_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_DIRECTION: {                                             // 0xD031
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_DIRECTION", 2);
        break;
    }

    unsigned char STAT_DIRECTION = (RXBUF_UCHAR(0));
        // Current gear position see TGearType / aktuelle Gangstellung siehe TGearType
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DIRECTION", "STAT_DIRECTION", STAT_DIRECTION, "\"0-n\"");

    unsigned char STAT_DIRECTION_SOURCE = (RXBUF_UCHAR(1));
        // see table TDirectionSource / siehe Tabelle TDirectionSource
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DIRECTION", "STAT_DIRECTION_SOURCE", STAT_DIRECTION_SOURCE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_GPS_DILUTION_OF_POSITION: {                              // 0xD032
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_GPS_DILUTION_OF_POSITION", 3);
        break;
    }

    unsigned char STAT_GPS_PDOP_WERT = (RXBUF_UCHAR(0));
        // GPS position accuracy / GPS Positionsgeanuigkeit
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_DILUTION_OF_POSITION", "STAT_GPS_PDOP_WERT", STAT_GPS_PDOP_WERT, "");

    unsigned char STAT_GPS_HDOP_WERT = (RXBUF_UCHAR(1));
        // GPS horizontal position accuracy / GPS horizontale Positionsgeanuigkeit
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_DILUTION_OF_POSITION", "STAT_GPS_HDOP_WERT", STAT_GPS_HDOP_WERT, "");

    unsigned char STAT_GPS_VDOP_WERT = (RXBUF_UCHAR(2));
        // GPS vertical position accuracy / GPS vertikale Positionsgeanuigkeit
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_DILUTION_OF_POSITION", "STAT_GPS_VDOP_WERT", STAT_GPS_VDOP_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_GPS_SATINFO: {                                           // 0xD034
    if (datalen < 66) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_GPS_SATINFO", 66);
        break;
    }

    unsigned char STAT_NUMBER_VISIBLE_SATS_WERT = (RXBUF_UCHAR(0));
        // Number of theoretically reachable satellites / Anzahl der theoretisch erreichbaren Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_NUMBER_VISIBLE_SATS_WERT", STAT_NUMBER_VISIBLE_SATS_WERT, "");

    unsigned char STAT_NUMBER_TRACKED_SATS_WERT = (RXBUF_UCHAR(1));
        // Number of satellites tracked / Anzahl der aufgespuerten Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_NUMBER_TRACKED_SATS_WERT", STAT_NUMBER_TRACKED_SATS_WERT, "");

    unsigned char STAT_SAT_1_ID_WERT = (RXBUF_UCHAR(2));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_1_ID_WERT", STAT_SAT_1_ID_WERT, "");

    unsigned char STAT_SAT_1_STATUS = (RXBUF_UCHAR(3));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_1_STATUS", STAT_SAT_1_STATUS, "\"0-n\"");

    short STAT_SAT_1_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(4));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_1_SIGNAL_TO_NOISE_WERT", STAT_SAT_1_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_2_ID_WERT = (RXBUF_UCHAR(6));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_2_ID_WERT", STAT_SAT_2_ID_WERT, "");

    unsigned char STAT_SAT_2_STATUS = (RXBUF_UCHAR(7));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_2_STATUS", STAT_SAT_2_STATUS, "\"0-n\"");

    short STAT_SAT_2_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(8));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_2_SIGNAL_TO_NOISE_WERT", STAT_SAT_2_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_3_ID_WERT = (RXBUF_UCHAR(10));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_3_ID_WERT", STAT_SAT_3_ID_WERT, "");

    unsigned char STAT_SAT_3_STATUS = (RXBUF_UCHAR(11));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_3_STATUS", STAT_SAT_3_STATUS, "\"0-n\"");

    short STAT_SAT_3_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(12));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_3_SIGNAL_TO_NOISE_WERT", STAT_SAT_3_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_4_ID_WERT = (RXBUF_UCHAR(14));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_4_ID_WERT", STAT_SAT_4_ID_WERT, "");

    unsigned char STAT_SAT_4_STATUS = (RXBUF_UCHAR(15));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_4_STATUS", STAT_SAT_4_STATUS, "\"0-n\"");

    short STAT_SAT_4_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(16));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_4_SIGNAL_TO_NOISE_WERT", STAT_SAT_4_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_5_ID_WERT = (RXBUF_UCHAR(18));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_5_ID_WERT", STAT_SAT_5_ID_WERT, "");

    unsigned char STAT_SAT_5_STATUS = (RXBUF_UCHAR(19));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_5_STATUS", STAT_SAT_5_STATUS, "\"0-n\"");

    short STAT_SAT_5_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(20));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_5_SIGNAL_TO_NOISE_WERT", STAT_SAT_5_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_6_ID_WERT = (RXBUF_UCHAR(22));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_6_ID_WERT", STAT_SAT_6_ID_WERT, "");

    unsigned char STAT_SAT_6_STATUS = (RXBUF_UCHAR(23));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_6_STATUS", STAT_SAT_6_STATUS, "\"0-n\"");

    short STAT_SAT_6_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(24));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_6_SIGNAL_TO_NOISE_WERT", STAT_SAT_6_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_7_ID_WERT = (RXBUF_UCHAR(26));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_7_ID_WERT", STAT_SAT_7_ID_WERT, "");

    unsigned char STAT_SAT_7_STATUS = (RXBUF_UCHAR(27));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_7_STATUS", STAT_SAT_7_STATUS, "\"0-n\"");

    short STAT_SAT_7_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(28));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_7_SIGNAL_TO_NOISE_WERT", STAT_SAT_7_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_8_ID_WERT = (RXBUF_UCHAR(30));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_8_ID_WERT", STAT_SAT_8_ID_WERT, "");

    unsigned char STAT_SAT_8_STATUS = (RXBUF_UCHAR(31));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_8_STATUS", STAT_SAT_8_STATUS, "\"0-n\"");

    short STAT_SAT_8_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(32));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_8_SIGNAL_TO_NOISE_WERT", STAT_SAT_8_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_9_ID_WERT = (RXBUF_UCHAR(34));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_9_ID_WERT", STAT_SAT_9_ID_WERT, "");

    unsigned char STAT_SAT_9_STATUS = (RXBUF_UCHAR(35));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_9_STATUS", STAT_SAT_9_STATUS, "\"0-n\"");

    short STAT_SAT_9_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(36));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_9_SIGNAL_TO_NOISE_WERT", STAT_SAT_9_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_10_ID_WERT = (RXBUF_UCHAR(38));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_10_ID_WERT", STAT_SAT_10_ID_WERT, "");

    unsigned char STAT_SAT_10_STATUS = (RXBUF_UCHAR(39));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_10_STATUS", STAT_SAT_10_STATUS, "\"0-n\"");

    short STAT_SAT_10_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(40));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_10_SIGNAL_TO_NOISE_WERT", STAT_SAT_10_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_11_ID_WERT = (RXBUF_UCHAR(42));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_11_ID_WERT", STAT_SAT_11_ID_WERT, "");

    unsigned char STAT_SAT_11_STATUS = (RXBUF_UCHAR(43));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_11_STATUS", STAT_SAT_11_STATUS, "\"0-n\"");

    short STAT_SAT_11_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(44));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_11_SIGNAL_TO_NOISE_WERT", STAT_SAT_11_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_12_ID_WERT = (RXBUF_UCHAR(46));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_12_ID_WERT", STAT_SAT_12_ID_WERT, "");

    unsigned char STAT_SAT_12_STATUS = (RXBUF_UCHAR(47));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_12_STATUS", STAT_SAT_12_STATUS, "\"0-n\"");

    short STAT_SAT_12_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(48));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_12_SIGNAL_TO_NOISE_WERT", STAT_SAT_12_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_13_ID_WERT = (RXBUF_UCHAR(50));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_13_ID_WERT", STAT_SAT_13_ID_WERT, "");

    unsigned char STAT_SAT_13_STATUS = (RXBUF_UCHAR(51));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_13_STATUS", STAT_SAT_13_STATUS, "\"0-n\"");

    short STAT_SAT_13_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(52));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_13_SIGNAL_TO_NOISE_WERT", STAT_SAT_13_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_14_ID_WERT = (RXBUF_UCHAR(54));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_14_ID_WERT", STAT_SAT_14_ID_WERT, "");

    unsigned char STAT_SAT_14_STATUS = (RXBUF_UCHAR(55));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_14_STATUS", STAT_SAT_14_STATUS, "\"0-n\"");

    short STAT_SAT_14_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(56));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_14_SIGNAL_TO_NOISE_WERT", STAT_SAT_14_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_15_ID_WERT = (RXBUF_UCHAR(58));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_15_ID_WERT", STAT_SAT_15_ID_WERT, "");

    unsigned char STAT_SAT_15_STATUS = (RXBUF_UCHAR(59));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_15_STATUS", STAT_SAT_15_STATUS, "\"0-n\"");

    short STAT_SAT_15_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(60));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_15_SIGNAL_TO_NOISE_WERT", STAT_SAT_15_SIGNAL_TO_NOISE_WERT, "");

    unsigned char STAT_SAT_16_ID_WERT = (RXBUF_UCHAR(62));
        // ID of the satellite / ID des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_16_ID_WERT", STAT_SAT_16_ID_WERT, "");

    unsigned char STAT_SAT_16_STATUS = (RXBUF_UCHAR(63));
        // Status of the satellite / Status des Satelliten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_16_STATUS", STAT_SAT_16_STATUS, "\"0-n\"");

    short STAT_SAT_16_SIGNAL_TO_NOISE_WERT = (RXBUF_SINT(64));
        // Signal-to-noise ratio / Signal- Rauschabstand
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "STATUS_GPS_SATINFO", "STAT_SAT_16_SIGNAL_TO_NOISE_WERT", STAT_SAT_16_SIGNAL_TO_NOISE_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_GPS: {                                                   // 0xD038
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_GPS", 1);
        break;
    }

    unsigned char STAT_GPS = (RXBUF_UCHAR(0));
        // Reads the GPS status. See table TGpsStatus. / Liest den GPS Status. Siehe Tabelle TGpsStatus.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_GPS", "STAT_GPS", STAT_GPS, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_GPS_RECEIVER_SW_VERSION: {                               // 0xD03B
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_GPS_RECEIVER_SW_VERSION", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_MAPMATERIAL_VERSION: {                                   // 0xD03C
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_MAPMATERIAL_VERSION", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_NAVI_CALIBRATION: {                                      // 0xD03D
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_NAVI_CALIBRATION", 1);
        break;
    }

    unsigned char STAT_NAVI_CALIBRATION = (RXBUF_UCHAR(0));
        // Asks whether the navigation system is calibrated. See table TNaviCalibration / Fragt ob das Navi kalibriert
        // ist. Siehe Tabelle TNaviCalibration
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_NAVI_CALIBRATION", "STAT_NAVI_CALIBRATION", STAT_NAVI_CALIBRATION, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_EXT_GYROSIGNAL: {                                        // 0xD03E
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_EXT_GYROSIGNAL", 1);
        break;
    }

    unsigned char STAT_EXT_GYRO_SIGNAL = (RXBUF_UCHAR(0));
        // Asks whether the gyro signal is received See table TExtGyroSignal / Fragt ob das Gyrosignal empfangen wird
        // Siehe Tabelle TExtGyroSignal
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_EXT_GYROSIGNAL", "STAT_EXT_GYRO_SIGNAL", STAT_EXT_GYRO_SIGNAL, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_HMI_VERSION: {                                           // 0xD03F
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_HMI_VERSION", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SGBMID_GRACENOTES: {                                     // 0xD042
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SGBMID_GRACENOTES", 8);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_ANT_QFS_FM2: {                                           // 0xD045
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_ANT_QFS_FM2", 8);
        break;
    }

    unsigned char STAT_QUALITY_WERT_0XD045 = (RXBUF_UCHAR(0));
        // Values between 0..15 This is the value used for AF tracking, where 15 corresponds to the best quality. / Werte
        // zwischen 0..15 Dies ist der für AF-Tracking verwendete Wert, wobei 15 bester Qualität entspricht.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANT_QFS_FM2", "STAT_QUALITY_WERT_0XD045", STAT_QUALITY_WERT_0XD045, "");

    unsigned char STAT_FIELDSTRENGTH_WERT_0XD045 = (RXBUF_UCHAR(1));
        // Values between 0..15 This corresponds to 0..60 dBµV in steps of 4dB. / Werte zwischen 0..15 Dies entspricht
        // 0..60 dBµV in Schritten von 4dB.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANT_QFS_FM2", "STAT_FIELDSTRENGTH_WERT_0XD045", STAT_FIELDSTRENGTH_WERT_0XD045, "");

    unsigned char STAT_ANT_PW_0XD045 = (RXBUF_UCHAR(2));
        // indicates the status of the antenna power supply. / gibt den Status der Antennenstromversorgung wieder.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANT_QFS_FM2", "STAT_ANT_PW_0XD045", STAT_ANT_PW_0XD045, "\"0-n\"");

    unsigned char STAT_FIELDSTRENGTH_EXACT_WERT_0XD045 = (RXBUF_UCHAR(3));
        // Values between 0..60 This corresponds to 0..60 dBµV in steps of 1dB. Return of 255 if no measurement possible.
        // / Werte zwischen 0..60 Dies entspricht 0..60 dBµV in Schritten von 1dB. Rückgabe von 255, wenn keine Messung
        // möglich.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ANT_QFS_FM2", "STAT_FIELDSTRENGTH_EXACT_WERT_0XD045", STAT_FIELDSTRENGTH_EXACT_WERT_0XD045, "\"dBµV\"");

    unsigned long STAT_FREQUENZ_WERT_0XD045 = (RXBUF_UINT32(4));
        // The currently set frequency in the range 150 - 108000 [kHz] / Die derzeit eingestellte Frequenz im Bereich 150
        // - 108000 [kHz]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_ANT_QFS_FM2", "STAT_FREQUENZ_WERT_0XD045", STAT_FREQUENZ_WERT_0XD045, "\"kHz\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SIGNAL_DAB: {                                            // 0xD053
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SIGNAL_DAB", 1);
        break;
    }

    unsigned char STAT_SIGNAL_DAB = (RXBUF_UCHAR(0));
        // DAB signal / DAB Signal
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SIGNAL_DAB", "STAT_SIGNAL_DAB", STAT_SIGNAL_DAB, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_USB_HUB_TEST: {                                          // 0xD057
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_USB_HUB_TEST", 2);
        break;
    }

    unsigned char STAT_USB_HUB_TEST_PORT_1 = (RXBUF_UCHAR(0));
        // Status HUB connection port 1 / Status HUB Verbindung Port 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_USB_HUB_TEST", "STAT_USB_HUB_TEST_PORT_1", STAT_USB_HUB_TEST_PORT_1, "\"0-n\"");

    unsigned char STAT_USB_HUB_TEST_PORT_2 = (RXBUF_UCHAR(1));
        // Status HUB connection port 2 / Status HUB Verbindung Port 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_USB_HUB_TEST", "STAT_USB_HUB_TEST_PORT_2", STAT_USB_HUB_TEST_PORT_2, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_ROUTE_DOWNLOAD: {                                        // 0xD065
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_ROUTE_DOWNLOAD", 4);
        break;
    }

    unsigned char STAT_ROUTE_DOWNLOAD = (RXBUF_UCHAR(0));
        // Status route download / Status Route download
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ROUTE_DOWNLOAD", "STAT_ROUTE_DOWNLOAD", STAT_ROUTE_DOWNLOAD, "\"0-n\"");

    unsigned char STAT_PERCENT_COMPLETE_WERT = (RXBUF_UCHAR(1));
        // Completion of route download in percent / Fertigstellung Route Download in Prozent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ROUTE_DOWNLOAD", "STAT_PERCENT_COMPLETE_WERT", STAT_PERCENT_COMPLETE_WERT, "\"%\"");

    unsigned short STAT_AVAILABLE_DATASETS_WERT = (RXBUF_UINT(2));
        // Number of available records / Anzahl verfügbarer Datensätze
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_ROUTE_DOWNLOAD", "STAT_AVAILABLE_DATASETS_WERT", STAT_AVAILABLE_DATASETS_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_ADAS: {                                                  // 0xD067
    if (datalen < 17) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_ADAS", 17);
        break;
    }

    unsigned short STAT_LIFECYCLE_DURATION_WERT = (RXBUF_UINT(0));
        // Duration of the lifecycle in minutes / Dauer des Lifecycles in Minuten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_ADAS", "STAT_LIFECYCLE_DURATION_WERT", STAT_LIFECYCLE_DURATION_WERT, "");

    unsigned char STAT_RECEIVED_RESYNCS_ACC_WERT = (RXBUF_UCHAR(2));
        // Number of resyncs that have been received from the ACC ECU / Number of resyncs that have been received from
        // the ACC ECU
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_RECEIVED_RESYNCS_ACC_WERT", STAT_RECEIVED_RESYNCS_ACC_WERT, "");

    unsigned char STAT_RECEIVED_RESYNCS_NIVI_WERT = (RXBUF_UCHAR(3));
        // Number of resyncs that have been received from the Night Vision ECU / Number of resyncs that have been
        // received from the Night Vision ECU
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_RECEIVED_RESYNCS_NIVI_WERT", STAT_RECEIVED_RESYNCS_NIVI_WERT, "");

    unsigned char STAT_RECEIVED_RESYNCS_LDM_WERT = (RXBUF_UCHAR(4));
        // Number of resyncs that have been received from the LDM ECU / Number of resyncs that have been received from
        // the LDM ECU
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_RECEIVED_RESYNCS_LDM_WERT", STAT_RECEIVED_RESYNCS_LDM_WERT, "");

    unsigned char STAT_RECEIVED_RESYNCS_ICM_QL_WERT = (RXBUF_UCHAR(5));
        // Number of resyncs that have been received from the ICM Q / L ECU / Number of resyncs that have been received
        // from the ICM Q/L ECU
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_RECEIVED_RESYNCS_ICM_QL_WERT", STAT_RECEIVED_RESYNCS_ICM_QL_WERT, "");

    unsigned char STAT_RECEIVED_RESYNCS_KAFAS_WERT = (RXBUF_UCHAR(6));
        // Number of resyncs that have been received from the KAFAS ECU / Number of resyncs that have been received from
        // the KAFAS ECU
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_RECEIVED_RESYNCS_KAFAS_WERT", STAT_RECEIVED_RESYNCS_KAFAS_WERT, "");

    unsigned char STAT_RECEIVED_RESYNCS_FLA_WERT = (RXBUF_UCHAR(7));
        // Number of resyncs that have been received from the FLA ECU / Number of resyncs that have been received from
        // the FLA ECU
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_RECEIVED_RESYNCS_FLA_WERT", STAT_RECEIVED_RESYNCS_FLA_WERT, "");

    unsigned char STAT_RECEIVED_RESYNCS_FRMFA_WERT = (RXBUF_UCHAR(8));
        // Number of resyncs that have been received from the FRMFA ECU / Number of resyncs that have been received from
        // the FRMFA ECU
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_RECEIVED_RESYNCS_FRMFA_WERT", STAT_RECEIVED_RESYNCS_FRMFA_WERT, "");

    unsigned char STAT_SENT_NAVGRAPH_WERT = (RXBUF_UCHAR(9));
        // Number of NavGraph messages that have been sent / Number of NavGraph messages that have been sent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_SENT_NAVGRAPH_WERT", STAT_SENT_NAVGRAPH_WERT, "");

    unsigned char STAT_SENT_NAVGRAPH_V_WERT = (RXBUF_UCHAR(10));
        // Number of NavGraph extended speed messages that have been sent / Number of NavGraph extended speed messages
        // that have been sent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_SENT_NAVGRAPH_V_WERT", STAT_SENT_NAVGRAPH_V_WERT, "");

    unsigned char STAT_SENT_NAVGRAPH_LNE_WERT = (RXBUF_UCHAR(11));
        // Number of NavGraph extended lane messages that have been sent / Number of NavGraph extended lane messages that
        // have been sent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_SENT_NAVGRAPH_LNE_WERT", STAT_SENT_NAVGRAPH_LNE_WERT, "");

    unsigned char STAT_SENT_NAVGRAPHSYNC_WERT = (RXBUF_UCHAR(12));
        // Number of NavGraphSync messages that have been sent / Number of NavGraphSync messages that have been sent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_SENT_NAVGRAPHSYNC_WERT", STAT_SENT_NAVGRAPHSYNC_WERT, "");

    unsigned char STAT_SENT_NAVGPS1_WERT = (RXBUF_UCHAR(13));
        // Number of NavGPS1 messages that have been sent / Number of NavGPS1 messages that have been sent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_SENT_NAVGPS1_WERT", STAT_SENT_NAVGPS1_WERT, "");

    unsigned char STAT_SENT_NAVGPS2_WERT = (RXBUF_UCHAR(14));
        // Number of NavGPS2 messages that have been sent / Number of NavGPS2 messages that have been sent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_SENT_NAVGPS2_WERT", STAT_SENT_NAVGPS2_WERT, "");

    unsigned char STAT_SENT_NAVSYSINFO_WERT = (RXBUF_UCHAR(15));
        // Number of NavSysInfo messages that have been sent / Number of NavSysInfo messages that have been sent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_SENT_NAVSYSINFO_WERT", STAT_SENT_NAVSYSINFO_WERT, "");

    unsigned char STAT_SENT_NAVGRAPHMATCH_WERT = (RXBUF_UCHAR(16));
        // Number of NavGraphMatch messages that have been sent / Number of NavGraphMatch messages that have been sent
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_ADAS", "STAT_SENT_NAVGRAPHMATCH_WERT", STAT_SENT_NAVGRAPHMATCH_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_TDA_AKTIVIERUNG: {                                       // 0xD091
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_TDA_AKTIVIERUNG", 1);
        break;
    }

    unsigned char STAT_DIENSTE_AKTIVIERUNG = (RXBUF_UCHAR(0));
        // Status of TDA BMW services / Status TDA BMW Dienste
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_TDA_AKTIVIERUNG", "STAT_DIENSTE_AKTIVIERUNG", STAT_DIENSTE_AKTIVIERUNG, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_TIME_AFTER_STARTUP: {                                    // 0xD092
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_TIME_AFTER_STARTUP", 3);
        break;
    }

    unsigned char STAT_TIME_AFTER_START_UP_WERT = (RXBUF_UCHAR(0));
        // Values from 0-255 [s], which indicate how much time has passed since booting (waking up) / Werte von 0-255
        // [s], die angeben, wie viel Zeit seit dem Hochstarten (Aufwecken) vergangen ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_TIME_AFTER_STARTUP", "STAT_TIME_AFTER_START_UP_WERT", STAT_TIME_AFTER_START_UP_WERT, "\"s\"");

    char STAT_TIME_AFTER_POWER_DOWN_AVAILABLE_WERT = (RXBUF_SCHAR(1));
        // Values from 0-127 [s], which indicate how much time has passed since the internal traffic jam was reached, to
        // execute a powerdown immediately. -1 means 'not yet reached' / Werte von 0-127 [s], die angeben, wie viel Zeit
        // vergangen ist, seit dem intern der Staus erreicht wurde, sofort einen Powerdown auszuführen. -1 bedeutet 'noch
        // nicht erreicht'
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_TIME_AFTER_STARTUP", "STAT_TIME_AFTER_POWER_DOWN_AVAILABLE_WERT", STAT_TIME_AFTER_POWER_DOWN_AVAILABLE_WERT, "\"s\"");

    char STAT_TIME_AFTER_FULLY_OPERATIONAL_WERT = (RXBUF_SCHAR(2));
        // Values from 0-127 [s], which indicate how much time has passed since the internal traffic jam 'fully started'
        // was reached. -1 means 'not yet reached' / Werte von 0-127 [s], die angeben, wie viel Zeit vergangen ist, seit
        // dem intern der Staus 'vollständig aufgestartet' erreicht wurde. -1 bedeutet 'noch nicht erreicht'
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_TIME_AFTER_STARTUP", "STAT_TIME_AFTER_FULLY_OPERATIONAL_WERT", STAT_TIME_AFTER_FULLY_OPERATIONAL_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_FM_PHASDIV_ANTENNA: {                                    // 0xD093
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_FM_PHASDIV_ANTENNA", 2);
        break;
    }

    unsigned char STAT_FM_PHASEDIV_ANTENNA1 = (RXBUF_UCHAR(0));
        // Status FM 1 phase diversity antenna. For the result, see table TAB_stateFMPhasAntenna / Status FM 1
        // Phasendiversity Antenne. Ergebnis siehe Tabelle TAB_stateFMPhasAntenna
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_FM_PHASDIV_ANTENNA", "STAT_FM_PHASEDIV_ANTENNA1", STAT_FM_PHASEDIV_ANTENNA1, "\"0-n\"");

    unsigned char STAT_FM_PHASEDIV_ANTENNA2 = (RXBUF_UCHAR(1));
        // Status FM 2 phase diversity antenna. For the result, see table TAB_stateFMPhasAntenna / Status FM 2
        // Phasendiversity Antenne. Ergebnis siehe Tabelle TAB_stateFMPhasAntenna
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_FM_PHASDIV_ANTENNA", "STAT_FM_PHASEDIV_ANTENNA2", STAT_FM_PHASEDIV_ANTENNA2, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_BT_FIRMWARE: {                                           // 0xD095
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_BT_FIRMWARE", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_HD_DECODER_FIRMWARE: {                                          // 0xD0B8
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_HD_DECODER_FIRMWARE", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ABLAUF_ZERTIFIKAT: {                                            // 0xD0B9
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_ABLAUF_ZERTIFIKAT", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_COOKIES: {                                                      // 0xD0BA
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_COOKIES", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_COUNTER_FILES_MUSICDB: {                                        // 0xD0C1
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_COUNTER_FILES_MUSICDB", 4);
        break;
    }

    unsigned long STAT_MUSICDB_STORED_FILES_WERT = (RXBUF_UINT32(0));
        // Number of files stored in the music DB / Anzahl der Dateien die in der Musik DB gespeichert sind
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "COUNTER_FILES_MUSICDB", "STAT_MUSICDB_STORED_FILES_WERT", STAT_MUSICDB_STORED_FILES_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ZIN_CENTRAL_INSTRUMENT: {                                       // 0xD0C9
    if (datalen < 9) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_ZIN_CENTRAL_INSTRUMENT", 9);
        break;
    }

    unsigned char STAT_HW_INDEX_WERT = (RXBUF_UCHAR(0));
        // Hardware version value / Wert der Hardware-Version
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_CENTRAL_INSTRUMENT", "STAT_HW_INDEX_WERT", STAT_HW_INDEX_WERT, "");

    unsigned char STAT_SW_INDEX_WERT = (RXBUF_UCHAR(1));
        // Software version value / Wert der Software-Version
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_CENTRAL_INSTRUMENT", "STAT_SW_INDEX_WERT", STAT_SW_INDEX_WERT, "");

    unsigned char STAT_CRC_COUNTER_WERT = (RXBUF_UCHAR(2));
        // Number of CRC errors detected / Anzahl der erkannten CRC-Fehler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_CENTRAL_INSTRUMENT", "STAT_CRC_COUNTER_WERT", STAT_CRC_COUNTER_WERT, "");

    unsigned long STAT_SERIAL_NUMBER_WERT = (RXBUF_UINT32(3));
        // Serial number of the central instrument / Seriennummer des Zentralinstruments
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "ZIN_CENTRAL_INSTRUMENT", "STAT_SERIAL_NUMBER_WERT", STAT_SERIAL_NUMBER_WERT, "");

    unsigned char STAT_DIAGNOSTIC_FLAGS = (RXBUF_UCHAR(7));
        // Returns the status of the central instrument. Values from the table TAB_ZIN_DIAGNOSTIC_FLAG / Gibt den Status
        // des Zentralinstruments zurück Werte aus der Tabelle TAB_ZIN_DIAGNOSTIC_FLAG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_CENTRAL_INSTRUMENT", "STAT_DIAGNOSTIC_FLAGS", STAT_DIAGNOSTIC_FLAGS, "\"0-n\"");

    unsigned char STAT_ZIN_VARIANT = (RXBUF_UCHAR(8));
        // Reports the variant of the central instrument used / Reports the variant of the used central instrument
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_CENTRAL_INSTRUMENT", "STAT_ZIN_VARIANT", STAT_ZIN_VARIANT, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ZIN_EVENT_QUEUE: {                                              // 0xD0CA
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_ZIN_EVENT_QUEUE", 7);
        break;
    }

    unsigned char STAT_EVENT_ID_0_WERT = (RXBUF_UCHAR(0));
        // first event ID / erste Event ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_EVENT_QUEUE", "STAT_EVENT_ID_0_WERT", STAT_EVENT_ID_0_WERT, "");

    unsigned char STAT_EVENT_ID_1_WERT = (RXBUF_UCHAR(1));
        // second event ID / zweite Event ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_EVENT_QUEUE", "STAT_EVENT_ID_1_WERT", STAT_EVENT_ID_1_WERT, "");

    unsigned char STAT_EVENT_ID_2_WERT = (RXBUF_UCHAR(2));
        // third event ID / dritte Event ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_EVENT_QUEUE", "STAT_EVENT_ID_2_WERT", STAT_EVENT_ID_2_WERT, "");

    unsigned char STAT_EVENT_ID_3_WERT = (RXBUF_UCHAR(3));
        // fourth event ID / vierte Event ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_EVENT_QUEUE", "STAT_EVENT_ID_3_WERT", STAT_EVENT_ID_3_WERT, "");

    unsigned char STAT_EVENT_ID_4_WERT = (RXBUF_UCHAR(4));
        // fifth event ID / fünfte Event ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_EVENT_QUEUE", "STAT_EVENT_ID_4_WERT", STAT_EVENT_ID_4_WERT, "");

    unsigned char STAT_EVENT_ID_5_WERT = (RXBUF_UCHAR(5));
        // sixth event ID / sechste Event ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_EVENT_QUEUE", "STAT_EVENT_ID_5_WERT", STAT_EVENT_ID_5_WERT, "");

    unsigned char STAT_EVENT_ID_6_WERT = (RXBUF_UCHAR(6));
        // seventh event ID / siebte Event ID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_EVENT_QUEUE", "STAT_EVENT_ID_6_WERT", STAT_EVENT_ID_6_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_ZIN_INTERNAL_STATES: {                                          // 0xD0CB
    if (datalen < 23) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_ZIN_INTERNAL_STATES", 23);
        break;
    }

    unsigned char STAT_CURRENT_WIDGET_ID_WERT = (RXBUF_UCHAR(0));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_CURRENT_WIDGET_ID_WERT", STAT_CURRENT_WIDGET_ID_WERT, "");

    unsigned char STAT_NEXT_WIDGET_ID_PRIO_1_WERT = (RXBUF_UCHAR(1));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_NEXT_WIDGET_ID_PRIO_1_WERT", STAT_NEXT_WIDGET_ID_PRIO_1_WERT, "");

    unsigned char STAT_NEXT_WIDGET_ID_PRIO_2_WERT = (RXBUF_UCHAR(2));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_NEXT_WIDGET_ID_PRIO_2_WERT", STAT_NEXT_WIDGET_ID_PRIO_2_WERT, "");

    unsigned char STAT_NEXT_WIDGET_ID_PRIO_3_WERT = (RXBUF_UCHAR(3));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_NEXT_WIDGET_ID_PRIO_3_WERT", STAT_NEXT_WIDGET_ID_PRIO_3_WERT, "");

    unsigned char STAT_SW_MAJOR_VERSION_WERT = (RXBUF_UCHAR(4));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_SW_MAJOR_VERSION_WERT", STAT_SW_MAJOR_VERSION_WERT, "");

    unsigned char STAT_SW_MINOR_VERSION_WERT = (RXBUF_UCHAR(5));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_SW_MINOR_VERSION_WERT", STAT_SW_MINOR_VERSION_WERT, "");

    unsigned char STAT_SW_PATCH_VERSION_WERT = (RXBUF_UCHAR(6));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_SW_PATCH_VERSION_WERT", STAT_SW_PATCH_VERSION_WERT, "");

    unsigned char STAT_TARGET_BRIGHTNESS_WERT = (RXBUF_UCHAR(7));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_TARGET_BRIGHTNESS_WERT", STAT_TARGET_BRIGHTNESS_WERT, "");

    char STAT_LED_RING_OFFSET_BRIGHTNESS_WERT = (RXBUF_SCHAR(8));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_LED_RING_OFFSET_BRIGHTNESS_WERT", STAT_LED_RING_OFFSET_BRIGHTNESS_WERT, "");

    unsigned short STAT_CURRENT_PWM_OUTPUT_VALUE_WERT = (RXBUF_UINT(9));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_CURRENT_PWM_OUTPUT_VALUE_WERT", STAT_CURRENT_PWM_OUTPUT_VALUE_WERT, "");

    unsigned char STAT_LED_RING_SWITCH_WERT = (RXBUF_UCHAR(11));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_LED_RING_SWITCH_WERT", STAT_LED_RING_SWITCH_WERT, "");

    unsigned char STAT_PERMANENT_SWITCH_WERT = (RXBUF_UCHAR(12));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_PERMANENT_SWITCH_WERT", STAT_PERMANENT_SWITCH_WERT, "");

    unsigned char STAT_PERMANENT_DISPLAYS_WERT = (RXBUF_UCHAR(13));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_PERMANENT_DISPLAYS_WERT", STAT_PERMANENT_DISPLAYS_WERT, "");

    unsigned char STAT_ANIMATION_SWITCH_WERT = (RXBUF_UCHAR(14));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_ANIMATION_SWITCH_WERT", STAT_ANIMATION_SWITCH_WERT, "");

    unsigned long STAT_ANIMATION_DISPLAYS_WERT = (RXBUF_UINT32(15));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_ANIMATION_DISPLAYS_WERT", STAT_ANIMATION_DISPLAYS_WERT, "");

    unsigned char STAT_ANAIMATION_TRIGGER_EVENT_WERT = (RXBUF_UCHAR(19));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_ANAIMATION_TRIGGER_EVENT_WERT", STAT_ANAIMATION_TRIGGER_EVENT_WERT, "");

    unsigned char STAT_SEMI_PER_EVENT_ID_WERT = (RXBUF_UCHAR(20));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_SEMI_PER_EVENT_ID_WERT", STAT_SEMI_PER_EVENT_ID_WERT, "");

    unsigned char STAT_SEMI_PER_EVENT_PRIO_WERT = (RXBUF_UCHAR(21));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_SEMI_PER_EVENT_PRIO_WERT", STAT_SEMI_PER_EVENT_PRIO_WERT, "");

    unsigned char STAT_SEMI_PER_EVENT_TRIGGER_WERT = (RXBUF_UCHAR(22));
        // - / -
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "ZIN_INTERNAL_STATES", "STAT_SEMI_PER_EVENT_TRIGGER_WERT", STAT_SEMI_PER_EVENT_TRIGGER_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_PROVISIONING_PARAMETER: {                                       // 0xD0CE
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_PROVISIONING_PARAMETER", 8);
        break;
    }

    unsigned short STAT_CAUSE_WERT = (RXBUF_UINT(6));
        // Cause value The value indicates the trigger for the provisioning. 0: Required access data is missing in the
        // DASAS data 1: A required OTAAS is expired 2: Update request by user via the HMI 3: Application trigger 4: The
        // PINGUIN triggered the provisioning 5: ACM triggered provisioning on DPAS Mode 6: Provisioning via Diagnosis /
        // Cause Wert Der Wert gibt den Auslöser der Provisionierung an. 0: Required access data is missing in the DASAS
        // data 1: A required OTAAS is expired 2: Update request by user via the HMI  3: Application trigger 4: The
        // PINGUIN triggered the provisioning  5: ACM triggered provisioning on DPAS Mode 6: Provisioning via Diagnosis
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "PROVISIONING_PARAMETER", "STAT_CAUSE_WERT", STAT_CAUSE_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_MEDIA_STATISTIK: {                                              // 0xD0D1
    if (datalen < 36) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_MEDIA_STATISTIK", 36);
        break;
    }

    unsigned long STAT_COUNTER_MEDIA_WERT = (RXBUF_UINT32(0));
        // Number of media inserted in the internal CD / DVD drive / Anzahl der eingelegten Medien des internen CD /
        // DVD-Laufwerks
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "MEDIA_STATISTIK", "STAT_COUNTER_MEDIA_WERT", STAT_COUNTER_MEDIA_WERT, "");

    unsigned long STAT_COUNTER_AUDIO_CDS_WERT = (RXBUF_UINT32(4));
        // Number of audio CDs (CDDA) inserted in the internal CD / DVD drive / Anzahl der eingelegten Audio-CDs (CDDA)
        // des internen CD / DVD-Laufwerks
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "MEDIA_STATISTIK", "STAT_COUNTER_AUDIO_CDS_WERT", STAT_COUNTER_AUDIO_CDS_WERT, "");

    unsigned long STAT_COUNTER_CD_ROM_WERT = (RXBUF_UINT32(8));
        // Number of inserted audio CD-ROMs (CD-R / -RW, DVD-R / -RW / + R / + RW ...) of the internal CD / DVD drive /
        // Anzahl der eingelegten Audio-CD-ROMs (CD-R/-RW, DVD-R/-RW / + R / + RW ...) des internen CD / DVD-Laufwerks
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "MEDIA_STATISTIK", "STAT_COUNTER_CD_ROM_WERT", STAT_COUNTER_CD_ROM_WERT, "");

    unsigned long STAT_COUNTER_DVD_VIDEO_WERT = (RXBUF_UINT32(12));
        // Number of video DVDs inserted in the internal CD / DVD drive / Anzahl der eingelegten Video-DVDs des internen
        // CD / DVD-Laufwerks
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "MEDIA_STATISTIK", "STAT_COUNTER_DVD_VIDEO_WERT", STAT_COUNTER_DVD_VIDEO_WERT, "");

    unsigned long STAT_COUNTER_BLURAY_WERT = (RXBUF_UINT32(16));
        // Number of inserted Blu-ray disks of the internal Blu-ray drive / Number of inserted Blu-ray-disks of the
        // internal Blu-ray drive
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "MEDIA_STATISTIK", "STAT_COUNTER_BLURAY_WERT", STAT_COUNTER_BLURAY_WERT, "");

    unsigned long STAT_RECOGNIZED_AUDIO_CDS_WERT = (RXBUF_UINT32(20));
        // Number of audio CDs recognized by the Gracenote DB / Anzahl der Audio-CDs die von der Gracenote DB erkannt
        // wurden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "MEDIA_STATISTIK", "STAT_RECOGNIZED_AUDIO_CDS_WERT", STAT_RECOGNIZED_AUDIO_CDS_WERT, "");

    unsigned long STAT_ERROR_DURING_PLAYBACK_WERT = (RXBUF_UINT32(24));
        // Number of files that caused playback problems / Anzahl der Dateien, die Probleme bei der Wiedergabe
        // verursachten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "MEDIA_STATISTIK", "STAT_ERROR_DURING_PLAYBACK_WERT", STAT_ERROR_DURING_PLAYBACK_WERT, "");

    unsigned short STAT_PLAYBACK_TIME_CD_WERT = (RXBUF_UINT(28));
        // playback time for using the CD drive / playback time for using the CD drive
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "MEDIA_STATISTIK", "STAT_PLAYBACK_TIME_CD_WERT", STAT_PLAYBACK_TIME_CD_WERT, "");

    unsigned short STAT_PLAYBACK_TIME_DVD_WERT = (RXBUF_UINT(30));
        // playback time for using the DVD drive / playback time for using the DVD drive
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "MEDIA_STATISTIK", "STAT_PLAYBACK_TIME_DVD_WERT", STAT_PLAYBACK_TIME_DVD_WERT, "");

    unsigned short STAT_PLAYBACK_TIME_BLURAY_WERT = (RXBUF_UINT(32));
        // Playback time while using the Blu-ray drive in hours / Playback time while using the Blu-ray drive in hours
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "MEDIA_STATISTIK", "STAT_PLAYBACK_TIME_BLURAY_WERT", STAT_PLAYBACK_TIME_BLURAY_WERT, "");

    unsigned short STAT_INSERT_EJECT_COUNT_WERT = (RXBUF_UINT(34));
        // counter for insert or eject a medium into a CD / DVD drive / counter for insert or eject a medium into a CD/
        // DVD drive
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "MEDIA_STATISTIK", "STAT_INSERT_EJECT_COUNT_WERT", STAT_INSERT_EJECT_COUNT_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_PROVISIONING_DATA: {                                            // 0xD0D3
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_PROVISIONING_DATA", 1);
        break;
    }

    unsigned char STAT_PROVISIONING_0XD0D3 = (RXBUF_UCHAR(0));
        // Status of the writing process of the provisioning data. / Status vom Schreibvorgang der Provisionierungsdaten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "PROVISIONING_DATA", "STAT_PROVISIONING_0XD0D3", STAT_PROVISIONING_0XD0D3, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_LAST_DESTINATIONS_FIRST_DATA_SET: {                      // 0xD0D6
    if (datalen < 176) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_LAST_DESTINATIONS_FIRST_DATA_SET", 176);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SDARS_RADIO_ID: {                                        // 0xD0DA
    if (datalen < 12) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SDARS_RADIO_ID", 12);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_SDARS_VERSIONS: {                                               // 0xD0DD
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_SDARS_VERSIONS", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SDARS_SIGNAL_QUALITY_SXM: {                              // 0xD0DF
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SDARS_SIGNAL_QUALITY_SXM", 2);
        break;
    }

    unsigned char STAT_SDARS_COMP_RECEPTION_SXM = (RXBUF_UCHAR(0));
        // Composite reception quality as integer / Composite reception quality as integer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SDARS_SIGNAL_QUALITY_SXM", "STAT_SDARS_COMP_RECEPTION_SXM", STAT_SDARS_COMP_RECEPTION_SXM, "\"0-n\"");

    unsigned char STAT_SDARS_GLOBAL_STATUS = (RXBUF_UCHAR(1));
        // Global status as integer / Global status as integer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SDARS_SIGNAL_QUALITY_SXM", "STAT_SDARS_GLOBAL_STATUS", STAT_SDARS_GLOBAL_STATUS, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_LAST_DESTINATIONS_SECOND_DATA_SET: {                     // 0xD0E0
    if (datalen < 113) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_LAST_DESTINATIONS_SECOND_DATA_SET", 113);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_DRIVE: {                                                 // 0xD0E2
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_DRIVE", 1);
        break;
    }

    unsigned char STAT_MEDIUM_INSERTED = (RXBUF_UCHAR(0));
        // Information if and what type of medium is inserted into drive as integer / Information if and what type of
        // medium is inserted into drive as integer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_DRIVE", "STAT_MEDIUM_INSERTED", STAT_MEDIUM_INSERTED, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_BORDERLINE_SETTING: {                                    // 0xD0E5
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_BORDERLINE_SETTING", 3);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_BORDERLINE_CHANGE_MODE: {                                // 0xD0E8
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_BORDERLINE_CHANGE_MODE", 1);
        break;
    }

    unsigned char STAT_BORDERLINE_CHANGE_MODE = (RXBUF_UCHAR(0));
        // returns if a borderline is set to mode<automatic> or<manual> / returns if a borderline is set to mode
        // <automatic> or <manual>
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_BORDERLINE_CHANGE_MODE", "STAT_BORDERLINE_CHANGE_MODE", STAT_BORDERLINE_CHANGE_MODE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SDARS_PELLET_LESEN: {                                    // 0xD0E9
    if (datalen < 100) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SDARS_PELLET_LESEN", 100);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_PROVISIONING_FORMAT: {                                          // 0xD0EB
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_PROVISIONING_FORMAT", 1);
        break;
    }

    unsigned char STAT_STAT_SIGNATURE = (RXBUF_UCHAR(0));
        // is used to understand a signed provisioning file / dient dazu, eine signierte Bereitstellungsdatei zu
        // verstehen 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "PROVISIONING_FORMAT", "STAT_STAT_SIGNATURE", STAT_STAT_SIGNATURE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_WLAN_AUSSTATTUNG: {                                             // 0xD1FA
    if (datalen < 4) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_WLAN_AUSSTATTUNG", 4);
        break;
    }

    unsigned char STAT_WLAN_CODED = (RXBUF_UCHAR(0));
        // WLAN encoded if at least 1 of the following values STAT_WLAN_AP_SA, STAT_WLAN_WIFI_DIRECT_SA or
        // STAT_WLAN_STATION_SA is active / WLAN codiert, wenn mindestens 1 der folgenden Wert STAT_WLAN_AP_SA,
        // STAT_WLAN_WIFI_DIRECT_SA oder STAT_WLAN_STATION_SA aktiv ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_AUSSTATTUNG", "STAT_WLAN_CODED", STAT_WLAN_CODED, "\"0-n\"");

    unsigned char STAT_WLAN_AP_SA = (RXBUF_UCHAR(1));
        // WLAN AP / WLAN AP
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_AUSSTATTUNG", "STAT_WLAN_AP_SA", STAT_WLAN_AP_SA, "\"0-n\"");

    unsigned char STAT_WLAN_WIFI_DIRECT_SA = (RXBUF_UCHAR(2));
        // WLAN Wifi Direct / WLAN Wifi Direct 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_AUSSTATTUNG", "STAT_WLAN_WIFI_DIRECT_SA", STAT_WLAN_WIFI_DIRECT_SA, "\"0-n\"");

    unsigned char STAT_WLAN_STATION_SA = (RXBUF_UCHAR(3));
        // WLAN station / WLAN Station 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_AUSSTATTUNG", "STAT_WLAN_STATION_SA", STAT_WLAN_STATION_SA, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_WLAN_DEVICELIST_WIFI_DIRECT: {                                  // 0xD1FC
    if (datalen < 48) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_WLAN_DEVICELIST_WIFI_DIRECT", 48);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_USB_TEST: {                                                     // 0xD207
    if (datalen < 21) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_USB_TEST", 21);
        break;
    }

    unsigned char STAT_USB_HUB_KDZ_CODING = (RXBUF_UCHAR(0));
        // Status of whether a USB HUB is installed between HU and KDZ; depends on the coding test / Status, ob ein
        // USB-HUB zwischen HU und KDZ installiert ist; hängt von der Codierprüfung ab
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "USB_TEST", "STAT_USB_HUB_KDZ_CODING", STAT_USB_HUB_KDZ_CODING, "\"0-n\"");

    unsigned char STAT_USB_TEST_HUB = (RXBUF_UCHAR(1));
        // Status of the USB interface test / Status des USB-Interface-Tests
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "USB_TEST", "STAT_USB_TEST_HUB", STAT_USB_TEST_HUB, "\"0-n\"");

    unsigned short STAT_VENDORID_HUB_WERT = (RXBUF_UINT(2));
        // VendorID that is issued by the USB interface / VendorID, dass von der USB Schnittstelle ausgegeben wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "USB_TEST", "STAT_VENDORID_HUB_WERT", STAT_VENDORID_HUB_WERT, "\"HEX\"");

    unsigned short STAT_PRODUCTID_HUB_WERT = (RXBUF_UINT(4));
        // Predefined ProductID that is output for the device from the USB interface / vorgegebene ProductID, die für das
        // Gerät von der USB Schnittstelle ausgegeben wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "USB_TEST", "STAT_PRODUCTID_HUB_WERT", STAT_PRODUCTID_HUB_WERT, "\"HEX\"");

    unsigned char STAT_USB_TEST_KDZ1 = (RXBUF_UCHAR(6));
        // Status of the USB interface test / Status des USB-Interface-Tests
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "USB_TEST", "STAT_USB_TEST_KDZ1", STAT_USB_TEST_KDZ1, "\"0-n\"");

    unsigned short STAT_VENDORID_KDZ1_WERT = (RXBUF_UINT(7));
        // VendorID that is issued by the USB interface / VendorID, die von der USB Schnittstelle ausgegeben wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "USB_TEST", "STAT_VENDORID_KDZ1_WERT", STAT_VENDORID_KDZ1_WERT, "\"HEX\"");

    unsigned short STAT_PRODUCTID_KDZ1_WERT = (RXBUF_UINT(9));
        // Predefined ProductID that is output for the device from the USB interface / vorgegebene ProductID, die für das
        // Gerät von der USB Schnittstelle ausgegeben wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "USB_TEST", "STAT_PRODUCTID_KDZ1_WERT", STAT_PRODUCTID_KDZ1_WERT, "\"HEX\"");

    unsigned char STAT_USB_TEST_KDZ2 = (RXBUF_UCHAR(11));
        // Status of the USB interface test / Status des USB-Interface-Tests
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "USB_TEST", "STAT_USB_TEST_KDZ2", STAT_USB_TEST_KDZ2, "\"0-n\"");

    unsigned short STAT_VENDORID_KDZ2_WERT = (RXBUF_UINT(12));
        // VendorID that is issued by the USB interface / VendorID, die von der USB Schnittstelle ausgegeben wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "USB_TEST", "STAT_VENDORID_KDZ2_WERT", STAT_VENDORID_KDZ2_WERT, "\"HEX\"");

    unsigned short STAT_PRODUCTID_KDZ2_WERT = (RXBUF_UINT(14));
        // Predefined ProductID that is output for the device from the USB interface / vorgegebene ProductID, die für das
        // Gerät von der USB Schnittstelle ausgegeben wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "USB_TEST", "STAT_PRODUCTID_KDZ2_WERT", STAT_PRODUCTID_KDZ2_WERT, "\"HEX\"");

    unsigned char STAT_USB_TEST_SIA = (RXBUF_UCHAR(16));
        // Result of the Snap In Adpater test / Ergebnis des Snap In Adpater Tests
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "USB_TEST", "STAT_USB_TEST_SIA", STAT_USB_TEST_SIA, "\"0-n\"");

    unsigned short STAT_VENDORID_SIA_WERT = (RXBUF_UINT(17));
        // recognized VendorID of the device from the USB interface is output / erkannte VendorID des Gerätes von der USB
        // Schnittstelle wird ausgegeben
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "USB_TEST", "STAT_VENDORID_SIA_WERT", STAT_VENDORID_SIA_WERT, "\"HEX\"");

    unsigned short STAT_PRODUCTID_SIA_WERT = (RXBUF_UINT(19));
        //  recognized ProductID of the device from the USB interface is output /  erkannte ProductID des Gerätes von der
        // USB Schnittstelle wird ausgegeben
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "USB_TEST", "STAT_PRODUCTID_SIA_WERT", STAT_PRODUCTID_SIA_WERT, "\"HEX\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_WLAN_AP_NETWORK: {                                              // 0xD20E
    if (datalen < 97) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_WLAN_AP_NETWORK", 97);
        break;
    }

    unsigned char STAT_WLAN_AP_ENCRYPTION = (RXBUF_UCHAR(32));
        // Type of encryption from the AP network / Typ der Verschlüsselung vom AP Netzwerk
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_AP_NETWORK", "STAT_WLAN_AP_ENCRYPTION", STAT_WLAN_AP_ENCRYPTION, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_TOUCH_COMMAND_NUMBER: {                                         // 0xD26A
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_TOUCH_COMMAND_NUMBER", 2);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_CID_PHOTOSENSOR: {                                              // 0xD5CB
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_CID_PHOTOSENSOR", 2);
        break;
    }

    short STAT_PHOTOSENSOR_CID_WERT = (RXBUF_SINT(0));
        // Analog value phototransistor in the CID / Analogwert Fototransistor im CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%d%s\n", "NBT", "CID_PHOTOSENSOR", "STAT_PHOTOSENSOR_CID_WERT", STAT_PHOTOSENSOR_CID_WERT, "\"lx\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_CID_TEMP_BACKLIGHT: {                                           // 0xD5CC
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_CID_TEMP_BACKLIGHT", 1);
        break;
    }

    char STAT_TEMP_BACKLIGHT_WERT = (RXBUF_SCHAR(0));
        // Temperature backlight / Temperatur Hintergrundbeleuchtung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_TEMP_BACKLIGHT", "STAT_TEMP_BACKLIGHT_WERT", STAT_TEMP_BACKLIGHT_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_CID_HELLIGKEIT_SOLLWERT: {                                      // 0xD5CD
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_CID_HELLIGKEIT_SOLLWERT", 1);
        break;
    }

    char STAT_HELLIGKEIT_SOLL_WERT = (RXBUF_SCHAR(0));
        // Setpoint brightness value from the dimming module / Soll-Helligkeitswert vom Dimm-Modul
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_HELLIGKEIT_SOLLWERT", "STAT_HELLIGKEIT_SOLL_WERT", STAT_HELLIGKEIT_SOLL_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_CID_HELLIGKEIT_ISTWERT: {                                       // 0xD5CE
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_CID_HELLIGKEIT_ISTWERT", 1);
        break;
    }

    char STAT_HELLIGKEIT_IST_WERT = (RXBUF_SCHAR(0));
        // Actual brightness value / Ist-Helligkeitswert
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_HELLIGKEIT_ISTWERT", "STAT_HELLIGKEIT_IST_WERT", STAT_HELLIGKEIT_IST_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_CID_EINGANGSWERTE_LESEN: {                                      // 0xD5CF
    if (datalen < 5) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_CID_EINGANGSWERTE_LESEN", 5);
        break;
    }

    unsigned char STAT_DISPLAY_AKTIVIERUNG = (RXBUF_UCHAR(0));
        // Display activation [uint8, 0x0..0xF] (signal ENB_DISP from head unit) / Display-Aktivierung [uint8, 0x0..0xF] 
        // (Signal ENB_DISP von Head Unit)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_EINGANGSWERTE_LESEN", "STAT_DISPLAY_AKTIVIERUNG", STAT_DISPLAY_AKTIVIERUNG, "\"0-n\"");

    char STAT_OFFSET_HELLIGKEIT_WERT = (RXBUF_SCHAR(1));
        // Offset brightness [sint8, -127 .. + 127 = -100 .. + 100%, 128 = invalid, error value] (signal OFFS_BRIG_FRT
        // from head unit) / Offset Helligkeit [sint8, -127..+127 = -100..+100%, 128 = Ungültig, Fehlerwert]  (Signal
        // OFFS_BRIG_FRT von Head Unit)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_EINGANGSWERTE_LESEN", "STAT_OFFSET_HELLIGKEIT_WERT", STAT_OFFSET_HELLIGKEIT_WERT, "");

    unsigned char STAT_DIMMRAD_WERT = (RXBUF_UCHAR(2));
        // Dimming wheel position [uint8, 0..254 = 0-100%, 255 = FF = invalid, error value] (signal CTR_ILUM_SW) /
        // Dimmrad-Stellung [uint8, 0..254 = 0-100%, 255 = FF = Ungültig, Fehlerwert]  (Signal CTR_ILUM_SW)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_EINGANGSWERTE_LESEN", "STAT_DIMMRAD_WERT", STAT_DIMMRAD_WERT, "");

    unsigned char STAT_HELLIGKEIT_KOMBI_WERT = (RXBUF_UCHAR(3));
        // Brightness value I-combination brightness sensor [uint8, 0..254 = 0-100%, 255 = FF = invalid, error value]
        // (signal DSTN_LCD_LUM) / Helligkeitswert I-Kombi-Helligkeits-Sensor [uint8, 0..254  = 0-100%, 255 = FF =
        // Ungültig, Fehlerwert]  (Signal DSTN_LCD_LUM)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_EINGANGSWERTE_LESEN", "STAT_HELLIGKEIT_KOMBI_WERT", STAT_HELLIGKEIT_KOMBI_WERT, "");

    unsigned char STAT_DAEMPFUNG_LCD_WERT = (RXBUF_UCHAR(4));
        // Attenuation of LCD luminance [uint8, 0..240 = fast..slow, 241..254 = erratic, 255 = FF = invalid, error
        // value], speed of the brightness control. (Signal DMPNG_LCD_LUM) / Dämpfung LCD Leuchtdichte [uint8, 0..240 =
        // schnell..langsam, 241..254 = sprunghaft, 255 = FF = Ungültig, Fehlerwert], Geschwindigkeit der
        // Helligkeitsregelung. (Signal DMPNG_LCD_LUM)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_EINGANGSWERTE_LESEN", "STAT_DAEMPFUNG_LCD_WERT", STAT_DAEMPFUNG_LCD_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_CID_VERBINDUNG: {                                               // 0xD5D0
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_CID_VERBINDUNG", 1);
        break;
    }

    unsigned char STAT_CID_VERBINDUNG = (RXBUF_UCHAR(0));
        // Status of the CID connection: 0 = CID connection OK, image is displayed 1 = No activation of image output 2 =
        // Display device not ready for display 3 = No communication with display device 4 = Invalid image data 255 =
        // Invalid value (default after RESET) / Status der CID-Verbindung: 0 = CID-Verbindung in Ordnung, Bild wird
        // angezeigt 1 = Keine Aktivierung der Bildausgabe 2 = Anzeigegerät nicht anzeigebereit 3 = Keine Kommunikation
        // mit Anzeigegerät 4 = Bilddaten ungültig 255 = Ungültigkeitswert (Default nach RESET)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_VERBINDUNG", "STAT_CID_VERBINDUNG", STAT_CID_VERBINDUNG, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_CID_DETAIL_INFORMATIONEN: {                                     // 0xD5D4
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_CID_DETAIL_INFORMATIONEN", 8);
        break;
    }

    unsigned short STAT_CID_LOCATION_WERT = (RXBUF_UINT(0));
        // CID location / CID Location
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "CID_DETAIL_INFORMATIONEN", "STAT_CID_LOCATION_WERT", STAT_CID_LOCATION_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_EQDATA_FILENAME: {                                              // 0x4008
    if (datalen < 0) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_EQDATA_FILENAME", 0);
        break;
    }

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_SENSOR_WERTE: {                                          // 0x400A
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_SENSOR_WERTE", 8);
        break;
    }

    unsigned short STAT_AMB_SENSOR_WERT = (RXBUF_UINT(0));
        // Ambient brightness of the local CID sensor (Lux). Range: [0x0000¿0x03E8] 0¿1000 Lux 0xFFFF invalid or sensor
        // not implemented / Ambient brightness of the local CID sensor (Lux). Range: [0x0000¿0x03E8] 0¿1000 Lux 0xFFFF
        // invalid or sensor not implemented
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_SENSOR_WERTE", "STAT_AMB_SENSOR_WERT", STAT_AMB_SENSOR_WERT, "\"lx\"");

    char STAT_BL_TEMP_WERT = (RXBUF_SCHAR(2));
        // Currently measured temperature of the backlight temperature sensor. Range: [0xD8¿0x78] -40 ° C to 120 ° C 0x80
        // -128 ° C Sensor Failure / Currently measured temperature of the backlight temperature sensor. Range:
        // [0xD8¿0x78] -40°C bis  120°C 0x80 -128°C  Sensor Failure
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SENSOR_WERTE", "STAT_BL_TEMP_WERT", STAT_BL_TEMP_WERT, "\"°C\"");

    unsigned short STAT_VCC_VOLTAGE_WERT = (RXBUF_UINT(3));
        // Vcc voltage of the CID in steps of 1/10 V Range: [0x0000¿0xFFFE] 0xFFFF invalid / Vcc voltage of the CID in
        // steps of 1/10 V Range: [0x0000¿0xFFFE]  0xFFFF invalid
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_SENSOR_WERTE", "STAT_VCC_VOLTAGE_WERT", STAT_VCC_VOLTAGE_WERT, "");

    unsigned char STAT_BACKLIGT_DRIVER_WERT = (RXBUF_UCHAR(5));
        // Error status output pins of the backlight LED. Range: [0x00¿0x03] 0xFF invalid / Error status output pins of
        // the backlight LED. Range: [0x00¿0x03] 0xFF invalid
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_SENSOR_WERTE", "STAT_BACKLIGT_DRIVER_WERT", STAT_BACKLIGT_DRIVER_WERT, "");

    unsigned short STAT_INT_STATUS_WERT = (RXBUF_UINT(6));
        // Contents of the Indigo register ¿IntStatus' Range: [0x0000¿0xFFFF] / Contents of the Indigo register
        // ¿IntStatus' Range: [0x0000¿0xFFFF]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_SENSOR_WERTE", "STAT_INT_STATUS_WERT", STAT_INT_STATUS_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_CID_SW_VERSION: {                                        // 0x400E
    if (datalen < 3) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_CID_SW_VERSION", 3);
        break;
    }

    unsigned char STAT_MAJOR_VERSION_WERT = (RXBUF_UCHAR(0));
        // Major SW version of the CID / Major SW version of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_CID_SW_VERSION", "STAT_MAJOR_VERSION_WERT", STAT_MAJOR_VERSION_WERT, "");

    unsigned char STAT_MINOR_VERSION_WERT = (RXBUF_UCHAR(1));
        // Minor SW version of the CID / Minor SW version of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_CID_SW_VERSION", "STAT_MINOR_VERSION_WERT", STAT_MINOR_VERSION_WERT, "");

    unsigned char STAT_PATCH_VERSION_WERT = (RXBUF_UCHAR(2));
        // Patch version of the CID / Patch version of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_CID_SW_VERSION", "STAT_PATCH_VERSION_WERT", STAT_PATCH_VERSION_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_INTERNAL_STATES: {                                       // 0x400F
    if (datalen < 14) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_INTERNAL_STATES", 14);
        break;
    }

    unsigned char STAT_CID_POWER_MODE = (RXBUF_UCHAR(0));
        // Indicates if the CID is enabled by the head unit power mode / Indicates if the CID is enabled by the head unit
        // power mode
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_CID_POWER_MODE", STAT_CID_POWER_MODE, "\"0-n\"");

    unsigned short STAT_ERROR_FLAGS_WERT = (RXBUF_UINT(1));
        // Indicates which internal error are active.Range: [0x0000¿0xFFFF] / Indicates which internal error are
        // active.Range: [0x0000¿0xFFFF]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_ERROR_FLAGS_WERT", STAT_ERROR_FLAGS_WERT, "");

    unsigned char STAT_MAIN_STATE = (RXBUF_UCHAR(3));
        // Main state of the CID state machine / Main state of the CID state machine
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_MAIN_STATE", STAT_MAIN_STATE, "\"0-n\"");

    unsigned char STAT_OPERATION_STATE = (RXBUF_UCHAR(4));
        // Operation state of the CID state machine / Operation state of the CID state machine
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_OPERATION_STATE", STAT_OPERATION_STATE, "\"0-n\"");

    unsigned char STAT_INIT_STATE = (RXBUF_UCHAR(5));
        // Initialization (startup) state of the CID state machine / Initialization (startup) state of the CID state
        // machine
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_INIT_STATE", STAT_INIT_STATE, "\"0-n\"");

    unsigned char STAT_COM_STATE = (RXBUF_UCHAR(6));
        // State of the communication stack / State of the communication stack
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_COM_STATE", STAT_COM_STATE, "\"0-n\"");

    unsigned char STAT_SCHEDULE_ID = (RXBUF_UCHAR(7));
        // Schedule ID of communication stack. Range: [0x00¿0x04] 0xFF invalid / Schedule ID of communication stack.
        // Range: [0x00¿0x04] 0xFF invalid
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_SCHEDULE_ID", STAT_SCHEDULE_ID, "\"0-n\"");

    unsigned char STAT_FADE_STATE = (RXBUF_UCHAR(8));
        // Fading state of the dimming module / Fading state of the dimming module
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_FADE_STATE", STAT_FADE_STATE, "\"0-n\"");

    unsigned char STAT_FLASH_STATE = (RXBUF_UCHAR(9));
        // Flash reading state of the GDC module / Flash reading state of the GDC module
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_FLASH_STATE", STAT_FLASH_STATE, "\"0-n\"");

    unsigned char STAT_FLASH_DATA_CHANGED = (RXBUF_UCHAR(10));
        // Indicates if the flash data of the connected CID has been changed and must be saved by the head unit /
        // Indicates if the flash data of the connected CID has been changed and must be saved by the head unit
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_FLASH_DATA_CHANGED", STAT_FLASH_DATA_CHANGED, "\"0-n\"");

    unsigned char STAT_DISPLAY_VOLTAGE = (RXBUF_UCHAR(11));
        // Activation state of the display power supply / Activation state of the display power supply
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_DISPLAY_VOLTAGE", STAT_DISPLAY_VOLTAGE, "\"0-n\"");

    unsigned char STAT_DISPLAY_ENABLE = (RXBUF_UCHAR(12));
        // Activation state of the complete CID (also contained in Status Monitor) / Activation state of the complete CID
        // (also contained in Status Monitor)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_DISPLAY_ENABLE", STAT_DISPLAY_ENABLE, "\"0-n\"");

    unsigned char STAT_DISPLAY_READY = (RXBUF_UCHAR(13));
        // Indicated if CID is ready to display or not (also contained in Status Monitor) / Indicated if CID is ready to
        // display or not (also contained in Status Monitor)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_INTERNAL_STATES", "STAT_DISPLAY_READY", STAT_DISPLAY_READY, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_CID_CODIERDATEN: {                                              // 0x4010
    if (datalen < 32) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_CID_CODIERDATEN", 32);
        break;
    }

    unsigned short STAT_DIM_CURVE_X1_WERT = (RXBUF_UINT(0));
        // Curve point X1 of the dimming curve. / Curve point X1 of the dimming curve.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_CURVE_X1_WERT", STAT_DIM_CURVE_X1_WERT, "");

    unsigned short STAT_DIM_CURVE_X2_WERT = (RXBUF_UINT(2));
        // Curve point X2 of the dimming curve. / Curve point X2 of the dimming curve.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_CURVE_X2_WERT", STAT_DIM_CURVE_X2_WERT, "");

    unsigned short STAT_DIM_CURVE_X3_WERT = (RXBUF_UINT(4));
        // Curve point X3 of the dimming curve. / Curve point X3 of the dimming curve.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_CURVE_X3_WERT", STAT_DIM_CURVE_X3_WERT, "");

    unsigned short STAT_DIM_CURVE_Y1_WERT = (RXBUF_UINT(6));
        // Curve point Y1 of the dimming curve. / Curve point Y1 of the dimming curve.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_CURVE_Y1_WERT", STAT_DIM_CURVE_Y1_WERT, "");

    unsigned short STAT_DIM_CURVE_Y2_WERT = (RXBUF_UINT(8));
        // Curve point Y2 of the dimming curve. / Curve point Y2 of the dimming curve.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_CURVE_Y2_WERT", STAT_DIM_CURVE_Y2_WERT, "");

    unsigned short STAT_DIM_CURVE_Y3_WERT = (RXBUF_UINT(10));
        // Curve point Y3 of the dimming curve. / Curve point Y3 of the dimming curve.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_CURVE_Y3_WERT", STAT_DIM_CURVE_Y3_WERT, "");

    unsigned char STAT_DIM_TOLERANCE_ALPHA_WERT = (RXBUF_UCHAR(12));
        // Width of dimming module tolerance band (dynamic part) / Width of dimming module tolerance band (dynamic part)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_TOLERANCE_ALPHA_WERT", STAT_DIM_TOLERANCE_ALPHA_WERT, "");

    unsigned char STAT_DIM_TOLERANCE_ABS_WERT = (RXBUF_UCHAR(13));
        // Width of dimming module tolerance band (static part) / Width of dimming module tolerance band (static part)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_TOLERANCE_ABS_WERT", STAT_DIM_TOLERANCE_ABS_WERT, "");

    unsigned char STAT_DIM_DIFF_GAIN_WERT = (RXBUF_UCHAR(14));
        // Amplification factor for brightness deviation / Amplification factor for brightness deviation
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_DIFF_GAIN_WERT", STAT_DIM_DIFF_GAIN_WERT, "");

    unsigned char STAT_DIM_DIFF_THRESHOLD_WERT = (RXBUF_UCHAR(15));
        // Threshold for luminous density deviation / Threshold for luminous density deviation
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_DIFF_THRESHOLD_WERT", STAT_DIM_DIFF_THRESHOLD_WERT, "");

    unsigned char STAT_DIM_DIFF_BIAS_WERT = (RXBUF_UCHAR(16));
        // Decay constant for dynamic damping / Decay constant for dynamic damping
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_DIFF_BIAS_WERT", STAT_DIM_DIFF_BIAS_WERT, "");

    unsigned char STAT_DIM_DIFF_MAX_WERT = (RXBUF_UCHAR(17));
        // Maximum time constant for local photo sensor filtering / Maximum time constant for local photo sensor
        // filtering
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_DIFF_MAX_WERT", STAT_DIM_DIFF_MAX_WERT, "");

    unsigned char STAT_DIM_DIFF_MIN_WERT = (RXBUF_UCHAR(18));
        // Minimum time constant for local photo sensor filtering / Minimum time constant for local photo sensor
        // filtering
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_DIFF_MIN_WERT", STAT_DIM_DIFF_MIN_WERT, "");

    unsigned char STAT_DIM_UP_MIN_WERT = (RXBUF_UCHAR(19));
        // Minimum time constant of dark to bright regulation / Minimum time constant of dark to bright regulation
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_UP_MIN_WERT", STAT_DIM_UP_MIN_WERT, "");

    unsigned char STAT_DIM_DOWN_MIN_WERT = (RXBUF_UCHAR(20));
        // Minimum time constant from bright to dark regulation / Minimum time constant of bright to dark regulation
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_DOWN_MIN_WERT", STAT_DIM_DOWN_MIN_WERT, "");

    unsigned char STAT_DIM_MAX_OFFSET_BRIG_WERT = (RXBUF_UCHAR(21));
        // Upper border of the brightness offset regulation range / Upper border of the brightness offset regulation
        // range
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_MAX_OFFSET_BRIG_WERT", STAT_DIM_MAX_OFFSET_BRIG_WERT, "");

    unsigned char STAT_DIM_FADE_TIME_T0_WERT = (RXBUF_UCHAR(22));
        // Death time before fading starts (resolution 100ms). Range: [0x00¿0xFF] / Death time before fading starts
        // (resolution 100ms). Range: [0x00¿0xFF]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_FADE_TIME_T0_WERT", STAT_DIM_FADE_TIME_T0_WERT, "");

    unsigned char STAT_DIM_FADE_TIME_T1_WERT = (RXBUF_UCHAR(23));
        // Time to fade to current luminous density (resolution 100ms). Range: [0x00¿0x3F] / Time to fade to current
        // luminous density (resolution 100ms). Range: [0x00¿0x3F]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_FADE_TIME_T1_WERT", STAT_DIM_FADE_TIME_T1_WERT, "");

    unsigned char STAT_DIM_FADE_TIME_T2_WERT = (RXBUF_UCHAR(24));
        // Time to fade out (resolution 100ms). Range: [0x00¿0x3F] / Time to fade out (resolution 100ms). Range:
        // [0x00¿0x3F]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_FADE_TIME_T2_WERT", STAT_DIM_FADE_TIME_T2_WERT, "");

    unsigned char STAT_DIM_FADE_EXPO_T1_WERT = (RXBUF_UCHAR(25));
        //  Fade in ramp curve exponent. 0 = linear, 1 = square, ... Range: [0x00¿0x04] /  Fade in ramp curve exponent.
        // 0=linear, 1=square, ... Range: [0x00¿0x04] 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_FADE_EXPO_T1_WERT", STAT_DIM_FADE_EXPO_T1_WERT, "");

    unsigned char STAT_DIM_FADE_EXPO_T2_WERT = (RXBUF_UCHAR(26));
        //  Fade out ramp curve exponent. 0 = linear, 1 = square, ... Range: [0x00¿0x04] /  Fade out ramp curve exponent.
        // 0=linear, 1=square, ... Range: [0x00¿0x04] 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_FADE_EXPO_T2_WERT", STAT_DIM_FADE_EXPO_T2_WERT, "");

    unsigned short STAT_DIM_FILT_CHANGE_SENSITIVITY_WERT = (RXBUF_UINT(27));
        // Adjusts the reaction on strong signal changes depending on the time the input value is stable. 0 = no
        // adjustment (old filter algorithm) 1-65535 = number of dim cycles the input value has to be stable Range:
        // [0x0000¿0xFFFF] / Adjusts the reaction on  strong signal changes depending on the time the input value is
        // stable. 0 = no adjustment (old filter algorithm) 1-65535 = number of dim cycles the input value has to be
        // stable Range: [0x0000¿0xFFFF]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_FILT_CHANGE_SENSITIVITY_WERT", STAT_DIM_FILT_CHANGE_SENSITIVITY_WERT, "");

    unsigned char STAT_DIM_MIN_OFFSET_BRIG_WERT = (RXBUF_UCHAR(29));
        // Lower border of the brightness offset regulation range / Lower border of the brightness offset regulation
        // range
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_DIM_MIN_OFFSET_BRIG_WERT", STAT_DIM_MIN_OFFSET_BRIG_WERT, "");

    unsigned char STAT_ENDIANESS_ADAPTED_WERT = (RXBUF_UCHAR(30));
        // Indicates if the endianess of the coding data block has been adapted or not / Indicates if the endianess of
        // the coding data block has been adapted or not
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_ENDIANESS_ADAPTED_WERT", STAT_ENDIANESS_ADAPTED_WERT, "");

    unsigned char STAT_PADDING_WERT = (RXBUF_UCHAR(31));
        // Padding for further use / Padding for further use
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "CID_CODIERDATEN", "STAT_PADDING_WERT", STAT_PADDING_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_STATUS_CID_DETAIL_INFORMATION_EXTENDED: {                       // 0x4011
    if (datalen < 24) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_STATUS_CID_DETAIL_INFORMATION_EXTENDED", 24);
        break;
    }

    unsigned short STAT_CID_LOCATION_WERT_0X4011 = (RXBUF_UINT(0));
        // Value of the location in the car / Value of the location in the car
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_CID_LOCATION_WERT_0X4011", STAT_CID_LOCATION_WERT_0X4011, "");

    unsigned char STAT_SUPPLIER_NR_WERT = (RXBUF_UCHAR(8));
        // Value of the supplier part number / Value of the supplier part number
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_SUPPLIER_NR_WERT", STAT_SUPPLIER_NR_WERT, "");

    unsigned long STAT_SERIAL_NUMBER_WERT_0X4011 = (RXBUF_UINT32(9));
        // Value of the serial number. / Value of the serial number.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_SERIAL_NUMBER_WERT_0X4011", STAT_SERIAL_NUMBER_WERT_0X4011, "");

    unsigned char STAT_PRODUCTION_YEAR_WERT = (RXBUF_UCHAR(13));
        // Year of production of the CID / Year of production of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_PRODUCTION_YEAR_WERT", STAT_PRODUCTION_YEAR_WERT, "\"HEX\"");

    unsigned char STAT_PRODUCTION_MONTH_WERT = (RXBUF_UCHAR(14));
        // Month of production of the CID / Month of production of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_PRODUCTION_MONTH_WERT", STAT_PRODUCTION_MONTH_WERT, "\"HEX\"");

    unsigned char STAT_PRODUCTION_DAY_WERT = (RXBUF_UCHAR(15));
        // Day of production of the CID / Day of production of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_PRODUCTION_DAY_WERT", STAT_PRODUCTION_DAY_WERT, "\"HEX\"");

    unsigned short STAT_HARDWARE_VERSION_WERT = (RXBUF_UINT(16));
        // Hardware version of the CID / Hardware version of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_HARDWARE_VERSION_WERT", STAT_HARDWARE_VERSION_WERT, "");

    unsigned short STAT_DISPLAY_VERSION_WERT = (RXBUF_UINT(18));
        // Display version of the CID / Display version of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_DISPLAY_VERSION_WERT", STAT_DISPLAY_VERSION_WERT, "");

    unsigned short STAT_MECHANICAL_VERSION_WERT = (RXBUF_UINT(20));
        // Mechanical version of the CID / Mechanical version of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_MECHANICAL_VERSION_WERT", STAT_MECHANICAL_VERSION_WERT, "");

    unsigned short STAT_FLASH_DATA_VERSION_WERT = (RXBUF_UINT(22));
        // Flash data version of the CID / Flash data version of the CID
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "NBT", "STATUS_CID_DETAIL_INFORMATION_EXTENDED", "STAT_FLASH_DATA_VERSION_WERT", STAT_FLASH_DATA_VERSION_WERT, "");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_WLAN_SIGNAL_TEST_AP: {                                          // 0x4044
    if (datalen < 64) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_WLAN_SIGNAL_TEST_AP", 64);
        break;
    }

    unsigned char STAT_WLAN_ERRORRATE_AP_1_WERT = (RXBUF_UCHAR(6));
        // Error rate (0-100%) of the connected device 1 / Fehlerrate (0-100%) des verbundenen Gerät 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_AP_1_WERT", STAT_WLAN_ERRORRATE_AP_1_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_AP_1_WERT = (RXBUF_UCHAR(7)-255.0);
        // Power of the connected device 1 / Power des verbundenen Gerät 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_DBM_AP_1_WERT", STAT_WLAN_ERRORRATE_DBM_AP_1_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_AP_2_WERT = (RXBUF_UCHAR(14));
        // Error rate (0-100%) of the connected device 2 / Fehlerrate (0-100%) des verbundenen Gerät 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_AP_2_WERT", STAT_WLAN_ERRORRATE_AP_2_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_AP_2_WERT = (RXBUF_UCHAR(15)-255.0);
        // Power of the connected device 2 / Power des verbundenen Gerät 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_DBM_AP_2_WERT", STAT_WLAN_ERRORRATE_DBM_AP_2_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_AP_3_WERT = (RXBUF_UCHAR(22));
        // Error rate (0-100%) of the connected device 3 / Fehlerrate (0-100%) des verbundenen Gerät 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_AP_3_WERT", STAT_WLAN_ERRORRATE_AP_3_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_AP_3_WERT = (RXBUF_UCHAR(23)-255.0);
        // Power of the connected device 3 / Power des verbundenen Gerät 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_DBM_AP_3_WERT", STAT_WLAN_ERRORRATE_DBM_AP_3_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_AP_4_WERT = (RXBUF_UCHAR(30));
        // Error rate (0-100%) of the connected device 4 / Fehlerrate (0-100%) des verbundenen Gerät 4
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_AP_4_WERT", STAT_WLAN_ERRORRATE_AP_4_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_AP_4_WERT = (RXBUF_UCHAR(31)-255.0);
        // Power of the connected device 4 / Power des verbundenen Gerät 4
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_DBM_AP_4_WERT", STAT_WLAN_ERRORRATE_DBM_AP_4_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_AP_5_WERT = (RXBUF_UCHAR(38));
        // Error rate (0-100%) of the connected device 5 / Fehlerrate (0-100%) des verbundenen Gerät 5
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_AP_5_WERT", STAT_WLAN_ERRORRATE_AP_5_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_AP_5_WERT = (RXBUF_UCHAR(39)-255.0);
        // Power of the connected device 5 / Power des verbundenen Gerät 5
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_DBM_AP_5_WERT", STAT_WLAN_ERRORRATE_DBM_AP_5_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_AP_6_WERT = (RXBUF_UCHAR(46));
        // Error rate (0-100%) of the connected device 6 / Fehlerrate (0-100%) des verbundenen Gerät 6
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_AP_6_WERT", STAT_WLAN_ERRORRATE_AP_6_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_AP_6_WERT = (RXBUF_UCHAR(47)-255.0);
        // Power of the connected device 6 / Power des verbundenen Gerät 6
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_DBM_AP_6_WERT", STAT_WLAN_ERRORRATE_DBM_AP_6_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_AP_7_WERT = (RXBUF_UCHAR(54));
        // Error rate (0-100%) of the connected device 7 / Fehlerrate (0-100%) des verbundenen Gerät 7
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_AP_7_WERT", STAT_WLAN_ERRORRATE_AP_7_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_AP_7_WERT = (RXBUF_UCHAR(55)-255.0);
        // Power of the connected device 7 / Power des verbundenen Gerät 7
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_DBM_AP_7_WERT", STAT_WLAN_ERRORRATE_DBM_AP_7_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_AP_8_WERT = (RXBUF_UCHAR(62));
        // Error rate (0-100%) of the connected device 8 / Fehlerrate (0-100%) des verbundenen Gerät 8
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_AP_8_WERT", STAT_WLAN_ERRORRATE_AP_8_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_AP_8_WERT = (RXBUF_UCHAR(63)-255.0);
        // Power of the connected device 8 / Power des verbundenen Gerät 8
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_AP", "STAT_WLAN_ERRORRATE_DBM_AP_8_WERT", STAT_WLAN_ERRORRATE_DBM_AP_8_WERT, "\"dBm\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT_WLAN_SIGNAL_TEST_WIFI_DIRECT: {                                 // 0x4045
    if (datalen < 64) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_NBT_WLAN_SIGNAL_TEST_WIFI_DIRECT", 64);
        break;
    }

    unsigned char STAT_WLAN_ERRORRATE_DIRECT_1_WERT = (RXBUF_UCHAR(6));
        // Error rate (0-100%) of the connected device 1 / Fehlerrate (0-100%) des verbundenen Gerät 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DIRECT_1_WERT", STAT_WLAN_ERRORRATE_DIRECT_1_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_DIRECT_1_WERT = (RXBUF_UCHAR(7)-255.0);
        // Power of the connected device 1 / Power des verbundenen Gerät 1
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DBM_DIRECT_1_WERT", STAT_WLAN_ERRORRATE_DBM_DIRECT_1_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_DIRECT_2_WERT = (RXBUF_UCHAR(14));
        // Error rate (0-100%) of the connected device 2 / Fehlerrate (0-100%) des verbundenen Gerät 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DIRECT_2_WERT", STAT_WLAN_ERRORRATE_DIRECT_2_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_DIRECT_2_WERT = (RXBUF_UCHAR(15)-255.0);
        // Power of the connected device 2 / Power des verbundenen Gerät 2
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DBM_DIRECT_2_WERT", STAT_WLAN_ERRORRATE_DBM_DIRECT_2_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_DIRECT_3_WERT = (RXBUF_UCHAR(22));
        // Error rate (0-100%) of the connected device 3 / Fehlerrate (0-100%) des verbundenen Gerät 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DIRECT_3_WERT", STAT_WLAN_ERRORRATE_DIRECT_3_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_DIRECT_3_WERT = (RXBUF_UCHAR(23)-255.0);
        // Power of the connected device 3 / Power des verbundenen Gerät 3
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DBM_DIRECT_3_WERT", STAT_WLAN_ERRORRATE_DBM_DIRECT_3_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_DIRECT_4_WERT = (RXBUF_UCHAR(30));
        // Error rate (0-100%) of the connected device 4 / Fehlerrate (0-100%) des verbundenen Gerät 4
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DIRECT_4_WERT", STAT_WLAN_ERRORRATE_DIRECT_4_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_DIRECT_4_WERT = (RXBUF_UCHAR(31)-255.0);
        // Power of the connected device 4 / Power des verbundenen Gerät 4
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DBM_DIRECT_4_WERT", STAT_WLAN_ERRORRATE_DBM_DIRECT_4_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_DIRECT_5_WERT = (RXBUF_UCHAR(38));
        // Error rate (0-100%) of the connected device 5 / Fehlerrate (0-100%) des verbundenen Gerät 5
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DIRECT_5_WERT", STAT_WLAN_ERRORRATE_DIRECT_5_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_DIRECT_5_WERT = (RXBUF_UCHAR(39)-255.0);
        // Power of the connected device 5 / Power des verbundenen Gerät 5
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DBM_DIRECT_5_WERT", STAT_WLAN_ERRORRATE_DBM_DIRECT_5_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_DIRECT_6_WERT = (RXBUF_UCHAR(46));
        // Error rate (0-100%) of the connected device 6 / Fehlerrate (0-100%) des verbundenen Gerät 6
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DIRECT_6_WERT", STAT_WLAN_ERRORRATE_DIRECT_6_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_DIRECT_6_WERT = (RXBUF_UCHAR(47)-255.0);
        // Power of the connected device 6 / Power des verbundenen Gerät 6
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DBM_DIRECT_6_WERT", STAT_WLAN_ERRORRATE_DBM_DIRECT_6_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_DIRECT_7_WERT = (RXBUF_UCHAR(54));
        // Error rate (0-100%) of the connected device 7 / Fehlerrate (0-100%) des verbundenen Gerät 7
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DIRECT_7_WERT", STAT_WLAN_ERRORRATE_DIRECT_7_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_DIRECT_7_WERT = (RXBUF_UCHAR(55)-255.0);
        // Power of the connected device 7 / Power des verbundenen Gerät 7
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DBM_DIRECT_7_WERT", STAT_WLAN_ERRORRATE_DBM_DIRECT_7_WERT, "\"dBm\"");

    unsigned char STAT_WLAN_ERRORRATE_DIRECT_8_WERT = (RXBUF_UCHAR(62));
        // Error rate (0-100%) of the connected device 8 / Fehlerrate (0-100%) des verbundenen Gerät 8
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DIRECT_8_WERT", STAT_WLAN_ERRORRATE_DIRECT_8_WERT, "\"%\"");

    unsigned char STAT_WLAN_ERRORRATE_DBM_DIRECT_8_WERT = (RXBUF_UCHAR(63)-255.0);
        // Power of the connected device 8 / Power des verbundenen Gerät 8
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "NBT", "WLAN_SIGNAL_TEST_WIFI_DIRECT", "STAT_WLAN_ERRORRATE_DBM_DIRECT_8_WERT", STAT_WLAN_ERRORRATE_DBM_DIRECT_8_WERT, "\"dBm\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT__STEUERN_DELETE_PERSISTENCY_JACINTO: {                          // 0xFDE1
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT__STEUERN_DELETE_PERSISTENCY_INTEL_PLUS_SWT: {                   // 0xFDE2
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT__STEUERN_DELETE_PERSISTENCY_INTEL: {                            // 0xFDE3
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT__STEUERN_BACKUP_PERSISTENCY: {                                  // 0xFDE5
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_NBT__STEUERN_RESTORE_PERSISTENCY: {                                 // 0xFDE6
    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }
