// s_baltst_myenumerationwithfallback.cpp  *DO NOT EDIT*   @generated -*-C++-*-

#include <bsls_ident.h>
BSLS_IDENT_RCSID(s_baltst_myenumerationwithfallback_cpp, "$Id$ $CSID$")

#include <s_baltst_myenumerationwithfallback.h>

#include <bdlat_formattingmode.h>
#include <bdlat_valuetypefunctions.h>
#include <bdlb_print.h>
#include <bdlb_printmethods.h>
#include <bdlb_string.h>

#include <bslim_printer.h>
#include <bsls_assert.h>

#include <bsl_cstring.h>
#include <bsl_iomanip.h>
#include <bsl_limits.h>
#include <bsl_ostream.h>
#include <bsl_utility.h>

namespace BloombergLP {
namespace s_baltst {

                      // -------------------------------
                      // class MyEnumerationWithFallback
                      // -------------------------------

// CONSTANTS

const char MyEnumerationWithFallback::CLASS_NAME[] = "MyEnumerationWithFallback";

const bdlat_EnumeratorInfo MyEnumerationWithFallback::ENUMERATOR_INFO_ARRAY[] = {
    {
        MyEnumerationWithFallback::VALUE1,
        "VALUE1",
        sizeof("VALUE1") - 1,
        ""
    },
    {
        MyEnumerationWithFallback::VALUE2,
        "VALUE2",
        sizeof("VALUE2") - 1,
        ""
    },
    {
        MyEnumerationWithFallback::UNKNOWN,
        "UNKNOWN",
        sizeof("UNKNOWN") - 1,
        ""
    }
};

// CLASS METHODS

int MyEnumerationWithFallback::fromInt(MyEnumerationWithFallback::Value *result, int number)
{
    switch (number) {
      case MyEnumerationWithFallback::VALUE1:
      case MyEnumerationWithFallback::VALUE2:
      case MyEnumerationWithFallback::UNKNOWN:
        *result = static_cast<MyEnumerationWithFallback::Value>(number);
        return 0;
      default:
        return -1;
    }
}

int MyEnumerationWithFallback::fromString(
        MyEnumerationWithFallback::Value *result,
        const char         *string,
        int                 stringLength)
{
    for (int i = 0; i < 3; ++i) {
        const bdlat_EnumeratorInfo& enumeratorInfo =
                    MyEnumerationWithFallback::ENUMERATOR_INFO_ARRAY[i];

        if (stringLength == enumeratorInfo.d_nameLength
        &&  0 == bsl::memcmp(enumeratorInfo.d_name_p, string, stringLength))
        {
            *result = static_cast<MyEnumerationWithFallback::Value>(enumeratorInfo.d_value);
            return 0;
        }
    }

    return -1;
}

int MyEnumerationWithFallback::makeFallback(MyEnumerationWithFallback::Value *result)
{
    *result = UNKNOWN;
    return 0;
}

const char *MyEnumerationWithFallback::toString(MyEnumerationWithFallback::Value value)
{
    switch (value) {
      case VALUE1: {
        return "VALUE1";
      }
      case VALUE2: {
        return "VALUE2";
      }
      case UNKNOWN: {
        return "UNKNOWN";
      }
    }

    BSLS_ASSERT(!"invalid enumerator");
    return 0;
}

bool MyEnumerationWithFallback::hasFallback(MyEnumerationWithFallback::Value)
{
    return true;
}

bool MyEnumerationWithFallback::isFallback(MyEnumerationWithFallback::Value value)
{
    return value == UNKNOWN;
}

}  // close package namespace
}  // close enterprise namespace

// GENERATED BY @BLP_BAS_CODEGEN_VERSION@
// USING bas_codegen.pl s_baltst_myenumerationwithfallback.xsd --mode msg --includedir . --msgComponent myenumerationwithfallback --noRecurse --noExternalization --noHashSupport --noAggregateConversion
// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright 2023 Bloomberg Finance L.P. All rights reserved.
//      Property of Bloomberg Finance L.P. (BFLP)
//      This software is made available solely pursuant to the
//      terms of a BFLP license agreement which governs its use.
// ------------------------------- END-OF-FILE --------------------------------
