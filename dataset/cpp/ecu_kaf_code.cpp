
//
// Warning: don't edit - generated by generate_ecu_code.pl processing ../dev/kafas20.json: KAF 5D: Camera based driver assistance system
// This generated code  makes it easier to process CANBUS messages from the KAF ecu in a BMW i3
//

  case I3_PID_KAF__FASTA_FLA_DATA: {                                              // 0x4001
    if (datalen < 24) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__FASTA_FLA_DATA", 24);
        break;
    }

    unsigned long STAT_FLA_OP_TIME_WERT = (RXBUF_UINT32(0));
        // Duration of FLA activated by driver [s] / Zeitdauer FLA durch Fahrer aktiviert [s]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_FASTA_FLA_DATA", "STAT_FLA_OP_TIME_WERT", STAT_FLA_OP_TIME_WERT, "\"s\"");

    unsigned long STAT_DELTA_TIME_FLA_NIGHT_WERT = (RXBUF_UINT32(4));
        // Duration in the ambient brightness FLA activation allowed [s] / Zeitdauer in der Umgebungshelligkeit FLA
        // Aktivierung erlaubt  [s]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_FASTA_FLA_DATA", "STAT_DELTA_TIME_FLA_NIGHT_WERT", STAT_DELTA_TIME_FLA_NIGHT_WERT, "\"s\"");

    unsigned long STAT_DELTA_TIME_FLA_ACT_HB_WERT = (RXBUF_UINT32(8));
        // Duration of switch-on recommendation FLA [s] / Zeitdauer Einschaltempfehlung FLA  [s]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_FASTA_FLA_DATA", "STAT_DELTA_TIME_FLA_ACT_HB_WERT", STAT_DELTA_TIME_FLA_ACT_HB_WERT, "\"s\"");

    unsigned long STAT_DELTA_TIME_FLA_ACT_LB_WERT = (RXBUF_UINT32(12));
        // Duration of switch-off recommendation [s] / Zeitdauer Abschaltempfehlung [s]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_FASTA_FLA_DATA", "STAT_DELTA_TIME_FLA_ACT_LB_WERT", STAT_DELTA_TIME_FLA_ACT_LB_WERT, "\"s\"");

    unsigned long STAT_FLA_COUNT_OVERRIDE_WERT = (RXBUF_UINT32(16));
        // Number of driver overloads / Anzahl Übersteuerung durch Fahrer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_FASTA_FLA_DATA", "STAT_FLA_COUNT_OVERRIDE_WERT", STAT_FLA_COUNT_OVERRIDE_WERT, "\"Counts\"");

    unsigned long STAT_OPTIME_TOTAL_WERT = (RXBUF_UINT32(20));
        // Absolute operating time counter [s] / Absoluter Betriebszeitzähler [s]
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_FASTA_FLA_DATA", "STAT_OPTIME_TOTAL_WERT", STAT_OPTIME_TOTAL_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__KAFAS_ECU_DATA: {                                              // 0x4002
    if (datalen < 38) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__KAFAS_ECU_DATA", 38);
        break;
    }

    unsigned short STAT_CNTRY_CODE_WERT = (RXBUF_UINT(0));
        // ISO Country Code of the country in which the vehicle covered the most kilometers. / ISO Country Code des
        // Landes in welchem das Fahrzeug die meisten  Kilometer zurückgelegt hat.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_CNTRY_CODE_WERT", STAT_CNTRY_CODE_WERT, "\"Counts\"");

    unsigned long STAT_OPTIME_TOTAL_WERT_0X4002 = (RXBUF_UINT32(2));
        // Absolute operating time counter / Absoluter Betriebszeitzähler
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_OPTIME_TOTAL_WERT_0X4002", STAT_OPTIME_TOTAL_WERT_0X4002, "\"s\"");

    unsigned long STAT_OPTIME_NIGHT_WERT = (RXBUF_UINT32(6));
        // Operating time at night. Based on BV-Algo overnight decision / Betriebszeit in der Nacht. Basiert auf BV-Algo
        // Nachtentscheidung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_OPTIME_NIGHT_WERT", STAT_OPTIME_NIGHT_WERT, "\"s\"");

    unsigned long STAT_OPTIME_WIPER_WERT = (RXBUF_UINT32(10));
        // Operating time during rain. Based on Algo Rain Decision / Betriebszeit während Regen. Basiert auf Algo
        // Regenentscheidung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_OPTIME_WIPER_WERT", STAT_OPTIME_WIPER_WERT, "\"s\"");

    unsigned long STAT_DRIVEN_DIST_TOTAL_WERT = (RXBUF_UINT32(14));
        // Absolutely driven kilometers / Absolut gefahrene Kilometer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_DRIVEN_DIST_TOTAL_WERT", STAT_DRIVEN_DIST_TOTAL_WERT, "\"km\"");

    unsigned long STAT_DRIVEN_DIST_URBAN_WERT = (RXBUF_UINT32(18));
        // Total kilometers driven on urban or residential area roads / Absolut gefahrene Kilometer auf Straßentyp Urban
        // oder Residential Area
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_DRIVEN_DIST_URBAN_WERT", STAT_DRIVEN_DIST_URBAN_WERT, "\"km\"");

    unsigned long STAT_DRIVEN_DIST_RURAL_WERT = (RXBUF_UINT32(22));
        // Absolute kilometers driven on the rural or highway type / Absolut gefahrene Kilometer auf Straßentyp Rural
        // oder Highway
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_DRIVEN_DIST_RURAL_WERT", STAT_DRIVEN_DIST_RURAL_WERT, "\"km\"");

    unsigned long STAT_DRIVEN_DIST_MOWAY_WERT = (RXBUF_UINT32(26));
        // Absolute kilometers driven on road type Motorway / Absolut gefahrene Kilometer auf Straßentyp Motorway
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_DRIVEN_DIST_MOWAY_WERT", STAT_DRIVEN_DIST_MOWAY_WERT, "\"km\"");

    unsigned long STAT_DRIVEN_DIST_NA_WERT = (RXBUF_UINT32(30));
        // Absolute kilometers driven with no available road type / Absolut gefahrene Kilometer ohne verfügbaren
        // Straßentyp
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_DRIVEN_DIST_NA_WERT", STAT_DRIVEN_DIST_NA_WERT, "\"km\"");

    unsigned short STAT_AMNT_EYEQ_RESET_WERT = (RXBUF_UINT(34));
        // Number of resets of the BV processor performed during normal operation / Anzahl der erfolgten Resets des
        // BV-Prozessors während normalem Betrieb
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_AMNT_EYEQ_RESET_WERT", STAT_AMNT_EYEQ_RESET_WERT, "\"Counts\"");

    unsigned short STAT_AMNT_ONLINE_CALIB_WERT = (RXBUF_UINT(36));
        // Counter for the completed online calibration processes / Zähler über die Erfolgten Online-Kalibriervorgänge
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_ECU_DATA", "STAT_AMNT_ONLINE_CALIB_WERT", STAT_AMNT_ONLINE_CALIB_WERT, "\"Counts\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__KAFAS_TLC_DATA: {                                              // 0x4003
    if (datalen < 20) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__KAFAS_TLC_DATA", 20);
        break;
    }

    unsigned long STAT_TLC_DRIV_LEFT_AVAIL_WERT = (RXBUF_UINT32(0));
        // Absolute kilometers driven with availability on the left / Absolut gefahrene Kilometer mit Verfübarkeit auf
        // der linken Seite
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_TLC_DATA", "STAT_TLC_DRIV_LEFT_AVAIL_WERT", STAT_TLC_DRIV_LEFT_AVAIL_WERT, "\"km\"");

    unsigned long STAT_TLC_DRIV_RIGHT_AVAIL_WERT = (RXBUF_UINT32(4));
        // Absolute kilometers driven with availability on the right / Absolut gefahrene Kilometer mit Verfübarkeit auf
        // der rechten Seite
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_TLC_DATA", "STAT_TLC_DRIV_RIGHT_AVAIL_WERT", STAT_TLC_DRIV_RIGHT_AVAIL_WERT, "\"km\"");

    unsigned long STAT_TLC_DRIV_DIST_REL_SPD_WERT = (RXBUF_UINT32(8));
        // Absolutely driven with active TLC and relevant speed / Absolut gefahrene  mit aktivem TLC und relavanter
        // Geschwindigkeit
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_TLC_DATA", "STAT_TLC_DRIV_DIST_REL_SPD_WERT", STAT_TLC_DRIV_DIST_REL_SPD_WERT, "\"km\"");

    unsigned short STAT_TLC_AMNT_WARN_WERT = (RXBUF_UINT(12));
        // Number of issued TLC warnings / Anzahl ausgegebener TLC Warnungen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_TLC_DATA", "STAT_TLC_AMNT_WARN_WERT", STAT_TLC_AMNT_WARN_WERT, "\"Counts\"");

    unsigned short STAT_TLC_AMNT_DEACT_WERT = (RXBUF_UINT(14));
        // Number of times the TLC function was deactivated by the driver / Anzahl der Deaktivierung der TLC-Funktion
        // durch den Fahrer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_TLC_DATA", "STAT_TLC_AMNT_DEACT_WERT", STAT_TLC_AMNT_DEACT_WERT, "\"Counts\"");

    unsigned long STAT_TLC_DRIV_DIST_ACT_WERT = (RXBUF_UINT32(16));
        // Kilometers driven with activated TLC / Gefahrene Kilometer mit aktiviertem TLC
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_TLC_DATA", "STAT_TLC_DRIV_DIST_ACT_WERT", STAT_TLC_DRIV_DIST_ACT_WERT, "\"km\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_KAFAS_FCW_DATA: {                                               // 0x4004
    if (datalen < 42) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_KAFAS_FCW_DATA", 42);
        break;
    }

    unsigned long STAT_FCW_DRIVEN_DIST_ACT_WERT = (RXBUF_UINT32(0));
        // Total kilometers driven with activated FCW function / Absolut gefahrene Kilometer mit aktivierter FCW Funktion
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_DRIVEN_DIST_ACT_WERT", STAT_FCW_DRIVEN_DIST_ACT_WERT, "\"km\"");

    unsigned long STAT_FCW_DRIVEN_DIST_FS_WERT = (RXBUF_UINT32(4));
        // Total kilometers driven in fail safe mode / Absolut gefahrene Kilometer im Fail Safe Mode
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_DRIVEN_DIST_FS_WERT", STAT_FCW_DRIVEN_DIST_FS_WERT, "\"km\"");

    unsigned long STAT_FCW_DRIVEN_DIST_FS_ACT_WERT = (RXBUF_UINT32(8));
        // Total kilometers driven with activated FCW function in fail safe mode / Absolut gefahrene Kilometer mit
        // aktivierter FCW Funktion im Fail Safe Mode
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_DRIVEN_DIST_FS_ACT_WERT", STAT_FCW_DRIVEN_DIST_FS_ACT_WERT, "\"km\"");

    unsigned long STAT_FCW_DRIVEN_DIST_FOR_OFF_WERT = (RXBUF_UINT32(12));
        // Absolutely driven kilometers with activated FCW function and advance warning level off / Absolut gefahrene
        // Kilometer mit aktivierter FCW Funktion und Vorwarnstufe  aus 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_DRIVEN_DIST_FOR_OFF_WERT", STAT_FCW_DRIVEN_DIST_FOR_OFF_WERT, "\"km\"");

    unsigned long STAT_FCW_DRIVEN_DIST_FOR_EARLY_WERT = (RXBUF_UINT32(16));
        // Total kilometers traveled with activated FCW function and early warning level / Absolut gefahrene Kilometer
        // mit aktivierter FCW Funktion und Vorwarnstufe  früh 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_DRIVEN_DIST_FOR_EARLY_WERT", STAT_FCW_DRIVEN_DIST_FOR_EARLY_WERT, "\"km\"");

    unsigned long STAT_FCW_DRIVEN_DIST_FOR_LATE_WERT = (RXBUF_UINT32(20));
        // Total kilometers driven with activated FCW function and late warning level / Absolut gefahrene Kilometer mit
        // aktivierter FCW Funktion und Vorwarnstufe  spät 
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_DRIVEN_DIST_FOR_LATE_WERT", STAT_FCW_DRIVEN_DIST_FOR_LATE_WERT, "\"km\"");

    unsigned short STAT_FCW_AMNT_FOR_WERT = (RXBUF_UINT(24));
        // Number of pre-warnings / Anzahl der Vorwarnungen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_AMNT_FOR_WERT", STAT_FCW_AMNT_FOR_WERT, "\"Counts\"");

    unsigned short STAT_FCW_AMNT_ACUTE_WERT = (RXBUF_UINT(26));
        // Number of acute warnings / Anzahl der Akutwarnungen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_AMNT_ACUTE_WERT", STAT_FCW_AMNT_ACUTE_WERT, "\"Counts\"");

    unsigned short STAT_FCW_AMNT_ACUTE_45_WERT = (RXBUF_UINT(28));
        // Number of acute warnings in the range 0 km / h¿ 45 km / h / Anzahl der Akutwarnungen im Bereich 0 km/h¿ 45
        // km/h
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_AMNT_ACUTE_45_WERT", STAT_FCW_AMNT_ACUTE_45_WERT, "\"Counts\"");

    unsigned short STAT_FCW_AMNT_ACUTE_90_WERT = (RXBUF_UINT(30));
        // Number of acute warnings in the range 45 km / h¿ 90 km / h / Anzahl der Akutwarnungen im Bereich 45 km/h¿ 90
        // km/h
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_AMNT_ACUTE_90_WERT", STAT_FCW_AMNT_ACUTE_90_WERT, "\"Counts\"");

    unsigned short STAT_FCW_AMNT_ACUTE_135_WERT = (RXBUF_UINT(32));
        // Number of acute warnings in the range 90 km / h¿ 135 km / h / Anzahl der Akutwarnungen im Bereich 90 km/h¿ 135
        // km/h
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_AMNT_ACUTE_135_WERT", STAT_FCW_AMNT_ACUTE_135_WERT, "\"Counts\"");

    unsigned short STAT_FCW_PREFILLS_WERT = (RXBUF_UINT(34));
        // Number of pre-fill requests triggered by FCW / Anzahl der von FCW ausgelösten Pre-Fill Anforderungen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_PREFILLS_WERT", STAT_FCW_PREFILLS_WERT, "\"Counts\"");

    unsigned short STAT_FCW_PRECRASH_WERT = (RXBUF_UINT(36));
        // Number of pre-crash messages triggered by FCW / Anzahl der von FCW ausgelösten Pre-Crash Meldungen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_PRECRASH_WERT", STAT_FCW_PRECRASH_WERT, "\"Counts\"");

    unsigned short STAT_FCW_DEACT_WERT = (RXBUF_UINT(38));
        // Number of times the FCW function has been deactivated by the driver / Anzahl der Deaktivierung der
        // FCW-Funktion durch den Fahrer
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_DEACT_WERT", STAT_FCW_DEACT_WERT, "\"Counts\"");

    unsigned short STAT_FCW_FS_CC_WERT = (RXBUF_UINT(40));
        // Number of triggered Fail-Save CC messages / Anzahl der ausgelösten Fail-Save CC-Meldungen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KAFAS_FCW_DATA", "STAT_FCW_FS_CC_WERT", STAT_FCW_FS_CC_WERT, "\"Counts\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__KAFAS_SLI_DATA: {                                              // 0x4005
    if (datalen < 27) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__KAFAS_SLI_DATA", 27);
        break;
    }

    unsigned long STAT_SLI_AMT_CAM_DET_WERT = (RXBUF_UINT32(0));
        // Number of camera detections of traffic signs / Anzahl der Kameradetektionen von Verkehrsschildern
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_AMT_CAM_DET_WERT", STAT_SLI_AMT_CAM_DET_WERT, "\"Counts\"");

    char STAT_SLI_MATCH_URBAN_WERT = (RXBUF_UCHAR(4));
        // Share of camera detection that match the explicit speed limits on the street type Urban or Residential Area /
        // Anteil der  Kameradetektion die mit den expliziten Speed Limits auf dem Straßentyp Urban oder Residential Area
        // übereinstimmen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_MATCH_URBAN_WERT", STAT_SLI_MATCH_URBAN_WERT, "\"Counts\"");

    char STAT_SLI_MATCH_RURAL_WERT = (RXBUF_UCHAR(5));
        // Proportion of camera detection that corresponds to the explicit speed limits on the road type rural or highway
        // / Anteil der  Kameradetektion die mit den expliziten Speed Limits auf dem Straßentyp Rural oder Highway
        // übereinstimmen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_MATCH_RURAL_WERT", STAT_SLI_MATCH_RURAL_WERT, "\"Counts\"");

    char STAT_SLI_MATCH_MOWAY_WERT = (RXBUF_UCHAR(6));
        // Percentage of camera detection that corresponds to the explicit speed limits on the road type Motorway /
        // Anteil der  Kameradetektion die mit den expliziten Speed Limits auf dem Straßentyp Motorway übereinstimmen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_MATCH_MOWAY_WERT", STAT_SLI_MATCH_MOWAY_WERT, "\"Counts\"");

    unsigned short STAT_SLI_REP_URBAN_WERT = (RXBUF_UINT(7));
        // Average distance at which signs repeat on the street type Urban or Residential Area / Durschnittlich Enfernung
        // in welcher sich Schilder auf dem Straßentyp Urbanoder Residential Area wiederholen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_REP_URBAN_WERT", STAT_SLI_REP_URBAN_WERT, "\"m\"");

    unsigned short STAT_SLI_REP_RURAL_WERT = (RXBUF_UINT(9));
        // Average distance at which signs repeat on the road type rural or highway / Durschnittlich Enfernung in welcher
        // sich Schilder auf dem Straßentyp Rural oder Highway wiederholen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_REP_RURAL_WERT", STAT_SLI_REP_RURAL_WERT, "\"m\"");

    unsigned short STAT_SLI_REP_MOWAY_WERT = (RXBUF_UINT(11));
        // Average distance at which signs repeat on the road type Motorway / Durschnittlich Enfernung in welcher sich
        // Schilder auf dem Straßentyp Motorway wiederholen
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_REP_MOWAY_WERT", STAT_SLI_REP_MOWAY_WERT, "\"m\"");

    unsigned long STAT_SLI_OVER_SLI_WERT = (RXBUF_UINT32(13));
        // Distance driven at least 20 km / h above the detected speed limit / Gefahrene Entfernung mit mindestens 20
        // km/h über dem erkannten Speed Limit
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_OVER_SLI_WERT", STAT_SLI_OVER_SLI_WERT, "\"km\"");

    unsigned short STAT_SLI_SSS_TIME_WERT = (RXBUF_UINT(17));
        // Number of recognized additional characters with time restriction / Anzahl der erkannten Zusatzzeichen mit
        // Zeitbeschränkung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_SSS_TIME_WERT", STAT_SLI_SSS_TIME_WERT, "\"Counts\"");

    unsigned long STAT_SLI_NPI_WERT = (RXBUF_UINT32(19));
        // Kilometers driven with no overtaking recognized / Gefahrene Kilometer mit erkanntem Überholverbot
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_NPI_WERT", STAT_SLI_NPI_WERT, "\"km\"");

    unsigned short STAT_SLI_NP_WITHDRAW_DIST_WERT = (RXBUF_UINT(23));
        // Number of cancellations of overtaking ban due to exceeding the stopping distance / Anzahl Aufhebungen
        // Überholverbot infolge Überschreitung Haltedistanz
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_NP_WITHDRAW_DIST_WERT", STAT_SLI_NP_WITHDRAW_DIST_WERT, "\"Counts\"");

    unsigned short STAT_SLI_NP_WITHDRAW_SIGN_WERT = (RXBUF_UINT(25));
        // Number of cancellations No overtaking due to detection of a lifting sign / Anzahl Aufhebungen Überholverbot
        // infolge Detektion Aufhebungsschild
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_KAFAS_SLI_DATA", "STAT_SLI_NP_WITHDRAW_SIGN_WERT", STAT_SLI_NP_WITHDRAW_SIGN_WERT, "\"Counts\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__STATUS_SAFETY_DIAG_INFO: {                                     // 0x400E
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__STATUS_SAFETY_DIAG_INFO", 7);
        break;
    }

    unsigned char STAT_BYTE_0_FAULT_WERT = (RXBUF_UCHAR(0));
        // The parameter values shall indicate 0 for fault_not_present and 1 for fault_present. Bit: 0
        // UP1V0D_freeze_fault 1 UP1V8D_freeze_fault 2 UP2V5D_freeze_fault 3 UP3V3D_freeze_fault 4 UP5V0D_freeze_fault 5
        // VTEMP1_freeze_fault 6 VTEMP2_freeze_fault 7 V_BAT1_freeze_fault / The parameter values shall indicate 0 for
        // fault_not_present and 1 for fault_present. Bit: 0 UP1V0D_freeze_fault 1 UP1V8D_freeze_fault 2
        // UP2V5D_freeze_fault 3 UP3V3D_freeze_fault 4 UP5V0D_freeze_fault 5 VTEMP1_freeze_fault 6 VTEMP2_freeze_fault 7
        // V_BAT1_freeze_fault
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_SAFETY_DIAG_INFO", "STAT_BYTE_0_FAULT_WERT", STAT_BYTE_0_FAULT_WERT, "\"HEX\"");

    unsigned char STAT_BYTE_1_FAULT_WERT = (RXBUF_UCHAR(1));
        // The parameter values shall indicate 0 for fault_not_present and 1 for fault_present. Bit: 0
        // UP1V0D_freeze_fault 1 UP1V8D_freeze_fault 2 UP2V5D_freeze_fault 3 UP3V3D_freeze_fault 4 UP5V0D_freeze_fault 5
        // VTEMP1_freeze_fault 6 VTEMP2_freeze_fault 7 V_BAT1_freeze_fault / The parameter values shall indicate 0 for
        // fault_not_present and 1 for fault_present. Bit: 0 UP1V0D_freeze_fault 1 UP1V8D_freeze_fault 2
        // UP2V5D_freeze_fault 3 UP3V3D_freeze_fault 4 UP5V0D_freeze_fault 5 VTEMP1_freeze_fault 6 VTEMP2_freeze_fault 7
        // V_BAT1_freeze_fault
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_SAFETY_DIAG_INFO", "STAT_BYTE_1_FAULT_WERT", STAT_BYTE_1_FAULT_WERT, "\"HEX\"");

    unsigned char STAT_BYTE_2_FAULT_WERT = (RXBUF_UCHAR(2));
        // The parameter values shall indicate 0 for fault_not_present and 1 for fault_present. Bit: 0
        // UP1V0D_voltage_fault 1 UP1V8D_voltage_fault 2 UP2V5D_voltage_fault 3 UP3V3D_voltage_fault 4
        // UP5V0D_voltage_fault 5 VTEMP1_temperature_fault 6 VTEMP2_temperature_fault 7 V_BAT1_voltage_fault / The
        // parameter values shall indicate 0 for fault_not_present and 1 for fault_present.  Bit: 0 UP1V0D_voltage_fault
        // 1 UP1V8D_voltage_fault 2 UP2V5D_voltage_fault 3 UP3V3D_voltage_fault 4 UP5V0D_voltage_fault 5
        // VTEMP1_temperature_fault 6 VTEMP2_temperature_fault 7 V_BAT1_voltage_fault
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_SAFETY_DIAG_INFO", "STAT_BYTE_2_FAULT_WERT", STAT_BYTE_2_FAULT_WERT, "\"HEX\"");

    unsigned char STAT_BYTE_3_FAULT_WERT = (RXBUF_UCHAR(3));
        // The parameter values shall indicate 0 for fault_not_present and 1 for fault_present. Bit: 0
        // ECU_inconsistent_temperature_fault / The parameter values shall indicate 0 for fault_not_present and 1 for
        // fault_present. Bit: 0 ECU_inconsistent_temperature_fault
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_SAFETY_DIAG_INFO", "STAT_BYTE_3_FAULT_WERT", STAT_BYTE_3_FAULT_WERT, "\"HEX\"");

    unsigned char STAT_BYTE_4_FAULT_WERT = (RXBUF_UCHAR(4));
        // The parameter values shall indicate 0 for fault_not_present and 1 for fault_present. Bit: 0 Eq2Unavailable 1
        // Eq2FaultHandlingAliveError 2 Eq2FaultHandlingCrcError 3 VideoError_400 4 TempStatus_400 5 CamLVDS_Defect_400 6
        // CamEEP_Fail_400 7 BurntPixel_400 / The parameter values shall indicate 0 for fault_not_present and 1 for
        // fault_present. Bit: 0 Eq2Unavailable 1 Eq2FaultHandlingAliveError 2 Eq2FaultHandlingCrcError 3 VideoError_400
        // 4 TempStatus_400 5 CamLVDS_Defect_400 6 CamEEP_Fail_400 7 BurntPixel_400
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_SAFETY_DIAG_INFO", "STAT_BYTE_4_FAULT_WERT", STAT_BYTE_4_FAULT_WERT, "\"HEX\"");

    unsigned char STAT_BYTE_5_FAULT_WERT = (RXBUF_UCHAR(5));
        // The parameter values shall indicate 0 for fault_not_present and 1 for fault_present. Bit: 0 DDR_Failure_400 1
        // WdgMSafetyAliveSupervisonFault / The parameter values shall indicate 0 for fault_not_present and 1 for
        // fault_present. Bit: 0 DDR_Failure_400 1 WdgMSafetyAliveSupervisonFault
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_SAFETY_DIAG_INFO", "STAT_BYTE_5_FAULT_WERT", STAT_BYTE_5_FAULT_WERT, "\"HEX\"");

    unsigned char STAT_BYTE_6_FAULT_WERT = (RXBUF_UCHAR(6));
        // The parameter values shall indicate 0 for fault_not_present and 1 for fault_present. Bit: 0 ActiveFaultClass
        // Bit 0 * 1 ActiveFaultClass Bit 1 * 2 ActiveFaultClass Bit 2 * 3 (not disp_drasy_available) 4 (not
        // aAssistFunctionAvailable) 5 (not qAssistActive) 6 Not in use 7 Safe state entered disp_drasy_available means
        // that the bit is 0 when the signal is available, and 1 when it is not available / The parameter values shall
        // indicate 0 for fault_not_present and 1 for fault_present. Bit: 0 ActiveFaultClass Bit 0* 1 ActiveFaultClass
        // Bit 1* 2 ActiveFaultClass Bit 2* 3 (not disp_drasy_available)  4 (not aAssistFunctionAvailable) 5 (not
        // qAssistActive) 6 Not in use 7 Safe state entered disp_drasy_available  means that the bit is  0  when the
        // signal is availablem, and  1  when it is not available
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_SAFETY_DIAG_INFO", "STAT_BYTE_6_FAULT_WERT", STAT_BYTE_6_FAULT_WERT, "\"HEX\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__STATUS_WARNZEITPUNKT_FCW: {                                    // 0x400F
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__STATUS_WARNZEITPUNKT_FCW", 1);
        break;
    }

    unsigned char STAT_WARN_FLAV_FCW = (RXBUF_UCHAR(0));
        // currently selected warning flavor / currently selected warning flavor
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_WARNZEITPUNKT_FCW", "STAT_WARN_FLAV_FCW", STAT_WARN_FLAV_FCW, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_FASTA_PPP_DATA: {                                               // 0x4010
    if (datalen < 50) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_FASTA_PPP_DATA", 50);
        break;
    }

    unsigned short STAT_PPP_WARNING_ZONE = (RXBUF_UINT(0));
        // Type of warning zone / Art der Warnzone
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_WARNING_ZONE", STAT_PPP_WARNING_ZONE, "\"0-n\"");

    unsigned short STAT_PPP_AMNT_DZ_EVENTS_0_TO_20_WERT = (RXBUF_UINT(2));
        // The parameter is determined by counting the number of DZ events in the range 0 <x <20 km / h / Die Kenngröße
        // wird bestimmt, indem die Anzahl der DZ-Events im Bereich 0 < x < 20 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_DZ_EVENTS_0_TO_20_WERT", STAT_PPP_AMNT_DZ_EVENTS_0_TO_20_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_DZ_EVENTS_20_TO_40_WERT = (RXBUF_UINT(4));
        // The parameter is determined by counting the number of DZ events in the range 20 <x <40 km / h / Die Kenngröße
        // wird bestimmt, indem die Anzahl der DZ-Events im Bereich 20 < x < 40 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_DZ_EVENTS_20_TO_40_WERT", STAT_PPP_AMNT_DZ_EVENTS_20_TO_40_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_DZ_EVENTS_40_TO_60_WERT = (RXBUF_UINT(6));
        // The parameter is determined by counting the number of DZ events in the range 40 <x <60 km / h / Die Kenngröße
        // wird bestimmt, indem die Anzahl der DZ-Events im Bereich 40 < x < 60 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_DZ_EVENTS_40_TO_60_WERT", STAT_PPP_AMNT_DZ_EVENTS_40_TO_60_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_PDZ1_EVENTS_0_TO_20_WERT = (RXBUF_UINT(8));
        // The parameter is determined by counting the number of PDZ1 events in the range 0 <x <20 km / h / Die Kenngröße
        // wird bestimmt, indem die Anzahl der PDZ1-Events im Bereich 0 < x < 20 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_PDZ1_EVENTS_0_TO_20_WERT", STAT_PPP_AMNT_PDZ1_EVENTS_0_TO_20_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_PDZ1_EVENTS_20_TO_40_WERT = (RXBUF_UINT(10));
        // The parameter is determined by counting the number of PDZ1 events in the range 20 <x <40 km / h / Die
        // Kenngröße wird bestimmt, indem die Anzahl der PDZ1-Events im Bereich 20 < x < 40 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_PDZ1_EVENTS_20_TO_40_WERT", STAT_PPP_AMNT_PDZ1_EVENTS_20_TO_40_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_PDZ1_EVENTS_40_TO_60_WERT = (RXBUF_UINT(12));
        // The parameter is determined by counting the number of PDZ1 events in the range 40 <x <60 km / h / Die
        // Kenngröße wird bestimmt, indem die Anzahl der PDZ1-Events im Bereich 40 < x < 60 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_PDZ1_EVENTS_40_TO_60_WERT", STAT_PPP_AMNT_PDZ1_EVENTS_40_TO_60_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_PDZ2_EVENTS_0_TO_20_WERT = (RXBUF_UINT(14));
        // The parameter is determined by counting the number of PDZ2 events in the range 0 <x <20 km / h / Die Kenngröße
        // wird bestimmt, indem die Anzahl der PDZ2-Events im Bereich 0 < x < 20 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_PDZ2_EVENTS_0_TO_20_WERT", STAT_PPP_AMNT_PDZ2_EVENTS_0_TO_20_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_PDZ2_EVENTS_20_TO_40_WERT = (RXBUF_UINT(16));
        // The parameter is determined by counting the number of PDZ2 events in the range 20 <x <40 km / h / Die
        // Kenngröße wird bestimmt, indem die Anzahl der PDZ2-Events im Bereich 20 < x < 40 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_PDZ2_EVENTS_20_TO_40_WERT", STAT_PPP_AMNT_PDZ2_EVENTS_20_TO_40_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_PDZ2_EVENTS_40_TO_60_WERT = (RXBUF_UINT(18));
        // The parameter is determined by counting the number of PDZ2 events in the range 40 <x <60 km / h / Die
        // Kenngröße wird bestimmt, indem die Anzahl der PDZ2-Events im Bereich 40 < x < 60 km/h gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_PDZ2_EVENTS_40_TO_60_WERT", STAT_PPP_AMNT_PDZ2_EVENTS_40_TO_60_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_PREWARNUNG_REQUESTS_WERT = (RXBUF_UINT(20));
        // The parameter is determined by counting the number of pre-warning requests / Die Kenngröße wird bestimmt,
        // indem die Anzahl der Pre-Warning-Requests gezählt wird
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_PREWARNUNG_REQUESTS_WERT", STAT_PPP_AMNT_PREWARNUNG_REQUESTS_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_ACUTEWARNING_REQUESTS_WERT = (RXBUF_UINT(22));
        // The parameter is determined by counting the number of acute warning requests. / Die Kenngröße wird bestimmt,
        // indem die Anzahl der Acute-Warning-Requests gezählt wird.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_ACUTEWARNING_REQUESTS_WERT", STAT_PPP_AMNT_ACUTEWARNING_REQUESTS_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_HBA_REQUESTS_WERT = (RXBUF_UINT(24));
        // The parameter is determined by counting the number of HBA requests. / Die Kenngröße wird bestimmt, indem die
        // Anzahl der HBA-Requests gezählt wird.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_HBA_REQUESTS_WERT", STAT_PPP_AMNT_HBA_REQUESTS_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_PREFILL_REQUESTS_WERT = (RXBUF_UINT(26));
        // The parameter is determined by counting the number of prefill requests. / Die Kenngröße wird bestimmt, indem
        // die Anzahl der Prefill-Requests gezählt wird.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_PREFILL_REQUESTS_WERT", STAT_PPP_AMNT_PREFILL_REQUESTS_WERT, "\"Counts\"");

    unsigned short STAT_PPP_AMNT_BRAKE_REQUESTS_WERT = (RXBUF_UINT(28));
        // The parameter is determined by counting the number of brake requests. / Die Kenngröße wird bestimmt, indem die
        // Anzahl der Brake-Requests gezählt wird.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_AMNT_BRAKE_REQUESTS_WERT", STAT_PPP_AMNT_BRAKE_REQUESTS_WERT, "\"Counts\"");

    unsigned short STAT_PPP_DEACT_DRIVER_WERT = (RXBUF_UINT(30));
        // The parameter is determined by counting the number of times the pFGS function was switched off by the driver.
        // (Status change of the activation by pressing the button) / Die Kenngröße wird bestimmt, indem die Anzahl der
        // Abschaltungen der Funktion pFGS durch den Fahrer gezählt wird. (Statuswechsel der Aktivierung durch
        // Tasterbetätigung)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_DEACT_DRIVER_WERT", STAT_PPP_DEACT_DRIVER_WERT, "\"Counts\"");

    unsigned short STAT_PPP_DEACT_AVAILABILITY_WERT = (RXBUF_UINT(32));
        // The parameter is determined by counting the number of times the pFGS function was switched off by the KAFAS
        // system based on the availability concept (e.g. recognition qualifier, degradation concept, ...). / Die
        // Kenngröße wird bestimmt, indem die Anzahl der Abschaltungen der Funktion pFGS durch das KAFAS System aufgrund
        // des Verfügbarkeitskonzeptes (z.B. Erkennungsqualifier, Degradationskonzept,...) gezählt wird.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_DEACT_AVAILABILITY_WERT", STAT_PPP_DEACT_AVAILABILITY_WERT, "\"Counts\"");

    unsigned short STAT_PPP_DEACT_WARNING_CHAIN_WERT = (RXBUF_UINT(34));
        // The parameter is determined by counting the number of times the pPP function has been switched off by the
        // KAFAS system based on the braking and warning chain. / Die Kenngröße wird bestimmt, indem die Anzahl der
        // Abschaltungen der Funktion pPP durch das KAFAS System aufgrund der Brems-und Warnkette gezählt wird.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_DEACT_WARNING_CHAIN_WERT", STAT_PPP_DEACT_WARNING_CHAIN_WERT, "\"Counts\"");

    unsigned long STAT_PPP_OPERATION_TIME_CL50_WERT = (RXBUF_UINT32(36));
        // The parameter is determined by always counting the operating time in seconds from terminal 50. / Die Kenngröße
        // wird bestimmt, indem immer ab Kl 50 die Betriebszeit in Sekunden gezählt wird.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_OPERATION_TIME_CL50_WERT", STAT_PPP_OPERATION_TIME_CL50_WERT, "\"s\"");

    unsigned long STAT_PPP_OPERATION_TIME_ACTIVE_WERT = (RXBUF_UINT32(40));
        // The parameter is determined by always counting the operating time in seconds from terminal 50 while the pFGS
        // function is activated. / Die Kenngröße wird bestimmt, indem immer ab Kl 50 die Betriebszeit in Sekunden
        // gezählt wird, während die pFGS-Funktion aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_OPERATION_TIME_ACTIVE_WERT", STAT_PPP_OPERATION_TIME_ACTIVE_WERT, "\"s\"");

    unsigned short STAT_PPP_FS_CC_WERT = (RXBUF_UINT(44));
        // The parameter is determined by counting the number of Check Control messages triggered due to reduced
        // visibility for the pFGS function. / Die Kenngröße wird bestimmt, indem die Anzahl der ausgelösten Check
        // Control Meldungen aufgrund reduzierter Sicht für die Funktion pFGS gezählt wird.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_FS_CC_WERT", STAT_PPP_FS_CC_WERT, "\"Counts\"");

    unsigned long STAT_PPP_DRIVEN_TIME_FS_ACT_WERT = (RXBUF_UINT32(46));
        // The parameter is determined by determining the operating time from Kl 50 in seconds in which pFGS is in the
        // reduced visibility status and activated by the driver. / Die Kenngröße wird bestimmt, indem die Betriebszeit
        // ab Kl 50 in Sekunden ermittelt wird, in der pFGS im Status  reduzierte Sicht  und vom Fahrer aktiviert ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "FASTA_PPP_DATA", "STAT_PPP_DRIVEN_TIME_FS_ACT_WERT", STAT_PPP_DRIVEN_TIME_FS_ACT_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_FASTA_CCM_DATA: {                                               // 0x4011
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_FASTA_CCM_DATA", 6);
        break;
    }

    unsigned short STAT_CCM_AMNT_BRAKE_20_WERT = (RXBUF_UINT(0));
        // The parameter is determined by counting the number of CCM brakes in which the speed of the host vehicle at the
        // start of braking is greater than or equal to 0 km / h and less than 20 km / h. / Die Kenngröße wird bestimmt,
        // indem die Anzahl der CCM-Bremsungen gezählt wird, bei denen die Geschwindigkeit des Egofahrzeugs zu
        // Bremsbeginn größer gleich 0 km/h und kleiner 20 km/h ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_CCM_DATA", "STAT_CCM_AMNT_BRAKE_20_WERT", STAT_CCM_AMNT_BRAKE_20_WERT, "\"Counts\"");

    unsigned short STAT_CCM_AMNT_BRAKE_40_WERT = (RXBUF_UINT(2));
        // The parameter is determined by counting the number of CCM brakes in which the speed of the host vehicle at the
        // start of braking is greater than or equal to 20 km / h and less than 40 km / h. / Die Kenngröße wird bestimmt,
        // indem die Anzahl der CCM-Bremsungen gezählt wird, bei denen die Geschwindigkeit des Egofahrzeugs zu
        // Bremsbeginn größer gleich 20 km/h und kleiner 40 km/h ist.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_CCM_DATA", "STAT_CCM_AMNT_BRAKE_40_WERT", STAT_CCM_AMNT_BRAKE_40_WERT, "\"Counts\"");

    unsigned short STAT_CCM_AMNT_BRAKE_GEQ40_WERT = (RXBUF_UINT(4));
        // The parameter is determined by counting the number of CCM brakes in which the speed of the host vehicle is
        // greater than or equal to 40 km / h at the beginning of the braking / Die Kenngröße wird bestimmt, indem die
        // Anzahl der CCM-Bremsungen gezählt wird, bei denen die Geschwindigkeit des Egofahrzeugs zu Bremsbeginn größer
        // gleich 40 km/h ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "FASTA_CCM_DATA", "STAT_CCM_AMNT_BRAKE_GEQ40_WERT", STAT_CCM_AMNT_BRAKE_GEQ40_WERT, "\"Counts\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__KAFAS_ENVINT_DATA: {                                           // 0x4012
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__KAFAS_ENVINT_DATA", 8);
        break;
    }

    unsigned long STAT_ENVINT_DRIVEN_DIST_FS_WERT = (RXBUF_UINT32(0));
        // Cont the number of km driven with degraded availability / Cont the number of km driven with degraded
        // availability
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ENVINT_DATA", "STAT_ENVINT_DRIVEN_DIST_FS_WERT", STAT_ENVINT_DRIVEN_DIST_FS_WERT, "\"km\"");

    unsigned long STAT_ENVINT_DRIVEN_TIME_FS_WERT = (RXBUF_UINT32(4));
        // Count the time in seconds driven with degraded availability / Count the time in seconds driven with degraded
        // availability
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "_KAFAS_ENVINT_DATA", "STAT_ENVINT_DRIVEN_TIME_FS_WERT", STAT_ENVINT_DRIVEN_TIME_FS_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_PPP_ANFORDERUNGEN: {                                            // 0x4016
    if (datalen < 9) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_PPP_ANFORDERUNGEN", 9);
        break;
    }

    unsigned char STAT_TYPE_OF_WARNING = (RXBUF_UCHAR(0));
        // 0x01 if only a Brake request according to 2) is triggered 0x02 if only an Acute warning request according to
        // 1) is triggered 0x03 if both an Acute warning request and a Brake request is triggered / 0x01 if only a Brake
        // request according to 2) is triggered 0x02 if only an Acute warning request according to 1)  is triggered 0x03
        // if both an Acute warning request and a Brake request is triggered
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "PPP_ANFORDERUNGEN", "STAT_TYPE_OF_WARNING", STAT_TYPE_OF_WARNING, "\"0-n\"");

    unsigned long STAT_TIMESTAMP_ACUTE_WERT = (RXBUF_UINT32(1));
        // The time stamp is the system time value (message 328h) when the warning happened / The time stamp is the
        // system time value (message 328h) when the warning happened
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "PPP_ANFORDERUNGEN", "STAT_TIMESTAMP_ACUTE_WERT", STAT_TIMESTAMP_ACUTE_WERT, "\"s\"");

    unsigned long STAT_TIMESTAMP_BRAKE_WERT = (RXBUF_UINT32(5));
        // The time stamp is the system time value (message 328h) when the warning happened. / The time stamp is the
        // system time value (message 328h) when the warning happened.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%lu%s\n", "KAF", "PPP_ANFORDERUNGEN", "STAT_TIMESTAMP_BRAKE_WERT", STAT_TIMESTAMP_BRAKE_WERT, "\"s\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__GENERIC_EYEQ2_INFO: {                                          // 0x4017
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__GENERIC_EYEQ2_INFO", 1);
        break;
    }

    unsigned char STAT_EYEQ2_RESTARTS_WERT = (RXBUF_UCHAR(0));
        // EyeQ2 restarts, 1 byte Counter for number of EyeQ2 restarts caused by camera error debouncing as described in
        // DTC 0x800ABB - Camera Connection Error / EyeQ2 restarts, 1 byte Counter for number of EyeQ2 restarts caused by
        // camera error  debouncing  as described in DTC 0x800ABB - Camera Connection Error
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_GENERIC_EYEQ2_INFO", "STAT_EYEQ2_RESTARTS_WERT", STAT_EYEQ2_RESTARTS_WERT, "\"Counts\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__STATUS_CAMERA_MONITORING_WERT: {                               // 0x4050
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__STATUS_CAMERA_MONITORING_WERT", 7);
        break;
    }

    unsigned short STAT_FRAME_INDEX_WERT = (RXBUF_UINT(0));
        // This is a frame counter, that shall be increased for every frame that is not skipped. Frames that are skipped
        // for any reason shall not increment this counter. When the counter reaches over 65535, it shall restart from 0.
        // The counter shall restart from 0 at every startup of the EyeQ2. / This is a frame counter, that shall be
        // increased for every frame that is not skipped. Frames that are skipped for any reason shall not increment this
        // counter. When the counter reaches over 65535, it shall restart from 0. The counter shall restart from 0 at
        // every startup of the EyeQ2.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_STATUS_CAMERA_MONITORING_WERT", "STAT_FRAME_INDEX_WERT", STAT_FRAME_INDEX_WERT, "\"Counts\"");

    unsigned short STAT_VIDEO_ERROR_COUNT_WERT = (RXBUF_UINT(2));
        // The number of bad frames received from the camera (frames dropped due to data / sync errors). This counter
        // shall be increased with one for each cycle the video error signal is set in the 0x400 message. / The number of
        // bad frames received from the camera (frames dropped due to data/sync errors). This counter shall be increased
        // with one for each cycle the  Video error  signal is set in the 0x400 message.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_STATUS_CAMERA_MONITORING_WERT", "STAT_VIDEO_ERROR_COUNT_WERT", STAT_VIDEO_ERROR_COUNT_WERT, "\"Counts\"");

    unsigned short STAT_DROPPED_FRAME_COUNT_WERT = (RXBUF_UINT(4));
        // The number of dropped frames. This counter shall be increased when there is a video error and when the EyeQ2
        // skips a frame for any other reason, such as too long processing time for the preceding frame. / The number of
        // dropped frames. This counter shall be increased when there is a video error and when the EyeQ2 skips a frame
        // for any other reason, such as too long processing time for the preceding frame.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_STATUS_CAMERA_MONITORING_WERT", "STAT_DROPPED_FRAME_COUNT_WERT", STAT_DROPPED_FRAME_COUNT_WERT, "\"Counts\"");

    unsigned char STAT_CAMERA_TEMP_WERT = (RXBUF_UCHAR(6)-60.0);
        // The camera temperature, as read by the EyeQ2 via I2C. The camera temperature shall be read from the EyeQ2
        // every 10 seconds. / The camera temperature, as read by the EyeQ2 via I2C. The camera temperature shall be read
        // from the EyeQ2 every 10 seconds.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_STATUS_CAMERA_MONITORING_WERT", "STAT_CAMERA_TEMP_WERT", STAT_CAMERA_TEMP_WERT, "\"°C\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_ABSCHALTGRUND_FERNLICHT: {                                      // 0xD341
    if (datalen < 8) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_ABSCHALTGRUND_FERNLICHT", 8);
        break;
    }

    unsigned char STAT_FLA_ENTGEGENKOMMENDES_FAHRZEUG = (RXBUF_UCHAR(0));
        // Indicates whether an oncoming vehicle has been detected: 0 = no vehicle detected, 1 = vehicle detected / Gibt
        // aus, ob ein entgegenkommendes Fahrzeug erkannt worden ist:  0 = kein Fahrzeug erkannt,  1 = Fahrzeug erkannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ABSCHALTGRUND_FERNLICHT", "STAT_FLA_ENTGEGENKOMMENDES_FAHRZEUG", STAT_FLA_ENTGEGENKOMMENDES_FAHRZEUG, "\"0/1\"");

    unsigned char STAT_FLA_VORAUSFAHRENDES_FAHRZEUG = (RXBUF_UCHAR(1));
        // Indicates whether a vehicle in front has been detected: 0 = no vehicle detected, 1 = vehicle detected / Gibt
        // aus, ob ein vorausfahrendes Fahrzeug erkannt worden ist:  0 = kein Fahrzeug erkannt,  1 = Fahrzeug erkannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ABSCHALTGRUND_FERNLICHT", "STAT_FLA_VORAUSFAHRENDES_FAHRZEUG", STAT_FLA_VORAUSFAHRENDES_FAHRZEUG, "\"0/1\"");

    unsigned char STAT_FLA_GESCHWINDIGKEITSLIMIT = (RXBUF_UCHAR(2));
        // Indicates whether the speed below the limit has been detected: 0 = speed above the threshold, high beam is
        // switched on, 1 = speed below the threshold, high beam is switched off / Gibt aus, ob die Geschwindigkeit
        // unterhalb der Grenze erkannt worden ist:  0 = Geschwindigkeit oberhalb der Schwelle, Fernlicht wird
        // eingeschaltet,  1 = Geschwindigkeit unterhalb der Schwelle, Fernlicht wird abgeschaltet
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ABSCHALTGRUND_FERNLICHT", "STAT_FLA_GESCHWINDIGKEITSLIMIT", STAT_FLA_GESCHWINDIGKEITSLIMIT, "\"0/1\"");

    unsigned char STAT_FLA_UMGEBUNGSHELLIGKEIT = (RXBUF_UCHAR(3));
        // Indicates whether ambient brightness (day) has been recognized: 0 = no brightness (night) recognized, 1 =
        // brightness (day) recognized / Gibt aus, ob Umgebungshelligkeit (Tag) erkannt worden ist:  0 = kein Helligkeit
        // (Nacht) erkannt,  1 = Helligkeit (Tag) erkannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ABSCHALTGRUND_FERNLICHT", "STAT_FLA_UMGEBUNGSHELLIGKEIT", STAT_FLA_UMGEBUNGSHELLIGKEIT, "\"0/1\"");

    unsigned char STAT_FLA_ORTSCHAFTSERKENNUNG = (RXBUF_UCHAR(4));
        // Indicates whether sufficient lighting has been detected: 0 = insufficient lighting detected, 1 = sufficient
        // lighting detected / Gibt aus, ob eine ausreichende Beleuchtung erkannt worden ist:  0 = keine ausreichende
        // Beleuchtung erkannt,  1 = ausreichende Beleuchtung erkannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ABSCHALTGRUND_FERNLICHT", "STAT_FLA_ORTSCHAFTSERKENNUNG", STAT_FLA_ORTSCHAFTSERKENNUNG, "\"0/1\"");

    unsigned char STAT_FLA_NEBELERKENNUNG = (RXBUF_UCHAR(5));
        // Indicates whether fog has been detected: 0 = no fog, 1 = fog detected / Gibt aus, ob Nebel erkannt worden ist:
        // 0 = kein Nebel,  1 = Nebel erkannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ABSCHALTGRUND_FERNLICHT", "STAT_FLA_NEBELERKENNUNG", STAT_FLA_NEBELERKENNUNG, "\"0/1\"");

    unsigned char STAT_FLA_AUTOBAHNMODE = (RXBUF_UCHAR(6));
        // Indicates whether a motorway has been recognized: 0 = no motorway, 1 = motorway recognized / Gibt aus, ob
        // Autobahn erkannt worden ist:  0 = keine Autobahn,  1 = Autobahn erkannt
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ABSCHALTGRUND_FERNLICHT", "STAT_FLA_AUTOBAHNMODE", STAT_FLA_AUTOBAHNMODE, "\"0/1\"");

    unsigned char STAT_FLA_VERZOEGERUNGSZEIT = (RXBUF_UCHAR(7));
        // Indicates whether the high beam is not switched on due to a time delay: 0 = no time delay, 1 = time delay /
        // Gibt aus, ob wegen einer Zeiterzögerung das Fernlicht nicht eingeschaltet wird:  0 = keine Zeitverzögerung,  1
        // = Zeitverzögerung
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ABSCHALTGRUND_FERNLICHT", "STAT_FLA_VERZOEGERUNGSZEIT", STAT_FLA_VERZOEGERUNGSZEIT, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_KONFIGURATION_KAFAS: {                                          // 0xD374
    if (datalen < 6) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_KONFIGURATION_KAFAS", 6);
        break;
    }

    unsigned char STAT_VORHANDEN_TLC = (RXBUF_UCHAR(0));
        // Indicates whether the time-to-line crossing function is available: 0 = not available; 1 = present / Gibt an,
        // ob die Funktion Time-to-Line Crossing vorhanden ist: 0= nicht vorhanden; 1= vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "KONFIGURATION_KAFAS", "STAT_VORHANDEN_TLC", STAT_VORHANDEN_TLC, "\"0/1\"");

    unsigned char STAT_VORHANDEN_FLA = (RXBUF_UCHAR(1));
        // Indicates whether the high beam assistant function is available: 0 = not available; 1 = present / Gibt an, ob
        // die Funktion Fernlichtassistent vorhanden ist: 0= nicht vorhanden; 1= vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "KONFIGURATION_KAFAS", "STAT_VORHANDEN_FLA", STAT_VORHANDEN_FLA, "\"0/1\"");

    unsigned char STAT_VORHANDEN_SLI = (RXBUF_UCHAR(2));
        // Indicates whether the Speed-Limit-Info function is available: 0 = not available; 1 = present / Gibt an, ob die
        // Funktion Speed-Limit-Info vorhanden ist: 0= nicht vorhanden; 1= vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "KONFIGURATION_KAFAS", "STAT_VORHANDEN_SLI", STAT_VORHANDEN_SLI, "\"0/1\"");

    unsigned char STAT_VORHANDEN_NPI = (RXBUF_UCHAR(3));
        // Indicates whether the NoPassing-Info function is available: 0 = not available; 1 = present / Gibt an, ob die
        // Funktion NoPassing-Info vorhanden ist: 0= nicht vorhanden; 1= vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "KONFIGURATION_KAFAS", "STAT_VORHANDEN_NPI", STAT_VORHANDEN_NPI, "\"0/1\"");

    unsigned char STAT_VORHANDEN_FCW = (RXBUF_UCHAR(4));
        // Indicates whether the Forward Collision Warning function is available: 0 = not available; 1 = present / Gibt
        // an, ob die Funktion Forward-Collision-Warning vorhanden ist: 0= nicht vorhanden; 1= vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "KONFIGURATION_KAFAS", "STAT_VORHANDEN_FCW", STAT_VORHANDEN_FCW, "\"0/1\"");

    unsigned char STAT_VORHANDEN_PED = (RXBUF_UCHAR(5));
        // Indicates whether the Pedistrian Recognition function is available: 0 = not available; 1 = present / Gibt an,
        // ob die Funktion Pedistrian Recognition (Fußgängererkennung) vorhanden ist: 0= nicht vorhanden; 1= vorhanden
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "KONFIGURATION_KAFAS", "STAT_VORHANDEN_PED", STAT_VORHANDEN_PED, "\"0/1\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_KAFAS_VINS_LESEN: {                                             // 0xD393
    if (datalen < 15) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_KAFAS_VINS_LESEN", 15);
        break;
    }

    unsigned char STAT_KAFAS_VIN_STATUS_NR = (RXBUF_UCHAR(14));
        // Indicates whether the assignment of camera to control unit matches: 0x00: NO MATCH, 0x01: MATCH / Gibt aus, ob
        // die Zuordnung Kamera zu Steuergerät übereinstimmt:  0x00: KEINE UEBEREINSTIMMUNG,  0x01: UEBEREINSTIMMUNG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "KAFAS_VINS_LESEN", "STAT_KAFAS_VIN_STATUS_NR", STAT_KAFAS_VIN_STATUS_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_KALIBRIERDATEN_KAFAS: {                                         // 0xD396
    if (datalen < 25) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_KALIBRIERDATEN_KAFAS", 25);
        break;
    }

    unsigned short STAT_OFFLINE_YAW_WERT = (RXBUF_UINT(0));
        // Offline yaw angle / Offline Yaw-Winkel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_OFFLINE_YAW_WERT", STAT_OFFLINE_YAW_WERT, "\"Pixel\"");

    unsigned short STAT_OFFLINE_HORIZON_WERT = (RXBUF_UINT(2));
        // Offline horizon angle / Offline Horizon-Winkel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_OFFLINE_HORIZON_WERT", STAT_OFFLINE_HORIZON_WERT, "\"Pixel\"");

    float STAT_OFFLINE_ROLL_WERT = (RXBUF_UINT(4)/100.0f);
        // Offline roll angle / Offline Roll-Winkel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_OFFLINE_ROLL_WERT", STAT_OFFLINE_ROLL_WERT, "\"Grad\"");

    unsigned short STAT_ONLINE_YAW_WERT = (RXBUF_UINT(6));
        // Online yaw angle / Online Yaw-Winkel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_ONLINE_YAW_WERT", STAT_ONLINE_YAW_WERT, "\"Pixel\"");

    unsigned short STAT_ONLINE_HORIZON_WERT = (RXBUF_UINT(8));
        // Online horizon angle / Online Horizon-Winkel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_ONLINE_HORIZON_WERT", STAT_ONLINE_HORIZON_WERT, "\"Pixel\"");

    float STAT_ONLINE_ROLL_WERT = (RXBUF_UINT(10)/100.0f);
        // Online roll angle / Online Roll-Winkel
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_ONLINE_ROLL_WERT", STAT_ONLINE_ROLL_WERT, "\"Grad\"");

    unsigned short STAT_KAM_HOEHE_WERT = (RXBUF_UINT(12));
        // Camera installation height / Kamera-Verbauhöhe
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_KAM_HOEHE_WERT", STAT_KAM_HOEHE_WERT, "\"mm\"");

    unsigned short STAT_BRENNWEITE_WERT = (RXBUF_UINT(14));
        // Focal length / Brennweite
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_BRENNWEITE_WERT", STAT_BRENNWEITE_WERT, "\"Pixel\"");

    unsigned short STAT_GRABBING_SHIFT_WERT = (RXBUF_UINT(16));
        // Grabbing shift / Grabbing-Shift
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "KALIBRIERDATEN_KAFAS", "STAT_GRABBING_SHIFT_WERT", STAT_GRABBING_SHIFT_WERT, "\"Pixel\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_KAMERAVERBINDUNG_ECU: {                                         // 0xD397
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_KAMERAVERBINDUNG_ECU", 1);
        break;
    }

    unsigned char STAT_KAFAS_VERBINDUNG_KAM_NR = (RXBUF_UCHAR(0));
        // For values see TAB_KAM_VERBINDUNG / Werte siehe TAB_KAM_VERBINDUNG
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "KAMERAVERBINDUNG_ECU", "STAT_KAFAS_VERBINDUNG_KAM_NR", STAT_KAFAS_VERBINDUNG_KAM_NR, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_ERGEBNIS_SLI: {                                                 // 0xD3AA
    if (datalen < 7) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_ERGEBNIS_SLI", 7);
        break;
    }

    unsigned char STAT_KAMERA_ZEICHEN_NR = (RXBUF_UCHAR(0));
        // Indicates which character was recognized by the camera: Results see TAB_ZEICHEN_KAMERA / Gibt aus, welches
        // Zeichen von der Kamera erkannt wurde:  Results siehe TAB_ZEICHEN_KAMERA
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ERGEBNIS_SLI", "STAT_KAMERA_ZEICHEN_NR", STAT_KAMERA_ZEICHEN_NR, "\"0-n\"");

    unsigned char STAT_KAMERA_GESCHWINDIGKEIT_WERT = (RXBUF_UCHAR(1));
        // Indicates the speed that was recognized in the characters: 0 = cancellation of everything, 5 to 150 in steps
        // of 5. / Gibt aus, welche Geschwindigkeit in den Zeichen erkannt wurde: 0 = Aufhebung alles, 5 bis 150 in 5-er
        // Schritten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ERGEBNIS_SLI", "STAT_KAMERA_GESCHWINDIGKEIT_WERT", STAT_KAMERA_GESCHWINDIGKEIT_WERT, "");

    unsigned char STAT_KARTE_ZEICHEN_NR = (RXBUF_UCHAR(2));
        // Indicates which character was read from the card: For results see TAB_ZEICHEN_KARTE / Gibt aus, welches
        // Zeichen aus der Karte gelesen wurde:  Results siehe TAB_ZEICHEN_KARTE
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ERGEBNIS_SLI", "STAT_KARTE_ZEICHEN_NR", STAT_KARTE_ZEICHEN_NR, "\"0-n\"");

    unsigned char STAT_KARTE_GESCHWINDIGKEIT_WERT = (RXBUF_UCHAR(3));
        // Indicates the speed that was read from the card: 0 = cancel everything, 5 to 150 in steps of 5. / Gibt aus,
        // welche Geschwindigkeit aus der Karte gelesen wurde: 0 = Aufhebung alles, 5 bis 150 in 5-er Schritten.
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ERGEBNIS_SLI", "STAT_KARTE_GESCHWINDIGKEIT_WERT", STAT_KARTE_GESCHWINDIGKEIT_WERT, "");

    unsigned char STAT_FUSIONIERT_ZEICHEN_NR = (RXBUF_UCHAR(4));
        // Indicates which character is output from the merged recognition result: Results see TAB_ZEICHEN_FUSIONIERT /
        // Gibt aus, welches Zeichen aus den fusioniertem Erkennungsergebnis ausgegeben wird: Results siehe
        // TAB_ZEICHEN_FUSIONIERT
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ERGEBNIS_SLI", "STAT_FUSIONIERT_ZEICHEN_NR", STAT_FUSIONIERT_ZEICHEN_NR, "\"0-n\"");

    unsigned char STAT_FUSIONIERT_GESCHWINDIGKEIT_WERT = (RXBUF_UCHAR(5));
        // Outputs the speed from the merged recognition result: 0 = cancel everything, 5 to 150 in steps of 5 / Gibt
        // aus, welche Geschwindigkeit aus dem fusionierten Erkennungsergebnis ausgegeben wird: 0 = Aufhebung alles, 5
        // bis 150 in 5-er Schritten
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ERGEBNIS_SLI", "STAT_FUSIONIERT_GESCHWINDIGKEIT_WERT", STAT_FUSIONIERT_GESCHWINDIGKEIT_WERT, "");

    unsigned char STAT_GUETE_KAM_SLI_GESCHW_WERT = (RXBUF_UCHAR(6));
        // Indicates the quality with which the restriction and cancellation sign for speeds was recognized with the
        // camera: 0 - 100 / Gibt aus, mit welcher Güte das Beschränkungs- und Aufhebungszeichen für Geschwindigkeiten
        // mit der Kamera erkannt wurde: 0 - 100
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "ERGEBNIS_SLI", "STAT_GUETE_KAM_SLI_GESCHW_WERT", STAT_GUETE_KAM_SLI_GESCHW_WERT, "\"%\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF_SPANNUNG_KLEMME_15N_WERT: {                                     // 0xDAD2
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF_SPANNUNG_KLEMME_15N_WERT", 2);
        break;
    }

    float STAT_SPANNUNG_KLEMME_15N_WERT = (RXBUF_UINT(0)/10.0f);
        // Voltage value on the control unit at terminal 15N (accurate to one decimal place) / Spannungswert am
        // Steuergerät an Klemme 15N (auf eine Nachkommastelle genau)
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%.4f%s\n", "KAF", "SPANNUNG_KLEMME_15N_WERT", "STAT_SPANNUNG_KLEMME_15N_WERT", STAT_SPANNUNG_KLEMME_15N_WERT, "\"V\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__DEBUG_AUSGABE: {                                               // 0xF001
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__DEBUG_AUSGABE", 2);
        break;
    }

    unsigned short STAT_DEBUG_AUSGABE = (RXBUF_UINT(0));
        // Returns the status of whether the debug message output is active / Liefert den Status ob die Ausgabe der
        // Debug-Nachrichten aktiv ist
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_DEBUG_AUSGABE", "STAT_DEBUG_AUSGABE", STAT_DEBUG_AUSGABE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__PEDANTIC_MODE: {                                               // 0xF003
    if (datalen < 1) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__PEDANTIC_MODE", 1);
        break;
    }

    unsigned char STAT_PEDANTIC_MODE = (RXBUF_UCHAR(0));
        // Activation status of Pedantic Mode for SLI and NPI / Aktivierungsstatus des Pedantic Mode für SLI und NPI
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%x%s\n", "KAF", "_PEDANTIC_MODE", "STAT_PEDANTIC_MODE", STAT_PEDANTIC_MODE, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }

  case I3_PID_KAF__ERASE_MICRO_CORE_DUMP: {                                       // 0xF004
    if (datalen < 2) {
        ESP_LOGW(TAG, "Received %d bytes for %s, expected %d", datalen, "I3_PID_KAF__ERASE_MICRO_CORE_DUMP", 2);
        break;
    }

    unsigned short STAT_ERASE_RESULT = (RXBUF_UINT(0));
        // Deletion result / Löschergebnis
    ESP_LOGD(TAG, "From ECU %s, pid %s: got %s=%u%s\n", "KAF", "_ERASE_MICRO_CORE_DUMP", "STAT_ERASE_RESULT", STAT_ERASE_RESULT, "\"0-n\"");

    // ==========  Add your processing here ==========
    hexdump(rxbuf, type, pid);

    break;
  }
