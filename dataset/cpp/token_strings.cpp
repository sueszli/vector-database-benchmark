static const map<Token, const char *> token_strings =
{
    { Token::SPACE, " " },
    /*
    CHAR_LITERAL = int('\''),
    STRING = int('\"'),
    IDENT = int('I'),

    // operations (1 char)
    BITAND = '&',
    BITOR = '|',
    COMPL = '~',
    NOT = '!',
    XOR = '^',

    // operations (multichar)
    AND = 300, // &&
    AND_ASSIGN, // &=
    NOT_EQ, // !=
    OR, // ||
    OR_EQ, // |=
    XOR_EQ, // ^= 
    */

    { Token::ADD_ASSIGN, "+=" },
    { Token::AND, "&&" },
    { Token::AND_ASSIGN, "&=" },
    { Token::ARROW, "->" },
    { Token::ARROWSTAR, "->*" },
    { Token::DECR, "--" },
    { Token::DIV_ASSIGN, "/=" },
    { Token::DOTSTAR, ".*" },
    { Token::ELLIPSIS, "..." },
    { Token::EQ, "==" },
    { Token::GEQ, ">=" },
    { Token::INCR, "++" },
    { Token::LEQ, "<=" },
    { Token::LSHIFT, "<<" },
    { Token::LSH_ASSIGN, "<<=" },
    { Token::MUL_ASSIGN, "*=" },
    { Token::MOD_ASSIGN, "%=" },
    { Token::NOT_EQ, "!=" },
    { Token::OR, "||" },
    { Token::OR_ASSIGN, "|=" },
    { Token::RSHIFT, ">>" },
    { Token::RSH_ASSIGN, ">>=" },
    { Token::SCOPE, "::" },
    { Token::SUB_ASSIGN, "-=" },
    { Token::XOR_ASSIGN, "^=" },
 
    { Token::ALIGNAS, "alignas" },
    { Token::ALIGNOF, "alignof" },
    { Token::ASM, "asm" },
    { Token::ATOMIC_CANCEL, "atomic_cancel" },
    { Token::ATOMIC_COMMIT, "atomic_commit" },
    { Token::ATOMIC_NOEXCEPT, "atomic_noexcept" },
    { Token::AUTO, "auto" },
    { Token::BOOL, "bool" },
    { Token::BREAK, "break" },
    { Token::CASE, "case" },
    { Token::CATCH, "catch" },
    { Token::CHAR, "char" },
    { Token::CHAR16_T, "char16_t" },
    { Token::CHAR32_T, "char32_t" },
    { Token::CLASS, "class" },
    { Token::COMPLEX, "complex" },
    { Token::CONCEPT, "concept" },
    { Token::CONST, "const" },
    { Token::CONSTEXPR, "constexpr" },
    { Token::CONST_CAST, "const_cast" },
    { Token::CONTINUE, "continue" },
    { Token::DECLTYPE, "decltype" },
    { Token::DEFAULT, "default" },
    { Token::DELETE, "delete" },
    { Token::DO, "od" },
    { Token::DOUBLE, "double" },
    { Token::DYNAMIC_CAST, "dynamic_cast" },
    { Token::ELSE, "else" },
    { Token::ENUM, "enum" },
    { Token::EXPLICIT, "explicit" },
    { Token::EXPORT, "export" },
    { Token::EXTERN, "extern" },
    { Token::FALSE, "false" },
    { Token::FLOAT, "float" },
    { Token::FOR, "for" },
    { Token::FRIEND, "friend" },
    { Token::GOTO, "goto" },
    { Token::IF, "if" },
    { Token::IMAGINARY, "imaginary" },
    { Token::IMPORT, "import" },
    { Token::INLINE, "inline" },
    { Token::INT, "int" },
    { Token::LONG, "long" },
    { Token::MODULE, "module" },
    { Token::MUTABLE, "mutable" },
    { Token::NAMESPACE, "namespace" },
    { Token::NEW, "new" },
    { Token::NOEXCEPT, "noexcept" },
    { Token::NULLPTR, "nullptr" },
    { Token::OPERATOR, "operator" },
    { Token::PRIVATE, "private" },
    { Token::PROTECTED, "protected" },
    { Token::PUBLIC, "public" },
    { Token::REGISTER, "register" },
    { Token::REINTERPRET_CAST, "reinterpret_cast" },
    { Token::REQUIRES, "requires" },
    { Token::RESTRICT, "restrict" },
    { Token::RETURN, "return" },
    { Token::SHORT, "short" },
    { Token::SIGNED, "signed" },
    { Token::SIZEOF, "sizeof" },
    { Token::STATIC, "static" },
    { Token::STATIC_ASSERT, "static_assert" },
    { Token::STATIC_CAST, "static_cast" },
    { Token::STRUCT, "struct" },
    { Token::SWITCH, "switch" },
    { Token::SYNCHRONIZED, "synchronized" },
    { Token::TEMPLATE, "template" },
    { Token::THIS, "this" },
    { Token::THREAD_LOCAL, "thread_local" },
    { Token::THROW, "throw" },
    { Token::TRUE, "true" },
    { Token::TRY, "try" },
    { Token::TYPEDEF, "typedef" },
    { Token::TYPEID, "typeid" },
    { Token::TYPENAME, "typename" },
    { Token::UNION, "union" },
    { Token::UNSIGNED, "unsigned" },
    { Token::USING, "using" },
    { Token::VIRTUAL, "virtual" },
    { Token::VOID, "void" },
    { Token::VOLATILE, "volatile" },
    { Token::WCHAR_T, "wchar_t" },
    { Token::WHILE, "while" },
};
