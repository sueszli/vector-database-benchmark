

  Vector对象是如何增长的：
      为了支持快速访问，vector将元素连续存储。在连续存储的前提下，且容器的大小是可变的，考虑向vector或string中添加元素会发生什么？
    如果没有空间容纳新元素，容器不可能简单地将它添加到内存中其他位置---因为内存必须连续存储。
      容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。
      如果我们每次添加一个新元素，vector就执行一次这样的内存分配和释放操作，性能会慢到不能接受。
      为了避免这种代价，标准库采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时，vector和string的实现通常会
    分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多新元素，这样，就不需要每次添加新元素都重新分配内存了。
    
    
 
shrink_to_fit()  ：  将capacity()减少到和size()相同大小。  搭配clear()使用，可以清空vector所占内存。

reserve(n)  :   分配至少容纳n个元素的内存空间。假设当前size()==24， capacity()==32,调用reserve(50)就会使capacity()大于等于50；
                此时容器最多能容纳大于等于50个元素。如果再占满，添加新元素时，就需要两倍内存分配策略。size()+1，capacity()翻倍！

size()  :  指当前已经保存的元素数目

capacity()  ：  指在不分配新内存空间的情况下，容器最多能容纳的元素个数。
                每次在添加新元素时，都以capacity()分配策略往上分配，一般新空间内存大小是当前元素个数的两倍。
