// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2023 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>

#include "imgui.h"
#include "implot/implot.h"
#include "implot/implot_internal.h"


namespace py = pybind11;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_implot_internal(py::module& m)
{
    using namespace ImPlot;
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:implot_internal.h>    ////////////////////
    m.def("im_log10",
        py::overload_cast<float>(ImLog10),
        py::arg("x"),
        "(private API)");

    m.def("im_log10",
        py::overload_cast<double>(ImLog10),
        py::arg("x"),
        "(private API)");

    m.def("im_sinh",
        py::overload_cast<float>(ImSinh),
        py::arg("x"),
        "(private API)");

    m.def("im_sinh",
        py::overload_cast<double>(ImSinh),
        py::arg("x"),
        "(private API)");

    m.def("im_asinh",
        py::overload_cast<float>(ImAsinh),
        py::arg("x"),
        "(private API)");

    m.def("im_asinh",
        py::overload_cast<double>(ImAsinh),
        py::arg("x"),
        "(private API)");

    m.def("im_pos_mod",
        ImPosMod,
        py::arg("l"), py::arg("r"),
        " Returns always positive modulo (assumes r != 0)\n(private API)");

    m.def("im_nan",
        ImNan,
        py::arg("val"),
        " Returns True if val is NAN\n(private API)");

    m.def("im_nan_or_inf",
        ImNanOrInf,
        py::arg("val"),
        " Returns True if val is NAN or INFINITY\n(private API)");

    m.def("im_constrain_nan",
        ImConstrainNan,
        py::arg("val"),
        " Turns NANs to 0s\n(private API)");

    m.def("im_constrain_inf",
        ImConstrainInf,
        py::arg("val"),
        " Turns infinity to floating point maximums\n(private API)");

    m.def("im_constrain_log",
        ImConstrainLog,
        py::arg("val"),
        " Turns numbers less than or equal to 0 to 0.001 (sort of arbitrary, is there a better way?)\n(private API)");

    m.def("im_constrain_time",
        ImConstrainTime,
        py::arg("val"),
        " Turns numbers less than 0 to zero\n(private API)");

    m.def("im_almost_equal",
        ImAlmostEqual,
        py::arg("v1"), py::arg("v2"), py::arg("ulp") = 2,
        " True if two numbers are approximately equal using units in the last place.\n(private API)");

    m.def("im_mix_u32",
        ImMixU32,
        py::arg("a"), py::arg("b"), py::arg("s"),
        " Mix color a and b by factor s in [0 256]\n(private API)");

    m.def("im_lerp_u32",
        ImLerpU32,
        py::arg("colors"), py::arg("size"), py::arg("t"),
        " Lerp across an array of 32-bit collors given t in [0.0 1.0]\n(private API)");

    m.def("im_alpha_u32",
        ImAlphaU32,
        py::arg("col"), py::arg("alpha"),
        " Set alpha channel of 32-bit color from float in range [0.0 1.0]\n(private API)");


    py::enum_<ImPlotTimeUnit_>(m, "TimeUnit_", py::arithmetic(), "")
        .value("us", ImPlotTimeUnit_Us, "microsecond")
        .value("ms", ImPlotTimeUnit_Ms, "millisecond")
        .value("s", ImPlotTimeUnit_S, "second")
        .value("min", ImPlotTimeUnit_Min, "minute")
        .value("hr", ImPlotTimeUnit_Hr, "hour")
        .value("day", ImPlotTimeUnit_Day, "day")
        .value("mo", ImPlotTimeUnit_Mo, "month")
        .value("yr", ImPlotTimeUnit_Yr, "year")
        .value("count", ImPlotTimeUnit_COUNT, "");


    py::enum_<ImPlotDateFmt_>(m, "DateFmt_", py::arithmetic(), "")
        .value("none", ImPlotDateFmt_None, "")
        .value("day_mo", ImPlotDateFmt_DayMo, "10/3           [ --10-03      ]")
        .value("day_mo_yr", ImPlotDateFmt_DayMoYr, "10/3/91        [ 1991-10-03   ]")
        .value("mo_yr", ImPlotDateFmt_MoYr, "Oct 1991       [ 1991-10      ]")
        .value("mo", ImPlotDateFmt_Mo, "Oct            [ --10         ]")
        .value("yr", ImPlotDateFmt_Yr, "1991           [ 1991         ]");


    py::enum_<ImPlotTimeFmt_>(m, "TimeFmt_", py::arithmetic(), "")
        .value("none", ImPlotTimeFmt_None, "")
        .value("us", ImPlotTimeFmt_Us, ".428 552       [ .428 552     ]")
        .value("s_us", ImPlotTimeFmt_SUs, ":29.428 552    [ :29.428 552  ]")
        .value("s_ms", ImPlotTimeFmt_SMs, ":29.428        [ :29.428      ]")
        .value("s", ImPlotTimeFmt_S, ":29            [ :29          ]")
        .value("min_s_ms", ImPlotTimeFmt_MinSMs, "21:29.428      [ 21:29.428    ]")
        .value("hr_min_s_ms", ImPlotTimeFmt_HrMinSMs, "7:21:29.428pm  [ 19:21:29.428 ]")
        .value("hr_min_s", ImPlotTimeFmt_HrMinS, "7:21:29pm      [ 19:21:29     ]")
        .value("hr_min", ImPlotTimeFmt_HrMin, "7:21pm         [ 19:21        ]")
        .value("hr", ImPlotTimeFmt_Hr, "7pm            [ 19:00        ]");


    auto pyClassImPlotDateTimeSpec =
        py::class_<ImPlotDateTimeSpec>
            (m, "DateTimeSpec", "Combined date/time format spec")
        .def(py::init<>())
        .def(py::init<ImPlotDateFmt, ImPlotTimeFmt, bool, bool>(),
            py::arg("date_fmt"), py::arg("time_fmt"), py::arg("use_24_hr_clk") = false, py::arg("use_iso_8601") = false)
        .def_readwrite("date", &ImPlotDateTimeSpec::Date, "")
        .def_readwrite("time", &ImPlotDateTimeSpec::Time, "")
        .def_readwrite("use_iso8601", &ImPlotDateTimeSpec::UseISO8601, "")
        .def_readwrite("use24_hour_clock", &ImPlotDateTimeSpec::Use24HourClock, "")
        ;


    auto pyClassImPlotTime =
        py::class_<ImPlotTime>
            (m, "Time", "Two part timestamp struct.")
        .def_readwrite("s", &ImPlotTime::S, "second part")
        .def_readwrite("us", &ImPlotTime::Us, "microsecond part")
        .def(py::init<>())
        .def(py::init<time_t, int>(),
            py::arg("s"), py::arg("us") = 0)
        .def("roll_over",
            &ImPlotTime::RollOver, "(private API)")
        .def("to_double",
            &ImPlotTime::ToDouble, "(private API)")
        .def_static("from_double",
            &ImPlotTime::FromDouble,
            py::arg("t"),
            "(private API)")
        ;


    auto pyClassImPlotColormapData =
        py::class_<ImPlotColormapData>
            (m, "ColormapData", "Colormap data storage")
        .def_readwrite("keys", &ImPlotColormapData::Keys, "")
        .def_readwrite("key_counts", &ImPlotColormapData::KeyCounts, "")
        .def_readwrite("key_offsets", &ImPlotColormapData::KeyOffsets, "")
        .def_readwrite("tables", &ImPlotColormapData::Tables, "")
        .def_readwrite("table_sizes", &ImPlotColormapData::TableSizes, "")
        .def_readwrite("table_offsets", &ImPlotColormapData::TableOffsets, "")
        .def_readwrite("text", &ImPlotColormapData::Text, "")
        .def_readwrite("text_offsets", &ImPlotColormapData::TextOffsets, "")
        .def_readwrite("map", &ImPlotColormapData::Map, "")
        .def_readwrite("count", &ImPlotColormapData::Count, "")
        .def(py::init<>())
        .def("append",
            &ImPlotColormapData::Append,
            py::arg("name"), py::arg("keys"), py::arg("count"), py::arg("qual"),
            "(private API)")
        .def("_append_table",
            &ImPlotColormapData::_AppendTable,
            py::arg("cmap"),
            "(private API)")
        .def("rebuild_tables",
            &ImPlotColormapData::RebuildTables, "(private API)")
        .def("is_qual",
            &ImPlotColormapData::IsQual,
            py::arg("cmap"),
            "(private API)")
        .def("get_name",
            &ImPlotColormapData::GetName,
            py::arg("cmap"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_index",
            &ImPlotColormapData::GetIndex,
            py::arg("name"),
            "(private API)")
        .def("get_keys",
            &ImPlotColormapData::GetKeys,
            py::arg("cmap"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_key_count",
            &ImPlotColormapData::GetKeyCount,
            py::arg("cmap"),
            "(private API)")
        .def("get_key_color",
            &ImPlotColormapData::GetKeyColor,
            py::arg("cmap"), py::arg("idx"),
            "(private API)")
        .def("set_key_color",
            &ImPlotColormapData::SetKeyColor,
            py::arg("cmap"), py::arg("idx"), py::arg("value"),
            "(private API)")
        .def("get_table",
            &ImPlotColormapData::GetTable,
            py::arg("cmap"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_table_size",
            &ImPlotColormapData::GetTableSize,
            py::arg("cmap"),
            "(private API)")
        .def("get_table_color",
            &ImPlotColormapData::GetTableColor,
            py::arg("cmap"), py::arg("idx"),
            "(private API)")
        .def("lerp_table",
            &ImPlotColormapData::LerpTable,
            py::arg("cmap"), py::arg("t"),
            "(private API)")
        ;


    auto pyClassImPlotPointError =
        py::class_<ImPlotPointError>
            (m, "PointError", "ImPlotPoint with positive/negative error values")
        .def_readwrite("x", &ImPlotPointError::X, "")
        .def_readwrite("y", &ImPlotPointError::Y, "")
        .def_readwrite("neg", &ImPlotPointError::Neg, "")
        .def_readwrite("pos", &ImPlotPointError::Pos, "")
        .def(py::init<double, double, double, double>(),
            py::arg("x"), py::arg("y"), py::arg("neg"), py::arg("pos"))
        ;


    auto pyClassImPlotAnnotation =
        py::class_<ImPlotAnnotation>
            (m, "Annotation", "Interior plot label/annotation")
        .def_readwrite("pos", &ImPlotAnnotation::Pos, "")
        .def_readwrite("offset", &ImPlotAnnotation::Offset, "")
        .def_readwrite("color_bg", &ImPlotAnnotation::ColorBg, "")
        .def_readwrite("color_fg", &ImPlotAnnotation::ColorFg, "")
        .def_readwrite("text_offset", &ImPlotAnnotation::TextOffset, "")
        .def_readwrite("clamp", &ImPlotAnnotation::Clamp, "")
        .def(py::init<>())
        ;


    auto pyClassImPlotAnnotationCollection =
        py::class_<ImPlotAnnotationCollection>
            (m, "AnnotationCollection", "Collection of plot labels")
        .def_readwrite("text_buffer", &ImPlotAnnotationCollection::TextBuffer, "")
        .def_readwrite("size", &ImPlotAnnotationCollection::Size, "")
        .def(py::init<>())
        .def("append",
            [](ImPlotAnnotationCollection & self, const ImVec2 & pos, const ImVec2 & off, ImU32 bg, ImU32 fg, bool clamp, const char * fmt)
            {
                auto Append_adapt_variadic_format = [&self](const ImVec2 & pos, const ImVec2 & off, ImU32 bg, ImU32 fg, bool clamp, const char * fmt)
                {
                    self.Append(pos, off, bg, fg, clamp, "%s", fmt);
                };

                Append_adapt_variadic_format(pos, off, bg, fg, clamp, fmt);
            },
            py::arg("pos"), py::arg("off"), py::arg("bg"), py::arg("fg"), py::arg("clamp"), py::arg("fmt"),
            "(private API)")
        .def("get_text",
            [](ImPlotAnnotationCollection & self, int idx) -> const char *
            {
                auto GetText_adapt_force_lambda = [&self](int idx) -> const char *
                {
                    auto lambda_result = self.GetText(idx);
                    return lambda_result;
                };

                return GetText_adapt_force_lambda(idx);
            },
            py::arg("idx"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("reset",
            &ImPlotAnnotationCollection::Reset, "(private API)")
        ;


    auto pyClassImPlotTag =
        py::class_<ImPlotTag>
            (m, "Tag", "")
        .def(py::init<>([](
        ImAxis Axis = ImAxis(), double Value = double(), ImU32 ColorBg = ImU32(), ImU32 ColorFg = ImU32(), int TextOffset = int())
        {
            auto r = std::make_unique<ImPlotTag>();
            r->Axis = Axis;
            r->Value = Value;
            r->ColorBg = ColorBg;
            r->ColorFg = ColorFg;
            r->TextOffset = TextOffset;
            return r;
        })
        , py::arg("axis") = ImAxis(), py::arg("value") = double(), py::arg("color_bg") = ImU32(), py::arg("color_fg") = ImU32(), py::arg("text_offset") = int()
        )
        .def_readwrite("axis", &ImPlotTag::Axis, "")
        .def_readwrite("value", &ImPlotTag::Value, "")
        .def_readwrite("color_bg", &ImPlotTag::ColorBg, "")
        .def_readwrite("color_fg", &ImPlotTag::ColorFg, "")
        .def_readwrite("text_offset", &ImPlotTag::TextOffset, "")
        ;


    auto pyClassImPlotTagCollection =
        py::class_<ImPlotTagCollection>
            (m, "TagCollection", "")
        .def_readwrite("text_buffer", &ImPlotTagCollection::TextBuffer, "")
        .def_readwrite("size", &ImPlotTagCollection::Size, "")
        .def(py::init<>())
        .def("append",
            [](ImPlotTagCollection & self, ImAxis axis, double value, ImU32 bg, ImU32 fg, const char * fmt)
            {
                auto Append_adapt_variadic_format = [&self](ImAxis axis, double value, ImU32 bg, ImU32 fg, const char * fmt)
                {
                    self.Append(axis, value, bg, fg, "%s", fmt);
                };

                Append_adapt_variadic_format(axis, value, bg, fg, fmt);
            },
            py::arg("axis"), py::arg("value"), py::arg("bg"), py::arg("fg"), py::arg("fmt"),
            "(private API)")
        .def("get_text",
            [](ImPlotTagCollection & self, int idx) -> const char *
            {
                auto GetText_adapt_force_lambda = [&self](int idx) -> const char *
                {
                    auto lambda_result = self.GetText(idx);
                    return lambda_result;
                };

                return GetText_adapt_force_lambda(idx);
            },
            py::arg("idx"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("reset",
            &ImPlotTagCollection::Reset, "(private API)")
        ;


    auto pyClassImPlotTick =
        py::class_<ImPlotTick>
            (m, "Tick", "Tick mark info")
        .def_readwrite("plot_pos", &ImPlotTick::PlotPos, "")
        .def_readwrite("pixel_pos", &ImPlotTick::PixelPos, "")
        .def_readwrite("label_size", &ImPlotTick::LabelSize, "")
        .def_readwrite("text_offset", &ImPlotTick::TextOffset, "")
        .def_readwrite("major", &ImPlotTick::Major, "")
        .def_readwrite("show_label", &ImPlotTick::ShowLabel, "")
        .def_readwrite("level", &ImPlotTick::Level, "")
        .def_readwrite("idx", &ImPlotTick::Idx, "")
        .def(py::init<double, bool, int, bool>(),
            py::arg("value"), py::arg("major"), py::arg("level"), py::arg("show_label"))
        ;


    auto pyClassImPlotTicker =
        py::class_<ImPlotTicker>
            (m, "Ticker", "Collection of ticks")
        .def_readwrite("text_buffer", &ImPlotTicker::TextBuffer, "")
        .def_readwrite("max_size", &ImPlotTicker::MaxSize, "")
        .def_readwrite("late_size", &ImPlotTicker::LateSize, "")
        .def_readwrite("levels", &ImPlotTicker::Levels, "")
        .def(py::init<>())
        .def("add_tick",
            py::overload_cast<double, bool, int, bool, const char *>(&ImPlotTicker::AddTick),
            py::arg("value"), py::arg("major"), py::arg("level"), py::arg("show_label"), py::arg("label"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("add_tick",
            py::overload_cast<ImPlotTick>(&ImPlotTicker::AddTick),
            py::arg("tick"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_text",
            [](const ImPlotTicker & self, int idx) -> const char *
            {
                auto GetText_adapt_force_lambda = [&self](int idx) -> const char *
                {
                    auto lambda_result = self.GetText(idx);
                    return lambda_result;
                };

                return GetText_adapt_force_lambda(idx);
            },
            py::arg("idx"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_text",
            [](ImPlotTicker & self, const ImPlotTick & tick) -> const char *
            {
                auto GetText_adapt_force_lambda = [&self](const ImPlotTick & tick) -> const char *
                {
                    auto lambda_result = self.GetText(tick);
                    return lambda_result;
                };

                return GetText_adapt_force_lambda(tick);
            },
            py::arg("tick"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("override_size_late",
            &ImPlotTicker::OverrideSizeLate,
            py::arg("size"),
            "(private API)")
        .def("reset",
            &ImPlotTicker::Reset, "(private API)")
        .def("tick_count",
            &ImPlotTicker::TickCount, "(private API)")
        ;


    auto pyClassImPlotAxis =
        py::class_<ImPlotAxis>
            (m, "Axis", "Axis state information that must persist after EndPlot")
        .def_readwrite("id_", &ImPlotAxis::ID, "")
        .def_readwrite("flags", &ImPlotAxis::Flags, "")
        .def_readwrite("previous_flags", &ImPlotAxis::PreviousFlags, "")
        .def_readwrite("range", &ImPlotAxis::Range, "")
        .def_readwrite("range_cond", &ImPlotAxis::RangeCond, "")
        .def_readwrite("scale", &ImPlotAxis::Scale, "")
        .def_readwrite("fit_extents", &ImPlotAxis::FitExtents, "")
        .def_readwrite("ortho_axis", &ImPlotAxis::OrthoAxis, "")
        .def_readwrite("constraint_range", &ImPlotAxis::ConstraintRange, "")
        .def_readwrite("constraint_zoom", &ImPlotAxis::ConstraintZoom, "")
        .def_readwrite("ticker", &ImPlotAxis::Ticker, "")
        .def_readwrite("formatter_data", &ImPlotAxis::FormatterData, "")
        .def_readwrite("linked_min", &ImPlotAxis::LinkedMin, "")
        .def_readwrite("linked_max", &ImPlotAxis::LinkedMax, "")
        .def_readwrite("picker_level", &ImPlotAxis::PickerLevel, "")
        .def_readwrite("picker_time_min", &ImPlotAxis::PickerTimeMin, "")
        .def_readwrite("picker_time_max", &ImPlotAxis::PickerTimeMax, "")
        .def_readwrite("transform_data", &ImPlotAxis::TransformData, "")
        .def_readwrite("pixel_min", &ImPlotAxis::PixelMin, "")
        .def_readwrite("pixel_max", &ImPlotAxis::PixelMax, "")
        .def_readwrite("scale_min", &ImPlotAxis::ScaleMin, "")
        .def_readwrite("scale_max", &ImPlotAxis::ScaleMax, "")
        .def_readwrite("scale_to_pixel", &ImPlotAxis::ScaleToPixel, "")
        .def_readwrite("datum1", &ImPlotAxis::Datum1, "")
        .def_readwrite("datum2", &ImPlotAxis::Datum2, "")
        .def_readwrite("hover_rect", &ImPlotAxis::HoverRect, "")
        .def_readwrite("label_offset", &ImPlotAxis::LabelOffset, "")
        .def_readwrite("color_maj", &ImPlotAxis::ColorMaj, "")
        .def_readwrite("color_min", &ImPlotAxis::ColorMin, "")
        .def_readwrite("color_tick", &ImPlotAxis::ColorTick, "")
        .def_readwrite("color_txt", &ImPlotAxis::ColorTxt, "")
        .def_readwrite("color_bg", &ImPlotAxis::ColorBg, "")
        .def_readwrite("color_hov", &ImPlotAxis::ColorHov, "")
        .def_readwrite("color_act", &ImPlotAxis::ColorAct, "")
        .def_readwrite("color_hi_li", &ImPlotAxis::ColorHiLi, "")
        .def_readwrite("enabled", &ImPlotAxis::Enabled, "")
        .def_readwrite("vertical", &ImPlotAxis::Vertical, "")
        .def_readwrite("fit_this_frame", &ImPlotAxis::FitThisFrame, "")
        .def_readwrite("has_range", &ImPlotAxis::HasRange, "")
        .def_readwrite("has_format_spec", &ImPlotAxis::HasFormatSpec, "")
        .def_readwrite("show_default_ticks", &ImPlotAxis::ShowDefaultTicks, "")
        .def_readwrite("hovered", &ImPlotAxis::Hovered, "")
        .def_readwrite("held", &ImPlotAxis::Held, "")
        .def(py::init<>())
        .def("reset",
            &ImPlotAxis::Reset, "(private API)")
        .def("set_min",
            &ImPlotAxis::SetMin,
            py::arg("_min"), py::arg("force") = false,
            "(private API)")
        .def("set_max",
            &ImPlotAxis::SetMax,
            py::arg("_max"), py::arg("force") = false,
            "(private API)")
        .def("set_range",
            py::overload_cast<double, double>(&ImPlotAxis::SetRange),
            py::arg("v1"), py::arg("v2"),
            "(private API)")
        .def("set_range",
            py::overload_cast<const ImPlotRange &>(&ImPlotAxis::SetRange),
            py::arg("range"),
            "(private API)")
        .def("set_aspect",
            &ImPlotAxis::SetAspect,
            py::arg("unit_per_pix"),
            "(private API)")
        .def("pixel_size",
            &ImPlotAxis::PixelSize, "(private API)")
        .def("get_aspect",
            &ImPlotAxis::GetAspect, "(private API)")
        .def("constrain",
            &ImPlotAxis::Constrain, "(private API)")
        .def("update_transform_cache",
            &ImPlotAxis::UpdateTransformCache, "(private API)")
        .def("plot_to_pixels",
            &ImPlotAxis::PlotToPixels,
            py::arg("plt"),
            "(private API)")
        .def("pixels_to_plot",
            &ImPlotAxis::PixelsToPlot,
            py::arg("pix"),
            "(private API)")
        .def("extend_fit",
            &ImPlotAxis::ExtendFit,
            py::arg("v"),
            "(private API)")
        .def("extend_fit_with",
            &ImPlotAxis::ExtendFitWith,
            py::arg("alt"), py::arg("v"), py::arg("v_alt"),
            "(private API)")
        .def("apply_fit",
            &ImPlotAxis::ApplyFit,
            py::arg("padding"),
            "(private API)")
        .def("has_label",
            &ImPlotAxis::HasLabel, "(private API)")
        .def("has_grid_lines",
            &ImPlotAxis::HasGridLines, "(private API)")
        .def("has_tick_labels",
            &ImPlotAxis::HasTickLabels, "(private API)")
        .def("has_tick_marks",
            &ImPlotAxis::HasTickMarks, "(private API)")
        .def("will_render",
            &ImPlotAxis::WillRender, "(private API)")
        .def("is_opposite",
            &ImPlotAxis::IsOpposite, "(private API)")
        .def("is_inverted",
            &ImPlotAxis::IsInverted, "(private API)")
        .def("is_foreground",
            &ImPlotAxis::IsForeground, "(private API)")
        .def("is_auto_fitting",
            &ImPlotAxis::IsAutoFitting, "(private API)")
        .def("can_init_fit",
            &ImPlotAxis::CanInitFit, "(private API)")
        .def("is_range_locked",
            &ImPlotAxis::IsRangeLocked, "(private API)")
        .def("is_locked_min",
            &ImPlotAxis::IsLockedMin, "(private API)")
        .def("is_locked_max",
            &ImPlotAxis::IsLockedMax, "(private API)")
        .def("is_locked",
            &ImPlotAxis::IsLocked, "(private API)")
        .def("is_input_locked_min",
            &ImPlotAxis::IsInputLockedMin, "(private API)")
        .def("is_input_locked_max",
            &ImPlotAxis::IsInputLockedMax, "(private API)")
        .def("is_input_locked",
            &ImPlotAxis::IsInputLocked, "(private API)")
        .def("has_menus",
            &ImPlotAxis::HasMenus, "(private API)")
        .def("is_pan_locked",
            &ImPlotAxis::IsPanLocked,
            py::arg("increasing"),
            "(private API)")
        .def("push_links",
            &ImPlotAxis::PushLinks, "(private API)")
        .def("pull_links",
            &ImPlotAxis::PullLinks, "(private API)")
        ;


    auto pyClassImPlotAlignmentData =
        py::class_<ImPlotAlignmentData>
            (m, "AlignmentData", "Align plots group data")
        .def_readwrite("vertical", &ImPlotAlignmentData::Vertical, "")
        .def_readwrite("pad_a", &ImPlotAlignmentData::PadA, "")
        .def_readwrite("pad_b", &ImPlotAlignmentData::PadB, "")
        .def_readwrite("pad_a_max", &ImPlotAlignmentData::PadAMax, "")
        .def_readwrite("pad_b_max", &ImPlotAlignmentData::PadBMax, "")
        .def(py::init<>())
        .def("begin",
            &ImPlotAlignmentData::Begin, "(private API)")
        .def("update",
            [](ImPlotAlignmentData & self, float pad_a, float pad_b, float delta_a, float delta_b) -> std::tuple<float, float, float, float>
            {
                auto Update_adapt_modifiable_immutable_to_return = [&self](float pad_a, float pad_b, float delta_a, float delta_b) -> std::tuple<float, float, float, float>
                {
                    float & pad_a_adapt_modifiable = pad_a;
                    float & pad_b_adapt_modifiable = pad_b;
                    float & delta_a_adapt_modifiable = delta_a;
                    float & delta_b_adapt_modifiable = delta_b;

                    self.Update(pad_a_adapt_modifiable, pad_b_adapt_modifiable, delta_a_adapt_modifiable, delta_b_adapt_modifiable);
                    return std::make_tuple(pad_a, pad_b, delta_a, delta_b);
                };

                return Update_adapt_modifiable_immutable_to_return(pad_a, pad_b, delta_a, delta_b);
            },
            py::arg("pad_a"), py::arg("pad_b"), py::arg("delta_a"), py::arg("delta_b"),
            "(private API)")
        .def("end",
            &ImPlotAlignmentData::End, "(private API)")
        .def("reset",
            &ImPlotAlignmentData::Reset, "(private API)")
        ;


    auto pyClassImPlotItem =
        py::class_<ImPlotItem>
            (m, "Item", "State information for Plot items")
        .def_readwrite("id_", &ImPlotItem::ID, "")
        .def_readwrite("color", &ImPlotItem::Color, "")
        .def_readwrite("legend_hover_rect", &ImPlotItem::LegendHoverRect, "")
        .def_readwrite("name_offset", &ImPlotItem::NameOffset, "")
        .def_readwrite("show", &ImPlotItem::Show, "")
        .def_readwrite("legend_hovered", &ImPlotItem::LegendHovered, "")
        .def_readwrite("seen_this_frame", &ImPlotItem::SeenThisFrame, "")
        .def(py::init<>())
        ;


    auto pyClassImPlotLegend =
        py::class_<ImPlotLegend>
            (m, "Legend", "Holds Legend state")
        .def_readwrite("flags", &ImPlotLegend::Flags, "")
        .def_readwrite("previous_flags", &ImPlotLegend::PreviousFlags, "")
        .def_readwrite("location", &ImPlotLegend::Location, "")
        .def_readwrite("previous_location", &ImPlotLegend::PreviousLocation, "")
        .def_readwrite("scroll", &ImPlotLegend::Scroll, "")
        .def_readwrite("indices", &ImPlotLegend::Indices, "")
        .def_readwrite("labels", &ImPlotLegend::Labels, "")
        .def_readwrite("rect", &ImPlotLegend::Rect, "")
        .def_readwrite("rect_clamped", &ImPlotLegend::RectClamped, "")
        .def_readwrite("hovered", &ImPlotLegend::Hovered, "")
        .def_readwrite("held", &ImPlotLegend::Held, "")
        .def_readwrite("can_go_inside", &ImPlotLegend::CanGoInside, "")
        .def(py::init<>())
        .def("reset",
            &ImPlotLegend::Reset, "(private API)")
        ;


    auto pyClassImPlotItemGroup =
        py::class_<ImPlotItemGroup>
            (m, "ItemGroup", "Holds Items and Legend data")
        .def_readwrite("id_", &ImPlotItemGroup::ID, "")
        .def_readwrite("legend", &ImPlotItemGroup::Legend, "")
        .def_readwrite("colormap_idx", &ImPlotItemGroup::ColormapIdx, "")
        .def(py::init<>())
        .def("get_item_count",
            &ImPlotItemGroup::GetItemCount, "(private API)")
        .def("get_item_id",
            &ImPlotItemGroup::GetItemID,
            py::arg("label_id"),
            "(private API)")
        .def("get_item",
            py::overload_cast<ImGuiID>(&ImPlotItemGroup::GetItem),
            py::arg("id_"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_item",
            py::overload_cast<const char *>(&ImPlotItemGroup::GetItem),
            py::arg("label_id"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_or_add_item",
            &ImPlotItemGroup::GetOrAddItem,
            py::arg("id_"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_item_by_index",
            &ImPlotItemGroup::GetItemByIndex,
            py::arg("i"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_item_index",
            &ImPlotItemGroup::GetItemIndex,
            py::arg("item"),
            "(private API)")
        .def("get_legend_count",
            &ImPlotItemGroup::GetLegendCount, "(private API)")
        .def("get_legend_item",
            &ImPlotItemGroup::GetLegendItem,
            py::arg("i"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("get_legend_label",
            &ImPlotItemGroup::GetLegendLabel,
            py::arg("i"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("reset",
            &ImPlotItemGroup::Reset, "(private API)")
        ;


    auto pyClassImPlotPlot =
        py::class_<ImPlotPlot>
            (m, "Plot", "Holds Plot state information that must persist after EndPlot")
        .def_readwrite("id_", &ImPlotPlot::ID, "")
        .def_readwrite("flags", &ImPlotPlot::Flags, "")
        .def_readwrite("previous_flags", &ImPlotPlot::PreviousFlags, "")
        .def_readwrite("mouse_text_location", &ImPlotPlot::MouseTextLocation, "")
        .def_readwrite("mouse_text_flags", &ImPlotPlot::MouseTextFlags, "")
        .def_readwrite("text_buffer", &ImPlotPlot::TextBuffer, "")
        .def_readwrite("items", &ImPlotPlot::Items, "")
        .def_readwrite("current_x", &ImPlotPlot::CurrentX, "")
        .def_readwrite("current_y", &ImPlotPlot::CurrentY, "")
        .def_readwrite("frame_rect", &ImPlotPlot::FrameRect, "")
        .def_readwrite("canvas_rect", &ImPlotPlot::CanvasRect, "")
        .def_readwrite("plot_rect", &ImPlotPlot::PlotRect, "")
        .def_readwrite("axes_rect", &ImPlotPlot::AxesRect, "")
        .def_readwrite("select_rect", &ImPlotPlot::SelectRect, "")
        .def_readwrite("select_start", &ImPlotPlot::SelectStart, "")
        .def_readwrite("title_offset", &ImPlotPlot::TitleOffset, "")
        .def_readwrite("just_created", &ImPlotPlot::JustCreated, "")
        .def_readwrite("initialized", &ImPlotPlot::Initialized, "")
        .def_readwrite("setup_locked", &ImPlotPlot::SetupLocked, "")
        .def_readwrite("fit_this_frame", &ImPlotPlot::FitThisFrame, "")
        .def_readwrite("hovered", &ImPlotPlot::Hovered, "")
        .def_readwrite("held", &ImPlotPlot::Held, "")
        .def_readwrite("selecting", &ImPlotPlot::Selecting, "")
        .def_readwrite("selected", &ImPlotPlot::Selected, "")
        .def_readwrite("context_locked", &ImPlotPlot::ContextLocked, "")
        .def(py::init<>())
        .def("is_input_locked",
            &ImPlotPlot::IsInputLocked, "(private API)")
        .def("clear_text_buffer",
            &ImPlotPlot::ClearTextBuffer, "(private API)")
        .def("set_title",
            &ImPlotPlot::SetTitle,
            py::arg("title"),
            "(private API)")
        .def("has_title",
            &ImPlotPlot::HasTitle, "(private API)")
        .def("get_title",
            &ImPlotPlot::GetTitle,
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("x_axis",
            py::overload_cast<int>(&ImPlotPlot::XAxis),
            py::arg("i"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("x_axis",
            py::overload_cast<int>(&ImPlotPlot::XAxis),
            py::arg("i"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("y_axis",
            py::overload_cast<int>(&ImPlotPlot::YAxis),
            py::arg("i"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("y_axis",
            py::overload_cast<int>(&ImPlotPlot::YAxis),
            py::arg("i"),
            "(private API)",
            pybind11::return_value_policy::reference)
        .def("enabled_axes_x",
            &ImPlotPlot::EnabledAxesX, "(private API)")
        .def("enabled_axes_y",
            &ImPlotPlot::EnabledAxesY, "(private API)")
        .def("set_axis_label",
            &ImPlotPlot::SetAxisLabel,
            py::arg("axis"), py::arg("label"),
            "(private API)")
        .def("get_axis_label",
            &ImPlotPlot::GetAxisLabel,
            py::arg("axis"),
            "(private API)",
            pybind11::return_value_policy::reference)
        ;


    auto pyClassImPlotSubplot =
        py::class_<ImPlotSubplot>
            (m, "Subplot", "Holds subplot data that must persist after EndSubplot")
        .def_readwrite("id_", &ImPlotSubplot::ID, "")
        .def_readwrite("flags", &ImPlotSubplot::Flags, "")
        .def_readwrite("previous_flags", &ImPlotSubplot::PreviousFlags, "")
        .def_readwrite("items", &ImPlotSubplot::Items, "")
        .def_readwrite("rows", &ImPlotSubplot::Rows, "")
        .def_readwrite("cols", &ImPlotSubplot::Cols, "")
        .def_readwrite("current_idx", &ImPlotSubplot::CurrentIdx, "")
        .def_readwrite("frame_rect", &ImPlotSubplot::FrameRect, "")
        .def_readwrite("grid_rect", &ImPlotSubplot::GridRect, "")
        .def_readwrite("cell_size", &ImPlotSubplot::CellSize, "")
        .def_readwrite("row_ratios", &ImPlotSubplot::RowRatios, "")
        .def_readwrite("col_ratios", &ImPlotSubplot::ColRatios, "")
        .def_property("temp_sizes",
            [](ImPlotSubplot &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<float>::format());
                auto base = pybind11::array(dtype, {2}, {sizeof(float)});
                return pybind11::array(dtype, {2}, {sizeof(float)}, self.TempSizes, base);
            }, [](ImPlotSubplot& self) {},
            "")
        .def_readwrite("frame_hovered", &ImPlotSubplot::FrameHovered, "")
        .def_readwrite("has_title", &ImPlotSubplot::HasTitle, "")
        .def(py::init<>())
        ;


    auto pyClassImPlotNextPlotData =
        py::class_<ImPlotNextPlotData>
            (m, "NextPlotData", "Temporary data storage for upcoming plot")
        .def(py::init<>())
        .def("reset",
            &ImPlotNextPlotData::Reset, "(private API)")
        ;


    auto pyClassImPlotNextItemData =
        py::class_<ImPlotNextItemData>
            (m, "NextItemData", "Temporary data storage for upcoming item")
        .def_readwrite("line_weight", &ImPlotNextItemData::LineWeight, "")
        .def_readwrite("marker", &ImPlotNextItemData::Marker, "")
        .def_readwrite("marker_size", &ImPlotNextItemData::MarkerSize, "")
        .def_readwrite("marker_weight", &ImPlotNextItemData::MarkerWeight, "")
        .def_readwrite("fill_alpha", &ImPlotNextItemData::FillAlpha, "")
        .def_readwrite("error_bar_size", &ImPlotNextItemData::ErrorBarSize, "")
        .def_readwrite("error_bar_weight", &ImPlotNextItemData::ErrorBarWeight, "")
        .def_readwrite("digital_bit_height", &ImPlotNextItemData::DigitalBitHeight, "")
        .def_readwrite("digital_bit_gap", &ImPlotNextItemData::DigitalBitGap, "")
        .def_readwrite("render_line", &ImPlotNextItemData::RenderLine, "")
        .def_readwrite("render_fill", &ImPlotNextItemData::RenderFill, "")
        .def_readwrite("render_marker_line", &ImPlotNextItemData::RenderMarkerLine, "")
        .def_readwrite("render_marker_fill", &ImPlotNextItemData::RenderMarkerFill, "")
        .def_readwrite("has_hidden", &ImPlotNextItemData::HasHidden, "")
        .def_readwrite("hidden", &ImPlotNextItemData::Hidden, "")
        .def_readwrite("hidden_cond", &ImPlotNextItemData::HiddenCond, "")
        .def(py::init<>())
        .def("reset",
            &ImPlotNextItemData::Reset, "(private API)")
        ;


    auto pyClassImPlotContext =
        py::class_<ImPlotContext>
            (m, "Context", "Holds state information that must persist between calls to BeginPlot()/EndPlot()")
        .def(py::init<>([](
        ImPlotTicker CTicker = ImPlotTicker(), ImPlotAnnotationCollection Annotations = ImPlotAnnotationCollection(), ImPlotTagCollection Tags = ImPlotTagCollection(), ImPlotStyle Style = ImPlotStyle(), ImVector<ImGuiColorMod> ColorModifiers = ImVector<ImGuiColorMod>(), ImVector<ImGuiStyleMod> StyleModifiers = ImVector<ImGuiStyleMod>(), ImPlotColormapData ColormapData = ImPlotColormapData(), ImVector<int> TempInt1 = ImVector<int>(), int DigitalPlotItemCnt = int(), int DigitalPlotOffset = int(), ImPlotNextPlotData NextPlotData = ImPlotNextPlotData(), ImPlotNextItemData NextItemData = ImPlotNextItemData(), ImPlotInputMap InputMap = ImPlotInputMap(), bool OpenContextThisFrame = bool(), ImGuiTextBuffer MousePosStringBuilder = ImGuiTextBuffer())
        {
            auto r = std::make_unique<ImPlotContext>();
            r->CTicker = CTicker;
            r->Annotations = Annotations;
            r->Tags = Tags;
            r->Style = Style;
            r->ColorModifiers = ColorModifiers;
            r->StyleModifiers = StyleModifiers;
            r->ColormapData = ColormapData;
            r->TempInt1 = TempInt1;
            r->DigitalPlotItemCnt = DigitalPlotItemCnt;
            r->DigitalPlotOffset = DigitalPlotOffset;
            r->NextPlotData = NextPlotData;
            r->NextItemData = NextItemData;
            r->InputMap = InputMap;
            r->OpenContextThisFrame = OpenContextThisFrame;
            r->MousePosStringBuilder = MousePosStringBuilder;
            return r;
        })
        , py::arg("c_ticker") = ImPlotTicker(), py::arg("annotations") = ImPlotAnnotationCollection(), py::arg("tags") = ImPlotTagCollection(), py::arg("style") = ImPlotStyle(), py::arg("color_modifiers") = ImVector<ImGuiColorMod>(), py::arg("style_modifiers") = ImVector<ImGuiStyleMod>(), py::arg("colormap_data") = ImPlotColormapData(), py::arg("temp_int1") = ImVector<int>(), py::arg("digital_plot_item_cnt") = int(), py::arg("digital_plot_offset") = int(), py::arg("next_plot_data") = ImPlotNextPlotData(), py::arg("next_item_data") = ImPlotNextItemData(), py::arg("input_map") = ImPlotInputMap(), py::arg("open_context_this_frame") = bool(), py::arg("mouse_pos_string_builder") = ImGuiTextBuffer()
        )
        .def_readwrite("current_plot", &ImPlotContext::CurrentPlot, "")
        .def_readwrite("current_subplot", &ImPlotContext::CurrentSubplot, "")
        .def_readwrite("current_items", &ImPlotContext::CurrentItems, "")
        .def_readwrite("current_item", &ImPlotContext::CurrentItem, "")
        .def_readwrite("previous_item", &ImPlotContext::PreviousItem, "")
        .def_readwrite("c_ticker", &ImPlotContext::CTicker, "Tick Marks and Labels")
        .def_readwrite("annotations", &ImPlotContext::Annotations, "")
        .def_readwrite("tags", &ImPlotContext::Tags, "")
        .def_readwrite("style", &ImPlotContext::Style, "")
        .def_readwrite("color_modifiers", &ImPlotContext::ColorModifiers, "")
        .def_readwrite("style_modifiers", &ImPlotContext::StyleModifiers, "")
        .def_readwrite("colormap_data", &ImPlotContext::ColormapData, "")
        .def_readwrite("temp_int1", &ImPlotContext::TempInt1, "")
        .def_readwrite("digital_plot_item_cnt", &ImPlotContext::DigitalPlotItemCnt, "")
        .def_readwrite("digital_plot_offset", &ImPlotContext::DigitalPlotOffset, "")
        .def_readwrite("next_plot_data", &ImPlotContext::NextPlotData, "")
        .def_readwrite("next_item_data", &ImPlotContext::NextItemData, "")
        .def_readwrite("input_map", &ImPlotContext::InputMap, "")
        .def_readwrite("open_context_this_frame", &ImPlotContext::OpenContextThisFrame, "")
        .def_readwrite("mouse_pos_string_builder", &ImPlotContext::MousePosStringBuilder, "")
        .def_readwrite("sort_items", &ImPlotContext::SortItems, "")
        .def_readwrite("current_alignment_h", &ImPlotContext::CurrentAlignmentH, "")
        .def_readwrite("current_alignment_v", &ImPlotContext::CurrentAlignmentV, "")
        ;


    m.def("initialize",
        ImPlot::Initialize,
        py::arg("ctx"),
        "Initializes an ImPlotContext");

    m.def("reset_ctx_for_next_plot",
        ImPlot::ResetCtxForNextPlot,
        py::arg("ctx"),
        "Resets an ImPlot context for the next call to BeginPlot");

    m.def("reset_ctx_for_next_aligned_plots",
        ImPlot::ResetCtxForNextAlignedPlots,
        py::arg("ctx"),
        "Resets an ImPlot context for the next call to BeginAlignedPlots");

    m.def("reset_ctx_for_next_subplot",
        ImPlot::ResetCtxForNextSubplot,
        py::arg("ctx"),
        "Resets an ImPlot context for the next call to BeginSubplot");

    m.def("get_plot",
        ImPlot::GetPlot,
        py::arg("title"),
        "Gets a plot from the current ImPlotContext",
        pybind11::return_value_policy::reference);

    m.def("get_current_plot",
        ImPlot::GetCurrentPlot,
        "Gets the current plot from the current ImPlotContext",
        pybind11::return_value_policy::reference);

    m.def("bust_plot_cache",
        ImPlot::BustPlotCache, "Busts the cache for every plot in the current context");

    m.def("show_plot_context_menu",
        ImPlot::ShowPlotContextMenu,
        py::arg("plot"),
        "Shows a plot's context menu.");

    m.def("setup_lock",
        ImPlot::SetupLock, " Lock Setup and call SetupFinish if necessary.\n(private API)");

    m.def("subplot_next_cell",
        ImPlot::SubplotNextCell, "Advances to next subplot");

    m.def("show_subplots_context_menu",
        ImPlot::ShowSubplotsContextMenu,
        py::arg("subplot"),
        "Shows a subplot's context menu.");

    m.def("begin_item",
        ImPlot::BeginItem,
        py::arg("label_id"), py::arg("flags") = 0, py::arg("recolor_from") = IMPLOT_AUTO,
        "Begins a new item. Returns False if the item should not be plotted. Pushes PlotClipRect.");

    m.def("end_item",
        ImPlot::EndItem, "Ends an item (call only if BeginItem returns True). Pops PlotClipRect.");

    m.def("register_or_get_item",
        [](const char * label_id, ImPlotItemFlags flags, std::optional<bool> just_created = std::nullopt) -> std::tuple<ImPlotItem *, std::optional<bool>>
        {
            auto RegisterOrGetItem_adapt_modifiable_immutable_to_return = [](const char * label_id, ImPlotItemFlags flags, std::optional<bool> just_created = std::nullopt) -> std::tuple<ImPlotItem *, std::optional<bool>>
            {
                bool * just_created_adapt_modifiable = nullptr;
                if (just_created.has_value())
                    just_created_adapt_modifiable = & (*just_created);

                ImPlotItem * r = ImPlot::RegisterOrGetItem(label_id, flags, just_created_adapt_modifiable);
                return std::make_tuple(r, just_created);
            };

            return RegisterOrGetItem_adapt_modifiable_immutable_to_return(label_id, flags, just_created);
        },
        py::arg("label_id"), py::arg("flags"), py::arg("just_created") = py::none(),
        "Register or get an existing item from the current plot.",
        pybind11::return_value_policy::reference);

    m.def("get_item",
        ImPlot::GetItem,
        py::arg("label_id"),
        "Get a plot item from the current plot.",
        pybind11::return_value_policy::reference);

    m.def("get_current_item",
        ImPlot::GetCurrentItem,
        "Gets the current item.",
        pybind11::return_value_policy::reference);

    m.def("bust_item_cache",
        ImPlot::BustItemCache, "Busts the cache for every item for every plot in the current context.");

    m.def("any_axes_input_locked",
        ImPlot::AnyAxesInputLocked,
        py::arg("axes"), py::arg("count"),
        " Returns True if any enabled axis is locked from user input.\n(private API)");

    m.def("all_axes_input_locked",
        ImPlot::AllAxesInputLocked,
        py::arg("axes"), py::arg("count"),
        " Returns True if all enabled axes are locked from user input.\n(private API)");

    m.def("any_axes_held",
        ImPlot::AnyAxesHeld,
        py::arg("axes"), py::arg("count"),
        "(private API)");

    m.def("any_axes_hovered",
        ImPlot::AnyAxesHovered,
        py::arg("axes"), py::arg("count"),
        "(private API)");

    m.def("fit_this_frame",
        ImPlot::FitThisFrame, " Returns True if the user has requested data to be fit.\n(private API)");

    m.def("fit_point_x",
        ImPlot::FitPointX,
        py::arg("x"),
        " Extends the current plot's axes so that it encompasses a vertical line at x\n(private API)");

    m.def("fit_point_y",
        ImPlot::FitPointY,
        py::arg("y"),
        " Extends the current plot's axes so that it encompasses a horizontal line at y\n(private API)");

    m.def("fit_point",
        ImPlot::FitPoint,
        py::arg("p"),
        " Extends the current plot's axes so that it encompasses point p\n(private API)");

    m.def("ranges_overlap",
        ImPlot::RangesOverlap,
        py::arg("r1"), py::arg("r2"),
        " Returns True if two ranges overlap\n(private API)");

    m.def("show_axis_context_menu",
        ImPlot::ShowAxisContextMenu,
        py::arg("axis"), py::arg("equal_axis"), py::arg("time_allowed") = false,
        "Shows an axis's context menu.");

    m.def("get_location_pos",
        ImPlot::GetLocationPos,
        py::arg("outer_rect"), py::arg("inner_size"), py::arg("location"), py::arg("pad") = ImVec2(0,0),
        "Gets the position of an inner rect that is located inside of an outer rect according to an ImPlotLocation and padding amount.");

    m.def("calc_legend_size",
        ImPlot::CalcLegendSize,
        py::arg("items"), py::arg("pad"), py::arg("spacing"), py::arg("vertical"),
        "Calculates the bounding box size of a legend _before_ clipping.");

    m.def("clamp_legend_rect",
        ImPlot::ClampLegendRect,
        py::arg("legend_rect"), py::arg("outer_rect"), py::arg("pad"),
        "Clips calculated legend size");

    m.def("show_legend_entries",
        ImPlot::ShowLegendEntries,
        py::arg("items"), py::arg("legend_bb"), py::arg("interactable"), py::arg("pad"), py::arg("spacing"), py::arg("vertical"), py::arg("draw_list"),
        "Renders legend entries into a bounding box");

    m.def("show_alt_legend",
        ImPlot::ShowAltLegend,
        py::arg("title_id"), py::arg("vertical") = true, py::arg("size") = ImVec2(0,0), py::arg("interactable") = true,
        "Shows an alternate legend for the plot identified by #title_id, outside of the plot frame (can be called before or after of Begin/EndPlot but must occur in the same ImGui window! This is not thoroughly tested nor scrollable!).");

    m.def("show_legend_context_menu",
        ImPlot::ShowLegendContextMenu,
        py::arg("legend"), py::arg("visible"),
        "Shows a legend's context menu.");

    m.def("get_item_data",
        ImPlot::GetItemData,
        " Get styling data for next item (call between Begin/EndItem)\n(private API)",
        pybind11::return_value_policy::reference);

    m.def("is_color_auto",
        py::overload_cast<const ImVec4 &>(ImPlot::IsColorAuto),
        py::arg("col"),
        " Returns True if a color is set to be automatically determined\n(private API)");

    m.def("is_color_auto",
        py::overload_cast<ImPlotCol>(ImPlot::IsColorAuto),
        py::arg("idx"),
        " Returns True if a style color is set to be automatically determined\n(private API)");

    m.def("get_auto_color",
        ImPlot::GetAutoColor,
        py::arg("idx"),
        "Returns the automatically deduced style color");

    m.def("get_style_color_vec4",
        ImPlot::GetStyleColorVec4,
        py::arg("idx"),
        "(private API)");

    m.def("get_style_color_u32",
        ImPlot::GetStyleColorU32,
        py::arg("idx"),
        "(private API)");

    m.def("add_text_vertical",
        ImPlot::AddTextVertical,
        py::arg("draw_list"), py::arg("pos"), py::arg("col"), py::arg("text_begin"), py::arg("text_end") = py::none(),
        "Draws vertical text. The position is the bottom left of the text rect.");

    m.def("add_text_centered",
        ImPlot::AddTextCentered,
        py::arg("draw_list"), py::arg("top_center"), py::arg("col"), py::arg("text_begin"), py::arg("text_end") = py::none(),
        "Draws multiline horizontal text centered.");

    m.def("calc_text_size_vertical",
        ImPlot::CalcTextSizeVertical,
        py::arg("text"),
        " Calculates the size of vertical text\n(private API)");

    m.def("calc_text_color",
        py::overload_cast<const ImVec4 &>(ImPlot::CalcTextColor),
        py::arg("bg"),
        "(private API)");

    m.def("calc_text_color",
        py::overload_cast<ImU32>(ImPlot::CalcTextColor),
        py::arg("bg"),
        "(private API)");

    m.def("calc_hover_color",
        ImPlot::CalcHoverColor,
        py::arg("col"),
        " Lightens or darkens a color for hover\n(private API)");

    m.def("clamp_label_pos",
        ImPlot::ClampLabelPos,
        py::arg("pos"), py::arg("size"), py::arg("min"), py::arg("max"),
        " Clamps a label position so that it fits a rect defined by Min/Max\n(private API)");

    m.def("get_colormap_color_u32",
        ImPlot::GetColormapColorU32,
        py::arg("idx"), py::arg("cmap"),
        "Returns a color from the Color map given an index >= 0 (modulo will be performed).");

    m.def("next_colormap_color_u32",
        ImPlot::NextColormapColorU32, "Returns the next unused colormap color and advances the colormap. Can be used to skip colors if desired.");

    m.def("sample_colormap_u32",
        ImPlot::SampleColormapU32,
        py::arg("t"), py::arg("cmap"),
        "Linearly interpolates a color from the current colormap given t between 0 and 1.");

    m.def("render_color_bar",
        ImPlot::RenderColorBar,
        py::arg("colors"), py::arg("size"), py::arg("draw_list"), py::arg("bounds"), py::arg("vert"), py::arg("reversed"), py::arg("continuous"),
        "Render a colormap bar");

    m.def("nice_num",
        ImPlot::NiceNum,
        py::arg("x"), py::arg("round"),
        "Rounds x to powers of 2,5 and 10 for generating axis labels (from Graphics Gems 1 Chapter 11.2)");

    m.def("order_of_magnitude",
        ImPlot::OrderOfMagnitude,
        py::arg("val"),
        " Computes order of magnitude of double.\n(private API)");

    m.def("order_to_precision",
        ImPlot::OrderToPrecision,
        py::arg("order"),
        " Returns the precision required for a order of magnitude.\n(private API)");

    m.def("precision",
        ImPlot::Precision,
        py::arg("val"),
        " Returns a floating point precision to use given a value\n(private API)");

    m.def("round_to",
        ImPlot::RoundTo,
        py::arg("val"), py::arg("prec"),
        " Round a value to a given precision\n(private API)");

    m.def("intersection",
        ImPlot::Intersection,
        py::arg("a1"), py::arg("a2"), py::arg("b1"), py::arg("b2"),
        " Returns the intersection point of two lines A and B (assumes they are not parallel!)\n(private API)");

    m.def("is_leap_year",
        ImPlot::IsLeapYear,
        py::arg("year"),
        " Returns True if year is leap year (366 days long)\n(private API)");

    m.def("get_days_in_month",
        ImPlot::GetDaysInMonth,
        py::arg("year"), py::arg("month"),
        " Returns the number of days in a month, accounting for Feb. leap years. #month is zero indexed.\n(private API)");

    m.def("make_time",
        ImPlot::MakeTime,
        py::arg("year"), py::arg("month") = 0, py::arg("day") = 1, py::arg("hour") = 0, py::arg("min") = 0, py::arg("sec") = 0, py::arg("us") = 0,
        " Make a timestamp from time components.\n year[1970-3000], month[0-11], day[1-31], hour[0-23], min[0-59], sec[0-59], us[0,999999]");

    m.def("get_year",
        ImPlot::GetYear,
        py::arg("t"),
        "Get year component from timestamp [1970-3000]");

    m.def("add_time",
        ImPlot::AddTime,
        py::arg("t"), py::arg("unit"), py::arg("count"),
        "Adds or subtracts time from a timestamp. #count > 0 to add, < 0 to subtract.");

    m.def("floor_time",
        ImPlot::FloorTime,
        py::arg("t"), py::arg("unit"),
        "Rounds a timestamp down to nearest unit.");

    m.def("ceil_time",
        ImPlot::CeilTime,
        py::arg("t"), py::arg("unit"),
        "Rounds a timestamp up to the nearest unit.");

    m.def("round_time",
        ImPlot::RoundTime,
        py::arg("t"), py::arg("unit"),
        "Rounds a timestamp up or down to the nearest unit.");

    m.def("combine_date_time",
        ImPlot::CombineDateTime,
        py::arg("date_part"), py::arg("time_part"),
        "Combines the date of one timestamp with the time-of-day of another timestamp.");

    m.def("show_date_picker",
        [](const char * id, int level, ImPlotTime * t, const ImPlotTime * t1 = nullptr, const ImPlotTime * t2 = nullptr) -> std::tuple<bool, int>
        {
            auto ShowDatePicker_adapt_modifiable_immutable_to_return = [](const char * id, int level, ImPlotTime * t, const ImPlotTime * t1 = nullptr, const ImPlotTime * t2 = nullptr) -> std::tuple<bool, int>
            {
                int * level_adapt_modifiable = & level;

                bool r = ImPlot::ShowDatePicker(id, level_adapt_modifiable, t, t1, t2);
                return std::make_tuple(r, level);
            };

            return ShowDatePicker_adapt_modifiable_immutable_to_return(id, level, t, t1, t2);
        },
        py::arg("id_"), py::arg("level"), py::arg("t"), py::arg("t1") = py::none(), py::arg("t2") = py::none(),
        " Shows a date picker widget block (year/month/day).\n #level = 0 for day, 1 for month, 2 for year. Modified by user interaction.\n #t will be set when a day is clicked and the function will return True.\n #t1 and #t2 are optional dates to highlight.");

    m.def("show_time_picker",
        ImPlot::ShowTimePicker,
        py::arg("id_"), py::arg("t"),
        " Shows a time picker widget block (hour/min/sec).\n #t will be set when a new hour, minute, or sec is selected or am/pm is toggled, and the function will return True.");

    m.def("transform_forward_log10",
        ImPlot::TransformForward_Log10,
        py::arg("v"), py::arg("param_1"),
        "(private API)");

    m.def("transform_inverse_log10",
        ImPlot::TransformInverse_Log10,
        py::arg("v"), py::arg("param_1"),
        "(private API)");

    m.def("transform_forward_sym_log",
        ImPlot::TransformForward_SymLog,
        py::arg("v"), py::arg("param_1"),
        "(private API)");

    m.def("transform_inverse_sym_log",
        ImPlot::TransformInverse_SymLog,
        py::arg("v"), py::arg("param_1"),
        "(private API)");

    m.def("transform_forward_logit",
        ImPlot::TransformForward_Logit,
        py::arg("v"), py::arg("param_1"),
        "(private API)");

    m.def("transform_inverse_logit",
        ImPlot::TransformInverse_Logit,
        py::arg("v"), py::arg("param_1"),
        "(private API)");


    auto pyClassFormatter_Time_Data =
        py::class_<ImPlot::Formatter_Time_Data>
            (m, "Formatter_Time_Data", "")
        .def(py::init<>([](
        ImPlotTime Time = ImPlotTime(), ImPlotDateTimeSpec Spec = ImPlotDateTimeSpec())
        {
            auto r = std::make_unique<Formatter_Time_Data>();
            r->Time = Time;
            r->Spec = Spec;
            return r;
        })
        , py::arg("time") = ImPlotTime(), py::arg("spec") = ImPlotDateTimeSpec()
        )
        .def_readwrite("time", &Formatter_Time_Data::Time, "")
        .def_readwrite("spec", &Formatter_Time_Data::Spec, "")
        .def_readwrite("user_formatter_data", &Formatter_Time_Data::UserFormatterData, "")
        ;
    ////////////////////    </generated_from:implot_internal.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
