   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*             CLIPS Version 6.30  10/19/06            */
   /*                                                     */
   /*                    AGENDA MODULE                    */
   /*******************************************************/

/*************************************************************/
/* Purpose:                                                  */
/*   Provides functionality for examining, manipulating,     */
/*   adding, and removing activations from the agenda.       */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Gary D. Riley                                        */
/*                                                           */
/* Contributing Programmer(s):                               */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Revision History:                                         */
/*      6.23: Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*      6.24: Removed CONFLICT_RESOLUTION_STRATEGIES         */
/*            and DYNAMIC_SALIENCE compilation flags.        */
/*                                                           */
/*            Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*            Added EnvGetActivationBasisPPForm function.    */
/*                                                           */
/*      6.30: Added salience groups to improve performance   */
/*            with large numbers of activations of different */
/*            saliences.                                     */
/*                                                           */
/*************************************************************/

#define _AGENDA_SOURCE_

#include <stdio.h>
#define _STDIO_INCLUDED_
#include <string.h>

#include "setup.h"

#if DEFRULE_CONSTRUCT

#include "argacces.h"
#include "constant.h"
#include "crstrtgy.h"
#include "engine.h"
#include "envrnmnt.h"
#include "extnfunc.h"
#include "memalloc.h"
#include "moduldef.h"
#include "modulutl.h"
#include "multifld.h"
#include "reteutil.h"
#include "retract.h"
#include "router.h"
#include "rulebsc.h"
#include "ruledef.h"
#include "strngrtr.h"
#include "sysdep.h"
#include "watch.h"

#include "agenda.h"

/***************************************/
/* LOCAL INTERNAL FUNCTION DEFINITIONS */
/***************************************/

   static void                    PrintActivation(void *,EXEC_STATUS,char *,void *);
   static void                    AgendaClearFunction(void *,EXEC_STATUS);
   static char                   *SalienceEvaluationName(int);
   static int                     EvaluateSalience(void *,EXEC_STATUS,void *);
   static struct salienceGroup   *ReuseOrCreateSalienceGroup(void *,EXEC_STATUS,struct defruleModule *,int);
   static struct salienceGroup   *FindSalienceGroup(struct defruleModule *,int);
   static void                    RemoveActivationFromGroup(void *,EXEC_STATUS,struct activation *,struct defruleModule *);
   
/*************************************************/
/* InitializeAgenda: Initializes the activations */
/*   watch item and the H/L commands for         */
/*   manipulating the agenda.                    */
/*************************************************/
globle void InitializeAgenda(
  void *theEnv,
  EXEC_STATUS)
  {   
   AllocateEnvironmentData(theEnv,execStatus,AGENDA_DATA,sizeof(struct agendaData),NULL);
   
   AgendaData(theEnv,execStatus)->SalienceEvaluation = WHEN_DEFINED;

   AgendaData(theEnv,execStatus)->Strategy = DEFAULT_STRATEGY;
   
   EnvAddClearFunction(theEnv,execStatus,"agenda",AgendaClearFunction,0);
#if DEBUGGING_FUNCTIONS
   AddWatchItem(theEnv,execStatus,"activations",1,&AgendaData(theEnv,execStatus)->WatchActivations,40,DefruleWatchAccess,DefruleWatchPrint);
#endif
#if ! RUN_TIME
   EnvDefineFunction2(theEnv,execStatus,"refresh", 'v', PTIEF RefreshCommand, "RefreshCommand", "11w");

   EnvDefineFunction2(theEnv,execStatus,"refresh-agenda",'v',
                   PTIEF RefreshAgendaCommand,"RefreshAgendaCommand", "01w");
   EnvDefineFunction2(theEnv,execStatus,"get-salience-evaluation",'w',
                   PTIEF GetSalienceEvaluationCommand,
                   "GetSalienceEvaluationCommand", "00");
   EnvDefineFunction2(theEnv,execStatus,"set-salience-evaluation",'w',
                   PTIEF SetSalienceEvaluationCommand,
                   "SetSalienceEvaluationCommand",
                   "11w");

#if DEBUGGING_FUNCTIONS
   EnvDefineFunction2(theEnv,execStatus,"agenda", 'v', PTIEF AgendaCommand, "AgendaCommand", "01w");
#endif
#endif
  }

/*****************************************************************/
/* AddActivation: Creates a rule activation to be added to the   */
/*   Agenda and links the activation with its associated partial */
/*   match. The function PlaceActivation is then called to place */
/*   the activation on the Agenda. Typically called when all     */
/*   patterns on the LHS of a rule have been satisfied.          */
/*****************************************************************/
globle void AddActivation(
  void *theEnv,
  EXEC_STATUS,
  void *vTheRule,
  void *vBinds)
  {
   struct activation *newActivation;
   struct defrule *theRule = (struct defrule *) vTheRule;
   struct partialMatch *binds = (struct partialMatch *) vBinds;
   struct defruleModule *theModuleItem;
   struct salienceGroup *theGroup;

   /*=======================================*/
   /* Focus on the module if the activation */
   /* is from an auto-focus rule.           */
   /*=======================================*/

   if (theRule->autoFocus)
     { EnvFocus(theEnv,execStatus,(void *) theRule->header.whichModule->theModule); }

   /*=======================================================*/
   /* Create the activation. The activation stores pointers */
   /* to its associated partial match and defrule. The      */
   /* activation is given a time tag, its salience is       */
   /* evaluated, and it is assigned a random number for use */
   /* with the random conflict resolution strategy.         */
   /*=======================================================*/

   newActivation = get_struct(theEnv,execStatus,activation);
   newActivation->theRule = theRule;
   newActivation->basis = binds;
   newActivation->timetag = AgendaData(theEnv,execStatus)->CurrentTimetag++;
   newActivation->salience = EvaluateSalience(theEnv,execStatus,theRule);

   newActivation->randomID = genrand();
   newActivation->prev = NULL;
   newActivation->next = NULL;

   AgendaData(theEnv,execStatus)->NumberOfActivations++;

   /*=======================================================*/
   /* Point the partial match to the activation to complete */
   /* the link between the join network and the agenda.     */
   /*=======================================================*/

   binds->marker = (void *) newActivation;

   /*====================================================*/
   /* If activations are being watch, display a message. */
   /*====================================================*/

#if DEBUGGING_FUNCTIONS
   if (newActivation->theRule->watchActivation)
     {
      EnvPrintRouter(theEnv,execStatus,WTRACE,"==> Activation ");
      PrintActivation(theEnv,execStatus,WTRACE,(void *) newActivation);
      EnvPrintRouter(theEnv,execStatus,WTRACE,"\n");
     }
#endif

    /*=====================================*/
    /* Place the activation on the agenda. */
    /*=====================================*/

    theModuleItem = (struct defruleModule *) theRule->header.whichModule;
    
    theGroup = ReuseOrCreateSalienceGroup(theEnv,execStatus,theModuleItem,newActivation->salience);
    
    PlaceActivation(theEnv,execStatus,&(theModuleItem->agenda),newActivation,theGroup);
   }

/***************************************************************/
/* ReuseOrCreateSalienceGroup: */
/***************************************************************/
static struct salienceGroup *ReuseOrCreateSalienceGroup(
  void *theEnv,
  EXEC_STATUS,
  struct defruleModule *theRuleModule,
  int salience)
  {
   struct salienceGroup *theGroup, *lastGroup, *newGroup;
   
   for (lastGroup = NULL, theGroup = theRuleModule->groupings;
        theGroup != NULL;
        lastGroup = theGroup, theGroup = theGroup->next)
     {
      if (theGroup->salience == salience)
        { return(theGroup); }
        
      if (theGroup->salience < salience)
        { break; }
     }
     
   newGroup = get_struct(theEnv,execStatus,salienceGroup);
   newGroup->salience = salience;
   newGroup->first = NULL;
   newGroup->last = NULL;
   newGroup->next = theGroup;
   newGroup->prev = lastGroup;
   
   if (newGroup->next != NULL)
     { newGroup->next->prev = newGroup; }

   if (newGroup->prev != NULL)
     { newGroup->prev->next = newGroup; }
   
   if (lastGroup == NULL)
     { theRuleModule->groupings = newGroup; }
     
   return newGroup;
  }

/***************************************************************/
/* FindSalienceGroup: */
/***************************************************************/
static struct salienceGroup *FindSalienceGroup(
  struct defruleModule *theRuleModule,
  int salience)
  {
   struct salienceGroup *theGroup;
   
   for (theGroup = theRuleModule->groupings;
        theGroup != NULL;
        theGroup = theGroup->next)
     {
      if (theGroup->salience == salience)
        { return(theGroup); }
        
      if (theGroup->salience < salience)
        { break; }
     }
     
   return NULL;
  }
  
/***************************************************************/
/* ClearRuleFromAgenda: Clears the agenda of a specified rule. */
/***************************************************************/
globle void ClearRuleFromAgenda(
  void *theEnv,
  EXEC_STATUS,
  void *vTheRule)
  {
   struct defrule *theRule = (struct defrule *) vTheRule;
   struct defrule *tempRule;
   struct activation *agendaPtr, *agendaNext;

   /*============================================*/
   /* Get a pointer to the agenda for the module */
   /* in which the rule is contained.            */
   /*============================================*/

   agendaPtr = ((struct defruleModule *) theRule->header.whichModule)->agenda;

   /*==============================================*/
   /* Loop through every activation on the agenda. */
   /*==============================================*/

   while (agendaPtr != NULL)
     {
      agendaNext = agendaPtr->next;

      /*========================================================*/
      /* Check each disjunct of the rule against the activation */
      /* to determine if the activation points to the rule. If  */
      /* it does, then remove the activation from the agenda.   */
      /*========================================================*/

      for (tempRule = theRule;
           tempRule != NULL;
           tempRule = tempRule->disjunct)
        {
         if (agendaPtr->theRule == tempRule)
           {
            RemoveActivation(theEnv,execStatus,agendaPtr,TRUE,TRUE);
            break;
           }
        }

      agendaPtr = agendaNext;
     }
  }

/****************************************************************/
/* EnvGetNextActivation: Returns an activation from the Agenda. */
/*   If its argument is NULL, then the first activation on the  */
/*   Agenda is returned. If its argument is not NULL, the next  */
/*   activation after the argument is returned.                 */
/****************************************************************/
globle void *EnvGetNextActivation(
  void *theEnv,
  EXEC_STATUS,
  void *actPtr)
  {
   struct defruleModule *theModuleItem;
   
   if (actPtr == NULL)
     {
      theModuleItem = (struct defruleModule *) GetModuleItem(theEnv,execStatus,NULL,DefruleData(theEnv,execStatus)->DefruleModuleIndex);
      if (theModuleItem == NULL) return(NULL);
      return((void *) theModuleItem->agenda);
     }
   else
     { return((void *) (((struct activation *) actPtr)->next)); }
  }

/*********************************************/
/* EnvGetActivationName: Returns the name of */
/*   the rule associated with an activation. */
/*********************************************/
#if WIN_BTC
#pragma argsused
#endif
globle char *EnvGetActivationName(
  void *theEnv,
  EXEC_STATUS,
  void *actPtr)
  {
#if MAC_MCW || WIN_MCW || MAC_XCD
#pragma unused(theEnv,execStatus)
#endif

   return(ValueToString(((struct activation *) actPtr)->theRule->header.name)); 
  }

/**************************************/
/* EnvSetActivationSalience: Sets the */
/*   salience value of an activation. */
/**************************************/
#if WIN_BTC
#pragma argsused
#endif
globle int EnvSetActivationSalience(
  void *theEnv,
  EXEC_STATUS,
  void *actPtr,
  int value)
  {
   int temp;
#if MAC_MCW || WIN_MCW || MAC_XCD
#pragma unused(theEnv,execStatus)
#endif

   temp = ((struct activation *) actPtr)->salience;
   ((struct activation *) actPtr)->salience = value;
   return(temp);
  }

/**********************************************/
/* EnvGetActivationPPForm: Returns the pretty */
/*   print representation of an activation.   */
/**********************************************/
globle void EnvGetActivationPPForm(
  void *theEnv,
  EXEC_STATUS,
  char *buffer,
  unsigned bufferLength,
  void *theActivation)
  {
   OpenStringDestination(theEnv,execStatus,"ActPPForm",buffer,bufferLength);
   PrintActivation(theEnv,execStatus,"ActPPForm",(void *) theActivation);
   CloseStringDestination(theEnv,execStatus,"ActPPForm");
  }

/****************************************************/
/* EnvGetActivationBasisPPForm: Returns the pretty  */
/*   print representation of an activation's basis. */
/****************************************************/
globle void EnvGetActivationBasisPPForm(
  void *theEnv,
  EXEC_STATUS,
  char *buffer,
  unsigned bufferLength,
  void *vTheActivation)
  {
   struct activation *theActivation = (struct activation *) vTheActivation;

   OpenStringDestination(theEnv,execStatus,"ActPPForm",buffer,bufferLength);
   PrintPartialMatch(theEnv,execStatus,"ActPPForm",theActivation->basis);
   CloseStringDestination(theEnv,execStatus,"ActPPForm");
  }

/********************************************/
/* MoveActivationToTop: Moves the specified */
/*   activation to the top of the agenda.   */
/********************************************/
globle intBool MoveActivationToTop(
  void *theEnv,
  EXEC_STATUS,
  void *vtheActivation)
  {
   struct activation *prevPtr;
   struct activation *theActivation = (struct activation *) vtheActivation;
   struct defruleModule *theModuleItem;

   /*====================================*/
   /* Determine the module of the agenda */
   /* in which the activation is stored. */
   /*====================================*/

   theModuleItem = (struct defruleModule *) theActivation->theRule->header.whichModule;

   /*============================================*/
   /* If the activation is already at the top of */
   /* the agenda, then nothing needs to be done. */
   /*============================================*/

   if (theActivation == theModuleItem->agenda) return(FALSE);

   /*=================================================*/
   /* Update the pointers of the activation preceding */
   /* and following the activation being moved.       */
   /*=================================================*/

   prevPtr = theActivation->prev;
   prevPtr->next = theActivation->next;
   if (theActivation->next != NULL) theActivation->next->prev = prevPtr;

   /*=======================================================*/
   /* Move the activation and then update its pointers, the */
   /* pointers of the activation following it, and the      */
   /* module pointer to the top activation on the agenda.   */
   /*=======================================================*/

   theActivation->next = theModuleItem->agenda;
   theModuleItem->agenda->prev = theActivation;
   theActivation->prev = NULL;
   theModuleItem->agenda = theActivation;

   /*=============================*/
   /* Mark the agenda as changed. */
   /*=============================*/

   AgendaData(theEnv,execStatus)->AgendaChanged = TRUE;

   return(TRUE);
  }

/**********************************************/
/* EnvDeleteActivation: Removes the specified */
/*   activation from the agenda.              */
/**********************************************/
globle intBool EnvDeleteActivation(
  void *theEnv,
  EXEC_STATUS,
  void *theActivation)
  {
   if (theActivation == NULL) RemoveAllActivations(theEnv,execStatus);
   else RemoveActivation(theEnv,execStatus,(struct activation *) theActivation,TRUE,TRUE);

   return(TRUE);
  }

/*******************************************************/
/* DetachActivation: Detaches the specified activation */
/*   from the list of activations on the Agenda.       */
/*******************************************************/
globle intBool DetachActivation(
  void *theEnv,
  EXEC_STATUS,
  void *vTheActivation)
  {
   struct defruleModule *theModuleItem;
   struct activation *theActivation = (struct activation *) vTheActivation;

   /*============================*/
   /* A NULL pointer is invalid. */
   /*============================*/

   if (theActivation == NULL) SystemError(theEnv,execStatus,"AGENDA",1);

   /*====================================*/
   /* Determine the module of the agenda */
   /* in which the activation is stored. */
   /*====================================*/

   theModuleItem = (struct defruleModule *) theActivation->theRule->header.whichModule;

   RemoveActivationFromGroup(theEnv,execStatus,theActivation,theModuleItem);

   /*========================================================*/
   /* If the activation is the top activation on the agenda, */
   /* then update the module pointer to agenda.              */
   /*========================================================*/

   if (theActivation == theModuleItem->agenda)
     { theModuleItem->agenda = theActivation->next; }

   /*==================================================*/
   /* Update the pointers in the preceding activation. */
   /*==================================================*/

   if (theActivation->prev != NULL)
     { theActivation->prev->next = theActivation->next; }

   /*==================================================*/
   /* Update the pointers in the following activation. */
   /*==================================================*/

   if (theActivation->next != NULL)
     { theActivation->next->prev = theActivation->prev; }

   /*=================================================*/
   /* Update the pointers in the detached activation. */
   /*=================================================*/

   theActivation->prev = NULL;
   theActivation->next = NULL;

   /*=============================*/
   /* Mark the agenda as changed. */
   /*=============================*/

   AgendaData(theEnv,execStatus)->AgendaChanged = TRUE;

   return(TRUE);
  }

/****************************************************************************/
/* PrintActivation: Prints an activation in a "pretty" format. Salience,    */
/*   rule name, and the partial match which activated the rule are printed. */
/****************************************************************************/
static void PrintActivation(
  void *theEnv,
  EXEC_STATUS,
  char *logicalName,
  void *vTheActivation)
  {
   struct activation *theActivation = (struct activation *) vTheActivation;
   char printSpace[20];

   gensprintf(printSpace,"%-6d ",theActivation->salience);
   EnvPrintRouter(theEnv,execStatus,logicalName,printSpace);
   EnvPrintRouter(theEnv,execStatus,logicalName,ValueToString(theActivation->theRule->header.name));
   EnvPrintRouter(theEnv,execStatus,logicalName,": ");
   PrintPartialMatch(theEnv,execStatus,logicalName,theActivation->basis);
  }

/*******************************/
/* EnvAgenda: C access routine */
/*   for the agenda command.   */
/*******************************/
globle void EnvAgenda(
  void *theEnv,
  EXEC_STATUS,
  char *logicalName,
  void *vTheModule)
  {
   struct defmodule *theModule = (struct defmodule *) vTheModule;

   ListItemsDriver(theEnv,execStatus,logicalName,theModule,"activation","activations",
                   EnvGetNextActivation,NULL,PrintActivation,NULL);
  }

/*******************************************************************/
/* RemoveActivation: Returns an activation and its associated data */
/*   structures to the Memory Manager. Links to other activations  */
/*   and partial matches may also be updated.                      */
/*******************************************************************/
globle void RemoveActivation(
  void *theEnv,
  EXEC_STATUS,
  void *vTheActivation,
  int updateAgenda,
  int updateLinks)
  {
   struct defruleModule *theModuleItem;
   struct activation *theActivation = (struct activation *) vTheActivation;

   /*====================================*/
   /* Determine the module of the agenda */
   /* in which the activation is stored. */
   /*====================================*/

   theModuleItem = (struct defruleModule *) theActivation->theRule->header.whichModule;

   /*=================================*/
   /* Update the agenda if necessary. */
   /*=================================*/

   if (updateAgenda == TRUE)
     {
      RemoveActivationFromGroup(theEnv,execStatus,theActivation,theModuleItem);

      /*===============================================*/
      /* Update the pointer links between activations. */
      /*===============================================*/

      if (theActivation->prev == NULL)
        {
         theModuleItem->agenda = theModuleItem->agenda->next;
         if (theModuleItem->agenda != NULL) theModuleItem->agenda->prev = NULL;
        }
      else
        {
         theActivation->prev->next = theActivation->next;
         if (theActivation->next != NULL)
           { theActivation->next->prev = theActivation->prev; }
        }

      /*===================================*/
      /* Indicate removal of activation if */
      /* activations are being watched.    */
      /*===================================*/

#if DEBUGGING_FUNCTIONS
      if (theActivation->theRule->watchActivation)
        {
         EnvPrintRouter(theEnv,execStatus,WTRACE,"<== Activation ");
         PrintActivation(theEnv,execStatus,WTRACE,(void *) theActivation);
         EnvPrintRouter(theEnv,execStatus,WTRACE,"\n");
        }
#endif

      /*=============================*/
      /* Mark the agenda as changed. */
      /*=============================*/

      AgendaData(theEnv,execStatus)->AgendaChanged = TRUE;
     }

   /*============================================*/
   /* Update join and agenda links if necessary. */
   /*============================================*/

   if ((updateLinks == TRUE) && (theActivation->basis != NULL))
     { theActivation->basis->marker = NULL; }

   /*================================================*/
   /* Return the activation to the free memory pool. */
   /*================================================*/

   AgendaData(theEnv,execStatus)->NumberOfActivations--;

   rtn_struct(theEnv,execStatus,activation,theActivation);
  }

/**************************************************************/
/* RemoveActivationFromGroup:      */
/**************************************************************/
static void RemoveActivationFromGroup(
  void *theEnv,
  EXEC_STATUS,
  struct activation *theActivation,
  struct defruleModule *theRuleModule)
  {
   struct salienceGroup *theGroup;
   
   theGroup = FindSalienceGroup(theRuleModule,theActivation->salience);
   if (theGroup == NULL) return;
   
   if (theActivation == theGroup->first)
     {
      /*====================================================*/
      /* If the activation is the only remaining activation */
      /* in the group, then the group needs to be removed.  */
      /*====================================================*/
      
      if (theActivation == theGroup->last)
        {
         if (theGroup->prev == NULL)
           { theRuleModule->groupings = theGroup->next; }
         else
           { theGroup->prev->next = theGroup->next; }
           
         if (theGroup->next != NULL)
           { theGroup->next->prev = theGroup->prev; }
           
         rtn_struct(theEnv,execStatus,salienceGroup,theGroup);
        }
        
      /*======================================================*/
      /* Otherwise this is the first activation in the group, */
      /* but there are other activations which follow.        */
      /*======================================================*/
      
      else
        { theGroup->first = theActivation->next; }
     }
   else
     {
      /*====================================================*/
      /* Otherwise if the activation isn't the first in the */
      /* group, then check to see if it's the last.         */
      /*====================================================*/
      
      if (theActivation == theGroup->last)
        { theGroup->last = theActivation->prev; }
        
      /*==================================================*/
      /* Otherwise the activation is in the middle of the */
      /* group and no first/last updates are needed.      */
      /*==================================================*/
      
      else
        { return; }
     }
  }

/**************************************************************/
/* AgendaClearFunction: Agenda clear routine for use with the */
/*   clear command. Resets the current time tag to zero.      */
/**************************************************************/
static void AgendaClearFunction(
  void *theEnv,
  EXEC_STATUS)
  {
   AgendaData(theEnv,execStatus)->CurrentTimetag = 0;
  }

/*************************************************/
/* RemoveAllActivations: Removes all activations */
/*   from the agenda of the current module.      */
/*************************************************/
globle void RemoveAllActivations(
  void *theEnv,
  EXEC_STATUS)
  {
   struct activation *tempPtr, *theActivation;
   struct salienceGroup *theGroup, *tempGroup;

   theActivation = GetDefruleModuleItem(theEnv,execStatus,NULL)->agenda;
   while (theActivation != NULL)
     {
      tempPtr = theActivation->next;
      RemoveActivation(theEnv,execStatus,theActivation,TRUE,TRUE);
      theActivation = tempPtr;
     }

   theGroup = GetDefruleModuleItem(theEnv,execStatus,NULL)->groupings;
   while (theGroup != NULL)
     {
      tempGroup = theGroup->next;
      rtn_struct(theEnv,execStatus,salienceGroup,theGroup);
      theGroup = tempGroup;
     }
 }

/*********************************************************/
/* EnvGetAgendaChanged: Returns the value of the boolean */
/*   flag which indicates whether any changes have been  */
/*   made to the agenda.                                 */
/*********************************************************/
globle int EnvGetAgendaChanged(
  void *theEnv,
  EXEC_STATUS)
  {
   return(AgendaData(theEnv,execStatus)->AgendaChanged);
  }

/*****************************************************************/
/* EnvSetAgendaChanged: Sets the value of the boolean flag which */
/*   indicates whether any changes have been made to the agenda. */
/*****************************************************************/
globle void EnvSetAgendaChanged(
  void *theEnv,
  EXEC_STATUS,
  int value)
  {
   AgendaData(theEnv,execStatus)->AgendaChanged = value;
  }

/**********************************************************/
/* EnvReorderAgenda: Completely reorders the agenda based */
/*   on the current conflict resolution strategy.         */
/**********************************************************/
globle void EnvReorderAgenda(
  void *theEnv,
  EXEC_STATUS,
  void *vTheModule)
  {
   struct activation *theActivation, *tempPtr;
   struct defmodule *theModule = (struct defmodule *) vTheModule;
   int allModules = FALSE;
   struct defruleModule *theModuleItem;
   struct salienceGroup *theGroup, *tempGroup;

   /*=============================================*/
   /* If the module specified is a NULL pointer,  */
   /* then every module has its agenda reordered. */
   /*=============================================*/

   if (theModule == NULL)
     {
      allModules = TRUE;
      theModule = (struct defmodule *) EnvGetNextDefmodule(theEnv,execStatus,NULL);
     }

   /*========================*/
   /* Reorder the agenda(s). */
   /*========================*/

   for (;
        theModule != NULL;
        theModule = (struct defmodule *) EnvGetNextDefmodule(theEnv,execStatus,theModule))
     {
      /*=================================*/
      /* Get the list of activations and */
      /* remove them from the agenda.    */
      /*=================================*/

      theModuleItem = GetDefruleModuleItem(theEnv,execStatus,theModule);
      theActivation = theModuleItem->agenda;
      theModuleItem->agenda = NULL;

      theGroup = theModuleItem->groupings;
      while (theGroup != NULL)
        {
         tempGroup = theGroup->next;
         rtn_struct(theEnv,execStatus,salienceGroup,theGroup);
         theGroup = tempGroup;
        }

      theModuleItem->groupings = NULL;
        
      /*=========================================*/
      /* Reorder the activations by placing them */
      /* back on the agenda one by one.          */
      /*=========================================*/

      while (theActivation != NULL)
        {
         tempPtr = theActivation->next;
         theActivation->next = NULL;
         theActivation->prev = NULL;
         theGroup = ReuseOrCreateSalienceGroup(theEnv,execStatus,theModuleItem,theActivation->salience);
         PlaceActivation(theEnv,execStatus,&(theModuleItem->agenda),theActivation,theGroup);
         theActivation = tempPtr;
        }

      /*===============================================*/
      /* Return if only one agenda is being reordered. */
      /*===============================================*/

      if (! allModules) return;
     }
  }

/****************************************************/
/* GetNumberOfActivations: Returns the value of the */
/*   total number of activations on all agendas.    */
/****************************************************/
globle unsigned long GetNumberOfActivations(
  void *theEnv,
  EXEC_STATUS)
  {  
   return(AgendaData(theEnv,execStatus)->NumberOfActivations); 
  }

/******************************************************/
/* RefreshCommand: H/L Command for refreshing a rule. */
/*   Syntax: (refresh <defrule-name>)                 */
/******************************************************/
globle void RefreshCommand(
  void *theEnv,
  EXEC_STATUS)
  {
   char *ruleName;
   void *rulePtr;

   /*===========================*/
   /* Get the name of the rule. */
   /*===========================*/

   ruleName = GetConstructName(theEnv,execStatus,"refresh","rule name");
   if (ruleName == NULL) return;

   /*===============================*/
   /* Determine if the rule exists. */
   /*===============================*/

   rulePtr = EnvFindDefrule(theEnv,execStatus,ruleName);
   if (rulePtr == NULL)
     {
      CantFindItemErrorMessage(theEnv,execStatus,"defrule",ruleName);
      return;
     }

   /*===================*/
   /* Refresh the rule. */
   /*===================*/

   EnvRefresh(theEnv,execStatus,rulePtr);
  }

/************************************************************/
/* EnvRefresh: Refreshes a defrule. Activations of the rule */
/*   that have already been fired are added to the agenda.  */
/************************************************************/
globle intBool EnvRefresh(
  void *theEnv,
  EXEC_STATUS,
  void *theRule)
  {
   struct defrule *rulePtr;
   struct partialMatch *listOfMatches;
   unsigned long b;
   
   /*====================================*/
   /* Refresh each disjunct of the rule. */
   /*====================================*/

   for (rulePtr = (struct defrule *) theRule;
        rulePtr != NULL;
        rulePtr = rulePtr->disjunct)
     {
      /*================================*/
      /* Check each partial match that  */
      /* satisfies the LHS of the rule. */
      /*================================*/

      for (b = 0; b < rulePtr->lastJoin->leftMemory->size; b++)
        {
         for (listOfMatches = rulePtr->lastJoin->leftMemory->beta[b];
              listOfMatches != NULL;
              listOfMatches = listOfMatches->nextInMemory)
           {
            /*=======================================================*/
            /* If the partial match is associated with an activation */
            /* (which it should always be), then place a new         */
            /* activation on the agenda if this partial matchdoesn't */
            /* have an activation associated with it.                */
            /*=======================================================*/

            if (((struct joinNode *) listOfMatches->owner)->ruleToActivate != NULL)
              {
               if (listOfMatches->marker == NULL)
                 { AddActivation(theEnv,execStatus,rulePtr,listOfMatches); }
              }
           }
        }
     }

   return(TRUE);
  }

/**********************************************/
/* RefreshAgendaCommand: H/L access routine   */
/*   for the refresh-agenda command.          */
/**********************************************/
globle void RefreshAgendaCommand(
  void *theEnv,
	EXEC_STATUS)
  {
   int numArgs, error;
   struct defmodule *theModule;

   /*==============================================*/
   /* This function can have at most one argument. */
   /*==============================================*/

   if ((numArgs = EnvArgCountCheck(theEnv,execStatus,"refresh-agenda",NO_MORE_THAN,1)) == -1) return;

   /*===============================================================*/
   /* If a module name is specified, then the agenda of that module */
   /* is refreshed. Otherwise, the agenda of the current module is  */
   /* refreshed.                                                    */
   /*===============================================================*/

   if (numArgs == 1)
     {
      theModule = GetModuleName(theEnv,execStatus,"refresh-agenda",1,&error);
      if (error) return;
     }
   else
     { theModule = ((struct defmodule *) EnvGetCurrentModule(theEnv,execStatus)); }

   /*===============================================*/
   /* Refresh the agenda of the appropriate module. */
   /*===============================================*/

   EnvRefreshAgenda(theEnv,execStatus,theModule);
  }

/**************************************/
/* EnvRefreshAgenda: C access routine */
/*   for the refresh-agenda command.  */
/**************************************/
globle void EnvRefreshAgenda(
  void *theEnv,
  EXEC_STATUS,
  void *vTheModule)
  {
   struct activation *theActivation;
   struct defmodule *theModule = (struct defmodule *) vTheModule;
   intBool oldValue;
   int allModules = FALSE;
   
   /*==========================*/
   /* Save the current module. */
   /*==========================*/

   SaveCurrentModule(theEnv,execStatus);

   /*=============================================*/
   /* If the module specified is a NULL pointer,  */
   /* then every module has its agenda refreshed. */
   /*=============================================*/

   if (theModule == NULL)
     {
      allModules = TRUE;
      theModule = (struct defmodule *) EnvGetNextDefmodule(theEnv,execStatus,NULL);
     }

   /*=======================================================*/
   /* Remember the current setting for salience evaluation. */
   /* To perform the refresh, the when activated setting is */
   /* used to recompute the salience values.                */
   /*=======================================================*/

   oldValue = EnvGetSalienceEvaluation(theEnv,execStatus);
   EnvSetSalienceEvaluation(theEnv,execStatus,WHEN_ACTIVATED);

   /*========================*/
   /* Refresh the agenda(s). */
   /*========================*/

   for (;
        theModule != NULL;
        theModule = (struct defmodule *) EnvGetNextDefmodule(theEnv,execStatus,theModule))
     {
      /*=========================================*/
      /* Change the current module to the module */
      /* of the agenda being refreshed.          */
      /*=========================================*/

      EnvSetCurrentModule(theEnv,execStatus,(void *) theModule);

      /*================================================================*/
      /* Recompute the salience values for the current module's agenda. */
      /*================================================================*/

      for (theActivation = (struct activation *) EnvGetNextActivation(theEnv,execStatus,NULL);
           theActivation != NULL;
           theActivation = (struct activation *) EnvGetNextActivation(theEnv,execStatus,theActivation))
        { theActivation->salience = EvaluateSalience(theEnv,execStatus,theActivation->theRule); }

      /*======================================================*/
      /* Reorder the agenda based on the new salience values. */
      /*======================================================*/

      EnvReorderAgenda(theEnv,execStatus,theModule);

      /*===============================================*/
      /* Return if only one agenda is being refreshed. */
      /*===============================================*/

      if (! allModules)
        {
         EnvSetSalienceEvaluation(theEnv,execStatus,oldValue);
         RestoreCurrentModule(theEnv,execStatus);
         return;
        }
     }

   /*==========================================*/
   /* Restore the salience evaluation setting. */
   /*==========================================*/

   EnvSetSalienceEvaluation(theEnv,execStatus,oldValue);

   /*=============================*/
   /* Restore the current module. */
   /*=============================*/

   RestoreCurrentModule(theEnv,execStatus);
  }

/*********************************************************/
/* SetSalienceEvaluationCommand: H/L Command for setting */
/*   the salience evaluation behavior.                   */
/*   Syntax: (set-salience-evaluation-behavior <symbol>) */
/*********************************************************/
globle void *SetSalienceEvaluationCommand(
  void *theEnv,
	EXEC_STATUS)
  {
   DATA_OBJECT argPtr;
   char *argument, *oldValue;

   /*==================================================*/
   /* Get the current setting for salience evaluation. */
   /*==================================================*/

   oldValue = SalienceEvaluationName(EnvGetSalienceEvaluation(theEnv,execStatus));

   /*=========================================*/
   /* This function expects a single argument */
   /* which must be a symbol.                 */
   /*=========================================*/

   if (EnvArgCountCheck(theEnv,execStatus,"set-salience-evaluation",EXACTLY,1) == -1)
     { return((SYMBOL_HN *) EnvAddSymbol(theEnv,execStatus,oldValue)); }

   if (EnvArgTypeCheck(theEnv,execStatus,"set-salience-evaluation",1,SYMBOL,&argPtr) == FALSE)
     { return((SYMBOL_HN *) EnvAddSymbol(theEnv,execStatus,oldValue)); }

   /*=============================================================*/
   /* The allowed symbols to pass as an argument to this function */
   /* are when-defined, when-activated, and every-cycle.          */
   /*=============================================================*/

   argument = DOToString(argPtr);

   if (strcmp(argument,"when-defined") == 0)
     { EnvSetSalienceEvaluation(theEnv,execStatus,WHEN_DEFINED); }
   else if (strcmp(argument,"when-activated") == 0)
     { EnvSetSalienceEvaluation(theEnv,execStatus,WHEN_ACTIVATED); }
   else if (strcmp(argument,"every-cycle") == 0)
     { EnvSetSalienceEvaluation(theEnv,execStatus,EVERY_CYCLE); }
   else
     {
      ExpectedTypeError1(theEnv,execStatus,"set-salience-evaluation",1,
      "symbol with value when-defined, when-activated, or every-cycle");
      return((SYMBOL_HN *) EnvAddSymbol(theEnv,execStatus,oldValue));
     }

   /*=================================================*/
   /* Return the old setting for salience evaluation. */
   /*=================================================*/

   return((SYMBOL_HN *) EnvAddSymbol(theEnv,execStatus,oldValue));
  }

/*********************************************************/
/* GetSalienceEvaluationCommand: H/L Command for getting */
/*   the salience evaluation behavior.                   */
/*   Syntax: (get-salience-evaluation-behavior)          */
/*********************************************************/
globle void *GetSalienceEvaluationCommand(
  void *theEnv,
  EXEC_STATUS)
  {
   EnvArgCountCheck(theEnv,execStatus,"get-salience-evaluation",EXACTLY,0);

   return((SYMBOL_HN *) EnvAddSymbol(theEnv,execStatus,SalienceEvaluationName(EnvGetSalienceEvaluation(theEnv,execStatus))));
  }

/*****************************************************************/
/* SalienceEvaluationName: Given the integer value corresponding */
/*   to a specified salience evaluation behavior, returns a      */
/*   character string of the behavior's name.                    */
/*****************************************************************/
static char *SalienceEvaluationName(
  int strategy)
  {
   char *sname;

   switch (strategy)
     {
      case WHEN_DEFINED:
        sname = "when-defined";
        break;
      case WHEN_ACTIVATED:
        sname = "when-activated";
        break;
      case EVERY_CYCLE:
        sname = "every-cycle";
        break;
      default:
        sname = "unknown";
        break;
     }

   return(sname);
  }

/****************************************************************/
/* EnvGetSalienceEvaluation: Returns the value of current type  */
/*  of salience evaluation (e.g., when defined, when activated, */
/*  or every cycle).                                            */
/****************************************************************/
globle intBool EnvGetSalienceEvaluation(
  void *theEnv,
  EXEC_STATUS)
  {   
   return(AgendaData(theEnv,execStatus)->SalienceEvaluation); 
  }

/***********************************************/
/* EnvSetSalienceEvaluation: Sets the value of */
/*   the current type of salience evaluation.  */
/***********************************************/
globle intBool EnvSetSalienceEvaluation(
  void *theEnv,
  EXEC_STATUS,
  int value)
  {
   int ov;

   ov = AgendaData(theEnv,execStatus)->SalienceEvaluation;
   AgendaData(theEnv,execStatus)->SalienceEvaluation = value;
   return(ov);
  }

/*****************************************************************/
/* EvaluateSalience: Returns the salience value of the specified */
/*   defrule. If salience evaluation is currently set to         */
/*   when-defined, then the current value of the rule's salience */
/*   is returned. Otherwise the salience expression associated   */
/*   with the rule is reevaluated, the value is stored as the    */
/*   rule's current salience, and it is then returned.           */
/*****************************************************************/
static int EvaluateSalience(
  void *theEnv,
  EXEC_STATUS,
  void *vPtr)
  {
   struct defrule *rPtr = (struct defrule *) vPtr;
   DATA_OBJECT salienceValue;
   int salience;

  /*==================================================*/
  /* If saliences are only being evaluated when rules */
  /* are defined, then just return the last salience  */
  /* value evaluated for the rule.                    */
  /*==================================================*/

  if (EnvGetSalienceEvaluation(theEnv,execStatus) == WHEN_DEFINED)
    { return(rPtr->salience); }

  /*=================================================================*/
  /* If the rule's salience value was defined as an integer constant */
  /* (i.e., not an expression or global variable which could change  */
  /* on reevaluation), then just return the salience value computed  */
  /* for the rule when it was defined.                               */
  /*=================================================================*/

  if (rPtr->dynamicSalience == NULL) return(rPtr->salience);

  /*====================================================*/
  /* Reevaluate the rule's salience. If an error occurs */
  /* during evaluation, print an error message.         */
  /*====================================================*/

  SetEvaluationError(theEnv,execStatus,FALSE);
  if (EvaluateExpression(theEnv,execStatus,rPtr->dynamicSalience,&salienceValue))
    {
     SalienceInformationError(theEnv,execStatus,"defrule",ValueToString(rPtr->header.name));
     return(rPtr->salience);
    }

  /*========================================*/
  /* The salience value must be an integer. */
  /*========================================*/

  if (salienceValue.type != INTEGER)
    {
     SalienceNonIntegerError(theEnv,execStatus);
     SalienceInformationError(theEnv,execStatus,"defrule",ValueToString(rPtr->header.name));
     SetEvaluationError(theEnv,execStatus,TRUE);
     return(rPtr->salience);
    }

  /*==========================================*/
  /* The salience value must fall between the */
  /* minimum and maximum allowed values.      */
  /*==========================================*/

  salience = (int) ValueToLong(salienceValue.value);

  if ((salience > MAX_DEFRULE_SALIENCE) || (salience < MIN_DEFRULE_SALIENCE))
    {
     SalienceRangeError(theEnv,execStatus,MIN_DEFRULE_SALIENCE,MAX_DEFRULE_SALIENCE);
     SetEvaluationError(theEnv,execStatus,TRUE);
     SalienceInformationError(theEnv,execStatus,"defrule",ValueToString(((struct defrule *) rPtr)->header.name));
     return(rPtr->salience);
    }

  /*===================================*/
  /* Store the new salience value with */
  /* the rule and return this value.   */
  /*===================================*/

  rPtr->salience = salience;
  return(rPtr->salience);
 }

#if DEBUGGING_FUNCTIONS

/***********************************************/
/* AgendaCommand: Prints out the agenda of the */
/*   rules that are ready to fire.             */
/*   Syntax: (agenda)                          */
/***********************************************/
globle void AgendaCommand(
  void *theEnv,
	EXEC_STATUS)
  {
   int numArgs, error;
   struct defmodule *theModule;

   /*==============================================*/
   /* This function can have at most one argument. */
   /*==============================================*/

   if ((numArgs = EnvArgCountCheck(theEnv,execStatus,"agenda",NO_MORE_THAN,1)) == -1) return;

   /*===============================================================*/
   /* If a module name is specified, then the agenda of that module */
   /* is displayed. Otherwise, the agenda of the current module is  */
   /* displayed.                                                    */
   /*===============================================================*/

   if (numArgs == 1)
     {
      theModule = GetModuleName(theEnv,execStatus,"agenda",1,&error);
      if (error) return;
     }
   else
     { theModule = ((struct defmodule *) EnvGetCurrentModule(theEnv,execStatus)); }

   /*===============================================*/
   /* Display the agenda of the appropriate module. */
   /*===============================================*/

   EnvAgenda(theEnv,execStatus,WDISPLAY,theModule);
  }

#endif /* DEBUGGING_FUNCTIONS */

#endif /* DEFRULE_CONSTRUCT */

