[
    {
        "func_name": "trim_dictlist",
        "original": "def trim_dictlist(dict_list, num):\n    new = {}\n    for (pair, pair_data) in dict_list.items():\n        new[pair] = pair_data[num:].reset_index()\n    return new",
        "mutated": [
            "def trim_dictlist(dict_list, num):\n    if False:\n        i = 10\n    new = {}\n    for (pair, pair_data) in dict_list.items():\n        new[pair] = pair_data[num:].reset_index()\n    return new",
            "def trim_dictlist(dict_list, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    new = {}\n    for (pair, pair_data) in dict_list.items():\n        new[pair] = pair_data[num:].reset_index()\n    return new",
            "def trim_dictlist(dict_list, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    new = {}\n    for (pair, pair_data) in dict_list.items():\n        new[pair] = pair_data[num:].reset_index()\n    return new",
            "def trim_dictlist(dict_list, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    new = {}\n    for (pair, pair_data) in dict_list.items():\n        new[pair] = pair_data[num:].reset_index()\n    return new",
            "def trim_dictlist(dict_list, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    new = {}\n    for (pair, pair_data) in dict_list.items():\n        new[pair] = pair_data[num:].reset_index()\n    return new"
        ]
    },
    {
        "func_name": "load_data_test",
        "original": "def load_data_test(what, testdatadir):\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_pair_history(pair='UNITTEST/BTC', datadir=testdatadir, timeframe='1m', timerange=timerange, drop_incomplete=False, fill_up_missing=False)\n    base = 0.001\n    if what == 'raise':\n        data.loc[:, 'open'] = data.index * base\n        data.loc[:, 'high'] = data.index * base + 0.0001\n        data.loc[:, 'low'] = data.index * base - 0.0001\n        data.loc[:, 'close'] = data.index * base\n    if what == 'lower':\n        data.loc[:, 'open'] = 1 - data.index * base\n        data.loc[:, 'high'] = 1 - data.index * base + 0.0001\n        data.loc[:, 'low'] = 1 - data.index * base - 0.0001\n        data.loc[:, 'close'] = 1 - data.index * base\n    if what == 'sine':\n        hz = 0.1\n        data.loc[:, 'open'] = np.sin(data.index * hz) / 1000 + base\n        data.loc[:, 'high'] = np.sin(data.index * hz) / 1000 + base + 0.0001\n        data.loc[:, 'low'] = np.sin(data.index * hz) / 1000 + base - 0.0001\n        data.loc[:, 'close'] = np.sin(data.index * hz) / 1000 + base\n    return {'UNITTEST/BTC': clean_ohlcv_dataframe(data, timeframe='1m', pair='UNITTEST/BTC', fill_missing=True, drop_incomplete=True)}",
        "mutated": [
            "def load_data_test(what, testdatadir):\n    if False:\n        i = 10\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_pair_history(pair='UNITTEST/BTC', datadir=testdatadir, timeframe='1m', timerange=timerange, drop_incomplete=False, fill_up_missing=False)\n    base = 0.001\n    if what == 'raise':\n        data.loc[:, 'open'] = data.index * base\n        data.loc[:, 'high'] = data.index * base + 0.0001\n        data.loc[:, 'low'] = data.index * base - 0.0001\n        data.loc[:, 'close'] = data.index * base\n    if what == 'lower':\n        data.loc[:, 'open'] = 1 - data.index * base\n        data.loc[:, 'high'] = 1 - data.index * base + 0.0001\n        data.loc[:, 'low'] = 1 - data.index * base - 0.0001\n        data.loc[:, 'close'] = 1 - data.index * base\n    if what == 'sine':\n        hz = 0.1\n        data.loc[:, 'open'] = np.sin(data.index * hz) / 1000 + base\n        data.loc[:, 'high'] = np.sin(data.index * hz) / 1000 + base + 0.0001\n        data.loc[:, 'low'] = np.sin(data.index * hz) / 1000 + base - 0.0001\n        data.loc[:, 'close'] = np.sin(data.index * hz) / 1000 + base\n    return {'UNITTEST/BTC': clean_ohlcv_dataframe(data, timeframe='1m', pair='UNITTEST/BTC', fill_missing=True, drop_incomplete=True)}",
            "def load_data_test(what, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_pair_history(pair='UNITTEST/BTC', datadir=testdatadir, timeframe='1m', timerange=timerange, drop_incomplete=False, fill_up_missing=False)\n    base = 0.001\n    if what == 'raise':\n        data.loc[:, 'open'] = data.index * base\n        data.loc[:, 'high'] = data.index * base + 0.0001\n        data.loc[:, 'low'] = data.index * base - 0.0001\n        data.loc[:, 'close'] = data.index * base\n    if what == 'lower':\n        data.loc[:, 'open'] = 1 - data.index * base\n        data.loc[:, 'high'] = 1 - data.index * base + 0.0001\n        data.loc[:, 'low'] = 1 - data.index * base - 0.0001\n        data.loc[:, 'close'] = 1 - data.index * base\n    if what == 'sine':\n        hz = 0.1\n        data.loc[:, 'open'] = np.sin(data.index * hz) / 1000 + base\n        data.loc[:, 'high'] = np.sin(data.index * hz) / 1000 + base + 0.0001\n        data.loc[:, 'low'] = np.sin(data.index * hz) / 1000 + base - 0.0001\n        data.loc[:, 'close'] = np.sin(data.index * hz) / 1000 + base\n    return {'UNITTEST/BTC': clean_ohlcv_dataframe(data, timeframe='1m', pair='UNITTEST/BTC', fill_missing=True, drop_incomplete=True)}",
            "def load_data_test(what, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_pair_history(pair='UNITTEST/BTC', datadir=testdatadir, timeframe='1m', timerange=timerange, drop_incomplete=False, fill_up_missing=False)\n    base = 0.001\n    if what == 'raise':\n        data.loc[:, 'open'] = data.index * base\n        data.loc[:, 'high'] = data.index * base + 0.0001\n        data.loc[:, 'low'] = data.index * base - 0.0001\n        data.loc[:, 'close'] = data.index * base\n    if what == 'lower':\n        data.loc[:, 'open'] = 1 - data.index * base\n        data.loc[:, 'high'] = 1 - data.index * base + 0.0001\n        data.loc[:, 'low'] = 1 - data.index * base - 0.0001\n        data.loc[:, 'close'] = 1 - data.index * base\n    if what == 'sine':\n        hz = 0.1\n        data.loc[:, 'open'] = np.sin(data.index * hz) / 1000 + base\n        data.loc[:, 'high'] = np.sin(data.index * hz) / 1000 + base + 0.0001\n        data.loc[:, 'low'] = np.sin(data.index * hz) / 1000 + base - 0.0001\n        data.loc[:, 'close'] = np.sin(data.index * hz) / 1000 + base\n    return {'UNITTEST/BTC': clean_ohlcv_dataframe(data, timeframe='1m', pair='UNITTEST/BTC', fill_missing=True, drop_incomplete=True)}",
            "def load_data_test(what, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_pair_history(pair='UNITTEST/BTC', datadir=testdatadir, timeframe='1m', timerange=timerange, drop_incomplete=False, fill_up_missing=False)\n    base = 0.001\n    if what == 'raise':\n        data.loc[:, 'open'] = data.index * base\n        data.loc[:, 'high'] = data.index * base + 0.0001\n        data.loc[:, 'low'] = data.index * base - 0.0001\n        data.loc[:, 'close'] = data.index * base\n    if what == 'lower':\n        data.loc[:, 'open'] = 1 - data.index * base\n        data.loc[:, 'high'] = 1 - data.index * base + 0.0001\n        data.loc[:, 'low'] = 1 - data.index * base - 0.0001\n        data.loc[:, 'close'] = 1 - data.index * base\n    if what == 'sine':\n        hz = 0.1\n        data.loc[:, 'open'] = np.sin(data.index * hz) / 1000 + base\n        data.loc[:, 'high'] = np.sin(data.index * hz) / 1000 + base + 0.0001\n        data.loc[:, 'low'] = np.sin(data.index * hz) / 1000 + base - 0.0001\n        data.loc[:, 'close'] = np.sin(data.index * hz) / 1000 + base\n    return {'UNITTEST/BTC': clean_ohlcv_dataframe(data, timeframe='1m', pair='UNITTEST/BTC', fill_missing=True, drop_incomplete=True)}",
            "def load_data_test(what, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_pair_history(pair='UNITTEST/BTC', datadir=testdatadir, timeframe='1m', timerange=timerange, drop_incomplete=False, fill_up_missing=False)\n    base = 0.001\n    if what == 'raise':\n        data.loc[:, 'open'] = data.index * base\n        data.loc[:, 'high'] = data.index * base + 0.0001\n        data.loc[:, 'low'] = data.index * base - 0.0001\n        data.loc[:, 'close'] = data.index * base\n    if what == 'lower':\n        data.loc[:, 'open'] = 1 - data.index * base\n        data.loc[:, 'high'] = 1 - data.index * base + 0.0001\n        data.loc[:, 'low'] = 1 - data.index * base - 0.0001\n        data.loc[:, 'close'] = 1 - data.index * base\n    if what == 'sine':\n        hz = 0.1\n        data.loc[:, 'open'] = np.sin(data.index * hz) / 1000 + base\n        data.loc[:, 'high'] = np.sin(data.index * hz) / 1000 + base + 0.0001\n        data.loc[:, 'low'] = np.sin(data.index * hz) / 1000 + base - 0.0001\n        data.loc[:, 'close'] = np.sin(data.index * hz) / 1000 + base\n    return {'UNITTEST/BTC': clean_ohlcv_dataframe(data, timeframe='1m', pair='UNITTEST/BTC', fill_missing=True, drop_incomplete=True)}"
        ]
    },
    {
        "func_name": "_make_backtest_conf",
        "original": "def _make_backtest_conf(mocker, datadir, conf=None, pair='UNITTEST/BTC'):\n    data = history.load_data(datadir=datadir, timeframe='1m', pairs=[pair])\n    data = trim_dictlist(data, -201)\n    patch_exchange(mocker)\n    backtesting = Backtesting(conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    return {'processed': processed, 'start_date': min_date, 'end_date': max_date}",
        "mutated": [
            "def _make_backtest_conf(mocker, datadir, conf=None, pair='UNITTEST/BTC'):\n    if False:\n        i = 10\n    data = history.load_data(datadir=datadir, timeframe='1m', pairs=[pair])\n    data = trim_dictlist(data, -201)\n    patch_exchange(mocker)\n    backtesting = Backtesting(conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    return {'processed': processed, 'start_date': min_date, 'end_date': max_date}",
            "def _make_backtest_conf(mocker, datadir, conf=None, pair='UNITTEST/BTC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = history.load_data(datadir=datadir, timeframe='1m', pairs=[pair])\n    data = trim_dictlist(data, -201)\n    patch_exchange(mocker)\n    backtesting = Backtesting(conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    return {'processed': processed, 'start_date': min_date, 'end_date': max_date}",
            "def _make_backtest_conf(mocker, datadir, conf=None, pair='UNITTEST/BTC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = history.load_data(datadir=datadir, timeframe='1m', pairs=[pair])\n    data = trim_dictlist(data, -201)\n    patch_exchange(mocker)\n    backtesting = Backtesting(conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    return {'processed': processed, 'start_date': min_date, 'end_date': max_date}",
            "def _make_backtest_conf(mocker, datadir, conf=None, pair='UNITTEST/BTC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = history.load_data(datadir=datadir, timeframe='1m', pairs=[pair])\n    data = trim_dictlist(data, -201)\n    patch_exchange(mocker)\n    backtesting = Backtesting(conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    return {'processed': processed, 'start_date': min_date, 'end_date': max_date}",
            "def _make_backtest_conf(mocker, datadir, conf=None, pair='UNITTEST/BTC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = history.load_data(datadir=datadir, timeframe='1m', pairs=[pair])\n    data = trim_dictlist(data, -201)\n    patch_exchange(mocker)\n    backtesting = Backtesting(conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    return {'processed': processed, 'start_date': min_date, 'end_date': max_date}"
        ]
    },
    {
        "func_name": "_trend",
        "original": "def _trend(signals, buy_value, sell_value):\n    n = len(signals['low'])\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(signals['date'])):\n        if random.random() > 0.5:\n            buy[i] = buy_value\n            sell[i] = sell_value\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return signals",
        "mutated": [
            "def _trend(signals, buy_value, sell_value):\n    if False:\n        i = 10\n    n = len(signals['low'])\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(signals['date'])):\n        if random.random() > 0.5:\n            buy[i] = buy_value\n            sell[i] = sell_value\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return signals",
            "def _trend(signals, buy_value, sell_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n = len(signals['low'])\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(signals['date'])):\n        if random.random() > 0.5:\n            buy[i] = buy_value\n            sell[i] = sell_value\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return signals",
            "def _trend(signals, buy_value, sell_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n = len(signals['low'])\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(signals['date'])):\n        if random.random() > 0.5:\n            buy[i] = buy_value\n            sell[i] = sell_value\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return signals",
            "def _trend(signals, buy_value, sell_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n = len(signals['low'])\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(signals['date'])):\n        if random.random() > 0.5:\n            buy[i] = buy_value\n            sell[i] = sell_value\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return signals",
            "def _trend(signals, buy_value, sell_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n = len(signals['low'])\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(signals['date'])):\n        if random.random() > 0.5:\n            buy[i] = buy_value\n            sell[i] = sell_value\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return signals"
        ]
    },
    {
        "func_name": "_trend_alternate",
        "original": "def _trend_alternate(dataframe=None, metadata=None):\n    signals = dataframe\n    low = signals['low']\n    n = len(low)\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(buy)):\n        if i % 2 == 0:\n            buy[i] = 1\n        else:\n            sell[i] = 1\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return dataframe",
        "mutated": [
            "def _trend_alternate(dataframe=None, metadata=None):\n    if False:\n        i = 10\n    signals = dataframe\n    low = signals['low']\n    n = len(low)\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(buy)):\n        if i % 2 == 0:\n            buy[i] = 1\n        else:\n            sell[i] = 1\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return dataframe",
            "def _trend_alternate(dataframe=None, metadata=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    signals = dataframe\n    low = signals['low']\n    n = len(low)\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(buy)):\n        if i % 2 == 0:\n            buy[i] = 1\n        else:\n            sell[i] = 1\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return dataframe",
            "def _trend_alternate(dataframe=None, metadata=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    signals = dataframe\n    low = signals['low']\n    n = len(low)\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(buy)):\n        if i % 2 == 0:\n            buy[i] = 1\n        else:\n            sell[i] = 1\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return dataframe",
            "def _trend_alternate(dataframe=None, metadata=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    signals = dataframe\n    low = signals['low']\n    n = len(low)\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(buy)):\n        if i % 2 == 0:\n            buy[i] = 1\n        else:\n            sell[i] = 1\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return dataframe",
            "def _trend_alternate(dataframe=None, metadata=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    signals = dataframe\n    low = signals['low']\n    n = len(low)\n    buy = np.zeros(n)\n    sell = np.zeros(n)\n    for i in range(0, len(buy)):\n        if i % 2 == 0:\n            buy[i] = 1\n        else:\n            sell[i] = 1\n    signals['enter_long'] = buy\n    signals['exit_long'] = sell\n    signals['enter_short'] = 0\n    signals['exit_short'] = 0\n    return dataframe"
        ]
    },
    {
        "func_name": "test_setup_optimize_configuration_without_arguments",
        "original": "def test_setup_optimize_configuration_without_arguments(mocker, default_conf, caplog) -> None:\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--export', 'none']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert not log_has_re('Parameter -i/--ticker-interval detected .*', caplog)\n    assert 'position_stacking' not in config\n    assert not log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'timerange' not in config\n    assert 'export' in config\n    assert config['export'] == 'none'\n    assert 'runmode' in config\n    assert config['runmode'] == RunMode.BACKTEST",
        "mutated": [
            "def test_setup_optimize_configuration_without_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--export', 'none']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert not log_has_re('Parameter -i/--ticker-interval detected .*', caplog)\n    assert 'position_stacking' not in config\n    assert not log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'timerange' not in config\n    assert 'export' in config\n    assert config['export'] == 'none'\n    assert 'runmode' in config\n    assert config['runmode'] == RunMode.BACKTEST",
            "def test_setup_optimize_configuration_without_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--export', 'none']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert not log_has_re('Parameter -i/--ticker-interval detected .*', caplog)\n    assert 'position_stacking' not in config\n    assert not log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'timerange' not in config\n    assert 'export' in config\n    assert config['export'] == 'none'\n    assert 'runmode' in config\n    assert config['runmode'] == RunMode.BACKTEST",
            "def test_setup_optimize_configuration_without_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--export', 'none']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert not log_has_re('Parameter -i/--ticker-interval detected .*', caplog)\n    assert 'position_stacking' not in config\n    assert not log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'timerange' not in config\n    assert 'export' in config\n    assert config['export'] == 'none'\n    assert 'runmode' in config\n    assert config['runmode'] == RunMode.BACKTEST",
            "def test_setup_optimize_configuration_without_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--export', 'none']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert not log_has_re('Parameter -i/--ticker-interval detected .*', caplog)\n    assert 'position_stacking' not in config\n    assert not log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'timerange' not in config\n    assert 'export' in config\n    assert config['export'] == 'none'\n    assert 'runmode' in config\n    assert config['runmode'] == RunMode.BACKTEST",
            "def test_setup_optimize_configuration_without_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--export', 'none']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert not log_has_re('Parameter -i/--ticker-interval detected .*', caplog)\n    assert 'position_stacking' not in config\n    assert not log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'timerange' not in config\n    assert 'export' in config\n    assert config['export'] == 'none'\n    assert 'runmode' in config\n    assert config['runmode'] == RunMode.BACKTEST"
        ]
    },
    {
        "func_name": "test_setup_bt_configuration_with_arguments",
        "original": "def test_setup_bt_configuration_with_arguments(mocker, default_conf, caplog) -> None:\n    patched_configuration_load_config_file(mocker, default_conf)\n    mocker.patch('freqtrade.configuration.configuration.create_datadir', lambda c, x: x)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', '/foo/bar', '--timeframe', '1m', '--enable-position-stacking', '--disable-max-market-positions', '--timerange', ':100', '--export-filename', 'foo_bar.json', '--fee', '0']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert config['runmode'] == RunMode.BACKTEST\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert log_has('Parameter -i/--timeframe detected ... Using timeframe: 1m ...', caplog)\n    assert 'position_stacking' in config\n    assert log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'use_max_market_positions' in config\n    assert log_has('Parameter --disable-max-market-positions detected ...', caplog)\n    assert log_has('max_open_trades set to unlimited ...', caplog)\n    assert 'timerange' in config\n    assert log_has('Parameter --timerange detected: {} ...'.format(config['timerange']), caplog)\n    assert 'export' in config\n    assert 'exportfilename' in config\n    assert isinstance(config['exportfilename'], Path)\n    assert log_has('Storing backtest results to {} ...'.format(config['exportfilename']), caplog)\n    assert 'fee' in config\n    assert log_has('Parameter --fee detected, setting fee to: {} ...'.format(config['fee']), caplog)",
        "mutated": [
            "def test_setup_bt_configuration_with_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n    patched_configuration_load_config_file(mocker, default_conf)\n    mocker.patch('freqtrade.configuration.configuration.create_datadir', lambda c, x: x)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', '/foo/bar', '--timeframe', '1m', '--enable-position-stacking', '--disable-max-market-positions', '--timerange', ':100', '--export-filename', 'foo_bar.json', '--fee', '0']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert config['runmode'] == RunMode.BACKTEST\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert log_has('Parameter -i/--timeframe detected ... Using timeframe: 1m ...', caplog)\n    assert 'position_stacking' in config\n    assert log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'use_max_market_positions' in config\n    assert log_has('Parameter --disable-max-market-positions detected ...', caplog)\n    assert log_has('max_open_trades set to unlimited ...', caplog)\n    assert 'timerange' in config\n    assert log_has('Parameter --timerange detected: {} ...'.format(config['timerange']), caplog)\n    assert 'export' in config\n    assert 'exportfilename' in config\n    assert isinstance(config['exportfilename'], Path)\n    assert log_has('Storing backtest results to {} ...'.format(config['exportfilename']), caplog)\n    assert 'fee' in config\n    assert log_has('Parameter --fee detected, setting fee to: {} ...'.format(config['fee']), caplog)",
            "def test_setup_bt_configuration_with_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patched_configuration_load_config_file(mocker, default_conf)\n    mocker.patch('freqtrade.configuration.configuration.create_datadir', lambda c, x: x)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', '/foo/bar', '--timeframe', '1m', '--enable-position-stacking', '--disable-max-market-positions', '--timerange', ':100', '--export-filename', 'foo_bar.json', '--fee', '0']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert config['runmode'] == RunMode.BACKTEST\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert log_has('Parameter -i/--timeframe detected ... Using timeframe: 1m ...', caplog)\n    assert 'position_stacking' in config\n    assert log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'use_max_market_positions' in config\n    assert log_has('Parameter --disable-max-market-positions detected ...', caplog)\n    assert log_has('max_open_trades set to unlimited ...', caplog)\n    assert 'timerange' in config\n    assert log_has('Parameter --timerange detected: {} ...'.format(config['timerange']), caplog)\n    assert 'export' in config\n    assert 'exportfilename' in config\n    assert isinstance(config['exportfilename'], Path)\n    assert log_has('Storing backtest results to {} ...'.format(config['exportfilename']), caplog)\n    assert 'fee' in config\n    assert log_has('Parameter --fee detected, setting fee to: {} ...'.format(config['fee']), caplog)",
            "def test_setup_bt_configuration_with_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patched_configuration_load_config_file(mocker, default_conf)\n    mocker.patch('freqtrade.configuration.configuration.create_datadir', lambda c, x: x)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', '/foo/bar', '--timeframe', '1m', '--enable-position-stacking', '--disable-max-market-positions', '--timerange', ':100', '--export-filename', 'foo_bar.json', '--fee', '0']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert config['runmode'] == RunMode.BACKTEST\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert log_has('Parameter -i/--timeframe detected ... Using timeframe: 1m ...', caplog)\n    assert 'position_stacking' in config\n    assert log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'use_max_market_positions' in config\n    assert log_has('Parameter --disable-max-market-positions detected ...', caplog)\n    assert log_has('max_open_trades set to unlimited ...', caplog)\n    assert 'timerange' in config\n    assert log_has('Parameter --timerange detected: {} ...'.format(config['timerange']), caplog)\n    assert 'export' in config\n    assert 'exportfilename' in config\n    assert isinstance(config['exportfilename'], Path)\n    assert log_has('Storing backtest results to {} ...'.format(config['exportfilename']), caplog)\n    assert 'fee' in config\n    assert log_has('Parameter --fee detected, setting fee to: {} ...'.format(config['fee']), caplog)",
            "def test_setup_bt_configuration_with_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patched_configuration_load_config_file(mocker, default_conf)\n    mocker.patch('freqtrade.configuration.configuration.create_datadir', lambda c, x: x)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', '/foo/bar', '--timeframe', '1m', '--enable-position-stacking', '--disable-max-market-positions', '--timerange', ':100', '--export-filename', 'foo_bar.json', '--fee', '0']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert config['runmode'] == RunMode.BACKTEST\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert log_has('Parameter -i/--timeframe detected ... Using timeframe: 1m ...', caplog)\n    assert 'position_stacking' in config\n    assert log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'use_max_market_positions' in config\n    assert log_has('Parameter --disable-max-market-positions detected ...', caplog)\n    assert log_has('max_open_trades set to unlimited ...', caplog)\n    assert 'timerange' in config\n    assert log_has('Parameter --timerange detected: {} ...'.format(config['timerange']), caplog)\n    assert 'export' in config\n    assert 'exportfilename' in config\n    assert isinstance(config['exportfilename'], Path)\n    assert log_has('Storing backtest results to {} ...'.format(config['exportfilename']), caplog)\n    assert 'fee' in config\n    assert log_has('Parameter --fee detected, setting fee to: {} ...'.format(config['fee']), caplog)",
            "def test_setup_bt_configuration_with_arguments(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patched_configuration_load_config_file(mocker, default_conf)\n    mocker.patch('freqtrade.configuration.configuration.create_datadir', lambda c, x: x)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', '/foo/bar', '--timeframe', '1m', '--enable-position-stacking', '--disable-max-market-positions', '--timerange', ':100', '--export-filename', 'foo_bar.json', '--fee', '0']\n    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert 'max_open_trades' in config\n    assert 'stake_currency' in config\n    assert 'stake_amount' in config\n    assert 'exchange' in config\n    assert 'pair_whitelist' in config['exchange']\n    assert 'datadir' in config\n    assert config['runmode'] == RunMode.BACKTEST\n    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n    assert 'timeframe' in config\n    assert log_has('Parameter -i/--timeframe detected ... Using timeframe: 1m ...', caplog)\n    assert 'position_stacking' in config\n    assert log_has('Parameter --enable-position-stacking detected ...', caplog)\n    assert 'use_max_market_positions' in config\n    assert log_has('Parameter --disable-max-market-positions detected ...', caplog)\n    assert log_has('max_open_trades set to unlimited ...', caplog)\n    assert 'timerange' in config\n    assert log_has('Parameter --timerange detected: {} ...'.format(config['timerange']), caplog)\n    assert 'export' in config\n    assert 'exportfilename' in config\n    assert isinstance(config['exportfilename'], Path)\n    assert log_has('Storing backtest results to {} ...'.format(config['exportfilename']), caplog)\n    assert 'fee' in config\n    assert log_has('Parameter --fee detected, setting fee to: {} ...'.format(config['fee']), caplog)"
        ]
    },
    {
        "func_name": "test_setup_optimize_configuration_stake_amount",
        "original": "def test_setup_optimize_configuration_stake_amount(mocker, default_conf, caplog) -> None:\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '2']\n    conf = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert isinstance(conf, dict)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '0.5']\n    with pytest.raises(OperationalException, match='Starting balance .* smaller .*'):\n        setup_optimize_configuration(get_args(args), RunMode.BACKTEST)",
        "mutated": [
            "def test_setup_optimize_configuration_stake_amount(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '2']\n    conf = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert isinstance(conf, dict)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '0.5']\n    with pytest.raises(OperationalException, match='Starting balance .* smaller .*'):\n        setup_optimize_configuration(get_args(args), RunMode.BACKTEST)",
            "def test_setup_optimize_configuration_stake_amount(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '2']\n    conf = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert isinstance(conf, dict)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '0.5']\n    with pytest.raises(OperationalException, match='Starting balance .* smaller .*'):\n        setup_optimize_configuration(get_args(args), RunMode.BACKTEST)",
            "def test_setup_optimize_configuration_stake_amount(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '2']\n    conf = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert isinstance(conf, dict)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '0.5']\n    with pytest.raises(OperationalException, match='Starting balance .* smaller .*'):\n        setup_optimize_configuration(get_args(args), RunMode.BACKTEST)",
            "def test_setup_optimize_configuration_stake_amount(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '2']\n    conf = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert isinstance(conf, dict)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '0.5']\n    with pytest.raises(OperationalException, match='Starting balance .* smaller .*'):\n        setup_optimize_configuration(get_args(args), RunMode.BACKTEST)",
            "def test_setup_optimize_configuration_stake_amount(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '2']\n    conf = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n    assert isinstance(conf, dict)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--stake-amount', '1', '--starting-balance', '0.5']\n    with pytest.raises(OperationalException, match='Starting balance .* smaller .*'):\n        setup_optimize_configuration(get_args(args), RunMode.BACKTEST)"
        ]
    },
    {
        "func_name": "test_start",
        "original": "def test_start(mocker, fee, default_conf, caplog) -> None:\n    start_mock = MagicMock()\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.start', start_mock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY]\n    pargs = get_args(args)\n    start_backtesting(pargs)\n    assert log_has('Starting freqtrade in Backtesting mode', caplog)\n    assert start_mock.call_count == 1",
        "mutated": [
            "def test_start(mocker, fee, default_conf, caplog) -> None:\n    if False:\n        i = 10\n    start_mock = MagicMock()\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.start', start_mock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY]\n    pargs = get_args(args)\n    start_backtesting(pargs)\n    assert log_has('Starting freqtrade in Backtesting mode', caplog)\n    assert start_mock.call_count == 1",
            "def test_start(mocker, fee, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start_mock = MagicMock()\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.start', start_mock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY]\n    pargs = get_args(args)\n    start_backtesting(pargs)\n    assert log_has('Starting freqtrade in Backtesting mode', caplog)\n    assert start_mock.call_count == 1",
            "def test_start(mocker, fee, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start_mock = MagicMock()\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.start', start_mock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY]\n    pargs = get_args(args)\n    start_backtesting(pargs)\n    assert log_has('Starting freqtrade in Backtesting mode', caplog)\n    assert start_mock.call_count == 1",
            "def test_start(mocker, fee, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start_mock = MagicMock()\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.start', start_mock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY]\n    pargs = get_args(args)\n    start_backtesting(pargs)\n    assert log_has('Starting freqtrade in Backtesting mode', caplog)\n    assert start_mock.call_count == 1",
            "def test_start(mocker, fee, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start_mock = MagicMock()\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.start', start_mock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY]\n    pargs = get_args(args)\n    start_backtesting(pargs)\n    assert log_has('Starting freqtrade in Backtesting mode', caplog)\n    assert start_mock.call_count == 1"
        ]
    },
    {
        "func_name": "test_backtesting_init",
        "original": "@pytest.mark.parametrize('order_types', ORDER_TYPES)\ndef test_backtesting_init(mocker, default_conf, order_types) -> None:\n    \"\"\"\n    Check that stoploss_on_exchange is set to False while backtesting\n    since backtesting assumes a perfect stoploss anyway.\n    \"\"\"\n    default_conf['order_types'] = order_types\n    patch_exchange(mocker)\n    get_fee = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.config == default_conf\n    assert backtesting.timeframe == '5m'\n    assert callable(backtesting.strategy.advise_all_indicators)\n    assert callable(backtesting.strategy.advise_entry)\n    assert callable(backtesting.strategy.advise_exit)\n    assert isinstance(backtesting.strategy.dp, DataProvider)\n    get_fee.assert_called()\n    assert backtesting.fee == 0.5\n    assert not backtesting.strategy.order_types['stoploss_on_exchange']\n    assert backtesting.strategy.bot_started is True",
        "mutated": [
            "@pytest.mark.parametrize('order_types', ORDER_TYPES)\ndef test_backtesting_init(mocker, default_conf, order_types) -> None:\n    if False:\n        i = 10\n    '\\n    Check that stoploss_on_exchange is set to False while backtesting\\n    since backtesting assumes a perfect stoploss anyway.\\n    '\n    default_conf['order_types'] = order_types\n    patch_exchange(mocker)\n    get_fee = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.config == default_conf\n    assert backtesting.timeframe == '5m'\n    assert callable(backtesting.strategy.advise_all_indicators)\n    assert callable(backtesting.strategy.advise_entry)\n    assert callable(backtesting.strategy.advise_exit)\n    assert isinstance(backtesting.strategy.dp, DataProvider)\n    get_fee.assert_called()\n    assert backtesting.fee == 0.5\n    assert not backtesting.strategy.order_types['stoploss_on_exchange']\n    assert backtesting.strategy.bot_started is True",
            "@pytest.mark.parametrize('order_types', ORDER_TYPES)\ndef test_backtesting_init(mocker, default_conf, order_types) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check that stoploss_on_exchange is set to False while backtesting\\n    since backtesting assumes a perfect stoploss anyway.\\n    '\n    default_conf['order_types'] = order_types\n    patch_exchange(mocker)\n    get_fee = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.config == default_conf\n    assert backtesting.timeframe == '5m'\n    assert callable(backtesting.strategy.advise_all_indicators)\n    assert callable(backtesting.strategy.advise_entry)\n    assert callable(backtesting.strategy.advise_exit)\n    assert isinstance(backtesting.strategy.dp, DataProvider)\n    get_fee.assert_called()\n    assert backtesting.fee == 0.5\n    assert not backtesting.strategy.order_types['stoploss_on_exchange']\n    assert backtesting.strategy.bot_started is True",
            "@pytest.mark.parametrize('order_types', ORDER_TYPES)\ndef test_backtesting_init(mocker, default_conf, order_types) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check that stoploss_on_exchange is set to False while backtesting\\n    since backtesting assumes a perfect stoploss anyway.\\n    '\n    default_conf['order_types'] = order_types\n    patch_exchange(mocker)\n    get_fee = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.config == default_conf\n    assert backtesting.timeframe == '5m'\n    assert callable(backtesting.strategy.advise_all_indicators)\n    assert callable(backtesting.strategy.advise_entry)\n    assert callable(backtesting.strategy.advise_exit)\n    assert isinstance(backtesting.strategy.dp, DataProvider)\n    get_fee.assert_called()\n    assert backtesting.fee == 0.5\n    assert not backtesting.strategy.order_types['stoploss_on_exchange']\n    assert backtesting.strategy.bot_started is True",
            "@pytest.mark.parametrize('order_types', ORDER_TYPES)\ndef test_backtesting_init(mocker, default_conf, order_types) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check that stoploss_on_exchange is set to False while backtesting\\n    since backtesting assumes a perfect stoploss anyway.\\n    '\n    default_conf['order_types'] = order_types\n    patch_exchange(mocker)\n    get_fee = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.config == default_conf\n    assert backtesting.timeframe == '5m'\n    assert callable(backtesting.strategy.advise_all_indicators)\n    assert callable(backtesting.strategy.advise_entry)\n    assert callable(backtesting.strategy.advise_exit)\n    assert isinstance(backtesting.strategy.dp, DataProvider)\n    get_fee.assert_called()\n    assert backtesting.fee == 0.5\n    assert not backtesting.strategy.order_types['stoploss_on_exchange']\n    assert backtesting.strategy.bot_started is True",
            "@pytest.mark.parametrize('order_types', ORDER_TYPES)\ndef test_backtesting_init(mocker, default_conf, order_types) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check that stoploss_on_exchange is set to False while backtesting\\n    since backtesting assumes a perfect stoploss anyway.\\n    '\n    default_conf['order_types'] = order_types\n    patch_exchange(mocker)\n    get_fee = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.config == default_conf\n    assert backtesting.timeframe == '5m'\n    assert callable(backtesting.strategy.advise_all_indicators)\n    assert callable(backtesting.strategy.advise_entry)\n    assert callable(backtesting.strategy.advise_exit)\n    assert isinstance(backtesting.strategy.dp, DataProvider)\n    get_fee.assert_called()\n    assert backtesting.fee == 0.5\n    assert not backtesting.strategy.order_types['stoploss_on_exchange']\n    assert backtesting.strategy.bot_started is True"
        ]
    },
    {
        "func_name": "test_backtesting_init_no_timeframe",
        "original": "def test_backtesting_init_no_timeframe(mocker, default_conf, caplog) -> None:\n    patch_exchange(mocker)\n    del default_conf['timeframe']\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'HyperoptableStrategy']\n    mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    with pytest.raises(OperationalException, match='Timeframe needs to be set in either configuration'):\n        Backtesting(default_conf)",
        "mutated": [
            "def test_backtesting_init_no_timeframe(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n    patch_exchange(mocker)\n    del default_conf['timeframe']\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'HyperoptableStrategy']\n    mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    with pytest.raises(OperationalException, match='Timeframe needs to be set in either configuration'):\n        Backtesting(default_conf)",
            "def test_backtesting_init_no_timeframe(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patch_exchange(mocker)\n    del default_conf['timeframe']\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'HyperoptableStrategy']\n    mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    with pytest.raises(OperationalException, match='Timeframe needs to be set in either configuration'):\n        Backtesting(default_conf)",
            "def test_backtesting_init_no_timeframe(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patch_exchange(mocker)\n    del default_conf['timeframe']\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'HyperoptableStrategy']\n    mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    with pytest.raises(OperationalException, match='Timeframe needs to be set in either configuration'):\n        Backtesting(default_conf)",
            "def test_backtesting_init_no_timeframe(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patch_exchange(mocker)\n    del default_conf['timeframe']\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'HyperoptableStrategy']\n    mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    with pytest.raises(OperationalException, match='Timeframe needs to be set in either configuration'):\n        Backtesting(default_conf)",
            "def test_backtesting_init_no_timeframe(mocker, default_conf, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patch_exchange(mocker)\n    del default_conf['timeframe']\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'HyperoptableStrategy']\n    mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    with pytest.raises(OperationalException, match='Timeframe needs to be set in either configuration'):\n        Backtesting(default_conf)"
        ]
    },
    {
        "func_name": "test_data_with_fee",
        "original": "def test_data_with_fee(default_conf, mocker) -> None:\n    patch_exchange(mocker)\n    default_conf['fee'] = 0.1234\n    fee_mock = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.1234\n    assert fee_mock.call_count == 0\n    default_conf['fee'] = 0.0\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.0\n    assert fee_mock.call_count == 0",
        "mutated": [
            "def test_data_with_fee(default_conf, mocker) -> None:\n    if False:\n        i = 10\n    patch_exchange(mocker)\n    default_conf['fee'] = 0.1234\n    fee_mock = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.1234\n    assert fee_mock.call_count == 0\n    default_conf['fee'] = 0.0\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.0\n    assert fee_mock.call_count == 0",
            "def test_data_with_fee(default_conf, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patch_exchange(mocker)\n    default_conf['fee'] = 0.1234\n    fee_mock = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.1234\n    assert fee_mock.call_count == 0\n    default_conf['fee'] = 0.0\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.0\n    assert fee_mock.call_count == 0",
            "def test_data_with_fee(default_conf, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patch_exchange(mocker)\n    default_conf['fee'] = 0.1234\n    fee_mock = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.1234\n    assert fee_mock.call_count == 0\n    default_conf['fee'] = 0.0\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.0\n    assert fee_mock.call_count == 0",
            "def test_data_with_fee(default_conf, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patch_exchange(mocker)\n    default_conf['fee'] = 0.1234\n    fee_mock = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.1234\n    assert fee_mock.call_count == 0\n    default_conf['fee'] = 0.0\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.0\n    assert fee_mock.call_count == 0",
            "def test_data_with_fee(default_conf, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patch_exchange(mocker)\n    default_conf['fee'] = 0.1234\n    fee_mock = mocker.patch(f'{EXMS}.get_fee', MagicMock(return_value=0.5))\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.1234\n    assert fee_mock.call_count == 0\n    default_conf['fee'] = 0.0\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    assert backtesting.fee == 0.0\n    assert fee_mock.call_count == 0"
        ]
    },
    {
        "func_name": "test_data_to_dataframe_bt",
        "original": "def test_data_to_dataframe_bt(default_conf, mocker, testdatadir) -> None:\n    patch_exchange(mocker)\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    assert len(processed['UNITTEST/BTC']) == 103\n    strategy = StrategyResolver.load_strategy(default_conf)\n    processed2 = strategy.advise_all_indicators(data)\n    assert processed['UNITTEST/BTC'].equals(processed2['UNITTEST/BTC'])",
        "mutated": [
            "def test_data_to_dataframe_bt(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    patch_exchange(mocker)\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    assert len(processed['UNITTEST/BTC']) == 103\n    strategy = StrategyResolver.load_strategy(default_conf)\n    processed2 = strategy.advise_all_indicators(data)\n    assert processed['UNITTEST/BTC'].equals(processed2['UNITTEST/BTC'])",
            "def test_data_to_dataframe_bt(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patch_exchange(mocker)\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    assert len(processed['UNITTEST/BTC']) == 103\n    strategy = StrategyResolver.load_strategy(default_conf)\n    processed2 = strategy.advise_all_indicators(data)\n    assert processed['UNITTEST/BTC'].equals(processed2['UNITTEST/BTC'])",
            "def test_data_to_dataframe_bt(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patch_exchange(mocker)\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    assert len(processed['UNITTEST/BTC']) == 103\n    strategy = StrategyResolver.load_strategy(default_conf)\n    processed2 = strategy.advise_all_indicators(data)\n    assert processed['UNITTEST/BTC'].equals(processed2['UNITTEST/BTC'])",
            "def test_data_to_dataframe_bt(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patch_exchange(mocker)\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    assert len(processed['UNITTEST/BTC']) == 103\n    strategy = StrategyResolver.load_strategy(default_conf)\n    processed2 = strategy.advise_all_indicators(data)\n    assert processed['UNITTEST/BTC'].equals(processed2['UNITTEST/BTC'])",
            "def test_data_to_dataframe_bt(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patch_exchange(mocker)\n    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n    data = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    processed = backtesting.strategy.advise_all_indicators(data)\n    assert len(processed['UNITTEST/BTC']) == 103\n    strategy = StrategyResolver.load_strategy(default_conf)\n    processed2 = strategy.advise_all_indicators(data)\n    assert processed['UNITTEST/BTC'].equals(processed2['UNITTEST/BTC'])"
        ]
    },
    {
        "func_name": "test_backtest_abort",
        "original": "def test_backtest_abort(default_conf, mocker, testdatadir) -> None:\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting.check_abort()\n    backtesting.abort = True\n    with pytest.raises(DependencyException, match='Stop requested'):\n        backtesting.check_abort()\n    assert backtesting.abort is False\n    assert backtesting.progress.progress == 0",
        "mutated": [
            "def test_backtest_abort(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting.check_abort()\n    backtesting.abort = True\n    with pytest.raises(DependencyException, match='Stop requested'):\n        backtesting.check_abort()\n    assert backtesting.abort is False\n    assert backtesting.progress.progress == 0",
            "def test_backtest_abort(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting.check_abort()\n    backtesting.abort = True\n    with pytest.raises(DependencyException, match='Stop requested'):\n        backtesting.check_abort()\n    assert backtesting.abort is False\n    assert backtesting.progress.progress == 0",
            "def test_backtest_abort(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting.check_abort()\n    backtesting.abort = True\n    with pytest.raises(DependencyException, match='Stop requested'):\n        backtesting.check_abort()\n    assert backtesting.abort is False\n    assert backtesting.progress.progress == 0",
            "def test_backtest_abort(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting.check_abort()\n    backtesting.abort = True\n    with pytest.raises(DependencyException, match='Stop requested'):\n        backtesting.check_abort()\n    assert backtesting.abort is False\n    assert backtesting.progress.progress == 0",
            "def test_backtest_abort(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting.check_abort()\n    backtesting.abort = True\n    with pytest.raises(DependencyException, match='Stop requested'):\n        backtesting.check_abort()\n    assert backtesting.abort is False\n    assert backtesting.progress.progress == 0"
        ]
    },
    {
        "func_name": "get_timerange",
        "original": "def get_timerange(input1):\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
        "mutated": [
            "def get_timerange(input1):\n    if False:\n        i = 10\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
            "def get_timerange(input1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
            "def get_timerange(input1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
            "def get_timerange(input1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
            "def get_timerange(input1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))"
        ]
    },
    {
        "func_name": "test_backtesting_start",
        "original": "def test_backtesting_start(default_conf, mocker, caplog) -> None:\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    sbs = mocker.patch('freqtrade.optimize.backtesting.store_backtest_stats')\n    sbc = mocker.patch('freqtrade.optimize.backtesting.store_backtest_analysis_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'signals'\n    default_conf['exportfilename'] = 'export.txt'\n    default_conf['timerange'] = '-1510694220'\n    default_conf['runmode'] = RunMode.BACKTEST\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.bot_loop_start = MagicMock()\n    backtesting.strategy.bot_start = MagicMock()\n    backtesting.start()\n    exists = ['Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    for line in exists:\n        assert log_has(line, caplog)\n    assert backtesting.strategy.dp._pairlists is not None\n    assert backtesting.strategy.bot_start.call_count == 1\n    assert backtesting.strategy.bot_loop_start.call_count == 0\n    assert sbs.call_count == 1\n    assert sbc.call_count == 1",
        "mutated": [
            "def test_backtesting_start(default_conf, mocker, caplog) -> None:\n    if False:\n        i = 10\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    sbs = mocker.patch('freqtrade.optimize.backtesting.store_backtest_stats')\n    sbc = mocker.patch('freqtrade.optimize.backtesting.store_backtest_analysis_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'signals'\n    default_conf['exportfilename'] = 'export.txt'\n    default_conf['timerange'] = '-1510694220'\n    default_conf['runmode'] = RunMode.BACKTEST\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.bot_loop_start = MagicMock()\n    backtesting.strategy.bot_start = MagicMock()\n    backtesting.start()\n    exists = ['Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    for line in exists:\n        assert log_has(line, caplog)\n    assert backtesting.strategy.dp._pairlists is not None\n    assert backtesting.strategy.bot_start.call_count == 1\n    assert backtesting.strategy.bot_loop_start.call_count == 0\n    assert sbs.call_count == 1\n    assert sbc.call_count == 1",
            "def test_backtesting_start(default_conf, mocker, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    sbs = mocker.patch('freqtrade.optimize.backtesting.store_backtest_stats')\n    sbc = mocker.patch('freqtrade.optimize.backtesting.store_backtest_analysis_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'signals'\n    default_conf['exportfilename'] = 'export.txt'\n    default_conf['timerange'] = '-1510694220'\n    default_conf['runmode'] = RunMode.BACKTEST\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.bot_loop_start = MagicMock()\n    backtesting.strategy.bot_start = MagicMock()\n    backtesting.start()\n    exists = ['Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    for line in exists:\n        assert log_has(line, caplog)\n    assert backtesting.strategy.dp._pairlists is not None\n    assert backtesting.strategy.bot_start.call_count == 1\n    assert backtesting.strategy.bot_loop_start.call_count == 0\n    assert sbs.call_count == 1\n    assert sbc.call_count == 1",
            "def test_backtesting_start(default_conf, mocker, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    sbs = mocker.patch('freqtrade.optimize.backtesting.store_backtest_stats')\n    sbc = mocker.patch('freqtrade.optimize.backtesting.store_backtest_analysis_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'signals'\n    default_conf['exportfilename'] = 'export.txt'\n    default_conf['timerange'] = '-1510694220'\n    default_conf['runmode'] = RunMode.BACKTEST\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.bot_loop_start = MagicMock()\n    backtesting.strategy.bot_start = MagicMock()\n    backtesting.start()\n    exists = ['Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    for line in exists:\n        assert log_has(line, caplog)\n    assert backtesting.strategy.dp._pairlists is not None\n    assert backtesting.strategy.bot_start.call_count == 1\n    assert backtesting.strategy.bot_loop_start.call_count == 0\n    assert sbs.call_count == 1\n    assert sbc.call_count == 1",
            "def test_backtesting_start(default_conf, mocker, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    sbs = mocker.patch('freqtrade.optimize.backtesting.store_backtest_stats')\n    sbc = mocker.patch('freqtrade.optimize.backtesting.store_backtest_analysis_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'signals'\n    default_conf['exportfilename'] = 'export.txt'\n    default_conf['timerange'] = '-1510694220'\n    default_conf['runmode'] = RunMode.BACKTEST\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.bot_loop_start = MagicMock()\n    backtesting.strategy.bot_start = MagicMock()\n    backtesting.start()\n    exists = ['Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    for line in exists:\n        assert log_has(line, caplog)\n    assert backtesting.strategy.dp._pairlists is not None\n    assert backtesting.strategy.bot_start.call_count == 1\n    assert backtesting.strategy.bot_loop_start.call_count == 0\n    assert sbs.call_count == 1\n    assert sbc.call_count == 1",
            "def test_backtesting_start(default_conf, mocker, caplog) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    sbs = mocker.patch('freqtrade.optimize.backtesting.store_backtest_stats')\n    sbc = mocker.patch('freqtrade.optimize.backtesting.store_backtest_analysis_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'signals'\n    default_conf['exportfilename'] = 'export.txt'\n    default_conf['timerange'] = '-1510694220'\n    default_conf['runmode'] = RunMode.BACKTEST\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.bot_loop_start = MagicMock()\n    backtesting.strategy.bot_start = MagicMock()\n    backtesting.start()\n    exists = ['Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    for line in exists:\n        assert log_has(line, caplog)\n    assert backtesting.strategy.dp._pairlists is not None\n    assert backtesting.strategy.bot_start.call_count == 1\n    assert backtesting.strategy.bot_loop_start.call_count == 0\n    assert sbs.call_count == 1\n    assert sbc.call_count == 1"
        ]
    },
    {
        "func_name": "get_timerange",
        "original": "def get_timerange(input1):\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
        "mutated": [
            "def get_timerange(input1):\n    if False:\n        i = 10\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
            "def get_timerange(input1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
            "def get_timerange(input1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
            "def get_timerange(input1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))",
            "def get_timerange(input1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))"
        ]
    },
    {
        "func_name": "test_backtesting_start_no_data",
        "original": "def test_backtesting_start_no_data(default_conf, mocker, caplog, testdatadir) -> None:\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    with pytest.raises(OperationalException, match='No data found. Terminating.'):\n        backtesting.start()",
        "mutated": [
            "def test_backtesting_start_no_data(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    with pytest.raises(OperationalException, match='No data found. Terminating.'):\n        backtesting.start()",
            "def test_backtesting_start_no_data(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    with pytest.raises(OperationalException, match='No data found. Terminating.'):\n        backtesting.start()",
            "def test_backtesting_start_no_data(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    with pytest.raises(OperationalException, match='No data found. Terminating.'):\n        backtesting.start()",
            "def test_backtesting_start_no_data(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    with pytest.raises(OperationalException, match='No data found. Terminating.'):\n        backtesting.start()",
            "def test_backtesting_start_no_data(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def get_timerange(input1):\n        return (dt_utc(2017, 11, 14, 21, 17), dt_utc(2017, 11, 14, 22, 59))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    with pytest.raises(OperationalException, match='No data found. Terminating.'):\n        backtesting.start()"
        ]
    },
    {
        "func_name": "test_backtesting_no_pair_left",
        "original": "def test_backtesting_no_pair_left(default_conf, mocker, caplog, testdatadir) -> None:\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=[]))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    with pytest.raises(OperationalException, match='No pair in whitelist.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf.update({'pairlists': [{'method': 'StaticPairList'}], 'timeframe_detail': '1d'})\n    with pytest.raises(OperationalException, match='Detail timeframe must be smaller than strategy timeframe.'):\n        Backtesting(default_conf)",
        "mutated": [
            "def test_backtesting_no_pair_left(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=[]))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    with pytest.raises(OperationalException, match='No pair in whitelist.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf.update({'pairlists': [{'method': 'StaticPairList'}], 'timeframe_detail': '1d'})\n    with pytest.raises(OperationalException, match='Detail timeframe must be smaller than strategy timeframe.'):\n        Backtesting(default_conf)",
            "def test_backtesting_no_pair_left(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=[]))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    with pytest.raises(OperationalException, match='No pair in whitelist.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf.update({'pairlists': [{'method': 'StaticPairList'}], 'timeframe_detail': '1d'})\n    with pytest.raises(OperationalException, match='Detail timeframe must be smaller than strategy timeframe.'):\n        Backtesting(default_conf)",
            "def test_backtesting_no_pair_left(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=[]))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    with pytest.raises(OperationalException, match='No pair in whitelist.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf.update({'pairlists': [{'method': 'StaticPairList'}], 'timeframe_detail': '1d'})\n    with pytest.raises(OperationalException, match='Detail timeframe must be smaller than strategy timeframe.'):\n        Backtesting(default_conf)",
            "def test_backtesting_no_pair_left(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=[]))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    with pytest.raises(OperationalException, match='No pair in whitelist.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf.update({'pairlists': [{'method': 'StaticPairList'}], 'timeframe_detail': '1d'})\n    with pytest.raises(OperationalException, match='Detail timeframe must be smaller than strategy timeframe.'):\n        Backtesting(default_conf)",
            "def test_backtesting_no_pair_left(default_conf, mocker, caplog, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch('freqtrade.data.history.history_utils.load_pair_history', MagicMock(return_value=pd.DataFrame()))\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=[]))\n    default_conf['timeframe'] = '1m'\n    default_conf['export'] = 'none'\n    default_conf['timerange'] = '20180101-20180102'\n    with pytest.raises(OperationalException, match='No pair in whitelist.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf.update({'pairlists': [{'method': 'StaticPairList'}], 'timeframe_detail': '1d'})\n    with pytest.raises(OperationalException, match='Detail timeframe must be smaller than strategy timeframe.'):\n        Backtesting(default_conf)"
        ]
    },
    {
        "func_name": "test_backtesting_pairlist_list",
        "original": "def test_backtesting_pairlist_list(default_conf, mocker, caplog, testdatadir, tickers) -> None:\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch(f'{EXMS}.get_tickers', tickers)\n    mocker.patch(f'{EXMS}.price_to_precision', lambda s, x, y: y)\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/BTC']))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.refresh_pairlist')\n    default_conf['ticker_interval'] = '1m'\n    default_conf['export'] = 'none'\n    del default_conf['stoploss']\n    default_conf['timerange'] = '20180101-20180102'\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PerformanceFilter'}]\n    with pytest.raises(OperationalException, match='PerformanceFilter not allowed for backtesting.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PrecisionFilter'}]\n    Backtesting(default_conf)\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    with pytest.raises(OperationalException, match='PrecisionFilter not allowed for backtesting multiple strategies.'):\n        Backtesting(default_conf)",
        "mutated": [
            "def test_backtesting_pairlist_list(default_conf, mocker, caplog, testdatadir, tickers) -> None:\n    if False:\n        i = 10\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch(f'{EXMS}.get_tickers', tickers)\n    mocker.patch(f'{EXMS}.price_to_precision', lambda s, x, y: y)\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/BTC']))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.refresh_pairlist')\n    default_conf['ticker_interval'] = '1m'\n    default_conf['export'] = 'none'\n    del default_conf['stoploss']\n    default_conf['timerange'] = '20180101-20180102'\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PerformanceFilter'}]\n    with pytest.raises(OperationalException, match='PerformanceFilter not allowed for backtesting.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PrecisionFilter'}]\n    Backtesting(default_conf)\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    with pytest.raises(OperationalException, match='PrecisionFilter not allowed for backtesting multiple strategies.'):\n        Backtesting(default_conf)",
            "def test_backtesting_pairlist_list(default_conf, mocker, caplog, testdatadir, tickers) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch(f'{EXMS}.get_tickers', tickers)\n    mocker.patch(f'{EXMS}.price_to_precision', lambda s, x, y: y)\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/BTC']))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.refresh_pairlist')\n    default_conf['ticker_interval'] = '1m'\n    default_conf['export'] = 'none'\n    del default_conf['stoploss']\n    default_conf['timerange'] = '20180101-20180102'\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PerformanceFilter'}]\n    with pytest.raises(OperationalException, match='PerformanceFilter not allowed for backtesting.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PrecisionFilter'}]\n    Backtesting(default_conf)\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    with pytest.raises(OperationalException, match='PrecisionFilter not allowed for backtesting multiple strategies.'):\n        Backtesting(default_conf)",
            "def test_backtesting_pairlist_list(default_conf, mocker, caplog, testdatadir, tickers) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch(f'{EXMS}.get_tickers', tickers)\n    mocker.patch(f'{EXMS}.price_to_precision', lambda s, x, y: y)\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/BTC']))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.refresh_pairlist')\n    default_conf['ticker_interval'] = '1m'\n    default_conf['export'] = 'none'\n    del default_conf['stoploss']\n    default_conf['timerange'] = '20180101-20180102'\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PerformanceFilter'}]\n    with pytest.raises(OperationalException, match='PerformanceFilter not allowed for backtesting.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PrecisionFilter'}]\n    Backtesting(default_conf)\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    with pytest.raises(OperationalException, match='PrecisionFilter not allowed for backtesting multiple strategies.'):\n        Backtesting(default_conf)",
            "def test_backtesting_pairlist_list(default_conf, mocker, caplog, testdatadir, tickers) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch(f'{EXMS}.get_tickers', tickers)\n    mocker.patch(f'{EXMS}.price_to_precision', lambda s, x, y: y)\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/BTC']))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.refresh_pairlist')\n    default_conf['ticker_interval'] = '1m'\n    default_conf['export'] = 'none'\n    del default_conf['stoploss']\n    default_conf['timerange'] = '20180101-20180102'\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PerformanceFilter'}]\n    with pytest.raises(OperationalException, match='PerformanceFilter not allowed for backtesting.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PrecisionFilter'}]\n    Backtesting(default_conf)\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    with pytest.raises(OperationalException, match='PrecisionFilter not allowed for backtesting multiple strategies.'):\n        Backtesting(default_conf)",
            "def test_backtesting_pairlist_list(default_conf, mocker, caplog, testdatadir, tickers) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mocker.patch(f'{EXMS}.exchange_has', MagicMock(return_value=True))\n    mocker.patch(f'{EXMS}.get_tickers', tickers)\n    mocker.patch(f'{EXMS}.price_to_precision', lambda s, x, y: y)\n    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/BTC']))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.refresh_pairlist')\n    default_conf['ticker_interval'] = '1m'\n    default_conf['export'] = 'none'\n    del default_conf['stoploss']\n    default_conf['timerange'] = '20180101-20180102'\n    default_conf['pairlists'] = [{'method': 'VolumePairList', 'number_assets': 5}]\n    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting\\\\..*StaticPairList.*'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PerformanceFilter'}]\n    with pytest.raises(OperationalException, match='PerformanceFilter not allowed for backtesting.'):\n        Backtesting(default_conf)\n    default_conf['pairlists'] = [{'method': 'StaticPairList'}, {'method': 'PrecisionFilter'}]\n    Backtesting(default_conf)\n    default_conf['strategy_list'] = [CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    with pytest.raises(OperationalException, match='PrecisionFilter not allowed for backtesting multiple strategies.'):\n        Backtesting(default_conf)"
        ]
    },
    {
        "func_name": "test_backtest__enter_trade",
        "original": "def test_backtest__enter_trade(default_conf, fee, mocker) -> None:\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['stake_amount'] = 'unlimited'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 1, 0.001, 0.0011, 0, 0.00099, 0.0012, '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    assert trade.stake_amount == 495\n    LocalTrade.trades_open.append(trade)\n    LocalTrade.trades_open.append(trade)\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    LocalTrade.trades_open.pop()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is not None\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 123.5\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 123.5\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 20 / 0\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is False\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is True\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=300.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 300.0",
        "mutated": [
            "def test_backtest__enter_trade(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['stake_amount'] = 'unlimited'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 1, 0.001, 0.0011, 0, 0.00099, 0.0012, '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    assert trade.stake_amount == 495\n    LocalTrade.trades_open.append(trade)\n    LocalTrade.trades_open.append(trade)\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    LocalTrade.trades_open.pop()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is not None\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 123.5\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 123.5\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 20 / 0\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is False\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is True\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=300.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 300.0",
            "def test_backtest__enter_trade(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['stake_amount'] = 'unlimited'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 1, 0.001, 0.0011, 0, 0.00099, 0.0012, '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    assert trade.stake_amount == 495\n    LocalTrade.trades_open.append(trade)\n    LocalTrade.trades_open.append(trade)\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    LocalTrade.trades_open.pop()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is not None\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 123.5\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 123.5\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 20 / 0\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is False\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is True\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=300.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 300.0",
            "def test_backtest__enter_trade(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['stake_amount'] = 'unlimited'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 1, 0.001, 0.0011, 0, 0.00099, 0.0012, '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    assert trade.stake_amount == 495\n    LocalTrade.trades_open.append(trade)\n    LocalTrade.trades_open.append(trade)\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    LocalTrade.trades_open.pop()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is not None\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 123.5\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 123.5\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 20 / 0\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is False\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is True\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=300.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 300.0",
            "def test_backtest__enter_trade(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['stake_amount'] = 'unlimited'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 1, 0.001, 0.0011, 0, 0.00099, 0.0012, '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    assert trade.stake_amount == 495\n    LocalTrade.trades_open.append(trade)\n    LocalTrade.trades_open.append(trade)\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    LocalTrade.trades_open.pop()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is not None\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 123.5\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 123.5\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 20 / 0\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is False\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is True\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=300.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 300.0",
            "def test_backtest__enter_trade(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['stake_amount'] = 'unlimited'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 1, 0.001, 0.0011, 0, 0.00099, 0.0012, '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    assert trade.stake_amount == 495\n    LocalTrade.trades_open.append(trade)\n    LocalTrade.trades_open.append(trade)\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    LocalTrade.trades_open.pop()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is not None\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 123.5\n    backtesting.wallets.update()\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 123.5\n    backtesting.strategy.custom_stake_amount = lambda **kwargs: 20 / 0\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is False\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert trade\n    assert trade.stake_amount == 495\n    assert trade.is_short is True\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=300.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade\n    assert trade.stake_amount == 300.0"
        ]
    },
    {
        "func_name": "test_backtest__enter_trade_futures",
        "original": "def test_backtest__enter_trade_futures(default_conf_usdt, fee, mocker) -> None:\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch('freqtrade.optimize.backtesting.price_to_precision', lambda p, *args: p)\n    patch_exchange(mocker)\n    default_conf_usdt['stake_amount'] = 300\n    default_conf_usdt['max_open_trades'] = 2\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['stake_currency'] = 'USDT'\n    default_conf_usdt['exchange']['pair_whitelist'] = ['.*']\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'ETH/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 0.1, 0.12, 0.099, 0.11, 1, 0, 1, 0, '', '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=5.0)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert pytest.approx(trade.liquidation_price) == 0.081767037\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert pytest.approx(trade.liquidation_price) == 0.11787191\n    assert pytest.approx(trade.orders[0].cost) == trade.stake_amount * trade.leverage + trade.fee_open\n    assert pytest.approx(trade.orders[-1].stake_amount) == trade.stake_amount\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=600.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    mocker.patch('freqtrade.wallets.Wallets.get_trade_stake_amount', side_effect=DependencyException)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None",
        "mutated": [
            "def test_backtest__enter_trade_futures(default_conf_usdt, fee, mocker) -> None:\n    if False:\n        i = 10\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch('freqtrade.optimize.backtesting.price_to_precision', lambda p, *args: p)\n    patch_exchange(mocker)\n    default_conf_usdt['stake_amount'] = 300\n    default_conf_usdt['max_open_trades'] = 2\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['stake_currency'] = 'USDT'\n    default_conf_usdt['exchange']['pair_whitelist'] = ['.*']\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'ETH/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 0.1, 0.12, 0.099, 0.11, 1, 0, 1, 0, '', '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=5.0)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert pytest.approx(trade.liquidation_price) == 0.081767037\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert pytest.approx(trade.liquidation_price) == 0.11787191\n    assert pytest.approx(trade.orders[0].cost) == trade.stake_amount * trade.leverage + trade.fee_open\n    assert pytest.approx(trade.orders[-1].stake_amount) == trade.stake_amount\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=600.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    mocker.patch('freqtrade.wallets.Wallets.get_trade_stake_amount', side_effect=DependencyException)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None",
            "def test_backtest__enter_trade_futures(default_conf_usdt, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch('freqtrade.optimize.backtesting.price_to_precision', lambda p, *args: p)\n    patch_exchange(mocker)\n    default_conf_usdt['stake_amount'] = 300\n    default_conf_usdt['max_open_trades'] = 2\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['stake_currency'] = 'USDT'\n    default_conf_usdt['exchange']['pair_whitelist'] = ['.*']\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'ETH/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 0.1, 0.12, 0.099, 0.11, 1, 0, 1, 0, '', '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=5.0)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert pytest.approx(trade.liquidation_price) == 0.081767037\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert pytest.approx(trade.liquidation_price) == 0.11787191\n    assert pytest.approx(trade.orders[0].cost) == trade.stake_amount * trade.leverage + trade.fee_open\n    assert pytest.approx(trade.orders[-1].stake_amount) == trade.stake_amount\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=600.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    mocker.patch('freqtrade.wallets.Wallets.get_trade_stake_amount', side_effect=DependencyException)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None",
            "def test_backtest__enter_trade_futures(default_conf_usdt, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch('freqtrade.optimize.backtesting.price_to_precision', lambda p, *args: p)\n    patch_exchange(mocker)\n    default_conf_usdt['stake_amount'] = 300\n    default_conf_usdt['max_open_trades'] = 2\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['stake_currency'] = 'USDT'\n    default_conf_usdt['exchange']['pair_whitelist'] = ['.*']\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'ETH/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 0.1, 0.12, 0.099, 0.11, 1, 0, 1, 0, '', '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=5.0)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert pytest.approx(trade.liquidation_price) == 0.081767037\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert pytest.approx(trade.liquidation_price) == 0.11787191\n    assert pytest.approx(trade.orders[0].cost) == trade.stake_amount * trade.leverage + trade.fee_open\n    assert pytest.approx(trade.orders[-1].stake_amount) == trade.stake_amount\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=600.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    mocker.patch('freqtrade.wallets.Wallets.get_trade_stake_amount', side_effect=DependencyException)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None",
            "def test_backtest__enter_trade_futures(default_conf_usdt, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch('freqtrade.optimize.backtesting.price_to_precision', lambda p, *args: p)\n    patch_exchange(mocker)\n    default_conf_usdt['stake_amount'] = 300\n    default_conf_usdt['max_open_trades'] = 2\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['stake_currency'] = 'USDT'\n    default_conf_usdt['exchange']['pair_whitelist'] = ['.*']\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'ETH/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 0.1, 0.12, 0.099, 0.11, 1, 0, 1, 0, '', '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=5.0)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert pytest.approx(trade.liquidation_price) == 0.081767037\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert pytest.approx(trade.liquidation_price) == 0.11787191\n    assert pytest.approx(trade.orders[0].cost) == trade.stake_amount * trade.leverage + trade.fee_open\n    assert pytest.approx(trade.orders[-1].stake_amount) == trade.stake_amount\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=600.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    mocker.patch('freqtrade.wallets.Wallets.get_trade_stake_amount', side_effect=DependencyException)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None",
            "def test_backtest__enter_trade_futures(default_conf_usdt, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch('freqtrade.optimize.backtesting.price_to_precision', lambda p, *args: p)\n    patch_exchange(mocker)\n    default_conf_usdt['stake_amount'] = 300\n    default_conf_usdt['max_open_trades'] = 2\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['stake_currency'] = 'USDT'\n    default_conf_usdt['exchange']['pair_whitelist'] = ['.*']\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'ETH/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 0.1, 0.12, 0.099, 0.11, 1, 0, 1, 0, '', '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=5.0)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert pytest.approx(trade.liquidation_price) == 0.081767037\n    trade = backtesting._enter_trade(pair, row=row, direction='short')\n    assert pytest.approx(trade.liquidation_price) == 0.11787191\n    assert pytest.approx(trade.orders[0].cost) == trade.stake_amount * trade.leverage + trade.fee_open\n    assert pytest.approx(trade.orders[-1].stake_amount) == trade.stake_amount\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=600.0)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None\n    mocker.patch('freqtrade.wallets.Wallets.get_trade_stake_amount', side_effect=DependencyException)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert trade is None"
        ]
    },
    {
        "func_name": "test_backtest__check_trade_exit",
        "original": "def test_backtest__check_trade_exit(default_conf, fee, mocker) -> None:\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['timeframe_detail'] = '1m'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=4, minute=55, tzinfo=timezone.utc), 200, 201.5, 195, 201, 1, 0, 0, 0, '', '', '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    row_sell = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0, tzinfo=timezone.utc), 200, 210.5, 195, 201, 0, 0, 0, 0, '', '', '']\n    res = backtesting._check_trade_exit(trade, row_sell, row_sell[0].to_pydatetime())\n    assert res is not None\n    assert res.exit_reason == ExitType.ROI.value\n    assert res.close_date_utc == datetime(2020, 1, 1, 5, 0, tzinfo=timezone.utc)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    backtesting.detail_data[pair] = pd.DataFrame([], columns=['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long', 'enter_short', 'exit_short', 'long_tag', 'short_tag', 'exit_tag'])\n    res = backtesting._check_trade_exit(trade, row, row[0].to_pydatetime())\n    assert res is None",
        "mutated": [
            "def test_backtest__check_trade_exit(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['timeframe_detail'] = '1m'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=4, minute=55, tzinfo=timezone.utc), 200, 201.5, 195, 201, 1, 0, 0, 0, '', '', '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    row_sell = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0, tzinfo=timezone.utc), 200, 210.5, 195, 201, 0, 0, 0, 0, '', '', '']\n    res = backtesting._check_trade_exit(trade, row_sell, row_sell[0].to_pydatetime())\n    assert res is not None\n    assert res.exit_reason == ExitType.ROI.value\n    assert res.close_date_utc == datetime(2020, 1, 1, 5, 0, tzinfo=timezone.utc)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    backtesting.detail_data[pair] = pd.DataFrame([], columns=['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long', 'enter_short', 'exit_short', 'long_tag', 'short_tag', 'exit_tag'])\n    res = backtesting._check_trade_exit(trade, row, row[0].to_pydatetime())\n    assert res is None",
            "def test_backtest__check_trade_exit(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['timeframe_detail'] = '1m'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=4, minute=55, tzinfo=timezone.utc), 200, 201.5, 195, 201, 1, 0, 0, 0, '', '', '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    row_sell = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0, tzinfo=timezone.utc), 200, 210.5, 195, 201, 0, 0, 0, 0, '', '', '']\n    res = backtesting._check_trade_exit(trade, row_sell, row_sell[0].to_pydatetime())\n    assert res is not None\n    assert res.exit_reason == ExitType.ROI.value\n    assert res.close_date_utc == datetime(2020, 1, 1, 5, 0, tzinfo=timezone.utc)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    backtesting.detail_data[pair] = pd.DataFrame([], columns=['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long', 'enter_short', 'exit_short', 'long_tag', 'short_tag', 'exit_tag'])\n    res = backtesting._check_trade_exit(trade, row, row[0].to_pydatetime())\n    assert res is None",
            "def test_backtest__check_trade_exit(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['timeframe_detail'] = '1m'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=4, minute=55, tzinfo=timezone.utc), 200, 201.5, 195, 201, 1, 0, 0, 0, '', '', '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    row_sell = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0, tzinfo=timezone.utc), 200, 210.5, 195, 201, 0, 0, 0, 0, '', '', '']\n    res = backtesting._check_trade_exit(trade, row_sell, row_sell[0].to_pydatetime())\n    assert res is not None\n    assert res.exit_reason == ExitType.ROI.value\n    assert res.close_date_utc == datetime(2020, 1, 1, 5, 0, tzinfo=timezone.utc)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    backtesting.detail_data[pair] = pd.DataFrame([], columns=['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long', 'enter_short', 'exit_short', 'long_tag', 'short_tag', 'exit_tag'])\n    res = backtesting._check_trade_exit(trade, row, row[0].to_pydatetime())\n    assert res is None",
            "def test_backtest__check_trade_exit(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['timeframe_detail'] = '1m'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=4, minute=55, tzinfo=timezone.utc), 200, 201.5, 195, 201, 1, 0, 0, 0, '', '', '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    row_sell = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0, tzinfo=timezone.utc), 200, 210.5, 195, 201, 0, 0, 0, 0, '', '', '']\n    res = backtesting._check_trade_exit(trade, row_sell, row_sell[0].to_pydatetime())\n    assert res is not None\n    assert res.exit_reason == ExitType.ROI.value\n    assert res.close_date_utc == datetime(2020, 1, 1, 5, 0, tzinfo=timezone.utc)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    backtesting.detail_data[pair] = pd.DataFrame([], columns=['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long', 'enter_short', 'exit_short', 'long_tag', 'short_tag', 'exit_tag'])\n    res = backtesting._check_trade_exit(trade, row, row[0].to_pydatetime())\n    assert res is None",
            "def test_backtest__check_trade_exit(default_conf, fee, mocker) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['timeframe_detail'] = '1m'\n    default_conf['max_open_trades'] = 2\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=4, minute=55, tzinfo=timezone.utc), 200, 201.5, 195, 201, 1, 0, 0, 0, '', '', '']\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    row_sell = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0, tzinfo=timezone.utc), 200, 210.5, 195, 201, 0, 0, 0, 0, '', '', '']\n    res = backtesting._check_trade_exit(trade, row_sell, row_sell[0].to_pydatetime())\n    assert res is not None\n    assert res.exit_reason == ExitType.ROI.value\n    assert res.close_date_utc == datetime(2020, 1, 1, 5, 0, tzinfo=timezone.utc)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    assert isinstance(trade, LocalTrade)\n    backtesting.detail_data[pair] = pd.DataFrame([], columns=['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long', 'enter_short', 'exit_short', 'long_tag', 'short_tag', 'exit_tag'])\n    res = backtesting._check_trade_exit(trade, row, row[0].to_pydatetime())\n    assert res is None"
        ]
    },
    {
        "func_name": "test_backtest_one",
        "original": "def test_backtest_one(default_conf, fee, mocker, testdatadir) -> None:\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [0.001, 0.001], 'max_stake_amount': [0.001, 0.001], 'amount': [0.00957442, 0.0097064], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 35, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [235, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10501, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000], 'orders': [[{'amount': 0.00957442, 'safe_price': 0.104445, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517251200000, 'ft_is_entry': True}, {'amount': 0.00957442, 'safe_price': 0.10496853383458644, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517265300000, 'ft_is_entry': False}], [{'amount': 0.0097064, 'safe_price': 0.10302485, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517283000000, 'ft_is_entry': True}, {'amount': 0.0097064, 'safe_price': 0.10354126528822055, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517285400000, 'ft_is_entry': False}]]})\n    pd.testing.assert_frame_equal(results, expected)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert not ln.empty\n        assert round(ln.iloc[0]['open'], 6) == round(t['open_rate'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln1.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln1.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln1.iloc[0]['high'], 6)",
        "mutated": [
            "def test_backtest_one(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [0.001, 0.001], 'max_stake_amount': [0.001, 0.001], 'amount': [0.00957442, 0.0097064], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 35, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [235, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10501, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000], 'orders': [[{'amount': 0.00957442, 'safe_price': 0.104445, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517251200000, 'ft_is_entry': True}, {'amount': 0.00957442, 'safe_price': 0.10496853383458644, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517265300000, 'ft_is_entry': False}], [{'amount': 0.0097064, 'safe_price': 0.10302485, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517283000000, 'ft_is_entry': True}, {'amount': 0.0097064, 'safe_price': 0.10354126528822055, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517285400000, 'ft_is_entry': False}]]})\n    pd.testing.assert_frame_equal(results, expected)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert not ln.empty\n        assert round(ln.iloc[0]['open'], 6) == round(t['open_rate'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln1.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln1.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln1.iloc[0]['high'], 6)",
            "def test_backtest_one(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [0.001, 0.001], 'max_stake_amount': [0.001, 0.001], 'amount': [0.00957442, 0.0097064], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 35, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [235, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10501, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000], 'orders': [[{'amount': 0.00957442, 'safe_price': 0.104445, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517251200000, 'ft_is_entry': True}, {'amount': 0.00957442, 'safe_price': 0.10496853383458644, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517265300000, 'ft_is_entry': False}], [{'amount': 0.0097064, 'safe_price': 0.10302485, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517283000000, 'ft_is_entry': True}, {'amount': 0.0097064, 'safe_price': 0.10354126528822055, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517285400000, 'ft_is_entry': False}]]})\n    pd.testing.assert_frame_equal(results, expected)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert not ln.empty\n        assert round(ln.iloc[0]['open'], 6) == round(t['open_rate'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln1.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln1.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln1.iloc[0]['high'], 6)",
            "def test_backtest_one(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [0.001, 0.001], 'max_stake_amount': [0.001, 0.001], 'amount': [0.00957442, 0.0097064], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 35, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [235, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10501, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000], 'orders': [[{'amount': 0.00957442, 'safe_price': 0.104445, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517251200000, 'ft_is_entry': True}, {'amount': 0.00957442, 'safe_price': 0.10496853383458644, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517265300000, 'ft_is_entry': False}], [{'amount': 0.0097064, 'safe_price': 0.10302485, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517283000000, 'ft_is_entry': True}, {'amount': 0.0097064, 'safe_price': 0.10354126528822055, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517285400000, 'ft_is_entry': False}]]})\n    pd.testing.assert_frame_equal(results, expected)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert not ln.empty\n        assert round(ln.iloc[0]['open'], 6) == round(t['open_rate'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln1.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln1.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln1.iloc[0]['high'], 6)",
            "def test_backtest_one(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [0.001, 0.001], 'max_stake_amount': [0.001, 0.001], 'amount': [0.00957442, 0.0097064], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 35, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [235, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10501, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000], 'orders': [[{'amount': 0.00957442, 'safe_price': 0.104445, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517251200000, 'ft_is_entry': True}, {'amount': 0.00957442, 'safe_price': 0.10496853383458644, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517265300000, 'ft_is_entry': False}], [{'amount': 0.0097064, 'safe_price': 0.10302485, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517283000000, 'ft_is_entry': True}, {'amount': 0.0097064, 'safe_price': 0.10354126528822055, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517285400000, 'ft_is_entry': False}]]})\n    pd.testing.assert_frame_equal(results, expected)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert not ln.empty\n        assert round(ln.iloc[0]['open'], 6) == round(t['open_rate'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln1.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln1.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln1.iloc[0]['high'], 6)",
            "def test_backtest_one(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [0.001, 0.001], 'max_stake_amount': [0.001, 0.001], 'amount': [0.00957442, 0.0097064], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 35, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [235, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10501, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000], 'orders': [[{'amount': 0.00957442, 'safe_price': 0.104445, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517251200000, 'ft_is_entry': True}, {'amount': 0.00957442, 'safe_price': 0.10496853383458644, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517265300000, 'ft_is_entry': False}], [{'amount': 0.0097064, 'safe_price': 0.10302485, 'ft_order_side': 'buy', 'order_filled_timestamp': 1517283000000, 'ft_is_entry': True}, {'amount': 0.0097064, 'safe_price': 0.10354126528822055, 'ft_order_side': 'sell', 'order_filled_timestamp': 1517285400000, 'ft_is_entry': False}]]})\n    pd.testing.assert_frame_equal(results, expected)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert not ln.empty\n        assert round(ln.iloc[0]['open'], 6) == round(t['open_rate'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln1.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln1.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln1.iloc[0]['high'], 6)"
        ]
    },
    {
        "func_name": "advise_entry",
        "original": "def advise_entry(df, *args, **kwargs):\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
        "mutated": [
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df"
        ]
    },
    {
        "func_name": "custom_entry_price",
        "original": "def custom_entry_price(proposed_rate, **kwargs):\n    return proposed_rate * 0.997",
        "mutated": [
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n    return proposed_rate * 0.997",
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return proposed_rate * 0.997",
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return proposed_rate * 0.997",
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return proposed_rate * 0.997",
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return proposed_rate * 0.997"
        ]
    },
    {
        "func_name": "test_backtest_one_detail",
        "original": "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '1m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/ETH'\n    timerange = TimeRange.parse_timerange('20191010-20191013')\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=[pair], timerange=timerange)\n    if use_detail:\n        data_1m = history.load_data(datadir=testdatadir, timeframe='1m', pairs=[pair], timerange=timerange)\n        backtesting.detail_data = data_1m\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (2 if use_detail else 3)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = data_1m[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert late_entry > 0",
        "mutated": [
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '1m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/ETH'\n    timerange = TimeRange.parse_timerange('20191010-20191013')\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=[pair], timerange=timerange)\n    if use_detail:\n        data_1m = history.load_data(datadir=testdatadir, timeframe='1m', pairs=[pair], timerange=timerange)\n        backtesting.detail_data = data_1m\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (2 if use_detail else 3)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = data_1m[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert late_entry > 0",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '1m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/ETH'\n    timerange = TimeRange.parse_timerange('20191010-20191013')\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=[pair], timerange=timerange)\n    if use_detail:\n        data_1m = history.load_data(datadir=testdatadir, timeframe='1m', pairs=[pair], timerange=timerange)\n        backtesting.detail_data = data_1m\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (2 if use_detail else 3)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = data_1m[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert late_entry > 0",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '1m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/ETH'\n    timerange = TimeRange.parse_timerange('20191010-20191013')\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=[pair], timerange=timerange)\n    if use_detail:\n        data_1m = history.load_data(datadir=testdatadir, timeframe='1m', pairs=[pair], timerange=timerange)\n        backtesting.detail_data = data_1m\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (2 if use_detail else 3)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = data_1m[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert late_entry > 0",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '1m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/ETH'\n    timerange = TimeRange.parse_timerange('20191010-20191013')\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=[pair], timerange=timerange)\n    if use_detail:\n        data_1m = history.load_data(datadir=testdatadir, timeframe='1m', pairs=[pair], timerange=timerange)\n        backtesting.detail_data = data_1m\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (2 if use_detail else 3)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = data_1m[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert late_entry > 0",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf_usdt['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '1m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/ETH'\n    timerange = TimeRange.parse_timerange('20191010-20191013')\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=[pair], timerange=timerange)\n    if use_detail:\n        data_1m = history.load_data(datadir=testdatadir, timeframe='1m', pairs=[pair], timerange=timerange)\n        backtesting.detail_data = data_1m\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (2 if use_detail else 3)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = data_1m[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert late_entry > 0"
        ]
    },
    {
        "func_name": "advise_entry",
        "original": "def advise_entry(df, *args, **kwargs):\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
        "mutated": [
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    df.loc[df['rsi'] < 40, 'enter_long'] = 1\n    return df"
        ]
    },
    {
        "func_name": "custom_entry_price",
        "original": "def custom_entry_price(proposed_rate, **kwargs):\n    return proposed_rate * 0.997",
        "mutated": [
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n    return proposed_rate * 0.997",
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return proposed_rate * 0.997",
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return proposed_rate * 0.997",
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return proposed_rate * 0.997",
            "def custom_entry_price(proposed_rate, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return proposed_rate * 0.997"
        ]
    },
    {
        "func_name": "test_backtest_one_detail_futures",
        "original": "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (5 if use_detail else 2)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = backtesting.detail_data[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert -0.0181 < Trade.trades[1].funding_fees < -0.01",
        "mutated": [
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (5 if use_detail else 2)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = backtesting.detail_data[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert -0.0181 < Trade.trades[1].funding_fees < -0.01",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (5 if use_detail else 2)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = backtesting.detail_data[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert -0.0181 < Trade.trades[1].funding_fees < -0.01",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (5 if use_detail else 2)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = backtesting.detail_data[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert -0.0181 < Trade.trades[1].funding_fees < -0.01",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (5 if use_detail else 2)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = backtesting.detail_data[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert -0.0181 < Trade.trades[1].funding_fees < -0.01",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[df['rsi'] < 40, 'enter_long'] = 1\n        return df\n\n    def custom_entry_price(proposed_rate, **kwargs):\n        return proposed_rate * 0.997\n    default_conf_usdt['max_open_trades'] = 10\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.custom_entry_price = custom_entry_price\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == (5 if use_detail else 2)\n    assert 'orders' in results.columns\n    data_pair = processed[pair]\n    data_1m_pair = backtesting.detail_data[pair] if use_detail else pd.DataFrame()\n    late_entry = 0\n    for (_, t) in results.iterrows():\n        assert len(t['orders']) == 2\n        entryo = t['orders'][0]\n        entry_ts = datetime.fromtimestamp(entryo['order_filled_timestamp'] // 1000, tz=timezone.utc)\n        if entry_ts > t['open_date']:\n            late_entry += 1\n        ln = data_1m_pair.loc[data_1m_pair['date'] == entry_ts] if use_detail else data_pair.loc[data_pair['date'] == entry_ts]\n        assert not ln.empty\n        assert round(ln.iloc[0]['low'], 6) <= round(t['open_rate'], 6) <= round(ln.iloc[0]['high'], 6)\n        ln1 = data_pair.loc[data_pair['date'] == t['close_date']]\n        if use_detail:\n            ln1_1m = data_1m_pair.loc[data_1m_pair['date'] == t['close_date']]\n            assert not ln1.empty or not ln1_1m.empty\n        else:\n            assert not ln1.empty\n        ln2 = ln1_1m if ln1.empty else ln1\n        assert round(ln2.iloc[0]['low'], 6) <= round(t['close_rate'], 6) <= round(ln2.iloc[0]['high'], 6)\n    assert -0.0181 < Trade.trades[1].funding_fees < -0.01"
        ]
    },
    {
        "func_name": "advise_entry",
        "original": "def advise_entry(df, *args, **kwargs):\n    df.loc[:, 'enter_long'] = 1\n    return df",
        "mutated": [
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n    df.loc[:, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    df.loc[:, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    df.loc[:, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    df.loc[:, 'enter_long'] = 1\n    return df",
            "def advise_entry(df, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    df.loc[:, 'enter_long'] = 1\n    return df"
        ]
    },
    {
        "func_name": "adjust_trade_position",
        "original": "def adjust_trade_position(trade, current_time, **kwargs):\n    if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n        return None\n    return default_conf_usdt['stake_amount']",
        "mutated": [
            "def adjust_trade_position(trade, current_time, **kwargs):\n    if False:\n        i = 10\n    if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n        return None\n    return default_conf_usdt['stake_amount']",
            "def adjust_trade_position(trade, current_time, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n        return None\n    return default_conf_usdt['stake_amount']",
            "def adjust_trade_position(trade, current_time, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n        return None\n    return default_conf_usdt['stake_amount']",
            "def adjust_trade_position(trade, current_time, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n        return None\n    return default_conf_usdt['stake_amount']",
            "def adjust_trade_position(trade, current_time, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n        return None\n    return default_conf_usdt['stake_amount']"
        ]
    },
    {
        "func_name": "test_backtest_one_detail_futures_funding_fees",
        "original": "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures_funding_fees(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    default_conf_usdt['minimal_roi'] = {'0': 1}\n    default_conf_usdt['dry_run_wallet'] = 100000\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[:, 'enter_long'] = 1\n        return df\n\n    def adjust_trade_position(trade, current_time, **kwargs):\n        if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n            return None\n        return default_conf_usdt['stake_amount']\n    default_conf_usdt['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.adjust_trade_position = adjust_trade_position\n    backtesting.strategy.leverage = lambda **kwargs: 1\n    backtesting.strategy.position_adjustment_enable = True\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 1\n    assert 'orders' in results.columns\n    for t in Trade.trades:\n        assert t.nr_of_successful_entries >= 6\n        assert -1.81 < t.funding_fees < -0.1",
        "mutated": [
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures_funding_fees(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    default_conf_usdt['minimal_roi'] = {'0': 1}\n    default_conf_usdt['dry_run_wallet'] = 100000\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[:, 'enter_long'] = 1\n        return df\n\n    def adjust_trade_position(trade, current_time, **kwargs):\n        if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n            return None\n        return default_conf_usdt['stake_amount']\n    default_conf_usdt['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.adjust_trade_position = adjust_trade_position\n    backtesting.strategy.leverage = lambda **kwargs: 1\n    backtesting.strategy.position_adjustment_enable = True\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 1\n    assert 'orders' in results.columns\n    for t in Trade.trades:\n        assert t.nr_of_successful_entries >= 6\n        assert -1.81 < t.funding_fees < -0.1",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures_funding_fees(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    default_conf_usdt['minimal_roi'] = {'0': 1}\n    default_conf_usdt['dry_run_wallet'] = 100000\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[:, 'enter_long'] = 1\n        return df\n\n    def adjust_trade_position(trade, current_time, **kwargs):\n        if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n            return None\n        return default_conf_usdt['stake_amount']\n    default_conf_usdt['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.adjust_trade_position = adjust_trade_position\n    backtesting.strategy.leverage = lambda **kwargs: 1\n    backtesting.strategy.position_adjustment_enable = True\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 1\n    assert 'orders' in results.columns\n    for t in Trade.trades:\n        assert t.nr_of_successful_entries >= 6\n        assert -1.81 < t.funding_fees < -0.1",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures_funding_fees(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    default_conf_usdt['minimal_roi'] = {'0': 1}\n    default_conf_usdt['dry_run_wallet'] = 100000\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[:, 'enter_long'] = 1\n        return df\n\n    def adjust_trade_position(trade, current_time, **kwargs):\n        if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n            return None\n        return default_conf_usdt['stake_amount']\n    default_conf_usdt['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.adjust_trade_position = adjust_trade_position\n    backtesting.strategy.leverage = lambda **kwargs: 1\n    backtesting.strategy.position_adjustment_enable = True\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 1\n    assert 'orders' in results.columns\n    for t in Trade.trades:\n        assert t.nr_of_successful_entries >= 6\n        assert -1.81 < t.funding_fees < -0.1",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures_funding_fees(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    default_conf_usdt['minimal_roi'] = {'0': 1}\n    default_conf_usdt['dry_run_wallet'] = 100000\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[:, 'enter_long'] = 1\n        return df\n\n    def adjust_trade_position(trade, current_time, **kwargs):\n        if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n            return None\n        return default_conf_usdt['stake_amount']\n    default_conf_usdt['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.adjust_trade_position = adjust_trade_position\n    backtesting.strategy.leverage = lambda **kwargs: 1\n    backtesting.strategy.position_adjustment_enable = True\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 1\n    assert 'orders' in results.columns\n    for t in Trade.trades:\n        assert t.nr_of_successful_entries >= 6\n        assert -1.81 < t.funding_fees < -0.1",
            "@pytest.mark.parametrize('use_detail', [True, False])\ndef test_backtest_one_detail_futures_funding_fees(default_conf_usdt, fee, mocker, testdatadir, use_detail) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf_usdt['use_exit_signal'] = False\n    default_conf_usdt['trading_mode'] = 'futures'\n    default_conf_usdt['margin_mode'] = 'isolated'\n    default_conf_usdt['candle_type_def'] = CandleType.FUTURES\n    default_conf_usdt['minimal_roi'] = {'0': 1}\n    default_conf_usdt['dry_run_wallet'] = 100000\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.01, 0.01))\n    default_conf_usdt['timeframe'] = '1h'\n    if use_detail:\n        default_conf_usdt['timeframe_detail'] = '5m'\n    patch_exchange(mocker)\n\n    def advise_entry(df, *args, **kwargs):\n        df.loc[:, 'enter_long'] = 1\n        return df\n\n    def adjust_trade_position(trade, current_time, **kwargs):\n        if current_time > datetime(2021, 11, 18, 2, 0, 0, tzinfo=timezone.utc):\n            return None\n        return default_conf_usdt['stake_amount']\n    default_conf_usdt['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf_usdt)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.populate_entry_trend = advise_entry\n    backtesting.strategy.adjust_trade_position = adjust_trade_position\n    backtesting.strategy.leverage = lambda **kwargs: 1\n    backtesting.strategy.position_adjustment_enable = True\n    pair = 'XRP/USDT:USDT'\n    timerange = TimeRange.parse_timerange('20211117-20211119')\n    data = history.load_data(datadir=Path(testdatadir), timeframe='1h', pairs=[pair], timerange=timerange, candle_type=CandleType.FUTURES)\n    backtesting.load_bt_data_detail()\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 1\n    assert 'orders' in results.columns\n    for t in Trade.trades:\n        assert t.nr_of_successful_entries >= 6\n        assert -1.81 < t.funding_fees < -0.1"
        ]
    },
    {
        "func_name": "test_backtest_timedout_entry_orders",
        "original": "def test_backtest_timedout_entry_orders(default_conf, fee, mocker, testdatadir) -> None:\n    default_conf['strategy'] = 'StrategyTestV3CustomEntryPrice'\n    default_conf['startup_candle_count'] = 0\n    default_conf['unfilledtimeout'] = {'entry': 4}\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', 'date', 1517227800, 1517231100)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    (min_date, max_date) = get_timerange(data)\n    result = backtesting.backtest(processed=deepcopy(data), start_date=min_date, end_date=max_date)\n    assert result['timedout_entry_orders'] == 10",
        "mutated": [
            "def test_backtest_timedout_entry_orders(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    default_conf['strategy'] = 'StrategyTestV3CustomEntryPrice'\n    default_conf['startup_candle_count'] = 0\n    default_conf['unfilledtimeout'] = {'entry': 4}\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', 'date', 1517227800, 1517231100)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    (min_date, max_date) = get_timerange(data)\n    result = backtesting.backtest(processed=deepcopy(data), start_date=min_date, end_date=max_date)\n    assert result['timedout_entry_orders'] == 10",
            "def test_backtest_timedout_entry_orders(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['strategy'] = 'StrategyTestV3CustomEntryPrice'\n    default_conf['startup_candle_count'] = 0\n    default_conf['unfilledtimeout'] = {'entry': 4}\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', 'date', 1517227800, 1517231100)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    (min_date, max_date) = get_timerange(data)\n    result = backtesting.backtest(processed=deepcopy(data), start_date=min_date, end_date=max_date)\n    assert result['timedout_entry_orders'] == 10",
            "def test_backtest_timedout_entry_orders(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['strategy'] = 'StrategyTestV3CustomEntryPrice'\n    default_conf['startup_candle_count'] = 0\n    default_conf['unfilledtimeout'] = {'entry': 4}\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', 'date', 1517227800, 1517231100)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    (min_date, max_date) = get_timerange(data)\n    result = backtesting.backtest(processed=deepcopy(data), start_date=min_date, end_date=max_date)\n    assert result['timedout_entry_orders'] == 10",
            "def test_backtest_timedout_entry_orders(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['strategy'] = 'StrategyTestV3CustomEntryPrice'\n    default_conf['startup_candle_count'] = 0\n    default_conf['unfilledtimeout'] = {'entry': 4}\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', 'date', 1517227800, 1517231100)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    (min_date, max_date) = get_timerange(data)\n    result = backtesting.backtest(processed=deepcopy(data), start_date=min_date, end_date=max_date)\n    assert result['timedout_entry_orders'] == 10",
            "def test_backtest_timedout_entry_orders(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['strategy'] = 'StrategyTestV3CustomEntryPrice'\n    default_conf['startup_candle_count'] = 0\n    default_conf['unfilledtimeout'] = {'entry': 4}\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf['max_open_trades'] = 1\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', 'date', 1517227800, 1517231100)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    (min_date, max_date) = get_timerange(data)\n    result = backtesting.backtest(processed=deepcopy(data), start_date=min_date, end_date=max_date)\n    assert result['timedout_entry_orders'] == 10"
        ]
    },
    {
        "func_name": "test_backtest_1min_timeframe",
        "original": "def test_backtest_1min_timeframe(default_conf, fee, mocker, testdatadir) -> None:\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    data = history.load_data(datadir=testdatadir, timeframe='1m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert not results['results'].empty\n    assert len(results['results']) == 1",
        "mutated": [
            "def test_backtest_1min_timeframe(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    data = history.load_data(datadir=testdatadir, timeframe='1m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert not results['results'].empty\n    assert len(results['results']) == 1",
            "def test_backtest_1min_timeframe(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    data = history.load_data(datadir=testdatadir, timeframe='1m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert not results['results'].empty\n    assert len(results['results']) == 1",
            "def test_backtest_1min_timeframe(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    data = history.load_data(datadir=testdatadir, timeframe='1m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert not results['results'].empty\n    assert len(results['results']) == 1",
            "def test_backtest_1min_timeframe(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    data = history.load_data(datadir=testdatadir, timeframe='1m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert not results['results'].empty\n    assert len(results['results']) == 1",
            "def test_backtest_1min_timeframe(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    data = history.load_data(datadir=testdatadir, timeframe='1m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert not results['results'].empty\n    assert len(results['results']) == 1"
        ]
    },
    {
        "func_name": "test_backtest_trim_no_data_left",
        "original": "def test_backtest_trim_no_data_left(default_conf, fee, mocker, testdatadir) -> None:\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    backtesting.required_startup = 100\n    backtesting.timerange = timerange\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    df = data['UNITTEST/BTC']\n    df['date'] = df.loc[:, 'date'] - timedelta(days=1)\n    df = df.iloc[:100]\n    data['XRP/USDT'] = df\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)",
        "mutated": [
            "def test_backtest_trim_no_data_left(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    backtesting.required_startup = 100\n    backtesting.timerange = timerange\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    df = data['UNITTEST/BTC']\n    df['date'] = df.loc[:, 'date'] - timedelta(days=1)\n    df = df.iloc[:100]\n    data['XRP/USDT'] = df\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)",
            "def test_backtest_trim_no_data_left(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    backtesting.required_startup = 100\n    backtesting.timerange = timerange\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    df = data['UNITTEST/BTC']\n    df['date'] = df.loc[:, 'date'] - timedelta(days=1)\n    df = df.iloc[:100]\n    data['XRP/USDT'] = df\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)",
            "def test_backtest_trim_no_data_left(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    backtesting.required_startup = 100\n    backtesting.timerange = timerange\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    df = data['UNITTEST/BTC']\n    df['date'] = df.loc[:, 'date'] - timedelta(days=1)\n    df = df.iloc[:100]\n    data['XRP/USDT'] = df\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)",
            "def test_backtest_trim_no_data_left(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    backtesting.required_startup = 100\n    backtesting.timerange = timerange\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    df = data['UNITTEST/BTC']\n    df['date'] = df.loc[:, 'date'] - timedelta(days=1)\n    df = df.iloc[:100]\n    data['XRP/USDT'] = df\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)",
            "def test_backtest_trim_no_data_left(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    backtesting.required_startup = 100\n    backtesting.timerange = timerange\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    df = data['UNITTEST/BTC']\n    df['date'] = df.loc[:, 'date'] - timedelta(days=1)\n    df = df.iloc[:100]\n    data['XRP/USDT'] = df\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)"
        ]
    },
    {
        "func_name": "test_processed",
        "original": "def test_processed(default_conf, mocker, testdatadir) -> None:\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    dict_of_tickerrows = load_data_test('raise', testdatadir)\n    dataframes = backtesting.strategy.advise_all_indicators(dict_of_tickerrows)\n    dataframe = dataframes['UNITTEST/BTC']\n    cols = dataframe.columns\n    for col in ['close', 'high', 'low', 'open', 'date', 'ema10', 'rsi', 'fastd', 'plus_di']:\n        assert col in cols",
        "mutated": [
            "def test_processed(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    dict_of_tickerrows = load_data_test('raise', testdatadir)\n    dataframes = backtesting.strategy.advise_all_indicators(dict_of_tickerrows)\n    dataframe = dataframes['UNITTEST/BTC']\n    cols = dataframe.columns\n    for col in ['close', 'high', 'low', 'open', 'date', 'ema10', 'rsi', 'fastd', 'plus_di']:\n        assert col in cols",
            "def test_processed(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    dict_of_tickerrows = load_data_test('raise', testdatadir)\n    dataframes = backtesting.strategy.advise_all_indicators(dict_of_tickerrows)\n    dataframe = dataframes['UNITTEST/BTC']\n    cols = dataframe.columns\n    for col in ['close', 'high', 'low', 'open', 'date', 'ema10', 'rsi', 'fastd', 'plus_di']:\n        assert col in cols",
            "def test_processed(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    dict_of_tickerrows = load_data_test('raise', testdatadir)\n    dataframes = backtesting.strategy.advise_all_indicators(dict_of_tickerrows)\n    dataframe = dataframes['UNITTEST/BTC']\n    cols = dataframe.columns\n    for col in ['close', 'high', 'low', 'open', 'date', 'ema10', 'rsi', 'fastd', 'plus_di']:\n        assert col in cols",
            "def test_processed(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    dict_of_tickerrows = load_data_test('raise', testdatadir)\n    dataframes = backtesting.strategy.advise_all_indicators(dict_of_tickerrows)\n    dataframe = dataframes['UNITTEST/BTC']\n    cols = dataframe.columns\n    for col in ['close', 'high', 'low', 'open', 'date', 'ema10', 'rsi', 'fastd', 'plus_di']:\n        assert col in cols",
            "def test_processed(default_conf, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    dict_of_tickerrows = load_data_test('raise', testdatadir)\n    dataframes = backtesting.strategy.advise_all_indicators(dict_of_tickerrows)\n    dataframe = dataframes['UNITTEST/BTC']\n    cols = dataframe.columns\n    for col in ['close', 'high', 'low', 'open', 'date', 'ema10', 'rsi', 'fastd', 'plus_di']:\n        assert col in cols"
        ]
    },
    {
        "func_name": "tmp_confirm_entry",
        "original": "def tmp_confirm_entry(pair, current_time, **kwargs):\n    nonlocal count\n    dp = backtesting.strategy.dp\n    (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n    current_candle = df.iloc[-1].squeeze()\n    assert current_candle['enter_long'] == 1\n    candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n    assert candle_date == current_time\n    df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n    prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n    assert prior_time == df.iloc[-1].squeeze()['date']\n    assert df.iloc[-1].squeeze()['date'] < current_time\n    count += 1",
        "mutated": [
            "def tmp_confirm_entry(pair, current_time, **kwargs):\n    if False:\n        i = 10\n    nonlocal count\n    dp = backtesting.strategy.dp\n    (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n    current_candle = df.iloc[-1].squeeze()\n    assert current_candle['enter_long'] == 1\n    candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n    assert candle_date == current_time\n    df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n    prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n    assert prior_time == df.iloc[-1].squeeze()['date']\n    assert df.iloc[-1].squeeze()['date'] < current_time\n    count += 1",
            "def tmp_confirm_entry(pair, current_time, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nonlocal count\n    dp = backtesting.strategy.dp\n    (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n    current_candle = df.iloc[-1].squeeze()\n    assert current_candle['enter_long'] == 1\n    candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n    assert candle_date == current_time\n    df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n    prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n    assert prior_time == df.iloc[-1].squeeze()['date']\n    assert df.iloc[-1].squeeze()['date'] < current_time\n    count += 1",
            "def tmp_confirm_entry(pair, current_time, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nonlocal count\n    dp = backtesting.strategy.dp\n    (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n    current_candle = df.iloc[-1].squeeze()\n    assert current_candle['enter_long'] == 1\n    candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n    assert candle_date == current_time\n    df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n    prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n    assert prior_time == df.iloc[-1].squeeze()['date']\n    assert df.iloc[-1].squeeze()['date'] < current_time\n    count += 1",
            "def tmp_confirm_entry(pair, current_time, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nonlocal count\n    dp = backtesting.strategy.dp\n    (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n    current_candle = df.iloc[-1].squeeze()\n    assert current_candle['enter_long'] == 1\n    candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n    assert candle_date == current_time\n    df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n    prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n    assert prior_time == df.iloc[-1].squeeze()['date']\n    assert df.iloc[-1].squeeze()['date'] < current_time\n    count += 1",
            "def tmp_confirm_entry(pair, current_time, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nonlocal count\n    dp = backtesting.strategy.dp\n    (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n    current_candle = df.iloc[-1].squeeze()\n    assert current_candle['enter_long'] == 1\n    candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n    assert candle_date == current_time\n    df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n    prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n    assert prior_time == df.iloc[-1].squeeze()['date']\n    assert df.iloc[-1].squeeze()['date'] < current_time\n    count += 1"
        ]
    },
    {
        "func_name": "test_backtest_dataprovider_analyzed_df",
        "original": "def test_backtest_dataprovider_analyzed_df(default_conf, fee, mocker, testdatadir) -> None:\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=100000)\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    count = 0\n\n    def tmp_confirm_entry(pair, current_time, **kwargs):\n        nonlocal count\n        dp = backtesting.strategy.dp\n        (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n        current_candle = df.iloc[-1].squeeze()\n        assert current_candle['enter_long'] == 1\n        candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n        assert candle_date == current_time\n        df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n        prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n        assert prior_time == df.iloc[-1].squeeze()['date']\n        assert df.iloc[-1].squeeze()['date'] < current_time\n        count += 1\n    backtesting.strategy.confirm_trade_entry = tmp_confirm_entry\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    assert count == 5",
        "mutated": [
            "def test_backtest_dataprovider_analyzed_df(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=100000)\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    count = 0\n\n    def tmp_confirm_entry(pair, current_time, **kwargs):\n        nonlocal count\n        dp = backtesting.strategy.dp\n        (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n        current_candle = df.iloc[-1].squeeze()\n        assert current_candle['enter_long'] == 1\n        candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n        assert candle_date == current_time\n        df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n        prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n        assert prior_time == df.iloc[-1].squeeze()['date']\n        assert df.iloc[-1].squeeze()['date'] < current_time\n        count += 1\n    backtesting.strategy.confirm_trade_entry = tmp_confirm_entry\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    assert count == 5",
            "def test_backtest_dataprovider_analyzed_df(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=100000)\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    count = 0\n\n    def tmp_confirm_entry(pair, current_time, **kwargs):\n        nonlocal count\n        dp = backtesting.strategy.dp\n        (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n        current_candle = df.iloc[-1].squeeze()\n        assert current_candle['enter_long'] == 1\n        candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n        assert candle_date == current_time\n        df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n        prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n        assert prior_time == df.iloc[-1].squeeze()['date']\n        assert df.iloc[-1].squeeze()['date'] < current_time\n        count += 1\n    backtesting.strategy.confirm_trade_entry = tmp_confirm_entry\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    assert count == 5",
            "def test_backtest_dataprovider_analyzed_df(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=100000)\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    count = 0\n\n    def tmp_confirm_entry(pair, current_time, **kwargs):\n        nonlocal count\n        dp = backtesting.strategy.dp\n        (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n        current_candle = df.iloc[-1].squeeze()\n        assert current_candle['enter_long'] == 1\n        candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n        assert candle_date == current_time\n        df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n        prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n        assert prior_time == df.iloc[-1].squeeze()['date']\n        assert df.iloc[-1].squeeze()['date'] < current_time\n        count += 1\n    backtesting.strategy.confirm_trade_entry = tmp_confirm_entry\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    assert count == 5",
            "def test_backtest_dataprovider_analyzed_df(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=100000)\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    count = 0\n\n    def tmp_confirm_entry(pair, current_time, **kwargs):\n        nonlocal count\n        dp = backtesting.strategy.dp\n        (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n        current_candle = df.iloc[-1].squeeze()\n        assert current_candle['enter_long'] == 1\n        candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n        assert candle_date == current_time\n        df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n        prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n        assert prior_time == df.iloc[-1].squeeze()['date']\n        assert df.iloc[-1].squeeze()['date'] < current_time\n        count += 1\n    backtesting.strategy.confirm_trade_entry = tmp_confirm_entry\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    assert count == 5",
            "def test_backtest_dataprovider_analyzed_df(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=100000)\n    patch_exchange(mocker)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    count = 0\n\n    def tmp_confirm_entry(pair, current_time, **kwargs):\n        nonlocal count\n        dp = backtesting.strategy.dp\n        (df, _) = dp.get_analyzed_dataframe(pair, backtesting.strategy.timeframe)\n        current_candle = df.iloc[-1].squeeze()\n        assert current_candle['enter_long'] == 1\n        candle_date = timeframe_to_next_date(backtesting.strategy.timeframe, current_candle['date'])\n        assert candle_date == current_time\n        df = dp.get_pair_dataframe(pair, backtesting.strategy.timeframe)\n        prior_time = timeframe_to_prev_date(backtesting.strategy.timeframe, candle_date - timedelta(seconds=1))\n        assert prior_time == df.iloc[-1].squeeze()['date']\n        assert df.iloc[-1].squeeze()['date'] < current_time\n        count += 1\n    backtesting.strategy.confirm_trade_entry = tmp_confirm_entry\n    backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    assert count == 5"
        ]
    },
    {
        "func_name": "test_backtest_pricecontours_protections",
        "original": "def test_backtest_pricecontours_protections(default_conf, fee, mocker, testdatadir) -> None:\n    patch_exchange(mocker)\n    default_conf['protections'] = [{'method': 'CooldownPeriod', 'stop_duration': 3}]\n    default_conf['enable_protections'] = True\n    default_conf['timeframe'] = '1m'\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    tests = [['sine', 9], ['raise', 10], ['lower', 0], ['sine', 9], ['raise', 10]]\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    for [contour, numres] in tests:\n        print(f'{contour}, {numres}')\n        data = load_data_test(contour, testdatadir)\n        processed = backtesting.strategy.advise_all_indicators(data)\n        (min_date, max_date) = get_timerange(processed)\n        assert isinstance(processed, dict)\n        results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n        assert len(results['results']) == numres",
        "mutated": [
            "def test_backtest_pricecontours_protections(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    patch_exchange(mocker)\n    default_conf['protections'] = [{'method': 'CooldownPeriod', 'stop_duration': 3}]\n    default_conf['enable_protections'] = True\n    default_conf['timeframe'] = '1m'\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    tests = [['sine', 9], ['raise', 10], ['lower', 0], ['sine', 9], ['raise', 10]]\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    for [contour, numres] in tests:\n        print(f'{contour}, {numres}')\n        data = load_data_test(contour, testdatadir)\n        processed = backtesting.strategy.advise_all_indicators(data)\n        (min_date, max_date) = get_timerange(processed)\n        assert isinstance(processed, dict)\n        results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n        assert len(results['results']) == numres",
            "def test_backtest_pricecontours_protections(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patch_exchange(mocker)\n    default_conf['protections'] = [{'method': 'CooldownPeriod', 'stop_duration': 3}]\n    default_conf['enable_protections'] = True\n    default_conf['timeframe'] = '1m'\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    tests = [['sine', 9], ['raise', 10], ['lower', 0], ['sine', 9], ['raise', 10]]\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    for [contour, numres] in tests:\n        print(f'{contour}, {numres}')\n        data = load_data_test(contour, testdatadir)\n        processed = backtesting.strategy.advise_all_indicators(data)\n        (min_date, max_date) = get_timerange(processed)\n        assert isinstance(processed, dict)\n        results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n        assert len(results['results']) == numres",
            "def test_backtest_pricecontours_protections(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patch_exchange(mocker)\n    default_conf['protections'] = [{'method': 'CooldownPeriod', 'stop_duration': 3}]\n    default_conf['enable_protections'] = True\n    default_conf['timeframe'] = '1m'\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    tests = [['sine', 9], ['raise', 10], ['lower', 0], ['sine', 9], ['raise', 10]]\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    for [contour, numres] in tests:\n        print(f'{contour}, {numres}')\n        data = load_data_test(contour, testdatadir)\n        processed = backtesting.strategy.advise_all_indicators(data)\n        (min_date, max_date) = get_timerange(processed)\n        assert isinstance(processed, dict)\n        results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n        assert len(results['results']) == numres",
            "def test_backtest_pricecontours_protections(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patch_exchange(mocker)\n    default_conf['protections'] = [{'method': 'CooldownPeriod', 'stop_duration': 3}]\n    default_conf['enable_protections'] = True\n    default_conf['timeframe'] = '1m'\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    tests = [['sine', 9], ['raise', 10], ['lower', 0], ['sine', 9], ['raise', 10]]\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    for [contour, numres] in tests:\n        print(f'{contour}, {numres}')\n        data = load_data_test(contour, testdatadir)\n        processed = backtesting.strategy.advise_all_indicators(data)\n        (min_date, max_date) = get_timerange(processed)\n        assert isinstance(processed, dict)\n        results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n        assert len(results['results']) == numres",
            "def test_backtest_pricecontours_protections(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patch_exchange(mocker)\n    default_conf['protections'] = [{'method': 'CooldownPeriod', 'stop_duration': 3}]\n    default_conf['enable_protections'] = True\n    default_conf['timeframe'] = '1m'\n    default_conf['max_open_trades'] = 1\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    tests = [['sine', 9], ['raise', 10], ['lower', 0], ['sine', 9], ['raise', 10]]\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    for [contour, numres] in tests:\n        print(f'{contour}, {numres}')\n        data = load_data_test(contour, testdatadir)\n        processed = backtesting.strategy.advise_all_indicators(data)\n        (min_date, max_date) = get_timerange(processed)\n        assert isinstance(processed, dict)\n        results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n        assert len(results['results']) == numres"
        ]
    },
    {
        "func_name": "test_backtest_pricecontours",
        "original": "@pytest.mark.parametrize('protections,contour,expected', [(None, 'sine', 35), (None, 'raise', 19), (None, 'lower', 0), (None, 'sine', 35), (None, 'raise', 19), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'lower', 0), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10)])\ndef test_backtest_pricecontours(default_conf, fee, mocker, testdatadir, protections, contour, expected) -> None:\n    if protections:\n        default_conf['protections'] = protections\n        default_conf['enable_protections'] = True\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    data = load_data_test(contour, testdatadir)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    assert isinstance(processed, dict)\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert len(results['results']) == expected",
        "mutated": [
            "@pytest.mark.parametrize('protections,contour,expected', [(None, 'sine', 35), (None, 'raise', 19), (None, 'lower', 0), (None, 'sine', 35), (None, 'raise', 19), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'lower', 0), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10)])\ndef test_backtest_pricecontours(default_conf, fee, mocker, testdatadir, protections, contour, expected) -> None:\n    if False:\n        i = 10\n    if protections:\n        default_conf['protections'] = protections\n        default_conf['enable_protections'] = True\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    data = load_data_test(contour, testdatadir)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    assert isinstance(processed, dict)\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert len(results['results']) == expected",
            "@pytest.mark.parametrize('protections,contour,expected', [(None, 'sine', 35), (None, 'raise', 19), (None, 'lower', 0), (None, 'sine', 35), (None, 'raise', 19), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'lower', 0), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10)])\ndef test_backtest_pricecontours(default_conf, fee, mocker, testdatadir, protections, contour, expected) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if protections:\n        default_conf['protections'] = protections\n        default_conf['enable_protections'] = True\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    data = load_data_test(contour, testdatadir)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    assert isinstance(processed, dict)\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert len(results['results']) == expected",
            "@pytest.mark.parametrize('protections,contour,expected', [(None, 'sine', 35), (None, 'raise', 19), (None, 'lower', 0), (None, 'sine', 35), (None, 'raise', 19), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'lower', 0), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10)])\ndef test_backtest_pricecontours(default_conf, fee, mocker, testdatadir, protections, contour, expected) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if protections:\n        default_conf['protections'] = protections\n        default_conf['enable_protections'] = True\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    data = load_data_test(contour, testdatadir)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    assert isinstance(processed, dict)\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert len(results['results']) == expected",
            "@pytest.mark.parametrize('protections,contour,expected', [(None, 'sine', 35), (None, 'raise', 19), (None, 'lower', 0), (None, 'sine', 35), (None, 'raise', 19), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'lower', 0), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10)])\ndef test_backtest_pricecontours(default_conf, fee, mocker, testdatadir, protections, contour, expected) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if protections:\n        default_conf['protections'] = protections\n        default_conf['enable_protections'] = True\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    data = load_data_test(contour, testdatadir)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    assert isinstance(processed, dict)\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert len(results['results']) == expected",
            "@pytest.mark.parametrize('protections,contour,expected', [(None, 'sine', 35), (None, 'raise', 19), (None, 'lower', 0), (None, 'sine', 35), (None, 'raise', 19), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'lower', 0), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'sine', 9), ([{'method': 'CooldownPeriod', 'stop_duration': 3}], 'raise', 10)])\ndef test_backtest_pricecontours(default_conf, fee, mocker, testdatadir, protections, contour, expected) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if protections:\n        default_conf['protections'] = protections\n        default_conf['enable_protections'] = True\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    data = load_data_test(contour, testdatadir)\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    assert isinstance(processed, dict)\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    results = backtesting.backtest(processed=processed, start_date=min_date, end_date=max_date)\n    assert len(results['results']) == expected"
        ]
    },
    {
        "func_name": "fun",
        "original": "def fun(dataframe=None, pair=None):\n    buy_value = 1\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
        "mutated": [
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n    buy_value = 1\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    buy_value = 1\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    buy_value = 1\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    buy_value = 1\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    buy_value = 1\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)"
        ]
    },
    {
        "func_name": "test_backtest_clash_buy_sell",
        "original": "def test_backtest_clash_buy_sell(mocker, default_conf, testdatadir):\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 1\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
        "mutated": [
            "def test_backtest_clash_buy_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 1\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
            "def test_backtest_clash_buy_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 1\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
            "def test_backtest_clash_buy_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 1\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
            "def test_backtest_clash_buy_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 1\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
            "def test_backtest_clash_buy_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 1\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty"
        ]
    },
    {
        "func_name": "fun",
        "original": "def fun(dataframe=None, pair=None):\n    buy_value = 0\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
        "mutated": [
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n    buy_value = 0\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    buy_value = 0\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    buy_value = 0\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    buy_value = 0\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)",
            "def fun(dataframe=None, pair=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    buy_value = 0\n    sell_value = 1\n    return _trend(dataframe, buy_value, sell_value)"
        ]
    },
    {
        "func_name": "test_backtest_only_sell",
        "original": "def test_backtest_only_sell(mocker, default_conf, testdatadir):\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 0\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
        "mutated": [
            "def test_backtest_only_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 0\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
            "def test_backtest_only_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 0\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
            "def test_backtest_only_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 0\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
            "def test_backtest_only_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 0\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty",
            "def test_backtest_only_sell(mocker, default_conf, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def fun(dataframe=None, pair=None):\n        buy_value = 0\n        sell_value = 1\n        return _trend(dataframe, buy_value, sell_value)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = fun\n    backtesting.strategy.advise_exit = fun\n    result = backtesting.backtest(**backtest_conf)\n    assert result['results'].empty"
        ]
    },
    {
        "func_name": "test_backtest_alternate_buy_sell",
        "original": "def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, pair='UNITTEST/BTC', datadir=testdatadir)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting.required_startup = 0\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate\n    backtesting.strategy.advise_exit = _trend_alternate\n    result = backtesting.backtest(**backtest_conf)\n    results = result['results']\n    assert len(results) == 100\n    analyzed_df = backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]\n    assert len(analyzed_df) == 200\n    expected_last_candle_date = backtest_conf['end_date'] - timedelta(minutes=1)\n    assert analyzed_df.iloc[-1]['date'].to_pydatetime() == expected_last_candle_date\n    assert len(results.loc[results['is_open']]) == 0",
        "mutated": [
            "def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):\n    if False:\n        i = 10\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, pair='UNITTEST/BTC', datadir=testdatadir)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting.required_startup = 0\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate\n    backtesting.strategy.advise_exit = _trend_alternate\n    result = backtesting.backtest(**backtest_conf)\n    results = result['results']\n    assert len(results) == 100\n    analyzed_df = backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]\n    assert len(analyzed_df) == 200\n    expected_last_candle_date = backtest_conf['end_date'] - timedelta(minutes=1)\n    assert analyzed_df.iloc[-1]['date'].to_pydatetime() == expected_last_candle_date\n    assert len(results.loc[results['is_open']]) == 0",
            "def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, pair='UNITTEST/BTC', datadir=testdatadir)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting.required_startup = 0\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate\n    backtesting.strategy.advise_exit = _trend_alternate\n    result = backtesting.backtest(**backtest_conf)\n    results = result['results']\n    assert len(results) == 100\n    analyzed_df = backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]\n    assert len(analyzed_df) == 200\n    expected_last_candle_date = backtest_conf['end_date'] - timedelta(minutes=1)\n    assert analyzed_df.iloc[-1]['date'].to_pydatetime() == expected_last_candle_date\n    assert len(results.loc[results['is_open']]) == 0",
            "def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, pair='UNITTEST/BTC', datadir=testdatadir)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting.required_startup = 0\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate\n    backtesting.strategy.advise_exit = _trend_alternate\n    result = backtesting.backtest(**backtest_conf)\n    results = result['results']\n    assert len(results) == 100\n    analyzed_df = backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]\n    assert len(analyzed_df) == 200\n    expected_last_candle_date = backtest_conf['end_date'] - timedelta(minutes=1)\n    assert analyzed_df.iloc[-1]['date'].to_pydatetime() == expected_last_candle_date\n    assert len(results.loc[results['is_open']]) == 0",
            "def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, pair='UNITTEST/BTC', datadir=testdatadir)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting.required_startup = 0\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate\n    backtesting.strategy.advise_exit = _trend_alternate\n    result = backtesting.backtest(**backtest_conf)\n    results = result['results']\n    assert len(results) == 100\n    analyzed_df = backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]\n    assert len(analyzed_df) == 200\n    expected_last_candle_date = backtest_conf['end_date'] - timedelta(minutes=1)\n    assert analyzed_df.iloc[-1]['date'].to_pydatetime() == expected_last_candle_date\n    assert len(results.loc[results['is_open']]) == 0",
            "def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    default_conf['max_open_trades'] = 10\n    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, pair='UNITTEST/BTC', datadir=testdatadir)\n    default_conf['timeframe'] = '1m'\n    backtesting = Backtesting(default_conf)\n    backtesting.required_startup = 0\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate\n    backtesting.strategy.advise_exit = _trend_alternate\n    result = backtesting.backtest(**backtest_conf)\n    results = result['results']\n    assert len(results) == 100\n    analyzed_df = backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]\n    assert len(analyzed_df) == 200\n    expected_last_candle_date = backtest_conf['end_date'] - timedelta(minutes=1)\n    assert analyzed_df.iloc[-1]['date'].to_pydatetime() == expected_last_candle_date\n    assert len(results.loc[results['is_open']]) == 0"
        ]
    },
    {
        "func_name": "_trend_alternate_hold",
        "original": "def _trend_alternate_hold(dataframe=None, metadata=None):\n    \"\"\"\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\n        \"\"\"\n    if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n        multi = 20\n    else:\n        multi = 18\n    dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n    dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n    dataframe['enter_short'] = 0\n    dataframe['exit_short'] = 0\n    return dataframe",
        "mutated": [
            "def _trend_alternate_hold(dataframe=None, metadata=None):\n    if False:\n        i = 10\n    '\\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\\n        '\n    if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n        multi = 20\n    else:\n        multi = 18\n    dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n    dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n    dataframe['enter_short'] = 0\n    dataframe['exit_short'] = 0\n    return dataframe",
            "def _trend_alternate_hold(dataframe=None, metadata=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\\n        '\n    if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n        multi = 20\n    else:\n        multi = 18\n    dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n    dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n    dataframe['enter_short'] = 0\n    dataframe['exit_short'] = 0\n    return dataframe",
            "def _trend_alternate_hold(dataframe=None, metadata=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\\n        '\n    if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n        multi = 20\n    else:\n        multi = 18\n    dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n    dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n    dataframe['enter_short'] = 0\n    dataframe['exit_short'] = 0\n    return dataframe",
            "def _trend_alternate_hold(dataframe=None, metadata=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\\n        '\n    if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n        multi = 20\n    else:\n        multi = 18\n    dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n    dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n    dataframe['enter_short'] = 0\n    dataframe['exit_short'] = 0\n    return dataframe",
            "def _trend_alternate_hold(dataframe=None, metadata=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\\n        '\n    if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n        multi = 20\n    else:\n        multi = 18\n    dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n    dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n    dataframe['enter_short'] = 0\n    dataframe['exit_short'] = 0\n    return dataframe"
        ]
    },
    {
        "func_name": "test_backtest_multi_pair",
        "original": "@pytest.mark.parametrize('pair', ['ADA/BTC', 'LTC/BTC'])\n@pytest.mark.parametrize('tres', [0, 20, 30])\ndef test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n\n    def _trend_alternate_hold(dataframe=None, metadata=None):\n        \"\"\"\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\n        \"\"\"\n        if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n            multi = 20\n        else:\n            multi = 18\n        dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n        dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n        dataframe['enter_short'] = 0\n        dataframe['exit_short'] = 0\n        return dataframe\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    pairs = ['ADA/BTC', 'DASH/BTC', 'ETH/BTC', 'LTC/BTC', 'NXT/BTC']\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=pairs)\n    data = trim_dictlist(data, -500)\n    if tres > 0:\n        data[pair] = data[pair][tres:].reset_index()\n    default_conf['timeframe'] = '5m'\n    default_conf['max_open_trades'] = 3\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate_hold\n    backtesting.strategy.advise_exit = _trend_alternate_hold\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 2)) > 0\n    assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n    offset = 1 if tres == 0 else 0\n    removed_candles = len(data[pair]) - offset\n    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n    assert len(backtesting.dataprovider.get_analyzed_dataframe('NXT/BTC', '5m')[0]) == len(data['NXT/BTC']) - 1\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 1)) == 0",
        "mutated": [
            "@pytest.mark.parametrize('pair', ['ADA/BTC', 'LTC/BTC'])\n@pytest.mark.parametrize('tres', [0, 20, 30])\ndef test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n    if False:\n        i = 10\n\n    def _trend_alternate_hold(dataframe=None, metadata=None):\n        \"\"\"\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\n        \"\"\"\n        if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n            multi = 20\n        else:\n            multi = 18\n        dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n        dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n        dataframe['enter_short'] = 0\n        dataframe['exit_short'] = 0\n        return dataframe\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    pairs = ['ADA/BTC', 'DASH/BTC', 'ETH/BTC', 'LTC/BTC', 'NXT/BTC']\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=pairs)\n    data = trim_dictlist(data, -500)\n    if tres > 0:\n        data[pair] = data[pair][tres:].reset_index()\n    default_conf['timeframe'] = '5m'\n    default_conf['max_open_trades'] = 3\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate_hold\n    backtesting.strategy.advise_exit = _trend_alternate_hold\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 2)) > 0\n    assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n    offset = 1 if tres == 0 else 0\n    removed_candles = len(data[pair]) - offset\n    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n    assert len(backtesting.dataprovider.get_analyzed_dataframe('NXT/BTC', '5m')[0]) == len(data['NXT/BTC']) - 1\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 1)) == 0",
            "@pytest.mark.parametrize('pair', ['ADA/BTC', 'LTC/BTC'])\n@pytest.mark.parametrize('tres', [0, 20, 30])\ndef test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def _trend_alternate_hold(dataframe=None, metadata=None):\n        \"\"\"\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\n        \"\"\"\n        if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n            multi = 20\n        else:\n            multi = 18\n        dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n        dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n        dataframe['enter_short'] = 0\n        dataframe['exit_short'] = 0\n        return dataframe\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    pairs = ['ADA/BTC', 'DASH/BTC', 'ETH/BTC', 'LTC/BTC', 'NXT/BTC']\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=pairs)\n    data = trim_dictlist(data, -500)\n    if tres > 0:\n        data[pair] = data[pair][tres:].reset_index()\n    default_conf['timeframe'] = '5m'\n    default_conf['max_open_trades'] = 3\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate_hold\n    backtesting.strategy.advise_exit = _trend_alternate_hold\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 2)) > 0\n    assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n    offset = 1 if tres == 0 else 0\n    removed_candles = len(data[pair]) - offset\n    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n    assert len(backtesting.dataprovider.get_analyzed_dataframe('NXT/BTC', '5m')[0]) == len(data['NXT/BTC']) - 1\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 1)) == 0",
            "@pytest.mark.parametrize('pair', ['ADA/BTC', 'LTC/BTC'])\n@pytest.mark.parametrize('tres', [0, 20, 30])\ndef test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def _trend_alternate_hold(dataframe=None, metadata=None):\n        \"\"\"\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\n        \"\"\"\n        if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n            multi = 20\n        else:\n            multi = 18\n        dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n        dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n        dataframe['enter_short'] = 0\n        dataframe['exit_short'] = 0\n        return dataframe\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    pairs = ['ADA/BTC', 'DASH/BTC', 'ETH/BTC', 'LTC/BTC', 'NXT/BTC']\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=pairs)\n    data = trim_dictlist(data, -500)\n    if tres > 0:\n        data[pair] = data[pair][tres:].reset_index()\n    default_conf['timeframe'] = '5m'\n    default_conf['max_open_trades'] = 3\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate_hold\n    backtesting.strategy.advise_exit = _trend_alternate_hold\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 2)) > 0\n    assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n    offset = 1 if tres == 0 else 0\n    removed_candles = len(data[pair]) - offset\n    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n    assert len(backtesting.dataprovider.get_analyzed_dataframe('NXT/BTC', '5m')[0]) == len(data['NXT/BTC']) - 1\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 1)) == 0",
            "@pytest.mark.parametrize('pair', ['ADA/BTC', 'LTC/BTC'])\n@pytest.mark.parametrize('tres', [0, 20, 30])\ndef test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def _trend_alternate_hold(dataframe=None, metadata=None):\n        \"\"\"\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\n        \"\"\"\n        if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n            multi = 20\n        else:\n            multi = 18\n        dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n        dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n        dataframe['enter_short'] = 0\n        dataframe['exit_short'] = 0\n        return dataframe\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    pairs = ['ADA/BTC', 'DASH/BTC', 'ETH/BTC', 'LTC/BTC', 'NXT/BTC']\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=pairs)\n    data = trim_dictlist(data, -500)\n    if tres > 0:\n        data[pair] = data[pair][tres:].reset_index()\n    default_conf['timeframe'] = '5m'\n    default_conf['max_open_trades'] = 3\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate_hold\n    backtesting.strategy.advise_exit = _trend_alternate_hold\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 2)) > 0\n    assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n    offset = 1 if tres == 0 else 0\n    removed_candles = len(data[pair]) - offset\n    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n    assert len(backtesting.dataprovider.get_analyzed_dataframe('NXT/BTC', '5m')[0]) == len(data['NXT/BTC']) - 1\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 1)) == 0",
            "@pytest.mark.parametrize('pair', ['ADA/BTC', 'LTC/BTC'])\n@pytest.mark.parametrize('tres', [0, 20, 30])\ndef test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def _trend_alternate_hold(dataframe=None, metadata=None):\n        \"\"\"\n        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\n        \"\"\"\n        if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n            multi = 20\n        else:\n            multi = 18\n        dataframe['enter_long'] = np.where(dataframe.index % multi == 0, 1, 0)\n        dataframe['exit_long'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n        dataframe['enter_short'] = 0\n        dataframe['exit_short'] = 0\n        return dataframe\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    patch_exchange(mocker)\n    pairs = ['ADA/BTC', 'DASH/BTC', 'ETH/BTC', 'LTC/BTC', 'NXT/BTC']\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=pairs)\n    data = trim_dictlist(data, -500)\n    if tres > 0:\n        data[pair] = data[pair][tres:].reset_index()\n    default_conf['timeframe'] = '5m'\n    default_conf['max_open_trades'] = 3\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting.strategy.advise_entry = _trend_alternate_hold\n    backtesting.strategy.advise_exit = _trend_alternate_hold\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 2)) > 0\n    assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n    offset = 1 if tres == 0 else 0\n    removed_candles = len(data[pair]) - offset\n    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n    assert len(backtesting.dataprovider.get_analyzed_dataframe('NXT/BTC', '5m')[0]) == len(data['NXT/BTC']) - 1\n    backtesting.strategy.max_open_trades = 1\n    backtesting.config.update({'max_open_trades': 1})\n    backtest_conf = {'processed': deepcopy(processed), 'start_date': min_date, 'end_date': max_date}\n    results = backtesting.backtest(**backtest_conf)\n    assert len(evaluate_result_multi(results['results'], '5m', 1)) == 0"
        ]
    },
    {
        "func_name": "test_backtest_start_timerange",
        "original": "def test_backtest_start_timerange(default_conf, mocker, caplog, testdatadir):\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', str(testdatadir), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)",
        "mutated": [
            "def test_backtest_start_timerange(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', str(testdatadir), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)",
            "def test_backtest_start_timerange(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', str(testdatadir), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)",
            "def test_backtest_start_timerange(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', str(testdatadir), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)",
            "def test_backtest_start_timerange(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', str(testdatadir), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)",
            "def test_backtest_start_timerange(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--strategy', CURRENT_TEST_STRATEGY, '--datadir', str(testdatadir), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)"
        ]
    },
    {
        "func_name": "test_backtest_start_multi_strat",
        "original": "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat(default_conf, mocker, caplog, testdatadir):\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    text_table_mock = MagicMock()\n    sell_reason_mock = MagicMock()\n    strattable_mock = MagicMock()\n    strat_summary = MagicMock()\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.bt_output', text_table_bt_results=text_table_mock, text_table_strategy=strattable_mock)\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.optimize_reports', generate_pair_metrics=MagicMock(), generate_exit_reason_stats=sell_reason_mock, generate_strategy_comparison=strat_summary, generate_daily_stats=MagicMock())\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    assert backtestmock.call_count == 2\n    assert text_table_mock.call_count == 4\n    assert strattable_mock.call_count == 1\n    assert sell_reason_mock.call_count == 2\n    assert strat_summary.call_count == 1\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)",
        "mutated": [
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    text_table_mock = MagicMock()\n    sell_reason_mock = MagicMock()\n    strattable_mock = MagicMock()\n    strat_summary = MagicMock()\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.bt_output', text_table_bt_results=text_table_mock, text_table_strategy=strattable_mock)\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.optimize_reports', generate_pair_metrics=MagicMock(), generate_exit_reason_stats=sell_reason_mock, generate_strategy_comparison=strat_summary, generate_daily_stats=MagicMock())\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    assert backtestmock.call_count == 2\n    assert text_table_mock.call_count == 4\n    assert strattable_mock.call_count == 1\n    assert sell_reason_mock.call_count == 2\n    assert strat_summary.call_count == 1\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    text_table_mock = MagicMock()\n    sell_reason_mock = MagicMock()\n    strattable_mock = MagicMock()\n    strat_summary = MagicMock()\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.bt_output', text_table_bt_results=text_table_mock, text_table_strategy=strattable_mock)\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.optimize_reports', generate_pair_metrics=MagicMock(), generate_exit_reason_stats=sell_reason_mock, generate_strategy_comparison=strat_summary, generate_daily_stats=MagicMock())\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    assert backtestmock.call_count == 2\n    assert text_table_mock.call_count == 4\n    assert strattable_mock.call_count == 1\n    assert sell_reason_mock.call_count == 2\n    assert strat_summary.call_count == 1\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    text_table_mock = MagicMock()\n    sell_reason_mock = MagicMock()\n    strattable_mock = MagicMock()\n    strat_summary = MagicMock()\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.bt_output', text_table_bt_results=text_table_mock, text_table_strategy=strattable_mock)\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.optimize_reports', generate_pair_metrics=MagicMock(), generate_exit_reason_stats=sell_reason_mock, generate_strategy_comparison=strat_summary, generate_daily_stats=MagicMock())\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    assert backtestmock.call_count == 2\n    assert text_table_mock.call_count == 4\n    assert strattable_mock.call_count == 1\n    assert sell_reason_mock.call_count == 2\n    assert strat_summary.call_count == 1\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    text_table_mock = MagicMock()\n    sell_reason_mock = MagicMock()\n    strattable_mock = MagicMock()\n    strat_summary = MagicMock()\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.bt_output', text_table_bt_results=text_table_mock, text_table_strategy=strattable_mock)\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.optimize_reports', generate_pair_metrics=MagicMock(), generate_exit_reason_stats=sell_reason_mock, generate_strategy_comparison=strat_summary, generate_daily_stats=MagicMock())\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    assert backtestmock.call_count == 2\n    assert text_table_mock.call_count == 4\n    assert strattable_mock.call_count == 1\n    assert sell_reason_mock.call_count == 2\n    assert strat_summary.call_count == 1\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat(default_conf, mocker, caplog, testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    text_table_mock = MagicMock()\n    sell_reason_mock = MagicMock()\n    strattable_mock = MagicMock()\n    strat_summary = MagicMock()\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.bt_output', text_table_bt_results=text_table_mock, text_table_strategy=strattable_mock)\n    mocker.patch.multiple('freqtrade.optimize.optimize_reports.optimize_reports', generate_pair_metrics=MagicMock(), generate_exit_reason_stats=sell_reason_mock, generate_strategy_comparison=strat_summary, generate_daily_stats=MagicMock())\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    assert backtestmock.call_count == 2\n    assert text_table_mock.call_count == 4\n    assert strattable_mock.call_count == 1\n    assert sell_reason_mock.call_count == 2\n    assert strat_summary.call_count == 1\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)"
        ]
    },
    {
        "func_name": "test_backtest_start_multi_strat_nomock",
        "original": "def test_backtest_start_multi_strat_nomock(default_conf, mocker, caplog, testdatadir, capsys):\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'is_short': [False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'is_short': [False, False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--breakdown', 'day', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'DAY BREAKDOWN' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out\n    assert '2017-11-14 21:17:00 -> 2017-11-14 22:59:00 | Max open trades : 1' in captured.out\n    assert 'STRATEGY SUMMARY' in captured.out",
        "mutated": [
            "def test_backtest_start_multi_strat_nomock(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'is_short': [False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'is_short': [False, False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--breakdown', 'day', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'DAY BREAKDOWN' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out\n    assert '2017-11-14 21:17:00 -> 2017-11-14 22:59:00 | Max open trades : 1' in captured.out\n    assert 'STRATEGY SUMMARY' in captured.out",
            "def test_backtest_start_multi_strat_nomock(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'is_short': [False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'is_short': [False, False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--breakdown', 'day', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'DAY BREAKDOWN' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out\n    assert '2017-11-14 21:17:00 -> 2017-11-14 22:59:00 | Max open trades : 1' in captured.out\n    assert 'STRATEGY SUMMARY' in captured.out",
            "def test_backtest_start_multi_strat_nomock(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'is_short': [False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'is_short': [False, False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--breakdown', 'day', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'DAY BREAKDOWN' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out\n    assert '2017-11-14 21:17:00 -> 2017-11-14 22:59:00 | Max open trades : 1' in captured.out\n    assert 'STRATEGY SUMMARY' in captured.out",
            "def test_backtest_start_multi_strat_nomock(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'is_short': [False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'is_short': [False, False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--breakdown', 'day', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'DAY BREAKDOWN' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out\n    assert '2017-11-14 21:17:00 -> 2017-11-14 22:59:00 | Max open trades : 1' in captured.out\n    assert 'STRATEGY SUMMARY' in captured.out",
            "def test_backtest_start_multi_strat_nomock(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'is_short': [False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'is_short': [False, False, False], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--breakdown', 'day', '--strategy-list', CURRENT_TEST_STRATEGY, 'StrategyTestV2']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}', 'Running backtesting for Strategy StrategyTestV2']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'DAY BREAKDOWN' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out\n    assert '2017-11-14 21:17:00 -> 2017-11-14 22:59:00 | Max open trades : 1' in captured.out\n    assert 'STRATEGY SUMMARY' in captured.out"
        ]
    },
    {
        "func_name": "test_backtest_start_futures_noliq",
        "original": "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_futures_noliq(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['HULUMULU/USDT', 'XRP/USDT:USDT']))\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    with pytest.raises(OperationalException, match='Pairs .* got no leverage tiers available\\\\.'):\n        start_backtesting(args)",
        "mutated": [
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_futures_noliq(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['HULUMULU/USDT', 'XRP/USDT:USDT']))\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    with pytest.raises(OperationalException, match='Pairs .* got no leverage tiers available\\\\.'):\n        start_backtesting(args)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_futures_noliq(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['HULUMULU/USDT', 'XRP/USDT:USDT']))\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    with pytest.raises(OperationalException, match='Pairs .* got no leverage tiers available\\\\.'):\n        start_backtesting(args)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_futures_noliq(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['HULUMULU/USDT', 'XRP/USDT:USDT']))\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    with pytest.raises(OperationalException, match='Pairs .* got no leverage tiers available\\\\.'):\n        start_backtesting(args)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_futures_noliq(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['HULUMULU/USDT', 'XRP/USDT:USDT']))\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    with pytest.raises(OperationalException, match='Pairs .* got no leverage tiers available\\\\.'):\n        start_backtesting(args)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_futures_noliq(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['HULUMULU/USDT', 'XRP/USDT:USDT']))\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    with pytest.raises(OperationalException, match='Pairs .* got no leverage tiers available\\\\.'):\n        start_backtesting(args)"
        ]
    },
    {
        "func_name": "test_backtest_start_nomock_futures",
        "original": "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_nomock_futures(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2021-11-18 18:00:00', '2021-11-18 03:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-18 20:00:00', '2021-11-18 05:00:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2021-11-19 18:00:00', '2021-11-19 03:00:00', '2021-11-19 05:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-19 20:00:00', '2021-11-19 05:00:00', '2021-11-19 08:00:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1h ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2021-11-17 01:00:00 up to 2021-11-21 04:00:00 (4 days).', 'Backtesting with data from 2021-11-17 21:00:00 up to 2021-11-21 04:00:00 (3 days).', 'XRP/USDT:USDT, funding_rate, 8h, data starts at 2021-11-18 00:00:00', 'XRP/USDT:USDT, mark, 8h, data starts at 2021-11-18 00:00:00', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
        "mutated": [
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_nomock_futures(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2021-11-18 18:00:00', '2021-11-18 03:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-18 20:00:00', '2021-11-18 05:00:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2021-11-19 18:00:00', '2021-11-19 03:00:00', '2021-11-19 05:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-19 20:00:00', '2021-11-19 05:00:00', '2021-11-19 08:00:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1h ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2021-11-17 01:00:00 up to 2021-11-21 04:00:00 (4 days).', 'Backtesting with data from 2021-11-17 21:00:00 up to 2021-11-21 04:00:00 (3 days).', 'XRP/USDT:USDT, funding_rate, 8h, data starts at 2021-11-18 00:00:00', 'XRP/USDT:USDT, mark, 8h, data starts at 2021-11-18 00:00:00', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_nomock_futures(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2021-11-18 18:00:00', '2021-11-18 03:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-18 20:00:00', '2021-11-18 05:00:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2021-11-19 18:00:00', '2021-11-19 03:00:00', '2021-11-19 05:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-19 20:00:00', '2021-11-19 05:00:00', '2021-11-19 08:00:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1h ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2021-11-17 01:00:00 up to 2021-11-21 04:00:00 (4 days).', 'Backtesting with data from 2021-11-17 21:00:00 up to 2021-11-21 04:00:00 (3 days).', 'XRP/USDT:USDT, funding_rate, 8h, data starts at 2021-11-18 00:00:00', 'XRP/USDT:USDT, mark, 8h, data starts at 2021-11-18 00:00:00', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_nomock_futures(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2021-11-18 18:00:00', '2021-11-18 03:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-18 20:00:00', '2021-11-18 05:00:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2021-11-19 18:00:00', '2021-11-19 03:00:00', '2021-11-19 05:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-19 20:00:00', '2021-11-19 05:00:00', '2021-11-19 08:00:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1h ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2021-11-17 01:00:00 up to 2021-11-21 04:00:00 (4 days).', 'Backtesting with data from 2021-11-17 21:00:00 up to 2021-11-21 04:00:00 (3 days).', 'XRP/USDT:USDT, funding_rate, 8h, data starts at 2021-11-18 00:00:00', 'XRP/USDT:USDT, mark, 8h, data starts at 2021-11-18 00:00:00', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_nomock_futures(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2021-11-18 18:00:00', '2021-11-18 03:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-18 20:00:00', '2021-11-18 05:00:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2021-11-19 18:00:00', '2021-11-19 03:00:00', '2021-11-19 05:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-19 20:00:00', '2021-11-19 05:00:00', '2021-11-19 08:00:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1h ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2021-11-17 01:00:00 up to 2021-11-21 04:00:00 (4 days).', 'Backtesting with data from 2021-11-17 21:00:00 up to 2021-11-21 04:00:00 (3 days).', 'XRP/USDT:USDT, funding_rate, 8h, data starts at 2021-11-18 00:00:00', 'XRP/USDT:USDT, mark, 8h, data starts at 2021-11-18 00:00:00', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_nomock_futures(default_conf_usdt, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf_usdt.update({'trading_mode': 'futures', 'margin_mode': 'isolated', 'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False, 'strategy': CURRENT_TEST_STRATEGY})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2021-11-18 18:00:00', '2021-11-18 03:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-18 20:00:00', '2021-11-18 05:00:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/USDT:USDT', 'XRP/USDT:USDT', 'XRP/USDT:USDT'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2021-11-19 18:00:00', '2021-11-19 03:00:00', '2021-11-19 05:00:00'], utc=True), 'close_date': pd.to_datetime(['2021-11-19 20:00:00', '2021-11-19 05:00:00', '2021-11-19 08:00:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf_usdt, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/USDT:USDT']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf_usdt)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1h']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1h ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2021-11-17 01:00:00 up to 2021-11-21 04:00:00 (4 days).', 'Backtesting with data from 2021-11-17 21:00:00 up to 2021-11-21 04:00:00 (3 days).', 'XRP/USDT:USDT, funding_rate, 8h, data starts at 2021-11-18 00:00:00', 'XRP/USDT:USDT, mark, 8h, data starts at 2021-11-18 00:00:00', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out"
        ]
    },
    {
        "func_name": "test_backtest_start_multi_strat_nomock_detail",
        "original": "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat_nomock_detail(default_conf, mocker, caplog, testdatadir, capsys):\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/ETH']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '5m', '--timeframe-detail', '1m', '--strategy-list', CURRENT_TEST_STRATEGY]\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 5m ...', 'Parameter --timeframe-detail detected, using 1m for intra-candle backtesting ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2019-10-11 00:00:00 up to 2019-10-13 11:15:00 (2 days).', 'Backtesting with data from 2019-10-11 01:40:00 up to 2019-10-13 11:15:00 (2 days).', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
        "mutated": [
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat_nomock_detail(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/ETH']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '5m', '--timeframe-detail', '1m', '--strategy-list', CURRENT_TEST_STRATEGY]\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 5m ...', 'Parameter --timeframe-detail detected, using 1m for intra-candle backtesting ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2019-10-11 00:00:00 up to 2019-10-13 11:15:00 (2 days).', 'Backtesting with data from 2019-10-11 01:40:00 up to 2019-10-13 11:15:00 (2 days).', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat_nomock_detail(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/ETH']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '5m', '--timeframe-detail', '1m', '--strategy-list', CURRENT_TEST_STRATEGY]\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 5m ...', 'Parameter --timeframe-detail detected, using 1m for intra-candle backtesting ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2019-10-11 00:00:00 up to 2019-10-13 11:15:00 (2 days).', 'Backtesting with data from 2019-10-11 01:40:00 up to 2019-10-13 11:15:00 (2 days).', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat_nomock_detail(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/ETH']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '5m', '--timeframe-detail', '1m', '--strategy-list', CURRENT_TEST_STRATEGY]\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 5m ...', 'Parameter --timeframe-detail detected, using 1m for intra-candle backtesting ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2019-10-11 00:00:00 up to 2019-10-13 11:15:00 (2 days).', 'Backtesting with data from 2019-10-11 01:40:00 up to 2019-10-13 11:15:00 (2 days).', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat_nomock_detail(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/ETH']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '5m', '--timeframe-detail', '1m', '--strategy-list', CURRENT_TEST_STRATEGY]\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 5m ...', 'Parameter --timeframe-detail detected, using 1m for intra-candle backtesting ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2019-10-11 00:00:00 up to 2019-10-13 11:15:00 (2 days).', 'Backtesting with data from 2019-10-11 01:40:00 up to 2019-10-13 11:15:00 (2 days).', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out",
            "@pytest.mark.filterwarnings('ignore:deprecated')\ndef test_backtest_start_multi_strat_nomock_detail(default_conf, mocker, caplog, testdatadir, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00'], utc=True), 'trade_duration': [235, 40], 'is_open': [False, False], 'is_short': [False, False], 'stake_amount': [0.01, 0.01], 'open_rate': [0.104445, 0.10302485], 'close_rate': [0.104969, 0.103541], 'exit_reason': [ExitType.ROI, ExitType.ROI]})\n    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'], 'profit_ratio': [0.03, 0.01, 0.1], 'profit_abs': [0.01, 0.02, 0.2], 'open_date': pd.to_datetime(['2018-01-29 18:40:00', '2018-01-30 03:30:00', '2018-01-30 05:30:00'], utc=True), 'close_date': pd.to_datetime(['2018-01-29 20:45:00', '2018-01-30 05:35:00', '2018-01-30 08:30:00'], utc=True), 'trade_duration': [47, 40, 20], 'is_open': [False, False, False], 'is_short': [False, False, False], 'stake_amount': [0.01, 0.01, 0.01], 'open_rate': [0.104445, 0.10302485, 0.122541], 'close_rate': [0.104969, 0.103541, 0.123541], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    backtestmock = MagicMock(side_effect=[{'results': result1, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}, {'results': result2, 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000}])\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['XRP/ETH']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '5m', '--timeframe-detail', '1m', '--strategy-list', CURRENT_TEST_STRATEGY]\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 5m ...', 'Parameter --timeframe-detail detected, using 1m for intra-candle backtesting ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2019-10-11 00:00:00 up to 2019-10-13 11:15:00 (2 days).', 'Backtesting with data from 2019-10-11 01:40:00 up to 2019-10-13 11:15:00 (2 days).', f'Running backtesting for Strategy {CURRENT_TEST_STRATEGY}']\n    for line in exists:\n        assert log_has(line, caplog)\n    captured = capsys.readouterr()\n    assert 'BACKTESTING REPORT' in captured.out\n    assert 'EXIT REASON STATS' in captured.out\n    assert 'LEFT OPEN TRADES REPORT' in captured.out"
        ]
    },
    {
        "func_name": "test_backtest_start_multi_strat_caching",
        "original": "@pytest.mark.filterwarnings('ignore:deprecated')\n@pytest.mark.parametrize('run_id', ['2', 'changed'])\n@pytest.mark.parametrize('start_delta', [{'days': 0}, {'days': 1}, {'weeks': 1}, {'weeks': 4}])\n@pytest.mark.parametrize('cache', constants.BACKTEST_CACHE_AGE)\ndef test_backtest_start_multi_strat_caching(default_conf, mocker, caplog, testdatadir, run_id, start_delta, cache):\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results', MagicMock())\n    now = min_backtest_date = datetime.now(tz=timezone.utc)\n    start_time = now - timedelta(**start_delta) + timedelta(hours=1)\n    if cache == 'none':\n        min_backtest_date = now + timedelta(days=1)\n    elif cache == 'day':\n        min_backtest_date = now - timedelta(days=1)\n    elif cache == 'week':\n        min_backtest_date = now - timedelta(weeks=1)\n    elif cache == 'month':\n        min_backtest_date = now - timedelta(weeks=4)\n    load_backtest_metadata = MagicMock(return_value={'StrategyTestV2': {'run_id': '1', 'backtest_start_time': now.timestamp()}, 'StrategyTestV3': {'run_id': run_id, 'backtest_start_time': start_time.timestamp()}})\n    load_backtest_stats = MagicMock(side_effect=[{'metadata': {'StrategyTestV2': {'run_id': '1'}}, 'strategy': {'StrategyTestV2': {}}, 'strategy_comparison': [{'key': 'StrategyTestV2'}]}, {'metadata': {'StrategyTestV3': {'run_id': '2'}}, 'strategy': {'StrategyTestV3': {}}, 'strategy_comparison': [{'key': 'StrategyTestV3'}]}])\n    mocker.patch('pathlib.Path.glob', return_value=[Path(datetime.strftime(datetime.now(), 'backtest-result-%Y-%m-%d_%H-%M-%S.json'))])\n    mocker.patch.multiple('freqtrade.data.btanalysis', load_backtest_metadata=load_backtest_metadata, load_backtest_stats=load_backtest_stats)\n    mocker.patch('freqtrade.optimize.backtesting.get_strategy_run_id', side_effect=['1', '2', '2'])\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--cache', cache, '--strategy-list', 'StrategyTestV2', 'StrategyTestV3']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)\n    if cache == 'none':\n        assert backtestmock.call_count == 2\n        exists = ['Running backtesting for Strategy StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    elif run_id == '2' and min_backtest_date < start_time:\n        assert backtestmock.call_count == 0\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Reusing result of previous backtest for StrategyTestV3']\n    else:\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n        assert backtestmock.call_count == 1\n    for line in exists:\n        assert log_has(line, caplog)",
        "mutated": [
            "@pytest.mark.filterwarnings('ignore:deprecated')\n@pytest.mark.parametrize('run_id', ['2', 'changed'])\n@pytest.mark.parametrize('start_delta', [{'days': 0}, {'days': 1}, {'weeks': 1}, {'weeks': 4}])\n@pytest.mark.parametrize('cache', constants.BACKTEST_CACHE_AGE)\ndef test_backtest_start_multi_strat_caching(default_conf, mocker, caplog, testdatadir, run_id, start_delta, cache):\n    if False:\n        i = 10\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results', MagicMock())\n    now = min_backtest_date = datetime.now(tz=timezone.utc)\n    start_time = now - timedelta(**start_delta) + timedelta(hours=1)\n    if cache == 'none':\n        min_backtest_date = now + timedelta(days=1)\n    elif cache == 'day':\n        min_backtest_date = now - timedelta(days=1)\n    elif cache == 'week':\n        min_backtest_date = now - timedelta(weeks=1)\n    elif cache == 'month':\n        min_backtest_date = now - timedelta(weeks=4)\n    load_backtest_metadata = MagicMock(return_value={'StrategyTestV2': {'run_id': '1', 'backtest_start_time': now.timestamp()}, 'StrategyTestV3': {'run_id': run_id, 'backtest_start_time': start_time.timestamp()}})\n    load_backtest_stats = MagicMock(side_effect=[{'metadata': {'StrategyTestV2': {'run_id': '1'}}, 'strategy': {'StrategyTestV2': {}}, 'strategy_comparison': [{'key': 'StrategyTestV2'}]}, {'metadata': {'StrategyTestV3': {'run_id': '2'}}, 'strategy': {'StrategyTestV3': {}}, 'strategy_comparison': [{'key': 'StrategyTestV3'}]}])\n    mocker.patch('pathlib.Path.glob', return_value=[Path(datetime.strftime(datetime.now(), 'backtest-result-%Y-%m-%d_%H-%M-%S.json'))])\n    mocker.patch.multiple('freqtrade.data.btanalysis', load_backtest_metadata=load_backtest_metadata, load_backtest_stats=load_backtest_stats)\n    mocker.patch('freqtrade.optimize.backtesting.get_strategy_run_id', side_effect=['1', '2', '2'])\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--cache', cache, '--strategy-list', 'StrategyTestV2', 'StrategyTestV3']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)\n    if cache == 'none':\n        assert backtestmock.call_count == 2\n        exists = ['Running backtesting for Strategy StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    elif run_id == '2' and min_backtest_date < start_time:\n        assert backtestmock.call_count == 0\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Reusing result of previous backtest for StrategyTestV3']\n    else:\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n        assert backtestmock.call_count == 1\n    for line in exists:\n        assert log_has(line, caplog)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\n@pytest.mark.parametrize('run_id', ['2', 'changed'])\n@pytest.mark.parametrize('start_delta', [{'days': 0}, {'days': 1}, {'weeks': 1}, {'weeks': 4}])\n@pytest.mark.parametrize('cache', constants.BACKTEST_CACHE_AGE)\ndef test_backtest_start_multi_strat_caching(default_conf, mocker, caplog, testdatadir, run_id, start_delta, cache):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results', MagicMock())\n    now = min_backtest_date = datetime.now(tz=timezone.utc)\n    start_time = now - timedelta(**start_delta) + timedelta(hours=1)\n    if cache == 'none':\n        min_backtest_date = now + timedelta(days=1)\n    elif cache == 'day':\n        min_backtest_date = now - timedelta(days=1)\n    elif cache == 'week':\n        min_backtest_date = now - timedelta(weeks=1)\n    elif cache == 'month':\n        min_backtest_date = now - timedelta(weeks=4)\n    load_backtest_metadata = MagicMock(return_value={'StrategyTestV2': {'run_id': '1', 'backtest_start_time': now.timestamp()}, 'StrategyTestV3': {'run_id': run_id, 'backtest_start_time': start_time.timestamp()}})\n    load_backtest_stats = MagicMock(side_effect=[{'metadata': {'StrategyTestV2': {'run_id': '1'}}, 'strategy': {'StrategyTestV2': {}}, 'strategy_comparison': [{'key': 'StrategyTestV2'}]}, {'metadata': {'StrategyTestV3': {'run_id': '2'}}, 'strategy': {'StrategyTestV3': {}}, 'strategy_comparison': [{'key': 'StrategyTestV3'}]}])\n    mocker.patch('pathlib.Path.glob', return_value=[Path(datetime.strftime(datetime.now(), 'backtest-result-%Y-%m-%d_%H-%M-%S.json'))])\n    mocker.patch.multiple('freqtrade.data.btanalysis', load_backtest_metadata=load_backtest_metadata, load_backtest_stats=load_backtest_stats)\n    mocker.patch('freqtrade.optimize.backtesting.get_strategy_run_id', side_effect=['1', '2', '2'])\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--cache', cache, '--strategy-list', 'StrategyTestV2', 'StrategyTestV3']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)\n    if cache == 'none':\n        assert backtestmock.call_count == 2\n        exists = ['Running backtesting for Strategy StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    elif run_id == '2' and min_backtest_date < start_time:\n        assert backtestmock.call_count == 0\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Reusing result of previous backtest for StrategyTestV3']\n    else:\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n        assert backtestmock.call_count == 1\n    for line in exists:\n        assert log_has(line, caplog)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\n@pytest.mark.parametrize('run_id', ['2', 'changed'])\n@pytest.mark.parametrize('start_delta', [{'days': 0}, {'days': 1}, {'weeks': 1}, {'weeks': 4}])\n@pytest.mark.parametrize('cache', constants.BACKTEST_CACHE_AGE)\ndef test_backtest_start_multi_strat_caching(default_conf, mocker, caplog, testdatadir, run_id, start_delta, cache):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results', MagicMock())\n    now = min_backtest_date = datetime.now(tz=timezone.utc)\n    start_time = now - timedelta(**start_delta) + timedelta(hours=1)\n    if cache == 'none':\n        min_backtest_date = now + timedelta(days=1)\n    elif cache == 'day':\n        min_backtest_date = now - timedelta(days=1)\n    elif cache == 'week':\n        min_backtest_date = now - timedelta(weeks=1)\n    elif cache == 'month':\n        min_backtest_date = now - timedelta(weeks=4)\n    load_backtest_metadata = MagicMock(return_value={'StrategyTestV2': {'run_id': '1', 'backtest_start_time': now.timestamp()}, 'StrategyTestV3': {'run_id': run_id, 'backtest_start_time': start_time.timestamp()}})\n    load_backtest_stats = MagicMock(side_effect=[{'metadata': {'StrategyTestV2': {'run_id': '1'}}, 'strategy': {'StrategyTestV2': {}}, 'strategy_comparison': [{'key': 'StrategyTestV2'}]}, {'metadata': {'StrategyTestV3': {'run_id': '2'}}, 'strategy': {'StrategyTestV3': {}}, 'strategy_comparison': [{'key': 'StrategyTestV3'}]}])\n    mocker.patch('pathlib.Path.glob', return_value=[Path(datetime.strftime(datetime.now(), 'backtest-result-%Y-%m-%d_%H-%M-%S.json'))])\n    mocker.patch.multiple('freqtrade.data.btanalysis', load_backtest_metadata=load_backtest_metadata, load_backtest_stats=load_backtest_stats)\n    mocker.patch('freqtrade.optimize.backtesting.get_strategy_run_id', side_effect=['1', '2', '2'])\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--cache', cache, '--strategy-list', 'StrategyTestV2', 'StrategyTestV3']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)\n    if cache == 'none':\n        assert backtestmock.call_count == 2\n        exists = ['Running backtesting for Strategy StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    elif run_id == '2' and min_backtest_date < start_time:\n        assert backtestmock.call_count == 0\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Reusing result of previous backtest for StrategyTestV3']\n    else:\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n        assert backtestmock.call_count == 1\n    for line in exists:\n        assert log_has(line, caplog)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\n@pytest.mark.parametrize('run_id', ['2', 'changed'])\n@pytest.mark.parametrize('start_delta', [{'days': 0}, {'days': 1}, {'weeks': 1}, {'weeks': 4}])\n@pytest.mark.parametrize('cache', constants.BACKTEST_CACHE_AGE)\ndef test_backtest_start_multi_strat_caching(default_conf, mocker, caplog, testdatadir, run_id, start_delta, cache):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results', MagicMock())\n    now = min_backtest_date = datetime.now(tz=timezone.utc)\n    start_time = now - timedelta(**start_delta) + timedelta(hours=1)\n    if cache == 'none':\n        min_backtest_date = now + timedelta(days=1)\n    elif cache == 'day':\n        min_backtest_date = now - timedelta(days=1)\n    elif cache == 'week':\n        min_backtest_date = now - timedelta(weeks=1)\n    elif cache == 'month':\n        min_backtest_date = now - timedelta(weeks=4)\n    load_backtest_metadata = MagicMock(return_value={'StrategyTestV2': {'run_id': '1', 'backtest_start_time': now.timestamp()}, 'StrategyTestV3': {'run_id': run_id, 'backtest_start_time': start_time.timestamp()}})\n    load_backtest_stats = MagicMock(side_effect=[{'metadata': {'StrategyTestV2': {'run_id': '1'}}, 'strategy': {'StrategyTestV2': {}}, 'strategy_comparison': [{'key': 'StrategyTestV2'}]}, {'metadata': {'StrategyTestV3': {'run_id': '2'}}, 'strategy': {'StrategyTestV3': {}}, 'strategy_comparison': [{'key': 'StrategyTestV3'}]}])\n    mocker.patch('pathlib.Path.glob', return_value=[Path(datetime.strftime(datetime.now(), 'backtest-result-%Y-%m-%d_%H-%M-%S.json'))])\n    mocker.patch.multiple('freqtrade.data.btanalysis', load_backtest_metadata=load_backtest_metadata, load_backtest_stats=load_backtest_stats)\n    mocker.patch('freqtrade.optimize.backtesting.get_strategy_run_id', side_effect=['1', '2', '2'])\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--cache', cache, '--strategy-list', 'StrategyTestV2', 'StrategyTestV3']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)\n    if cache == 'none':\n        assert backtestmock.call_count == 2\n        exists = ['Running backtesting for Strategy StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    elif run_id == '2' and min_backtest_date < start_time:\n        assert backtestmock.call_count == 0\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Reusing result of previous backtest for StrategyTestV3']\n    else:\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n        assert backtestmock.call_count == 1\n    for line in exists:\n        assert log_has(line, caplog)",
            "@pytest.mark.filterwarnings('ignore:deprecated')\n@pytest.mark.parametrize('run_id', ['2', 'changed'])\n@pytest.mark.parametrize('start_delta', [{'days': 0}, {'days': 1}, {'weeks': 1}, {'weeks': 4}])\n@pytest.mark.parametrize('cache', constants.BACKTEST_CACHE_AGE)\ndef test_backtest_start_multi_strat_caching(default_conf, mocker, caplog, testdatadir, run_id, start_delta, cache):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf.update({'use_exit_signal': True, 'exit_profit_only': False, 'exit_profit_offset': 0.0, 'ignore_roi_if_entry_signal': False})\n    patch_exchange(mocker)\n    backtestmock = MagicMock(return_value={'results': pd.DataFrame(columns=BT_DATA_COLUMNS), 'config': default_conf, 'locks': [], 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'final_balance': 1000})\n    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist', PropertyMock(return_value=['UNITTEST/BTC']))\n    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results', MagicMock())\n    now = min_backtest_date = datetime.now(tz=timezone.utc)\n    start_time = now - timedelta(**start_delta) + timedelta(hours=1)\n    if cache == 'none':\n        min_backtest_date = now + timedelta(days=1)\n    elif cache == 'day':\n        min_backtest_date = now - timedelta(days=1)\n    elif cache == 'week':\n        min_backtest_date = now - timedelta(weeks=1)\n    elif cache == 'month':\n        min_backtest_date = now - timedelta(weeks=4)\n    load_backtest_metadata = MagicMock(return_value={'StrategyTestV2': {'run_id': '1', 'backtest_start_time': now.timestamp()}, 'StrategyTestV3': {'run_id': run_id, 'backtest_start_time': start_time.timestamp()}})\n    load_backtest_stats = MagicMock(side_effect=[{'metadata': {'StrategyTestV2': {'run_id': '1'}}, 'strategy': {'StrategyTestV2': {}}, 'strategy_comparison': [{'key': 'StrategyTestV2'}]}, {'metadata': {'StrategyTestV3': {'run_id': '2'}}, 'strategy': {'StrategyTestV3': {}}, 'strategy_comparison': [{'key': 'StrategyTestV3'}]}])\n    mocker.patch('pathlib.Path.glob', return_value=[Path(datetime.strftime(datetime.now(), 'backtest-result-%Y-%m-%d_%H-%M-%S.json'))])\n    mocker.patch.multiple('freqtrade.data.btanalysis', load_backtest_metadata=load_backtest_metadata, load_backtest_stats=load_backtest_stats)\n    mocker.patch('freqtrade.optimize.backtesting.get_strategy_run_id', side_effect=['1', '2', '2'])\n    patched_configuration_load_config_file(mocker, default_conf)\n    args = ['backtesting', '--config', 'config.json', '--datadir', str(testdatadir), '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'), '--timeframe', '1m', '--timerange', '1510694220-1510700340', '--enable-position-stacking', '--disable-max-market-positions', '--cache', cache, '--strategy-list', 'StrategyTestV2', 'StrategyTestV3']\n    args = get_args(args)\n    start_backtesting(args)\n    exists = ['Parameter -i/--timeframe detected ... Using timeframe: 1m ...', 'Parameter --timerange detected: 1510694220-1510700340 ...', f'Using data directory: {testdatadir} ...', 'Loading data from 2017-11-14 20:57:00 up to 2017-11-14 22:59:00 (0 days).', 'Parameter --enable-position-stacking detected ...']\n    for line in exists:\n        assert log_has(line, caplog)\n    if cache == 'none':\n        assert backtestmock.call_count == 2\n        exists = ['Running backtesting for Strategy StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n    elif run_id == '2' and min_backtest_date < start_time:\n        assert backtestmock.call_count == 0\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Reusing result of previous backtest for StrategyTestV3']\n    else:\n        exists = ['Reusing result of previous backtest for StrategyTestV2', 'Running backtesting for Strategy StrategyTestV3', 'Ignoring max_open_trades (--disable-max-market-positions was used) ...', 'Backtesting with data from 2017-11-14 21:17:00 up to 2017-11-14 22:59:00 (0 days).']\n        assert backtestmock.call_count == 1\n    for line in exists:\n        assert log_has(line, caplog)"
        ]
    },
    {
        "func_name": "test_get_strategy_run_id",
        "original": "def test_get_strategy_run_id(default_conf_usdt):\n    default_conf_usdt.update({'strategy': 'StrategyTestV2', 'max_open_trades': float('inf')})\n    strategy = StrategyResolver.load_strategy(default_conf_usdt)\n    x = get_strategy_run_id(strategy)\n    assert isinstance(x, str)",
        "mutated": [
            "def test_get_strategy_run_id(default_conf_usdt):\n    if False:\n        i = 10\n    default_conf_usdt.update({'strategy': 'StrategyTestV2', 'max_open_trades': float('inf')})\n    strategy = StrategyResolver.load_strategy(default_conf_usdt)\n    x = get_strategy_run_id(strategy)\n    assert isinstance(x, str)",
            "def test_get_strategy_run_id(default_conf_usdt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf_usdt.update({'strategy': 'StrategyTestV2', 'max_open_trades': float('inf')})\n    strategy = StrategyResolver.load_strategy(default_conf_usdt)\n    x = get_strategy_run_id(strategy)\n    assert isinstance(x, str)",
            "def test_get_strategy_run_id(default_conf_usdt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf_usdt.update({'strategy': 'StrategyTestV2', 'max_open_trades': float('inf')})\n    strategy = StrategyResolver.load_strategy(default_conf_usdt)\n    x = get_strategy_run_id(strategy)\n    assert isinstance(x, str)",
            "def test_get_strategy_run_id(default_conf_usdt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf_usdt.update({'strategy': 'StrategyTestV2', 'max_open_trades': float('inf')})\n    strategy = StrategyResolver.load_strategy(default_conf_usdt)\n    x = get_strategy_run_id(strategy)\n    assert isinstance(x, str)",
            "def test_get_strategy_run_id(default_conf_usdt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf_usdt.update({'strategy': 'StrategyTestV2', 'max_open_trades': float('inf')})\n    strategy = StrategyResolver.load_strategy(default_conf_usdt)\n    x = get_strategy_run_id(strategy)\n    assert isinstance(x, str)"
        ]
    },
    {
        "func_name": "test_get_backtest_metadata_filename",
        "original": "def test_get_backtest_metadata_filename():\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('/path/to/backtest.results.json')\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results.json'\n    expected = Path('/path/to/backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results'\n    expected = Path('/path/to/backtest_results.meta')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest.results.json'\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = 'backtest_results.json'\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected",
        "mutated": [
            "def test_get_backtest_metadata_filename():\n    if False:\n        i = 10\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('/path/to/backtest.results.json')\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results.json'\n    expected = Path('/path/to/backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results'\n    expected = Path('/path/to/backtest_results.meta')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest.results.json'\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = 'backtest_results.json'\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected",
            "def test_get_backtest_metadata_filename():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('/path/to/backtest.results.json')\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results.json'\n    expected = Path('/path/to/backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results'\n    expected = Path('/path/to/backtest_results.meta')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest.results.json'\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = 'backtest_results.json'\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected",
            "def test_get_backtest_metadata_filename():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('/path/to/backtest.results.json')\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results.json'\n    expected = Path('/path/to/backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results'\n    expected = Path('/path/to/backtest_results.meta')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest.results.json'\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = 'backtest_results.json'\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected",
            "def test_get_backtest_metadata_filename():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('/path/to/backtest.results.json')\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results.json'\n    expected = Path('/path/to/backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results'\n    expected = Path('/path/to/backtest_results.meta')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest.results.json'\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = 'backtest_results.json'\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected",
            "def test_get_backtest_metadata_filename():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('/path/to/backtest.results.json')\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = Path('backtest_results.json')\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results.json'\n    expected = Path('/path/to/backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest_results'\n    expected = Path('/path/to/backtest_results.meta')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = '/path/to/backtest.results.json'\n    expected = Path('/path/to/backtest.results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected\n    filename = 'backtest_results.json'\n    expected = Path('backtest_results.meta.json')\n    assert get_backtest_metadata_filename(filename) == expected"
        ]
    }
]