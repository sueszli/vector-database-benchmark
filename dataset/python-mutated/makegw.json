[
    {
        "func_name": "make_framework_support",
        "original": "def make_framework_support(header_file_name, interface_name, bMakeInterface=1, bMakeGateway=1):\n    \"\"\"Generate C++ code for a Python Interface and Gateway\n\n    header_file_name -- The full path to the .H file which defines the interface.\n    interface_name -- The name of the interface to search for, and to generate.\n    bMakeInterface = 1 -- Should interface (ie, client) support be generated.\n    bMakeGatewayInterface = 1 -- Should gateway (ie, server) support be generated.\n\n    This method will write a .cpp and .h file into the current directory,\n    (using the name of the interface to build the file name.\n\n    \"\"\"\n    fin = open(header_file_name)\n    try:\n        interface = makegwparse.parse_interface_info(interface_name, fin)\n    finally:\n        fin.close()\n    if bMakeInterface and bMakeGateway:\n        desc = 'Interface and Gateway'\n    elif bMakeInterface and (not bMakeGateway):\n        desc = 'Interface'\n    else:\n        desc = 'Gateway'\n    if interface.name[:5] == 'IEnum':\n        import win32com.makegw.makegwenum\n        ifc_cpp_writer = win32com.makegw.makegwenum._write_enumifc_cpp\n        gw_cpp_writer = win32com.makegw.makegwenum._write_enumgw_cpp\n    else:\n        ifc_cpp_writer = _write_ifc_cpp\n        gw_cpp_writer = _write_gw_cpp\n    fout = open('Py%s.cpp' % interface.name, 'w')\n    try:\n        fout.write(f'// This file implements the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n\\n#include \"shell_pch.h\"\\n')\n        fout.write('#include \"Py%s.h\"\\n\\n// @doc - This file contains autoduck documentation\\n' % interface.name)\n        if bMakeInterface:\n            ifc_cpp_writer(fout, interface)\n        if bMakeGateway:\n            gw_cpp_writer(fout, interface)\n    finally:\n        fout.close()\n    fout = open('Py%s.h' % interface.name, 'w')\n    try:\n        fout.write(f'// This file declares the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n')\n        if bMakeInterface:\n            _write_ifc_h(fout, interface)\n        if bMakeGateway:\n            _write_gw_h(fout, interface)\n    finally:\n        fout.close()",
        "mutated": [
            "def make_framework_support(header_file_name, interface_name, bMakeInterface=1, bMakeGateway=1):\n    if False:\n        i = 10\n    'Generate C++ code for a Python Interface and Gateway\\n\\n    header_file_name -- The full path to the .H file which defines the interface.\\n    interface_name -- The name of the interface to search for, and to generate.\\n    bMakeInterface = 1 -- Should interface (ie, client) support be generated.\\n    bMakeGatewayInterface = 1 -- Should gateway (ie, server) support be generated.\\n\\n    This method will write a .cpp and .h file into the current directory,\\n    (using the name of the interface to build the file name.\\n\\n    '\n    fin = open(header_file_name)\n    try:\n        interface = makegwparse.parse_interface_info(interface_name, fin)\n    finally:\n        fin.close()\n    if bMakeInterface and bMakeGateway:\n        desc = 'Interface and Gateway'\n    elif bMakeInterface and (not bMakeGateway):\n        desc = 'Interface'\n    else:\n        desc = 'Gateway'\n    if interface.name[:5] == 'IEnum':\n        import win32com.makegw.makegwenum\n        ifc_cpp_writer = win32com.makegw.makegwenum._write_enumifc_cpp\n        gw_cpp_writer = win32com.makegw.makegwenum._write_enumgw_cpp\n    else:\n        ifc_cpp_writer = _write_ifc_cpp\n        gw_cpp_writer = _write_gw_cpp\n    fout = open('Py%s.cpp' % interface.name, 'w')\n    try:\n        fout.write(f'// This file implements the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n\\n#include \"shell_pch.h\"\\n')\n        fout.write('#include \"Py%s.h\"\\n\\n// @doc - This file contains autoduck documentation\\n' % interface.name)\n        if bMakeInterface:\n            ifc_cpp_writer(fout, interface)\n        if bMakeGateway:\n            gw_cpp_writer(fout, interface)\n    finally:\n        fout.close()\n    fout = open('Py%s.h' % interface.name, 'w')\n    try:\n        fout.write(f'// This file declares the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n')\n        if bMakeInterface:\n            _write_ifc_h(fout, interface)\n        if bMakeGateway:\n            _write_gw_h(fout, interface)\n    finally:\n        fout.close()",
            "def make_framework_support(header_file_name, interface_name, bMakeInterface=1, bMakeGateway=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate C++ code for a Python Interface and Gateway\\n\\n    header_file_name -- The full path to the .H file which defines the interface.\\n    interface_name -- The name of the interface to search for, and to generate.\\n    bMakeInterface = 1 -- Should interface (ie, client) support be generated.\\n    bMakeGatewayInterface = 1 -- Should gateway (ie, server) support be generated.\\n\\n    This method will write a .cpp and .h file into the current directory,\\n    (using the name of the interface to build the file name.\\n\\n    '\n    fin = open(header_file_name)\n    try:\n        interface = makegwparse.parse_interface_info(interface_name, fin)\n    finally:\n        fin.close()\n    if bMakeInterface and bMakeGateway:\n        desc = 'Interface and Gateway'\n    elif bMakeInterface and (not bMakeGateway):\n        desc = 'Interface'\n    else:\n        desc = 'Gateway'\n    if interface.name[:5] == 'IEnum':\n        import win32com.makegw.makegwenum\n        ifc_cpp_writer = win32com.makegw.makegwenum._write_enumifc_cpp\n        gw_cpp_writer = win32com.makegw.makegwenum._write_enumgw_cpp\n    else:\n        ifc_cpp_writer = _write_ifc_cpp\n        gw_cpp_writer = _write_gw_cpp\n    fout = open('Py%s.cpp' % interface.name, 'w')\n    try:\n        fout.write(f'// This file implements the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n\\n#include \"shell_pch.h\"\\n')\n        fout.write('#include \"Py%s.h\"\\n\\n// @doc - This file contains autoduck documentation\\n' % interface.name)\n        if bMakeInterface:\n            ifc_cpp_writer(fout, interface)\n        if bMakeGateway:\n            gw_cpp_writer(fout, interface)\n    finally:\n        fout.close()\n    fout = open('Py%s.h' % interface.name, 'w')\n    try:\n        fout.write(f'// This file declares the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n')\n        if bMakeInterface:\n            _write_ifc_h(fout, interface)\n        if bMakeGateway:\n            _write_gw_h(fout, interface)\n    finally:\n        fout.close()",
            "def make_framework_support(header_file_name, interface_name, bMakeInterface=1, bMakeGateway=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate C++ code for a Python Interface and Gateway\\n\\n    header_file_name -- The full path to the .H file which defines the interface.\\n    interface_name -- The name of the interface to search for, and to generate.\\n    bMakeInterface = 1 -- Should interface (ie, client) support be generated.\\n    bMakeGatewayInterface = 1 -- Should gateway (ie, server) support be generated.\\n\\n    This method will write a .cpp and .h file into the current directory,\\n    (using the name of the interface to build the file name.\\n\\n    '\n    fin = open(header_file_name)\n    try:\n        interface = makegwparse.parse_interface_info(interface_name, fin)\n    finally:\n        fin.close()\n    if bMakeInterface and bMakeGateway:\n        desc = 'Interface and Gateway'\n    elif bMakeInterface and (not bMakeGateway):\n        desc = 'Interface'\n    else:\n        desc = 'Gateway'\n    if interface.name[:5] == 'IEnum':\n        import win32com.makegw.makegwenum\n        ifc_cpp_writer = win32com.makegw.makegwenum._write_enumifc_cpp\n        gw_cpp_writer = win32com.makegw.makegwenum._write_enumgw_cpp\n    else:\n        ifc_cpp_writer = _write_ifc_cpp\n        gw_cpp_writer = _write_gw_cpp\n    fout = open('Py%s.cpp' % interface.name, 'w')\n    try:\n        fout.write(f'// This file implements the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n\\n#include \"shell_pch.h\"\\n')\n        fout.write('#include \"Py%s.h\"\\n\\n// @doc - This file contains autoduck documentation\\n' % interface.name)\n        if bMakeInterface:\n            ifc_cpp_writer(fout, interface)\n        if bMakeGateway:\n            gw_cpp_writer(fout, interface)\n    finally:\n        fout.close()\n    fout = open('Py%s.h' % interface.name, 'w')\n    try:\n        fout.write(f'// This file declares the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n')\n        if bMakeInterface:\n            _write_ifc_h(fout, interface)\n        if bMakeGateway:\n            _write_gw_h(fout, interface)\n    finally:\n        fout.close()",
            "def make_framework_support(header_file_name, interface_name, bMakeInterface=1, bMakeGateway=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate C++ code for a Python Interface and Gateway\\n\\n    header_file_name -- The full path to the .H file which defines the interface.\\n    interface_name -- The name of the interface to search for, and to generate.\\n    bMakeInterface = 1 -- Should interface (ie, client) support be generated.\\n    bMakeGatewayInterface = 1 -- Should gateway (ie, server) support be generated.\\n\\n    This method will write a .cpp and .h file into the current directory,\\n    (using the name of the interface to build the file name.\\n\\n    '\n    fin = open(header_file_name)\n    try:\n        interface = makegwparse.parse_interface_info(interface_name, fin)\n    finally:\n        fin.close()\n    if bMakeInterface and bMakeGateway:\n        desc = 'Interface and Gateway'\n    elif bMakeInterface and (not bMakeGateway):\n        desc = 'Interface'\n    else:\n        desc = 'Gateway'\n    if interface.name[:5] == 'IEnum':\n        import win32com.makegw.makegwenum\n        ifc_cpp_writer = win32com.makegw.makegwenum._write_enumifc_cpp\n        gw_cpp_writer = win32com.makegw.makegwenum._write_enumgw_cpp\n    else:\n        ifc_cpp_writer = _write_ifc_cpp\n        gw_cpp_writer = _write_gw_cpp\n    fout = open('Py%s.cpp' % interface.name, 'w')\n    try:\n        fout.write(f'// This file implements the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n\\n#include \"shell_pch.h\"\\n')\n        fout.write('#include \"Py%s.h\"\\n\\n// @doc - This file contains autoduck documentation\\n' % interface.name)\n        if bMakeInterface:\n            ifc_cpp_writer(fout, interface)\n        if bMakeGateway:\n            gw_cpp_writer(fout, interface)\n    finally:\n        fout.close()\n    fout = open('Py%s.h' % interface.name, 'w')\n    try:\n        fout.write(f'// This file declares the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n')\n        if bMakeInterface:\n            _write_ifc_h(fout, interface)\n        if bMakeGateway:\n            _write_gw_h(fout, interface)\n    finally:\n        fout.close()",
            "def make_framework_support(header_file_name, interface_name, bMakeInterface=1, bMakeGateway=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate C++ code for a Python Interface and Gateway\\n\\n    header_file_name -- The full path to the .H file which defines the interface.\\n    interface_name -- The name of the interface to search for, and to generate.\\n    bMakeInterface = 1 -- Should interface (ie, client) support be generated.\\n    bMakeGatewayInterface = 1 -- Should gateway (ie, server) support be generated.\\n\\n    This method will write a .cpp and .h file into the current directory,\\n    (using the name of the interface to build the file name.\\n\\n    '\n    fin = open(header_file_name)\n    try:\n        interface = makegwparse.parse_interface_info(interface_name, fin)\n    finally:\n        fin.close()\n    if bMakeInterface and bMakeGateway:\n        desc = 'Interface and Gateway'\n    elif bMakeInterface and (not bMakeGateway):\n        desc = 'Interface'\n    else:\n        desc = 'Gateway'\n    if interface.name[:5] == 'IEnum':\n        import win32com.makegw.makegwenum\n        ifc_cpp_writer = win32com.makegw.makegwenum._write_enumifc_cpp\n        gw_cpp_writer = win32com.makegw.makegwenum._write_enumgw_cpp\n    else:\n        ifc_cpp_writer = _write_ifc_cpp\n        gw_cpp_writer = _write_gw_cpp\n    fout = open('Py%s.cpp' % interface.name, 'w')\n    try:\n        fout.write(f'// This file implements the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n\\n#include \"shell_pch.h\"\\n')\n        fout.write('#include \"Py%s.h\"\\n\\n// @doc - This file contains autoduck documentation\\n' % interface.name)\n        if bMakeInterface:\n            ifc_cpp_writer(fout, interface)\n        if bMakeGateway:\n            gw_cpp_writer(fout, interface)\n    finally:\n        fout.close()\n    fout = open('Py%s.h' % interface.name, 'w')\n    try:\n        fout.write(f'// This file declares the {interface.name} {desc} for Python.\\n// Generated by makegw.py\\n')\n        if bMakeInterface:\n            _write_ifc_h(fout, interface)\n        if bMakeGateway:\n            _write_gw_h(fout, interface)\n    finally:\n        fout.close()"
        ]
    },
    {
        "func_name": "_write_ifc_h",
        "original": "def _write_ifc_h(f, interface):\n    f.write(f'// ---------------------------------------------------\\n//\\n// Interface Declaration\\n\\nclass Py{interface.name} : public Py{interface.base}\\n{{\\npublic:\\n\\tMAKE_PYCOM_CTOR(Py{interface.name});\\n\\tstatic {interface.name} *GetI(PyObject *self);\\n\\tstatic PyComTypeObject type;\\n\\n\\t// The Python methods\\n')\n    for method in interface.methods:\n        f.write('\\tstatic PyObject *%s(PyObject *self, PyObject *args);\\n' % method.name)\n    f.write(f'\\nprotected:\\n\\tPy{interface.name}(IUnknown *pdisp);\\n\\t~Py{interface.name}();\\n}};\\n')",
        "mutated": [
            "def _write_ifc_h(f, interface):\n    if False:\n        i = 10\n    f.write(f'// ---------------------------------------------------\\n//\\n// Interface Declaration\\n\\nclass Py{interface.name} : public Py{interface.base}\\n{{\\npublic:\\n\\tMAKE_PYCOM_CTOR(Py{interface.name});\\n\\tstatic {interface.name} *GetI(PyObject *self);\\n\\tstatic PyComTypeObject type;\\n\\n\\t// The Python methods\\n')\n    for method in interface.methods:\n        f.write('\\tstatic PyObject *%s(PyObject *self, PyObject *args);\\n' % method.name)\n    f.write(f'\\nprotected:\\n\\tPy{interface.name}(IUnknown *pdisp);\\n\\t~Py{interface.name}();\\n}};\\n')",
            "def _write_ifc_h(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    f.write(f'// ---------------------------------------------------\\n//\\n// Interface Declaration\\n\\nclass Py{interface.name} : public Py{interface.base}\\n{{\\npublic:\\n\\tMAKE_PYCOM_CTOR(Py{interface.name});\\n\\tstatic {interface.name} *GetI(PyObject *self);\\n\\tstatic PyComTypeObject type;\\n\\n\\t// The Python methods\\n')\n    for method in interface.methods:\n        f.write('\\tstatic PyObject *%s(PyObject *self, PyObject *args);\\n' % method.name)\n    f.write(f'\\nprotected:\\n\\tPy{interface.name}(IUnknown *pdisp);\\n\\t~Py{interface.name}();\\n}};\\n')",
            "def _write_ifc_h(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    f.write(f'// ---------------------------------------------------\\n//\\n// Interface Declaration\\n\\nclass Py{interface.name} : public Py{interface.base}\\n{{\\npublic:\\n\\tMAKE_PYCOM_CTOR(Py{interface.name});\\n\\tstatic {interface.name} *GetI(PyObject *self);\\n\\tstatic PyComTypeObject type;\\n\\n\\t// The Python methods\\n')\n    for method in interface.methods:\n        f.write('\\tstatic PyObject *%s(PyObject *self, PyObject *args);\\n' % method.name)\n    f.write(f'\\nprotected:\\n\\tPy{interface.name}(IUnknown *pdisp);\\n\\t~Py{interface.name}();\\n}};\\n')",
            "def _write_ifc_h(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    f.write(f'// ---------------------------------------------------\\n//\\n// Interface Declaration\\n\\nclass Py{interface.name} : public Py{interface.base}\\n{{\\npublic:\\n\\tMAKE_PYCOM_CTOR(Py{interface.name});\\n\\tstatic {interface.name} *GetI(PyObject *self);\\n\\tstatic PyComTypeObject type;\\n\\n\\t// The Python methods\\n')\n    for method in interface.methods:\n        f.write('\\tstatic PyObject *%s(PyObject *self, PyObject *args);\\n' % method.name)\n    f.write(f'\\nprotected:\\n\\tPy{interface.name}(IUnknown *pdisp);\\n\\t~Py{interface.name}();\\n}};\\n')",
            "def _write_ifc_h(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    f.write(f'// ---------------------------------------------------\\n//\\n// Interface Declaration\\n\\nclass Py{interface.name} : public Py{interface.base}\\n{{\\npublic:\\n\\tMAKE_PYCOM_CTOR(Py{interface.name});\\n\\tstatic {interface.name} *GetI(PyObject *self);\\n\\tstatic PyComTypeObject type;\\n\\n\\t// The Python methods\\n')\n    for method in interface.methods:\n        f.write('\\tstatic PyObject *%s(PyObject *self, PyObject *args);\\n' % method.name)\n    f.write(f'\\nprotected:\\n\\tPy{interface.name}(IUnknown *pdisp);\\n\\t~Py{interface.name}();\\n}};\\n')"
        ]
    },
    {
        "func_name": "_write_ifc_cpp",
        "original": "def _write_ifc_cpp(f, interface):\n    name = interface.name\n    f.write('// ---------------------------------------------------\\n//\\n// Interface Implementation\\n\\nPy{name}::Py{name}(IUnknown *pdisp):\\n\\tPy{base}(pdisp)\\n{{\\n\\tob_type = &type;\\n}}\\n\\nPy{name}::~Py{name}()\\n{{\\n}}\\n\\n/* static */ {name} *Py{name}::GetI(PyObject *self)\\n{{\\n\\treturn ({name} *)Py{base}::GetI(self);\\n}}\\n\\n'.format(**interface.__dict__))\n    ptr = re.sub('[a-z]', '', interface.name)\n    strdict = {'interfacename': interface.name, 'ptr': ptr}\n    for method in interface.methods:\n        strdict['method'] = method.name\n        f.write('// @pymethod |Py{interfacename}|{method}|Description of {method}.\\nPyObject *Py{interfacename}::{method}(PyObject *self, PyObject *args)\\n{{\\n\\t{interfacename} *p{ptr} = GetI(self);\\n\\tif ( p{ptr} == NULL )\\n\\t\\treturn NULL;\\n'.format(**strdict))\n        argsParseTuple = argsCOM = formatChars = codePost = codePobjects = codeCobjects = cleanup = cleanup_gil = ''\n        needConversion = 0\n        for arg in method.args:\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                if arg.HasAttribute('in'):\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        f.write('\\t' + argCvt.GetAutoduckString() + '\\n')\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        cleanup = cleanup + argCvt.GetInterfaceArgCleanup()\n                        cleanup_gil = cleanup_gil + argCvt.GetInterfaceArgCleanupGIL()\n                (comArgName, comArgDeclString) = argCvt.GetInterfaceCppObjectInfo()\n                if comArgDeclString:\n                    codeCobjects = codeCobjects + '\\t%s;\\n' % comArgDeclString\n                argsCOM = argsCOM + ', ' + comArgName\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//     Please check the conversion function is appropriate and exists!\\n'.format(arg.name, arg.raw_type))\n                f.write(f'\\t{arg.type} {arg.name};\\n\\tPyObject *ob{arg.name};\\n')\n                f.write('\\t// @pyparm <o Py{}>|{}||Description for {}\\n'.format(arg.type, arg.name, arg.name))\n                codePost = codePost + '\\tif (bPythonIsHappy && !PyObject_As{}( ob{}, &{} )) bPythonIsHappy = FALSE;\\n'.format(arg.type, arg.name, arg.name)\n                formatChars = formatChars + 'O'\n                argsParseTuple = argsParseTuple + ', &ob%s' % arg.name\n                argsCOM = argsCOM + ', ' + arg.name\n                cleanup = cleanup + f'\\tPyObject_Free{arg.type}({arg.name});\\n'\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codePobjects)\n        f.write(codeCobjects)\n        f.write('\\tif ( !PyArg_ParseTuple(args, \"{}:{}\"{}) )\\n\\t\\treturn NULL;\\n'.format(formatChars, method.name, argsParseTuple))\n        if codePost:\n            f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n            f.write(codePost)\n            f.write('\\tif (!bPythonIsHappy) return NULL;\\n')\n        strdict['argsCOM'] = argsCOM[1:]\n        strdict['cleanup'] = cleanup\n        strdict['cleanup_gil'] = cleanup_gil\n        f.write('\\tHRESULT hr;\\n\\tPY_INTERFACE_PRECALL;\\n\\thr = p{ptr}->{method}({argsCOM} );\\n{cleanup}\\n\\tPY_INTERFACE_POSTCALL;\\n{cleanup_gil}\\n\\tif ( FAILED(hr) )\\n\\t\\treturn PyCom_BuildPyException(hr, p{ptr}, IID_{interfacename} );\\n'.format(**strdict))\n        codePre = codePost = formatChars = codeVarsPass = codeDecl = ''\n        for arg in method.args:\n            if not arg.HasAttribute('out'):\n                continue\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                formatChar = argCvt.GetFormatChar()\n                if formatChar:\n                    formatChars = formatChars + formatChar\n                    codePre = codePre + argCvt.GetBuildForInterfacePreCode()\n                    codePost = codePost + argCvt.GetBuildForInterfacePostCode()\n                    codeVarsPass = codeVarsPass + ', ' + argCvt.GetBuildValueArg()\n                    codeDecl = codeDecl + argCvt.DeclareParseArgTupleInputConverter()\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n                continue\n        if formatChars:\n            f.write('{}\\n{}\\tPyObject *pyretval = Py_BuildValue(\"{}\"{});\\n{}\\treturn pyretval;'.format(codeDecl, codePre, formatChars, codeVarsPass, codePost))\n        else:\n            f.write('\\tPy_INCREF(Py_None);\\n\\treturn Py_None;\\n')\n        f.write('\\n}\\n\\n')\n    f.write('// @object Py%s|Description of the interface\\n' % name)\n    f.write('static struct PyMethodDef Py%s_methods[] =\\n{\\n' % name)\n    for method in interface.methods:\n        f.write('\\t{{ \"{}\", Py{}::{}, 1 }}, // @pymeth {}|Description of {}\\n'.format(method.name, interface.name, method.name, method.name, method.name))\n    interfacebase = interface.base\n    f.write('\\t{{ NULL }}\\n}};\\n\\nPyComTypeObject Py{name}::type(\"Py{name}\",\\n\\t\\t&Py{interfacebase}::type,\\n\\t\\tsizeof(Py{name}),\\n\\t\\tPy{name}_methods,\\n\\t\\tGET_PYCOM_CTOR(Py{name}));\\n'.format(**locals()))",
        "mutated": [
            "def _write_ifc_cpp(f, interface):\n    if False:\n        i = 10\n    name = interface.name\n    f.write('// ---------------------------------------------------\\n//\\n// Interface Implementation\\n\\nPy{name}::Py{name}(IUnknown *pdisp):\\n\\tPy{base}(pdisp)\\n{{\\n\\tob_type = &type;\\n}}\\n\\nPy{name}::~Py{name}()\\n{{\\n}}\\n\\n/* static */ {name} *Py{name}::GetI(PyObject *self)\\n{{\\n\\treturn ({name} *)Py{base}::GetI(self);\\n}}\\n\\n'.format(**interface.__dict__))\n    ptr = re.sub('[a-z]', '', interface.name)\n    strdict = {'interfacename': interface.name, 'ptr': ptr}\n    for method in interface.methods:\n        strdict['method'] = method.name\n        f.write('// @pymethod |Py{interfacename}|{method}|Description of {method}.\\nPyObject *Py{interfacename}::{method}(PyObject *self, PyObject *args)\\n{{\\n\\t{interfacename} *p{ptr} = GetI(self);\\n\\tif ( p{ptr} == NULL )\\n\\t\\treturn NULL;\\n'.format(**strdict))\n        argsParseTuple = argsCOM = formatChars = codePost = codePobjects = codeCobjects = cleanup = cleanup_gil = ''\n        needConversion = 0\n        for arg in method.args:\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                if arg.HasAttribute('in'):\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        f.write('\\t' + argCvt.GetAutoduckString() + '\\n')\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        cleanup = cleanup + argCvt.GetInterfaceArgCleanup()\n                        cleanup_gil = cleanup_gil + argCvt.GetInterfaceArgCleanupGIL()\n                (comArgName, comArgDeclString) = argCvt.GetInterfaceCppObjectInfo()\n                if comArgDeclString:\n                    codeCobjects = codeCobjects + '\\t%s;\\n' % comArgDeclString\n                argsCOM = argsCOM + ', ' + comArgName\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//     Please check the conversion function is appropriate and exists!\\n'.format(arg.name, arg.raw_type))\n                f.write(f'\\t{arg.type} {arg.name};\\n\\tPyObject *ob{arg.name};\\n')\n                f.write('\\t// @pyparm <o Py{}>|{}||Description for {}\\n'.format(arg.type, arg.name, arg.name))\n                codePost = codePost + '\\tif (bPythonIsHappy && !PyObject_As{}( ob{}, &{} )) bPythonIsHappy = FALSE;\\n'.format(arg.type, arg.name, arg.name)\n                formatChars = formatChars + 'O'\n                argsParseTuple = argsParseTuple + ', &ob%s' % arg.name\n                argsCOM = argsCOM + ', ' + arg.name\n                cleanup = cleanup + f'\\tPyObject_Free{arg.type}({arg.name});\\n'\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codePobjects)\n        f.write(codeCobjects)\n        f.write('\\tif ( !PyArg_ParseTuple(args, \"{}:{}\"{}) )\\n\\t\\treturn NULL;\\n'.format(formatChars, method.name, argsParseTuple))\n        if codePost:\n            f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n            f.write(codePost)\n            f.write('\\tif (!bPythonIsHappy) return NULL;\\n')\n        strdict['argsCOM'] = argsCOM[1:]\n        strdict['cleanup'] = cleanup\n        strdict['cleanup_gil'] = cleanup_gil\n        f.write('\\tHRESULT hr;\\n\\tPY_INTERFACE_PRECALL;\\n\\thr = p{ptr}->{method}({argsCOM} );\\n{cleanup}\\n\\tPY_INTERFACE_POSTCALL;\\n{cleanup_gil}\\n\\tif ( FAILED(hr) )\\n\\t\\treturn PyCom_BuildPyException(hr, p{ptr}, IID_{interfacename} );\\n'.format(**strdict))\n        codePre = codePost = formatChars = codeVarsPass = codeDecl = ''\n        for arg in method.args:\n            if not arg.HasAttribute('out'):\n                continue\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                formatChar = argCvt.GetFormatChar()\n                if formatChar:\n                    formatChars = formatChars + formatChar\n                    codePre = codePre + argCvt.GetBuildForInterfacePreCode()\n                    codePost = codePost + argCvt.GetBuildForInterfacePostCode()\n                    codeVarsPass = codeVarsPass + ', ' + argCvt.GetBuildValueArg()\n                    codeDecl = codeDecl + argCvt.DeclareParseArgTupleInputConverter()\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n                continue\n        if formatChars:\n            f.write('{}\\n{}\\tPyObject *pyretval = Py_BuildValue(\"{}\"{});\\n{}\\treturn pyretval;'.format(codeDecl, codePre, formatChars, codeVarsPass, codePost))\n        else:\n            f.write('\\tPy_INCREF(Py_None);\\n\\treturn Py_None;\\n')\n        f.write('\\n}\\n\\n')\n    f.write('// @object Py%s|Description of the interface\\n' % name)\n    f.write('static struct PyMethodDef Py%s_methods[] =\\n{\\n' % name)\n    for method in interface.methods:\n        f.write('\\t{{ \"{}\", Py{}::{}, 1 }}, // @pymeth {}|Description of {}\\n'.format(method.name, interface.name, method.name, method.name, method.name))\n    interfacebase = interface.base\n    f.write('\\t{{ NULL }}\\n}};\\n\\nPyComTypeObject Py{name}::type(\"Py{name}\",\\n\\t\\t&Py{interfacebase}::type,\\n\\t\\tsizeof(Py{name}),\\n\\t\\tPy{name}_methods,\\n\\t\\tGET_PYCOM_CTOR(Py{name}));\\n'.format(**locals()))",
            "def _write_ifc_cpp(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    name = interface.name\n    f.write('// ---------------------------------------------------\\n//\\n// Interface Implementation\\n\\nPy{name}::Py{name}(IUnknown *pdisp):\\n\\tPy{base}(pdisp)\\n{{\\n\\tob_type = &type;\\n}}\\n\\nPy{name}::~Py{name}()\\n{{\\n}}\\n\\n/* static */ {name} *Py{name}::GetI(PyObject *self)\\n{{\\n\\treturn ({name} *)Py{base}::GetI(self);\\n}}\\n\\n'.format(**interface.__dict__))\n    ptr = re.sub('[a-z]', '', interface.name)\n    strdict = {'interfacename': interface.name, 'ptr': ptr}\n    for method in interface.methods:\n        strdict['method'] = method.name\n        f.write('// @pymethod |Py{interfacename}|{method}|Description of {method}.\\nPyObject *Py{interfacename}::{method}(PyObject *self, PyObject *args)\\n{{\\n\\t{interfacename} *p{ptr} = GetI(self);\\n\\tif ( p{ptr} == NULL )\\n\\t\\treturn NULL;\\n'.format(**strdict))\n        argsParseTuple = argsCOM = formatChars = codePost = codePobjects = codeCobjects = cleanup = cleanup_gil = ''\n        needConversion = 0\n        for arg in method.args:\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                if arg.HasAttribute('in'):\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        f.write('\\t' + argCvt.GetAutoduckString() + '\\n')\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        cleanup = cleanup + argCvt.GetInterfaceArgCleanup()\n                        cleanup_gil = cleanup_gil + argCvt.GetInterfaceArgCleanupGIL()\n                (comArgName, comArgDeclString) = argCvt.GetInterfaceCppObjectInfo()\n                if comArgDeclString:\n                    codeCobjects = codeCobjects + '\\t%s;\\n' % comArgDeclString\n                argsCOM = argsCOM + ', ' + comArgName\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//     Please check the conversion function is appropriate and exists!\\n'.format(arg.name, arg.raw_type))\n                f.write(f'\\t{arg.type} {arg.name};\\n\\tPyObject *ob{arg.name};\\n')\n                f.write('\\t// @pyparm <o Py{}>|{}||Description for {}\\n'.format(arg.type, arg.name, arg.name))\n                codePost = codePost + '\\tif (bPythonIsHappy && !PyObject_As{}( ob{}, &{} )) bPythonIsHappy = FALSE;\\n'.format(arg.type, arg.name, arg.name)\n                formatChars = formatChars + 'O'\n                argsParseTuple = argsParseTuple + ', &ob%s' % arg.name\n                argsCOM = argsCOM + ', ' + arg.name\n                cleanup = cleanup + f'\\tPyObject_Free{arg.type}({arg.name});\\n'\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codePobjects)\n        f.write(codeCobjects)\n        f.write('\\tif ( !PyArg_ParseTuple(args, \"{}:{}\"{}) )\\n\\t\\treturn NULL;\\n'.format(formatChars, method.name, argsParseTuple))\n        if codePost:\n            f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n            f.write(codePost)\n            f.write('\\tif (!bPythonIsHappy) return NULL;\\n')\n        strdict['argsCOM'] = argsCOM[1:]\n        strdict['cleanup'] = cleanup\n        strdict['cleanup_gil'] = cleanup_gil\n        f.write('\\tHRESULT hr;\\n\\tPY_INTERFACE_PRECALL;\\n\\thr = p{ptr}->{method}({argsCOM} );\\n{cleanup}\\n\\tPY_INTERFACE_POSTCALL;\\n{cleanup_gil}\\n\\tif ( FAILED(hr) )\\n\\t\\treturn PyCom_BuildPyException(hr, p{ptr}, IID_{interfacename} );\\n'.format(**strdict))\n        codePre = codePost = formatChars = codeVarsPass = codeDecl = ''\n        for arg in method.args:\n            if not arg.HasAttribute('out'):\n                continue\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                formatChar = argCvt.GetFormatChar()\n                if formatChar:\n                    formatChars = formatChars + formatChar\n                    codePre = codePre + argCvt.GetBuildForInterfacePreCode()\n                    codePost = codePost + argCvt.GetBuildForInterfacePostCode()\n                    codeVarsPass = codeVarsPass + ', ' + argCvt.GetBuildValueArg()\n                    codeDecl = codeDecl + argCvt.DeclareParseArgTupleInputConverter()\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n                continue\n        if formatChars:\n            f.write('{}\\n{}\\tPyObject *pyretval = Py_BuildValue(\"{}\"{});\\n{}\\treturn pyretval;'.format(codeDecl, codePre, formatChars, codeVarsPass, codePost))\n        else:\n            f.write('\\tPy_INCREF(Py_None);\\n\\treturn Py_None;\\n')\n        f.write('\\n}\\n\\n')\n    f.write('// @object Py%s|Description of the interface\\n' % name)\n    f.write('static struct PyMethodDef Py%s_methods[] =\\n{\\n' % name)\n    for method in interface.methods:\n        f.write('\\t{{ \"{}\", Py{}::{}, 1 }}, // @pymeth {}|Description of {}\\n'.format(method.name, interface.name, method.name, method.name, method.name))\n    interfacebase = interface.base\n    f.write('\\t{{ NULL }}\\n}};\\n\\nPyComTypeObject Py{name}::type(\"Py{name}\",\\n\\t\\t&Py{interfacebase}::type,\\n\\t\\tsizeof(Py{name}),\\n\\t\\tPy{name}_methods,\\n\\t\\tGET_PYCOM_CTOR(Py{name}));\\n'.format(**locals()))",
            "def _write_ifc_cpp(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    name = interface.name\n    f.write('// ---------------------------------------------------\\n//\\n// Interface Implementation\\n\\nPy{name}::Py{name}(IUnknown *pdisp):\\n\\tPy{base}(pdisp)\\n{{\\n\\tob_type = &type;\\n}}\\n\\nPy{name}::~Py{name}()\\n{{\\n}}\\n\\n/* static */ {name} *Py{name}::GetI(PyObject *self)\\n{{\\n\\treturn ({name} *)Py{base}::GetI(self);\\n}}\\n\\n'.format(**interface.__dict__))\n    ptr = re.sub('[a-z]', '', interface.name)\n    strdict = {'interfacename': interface.name, 'ptr': ptr}\n    for method in interface.methods:\n        strdict['method'] = method.name\n        f.write('// @pymethod |Py{interfacename}|{method}|Description of {method}.\\nPyObject *Py{interfacename}::{method}(PyObject *self, PyObject *args)\\n{{\\n\\t{interfacename} *p{ptr} = GetI(self);\\n\\tif ( p{ptr} == NULL )\\n\\t\\treturn NULL;\\n'.format(**strdict))\n        argsParseTuple = argsCOM = formatChars = codePost = codePobjects = codeCobjects = cleanup = cleanup_gil = ''\n        needConversion = 0\n        for arg in method.args:\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                if arg.HasAttribute('in'):\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        f.write('\\t' + argCvt.GetAutoduckString() + '\\n')\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        cleanup = cleanup + argCvt.GetInterfaceArgCleanup()\n                        cleanup_gil = cleanup_gil + argCvt.GetInterfaceArgCleanupGIL()\n                (comArgName, comArgDeclString) = argCvt.GetInterfaceCppObjectInfo()\n                if comArgDeclString:\n                    codeCobjects = codeCobjects + '\\t%s;\\n' % comArgDeclString\n                argsCOM = argsCOM + ', ' + comArgName\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//     Please check the conversion function is appropriate and exists!\\n'.format(arg.name, arg.raw_type))\n                f.write(f'\\t{arg.type} {arg.name};\\n\\tPyObject *ob{arg.name};\\n')\n                f.write('\\t// @pyparm <o Py{}>|{}||Description for {}\\n'.format(arg.type, arg.name, arg.name))\n                codePost = codePost + '\\tif (bPythonIsHappy && !PyObject_As{}( ob{}, &{} )) bPythonIsHappy = FALSE;\\n'.format(arg.type, arg.name, arg.name)\n                formatChars = formatChars + 'O'\n                argsParseTuple = argsParseTuple + ', &ob%s' % arg.name\n                argsCOM = argsCOM + ', ' + arg.name\n                cleanup = cleanup + f'\\tPyObject_Free{arg.type}({arg.name});\\n'\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codePobjects)\n        f.write(codeCobjects)\n        f.write('\\tif ( !PyArg_ParseTuple(args, \"{}:{}\"{}) )\\n\\t\\treturn NULL;\\n'.format(formatChars, method.name, argsParseTuple))\n        if codePost:\n            f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n            f.write(codePost)\n            f.write('\\tif (!bPythonIsHappy) return NULL;\\n')\n        strdict['argsCOM'] = argsCOM[1:]\n        strdict['cleanup'] = cleanup\n        strdict['cleanup_gil'] = cleanup_gil\n        f.write('\\tHRESULT hr;\\n\\tPY_INTERFACE_PRECALL;\\n\\thr = p{ptr}->{method}({argsCOM} );\\n{cleanup}\\n\\tPY_INTERFACE_POSTCALL;\\n{cleanup_gil}\\n\\tif ( FAILED(hr) )\\n\\t\\treturn PyCom_BuildPyException(hr, p{ptr}, IID_{interfacename} );\\n'.format(**strdict))\n        codePre = codePost = formatChars = codeVarsPass = codeDecl = ''\n        for arg in method.args:\n            if not arg.HasAttribute('out'):\n                continue\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                formatChar = argCvt.GetFormatChar()\n                if formatChar:\n                    formatChars = formatChars + formatChar\n                    codePre = codePre + argCvt.GetBuildForInterfacePreCode()\n                    codePost = codePost + argCvt.GetBuildForInterfacePostCode()\n                    codeVarsPass = codeVarsPass + ', ' + argCvt.GetBuildValueArg()\n                    codeDecl = codeDecl + argCvt.DeclareParseArgTupleInputConverter()\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n                continue\n        if formatChars:\n            f.write('{}\\n{}\\tPyObject *pyretval = Py_BuildValue(\"{}\"{});\\n{}\\treturn pyretval;'.format(codeDecl, codePre, formatChars, codeVarsPass, codePost))\n        else:\n            f.write('\\tPy_INCREF(Py_None);\\n\\treturn Py_None;\\n')\n        f.write('\\n}\\n\\n')\n    f.write('// @object Py%s|Description of the interface\\n' % name)\n    f.write('static struct PyMethodDef Py%s_methods[] =\\n{\\n' % name)\n    for method in interface.methods:\n        f.write('\\t{{ \"{}\", Py{}::{}, 1 }}, // @pymeth {}|Description of {}\\n'.format(method.name, interface.name, method.name, method.name, method.name))\n    interfacebase = interface.base\n    f.write('\\t{{ NULL }}\\n}};\\n\\nPyComTypeObject Py{name}::type(\"Py{name}\",\\n\\t\\t&Py{interfacebase}::type,\\n\\t\\tsizeof(Py{name}),\\n\\t\\tPy{name}_methods,\\n\\t\\tGET_PYCOM_CTOR(Py{name}));\\n'.format(**locals()))",
            "def _write_ifc_cpp(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    name = interface.name\n    f.write('// ---------------------------------------------------\\n//\\n// Interface Implementation\\n\\nPy{name}::Py{name}(IUnknown *pdisp):\\n\\tPy{base}(pdisp)\\n{{\\n\\tob_type = &type;\\n}}\\n\\nPy{name}::~Py{name}()\\n{{\\n}}\\n\\n/* static */ {name} *Py{name}::GetI(PyObject *self)\\n{{\\n\\treturn ({name} *)Py{base}::GetI(self);\\n}}\\n\\n'.format(**interface.__dict__))\n    ptr = re.sub('[a-z]', '', interface.name)\n    strdict = {'interfacename': interface.name, 'ptr': ptr}\n    for method in interface.methods:\n        strdict['method'] = method.name\n        f.write('// @pymethod |Py{interfacename}|{method}|Description of {method}.\\nPyObject *Py{interfacename}::{method}(PyObject *self, PyObject *args)\\n{{\\n\\t{interfacename} *p{ptr} = GetI(self);\\n\\tif ( p{ptr} == NULL )\\n\\t\\treturn NULL;\\n'.format(**strdict))\n        argsParseTuple = argsCOM = formatChars = codePost = codePobjects = codeCobjects = cleanup = cleanup_gil = ''\n        needConversion = 0\n        for arg in method.args:\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                if arg.HasAttribute('in'):\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        f.write('\\t' + argCvt.GetAutoduckString() + '\\n')\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        cleanup = cleanup + argCvt.GetInterfaceArgCleanup()\n                        cleanup_gil = cleanup_gil + argCvt.GetInterfaceArgCleanupGIL()\n                (comArgName, comArgDeclString) = argCvt.GetInterfaceCppObjectInfo()\n                if comArgDeclString:\n                    codeCobjects = codeCobjects + '\\t%s;\\n' % comArgDeclString\n                argsCOM = argsCOM + ', ' + comArgName\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//     Please check the conversion function is appropriate and exists!\\n'.format(arg.name, arg.raw_type))\n                f.write(f'\\t{arg.type} {arg.name};\\n\\tPyObject *ob{arg.name};\\n')\n                f.write('\\t// @pyparm <o Py{}>|{}||Description for {}\\n'.format(arg.type, arg.name, arg.name))\n                codePost = codePost + '\\tif (bPythonIsHappy && !PyObject_As{}( ob{}, &{} )) bPythonIsHappy = FALSE;\\n'.format(arg.type, arg.name, arg.name)\n                formatChars = formatChars + 'O'\n                argsParseTuple = argsParseTuple + ', &ob%s' % arg.name\n                argsCOM = argsCOM + ', ' + arg.name\n                cleanup = cleanup + f'\\tPyObject_Free{arg.type}({arg.name});\\n'\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codePobjects)\n        f.write(codeCobjects)\n        f.write('\\tif ( !PyArg_ParseTuple(args, \"{}:{}\"{}) )\\n\\t\\treturn NULL;\\n'.format(formatChars, method.name, argsParseTuple))\n        if codePost:\n            f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n            f.write(codePost)\n            f.write('\\tif (!bPythonIsHappy) return NULL;\\n')\n        strdict['argsCOM'] = argsCOM[1:]\n        strdict['cleanup'] = cleanup\n        strdict['cleanup_gil'] = cleanup_gil\n        f.write('\\tHRESULT hr;\\n\\tPY_INTERFACE_PRECALL;\\n\\thr = p{ptr}->{method}({argsCOM} );\\n{cleanup}\\n\\tPY_INTERFACE_POSTCALL;\\n{cleanup_gil}\\n\\tif ( FAILED(hr) )\\n\\t\\treturn PyCom_BuildPyException(hr, p{ptr}, IID_{interfacename} );\\n'.format(**strdict))\n        codePre = codePost = formatChars = codeVarsPass = codeDecl = ''\n        for arg in method.args:\n            if not arg.HasAttribute('out'):\n                continue\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                formatChar = argCvt.GetFormatChar()\n                if formatChar:\n                    formatChars = formatChars + formatChar\n                    codePre = codePre + argCvt.GetBuildForInterfacePreCode()\n                    codePost = codePost + argCvt.GetBuildForInterfacePostCode()\n                    codeVarsPass = codeVarsPass + ', ' + argCvt.GetBuildValueArg()\n                    codeDecl = codeDecl + argCvt.DeclareParseArgTupleInputConverter()\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n                continue\n        if formatChars:\n            f.write('{}\\n{}\\tPyObject *pyretval = Py_BuildValue(\"{}\"{});\\n{}\\treturn pyretval;'.format(codeDecl, codePre, formatChars, codeVarsPass, codePost))\n        else:\n            f.write('\\tPy_INCREF(Py_None);\\n\\treturn Py_None;\\n')\n        f.write('\\n}\\n\\n')\n    f.write('// @object Py%s|Description of the interface\\n' % name)\n    f.write('static struct PyMethodDef Py%s_methods[] =\\n{\\n' % name)\n    for method in interface.methods:\n        f.write('\\t{{ \"{}\", Py{}::{}, 1 }}, // @pymeth {}|Description of {}\\n'.format(method.name, interface.name, method.name, method.name, method.name))\n    interfacebase = interface.base\n    f.write('\\t{{ NULL }}\\n}};\\n\\nPyComTypeObject Py{name}::type(\"Py{name}\",\\n\\t\\t&Py{interfacebase}::type,\\n\\t\\tsizeof(Py{name}),\\n\\t\\tPy{name}_methods,\\n\\t\\tGET_PYCOM_CTOR(Py{name}));\\n'.format(**locals()))",
            "def _write_ifc_cpp(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    name = interface.name\n    f.write('// ---------------------------------------------------\\n//\\n// Interface Implementation\\n\\nPy{name}::Py{name}(IUnknown *pdisp):\\n\\tPy{base}(pdisp)\\n{{\\n\\tob_type = &type;\\n}}\\n\\nPy{name}::~Py{name}()\\n{{\\n}}\\n\\n/* static */ {name} *Py{name}::GetI(PyObject *self)\\n{{\\n\\treturn ({name} *)Py{base}::GetI(self);\\n}}\\n\\n'.format(**interface.__dict__))\n    ptr = re.sub('[a-z]', '', interface.name)\n    strdict = {'interfacename': interface.name, 'ptr': ptr}\n    for method in interface.methods:\n        strdict['method'] = method.name\n        f.write('// @pymethod |Py{interfacename}|{method}|Description of {method}.\\nPyObject *Py{interfacename}::{method}(PyObject *self, PyObject *args)\\n{{\\n\\t{interfacename} *p{ptr} = GetI(self);\\n\\tif ( p{ptr} == NULL )\\n\\t\\treturn NULL;\\n'.format(**strdict))\n        argsParseTuple = argsCOM = formatChars = codePost = codePobjects = codeCobjects = cleanup = cleanup_gil = ''\n        needConversion = 0\n        for arg in method.args:\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                if arg.HasAttribute('in'):\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        f.write('\\t' + argCvt.GetAutoduckString() + '\\n')\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        cleanup = cleanup + argCvt.GetInterfaceArgCleanup()\n                        cleanup_gil = cleanup_gil + argCvt.GetInterfaceArgCleanupGIL()\n                (comArgName, comArgDeclString) = argCvt.GetInterfaceCppObjectInfo()\n                if comArgDeclString:\n                    codeCobjects = codeCobjects + '\\t%s;\\n' % comArgDeclString\n                argsCOM = argsCOM + ', ' + comArgName\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//     Please check the conversion function is appropriate and exists!\\n'.format(arg.name, arg.raw_type))\n                f.write(f'\\t{arg.type} {arg.name};\\n\\tPyObject *ob{arg.name};\\n')\n                f.write('\\t// @pyparm <o Py{}>|{}||Description for {}\\n'.format(arg.type, arg.name, arg.name))\n                codePost = codePost + '\\tif (bPythonIsHappy && !PyObject_As{}( ob{}, &{} )) bPythonIsHappy = FALSE;\\n'.format(arg.type, arg.name, arg.name)\n                formatChars = formatChars + 'O'\n                argsParseTuple = argsParseTuple + ', &ob%s' % arg.name\n                argsCOM = argsCOM + ', ' + arg.name\n                cleanup = cleanup + f'\\tPyObject_Free{arg.type}({arg.name});\\n'\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codePobjects)\n        f.write(codeCobjects)\n        f.write('\\tif ( !PyArg_ParseTuple(args, \"{}:{}\"{}) )\\n\\t\\treturn NULL;\\n'.format(formatChars, method.name, argsParseTuple))\n        if codePost:\n            f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n            f.write(codePost)\n            f.write('\\tif (!bPythonIsHappy) return NULL;\\n')\n        strdict['argsCOM'] = argsCOM[1:]\n        strdict['cleanup'] = cleanup\n        strdict['cleanup_gil'] = cleanup_gil\n        f.write('\\tHRESULT hr;\\n\\tPY_INTERFACE_PRECALL;\\n\\thr = p{ptr}->{method}({argsCOM} );\\n{cleanup}\\n\\tPY_INTERFACE_POSTCALL;\\n{cleanup_gil}\\n\\tif ( FAILED(hr) )\\n\\t\\treturn PyCom_BuildPyException(hr, p{ptr}, IID_{interfacename} );\\n'.format(**strdict))\n        codePre = codePost = formatChars = codeVarsPass = codeDecl = ''\n        for arg in method.args:\n            if not arg.HasAttribute('out'):\n                continue\n            try:\n                argCvt = makegwparse.make_arg_converter(arg)\n                formatChar = argCvt.GetFormatChar()\n                if formatChar:\n                    formatChars = formatChars + formatChar\n                    codePre = codePre + argCvt.GetBuildForInterfacePreCode()\n                    codePost = codePost + argCvt.GetBuildForInterfacePostCode()\n                    codeVarsPass = codeVarsPass + ', ' + argCvt.GetBuildValueArg()\n                    codeDecl = codeDecl + argCvt.DeclareParseArgTupleInputConverter()\n            except makegwparse.error_not_supported as why:\n                f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n                continue\n        if formatChars:\n            f.write('{}\\n{}\\tPyObject *pyretval = Py_BuildValue(\"{}\"{});\\n{}\\treturn pyretval;'.format(codeDecl, codePre, formatChars, codeVarsPass, codePost))\n        else:\n            f.write('\\tPy_INCREF(Py_None);\\n\\treturn Py_None;\\n')\n        f.write('\\n}\\n\\n')\n    f.write('// @object Py%s|Description of the interface\\n' % name)\n    f.write('static struct PyMethodDef Py%s_methods[] =\\n{\\n' % name)\n    for method in interface.methods:\n        f.write('\\t{{ \"{}\", Py{}::{}, 1 }}, // @pymeth {}|Description of {}\\n'.format(method.name, interface.name, method.name, method.name, method.name))\n    interfacebase = interface.base\n    f.write('\\t{{ NULL }}\\n}};\\n\\nPyComTypeObject Py{name}::type(\"Py{name}\",\\n\\t\\t&Py{interfacebase}::type,\\n\\t\\tsizeof(Py{name}),\\n\\t\\tPy{name}_methods,\\n\\t\\tGET_PYCOM_CTOR(Py{name}));\\n'.format(**locals()))"
        ]
    },
    {
        "func_name": "_write_gw_h",
        "original": "def _write_gw_h(f, interface):\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write(f'// ---------------------------------------------------\\n//\\n// Gateway Declaration\\n\\nclass {gname} : public {base_name}, public {name}\\n{{\\nprotected:\\n\\t{gname}(PyObject *instance) : {base_name}(instance) {{ ; }}\\n\\tPYGATEWAY_MAKE_SUPPORT2({gname}, {name}, IID_{name}, {base_name})\\n\\n')\n    if interface.base != 'IUnknown':\n        f.write('\\t// {}\\n\\t// *** Manually add {} method decls here\\n\\n'.format(interface.base, interface.base))\n    else:\n        f.write('\\n\\n')\n    f.write('\\t// %s\\n' % name)\n    for method in interface.methods:\n        f.write('\\tSTDMETHOD(%s)(\\n' % method.name)\n        if method.args:\n            for arg in method.args[:-1]:\n                f.write('\\t\\t%s,\\n' % arg.GetRawDeclaration())\n            arg = method.args[-1]\n            f.write('\\t\\t%s);\\n\\n' % arg.GetRawDeclaration())\n        else:\n            f.write('\\t\\tvoid);\\n\\n')\n    f.write('};\\n')\n    f.close()",
        "mutated": [
            "def _write_gw_h(f, interface):\n    if False:\n        i = 10\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write(f'// ---------------------------------------------------\\n//\\n// Gateway Declaration\\n\\nclass {gname} : public {base_name}, public {name}\\n{{\\nprotected:\\n\\t{gname}(PyObject *instance) : {base_name}(instance) {{ ; }}\\n\\tPYGATEWAY_MAKE_SUPPORT2({gname}, {name}, IID_{name}, {base_name})\\n\\n')\n    if interface.base != 'IUnknown':\n        f.write('\\t// {}\\n\\t// *** Manually add {} method decls here\\n\\n'.format(interface.base, interface.base))\n    else:\n        f.write('\\n\\n')\n    f.write('\\t// %s\\n' % name)\n    for method in interface.methods:\n        f.write('\\tSTDMETHOD(%s)(\\n' % method.name)\n        if method.args:\n            for arg in method.args[:-1]:\n                f.write('\\t\\t%s,\\n' % arg.GetRawDeclaration())\n            arg = method.args[-1]\n            f.write('\\t\\t%s);\\n\\n' % arg.GetRawDeclaration())\n        else:\n            f.write('\\t\\tvoid);\\n\\n')\n    f.write('};\\n')\n    f.close()",
            "def _write_gw_h(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write(f'// ---------------------------------------------------\\n//\\n// Gateway Declaration\\n\\nclass {gname} : public {base_name}, public {name}\\n{{\\nprotected:\\n\\t{gname}(PyObject *instance) : {base_name}(instance) {{ ; }}\\n\\tPYGATEWAY_MAKE_SUPPORT2({gname}, {name}, IID_{name}, {base_name})\\n\\n')\n    if interface.base != 'IUnknown':\n        f.write('\\t// {}\\n\\t// *** Manually add {} method decls here\\n\\n'.format(interface.base, interface.base))\n    else:\n        f.write('\\n\\n')\n    f.write('\\t// %s\\n' % name)\n    for method in interface.methods:\n        f.write('\\tSTDMETHOD(%s)(\\n' % method.name)\n        if method.args:\n            for arg in method.args[:-1]:\n                f.write('\\t\\t%s,\\n' % arg.GetRawDeclaration())\n            arg = method.args[-1]\n            f.write('\\t\\t%s);\\n\\n' % arg.GetRawDeclaration())\n        else:\n            f.write('\\t\\tvoid);\\n\\n')\n    f.write('};\\n')\n    f.close()",
            "def _write_gw_h(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write(f'// ---------------------------------------------------\\n//\\n// Gateway Declaration\\n\\nclass {gname} : public {base_name}, public {name}\\n{{\\nprotected:\\n\\t{gname}(PyObject *instance) : {base_name}(instance) {{ ; }}\\n\\tPYGATEWAY_MAKE_SUPPORT2({gname}, {name}, IID_{name}, {base_name})\\n\\n')\n    if interface.base != 'IUnknown':\n        f.write('\\t// {}\\n\\t// *** Manually add {} method decls here\\n\\n'.format(interface.base, interface.base))\n    else:\n        f.write('\\n\\n')\n    f.write('\\t// %s\\n' % name)\n    for method in interface.methods:\n        f.write('\\tSTDMETHOD(%s)(\\n' % method.name)\n        if method.args:\n            for arg in method.args[:-1]:\n                f.write('\\t\\t%s,\\n' % arg.GetRawDeclaration())\n            arg = method.args[-1]\n            f.write('\\t\\t%s);\\n\\n' % arg.GetRawDeclaration())\n        else:\n            f.write('\\t\\tvoid);\\n\\n')\n    f.write('};\\n')\n    f.close()",
            "def _write_gw_h(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write(f'// ---------------------------------------------------\\n//\\n// Gateway Declaration\\n\\nclass {gname} : public {base_name}, public {name}\\n{{\\nprotected:\\n\\t{gname}(PyObject *instance) : {base_name}(instance) {{ ; }}\\n\\tPYGATEWAY_MAKE_SUPPORT2({gname}, {name}, IID_{name}, {base_name})\\n\\n')\n    if interface.base != 'IUnknown':\n        f.write('\\t// {}\\n\\t// *** Manually add {} method decls here\\n\\n'.format(interface.base, interface.base))\n    else:\n        f.write('\\n\\n')\n    f.write('\\t// %s\\n' % name)\n    for method in interface.methods:\n        f.write('\\tSTDMETHOD(%s)(\\n' % method.name)\n        if method.args:\n            for arg in method.args[:-1]:\n                f.write('\\t\\t%s,\\n' % arg.GetRawDeclaration())\n            arg = method.args[-1]\n            f.write('\\t\\t%s);\\n\\n' % arg.GetRawDeclaration())\n        else:\n            f.write('\\t\\tvoid);\\n\\n')\n    f.write('};\\n')\n    f.close()",
            "def _write_gw_h(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write(f'// ---------------------------------------------------\\n//\\n// Gateway Declaration\\n\\nclass {gname} : public {base_name}, public {name}\\n{{\\nprotected:\\n\\t{gname}(PyObject *instance) : {base_name}(instance) {{ ; }}\\n\\tPYGATEWAY_MAKE_SUPPORT2({gname}, {name}, IID_{name}, {base_name})\\n\\n')\n    if interface.base != 'IUnknown':\n        f.write('\\t// {}\\n\\t// *** Manually add {} method decls here\\n\\n'.format(interface.base, interface.base))\n    else:\n        f.write('\\n\\n')\n    f.write('\\t// %s\\n' % name)\n    for method in interface.methods:\n        f.write('\\tSTDMETHOD(%s)(\\n' % method.name)\n        if method.args:\n            for arg in method.args[:-1]:\n                f.write('\\t\\t%s,\\n' % arg.GetRawDeclaration())\n            arg = method.args[-1]\n            f.write('\\t\\t%s);\\n\\n' % arg.GetRawDeclaration())\n        else:\n            f.write('\\t\\tvoid);\\n\\n')\n    f.write('};\\n')\n    f.close()"
        ]
    },
    {
        "func_name": "_write_gw_cpp",
        "original": "def _write_gw_cpp(f, interface):\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write('// ---------------------------------------------------\\n//\\n// Gateway Implementation\\n'.format(name=name, gname=gname, base_name=base_name))\n    for method in interface.methods:\n        f.write(f'STDMETHODIMP {gname}::{method.name}(\\n')\n        if method.args:\n            for arg in method.args[:-1]:\n                inoutstr = ']['.join(arg.inout)\n                f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()},\\n')\n            arg = method.args[-1]\n            inoutstr = ']['.join(arg.inout)\n            f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()})\\n')\n        else:\n            f.write('\\t\\tvoid)\\n')\n        f.write('{\\n\\tPY_GATEWAY_METHOD;\\n')\n        cout = 0\n        codePre = codePost = codeVars = ''\n        argStr = ''\n        needConversion = 0\n        formatChars = ''\n        if method.args:\n            for arg in method.args:\n                if arg.HasAttribute('out'):\n                    cout = cout + 1\n                    if arg.indirectionLevel == 2:\n                        f.write('\\tif (%s==NULL) return E_POINTER;\\n' % arg.name)\n                if arg.HasAttribute('in'):\n                    try:\n                        argCvt = makegwparse.make_arg_converter(arg)\n                        argCvt.SetGatewayMode()\n                        formatchar = argCvt.GetFormatChar()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        if formatchar:\n                            formatChars = formatChars + formatchar\n                            codeVars = codeVars + argCvt.DeclareParseArgTupleInputConverter()\n                            argStr = argStr + ', ' + argCvt.GetBuildValueArg()\n                        codePre = codePre + argCvt.GetBuildForGatewayPreCode()\n                        codePost = codePost + argCvt.GetBuildForGatewayPostCode()\n                    except makegwparse.error_not_supported as why:\n                        f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//   - Please ensure this conversion function exists, and is appropriate\\n//   - {}\\n'.format(arg.name, arg.raw_type, why))\n                        f.write('\\tPyObject *ob{} = PyObject_From{}({});\\n'.format(arg.name, arg.type, arg.name))\n                        f.write('\\tif (ob{}==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(arg.name, method.name))\n                        codePost = codePost + '\\tPy_DECREF(ob%s);\\n' % arg.name\n                        formatChars = formatChars + 'O'\n                        argStr = argStr + ', ob%s' % arg.name\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codeVars)\n        f.write(codePre)\n        if cout:\n            f.write('\\tPyObject *result;\\n')\n            resStr = '&result'\n        else:\n            resStr = 'NULL'\n        if formatChars:\n            fullArgStr = f'{resStr}, \"{formatChars}\"{argStr}'\n        else:\n            fullArgStr = resStr\n        f.write(f'\\tHRESULT hr=InvokeViaPolicy(\"{method.name}\", {fullArgStr});\\n')\n        f.write(codePost)\n        if cout:\n            f.write('\\tif (FAILED(hr)) return hr;\\n')\n            f.write('\\t// Process the Python results, and convert back to the real params\\n')\n            formatChars = codePobjects = codePost = argsParseTuple = ''\n            needConversion = 0\n            for arg in method.args:\n                if not arg.HasAttribute('out'):\n                    continue\n                try:\n                    argCvt = makegwparse.make_arg_converter(arg)\n                    argCvt.SetGatewayMode()\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                except makegwparse.error_not_supported as why:\n                    f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n            if formatChars:\n                if len(formatChars) == 1:\n                    parseFn = 'PyArg_Parse'\n                else:\n                    parseFn = 'PyArg_ParseTuple'\n                if codePobjects:\n                    f.write(codePobjects)\n                f.write('\\tif (!{}(result, \"{}\" {}))\\n\\t\\treturn MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(parseFn, formatChars, argsParseTuple, method.name))\n            if codePost:\n                f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n                f.write(codePost)\n                f.write('\\tif (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\\n' % method.name)\n            f.write('\\tPy_DECREF(result);\\n')\n        f.write('\\treturn hr;\\n}\\n\\n')",
        "mutated": [
            "def _write_gw_cpp(f, interface):\n    if False:\n        i = 10\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write('// ---------------------------------------------------\\n//\\n// Gateway Implementation\\n'.format(name=name, gname=gname, base_name=base_name))\n    for method in interface.methods:\n        f.write(f'STDMETHODIMP {gname}::{method.name}(\\n')\n        if method.args:\n            for arg in method.args[:-1]:\n                inoutstr = ']['.join(arg.inout)\n                f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()},\\n')\n            arg = method.args[-1]\n            inoutstr = ']['.join(arg.inout)\n            f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()})\\n')\n        else:\n            f.write('\\t\\tvoid)\\n')\n        f.write('{\\n\\tPY_GATEWAY_METHOD;\\n')\n        cout = 0\n        codePre = codePost = codeVars = ''\n        argStr = ''\n        needConversion = 0\n        formatChars = ''\n        if method.args:\n            for arg in method.args:\n                if arg.HasAttribute('out'):\n                    cout = cout + 1\n                    if arg.indirectionLevel == 2:\n                        f.write('\\tif (%s==NULL) return E_POINTER;\\n' % arg.name)\n                if arg.HasAttribute('in'):\n                    try:\n                        argCvt = makegwparse.make_arg_converter(arg)\n                        argCvt.SetGatewayMode()\n                        formatchar = argCvt.GetFormatChar()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        if formatchar:\n                            formatChars = formatChars + formatchar\n                            codeVars = codeVars + argCvt.DeclareParseArgTupleInputConverter()\n                            argStr = argStr + ', ' + argCvt.GetBuildValueArg()\n                        codePre = codePre + argCvt.GetBuildForGatewayPreCode()\n                        codePost = codePost + argCvt.GetBuildForGatewayPostCode()\n                    except makegwparse.error_not_supported as why:\n                        f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//   - Please ensure this conversion function exists, and is appropriate\\n//   - {}\\n'.format(arg.name, arg.raw_type, why))\n                        f.write('\\tPyObject *ob{} = PyObject_From{}({});\\n'.format(arg.name, arg.type, arg.name))\n                        f.write('\\tif (ob{}==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(arg.name, method.name))\n                        codePost = codePost + '\\tPy_DECREF(ob%s);\\n' % arg.name\n                        formatChars = formatChars + 'O'\n                        argStr = argStr + ', ob%s' % arg.name\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codeVars)\n        f.write(codePre)\n        if cout:\n            f.write('\\tPyObject *result;\\n')\n            resStr = '&result'\n        else:\n            resStr = 'NULL'\n        if formatChars:\n            fullArgStr = f'{resStr}, \"{formatChars}\"{argStr}'\n        else:\n            fullArgStr = resStr\n        f.write(f'\\tHRESULT hr=InvokeViaPolicy(\"{method.name}\", {fullArgStr});\\n')\n        f.write(codePost)\n        if cout:\n            f.write('\\tif (FAILED(hr)) return hr;\\n')\n            f.write('\\t// Process the Python results, and convert back to the real params\\n')\n            formatChars = codePobjects = codePost = argsParseTuple = ''\n            needConversion = 0\n            for arg in method.args:\n                if not arg.HasAttribute('out'):\n                    continue\n                try:\n                    argCvt = makegwparse.make_arg_converter(arg)\n                    argCvt.SetGatewayMode()\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                except makegwparse.error_not_supported as why:\n                    f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n            if formatChars:\n                if len(formatChars) == 1:\n                    parseFn = 'PyArg_Parse'\n                else:\n                    parseFn = 'PyArg_ParseTuple'\n                if codePobjects:\n                    f.write(codePobjects)\n                f.write('\\tif (!{}(result, \"{}\" {}))\\n\\t\\treturn MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(parseFn, formatChars, argsParseTuple, method.name))\n            if codePost:\n                f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n                f.write(codePost)\n                f.write('\\tif (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\\n' % method.name)\n            f.write('\\tPy_DECREF(result);\\n')\n        f.write('\\treturn hr;\\n}\\n\\n')",
            "def _write_gw_cpp(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write('// ---------------------------------------------------\\n//\\n// Gateway Implementation\\n'.format(name=name, gname=gname, base_name=base_name))\n    for method in interface.methods:\n        f.write(f'STDMETHODIMP {gname}::{method.name}(\\n')\n        if method.args:\n            for arg in method.args[:-1]:\n                inoutstr = ']['.join(arg.inout)\n                f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()},\\n')\n            arg = method.args[-1]\n            inoutstr = ']['.join(arg.inout)\n            f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()})\\n')\n        else:\n            f.write('\\t\\tvoid)\\n')\n        f.write('{\\n\\tPY_GATEWAY_METHOD;\\n')\n        cout = 0\n        codePre = codePost = codeVars = ''\n        argStr = ''\n        needConversion = 0\n        formatChars = ''\n        if method.args:\n            for arg in method.args:\n                if arg.HasAttribute('out'):\n                    cout = cout + 1\n                    if arg.indirectionLevel == 2:\n                        f.write('\\tif (%s==NULL) return E_POINTER;\\n' % arg.name)\n                if arg.HasAttribute('in'):\n                    try:\n                        argCvt = makegwparse.make_arg_converter(arg)\n                        argCvt.SetGatewayMode()\n                        formatchar = argCvt.GetFormatChar()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        if formatchar:\n                            formatChars = formatChars + formatchar\n                            codeVars = codeVars + argCvt.DeclareParseArgTupleInputConverter()\n                            argStr = argStr + ', ' + argCvt.GetBuildValueArg()\n                        codePre = codePre + argCvt.GetBuildForGatewayPreCode()\n                        codePost = codePost + argCvt.GetBuildForGatewayPostCode()\n                    except makegwparse.error_not_supported as why:\n                        f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//   - Please ensure this conversion function exists, and is appropriate\\n//   - {}\\n'.format(arg.name, arg.raw_type, why))\n                        f.write('\\tPyObject *ob{} = PyObject_From{}({});\\n'.format(arg.name, arg.type, arg.name))\n                        f.write('\\tif (ob{}==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(arg.name, method.name))\n                        codePost = codePost + '\\tPy_DECREF(ob%s);\\n' % arg.name\n                        formatChars = formatChars + 'O'\n                        argStr = argStr + ', ob%s' % arg.name\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codeVars)\n        f.write(codePre)\n        if cout:\n            f.write('\\tPyObject *result;\\n')\n            resStr = '&result'\n        else:\n            resStr = 'NULL'\n        if formatChars:\n            fullArgStr = f'{resStr}, \"{formatChars}\"{argStr}'\n        else:\n            fullArgStr = resStr\n        f.write(f'\\tHRESULT hr=InvokeViaPolicy(\"{method.name}\", {fullArgStr});\\n')\n        f.write(codePost)\n        if cout:\n            f.write('\\tif (FAILED(hr)) return hr;\\n')\n            f.write('\\t// Process the Python results, and convert back to the real params\\n')\n            formatChars = codePobjects = codePost = argsParseTuple = ''\n            needConversion = 0\n            for arg in method.args:\n                if not arg.HasAttribute('out'):\n                    continue\n                try:\n                    argCvt = makegwparse.make_arg_converter(arg)\n                    argCvt.SetGatewayMode()\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                except makegwparse.error_not_supported as why:\n                    f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n            if formatChars:\n                if len(formatChars) == 1:\n                    parseFn = 'PyArg_Parse'\n                else:\n                    parseFn = 'PyArg_ParseTuple'\n                if codePobjects:\n                    f.write(codePobjects)\n                f.write('\\tif (!{}(result, \"{}\" {}))\\n\\t\\treturn MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(parseFn, formatChars, argsParseTuple, method.name))\n            if codePost:\n                f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n                f.write(codePost)\n                f.write('\\tif (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\\n' % method.name)\n            f.write('\\tPy_DECREF(result);\\n')\n        f.write('\\treturn hr;\\n}\\n\\n')",
            "def _write_gw_cpp(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write('// ---------------------------------------------------\\n//\\n// Gateway Implementation\\n'.format(name=name, gname=gname, base_name=base_name))\n    for method in interface.methods:\n        f.write(f'STDMETHODIMP {gname}::{method.name}(\\n')\n        if method.args:\n            for arg in method.args[:-1]:\n                inoutstr = ']['.join(arg.inout)\n                f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()},\\n')\n            arg = method.args[-1]\n            inoutstr = ']['.join(arg.inout)\n            f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()})\\n')\n        else:\n            f.write('\\t\\tvoid)\\n')\n        f.write('{\\n\\tPY_GATEWAY_METHOD;\\n')\n        cout = 0\n        codePre = codePost = codeVars = ''\n        argStr = ''\n        needConversion = 0\n        formatChars = ''\n        if method.args:\n            for arg in method.args:\n                if arg.HasAttribute('out'):\n                    cout = cout + 1\n                    if arg.indirectionLevel == 2:\n                        f.write('\\tif (%s==NULL) return E_POINTER;\\n' % arg.name)\n                if arg.HasAttribute('in'):\n                    try:\n                        argCvt = makegwparse.make_arg_converter(arg)\n                        argCvt.SetGatewayMode()\n                        formatchar = argCvt.GetFormatChar()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        if formatchar:\n                            formatChars = formatChars + formatchar\n                            codeVars = codeVars + argCvt.DeclareParseArgTupleInputConverter()\n                            argStr = argStr + ', ' + argCvt.GetBuildValueArg()\n                        codePre = codePre + argCvt.GetBuildForGatewayPreCode()\n                        codePost = codePost + argCvt.GetBuildForGatewayPostCode()\n                    except makegwparse.error_not_supported as why:\n                        f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//   - Please ensure this conversion function exists, and is appropriate\\n//   - {}\\n'.format(arg.name, arg.raw_type, why))\n                        f.write('\\tPyObject *ob{} = PyObject_From{}({});\\n'.format(arg.name, arg.type, arg.name))\n                        f.write('\\tif (ob{}==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(arg.name, method.name))\n                        codePost = codePost + '\\tPy_DECREF(ob%s);\\n' % arg.name\n                        formatChars = formatChars + 'O'\n                        argStr = argStr + ', ob%s' % arg.name\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codeVars)\n        f.write(codePre)\n        if cout:\n            f.write('\\tPyObject *result;\\n')\n            resStr = '&result'\n        else:\n            resStr = 'NULL'\n        if formatChars:\n            fullArgStr = f'{resStr}, \"{formatChars}\"{argStr}'\n        else:\n            fullArgStr = resStr\n        f.write(f'\\tHRESULT hr=InvokeViaPolicy(\"{method.name}\", {fullArgStr});\\n')\n        f.write(codePost)\n        if cout:\n            f.write('\\tif (FAILED(hr)) return hr;\\n')\n            f.write('\\t// Process the Python results, and convert back to the real params\\n')\n            formatChars = codePobjects = codePost = argsParseTuple = ''\n            needConversion = 0\n            for arg in method.args:\n                if not arg.HasAttribute('out'):\n                    continue\n                try:\n                    argCvt = makegwparse.make_arg_converter(arg)\n                    argCvt.SetGatewayMode()\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                except makegwparse.error_not_supported as why:\n                    f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n            if formatChars:\n                if len(formatChars) == 1:\n                    parseFn = 'PyArg_Parse'\n                else:\n                    parseFn = 'PyArg_ParseTuple'\n                if codePobjects:\n                    f.write(codePobjects)\n                f.write('\\tif (!{}(result, \"{}\" {}))\\n\\t\\treturn MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(parseFn, formatChars, argsParseTuple, method.name))\n            if codePost:\n                f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n                f.write(codePost)\n                f.write('\\tif (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\\n' % method.name)\n            f.write('\\tPy_DECREF(result);\\n')\n        f.write('\\treturn hr;\\n}\\n\\n')",
            "def _write_gw_cpp(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write('// ---------------------------------------------------\\n//\\n// Gateway Implementation\\n'.format(name=name, gname=gname, base_name=base_name))\n    for method in interface.methods:\n        f.write(f'STDMETHODIMP {gname}::{method.name}(\\n')\n        if method.args:\n            for arg in method.args[:-1]:\n                inoutstr = ']['.join(arg.inout)\n                f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()},\\n')\n            arg = method.args[-1]\n            inoutstr = ']['.join(arg.inout)\n            f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()})\\n')\n        else:\n            f.write('\\t\\tvoid)\\n')\n        f.write('{\\n\\tPY_GATEWAY_METHOD;\\n')\n        cout = 0\n        codePre = codePost = codeVars = ''\n        argStr = ''\n        needConversion = 0\n        formatChars = ''\n        if method.args:\n            for arg in method.args:\n                if arg.HasAttribute('out'):\n                    cout = cout + 1\n                    if arg.indirectionLevel == 2:\n                        f.write('\\tif (%s==NULL) return E_POINTER;\\n' % arg.name)\n                if arg.HasAttribute('in'):\n                    try:\n                        argCvt = makegwparse.make_arg_converter(arg)\n                        argCvt.SetGatewayMode()\n                        formatchar = argCvt.GetFormatChar()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        if formatchar:\n                            formatChars = formatChars + formatchar\n                            codeVars = codeVars + argCvt.DeclareParseArgTupleInputConverter()\n                            argStr = argStr + ', ' + argCvt.GetBuildValueArg()\n                        codePre = codePre + argCvt.GetBuildForGatewayPreCode()\n                        codePost = codePost + argCvt.GetBuildForGatewayPostCode()\n                    except makegwparse.error_not_supported as why:\n                        f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//   - Please ensure this conversion function exists, and is appropriate\\n//   - {}\\n'.format(arg.name, arg.raw_type, why))\n                        f.write('\\tPyObject *ob{} = PyObject_From{}({});\\n'.format(arg.name, arg.type, arg.name))\n                        f.write('\\tif (ob{}==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(arg.name, method.name))\n                        codePost = codePost + '\\tPy_DECREF(ob%s);\\n' % arg.name\n                        formatChars = formatChars + 'O'\n                        argStr = argStr + ', ob%s' % arg.name\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codeVars)\n        f.write(codePre)\n        if cout:\n            f.write('\\tPyObject *result;\\n')\n            resStr = '&result'\n        else:\n            resStr = 'NULL'\n        if formatChars:\n            fullArgStr = f'{resStr}, \"{formatChars}\"{argStr}'\n        else:\n            fullArgStr = resStr\n        f.write(f'\\tHRESULT hr=InvokeViaPolicy(\"{method.name}\", {fullArgStr});\\n')\n        f.write(codePost)\n        if cout:\n            f.write('\\tif (FAILED(hr)) return hr;\\n')\n            f.write('\\t// Process the Python results, and convert back to the real params\\n')\n            formatChars = codePobjects = codePost = argsParseTuple = ''\n            needConversion = 0\n            for arg in method.args:\n                if not arg.HasAttribute('out'):\n                    continue\n                try:\n                    argCvt = makegwparse.make_arg_converter(arg)\n                    argCvt.SetGatewayMode()\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                except makegwparse.error_not_supported as why:\n                    f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n            if formatChars:\n                if len(formatChars) == 1:\n                    parseFn = 'PyArg_Parse'\n                else:\n                    parseFn = 'PyArg_ParseTuple'\n                if codePobjects:\n                    f.write(codePobjects)\n                f.write('\\tif (!{}(result, \"{}\" {}))\\n\\t\\treturn MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(parseFn, formatChars, argsParseTuple, method.name))\n            if codePost:\n                f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n                f.write(codePost)\n                f.write('\\tif (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\\n' % method.name)\n            f.write('\\tPy_DECREF(result);\\n')\n        f.write('\\treturn hr;\\n}\\n\\n')",
            "def _write_gw_cpp(f, interface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if interface.name[0] == 'I':\n        gname = 'PyG' + interface.name[1:]\n    else:\n        gname = 'PyG' + interface.name\n    name = interface.name\n    if interface.base == 'IUnknown' or interface.base == 'IDispatch':\n        base_name = 'PyGatewayBase'\n    elif interface.base[0] == 'I':\n        base_name = 'PyG' + interface.base[1:]\n    else:\n        base_name = 'PyG' + interface.base\n    f.write('// ---------------------------------------------------\\n//\\n// Gateway Implementation\\n'.format(name=name, gname=gname, base_name=base_name))\n    for method in interface.methods:\n        f.write(f'STDMETHODIMP {gname}::{method.name}(\\n')\n        if method.args:\n            for arg in method.args[:-1]:\n                inoutstr = ']['.join(arg.inout)\n                f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()},\\n')\n            arg = method.args[-1]\n            inoutstr = ']['.join(arg.inout)\n            f.write(f'\\t\\t/* [{inoutstr}] */ {arg.GetRawDeclaration()})\\n')\n        else:\n            f.write('\\t\\tvoid)\\n')\n        f.write('{\\n\\tPY_GATEWAY_METHOD;\\n')\n        cout = 0\n        codePre = codePost = codeVars = ''\n        argStr = ''\n        needConversion = 0\n        formatChars = ''\n        if method.args:\n            for arg in method.args:\n                if arg.HasAttribute('out'):\n                    cout = cout + 1\n                    if arg.indirectionLevel == 2:\n                        f.write('\\tif (%s==NULL) return E_POINTER;\\n' % arg.name)\n                if arg.HasAttribute('in'):\n                    try:\n                        argCvt = makegwparse.make_arg_converter(arg)\n                        argCvt.SetGatewayMode()\n                        formatchar = argCvt.GetFormatChar()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                        if formatchar:\n                            formatChars = formatChars + formatchar\n                            codeVars = codeVars + argCvt.DeclareParseArgTupleInputConverter()\n                            argStr = argStr + ', ' + argCvt.GetBuildValueArg()\n                        codePre = codePre + argCvt.GetBuildForGatewayPreCode()\n                        codePost = codePost + argCvt.GetBuildForGatewayPostCode()\n                    except makegwparse.error_not_supported as why:\n                        f.write('// *** The input argument {} of type \"{}\" was not processed ***\\n//   - Please ensure this conversion function exists, and is appropriate\\n//   - {}\\n'.format(arg.name, arg.raw_type, why))\n                        f.write('\\tPyObject *ob{} = PyObject_From{}({});\\n'.format(arg.name, arg.type, arg.name))\n                        f.write('\\tif (ob{}==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(arg.name, method.name))\n                        codePost = codePost + '\\tPy_DECREF(ob%s);\\n' % arg.name\n                        formatChars = formatChars + 'O'\n                        argStr = argStr + ', ob%s' % arg.name\n        if needConversion:\n            f.write('\\tUSES_CONVERSION;\\n')\n        f.write(codeVars)\n        f.write(codePre)\n        if cout:\n            f.write('\\tPyObject *result;\\n')\n            resStr = '&result'\n        else:\n            resStr = 'NULL'\n        if formatChars:\n            fullArgStr = f'{resStr}, \"{formatChars}\"{argStr}'\n        else:\n            fullArgStr = resStr\n        f.write(f'\\tHRESULT hr=InvokeViaPolicy(\"{method.name}\", {fullArgStr});\\n')\n        f.write(codePost)\n        if cout:\n            f.write('\\tif (FAILED(hr)) return hr;\\n')\n            f.write('\\t// Process the Python results, and convert back to the real params\\n')\n            formatChars = codePobjects = codePost = argsParseTuple = ''\n            needConversion = 0\n            for arg in method.args:\n                if not arg.HasAttribute('out'):\n                    continue\n                try:\n                    argCvt = makegwparse.make_arg_converter(arg)\n                    argCvt.SetGatewayMode()\n                    val = argCvt.GetFormatChar()\n                    if val:\n                        formatChars = formatChars + val\n                        argsParseTuple = argsParseTuple + ', ' + argCvt.GetParseTupleArg()\n                        codePobjects = codePobjects + argCvt.DeclareParseArgTupleInputConverter()\n                        codePost = codePost + argCvt.GetParsePostCode()\n                        needConversion = needConversion or argCvt.NeedUSES_CONVERSION()\n                except makegwparse.error_not_supported as why:\n                    f.write('// *** The output argument {} of type \"{}\" was not processed ***\\n//     {}\\n'.format(arg.name, arg.raw_type, why))\n            if formatChars:\n                if len(formatChars) == 1:\n                    parseFn = 'PyArg_Parse'\n                else:\n                    parseFn = 'PyArg_ParseTuple'\n                if codePobjects:\n                    f.write(codePobjects)\n                f.write('\\tif (!{}(result, \"{}\" {}))\\n\\t\\treturn MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{}\");\\n'.format(parseFn, formatChars, argsParseTuple, method.name))\n            if codePost:\n                f.write('\\tBOOL bPythonIsHappy = TRUE;\\n')\n                f.write(codePost)\n                f.write('\\tif (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\\n' % method.name)\n            f.write('\\tPy_DECREF(result);\\n')\n        f.write('\\treturn hr;\\n}\\n\\n')"
        ]
    },
    {
        "func_name": "test",
        "original": "def test():\n    make_framework_support('d:\\\\msdev\\\\include\\\\objidl.h', 'IStorage')",
        "mutated": [
            "def test():\n    if False:\n        i = 10\n    make_framework_support('d:\\\\msdev\\\\include\\\\objidl.h', 'IStorage')",
            "def test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    make_framework_support('d:\\\\msdev\\\\include\\\\objidl.h', 'IStorage')",
            "def test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    make_framework_support('d:\\\\msdev\\\\include\\\\objidl.h', 'IStorage')",
            "def test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    make_framework_support('d:\\\\msdev\\\\include\\\\objidl.h', 'IStorage')",
            "def test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    make_framework_support('d:\\\\msdev\\\\include\\\\objidl.h', 'IStorage')"
        ]
    }
]