[
    {
        "func_name": "has_respawned",
        "original": "def has_respawned():\n    return hasattr(sys.modules['__main__'], '_respawned')",
        "mutated": [
            "def has_respawned():\n    if False:\n        i = 10\n    return hasattr(sys.modules['__main__'], '_respawned')",
            "def has_respawned():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return hasattr(sys.modules['__main__'], '_respawned')",
            "def has_respawned():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return hasattr(sys.modules['__main__'], '_respawned')",
            "def has_respawned():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return hasattr(sys.modules['__main__'], '_respawned')",
            "def has_respawned():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return hasattr(sys.modules['__main__'], '_respawned')"
        ]
    },
    {
        "func_name": "respawn_module",
        "original": "def respawn_module(interpreter_path):\n    \"\"\"\n    Respawn the currently-running Ansible Python module under the specified Python interpreter.\n\n    Ansible modules that require libraries that are typically available only under well-known interpreters\n    (eg, ``yum``, ``apt``, ``dnf``) can use bespoke logic to determine the libraries they need are not\n    available, then call `respawn_module` to re-execute the current module under a different interpreter\n    and exit the current process when the new subprocess has completed. The respawned process inherits only\n    stdout/stderr from the current process.\n\n    Only a single respawn is allowed. ``respawn_module`` will fail on nested respawns. Modules are encouraged\n    to call `has_respawned()` to defensively guide behavior before calling ``respawn_module``, and to ensure\n    that the target interpreter exists, as ``respawn_module`` will not fail gracefully.\n\n    :arg interpreter_path: path to a Python interpreter to respawn the current module\n    \"\"\"\n    if has_respawned():\n        raise Exception('module has already been respawned')\n    payload = _create_payload()\n    (stdin_read, stdin_write) = os.pipe()\n    os.write(stdin_write, to_bytes(payload))\n    os.close(stdin_write)\n    rc = subprocess.call([interpreter_path, '--'], stdin=stdin_read)\n    sys.exit(rc)",
        "mutated": [
            "def respawn_module(interpreter_path):\n    if False:\n        i = 10\n    '\\n    Respawn the currently-running Ansible Python module under the specified Python interpreter.\\n\\n    Ansible modules that require libraries that are typically available only under well-known interpreters\\n    (eg, ``yum``, ``apt``, ``dnf``) can use bespoke logic to determine the libraries they need are not\\n    available, then call `respawn_module` to re-execute the current module under a different interpreter\\n    and exit the current process when the new subprocess has completed. The respawned process inherits only\\n    stdout/stderr from the current process.\\n\\n    Only a single respawn is allowed. ``respawn_module`` will fail on nested respawns. Modules are encouraged\\n    to call `has_respawned()` to defensively guide behavior before calling ``respawn_module``, and to ensure\\n    that the target interpreter exists, as ``respawn_module`` will not fail gracefully.\\n\\n    :arg interpreter_path: path to a Python interpreter to respawn the current module\\n    '\n    if has_respawned():\n        raise Exception('module has already been respawned')\n    payload = _create_payload()\n    (stdin_read, stdin_write) = os.pipe()\n    os.write(stdin_write, to_bytes(payload))\n    os.close(stdin_write)\n    rc = subprocess.call([interpreter_path, '--'], stdin=stdin_read)\n    sys.exit(rc)",
            "def respawn_module(interpreter_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Respawn the currently-running Ansible Python module under the specified Python interpreter.\\n\\n    Ansible modules that require libraries that are typically available only under well-known interpreters\\n    (eg, ``yum``, ``apt``, ``dnf``) can use bespoke logic to determine the libraries they need are not\\n    available, then call `respawn_module` to re-execute the current module under a different interpreter\\n    and exit the current process when the new subprocess has completed. The respawned process inherits only\\n    stdout/stderr from the current process.\\n\\n    Only a single respawn is allowed. ``respawn_module`` will fail on nested respawns. Modules are encouraged\\n    to call `has_respawned()` to defensively guide behavior before calling ``respawn_module``, and to ensure\\n    that the target interpreter exists, as ``respawn_module`` will not fail gracefully.\\n\\n    :arg interpreter_path: path to a Python interpreter to respawn the current module\\n    '\n    if has_respawned():\n        raise Exception('module has already been respawned')\n    payload = _create_payload()\n    (stdin_read, stdin_write) = os.pipe()\n    os.write(stdin_write, to_bytes(payload))\n    os.close(stdin_write)\n    rc = subprocess.call([interpreter_path, '--'], stdin=stdin_read)\n    sys.exit(rc)",
            "def respawn_module(interpreter_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Respawn the currently-running Ansible Python module under the specified Python interpreter.\\n\\n    Ansible modules that require libraries that are typically available only under well-known interpreters\\n    (eg, ``yum``, ``apt``, ``dnf``) can use bespoke logic to determine the libraries they need are not\\n    available, then call `respawn_module` to re-execute the current module under a different interpreter\\n    and exit the current process when the new subprocess has completed. The respawned process inherits only\\n    stdout/stderr from the current process.\\n\\n    Only a single respawn is allowed. ``respawn_module`` will fail on nested respawns. Modules are encouraged\\n    to call `has_respawned()` to defensively guide behavior before calling ``respawn_module``, and to ensure\\n    that the target interpreter exists, as ``respawn_module`` will not fail gracefully.\\n\\n    :arg interpreter_path: path to a Python interpreter to respawn the current module\\n    '\n    if has_respawned():\n        raise Exception('module has already been respawned')\n    payload = _create_payload()\n    (stdin_read, stdin_write) = os.pipe()\n    os.write(stdin_write, to_bytes(payload))\n    os.close(stdin_write)\n    rc = subprocess.call([interpreter_path, '--'], stdin=stdin_read)\n    sys.exit(rc)",
            "def respawn_module(interpreter_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Respawn the currently-running Ansible Python module under the specified Python interpreter.\\n\\n    Ansible modules that require libraries that are typically available only under well-known interpreters\\n    (eg, ``yum``, ``apt``, ``dnf``) can use bespoke logic to determine the libraries they need are not\\n    available, then call `respawn_module` to re-execute the current module under a different interpreter\\n    and exit the current process when the new subprocess has completed. The respawned process inherits only\\n    stdout/stderr from the current process.\\n\\n    Only a single respawn is allowed. ``respawn_module`` will fail on nested respawns. Modules are encouraged\\n    to call `has_respawned()` to defensively guide behavior before calling ``respawn_module``, and to ensure\\n    that the target interpreter exists, as ``respawn_module`` will not fail gracefully.\\n\\n    :arg interpreter_path: path to a Python interpreter to respawn the current module\\n    '\n    if has_respawned():\n        raise Exception('module has already been respawned')\n    payload = _create_payload()\n    (stdin_read, stdin_write) = os.pipe()\n    os.write(stdin_write, to_bytes(payload))\n    os.close(stdin_write)\n    rc = subprocess.call([interpreter_path, '--'], stdin=stdin_read)\n    sys.exit(rc)",
            "def respawn_module(interpreter_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Respawn the currently-running Ansible Python module under the specified Python interpreter.\\n\\n    Ansible modules that require libraries that are typically available only under well-known interpreters\\n    (eg, ``yum``, ``apt``, ``dnf``) can use bespoke logic to determine the libraries they need are not\\n    available, then call `respawn_module` to re-execute the current module under a different interpreter\\n    and exit the current process when the new subprocess has completed. The respawned process inherits only\\n    stdout/stderr from the current process.\\n\\n    Only a single respawn is allowed. ``respawn_module`` will fail on nested respawns. Modules are encouraged\\n    to call `has_respawned()` to defensively guide behavior before calling ``respawn_module``, and to ensure\\n    that the target interpreter exists, as ``respawn_module`` will not fail gracefully.\\n\\n    :arg interpreter_path: path to a Python interpreter to respawn the current module\\n    '\n    if has_respawned():\n        raise Exception('module has already been respawned')\n    payload = _create_payload()\n    (stdin_read, stdin_write) = os.pipe()\n    os.write(stdin_write, to_bytes(payload))\n    os.close(stdin_write)\n    rc = subprocess.call([interpreter_path, '--'], stdin=stdin_read)\n    sys.exit(rc)"
        ]
    },
    {
        "func_name": "probe_interpreters_for_module",
        "original": "def probe_interpreters_for_module(interpreter_paths, module_name):\n    \"\"\"\n    Probes a supplied list of Python interpreters, returning the first one capable of\n    importing the named module. This is useful when attempting to locate a \"system\n    Python\" where OS-packaged utility modules are located.\n\n    :arg interpreter_paths: iterable of paths to Python interpreters. The paths will be probed\n    in order, and the first path that exists and can successfully import the named module will\n    be returned (or ``None`` if probing fails for all supplied paths).\n    :arg module_name: fully-qualified Python module name to probe for (eg, ``selinux``)\n    \"\"\"\n    for interpreter_path in interpreter_paths:\n        if not os.path.exists(interpreter_path):\n            continue\n        try:\n            rc = subprocess.call([interpreter_path, '-c', 'import {0}'.format(module_name)])\n            if rc == 0:\n                return interpreter_path\n        except Exception:\n            continue\n    return None",
        "mutated": [
            "def probe_interpreters_for_module(interpreter_paths, module_name):\n    if False:\n        i = 10\n    '\\n    Probes a supplied list of Python interpreters, returning the first one capable of\\n    importing the named module. This is useful when attempting to locate a \"system\\n    Python\" where OS-packaged utility modules are located.\\n\\n    :arg interpreter_paths: iterable of paths to Python interpreters. The paths will be probed\\n    in order, and the first path that exists and can successfully import the named module will\\n    be returned (or ``None`` if probing fails for all supplied paths).\\n    :arg module_name: fully-qualified Python module name to probe for (eg, ``selinux``)\\n    '\n    for interpreter_path in interpreter_paths:\n        if not os.path.exists(interpreter_path):\n            continue\n        try:\n            rc = subprocess.call([interpreter_path, '-c', 'import {0}'.format(module_name)])\n            if rc == 0:\n                return interpreter_path\n        except Exception:\n            continue\n    return None",
            "def probe_interpreters_for_module(interpreter_paths, module_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Probes a supplied list of Python interpreters, returning the first one capable of\\n    importing the named module. This is useful when attempting to locate a \"system\\n    Python\" where OS-packaged utility modules are located.\\n\\n    :arg interpreter_paths: iterable of paths to Python interpreters. The paths will be probed\\n    in order, and the first path that exists and can successfully import the named module will\\n    be returned (or ``None`` if probing fails for all supplied paths).\\n    :arg module_name: fully-qualified Python module name to probe for (eg, ``selinux``)\\n    '\n    for interpreter_path in interpreter_paths:\n        if not os.path.exists(interpreter_path):\n            continue\n        try:\n            rc = subprocess.call([interpreter_path, '-c', 'import {0}'.format(module_name)])\n            if rc == 0:\n                return interpreter_path\n        except Exception:\n            continue\n    return None",
            "def probe_interpreters_for_module(interpreter_paths, module_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Probes a supplied list of Python interpreters, returning the first one capable of\\n    importing the named module. This is useful when attempting to locate a \"system\\n    Python\" where OS-packaged utility modules are located.\\n\\n    :arg interpreter_paths: iterable of paths to Python interpreters. The paths will be probed\\n    in order, and the first path that exists and can successfully import the named module will\\n    be returned (or ``None`` if probing fails for all supplied paths).\\n    :arg module_name: fully-qualified Python module name to probe for (eg, ``selinux``)\\n    '\n    for interpreter_path in interpreter_paths:\n        if not os.path.exists(interpreter_path):\n            continue\n        try:\n            rc = subprocess.call([interpreter_path, '-c', 'import {0}'.format(module_name)])\n            if rc == 0:\n                return interpreter_path\n        except Exception:\n            continue\n    return None",
            "def probe_interpreters_for_module(interpreter_paths, module_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Probes a supplied list of Python interpreters, returning the first one capable of\\n    importing the named module. This is useful when attempting to locate a \"system\\n    Python\" where OS-packaged utility modules are located.\\n\\n    :arg interpreter_paths: iterable of paths to Python interpreters. The paths will be probed\\n    in order, and the first path that exists and can successfully import the named module will\\n    be returned (or ``None`` if probing fails for all supplied paths).\\n    :arg module_name: fully-qualified Python module name to probe for (eg, ``selinux``)\\n    '\n    for interpreter_path in interpreter_paths:\n        if not os.path.exists(interpreter_path):\n            continue\n        try:\n            rc = subprocess.call([interpreter_path, '-c', 'import {0}'.format(module_name)])\n            if rc == 0:\n                return interpreter_path\n        except Exception:\n            continue\n    return None",
            "def probe_interpreters_for_module(interpreter_paths, module_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Probes a supplied list of Python interpreters, returning the first one capable of\\n    importing the named module. This is useful when attempting to locate a \"system\\n    Python\" where OS-packaged utility modules are located.\\n\\n    :arg interpreter_paths: iterable of paths to Python interpreters. The paths will be probed\\n    in order, and the first path that exists and can successfully import the named module will\\n    be returned (or ``None`` if probing fails for all supplied paths).\\n    :arg module_name: fully-qualified Python module name to probe for (eg, ``selinux``)\\n    '\n    for interpreter_path in interpreter_paths:\n        if not os.path.exists(interpreter_path):\n            continue\n        try:\n            rc = subprocess.call([interpreter_path, '-c', 'import {0}'.format(module_name)])\n            if rc == 0:\n                return interpreter_path\n        except Exception:\n            continue\n    return None"
        ]
    },
    {
        "func_name": "_create_payload",
        "original": "def _create_payload():\n    from ansible.module_utils import basic\n    smuggled_args = getattr(basic, '_ANSIBLE_ARGS')\n    if not smuggled_args:\n        raise Exception('unable to access ansible.module_utils.basic._ANSIBLE_ARGS (not launched by AnsiballZ?)')\n    module_fqn = sys.modules['__main__']._module_fqn\n    modlib_path = sys.modules['__main__']._modlib_path\n    respawn_code_template = \"\\nimport runpy\\nimport sys\\n\\nmodule_fqn = {module_fqn!r}\\nmodlib_path = {modlib_path!r}\\nsmuggled_args = {smuggled_args!r}\\n\\nif __name__ == '__main__':\\n    sys.path.insert(0, modlib_path)\\n\\n    from ansible.module_utils import basic\\n    basic._ANSIBLE_ARGS = smuggled_args\\n\\n    runpy.run_module(module_fqn, init_globals=dict(_respawned=True), run_name='__main__', alter_sys=True)\\n    \"\n    respawn_code = respawn_code_template.format(module_fqn=module_fqn, modlib_path=modlib_path, smuggled_args=smuggled_args.strip())\n    return respawn_code",
        "mutated": [
            "def _create_payload():\n    if False:\n        i = 10\n    from ansible.module_utils import basic\n    smuggled_args = getattr(basic, '_ANSIBLE_ARGS')\n    if not smuggled_args:\n        raise Exception('unable to access ansible.module_utils.basic._ANSIBLE_ARGS (not launched by AnsiballZ?)')\n    module_fqn = sys.modules['__main__']._module_fqn\n    modlib_path = sys.modules['__main__']._modlib_path\n    respawn_code_template = \"\\nimport runpy\\nimport sys\\n\\nmodule_fqn = {module_fqn!r}\\nmodlib_path = {modlib_path!r}\\nsmuggled_args = {smuggled_args!r}\\n\\nif __name__ == '__main__':\\n    sys.path.insert(0, modlib_path)\\n\\n    from ansible.module_utils import basic\\n    basic._ANSIBLE_ARGS = smuggled_args\\n\\n    runpy.run_module(module_fqn, init_globals=dict(_respawned=True), run_name='__main__', alter_sys=True)\\n    \"\n    respawn_code = respawn_code_template.format(module_fqn=module_fqn, modlib_path=modlib_path, smuggled_args=smuggled_args.strip())\n    return respawn_code",
            "def _create_payload():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from ansible.module_utils import basic\n    smuggled_args = getattr(basic, '_ANSIBLE_ARGS')\n    if not smuggled_args:\n        raise Exception('unable to access ansible.module_utils.basic._ANSIBLE_ARGS (not launched by AnsiballZ?)')\n    module_fqn = sys.modules['__main__']._module_fqn\n    modlib_path = sys.modules['__main__']._modlib_path\n    respawn_code_template = \"\\nimport runpy\\nimport sys\\n\\nmodule_fqn = {module_fqn!r}\\nmodlib_path = {modlib_path!r}\\nsmuggled_args = {smuggled_args!r}\\n\\nif __name__ == '__main__':\\n    sys.path.insert(0, modlib_path)\\n\\n    from ansible.module_utils import basic\\n    basic._ANSIBLE_ARGS = smuggled_args\\n\\n    runpy.run_module(module_fqn, init_globals=dict(_respawned=True), run_name='__main__', alter_sys=True)\\n    \"\n    respawn_code = respawn_code_template.format(module_fqn=module_fqn, modlib_path=modlib_path, smuggled_args=smuggled_args.strip())\n    return respawn_code",
            "def _create_payload():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from ansible.module_utils import basic\n    smuggled_args = getattr(basic, '_ANSIBLE_ARGS')\n    if not smuggled_args:\n        raise Exception('unable to access ansible.module_utils.basic._ANSIBLE_ARGS (not launched by AnsiballZ?)')\n    module_fqn = sys.modules['__main__']._module_fqn\n    modlib_path = sys.modules['__main__']._modlib_path\n    respawn_code_template = \"\\nimport runpy\\nimport sys\\n\\nmodule_fqn = {module_fqn!r}\\nmodlib_path = {modlib_path!r}\\nsmuggled_args = {smuggled_args!r}\\n\\nif __name__ == '__main__':\\n    sys.path.insert(0, modlib_path)\\n\\n    from ansible.module_utils import basic\\n    basic._ANSIBLE_ARGS = smuggled_args\\n\\n    runpy.run_module(module_fqn, init_globals=dict(_respawned=True), run_name='__main__', alter_sys=True)\\n    \"\n    respawn_code = respawn_code_template.format(module_fqn=module_fqn, modlib_path=modlib_path, smuggled_args=smuggled_args.strip())\n    return respawn_code",
            "def _create_payload():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from ansible.module_utils import basic\n    smuggled_args = getattr(basic, '_ANSIBLE_ARGS')\n    if not smuggled_args:\n        raise Exception('unable to access ansible.module_utils.basic._ANSIBLE_ARGS (not launched by AnsiballZ?)')\n    module_fqn = sys.modules['__main__']._module_fqn\n    modlib_path = sys.modules['__main__']._modlib_path\n    respawn_code_template = \"\\nimport runpy\\nimport sys\\n\\nmodule_fqn = {module_fqn!r}\\nmodlib_path = {modlib_path!r}\\nsmuggled_args = {smuggled_args!r}\\n\\nif __name__ == '__main__':\\n    sys.path.insert(0, modlib_path)\\n\\n    from ansible.module_utils import basic\\n    basic._ANSIBLE_ARGS = smuggled_args\\n\\n    runpy.run_module(module_fqn, init_globals=dict(_respawned=True), run_name='__main__', alter_sys=True)\\n    \"\n    respawn_code = respawn_code_template.format(module_fqn=module_fqn, modlib_path=modlib_path, smuggled_args=smuggled_args.strip())\n    return respawn_code",
            "def _create_payload():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from ansible.module_utils import basic\n    smuggled_args = getattr(basic, '_ANSIBLE_ARGS')\n    if not smuggled_args:\n        raise Exception('unable to access ansible.module_utils.basic._ANSIBLE_ARGS (not launched by AnsiballZ?)')\n    module_fqn = sys.modules['__main__']._module_fqn\n    modlib_path = sys.modules['__main__']._modlib_path\n    respawn_code_template = \"\\nimport runpy\\nimport sys\\n\\nmodule_fqn = {module_fqn!r}\\nmodlib_path = {modlib_path!r}\\nsmuggled_args = {smuggled_args!r}\\n\\nif __name__ == '__main__':\\n    sys.path.insert(0, modlib_path)\\n\\n    from ansible.module_utils import basic\\n    basic._ANSIBLE_ARGS = smuggled_args\\n\\n    runpy.run_module(module_fqn, init_globals=dict(_respawned=True), run_name='__main__', alter_sys=True)\\n    \"\n    respawn_code = respawn_code_template.format(module_fqn=module_fqn, modlib_path=modlib_path, smuggled_args=smuggled_args.strip())\n    return respawn_code"
        ]
    }
]