[
    {
        "func_name": "prepare",
        "original": "def prepare(self, reactor: MemoryReactor, clock: Clock, hs: HomeServer) -> None:\n    self.other_user_id = self.register_user('otheruser', 'pass')\n    self.other_access_token = self.login('otheruser', 'pass')\n    self.room_creator = self.hs.get_room_creation_handler()\n    self.store = hs.get_datastores().main",
        "mutated": [
            "def prepare(self, reactor: MemoryReactor, clock: Clock, hs: HomeServer) -> None:\n    if False:\n        i = 10\n    self.other_user_id = self.register_user('otheruser', 'pass')\n    self.other_access_token = self.login('otheruser', 'pass')\n    self.room_creator = self.hs.get_room_creation_handler()\n    self.store = hs.get_datastores().main",
            "def prepare(self, reactor: MemoryReactor, clock: Clock, hs: HomeServer) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.other_user_id = self.register_user('otheruser', 'pass')\n    self.other_access_token = self.login('otheruser', 'pass')\n    self.room_creator = self.hs.get_room_creation_handler()\n    self.store = hs.get_datastores().main",
            "def prepare(self, reactor: MemoryReactor, clock: Clock, hs: HomeServer) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.other_user_id = self.register_user('otheruser', 'pass')\n    self.other_access_token = self.login('otheruser', 'pass')\n    self.room_creator = self.hs.get_room_creation_handler()\n    self.store = hs.get_datastores().main",
            "def prepare(self, reactor: MemoryReactor, clock: Clock, hs: HomeServer) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.other_user_id = self.register_user('otheruser', 'pass')\n    self.other_access_token = self.login('otheruser', 'pass')\n    self.room_creator = self.hs.get_room_creation_handler()\n    self.store = hs.get_datastores().main",
            "def prepare(self, reactor: MemoryReactor, clock: Clock, hs: HomeServer) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.other_user_id = self.register_user('otheruser', 'pass')\n    self.other_access_token = self.login('otheruser', 'pass')\n    self.room_creator = self.hs.get_room_creation_handler()\n    self.store = hs.get_datastores().main"
        ]
    },
    {
        "func_name": "default_config",
        "original": "def default_config(self) -> dict:\n    conf = super().default_config()\n    conf['stream_writers'] = {'receipts': ['worker1', 'worker2']}\n    conf['instance_map'] = {'main': {'host': 'testserv', 'port': 8765}, 'worker1': {'host': 'testserv', 'port': 1001}, 'worker2': {'host': 'testserv', 'port': 1002}}\n    return conf",
        "mutated": [
            "def default_config(self) -> dict:\n    if False:\n        i = 10\n    conf = super().default_config()\n    conf['stream_writers'] = {'receipts': ['worker1', 'worker2']}\n    conf['instance_map'] = {'main': {'host': 'testserv', 'port': 8765}, 'worker1': {'host': 'testserv', 'port': 1001}, 'worker2': {'host': 'testserv', 'port': 1002}}\n    return conf",
            "def default_config(self) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    conf = super().default_config()\n    conf['stream_writers'] = {'receipts': ['worker1', 'worker2']}\n    conf['instance_map'] = {'main': {'host': 'testserv', 'port': 8765}, 'worker1': {'host': 'testserv', 'port': 1001}, 'worker2': {'host': 'testserv', 'port': 1002}}\n    return conf",
            "def default_config(self) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    conf = super().default_config()\n    conf['stream_writers'] = {'receipts': ['worker1', 'worker2']}\n    conf['instance_map'] = {'main': {'host': 'testserv', 'port': 8765}, 'worker1': {'host': 'testserv', 'port': 1001}, 'worker2': {'host': 'testserv', 'port': 1002}}\n    return conf",
            "def default_config(self) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    conf = super().default_config()\n    conf['stream_writers'] = {'receipts': ['worker1', 'worker2']}\n    conf['instance_map'] = {'main': {'host': 'testserv', 'port': 8765}, 'worker1': {'host': 'testserv', 'port': 1001}, 'worker2': {'host': 'testserv', 'port': 1002}}\n    return conf",
            "def default_config(self) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    conf = super().default_config()\n    conf['stream_writers'] = {'receipts': ['worker1', 'worker2']}\n    conf['instance_map'] = {'main': {'host': 'testserv', 'port': 8765}, 'worker1': {'host': 'testserv', 'port': 1001}, 'worker2': {'host': 'testserv', 'port': 1002}}\n    return conf"
        ]
    },
    {
        "func_name": "test_basic",
        "original": "def test_basic(self) -> None:\n    \"\"\"Simple test to ensure that receipts can be sent on multiple\n        workers.\n        \"\"\"\n    worker1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker1]\n    worker2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker2]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)",
        "mutated": [
            "def test_basic(self) -> None:\n    if False:\n        i = 10\n    'Simple test to ensure that receipts can be sent on multiple\\n        workers.\\n        '\n    worker1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker1]\n    worker2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker2]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)",
            "def test_basic(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Simple test to ensure that receipts can be sent on multiple\\n        workers.\\n        '\n    worker1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker1]\n    worker2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker2]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)",
            "def test_basic(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Simple test to ensure that receipts can be sent on multiple\\n        workers.\\n        '\n    worker1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker1]\n    worker2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker2]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)",
            "def test_basic(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Simple test to ensure that receipts can be sent on multiple\\n        workers.\\n        '\n    worker1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker1]\n    worker2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker2]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)",
            "def test_basic(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Simple test to ensure that receipts can be sent on multiple\\n        workers.\\n        '\n    worker1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker1]\n    worker2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker2]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    event_id = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{event_id}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)"
        ]
    },
    {
        "func_name": "test_vector_clock_token",
        "original": "def test_vector_clock_token(self) -> None:\n    \"\"\"Tests that using a stream token with a vector clock component works\n        correctly with basic /sync usage.\n        \"\"\"\n    worker_hs1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker_hs1]\n    worker_hs2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker_hs2]\n    sync_hs = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'sync'})\n    sync_hs_site = self._hs_to_site[sync_hs]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    store = self.hs.get_datastores().main\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    first_event = response['event_id']\n    channel = make_request(self.reactor, sync_hs_site, 'GET', '/sync', access_token=access_token)\n    next_batch = channel.json_body['next_batch']\n    worker_store2 = worker_hs2.get_datastores().main\n    assert isinstance(worker_store2._receipts_id_gen, MultiWriterIdGenerator)\n    actx = worker_store2._receipts_id_gen.get_next()\n    self.get_success(actx.__aenter__())\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{first_event}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    receipts_token = store.get_max_receipt_stream_id()\n    self.assertGreater(len(receipts_token.instance_map), 0)\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={next_batch}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(first_event, events[0]['content'])\n    vector_clock_token = channel.json_body['next_batch']\n    parsed_token = self.get_success(StreamToken.from_string(store, vector_clock_token))\n    self.assertGreaterEqual(len(parsed_token.receipt_key.instance_map), 1)\n    self.get_success(actx.__aexit__(None, None, None))\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    second_event = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{second_event}', access_token=access_token, content={})\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={vector_clock_token}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(second_event, events[0]['content'])",
        "mutated": [
            "def test_vector_clock_token(self) -> None:\n    if False:\n        i = 10\n    'Tests that using a stream token with a vector clock component works\\n        correctly with basic /sync usage.\\n        '\n    worker_hs1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker_hs1]\n    worker_hs2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker_hs2]\n    sync_hs = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'sync'})\n    sync_hs_site = self._hs_to_site[sync_hs]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    store = self.hs.get_datastores().main\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    first_event = response['event_id']\n    channel = make_request(self.reactor, sync_hs_site, 'GET', '/sync', access_token=access_token)\n    next_batch = channel.json_body['next_batch']\n    worker_store2 = worker_hs2.get_datastores().main\n    assert isinstance(worker_store2._receipts_id_gen, MultiWriterIdGenerator)\n    actx = worker_store2._receipts_id_gen.get_next()\n    self.get_success(actx.__aenter__())\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{first_event}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    receipts_token = store.get_max_receipt_stream_id()\n    self.assertGreater(len(receipts_token.instance_map), 0)\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={next_batch}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(first_event, events[0]['content'])\n    vector_clock_token = channel.json_body['next_batch']\n    parsed_token = self.get_success(StreamToken.from_string(store, vector_clock_token))\n    self.assertGreaterEqual(len(parsed_token.receipt_key.instance_map), 1)\n    self.get_success(actx.__aexit__(None, None, None))\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    second_event = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{second_event}', access_token=access_token, content={})\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={vector_clock_token}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(second_event, events[0]['content'])",
            "def test_vector_clock_token(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that using a stream token with a vector clock component works\\n        correctly with basic /sync usage.\\n        '\n    worker_hs1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker_hs1]\n    worker_hs2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker_hs2]\n    sync_hs = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'sync'})\n    sync_hs_site = self._hs_to_site[sync_hs]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    store = self.hs.get_datastores().main\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    first_event = response['event_id']\n    channel = make_request(self.reactor, sync_hs_site, 'GET', '/sync', access_token=access_token)\n    next_batch = channel.json_body['next_batch']\n    worker_store2 = worker_hs2.get_datastores().main\n    assert isinstance(worker_store2._receipts_id_gen, MultiWriterIdGenerator)\n    actx = worker_store2._receipts_id_gen.get_next()\n    self.get_success(actx.__aenter__())\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{first_event}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    receipts_token = store.get_max_receipt_stream_id()\n    self.assertGreater(len(receipts_token.instance_map), 0)\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={next_batch}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(first_event, events[0]['content'])\n    vector_clock_token = channel.json_body['next_batch']\n    parsed_token = self.get_success(StreamToken.from_string(store, vector_clock_token))\n    self.assertGreaterEqual(len(parsed_token.receipt_key.instance_map), 1)\n    self.get_success(actx.__aexit__(None, None, None))\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    second_event = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{second_event}', access_token=access_token, content={})\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={vector_clock_token}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(second_event, events[0]['content'])",
            "def test_vector_clock_token(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that using a stream token with a vector clock component works\\n        correctly with basic /sync usage.\\n        '\n    worker_hs1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker_hs1]\n    worker_hs2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker_hs2]\n    sync_hs = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'sync'})\n    sync_hs_site = self._hs_to_site[sync_hs]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    store = self.hs.get_datastores().main\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    first_event = response['event_id']\n    channel = make_request(self.reactor, sync_hs_site, 'GET', '/sync', access_token=access_token)\n    next_batch = channel.json_body['next_batch']\n    worker_store2 = worker_hs2.get_datastores().main\n    assert isinstance(worker_store2._receipts_id_gen, MultiWriterIdGenerator)\n    actx = worker_store2._receipts_id_gen.get_next()\n    self.get_success(actx.__aenter__())\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{first_event}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    receipts_token = store.get_max_receipt_stream_id()\n    self.assertGreater(len(receipts_token.instance_map), 0)\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={next_batch}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(first_event, events[0]['content'])\n    vector_clock_token = channel.json_body['next_batch']\n    parsed_token = self.get_success(StreamToken.from_string(store, vector_clock_token))\n    self.assertGreaterEqual(len(parsed_token.receipt_key.instance_map), 1)\n    self.get_success(actx.__aexit__(None, None, None))\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    second_event = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{second_event}', access_token=access_token, content={})\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={vector_clock_token}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(second_event, events[0]['content'])",
            "def test_vector_clock_token(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that using a stream token with a vector clock component works\\n        correctly with basic /sync usage.\\n        '\n    worker_hs1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker_hs1]\n    worker_hs2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker_hs2]\n    sync_hs = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'sync'})\n    sync_hs_site = self._hs_to_site[sync_hs]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    store = self.hs.get_datastores().main\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    first_event = response['event_id']\n    channel = make_request(self.reactor, sync_hs_site, 'GET', '/sync', access_token=access_token)\n    next_batch = channel.json_body['next_batch']\n    worker_store2 = worker_hs2.get_datastores().main\n    assert isinstance(worker_store2._receipts_id_gen, MultiWriterIdGenerator)\n    actx = worker_store2._receipts_id_gen.get_next()\n    self.get_success(actx.__aenter__())\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{first_event}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    receipts_token = store.get_max_receipt_stream_id()\n    self.assertGreater(len(receipts_token.instance_map), 0)\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={next_batch}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(first_event, events[0]['content'])\n    vector_clock_token = channel.json_body['next_batch']\n    parsed_token = self.get_success(StreamToken.from_string(store, vector_clock_token))\n    self.assertGreaterEqual(len(parsed_token.receipt_key.instance_map), 1)\n    self.get_success(actx.__aexit__(None, None, None))\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    second_event = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{second_event}', access_token=access_token, content={})\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={vector_clock_token}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(second_event, events[0]['content'])",
            "def test_vector_clock_token(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that using a stream token with a vector clock component works\\n        correctly with basic /sync usage.\\n        '\n    worker_hs1 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker1'})\n    worker1_site = self._hs_to_site[worker_hs1]\n    worker_hs2 = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'worker2'})\n    worker2_site = self._hs_to_site[worker_hs2]\n    sync_hs = self.make_worker_hs('synapse.app.generic_worker', {'worker_name': 'sync'})\n    sync_hs_site = self._hs_to_site[sync_hs]\n    user_id = self.register_user('user', 'pass')\n    access_token = self.login('user', 'pass')\n    store = self.hs.get_datastores().main\n    room_id = self.helper.create_room_as(user_id, tok=access_token)\n    self.helper.join(room=room_id, user=self.other_user_id, tok=self.other_access_token)\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    first_event = response['event_id']\n    channel = make_request(self.reactor, sync_hs_site, 'GET', '/sync', access_token=access_token)\n    next_batch = channel.json_body['next_batch']\n    worker_store2 = worker_hs2.get_datastores().main\n    assert isinstance(worker_store2._receipts_id_gen, MultiWriterIdGenerator)\n    actx = worker_store2._receipts_id_gen.get_next()\n    self.get_success(actx.__aenter__())\n    channel = make_request(reactor=self.reactor, site=worker1_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{first_event}', access_token=access_token, content={})\n    self.assertEqual(200, channel.code)\n    receipts_token = store.get_max_receipt_stream_id()\n    self.assertGreater(len(receipts_token.instance_map), 0)\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={next_batch}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(first_event, events[0]['content'])\n    vector_clock_token = channel.json_body['next_batch']\n    parsed_token = self.get_success(StreamToken.from_string(store, vector_clock_token))\n    self.assertGreaterEqual(len(parsed_token.receipt_key.instance_map), 1)\n    self.get_success(actx.__aexit__(None, None, None))\n    response = self.helper.send(room_id, body='Hi!', tok=self.other_access_token)\n    second_event = response['event_id']\n    channel = make_request(reactor=self.reactor, site=worker2_site, method='POST', path=f'/rooms/{room_id}/receipt/{ReceiptTypes.READ}/{second_event}', access_token=access_token, content={})\n    channel = make_request(self.reactor, sync_hs_site, 'GET', f'/sync?since={vector_clock_token}', access_token=access_token)\n    self.assertIn(room_id, channel.json_body['rooms']['join'])\n    events = channel.json_body['rooms']['join'][room_id]['ephemeral']['events']\n    self.assertEqual(len(events), 1)\n    self.assertIn(second_event, events[0]['content'])"
        ]
    }
]