[
    {
        "func_name": "__init__",
        "original": "def __init__(self, seq2seq):\n    super(BeamSearch, self).__init__(name=None)\n    self.layers = seq2seq\n    self.hasLUT = seq2seq.hasLUT\n    new_steps = 1\n    seq2seq.decoder.switch_mode(inference=True)\n    self.z_shape = new_steps if self.hasLUT else (seq2seq.out_shape[0], new_steps)",
        "mutated": [
            "def __init__(self, seq2seq):\n    if False:\n        i = 10\n    super(BeamSearch, self).__init__(name=None)\n    self.layers = seq2seq\n    self.hasLUT = seq2seq.hasLUT\n    new_steps = 1\n    seq2seq.decoder.switch_mode(inference=True)\n    self.z_shape = new_steps if self.hasLUT else (seq2seq.out_shape[0], new_steps)",
            "def __init__(self, seq2seq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BeamSearch, self).__init__(name=None)\n    self.layers = seq2seq\n    self.hasLUT = seq2seq.hasLUT\n    new_steps = 1\n    seq2seq.decoder.switch_mode(inference=True)\n    self.z_shape = new_steps if self.hasLUT else (seq2seq.out_shape[0], new_steps)",
            "def __init__(self, seq2seq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BeamSearch, self).__init__(name=None)\n    self.layers = seq2seq\n    self.hasLUT = seq2seq.hasLUT\n    new_steps = 1\n    seq2seq.decoder.switch_mode(inference=True)\n    self.z_shape = new_steps if self.hasLUT else (seq2seq.out_shape[0], new_steps)",
            "def __init__(self, seq2seq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BeamSearch, self).__init__(name=None)\n    self.layers = seq2seq\n    self.hasLUT = seq2seq.hasLUT\n    new_steps = 1\n    seq2seq.decoder.switch_mode(inference=True)\n    self.z_shape = new_steps if self.hasLUT else (seq2seq.out_shape[0], new_steps)",
            "def __init__(self, seq2seq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BeamSearch, self).__init__(name=None)\n    self.layers = seq2seq\n    self.hasLUT = seq2seq.hasLUT\n    new_steps = 1\n    seq2seq.decoder.switch_mode(inference=True)\n    self.z_shape = new_steps if self.hasLUT else (seq2seq.out_shape[0], new_steps)"
        ]
    },
    {
        "func_name": "beamsearch",
        "original": "def beamsearch(self, inputs, num_beams=5, steps=None):\n    \"\"\"\n        Perform an fprop path and beam search on a given set of network inputs.\n\n        Arguments:\n            inputs (Tensor): Minibatch of network inputs\n            num_beams (Int): Number of beams (hypothesis) to search over\n            steps (Int): Length of desired output in number of time steps\n        \"\"\"\n    self.num_beams = num_beams\n    self.num_live = 1\n    self.num_dead = 0\n    if steps is None:\n        steps = self.layers.in_shape[1]\n    bsz = self.be.bsz\n    self.z_list = [self.be.iobuf(self.z_shape) for _ in range(num_beams)]\n    for i in range(num_beams):\n        if getattr(self.layers.decoder, 'start_index', None) is not None:\n            self.z_list[i][self.layers.decoder.start_index] = 1\n    self.candidates = [np.zeros((steps, bsz)) for _ in range(num_beams)]\n    self.scores = [np.zeros(bsz) for _ in range(num_beams)]\n    z = self.be.iobuf(self.z_shape)\n    self.layers.encoder.fprop(inputs, inference=True, beta=0.0)\n    final_states = self.layers.encoder.get_final_states(self.layers.decoder_connections)\n    if len(final_states) != len(self.layers.decoder._recurrent):\n        raise ValueError('number of decoder layers ({num_layers}) does not match the number of decoder connections ({num_decoder_connections}).'.format(num_layers=len(self.layers.decoder._recurrent), num_decoder_connections=len(final_states)))\n    else:\n        init_state_list = final_states\n    self.init_state_lists = [[self.be.zeros_like(rec.h[-1]) for rec in self.layers.decoder._recurrent] for _ in range(num_beams)]\n    self.init_state_lists[0] = init_state_list\n    if self.hasLUT:\n        z_beams = [self.be.iobuf(self.layers.decoder.out_shape) for _ in range(self.num_beams)]\n    else:\n        z_beams = [self.be.iobuf(self.z_shape) for _ in range(self.num_beams)]\n    hidden_state_beams = [[self.be.zeros_like(l.final_state()) for l in self.layers.decoder._recurrent] for _ in range(self.num_beams)]\n    for t in range(steps):\n        for bb in range(self.num_live):\n            z = self.layers.decoder.fprop(self.z_list[bb], inference=True, init_state_list=self.init_state_lists[bb])\n            z_beams[bb][:] = z\n            for (i, l) in enumerate(self.layers.decoder._recurrent):\n                hidden_state_beams[bb][i][:] = l.final_state()\n        self._beamsearch_step(t, z_beams, hidden_state_beams)\n    return self.be.array(self.candidates[-1])",
        "mutated": [
            "def beamsearch(self, inputs, num_beams=5, steps=None):\n    if False:\n        i = 10\n    '\\n        Perform an fprop path and beam search on a given set of network inputs.\\n\\n        Arguments:\\n            inputs (Tensor): Minibatch of network inputs\\n            num_beams (Int): Number of beams (hypothesis) to search over\\n            steps (Int): Length of desired output in number of time steps\\n        '\n    self.num_beams = num_beams\n    self.num_live = 1\n    self.num_dead = 0\n    if steps is None:\n        steps = self.layers.in_shape[1]\n    bsz = self.be.bsz\n    self.z_list = [self.be.iobuf(self.z_shape) for _ in range(num_beams)]\n    for i in range(num_beams):\n        if getattr(self.layers.decoder, 'start_index', None) is not None:\n            self.z_list[i][self.layers.decoder.start_index] = 1\n    self.candidates = [np.zeros((steps, bsz)) for _ in range(num_beams)]\n    self.scores = [np.zeros(bsz) for _ in range(num_beams)]\n    z = self.be.iobuf(self.z_shape)\n    self.layers.encoder.fprop(inputs, inference=True, beta=0.0)\n    final_states = self.layers.encoder.get_final_states(self.layers.decoder_connections)\n    if len(final_states) != len(self.layers.decoder._recurrent):\n        raise ValueError('number of decoder layers ({num_layers}) does not match the number of decoder connections ({num_decoder_connections}).'.format(num_layers=len(self.layers.decoder._recurrent), num_decoder_connections=len(final_states)))\n    else:\n        init_state_list = final_states\n    self.init_state_lists = [[self.be.zeros_like(rec.h[-1]) for rec in self.layers.decoder._recurrent] for _ in range(num_beams)]\n    self.init_state_lists[0] = init_state_list\n    if self.hasLUT:\n        z_beams = [self.be.iobuf(self.layers.decoder.out_shape) for _ in range(self.num_beams)]\n    else:\n        z_beams = [self.be.iobuf(self.z_shape) for _ in range(self.num_beams)]\n    hidden_state_beams = [[self.be.zeros_like(l.final_state()) for l in self.layers.decoder._recurrent] for _ in range(self.num_beams)]\n    for t in range(steps):\n        for bb in range(self.num_live):\n            z = self.layers.decoder.fprop(self.z_list[bb], inference=True, init_state_list=self.init_state_lists[bb])\n            z_beams[bb][:] = z\n            for (i, l) in enumerate(self.layers.decoder._recurrent):\n                hidden_state_beams[bb][i][:] = l.final_state()\n        self._beamsearch_step(t, z_beams, hidden_state_beams)\n    return self.be.array(self.candidates[-1])",
            "def beamsearch(self, inputs, num_beams=5, steps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Perform an fprop path and beam search on a given set of network inputs.\\n\\n        Arguments:\\n            inputs (Tensor): Minibatch of network inputs\\n            num_beams (Int): Number of beams (hypothesis) to search over\\n            steps (Int): Length of desired output in number of time steps\\n        '\n    self.num_beams = num_beams\n    self.num_live = 1\n    self.num_dead = 0\n    if steps is None:\n        steps = self.layers.in_shape[1]\n    bsz = self.be.bsz\n    self.z_list = [self.be.iobuf(self.z_shape) for _ in range(num_beams)]\n    for i in range(num_beams):\n        if getattr(self.layers.decoder, 'start_index', None) is not None:\n            self.z_list[i][self.layers.decoder.start_index] = 1\n    self.candidates = [np.zeros((steps, bsz)) for _ in range(num_beams)]\n    self.scores = [np.zeros(bsz) for _ in range(num_beams)]\n    z = self.be.iobuf(self.z_shape)\n    self.layers.encoder.fprop(inputs, inference=True, beta=0.0)\n    final_states = self.layers.encoder.get_final_states(self.layers.decoder_connections)\n    if len(final_states) != len(self.layers.decoder._recurrent):\n        raise ValueError('number of decoder layers ({num_layers}) does not match the number of decoder connections ({num_decoder_connections}).'.format(num_layers=len(self.layers.decoder._recurrent), num_decoder_connections=len(final_states)))\n    else:\n        init_state_list = final_states\n    self.init_state_lists = [[self.be.zeros_like(rec.h[-1]) for rec in self.layers.decoder._recurrent] for _ in range(num_beams)]\n    self.init_state_lists[0] = init_state_list\n    if self.hasLUT:\n        z_beams = [self.be.iobuf(self.layers.decoder.out_shape) for _ in range(self.num_beams)]\n    else:\n        z_beams = [self.be.iobuf(self.z_shape) for _ in range(self.num_beams)]\n    hidden_state_beams = [[self.be.zeros_like(l.final_state()) for l in self.layers.decoder._recurrent] for _ in range(self.num_beams)]\n    for t in range(steps):\n        for bb in range(self.num_live):\n            z = self.layers.decoder.fprop(self.z_list[bb], inference=True, init_state_list=self.init_state_lists[bb])\n            z_beams[bb][:] = z\n            for (i, l) in enumerate(self.layers.decoder._recurrent):\n                hidden_state_beams[bb][i][:] = l.final_state()\n        self._beamsearch_step(t, z_beams, hidden_state_beams)\n    return self.be.array(self.candidates[-1])",
            "def beamsearch(self, inputs, num_beams=5, steps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Perform an fprop path and beam search on a given set of network inputs.\\n\\n        Arguments:\\n            inputs (Tensor): Minibatch of network inputs\\n            num_beams (Int): Number of beams (hypothesis) to search over\\n            steps (Int): Length of desired output in number of time steps\\n        '\n    self.num_beams = num_beams\n    self.num_live = 1\n    self.num_dead = 0\n    if steps is None:\n        steps = self.layers.in_shape[1]\n    bsz = self.be.bsz\n    self.z_list = [self.be.iobuf(self.z_shape) for _ in range(num_beams)]\n    for i in range(num_beams):\n        if getattr(self.layers.decoder, 'start_index', None) is not None:\n            self.z_list[i][self.layers.decoder.start_index] = 1\n    self.candidates = [np.zeros((steps, bsz)) for _ in range(num_beams)]\n    self.scores = [np.zeros(bsz) for _ in range(num_beams)]\n    z = self.be.iobuf(self.z_shape)\n    self.layers.encoder.fprop(inputs, inference=True, beta=0.0)\n    final_states = self.layers.encoder.get_final_states(self.layers.decoder_connections)\n    if len(final_states) != len(self.layers.decoder._recurrent):\n        raise ValueError('number of decoder layers ({num_layers}) does not match the number of decoder connections ({num_decoder_connections}).'.format(num_layers=len(self.layers.decoder._recurrent), num_decoder_connections=len(final_states)))\n    else:\n        init_state_list = final_states\n    self.init_state_lists = [[self.be.zeros_like(rec.h[-1]) for rec in self.layers.decoder._recurrent] for _ in range(num_beams)]\n    self.init_state_lists[0] = init_state_list\n    if self.hasLUT:\n        z_beams = [self.be.iobuf(self.layers.decoder.out_shape) for _ in range(self.num_beams)]\n    else:\n        z_beams = [self.be.iobuf(self.z_shape) for _ in range(self.num_beams)]\n    hidden_state_beams = [[self.be.zeros_like(l.final_state()) for l in self.layers.decoder._recurrent] for _ in range(self.num_beams)]\n    for t in range(steps):\n        for bb in range(self.num_live):\n            z = self.layers.decoder.fprop(self.z_list[bb], inference=True, init_state_list=self.init_state_lists[bb])\n            z_beams[bb][:] = z\n            for (i, l) in enumerate(self.layers.decoder._recurrent):\n                hidden_state_beams[bb][i][:] = l.final_state()\n        self._beamsearch_step(t, z_beams, hidden_state_beams)\n    return self.be.array(self.candidates[-1])",
            "def beamsearch(self, inputs, num_beams=5, steps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Perform an fprop path and beam search on a given set of network inputs.\\n\\n        Arguments:\\n            inputs (Tensor): Minibatch of network inputs\\n            num_beams (Int): Number of beams (hypothesis) to search over\\n            steps (Int): Length of desired output in number of time steps\\n        '\n    self.num_beams = num_beams\n    self.num_live = 1\n    self.num_dead = 0\n    if steps is None:\n        steps = self.layers.in_shape[1]\n    bsz = self.be.bsz\n    self.z_list = [self.be.iobuf(self.z_shape) for _ in range(num_beams)]\n    for i in range(num_beams):\n        if getattr(self.layers.decoder, 'start_index', None) is not None:\n            self.z_list[i][self.layers.decoder.start_index] = 1\n    self.candidates = [np.zeros((steps, bsz)) for _ in range(num_beams)]\n    self.scores = [np.zeros(bsz) for _ in range(num_beams)]\n    z = self.be.iobuf(self.z_shape)\n    self.layers.encoder.fprop(inputs, inference=True, beta=0.0)\n    final_states = self.layers.encoder.get_final_states(self.layers.decoder_connections)\n    if len(final_states) != len(self.layers.decoder._recurrent):\n        raise ValueError('number of decoder layers ({num_layers}) does not match the number of decoder connections ({num_decoder_connections}).'.format(num_layers=len(self.layers.decoder._recurrent), num_decoder_connections=len(final_states)))\n    else:\n        init_state_list = final_states\n    self.init_state_lists = [[self.be.zeros_like(rec.h[-1]) for rec in self.layers.decoder._recurrent] for _ in range(num_beams)]\n    self.init_state_lists[0] = init_state_list\n    if self.hasLUT:\n        z_beams = [self.be.iobuf(self.layers.decoder.out_shape) for _ in range(self.num_beams)]\n    else:\n        z_beams = [self.be.iobuf(self.z_shape) for _ in range(self.num_beams)]\n    hidden_state_beams = [[self.be.zeros_like(l.final_state()) for l in self.layers.decoder._recurrent] for _ in range(self.num_beams)]\n    for t in range(steps):\n        for bb in range(self.num_live):\n            z = self.layers.decoder.fprop(self.z_list[bb], inference=True, init_state_list=self.init_state_lists[bb])\n            z_beams[bb][:] = z\n            for (i, l) in enumerate(self.layers.decoder._recurrent):\n                hidden_state_beams[bb][i][:] = l.final_state()\n        self._beamsearch_step(t, z_beams, hidden_state_beams)\n    return self.be.array(self.candidates[-1])",
            "def beamsearch(self, inputs, num_beams=5, steps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Perform an fprop path and beam search on a given set of network inputs.\\n\\n        Arguments:\\n            inputs (Tensor): Minibatch of network inputs\\n            num_beams (Int): Number of beams (hypothesis) to search over\\n            steps (Int): Length of desired output in number of time steps\\n        '\n    self.num_beams = num_beams\n    self.num_live = 1\n    self.num_dead = 0\n    if steps is None:\n        steps = self.layers.in_shape[1]\n    bsz = self.be.bsz\n    self.z_list = [self.be.iobuf(self.z_shape) for _ in range(num_beams)]\n    for i in range(num_beams):\n        if getattr(self.layers.decoder, 'start_index', None) is not None:\n            self.z_list[i][self.layers.decoder.start_index] = 1\n    self.candidates = [np.zeros((steps, bsz)) for _ in range(num_beams)]\n    self.scores = [np.zeros(bsz) for _ in range(num_beams)]\n    z = self.be.iobuf(self.z_shape)\n    self.layers.encoder.fprop(inputs, inference=True, beta=0.0)\n    final_states = self.layers.encoder.get_final_states(self.layers.decoder_connections)\n    if len(final_states) != len(self.layers.decoder._recurrent):\n        raise ValueError('number of decoder layers ({num_layers}) does not match the number of decoder connections ({num_decoder_connections}).'.format(num_layers=len(self.layers.decoder._recurrent), num_decoder_connections=len(final_states)))\n    else:\n        init_state_list = final_states\n    self.init_state_lists = [[self.be.zeros_like(rec.h[-1]) for rec in self.layers.decoder._recurrent] for _ in range(num_beams)]\n    self.init_state_lists[0] = init_state_list\n    if self.hasLUT:\n        z_beams = [self.be.iobuf(self.layers.decoder.out_shape) for _ in range(self.num_beams)]\n    else:\n        z_beams = [self.be.iobuf(self.z_shape) for _ in range(self.num_beams)]\n    hidden_state_beams = [[self.be.zeros_like(l.final_state()) for l in self.layers.decoder._recurrent] for _ in range(self.num_beams)]\n    for t in range(steps):\n        for bb in range(self.num_live):\n            z = self.layers.decoder.fprop(self.z_list[bb], inference=True, init_state_list=self.init_state_lists[bb])\n            z_beams[bb][:] = z\n            for (i, l) in enumerate(self.layers.decoder._recurrent):\n                hidden_state_beams[bb][i][:] = l.final_state()\n        self._beamsearch_step(t, z_beams, hidden_state_beams)\n    return self.be.array(self.candidates[-1])"
        ]
    },
    {
        "func_name": "_beamsearch_step",
        "original": "def _beamsearch_step(self, t, z_list_t, init_state_lists):\n    \"\"\"\n        Arguments:\n            t (int): time step\n            z_list (list of tensors) : fprop outputs for all beams\n        \"\"\"\n    num_out = self.layers.out_shape[0]\n    init_state_lists_in = []\n    for isl in init_state_lists:\n        init_state_lists_in.append([state.get() for state in isl])\n    init_state_lists_out = [[np.zeros(tnsr.shape) for tnsr in init_state_lists[0]] for _ in range(len(init_state_lists_in))]\n    z_list = [z_list_t[bb].get() for bb in range(self.num_live)]\n    scores_list = [np.log(z) + score for (z, score) in zip(z_list, self.scores)]\n    scores = np.vstack(scores_list)\n    self.num_live = num_live = self.num_beams - self.num_dead\n    ind = scores.argsort(axis=0)[-num_live:]\n    self.scores_list = scores_list\n    hyp_num = (ind // num_out).astype(np.int32)\n    word_num = ind % num_out\n    old_candidates = [can.copy() for can in self.candidates]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            self.candidates[bb][:, ex_with_hyp] = old_candidates[hyp][:, ex_with_hyp]\n            wnum = word_num[bb, ex_with_hyp]\n            self.scores[bb][ex_with_hyp] = scores_list[hyp][wnum, ex_with_hyp]\n        self.candidates[bb][t, :] = word_num[bb, :]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            for ii in range(len(self.layers.decoder._recurrent)):\n                init_state_lists_out[bb][ii][:, ex_with_hyp] = init_state_lists_in[hyp][ii][:, ex_with_hyp]\n    for bb in range(num_live):\n        if self.hasLUT:\n            inputs = self.be.array(self.candidates[bb][t, :].reshape(1, -1))\n            self.z_list[bb][:] = inputs\n        else:\n            inputs = self.be.array(self.candidates[bb][t, :], dtype=np.int32)\n            self.z_list[bb][:] = self.be.onehot(inputs, axis=0)\n    for (ii, isl) in enumerate(init_state_lists_out):\n        for (jj, state) in enumerate(isl):\n            self.init_state_lists[ii][jj][:] = state",
        "mutated": [
            "def _beamsearch_step(self, t, z_list_t, init_state_lists):\n    if False:\n        i = 10\n    '\\n        Arguments:\\n            t (int): time step\\n            z_list (list of tensors) : fprop outputs for all beams\\n        '\n    num_out = self.layers.out_shape[0]\n    init_state_lists_in = []\n    for isl in init_state_lists:\n        init_state_lists_in.append([state.get() for state in isl])\n    init_state_lists_out = [[np.zeros(tnsr.shape) for tnsr in init_state_lists[0]] for _ in range(len(init_state_lists_in))]\n    z_list = [z_list_t[bb].get() for bb in range(self.num_live)]\n    scores_list = [np.log(z) + score for (z, score) in zip(z_list, self.scores)]\n    scores = np.vstack(scores_list)\n    self.num_live = num_live = self.num_beams - self.num_dead\n    ind = scores.argsort(axis=0)[-num_live:]\n    self.scores_list = scores_list\n    hyp_num = (ind // num_out).astype(np.int32)\n    word_num = ind % num_out\n    old_candidates = [can.copy() for can in self.candidates]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            self.candidates[bb][:, ex_with_hyp] = old_candidates[hyp][:, ex_with_hyp]\n            wnum = word_num[bb, ex_with_hyp]\n            self.scores[bb][ex_with_hyp] = scores_list[hyp][wnum, ex_with_hyp]\n        self.candidates[bb][t, :] = word_num[bb, :]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            for ii in range(len(self.layers.decoder._recurrent)):\n                init_state_lists_out[bb][ii][:, ex_with_hyp] = init_state_lists_in[hyp][ii][:, ex_with_hyp]\n    for bb in range(num_live):\n        if self.hasLUT:\n            inputs = self.be.array(self.candidates[bb][t, :].reshape(1, -1))\n            self.z_list[bb][:] = inputs\n        else:\n            inputs = self.be.array(self.candidates[bb][t, :], dtype=np.int32)\n            self.z_list[bb][:] = self.be.onehot(inputs, axis=0)\n    for (ii, isl) in enumerate(init_state_lists_out):\n        for (jj, state) in enumerate(isl):\n            self.init_state_lists[ii][jj][:] = state",
            "def _beamsearch_step(self, t, z_list_t, init_state_lists):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Arguments:\\n            t (int): time step\\n            z_list (list of tensors) : fprop outputs for all beams\\n        '\n    num_out = self.layers.out_shape[0]\n    init_state_lists_in = []\n    for isl in init_state_lists:\n        init_state_lists_in.append([state.get() for state in isl])\n    init_state_lists_out = [[np.zeros(tnsr.shape) for tnsr in init_state_lists[0]] for _ in range(len(init_state_lists_in))]\n    z_list = [z_list_t[bb].get() for bb in range(self.num_live)]\n    scores_list = [np.log(z) + score for (z, score) in zip(z_list, self.scores)]\n    scores = np.vstack(scores_list)\n    self.num_live = num_live = self.num_beams - self.num_dead\n    ind = scores.argsort(axis=0)[-num_live:]\n    self.scores_list = scores_list\n    hyp_num = (ind // num_out).astype(np.int32)\n    word_num = ind % num_out\n    old_candidates = [can.copy() for can in self.candidates]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            self.candidates[bb][:, ex_with_hyp] = old_candidates[hyp][:, ex_with_hyp]\n            wnum = word_num[bb, ex_with_hyp]\n            self.scores[bb][ex_with_hyp] = scores_list[hyp][wnum, ex_with_hyp]\n        self.candidates[bb][t, :] = word_num[bb, :]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            for ii in range(len(self.layers.decoder._recurrent)):\n                init_state_lists_out[bb][ii][:, ex_with_hyp] = init_state_lists_in[hyp][ii][:, ex_with_hyp]\n    for bb in range(num_live):\n        if self.hasLUT:\n            inputs = self.be.array(self.candidates[bb][t, :].reshape(1, -1))\n            self.z_list[bb][:] = inputs\n        else:\n            inputs = self.be.array(self.candidates[bb][t, :], dtype=np.int32)\n            self.z_list[bb][:] = self.be.onehot(inputs, axis=0)\n    for (ii, isl) in enumerate(init_state_lists_out):\n        for (jj, state) in enumerate(isl):\n            self.init_state_lists[ii][jj][:] = state",
            "def _beamsearch_step(self, t, z_list_t, init_state_lists):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Arguments:\\n            t (int): time step\\n            z_list (list of tensors) : fprop outputs for all beams\\n        '\n    num_out = self.layers.out_shape[0]\n    init_state_lists_in = []\n    for isl in init_state_lists:\n        init_state_lists_in.append([state.get() for state in isl])\n    init_state_lists_out = [[np.zeros(tnsr.shape) for tnsr in init_state_lists[0]] for _ in range(len(init_state_lists_in))]\n    z_list = [z_list_t[bb].get() for bb in range(self.num_live)]\n    scores_list = [np.log(z) + score for (z, score) in zip(z_list, self.scores)]\n    scores = np.vstack(scores_list)\n    self.num_live = num_live = self.num_beams - self.num_dead\n    ind = scores.argsort(axis=0)[-num_live:]\n    self.scores_list = scores_list\n    hyp_num = (ind // num_out).astype(np.int32)\n    word_num = ind % num_out\n    old_candidates = [can.copy() for can in self.candidates]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            self.candidates[bb][:, ex_with_hyp] = old_candidates[hyp][:, ex_with_hyp]\n            wnum = word_num[bb, ex_with_hyp]\n            self.scores[bb][ex_with_hyp] = scores_list[hyp][wnum, ex_with_hyp]\n        self.candidates[bb][t, :] = word_num[bb, :]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            for ii in range(len(self.layers.decoder._recurrent)):\n                init_state_lists_out[bb][ii][:, ex_with_hyp] = init_state_lists_in[hyp][ii][:, ex_with_hyp]\n    for bb in range(num_live):\n        if self.hasLUT:\n            inputs = self.be.array(self.candidates[bb][t, :].reshape(1, -1))\n            self.z_list[bb][:] = inputs\n        else:\n            inputs = self.be.array(self.candidates[bb][t, :], dtype=np.int32)\n            self.z_list[bb][:] = self.be.onehot(inputs, axis=0)\n    for (ii, isl) in enumerate(init_state_lists_out):\n        for (jj, state) in enumerate(isl):\n            self.init_state_lists[ii][jj][:] = state",
            "def _beamsearch_step(self, t, z_list_t, init_state_lists):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Arguments:\\n            t (int): time step\\n            z_list (list of tensors) : fprop outputs for all beams\\n        '\n    num_out = self.layers.out_shape[0]\n    init_state_lists_in = []\n    for isl in init_state_lists:\n        init_state_lists_in.append([state.get() for state in isl])\n    init_state_lists_out = [[np.zeros(tnsr.shape) for tnsr in init_state_lists[0]] for _ in range(len(init_state_lists_in))]\n    z_list = [z_list_t[bb].get() for bb in range(self.num_live)]\n    scores_list = [np.log(z) + score for (z, score) in zip(z_list, self.scores)]\n    scores = np.vstack(scores_list)\n    self.num_live = num_live = self.num_beams - self.num_dead\n    ind = scores.argsort(axis=0)[-num_live:]\n    self.scores_list = scores_list\n    hyp_num = (ind // num_out).astype(np.int32)\n    word_num = ind % num_out\n    old_candidates = [can.copy() for can in self.candidates]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            self.candidates[bb][:, ex_with_hyp] = old_candidates[hyp][:, ex_with_hyp]\n            wnum = word_num[bb, ex_with_hyp]\n            self.scores[bb][ex_with_hyp] = scores_list[hyp][wnum, ex_with_hyp]\n        self.candidates[bb][t, :] = word_num[bb, :]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            for ii in range(len(self.layers.decoder._recurrent)):\n                init_state_lists_out[bb][ii][:, ex_with_hyp] = init_state_lists_in[hyp][ii][:, ex_with_hyp]\n    for bb in range(num_live):\n        if self.hasLUT:\n            inputs = self.be.array(self.candidates[bb][t, :].reshape(1, -1))\n            self.z_list[bb][:] = inputs\n        else:\n            inputs = self.be.array(self.candidates[bb][t, :], dtype=np.int32)\n            self.z_list[bb][:] = self.be.onehot(inputs, axis=0)\n    for (ii, isl) in enumerate(init_state_lists_out):\n        for (jj, state) in enumerate(isl):\n            self.init_state_lists[ii][jj][:] = state",
            "def _beamsearch_step(self, t, z_list_t, init_state_lists):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Arguments:\\n            t (int): time step\\n            z_list (list of tensors) : fprop outputs for all beams\\n        '\n    num_out = self.layers.out_shape[0]\n    init_state_lists_in = []\n    for isl in init_state_lists:\n        init_state_lists_in.append([state.get() for state in isl])\n    init_state_lists_out = [[np.zeros(tnsr.shape) for tnsr in init_state_lists[0]] for _ in range(len(init_state_lists_in))]\n    z_list = [z_list_t[bb].get() for bb in range(self.num_live)]\n    scores_list = [np.log(z) + score for (z, score) in zip(z_list, self.scores)]\n    scores = np.vstack(scores_list)\n    self.num_live = num_live = self.num_beams - self.num_dead\n    ind = scores.argsort(axis=0)[-num_live:]\n    self.scores_list = scores_list\n    hyp_num = (ind // num_out).astype(np.int32)\n    word_num = ind % num_out\n    old_candidates = [can.copy() for can in self.candidates]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            self.candidates[bb][:, ex_with_hyp] = old_candidates[hyp][:, ex_with_hyp]\n            wnum = word_num[bb, ex_with_hyp]\n            self.scores[bb][ex_with_hyp] = scores_list[hyp][wnum, ex_with_hyp]\n        self.candidates[bb][t, :] = word_num[bb, :]\n    for bb in range(num_live):\n        for hyp in range(len(scores_list)):\n            ex_with_hyp = np.where(hyp_num[bb, :] == hyp)[0]\n            for ii in range(len(self.layers.decoder._recurrent)):\n                init_state_lists_out[bb][ii][:, ex_with_hyp] = init_state_lists_in[hyp][ii][:, ex_with_hyp]\n    for bb in range(num_live):\n        if self.hasLUT:\n            inputs = self.be.array(self.candidates[bb][t, :].reshape(1, -1))\n            self.z_list[bb][:] = inputs\n        else:\n            inputs = self.be.array(self.candidates[bb][t, :], dtype=np.int32)\n            self.z_list[bb][:] = self.be.onehot(inputs, axis=0)\n    for (ii, isl) in enumerate(init_state_lists_out):\n        for (jj, state) in enumerate(isl):\n            self.init_state_lists[ii][jj][:] = state"
        ]
    }
]