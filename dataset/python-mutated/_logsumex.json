[
    {
        "func_name": "logsumexp",
        "original": "def logsumexp(a, axis=None, b=None, keepdims=False, return_sign=False):\n    \"\"\"Compute the log of the sum of exponentials of input elements.\n\n    Parameters\n    ----------\n    a : cupy.ndarray\n        Input array\n    axis : None or int or tuple of ints, optional\n        Axis or axes over which the sum is taken. By default\n        `axis` is None, and all elements are summed\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced\n        are left in the result as dimensions with size one. With\n        this option, the result will broadcast correctly\n        against the original array\n    b : cupy.ndarray, optional\n        Scaling factor for exp(`a`) must be of the same shape as `a` or\n        broadcastable to `a`. These values may be negative in order to\n        implement subtraction\n    return_sign : bool, optional\n        If this is set to True, the result will be a pair containing sign\n        information; if False, results that are negative will be returned\n        as NaN. Default is False\n\n    Returns\n    -------\n    res : cupy.ndarray\n        The result, ``cp.log(cp.sum(cp.exp(a)))`` calculated\n        in a numerically more stable way. If `b` is given then\n        ``cp.log(cp.sum(b*cp.exp(a)))`` is returned\n    sgn : cupy.ndarray\n        If return_sign is True, this will be an array of floating-point\n        numbers matching res and +1, 0, or -1 depending on the sign of\n        the result. If False, only onw result is returned\n\n    See Also\n    --------\n    scipy.special.logsumexp\n\n    \"\"\"\n    if b is not None:\n        (a, b) = cp.broadcast_arrays(a, b)\n        if cp.any(b == 0):\n            a = a + 0.0\n            a[b == 0] = -cp.inf\n    a_max = cp.max(a, axis=axis, keepdims=True)\n    if a_max.ndim > 0:\n        a_max[~cp.isfinite(a_max)] = 0\n    elif not cp.isfinite(a_max):\n        a_max = 0\n    if b is not None:\n        tmp = b * cp.exp(a - a_max)\n    else:\n        tmp = cp.exp(a - a_max)\n    s = cp.sum(tmp, axis=axis, keepdims=keepdims)\n    if return_sign:\n        sgn = cp.sign(s)\n        s *= sgn\n    out = cp.log(s)\n    if not keepdims:\n        a_max = cp.squeeze(a_max, axis=axis)\n    out += a_max\n    if return_sign:\n        return (out, sgn)\n    else:\n        return out",
        "mutated": [
            "def logsumexp(a, axis=None, b=None, keepdims=False, return_sign=False):\n    if False:\n        i = 10\n    'Compute the log of the sum of exponentials of input elements.\\n\\n    Parameters\\n    ----------\\n    a : cupy.ndarray\\n        Input array\\n    axis : None or int or tuple of ints, optional\\n        Axis or axes over which the sum is taken. By default\\n        `axis` is None, and all elements are summed\\n    keepdims : bool, optional\\n        If this is set to True, the axes which are reduced\\n        are left in the result as dimensions with size one. With\\n        this option, the result will broadcast correctly\\n        against the original array\\n    b : cupy.ndarray, optional\\n        Scaling factor for exp(`a`) must be of the same shape as `a` or\\n        broadcastable to `a`. These values may be negative in order to\\n        implement subtraction\\n    return_sign : bool, optional\\n        If this is set to True, the result will be a pair containing sign\\n        information; if False, results that are negative will be returned\\n        as NaN. Default is False\\n\\n    Returns\\n    -------\\n    res : cupy.ndarray\\n        The result, ``cp.log(cp.sum(cp.exp(a)))`` calculated\\n        in a numerically more stable way. If `b` is given then\\n        ``cp.log(cp.sum(b*cp.exp(a)))`` is returned\\n    sgn : cupy.ndarray\\n        If return_sign is True, this will be an array of floating-point\\n        numbers matching res and +1, 0, or -1 depending on the sign of\\n        the result. If False, only onw result is returned\\n\\n    See Also\\n    --------\\n    scipy.special.logsumexp\\n\\n    '\n    if b is not None:\n        (a, b) = cp.broadcast_arrays(a, b)\n        if cp.any(b == 0):\n            a = a + 0.0\n            a[b == 0] = -cp.inf\n    a_max = cp.max(a, axis=axis, keepdims=True)\n    if a_max.ndim > 0:\n        a_max[~cp.isfinite(a_max)] = 0\n    elif not cp.isfinite(a_max):\n        a_max = 0\n    if b is not None:\n        tmp = b * cp.exp(a - a_max)\n    else:\n        tmp = cp.exp(a - a_max)\n    s = cp.sum(tmp, axis=axis, keepdims=keepdims)\n    if return_sign:\n        sgn = cp.sign(s)\n        s *= sgn\n    out = cp.log(s)\n    if not keepdims:\n        a_max = cp.squeeze(a_max, axis=axis)\n    out += a_max\n    if return_sign:\n        return (out, sgn)\n    else:\n        return out",
            "def logsumexp(a, axis=None, b=None, keepdims=False, return_sign=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the log of the sum of exponentials of input elements.\\n\\n    Parameters\\n    ----------\\n    a : cupy.ndarray\\n        Input array\\n    axis : None or int or tuple of ints, optional\\n        Axis or axes over which the sum is taken. By default\\n        `axis` is None, and all elements are summed\\n    keepdims : bool, optional\\n        If this is set to True, the axes which are reduced\\n        are left in the result as dimensions with size one. With\\n        this option, the result will broadcast correctly\\n        against the original array\\n    b : cupy.ndarray, optional\\n        Scaling factor for exp(`a`) must be of the same shape as `a` or\\n        broadcastable to `a`. These values may be negative in order to\\n        implement subtraction\\n    return_sign : bool, optional\\n        If this is set to True, the result will be a pair containing sign\\n        information; if False, results that are negative will be returned\\n        as NaN. Default is False\\n\\n    Returns\\n    -------\\n    res : cupy.ndarray\\n        The result, ``cp.log(cp.sum(cp.exp(a)))`` calculated\\n        in a numerically more stable way. If `b` is given then\\n        ``cp.log(cp.sum(b*cp.exp(a)))`` is returned\\n    sgn : cupy.ndarray\\n        If return_sign is True, this will be an array of floating-point\\n        numbers matching res and +1, 0, or -1 depending on the sign of\\n        the result. If False, only onw result is returned\\n\\n    See Also\\n    --------\\n    scipy.special.logsumexp\\n\\n    '\n    if b is not None:\n        (a, b) = cp.broadcast_arrays(a, b)\n        if cp.any(b == 0):\n            a = a + 0.0\n            a[b == 0] = -cp.inf\n    a_max = cp.max(a, axis=axis, keepdims=True)\n    if a_max.ndim > 0:\n        a_max[~cp.isfinite(a_max)] = 0\n    elif not cp.isfinite(a_max):\n        a_max = 0\n    if b is not None:\n        tmp = b * cp.exp(a - a_max)\n    else:\n        tmp = cp.exp(a - a_max)\n    s = cp.sum(tmp, axis=axis, keepdims=keepdims)\n    if return_sign:\n        sgn = cp.sign(s)\n        s *= sgn\n    out = cp.log(s)\n    if not keepdims:\n        a_max = cp.squeeze(a_max, axis=axis)\n    out += a_max\n    if return_sign:\n        return (out, sgn)\n    else:\n        return out",
            "def logsumexp(a, axis=None, b=None, keepdims=False, return_sign=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the log of the sum of exponentials of input elements.\\n\\n    Parameters\\n    ----------\\n    a : cupy.ndarray\\n        Input array\\n    axis : None or int or tuple of ints, optional\\n        Axis or axes over which the sum is taken. By default\\n        `axis` is None, and all elements are summed\\n    keepdims : bool, optional\\n        If this is set to True, the axes which are reduced\\n        are left in the result as dimensions with size one. With\\n        this option, the result will broadcast correctly\\n        against the original array\\n    b : cupy.ndarray, optional\\n        Scaling factor for exp(`a`) must be of the same shape as `a` or\\n        broadcastable to `a`. These values may be negative in order to\\n        implement subtraction\\n    return_sign : bool, optional\\n        If this is set to True, the result will be a pair containing sign\\n        information; if False, results that are negative will be returned\\n        as NaN. Default is False\\n\\n    Returns\\n    -------\\n    res : cupy.ndarray\\n        The result, ``cp.log(cp.sum(cp.exp(a)))`` calculated\\n        in a numerically more stable way. If `b` is given then\\n        ``cp.log(cp.sum(b*cp.exp(a)))`` is returned\\n    sgn : cupy.ndarray\\n        If return_sign is True, this will be an array of floating-point\\n        numbers matching res and +1, 0, or -1 depending on the sign of\\n        the result. If False, only onw result is returned\\n\\n    See Also\\n    --------\\n    scipy.special.logsumexp\\n\\n    '\n    if b is not None:\n        (a, b) = cp.broadcast_arrays(a, b)\n        if cp.any(b == 0):\n            a = a + 0.0\n            a[b == 0] = -cp.inf\n    a_max = cp.max(a, axis=axis, keepdims=True)\n    if a_max.ndim > 0:\n        a_max[~cp.isfinite(a_max)] = 0\n    elif not cp.isfinite(a_max):\n        a_max = 0\n    if b is not None:\n        tmp = b * cp.exp(a - a_max)\n    else:\n        tmp = cp.exp(a - a_max)\n    s = cp.sum(tmp, axis=axis, keepdims=keepdims)\n    if return_sign:\n        sgn = cp.sign(s)\n        s *= sgn\n    out = cp.log(s)\n    if not keepdims:\n        a_max = cp.squeeze(a_max, axis=axis)\n    out += a_max\n    if return_sign:\n        return (out, sgn)\n    else:\n        return out",
            "def logsumexp(a, axis=None, b=None, keepdims=False, return_sign=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the log of the sum of exponentials of input elements.\\n\\n    Parameters\\n    ----------\\n    a : cupy.ndarray\\n        Input array\\n    axis : None or int or tuple of ints, optional\\n        Axis or axes over which the sum is taken. By default\\n        `axis` is None, and all elements are summed\\n    keepdims : bool, optional\\n        If this is set to True, the axes which are reduced\\n        are left in the result as dimensions with size one. With\\n        this option, the result will broadcast correctly\\n        against the original array\\n    b : cupy.ndarray, optional\\n        Scaling factor for exp(`a`) must be of the same shape as `a` or\\n        broadcastable to `a`. These values may be negative in order to\\n        implement subtraction\\n    return_sign : bool, optional\\n        If this is set to True, the result will be a pair containing sign\\n        information; if False, results that are negative will be returned\\n        as NaN. Default is False\\n\\n    Returns\\n    -------\\n    res : cupy.ndarray\\n        The result, ``cp.log(cp.sum(cp.exp(a)))`` calculated\\n        in a numerically more stable way. If `b` is given then\\n        ``cp.log(cp.sum(b*cp.exp(a)))`` is returned\\n    sgn : cupy.ndarray\\n        If return_sign is True, this will be an array of floating-point\\n        numbers matching res and +1, 0, or -1 depending on the sign of\\n        the result. If False, only onw result is returned\\n\\n    See Also\\n    --------\\n    scipy.special.logsumexp\\n\\n    '\n    if b is not None:\n        (a, b) = cp.broadcast_arrays(a, b)\n        if cp.any(b == 0):\n            a = a + 0.0\n            a[b == 0] = -cp.inf\n    a_max = cp.max(a, axis=axis, keepdims=True)\n    if a_max.ndim > 0:\n        a_max[~cp.isfinite(a_max)] = 0\n    elif not cp.isfinite(a_max):\n        a_max = 0\n    if b is not None:\n        tmp = b * cp.exp(a - a_max)\n    else:\n        tmp = cp.exp(a - a_max)\n    s = cp.sum(tmp, axis=axis, keepdims=keepdims)\n    if return_sign:\n        sgn = cp.sign(s)\n        s *= sgn\n    out = cp.log(s)\n    if not keepdims:\n        a_max = cp.squeeze(a_max, axis=axis)\n    out += a_max\n    if return_sign:\n        return (out, sgn)\n    else:\n        return out",
            "def logsumexp(a, axis=None, b=None, keepdims=False, return_sign=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the log of the sum of exponentials of input elements.\\n\\n    Parameters\\n    ----------\\n    a : cupy.ndarray\\n        Input array\\n    axis : None or int or tuple of ints, optional\\n        Axis or axes over which the sum is taken. By default\\n        `axis` is None, and all elements are summed\\n    keepdims : bool, optional\\n        If this is set to True, the axes which are reduced\\n        are left in the result as dimensions with size one. With\\n        this option, the result will broadcast correctly\\n        against the original array\\n    b : cupy.ndarray, optional\\n        Scaling factor for exp(`a`) must be of the same shape as `a` or\\n        broadcastable to `a`. These values may be negative in order to\\n        implement subtraction\\n    return_sign : bool, optional\\n        If this is set to True, the result will be a pair containing sign\\n        information; if False, results that are negative will be returned\\n        as NaN. Default is False\\n\\n    Returns\\n    -------\\n    res : cupy.ndarray\\n        The result, ``cp.log(cp.sum(cp.exp(a)))`` calculated\\n        in a numerically more stable way. If `b` is given then\\n        ``cp.log(cp.sum(b*cp.exp(a)))`` is returned\\n    sgn : cupy.ndarray\\n        If return_sign is True, this will be an array of floating-point\\n        numbers matching res and +1, 0, or -1 depending on the sign of\\n        the result. If False, only onw result is returned\\n\\n    See Also\\n    --------\\n    scipy.special.logsumexp\\n\\n    '\n    if b is not None:\n        (a, b) = cp.broadcast_arrays(a, b)\n        if cp.any(b == 0):\n            a = a + 0.0\n            a[b == 0] = -cp.inf\n    a_max = cp.max(a, axis=axis, keepdims=True)\n    if a_max.ndim > 0:\n        a_max[~cp.isfinite(a_max)] = 0\n    elif not cp.isfinite(a_max):\n        a_max = 0\n    if b is not None:\n        tmp = b * cp.exp(a - a_max)\n    else:\n        tmp = cp.exp(a - a_max)\n    s = cp.sum(tmp, axis=axis, keepdims=keepdims)\n    if return_sign:\n        sgn = cp.sign(s)\n        s *= sgn\n    out = cp.log(s)\n    if not keepdims:\n        a_max = cp.squeeze(a_max, axis=axis)\n    out += a_max\n    if return_sign:\n        return (out, sgn)\n    else:\n        return out"
        ]
    }
]