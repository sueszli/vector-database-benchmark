[
    {
        "func_name": "random_scrambling_vectors",
        "original": "def random_scrambling_vectors(dim: types.IntTensor, seed: int, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    \"\"\"Returns a `Tensor` drawn from a uniform distribution.\n\n  The returned `Tensor` can be can be added to the specified\n  `generating_vectors` in order to randomize it.\n\n  #### Examples\n\n  ```python\n  import tf_quant_finance as tff\n\n  # Example: Creating random vectors which can scramble 2D generating vectors.\n\n  dim = 2\n  seed = (2, 3)\n\n  tff.math.qmc.random_scrambling_vectors(dim, seed=seed)\n  # ==> tf.Tensor([0.17481351, 0.9780868], shape=(2,), dtype=float32)\n  ```\n\n  Args:\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of\n      points which can be sampled from the generating vectors to scramble.\n    seed: Positive scalar `Tensor` with shape [2] and dtype `int32` used as seed\n      for the random generator.\n    validate_args: Python `bool` indicating whether to validate arguments.\n      Default value: `False`.\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\n      `float32` or `float64`).\n      Default value: `None` which maps to `tf.float32`.\n    name: Python `str` name prefixed to ops created by this function.\n      Default value: `None` which maps to `random_scrambling_vectors`.\n\n  Returns:\n    A `Tensor` of real values between 0 (incl.) and 1 (excl.) with `shape`\n    `(dim,)`.\n  \"\"\"\n    with tf.name_scope(name or 'random_scrambling_vectors'):\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_positive(dim, message='dim must be positive'))\n        with tf.control_dependencies(control_deps):\n            return tf.random.stateless_uniform((dim,), seed, minval=0.0, maxval=1.0, dtype=dtype or tf.float32)",
        "mutated": [
            "def random_scrambling_vectors(dim: types.IntTensor, seed: int, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n    'Returns a `Tensor` drawn from a uniform distribution.\\n\\n  The returned `Tensor` can be can be added to the specified\\n  `generating_vectors` in order to randomize it.\\n\\n  #### Examples\\n\\n  ```python\\n  import tf_quant_finance as tff\\n\\n  # Example: Creating random vectors which can scramble 2D generating vectors.\\n\\n  dim = 2\\n  seed = (2, 3)\\n\\n  tff.math.qmc.random_scrambling_vectors(dim, seed=seed)\\n  # ==> tf.Tensor([0.17481351, 0.9780868], shape=(2,), dtype=float32)\\n  ```\\n\\n  Args:\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of\\n      points which can be sampled from the generating vectors to scramble.\\n    seed: Positive scalar `Tensor` with shape [2] and dtype `int32` used as seed\\n      for the random generator.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `tf.float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `random_scrambling_vectors`.\\n\\n  Returns:\\n    A `Tensor` of real values between 0 (incl.) and 1 (excl.) with `shape`\\n    `(dim,)`.\\n  '\n    with tf.name_scope(name or 'random_scrambling_vectors'):\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_positive(dim, message='dim must be positive'))\n        with tf.control_dependencies(control_deps):\n            return tf.random.stateless_uniform((dim,), seed, minval=0.0, maxval=1.0, dtype=dtype or tf.float32)",
            "def random_scrambling_vectors(dim: types.IntTensor, seed: int, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a `Tensor` drawn from a uniform distribution.\\n\\n  The returned `Tensor` can be can be added to the specified\\n  `generating_vectors` in order to randomize it.\\n\\n  #### Examples\\n\\n  ```python\\n  import tf_quant_finance as tff\\n\\n  # Example: Creating random vectors which can scramble 2D generating vectors.\\n\\n  dim = 2\\n  seed = (2, 3)\\n\\n  tff.math.qmc.random_scrambling_vectors(dim, seed=seed)\\n  # ==> tf.Tensor([0.17481351, 0.9780868], shape=(2,), dtype=float32)\\n  ```\\n\\n  Args:\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of\\n      points which can be sampled from the generating vectors to scramble.\\n    seed: Positive scalar `Tensor` with shape [2] and dtype `int32` used as seed\\n      for the random generator.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `tf.float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `random_scrambling_vectors`.\\n\\n  Returns:\\n    A `Tensor` of real values between 0 (incl.) and 1 (excl.) with `shape`\\n    `(dim,)`.\\n  '\n    with tf.name_scope(name or 'random_scrambling_vectors'):\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_positive(dim, message='dim must be positive'))\n        with tf.control_dependencies(control_deps):\n            return tf.random.stateless_uniform((dim,), seed, minval=0.0, maxval=1.0, dtype=dtype or tf.float32)",
            "def random_scrambling_vectors(dim: types.IntTensor, seed: int, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a `Tensor` drawn from a uniform distribution.\\n\\n  The returned `Tensor` can be can be added to the specified\\n  `generating_vectors` in order to randomize it.\\n\\n  #### Examples\\n\\n  ```python\\n  import tf_quant_finance as tff\\n\\n  # Example: Creating random vectors which can scramble 2D generating vectors.\\n\\n  dim = 2\\n  seed = (2, 3)\\n\\n  tff.math.qmc.random_scrambling_vectors(dim, seed=seed)\\n  # ==> tf.Tensor([0.17481351, 0.9780868], shape=(2,), dtype=float32)\\n  ```\\n\\n  Args:\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of\\n      points which can be sampled from the generating vectors to scramble.\\n    seed: Positive scalar `Tensor` with shape [2] and dtype `int32` used as seed\\n      for the random generator.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `tf.float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `random_scrambling_vectors`.\\n\\n  Returns:\\n    A `Tensor` of real values between 0 (incl.) and 1 (excl.) with `shape`\\n    `(dim,)`.\\n  '\n    with tf.name_scope(name or 'random_scrambling_vectors'):\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_positive(dim, message='dim must be positive'))\n        with tf.control_dependencies(control_deps):\n            return tf.random.stateless_uniform((dim,), seed, minval=0.0, maxval=1.0, dtype=dtype or tf.float32)",
            "def random_scrambling_vectors(dim: types.IntTensor, seed: int, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a `Tensor` drawn from a uniform distribution.\\n\\n  The returned `Tensor` can be can be added to the specified\\n  `generating_vectors` in order to randomize it.\\n\\n  #### Examples\\n\\n  ```python\\n  import tf_quant_finance as tff\\n\\n  # Example: Creating random vectors which can scramble 2D generating vectors.\\n\\n  dim = 2\\n  seed = (2, 3)\\n\\n  tff.math.qmc.random_scrambling_vectors(dim, seed=seed)\\n  # ==> tf.Tensor([0.17481351, 0.9780868], shape=(2,), dtype=float32)\\n  ```\\n\\n  Args:\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of\\n      points which can be sampled from the generating vectors to scramble.\\n    seed: Positive scalar `Tensor` with shape [2] and dtype `int32` used as seed\\n      for the random generator.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `tf.float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `random_scrambling_vectors`.\\n\\n  Returns:\\n    A `Tensor` of real values between 0 (incl.) and 1 (excl.) with `shape`\\n    `(dim,)`.\\n  '\n    with tf.name_scope(name or 'random_scrambling_vectors'):\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_positive(dim, message='dim must be positive'))\n        with tf.control_dependencies(control_deps):\n            return tf.random.stateless_uniform((dim,), seed, minval=0.0, maxval=1.0, dtype=dtype or tf.float32)",
            "def random_scrambling_vectors(dim: types.IntTensor, seed: int, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a `Tensor` drawn from a uniform distribution.\\n\\n  The returned `Tensor` can be can be added to the specified\\n  `generating_vectors` in order to randomize it.\\n\\n  #### Examples\\n\\n  ```python\\n  import tf_quant_finance as tff\\n\\n  # Example: Creating random vectors which can scramble 2D generating vectors.\\n\\n  dim = 2\\n  seed = (2, 3)\\n\\n  tff.math.qmc.random_scrambling_vectors(dim, seed=seed)\\n  # ==> tf.Tensor([0.17481351, 0.9780868], shape=(2,), dtype=float32)\\n  ```\\n\\n  Args:\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of\\n      points which can be sampled from the generating vectors to scramble.\\n    seed: Positive scalar `Tensor` with shape [2] and dtype `int32` used as seed\\n      for the random generator.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `tf.float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `random_scrambling_vectors`.\\n\\n  Returns:\\n    A `Tensor` of real values between 0 (incl.) and 1 (excl.) with `shape`\\n    `(dim,)`.\\n  '\n    with tf.name_scope(name or 'random_scrambling_vectors'):\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_positive(dim, message='dim must be positive'))\n        with tf.control_dependencies(control_deps):\n            return tf.random.stateless_uniform((dim,), seed, minval=0.0, maxval=1.0, dtype=dtype or tf.float32)"
        ]
    },
    {
        "func_name": "lattice_rule_sample",
        "original": "def lattice_rule_sample(generating_vectors: types.IntTensor, dim: types.IntTensor, num_results: types.IntTensor, sequence_indices: types.IntTensor=None, additive_shift: types.FloatTensor=None, apply_tent_transform: bool=False, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    \"\"\"Constructs a lattice rule from a generating vector.\n\n  #### Examples\n\n  ```python\n  import tensorflow as tf\n  import tf_quant_finance as tff\n\n  # Example: Sampling 1,000 points from 2D generating vectors.\n\n  generating_vectors = tf.constant([1, 387275, 314993, 50301], dtype=tf.int32)\n\n  dim = 2\n  num_results = 1000\n\n  tff.math.qmc.lattice_rule_sample(generating_vectors, dim, num_results)\n  # ==> tf.Tensor([\n  #             [0.,         0.        ],\n  #             [0.001,      0.2749939 ],\n  #             [0.002,      0.5499878 ],\n  #             ...\n  #             [0.99700004, 0.1689148 ],\n  #             [0.998,      0.4439087 ],\n  #             [0.9990001,  0.7189026 ],\n  #         ], shape=(1000, 2), dtype=float32)\n  ```\n\n  Args:\n    generating_vectors: Positive scalar `Tensor` of integers with rank 1\n      representing the vector from which to sample points.\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of the\n      sampled points. Must not exceed the size of `generating_vectors`.\n    num_results: Positive scalar `Tensor` of integers with rank 0. The maximum\n      number of points to sample.\n    sequence_indices: Optional positive scalar `Tensor` of integers with rank 1.\n      The elements of the sequence to return specified by their position in the\n      sequence.\n      Default value: `None` which corresponds to the `[0, num_results)` range.\n    additive_shift: Optional scalar `Tensor` of real values with the same\n      `shape` as `generating_vectors`. The additive shift to add to all the\n      points (modulo 1) before applying the tent transform.\n      Default value: `None`.\n    apply_tent_transform: Python `bool` indicating whether to apply a tent\n      transform to the sampled points.\n      Default value: `False`.\n    validate_args: Python `bool` indicating whether to validate arguments.\n      Default value: `False`.\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\n      `float32` or `float64`).\n      Default value: `None` which maps to `float32`.\n    name: Python `str` name prefixed to ops created by this function.\n      Default value: `None` which maps to `sample_lattice_rule`.\n\n  Returns:\n    A `Tensor` of samples from  the Sobol sequence with `shape`\n    `(num_samples,)` where `num_samples = min(num_results,\n    size(sequence_indices))`.\n  \"\"\"\n    with tf.name_scope(name or 'sample_lattice_rule'):\n        generating_vectors = tf.convert_to_tensor(generating_vectors, name='generating_vectors')\n        int_dtype = generating_vectors.dtype\n        real_dtype = dtype or tf.float32\n        dim = tf.convert_to_tensor(dim, dtype=int_dtype, name='dim')\n        num_results = tf.convert_to_tensor(num_results, dtype=int_dtype, name='num_results')\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_equal(tf.rank(generating_vectors), 1, message='generating_vectors must have rank 1'))\n            control_deps.append(tf.debugging.assert_less_equal(dim, tf.size(generating_vectors, out_type=int_dtype), message='dim must not exceed the size of generating_vectors'))\n            control_deps.append(tf.debugging.assert_positive(num_results, message='num_results must be positive'))\n        with tf.control_dependencies(control_deps):\n            if sequence_indices is None:\n                sequence_indices = tf.range(0, num_results)\n            sequence_indices = tf.cast(sequence_indices, int_dtype, name='sequence_indices')\n            unit = tf.ones(shape=(), dtype=real_dtype)\n            scaled_vector = tf.divide(tf.cast(generating_vectors[:dim], real_dtype), tf.cast(num_results, real_dtype))\n            points = tf.multiply(tf.expand_dims(tf.cast(sequence_indices, real_dtype), axis=1), tf.expand_dims(tf.math.floormod(scaled_vector, unit), axis=0))\n            if additive_shift is not None:\n                additive_shift = tf.cast(additive_shift, real_dtype, name='additive_shift')\n                points += additive_shift[:dim]\n            points = tf.math.floormod(points, unit)\n            return utils.tent_transform(points) if apply_tent_transform else points",
        "mutated": [
            "def lattice_rule_sample(generating_vectors: types.IntTensor, dim: types.IntTensor, num_results: types.IntTensor, sequence_indices: types.IntTensor=None, additive_shift: types.FloatTensor=None, apply_tent_transform: bool=False, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n    'Constructs a lattice rule from a generating vector.\\n\\n  #### Examples\\n\\n  ```python\\n  import tensorflow as tf\\n  import tf_quant_finance as tff\\n\\n  # Example: Sampling 1,000 points from 2D generating vectors.\\n\\n  generating_vectors = tf.constant([1, 387275, 314993, 50301], dtype=tf.int32)\\n\\n  dim = 2\\n  num_results = 1000\\n\\n  tff.math.qmc.lattice_rule_sample(generating_vectors, dim, num_results)\\n  # ==> tf.Tensor([\\n  #             [0.,         0.        ],\\n  #             [0.001,      0.2749939 ],\\n  #             [0.002,      0.5499878 ],\\n  #             ...\\n  #             [0.99700004, 0.1689148 ],\\n  #             [0.998,      0.4439087 ],\\n  #             [0.9990001,  0.7189026 ],\\n  #         ], shape=(1000, 2), dtype=float32)\\n  ```\\n\\n  Args:\\n    generating_vectors: Positive scalar `Tensor` of integers with rank 1\\n      representing the vector from which to sample points.\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of the\\n      sampled points. Must not exceed the size of `generating_vectors`.\\n    num_results: Positive scalar `Tensor` of integers with rank 0. The maximum\\n      number of points to sample.\\n    sequence_indices: Optional positive scalar `Tensor` of integers with rank 1.\\n      The elements of the sequence to return specified by their position in the\\n      sequence.\\n      Default value: `None` which corresponds to the `[0, num_results)` range.\\n    additive_shift: Optional scalar `Tensor` of real values with the same\\n      `shape` as `generating_vectors`. The additive shift to add to all the\\n      points (modulo 1) before applying the tent transform.\\n      Default value: `None`.\\n    apply_tent_transform: Python `bool` indicating whether to apply a tent\\n      transform to the sampled points.\\n      Default value: `False`.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `sample_lattice_rule`.\\n\\n  Returns:\\n    A `Tensor` of samples from  the Sobol sequence with `shape`\\n    `(num_samples,)` where `num_samples = min(num_results,\\n    size(sequence_indices))`.\\n  '\n    with tf.name_scope(name or 'sample_lattice_rule'):\n        generating_vectors = tf.convert_to_tensor(generating_vectors, name='generating_vectors')\n        int_dtype = generating_vectors.dtype\n        real_dtype = dtype or tf.float32\n        dim = tf.convert_to_tensor(dim, dtype=int_dtype, name='dim')\n        num_results = tf.convert_to_tensor(num_results, dtype=int_dtype, name='num_results')\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_equal(tf.rank(generating_vectors), 1, message='generating_vectors must have rank 1'))\n            control_deps.append(tf.debugging.assert_less_equal(dim, tf.size(generating_vectors, out_type=int_dtype), message='dim must not exceed the size of generating_vectors'))\n            control_deps.append(tf.debugging.assert_positive(num_results, message='num_results must be positive'))\n        with tf.control_dependencies(control_deps):\n            if sequence_indices is None:\n                sequence_indices = tf.range(0, num_results)\n            sequence_indices = tf.cast(sequence_indices, int_dtype, name='sequence_indices')\n            unit = tf.ones(shape=(), dtype=real_dtype)\n            scaled_vector = tf.divide(tf.cast(generating_vectors[:dim], real_dtype), tf.cast(num_results, real_dtype))\n            points = tf.multiply(tf.expand_dims(tf.cast(sequence_indices, real_dtype), axis=1), tf.expand_dims(tf.math.floormod(scaled_vector, unit), axis=0))\n            if additive_shift is not None:\n                additive_shift = tf.cast(additive_shift, real_dtype, name='additive_shift')\n                points += additive_shift[:dim]\n            points = tf.math.floormod(points, unit)\n            return utils.tent_transform(points) if apply_tent_transform else points",
            "def lattice_rule_sample(generating_vectors: types.IntTensor, dim: types.IntTensor, num_results: types.IntTensor, sequence_indices: types.IntTensor=None, additive_shift: types.FloatTensor=None, apply_tent_transform: bool=False, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Constructs a lattice rule from a generating vector.\\n\\n  #### Examples\\n\\n  ```python\\n  import tensorflow as tf\\n  import tf_quant_finance as tff\\n\\n  # Example: Sampling 1,000 points from 2D generating vectors.\\n\\n  generating_vectors = tf.constant([1, 387275, 314993, 50301], dtype=tf.int32)\\n\\n  dim = 2\\n  num_results = 1000\\n\\n  tff.math.qmc.lattice_rule_sample(generating_vectors, dim, num_results)\\n  # ==> tf.Tensor([\\n  #             [0.,         0.        ],\\n  #             [0.001,      0.2749939 ],\\n  #             [0.002,      0.5499878 ],\\n  #             ...\\n  #             [0.99700004, 0.1689148 ],\\n  #             [0.998,      0.4439087 ],\\n  #             [0.9990001,  0.7189026 ],\\n  #         ], shape=(1000, 2), dtype=float32)\\n  ```\\n\\n  Args:\\n    generating_vectors: Positive scalar `Tensor` of integers with rank 1\\n      representing the vector from which to sample points.\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of the\\n      sampled points. Must not exceed the size of `generating_vectors`.\\n    num_results: Positive scalar `Tensor` of integers with rank 0. The maximum\\n      number of points to sample.\\n    sequence_indices: Optional positive scalar `Tensor` of integers with rank 1.\\n      The elements of the sequence to return specified by their position in the\\n      sequence.\\n      Default value: `None` which corresponds to the `[0, num_results)` range.\\n    additive_shift: Optional scalar `Tensor` of real values with the same\\n      `shape` as `generating_vectors`. The additive shift to add to all the\\n      points (modulo 1) before applying the tent transform.\\n      Default value: `None`.\\n    apply_tent_transform: Python `bool` indicating whether to apply a tent\\n      transform to the sampled points.\\n      Default value: `False`.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `sample_lattice_rule`.\\n\\n  Returns:\\n    A `Tensor` of samples from  the Sobol sequence with `shape`\\n    `(num_samples,)` where `num_samples = min(num_results,\\n    size(sequence_indices))`.\\n  '\n    with tf.name_scope(name or 'sample_lattice_rule'):\n        generating_vectors = tf.convert_to_tensor(generating_vectors, name='generating_vectors')\n        int_dtype = generating_vectors.dtype\n        real_dtype = dtype or tf.float32\n        dim = tf.convert_to_tensor(dim, dtype=int_dtype, name='dim')\n        num_results = tf.convert_to_tensor(num_results, dtype=int_dtype, name='num_results')\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_equal(tf.rank(generating_vectors), 1, message='generating_vectors must have rank 1'))\n            control_deps.append(tf.debugging.assert_less_equal(dim, tf.size(generating_vectors, out_type=int_dtype), message='dim must not exceed the size of generating_vectors'))\n            control_deps.append(tf.debugging.assert_positive(num_results, message='num_results must be positive'))\n        with tf.control_dependencies(control_deps):\n            if sequence_indices is None:\n                sequence_indices = tf.range(0, num_results)\n            sequence_indices = tf.cast(sequence_indices, int_dtype, name='sequence_indices')\n            unit = tf.ones(shape=(), dtype=real_dtype)\n            scaled_vector = tf.divide(tf.cast(generating_vectors[:dim], real_dtype), tf.cast(num_results, real_dtype))\n            points = tf.multiply(tf.expand_dims(tf.cast(sequence_indices, real_dtype), axis=1), tf.expand_dims(tf.math.floormod(scaled_vector, unit), axis=0))\n            if additive_shift is not None:\n                additive_shift = tf.cast(additive_shift, real_dtype, name='additive_shift')\n                points += additive_shift[:dim]\n            points = tf.math.floormod(points, unit)\n            return utils.tent_transform(points) if apply_tent_transform else points",
            "def lattice_rule_sample(generating_vectors: types.IntTensor, dim: types.IntTensor, num_results: types.IntTensor, sequence_indices: types.IntTensor=None, additive_shift: types.FloatTensor=None, apply_tent_transform: bool=False, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Constructs a lattice rule from a generating vector.\\n\\n  #### Examples\\n\\n  ```python\\n  import tensorflow as tf\\n  import tf_quant_finance as tff\\n\\n  # Example: Sampling 1,000 points from 2D generating vectors.\\n\\n  generating_vectors = tf.constant([1, 387275, 314993, 50301], dtype=tf.int32)\\n\\n  dim = 2\\n  num_results = 1000\\n\\n  tff.math.qmc.lattice_rule_sample(generating_vectors, dim, num_results)\\n  # ==> tf.Tensor([\\n  #             [0.,         0.        ],\\n  #             [0.001,      0.2749939 ],\\n  #             [0.002,      0.5499878 ],\\n  #             ...\\n  #             [0.99700004, 0.1689148 ],\\n  #             [0.998,      0.4439087 ],\\n  #             [0.9990001,  0.7189026 ],\\n  #         ], shape=(1000, 2), dtype=float32)\\n  ```\\n\\n  Args:\\n    generating_vectors: Positive scalar `Tensor` of integers with rank 1\\n      representing the vector from which to sample points.\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of the\\n      sampled points. Must not exceed the size of `generating_vectors`.\\n    num_results: Positive scalar `Tensor` of integers with rank 0. The maximum\\n      number of points to sample.\\n    sequence_indices: Optional positive scalar `Tensor` of integers with rank 1.\\n      The elements of the sequence to return specified by their position in the\\n      sequence.\\n      Default value: `None` which corresponds to the `[0, num_results)` range.\\n    additive_shift: Optional scalar `Tensor` of real values with the same\\n      `shape` as `generating_vectors`. The additive shift to add to all the\\n      points (modulo 1) before applying the tent transform.\\n      Default value: `None`.\\n    apply_tent_transform: Python `bool` indicating whether to apply a tent\\n      transform to the sampled points.\\n      Default value: `False`.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `sample_lattice_rule`.\\n\\n  Returns:\\n    A `Tensor` of samples from  the Sobol sequence with `shape`\\n    `(num_samples,)` where `num_samples = min(num_results,\\n    size(sequence_indices))`.\\n  '\n    with tf.name_scope(name or 'sample_lattice_rule'):\n        generating_vectors = tf.convert_to_tensor(generating_vectors, name='generating_vectors')\n        int_dtype = generating_vectors.dtype\n        real_dtype = dtype or tf.float32\n        dim = tf.convert_to_tensor(dim, dtype=int_dtype, name='dim')\n        num_results = tf.convert_to_tensor(num_results, dtype=int_dtype, name='num_results')\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_equal(tf.rank(generating_vectors), 1, message='generating_vectors must have rank 1'))\n            control_deps.append(tf.debugging.assert_less_equal(dim, tf.size(generating_vectors, out_type=int_dtype), message='dim must not exceed the size of generating_vectors'))\n            control_deps.append(tf.debugging.assert_positive(num_results, message='num_results must be positive'))\n        with tf.control_dependencies(control_deps):\n            if sequence_indices is None:\n                sequence_indices = tf.range(0, num_results)\n            sequence_indices = tf.cast(sequence_indices, int_dtype, name='sequence_indices')\n            unit = tf.ones(shape=(), dtype=real_dtype)\n            scaled_vector = tf.divide(tf.cast(generating_vectors[:dim], real_dtype), tf.cast(num_results, real_dtype))\n            points = tf.multiply(tf.expand_dims(tf.cast(sequence_indices, real_dtype), axis=1), tf.expand_dims(tf.math.floormod(scaled_vector, unit), axis=0))\n            if additive_shift is not None:\n                additive_shift = tf.cast(additive_shift, real_dtype, name='additive_shift')\n                points += additive_shift[:dim]\n            points = tf.math.floormod(points, unit)\n            return utils.tent_transform(points) if apply_tent_transform else points",
            "def lattice_rule_sample(generating_vectors: types.IntTensor, dim: types.IntTensor, num_results: types.IntTensor, sequence_indices: types.IntTensor=None, additive_shift: types.FloatTensor=None, apply_tent_transform: bool=False, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Constructs a lattice rule from a generating vector.\\n\\n  #### Examples\\n\\n  ```python\\n  import tensorflow as tf\\n  import tf_quant_finance as tff\\n\\n  # Example: Sampling 1,000 points from 2D generating vectors.\\n\\n  generating_vectors = tf.constant([1, 387275, 314993, 50301], dtype=tf.int32)\\n\\n  dim = 2\\n  num_results = 1000\\n\\n  tff.math.qmc.lattice_rule_sample(generating_vectors, dim, num_results)\\n  # ==> tf.Tensor([\\n  #             [0.,         0.        ],\\n  #             [0.001,      0.2749939 ],\\n  #             [0.002,      0.5499878 ],\\n  #             ...\\n  #             [0.99700004, 0.1689148 ],\\n  #             [0.998,      0.4439087 ],\\n  #             [0.9990001,  0.7189026 ],\\n  #         ], shape=(1000, 2), dtype=float32)\\n  ```\\n\\n  Args:\\n    generating_vectors: Positive scalar `Tensor` of integers with rank 1\\n      representing the vector from which to sample points.\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of the\\n      sampled points. Must not exceed the size of `generating_vectors`.\\n    num_results: Positive scalar `Tensor` of integers with rank 0. The maximum\\n      number of points to sample.\\n    sequence_indices: Optional positive scalar `Tensor` of integers with rank 1.\\n      The elements of the sequence to return specified by their position in the\\n      sequence.\\n      Default value: `None` which corresponds to the `[0, num_results)` range.\\n    additive_shift: Optional scalar `Tensor` of real values with the same\\n      `shape` as `generating_vectors`. The additive shift to add to all the\\n      points (modulo 1) before applying the tent transform.\\n      Default value: `None`.\\n    apply_tent_transform: Python `bool` indicating whether to apply a tent\\n      transform to the sampled points.\\n      Default value: `False`.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `sample_lattice_rule`.\\n\\n  Returns:\\n    A `Tensor` of samples from  the Sobol sequence with `shape`\\n    `(num_samples,)` where `num_samples = min(num_results,\\n    size(sequence_indices))`.\\n  '\n    with tf.name_scope(name or 'sample_lattice_rule'):\n        generating_vectors = tf.convert_to_tensor(generating_vectors, name='generating_vectors')\n        int_dtype = generating_vectors.dtype\n        real_dtype = dtype or tf.float32\n        dim = tf.convert_to_tensor(dim, dtype=int_dtype, name='dim')\n        num_results = tf.convert_to_tensor(num_results, dtype=int_dtype, name='num_results')\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_equal(tf.rank(generating_vectors), 1, message='generating_vectors must have rank 1'))\n            control_deps.append(tf.debugging.assert_less_equal(dim, tf.size(generating_vectors, out_type=int_dtype), message='dim must not exceed the size of generating_vectors'))\n            control_deps.append(tf.debugging.assert_positive(num_results, message='num_results must be positive'))\n        with tf.control_dependencies(control_deps):\n            if sequence_indices is None:\n                sequence_indices = tf.range(0, num_results)\n            sequence_indices = tf.cast(sequence_indices, int_dtype, name='sequence_indices')\n            unit = tf.ones(shape=(), dtype=real_dtype)\n            scaled_vector = tf.divide(tf.cast(generating_vectors[:dim], real_dtype), tf.cast(num_results, real_dtype))\n            points = tf.multiply(tf.expand_dims(tf.cast(sequence_indices, real_dtype), axis=1), tf.expand_dims(tf.math.floormod(scaled_vector, unit), axis=0))\n            if additive_shift is not None:\n                additive_shift = tf.cast(additive_shift, real_dtype, name='additive_shift')\n                points += additive_shift[:dim]\n            points = tf.math.floormod(points, unit)\n            return utils.tent_transform(points) if apply_tent_transform else points",
            "def lattice_rule_sample(generating_vectors: types.IntTensor, dim: types.IntTensor, num_results: types.IntTensor, sequence_indices: types.IntTensor=None, additive_shift: types.FloatTensor=None, apply_tent_transform: bool=False, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Constructs a lattice rule from a generating vector.\\n\\n  #### Examples\\n\\n  ```python\\n  import tensorflow as tf\\n  import tf_quant_finance as tff\\n\\n  # Example: Sampling 1,000 points from 2D generating vectors.\\n\\n  generating_vectors = tf.constant([1, 387275, 314993, 50301], dtype=tf.int32)\\n\\n  dim = 2\\n  num_results = 1000\\n\\n  tff.math.qmc.lattice_rule_sample(generating_vectors, dim, num_results)\\n  # ==> tf.Tensor([\\n  #             [0.,         0.        ],\\n  #             [0.001,      0.2749939 ],\\n  #             [0.002,      0.5499878 ],\\n  #             ...\\n  #             [0.99700004, 0.1689148 ],\\n  #             [0.998,      0.4439087 ],\\n  #             [0.9990001,  0.7189026 ],\\n  #         ], shape=(1000, 2), dtype=float32)\\n  ```\\n\\n  Args:\\n    generating_vectors: Positive scalar `Tensor` of integers with rank 1\\n      representing the vector from which to sample points.\\n    dim: Positive scalar `Tensor` of integers with rank 0. The event size of the\\n      sampled points. Must not exceed the size of `generating_vectors`.\\n    num_results: Positive scalar `Tensor` of integers with rank 0. The maximum\\n      number of points to sample.\\n    sequence_indices: Optional positive scalar `Tensor` of integers with rank 1.\\n      The elements of the sequence to return specified by their position in the\\n      sequence.\\n      Default value: `None` which corresponds to the `[0, num_results)` range.\\n    additive_shift: Optional scalar `Tensor` of real values with the same\\n      `shape` as `generating_vectors`. The additive shift to add to all the\\n      points (modulo 1) before applying the tent transform.\\n      Default value: `None`.\\n    apply_tent_transform: Python `bool` indicating whether to apply a tent\\n      transform to the sampled points.\\n      Default value: `False`.\\n    validate_args: Python `bool` indicating whether to validate arguments.\\n      Default value: `False`.\\n    dtype: Optional `dtype`. The `dtype` of the output `Tensor` (either\\n      `float32` or `float64`).\\n      Default value: `None` which maps to `float32`.\\n    name: Python `str` name prefixed to ops created by this function.\\n      Default value: `None` which maps to `sample_lattice_rule`.\\n\\n  Returns:\\n    A `Tensor` of samples from  the Sobol sequence with `shape`\\n    `(num_samples,)` where `num_samples = min(num_results,\\n    size(sequence_indices))`.\\n  '\n    with tf.name_scope(name or 'sample_lattice_rule'):\n        generating_vectors = tf.convert_to_tensor(generating_vectors, name='generating_vectors')\n        int_dtype = generating_vectors.dtype\n        real_dtype = dtype or tf.float32\n        dim = tf.convert_to_tensor(dim, dtype=int_dtype, name='dim')\n        num_results = tf.convert_to_tensor(num_results, dtype=int_dtype, name='num_results')\n        control_deps = []\n        if validate_args:\n            control_deps.append(tf.debugging.assert_equal(tf.rank(generating_vectors), 1, message='generating_vectors must have rank 1'))\n            control_deps.append(tf.debugging.assert_less_equal(dim, tf.size(generating_vectors, out_type=int_dtype), message='dim must not exceed the size of generating_vectors'))\n            control_deps.append(tf.debugging.assert_positive(num_results, message='num_results must be positive'))\n        with tf.control_dependencies(control_deps):\n            if sequence_indices is None:\n                sequence_indices = tf.range(0, num_results)\n            sequence_indices = tf.cast(sequence_indices, int_dtype, name='sequence_indices')\n            unit = tf.ones(shape=(), dtype=real_dtype)\n            scaled_vector = tf.divide(tf.cast(generating_vectors[:dim], real_dtype), tf.cast(num_results, real_dtype))\n            points = tf.multiply(tf.expand_dims(tf.cast(sequence_indices, real_dtype), axis=1), tf.expand_dims(tf.math.floormod(scaled_vector, unit), axis=0))\n            if additive_shift is not None:\n                additive_shift = tf.cast(additive_shift, real_dtype, name='additive_shift')\n                points += additive_shift[:dim]\n            points = tf.math.floormod(points, unit)\n            return utils.tent_transform(points) if apply_tent_transform else points"
        ]
    }
]