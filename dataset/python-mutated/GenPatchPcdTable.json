[
    {
        "func_name": "parsePcdInfoFromMapFile",
        "original": "def parsePcdInfoFromMapFile(mapfilepath, efifilepath):\n    \"\"\" Parse map file to get binary patch pcd information\n    @param path    Map file absolution path\n\n    @return a list which element hold (PcdName, Offset, SectionName)\n    \"\"\"\n    lines = []\n    try:\n        f = open(mapfilepath, 'r')\n        lines = f.readlines()\n        f.close()\n    except:\n        return None\n    if len(lines) == 0:\n        return None\n    firstline = lines[0].strip()\n    if re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', firstline):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    if firstline.startswith('Archive member included ') and firstline.endswith(' file (symbol)'):\n        return _parseForGCC(lines, efifilepath)\n    if firstline.startswith('# Path:'):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    return _parseGeneral(lines, efifilepath)",
        "mutated": [
            "def parsePcdInfoFromMapFile(mapfilepath, efifilepath):\n    if False:\n        i = 10\n    ' Parse map file to get binary patch pcd information\\n    @param path    Map file absolution path\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    lines = []\n    try:\n        f = open(mapfilepath, 'r')\n        lines = f.readlines()\n        f.close()\n    except:\n        return None\n    if len(lines) == 0:\n        return None\n    firstline = lines[0].strip()\n    if re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', firstline):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    if firstline.startswith('Archive member included ') and firstline.endswith(' file (symbol)'):\n        return _parseForGCC(lines, efifilepath)\n    if firstline.startswith('# Path:'):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    return _parseGeneral(lines, efifilepath)",
            "def parsePcdInfoFromMapFile(mapfilepath, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Parse map file to get binary patch pcd information\\n    @param path    Map file absolution path\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    lines = []\n    try:\n        f = open(mapfilepath, 'r')\n        lines = f.readlines()\n        f.close()\n    except:\n        return None\n    if len(lines) == 0:\n        return None\n    firstline = lines[0].strip()\n    if re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', firstline):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    if firstline.startswith('Archive member included ') and firstline.endswith(' file (symbol)'):\n        return _parseForGCC(lines, efifilepath)\n    if firstline.startswith('# Path:'):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    return _parseGeneral(lines, efifilepath)",
            "def parsePcdInfoFromMapFile(mapfilepath, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Parse map file to get binary patch pcd information\\n    @param path    Map file absolution path\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    lines = []\n    try:\n        f = open(mapfilepath, 'r')\n        lines = f.readlines()\n        f.close()\n    except:\n        return None\n    if len(lines) == 0:\n        return None\n    firstline = lines[0].strip()\n    if re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', firstline):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    if firstline.startswith('Archive member included ') and firstline.endswith(' file (symbol)'):\n        return _parseForGCC(lines, efifilepath)\n    if firstline.startswith('# Path:'):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    return _parseGeneral(lines, efifilepath)",
            "def parsePcdInfoFromMapFile(mapfilepath, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Parse map file to get binary patch pcd information\\n    @param path    Map file absolution path\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    lines = []\n    try:\n        f = open(mapfilepath, 'r')\n        lines = f.readlines()\n        f.close()\n    except:\n        return None\n    if len(lines) == 0:\n        return None\n    firstline = lines[0].strip()\n    if re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', firstline):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    if firstline.startswith('Archive member included ') and firstline.endswith(' file (symbol)'):\n        return _parseForGCC(lines, efifilepath)\n    if firstline.startswith('# Path:'):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    return _parseGeneral(lines, efifilepath)",
            "def parsePcdInfoFromMapFile(mapfilepath, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Parse map file to get binary patch pcd information\\n    @param path    Map file absolution path\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    lines = []\n    try:\n        f = open(mapfilepath, 'r')\n        lines = f.readlines()\n        f.close()\n    except:\n        return None\n    if len(lines) == 0:\n        return None\n    firstline = lines[0].strip()\n    if re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', firstline):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    if firstline.startswith('Archive member included ') and firstline.endswith(' file (symbol)'):\n        return _parseForGCC(lines, efifilepath)\n    if firstline.startswith('# Path:'):\n        return _parseForXcodeAndClang9(lines, efifilepath)\n    return _parseGeneral(lines, efifilepath)"
        ]
    },
    {
        "func_name": "_parseForXcodeAndClang9",
        "original": "def _parseForXcodeAndClang9(lines, efifilepath):\n    valuePattern = re.compile('^([\\\\da-fA-FxX]+)([\\\\s\\\\S]*)([_]*_gPcd_BinaryPatch_([\\\\w]+))')\n    status = 0\n    pcds = []\n    for line in lines:\n        line = line.strip()\n        if status == 0 and (re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', line) or line == '# Symbols:'):\n            status = 1\n            continue\n        if status == 1 and len(line) != 0:\n            if '_gPcd_BinaryPatch_' in line:\n                m = valuePattern.match(line)\n                if m is not None:\n                    pcds.append((m.groups(0)[3], int(m.groups(0)[0], 16)))\n    return pcds",
        "mutated": [
            "def _parseForXcodeAndClang9(lines, efifilepath):\n    if False:\n        i = 10\n    valuePattern = re.compile('^([\\\\da-fA-FxX]+)([\\\\s\\\\S]*)([_]*_gPcd_BinaryPatch_([\\\\w]+))')\n    status = 0\n    pcds = []\n    for line in lines:\n        line = line.strip()\n        if status == 0 and (re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', line) or line == '# Symbols:'):\n            status = 1\n            continue\n        if status == 1 and len(line) != 0:\n            if '_gPcd_BinaryPatch_' in line:\n                m = valuePattern.match(line)\n                if m is not None:\n                    pcds.append((m.groups(0)[3], int(m.groups(0)[0], 16)))\n    return pcds",
            "def _parseForXcodeAndClang9(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    valuePattern = re.compile('^([\\\\da-fA-FxX]+)([\\\\s\\\\S]*)([_]*_gPcd_BinaryPatch_([\\\\w]+))')\n    status = 0\n    pcds = []\n    for line in lines:\n        line = line.strip()\n        if status == 0 and (re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', line) or line == '# Symbols:'):\n            status = 1\n            continue\n        if status == 1 and len(line) != 0:\n            if '_gPcd_BinaryPatch_' in line:\n                m = valuePattern.match(line)\n                if m is not None:\n                    pcds.append((m.groups(0)[3], int(m.groups(0)[0], 16)))\n    return pcds",
            "def _parseForXcodeAndClang9(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    valuePattern = re.compile('^([\\\\da-fA-FxX]+)([\\\\s\\\\S]*)([_]*_gPcd_BinaryPatch_([\\\\w]+))')\n    status = 0\n    pcds = []\n    for line in lines:\n        line = line.strip()\n        if status == 0 and (re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', line) or line == '# Symbols:'):\n            status = 1\n            continue\n        if status == 1 and len(line) != 0:\n            if '_gPcd_BinaryPatch_' in line:\n                m = valuePattern.match(line)\n                if m is not None:\n                    pcds.append((m.groups(0)[3], int(m.groups(0)[0], 16)))\n    return pcds",
            "def _parseForXcodeAndClang9(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    valuePattern = re.compile('^([\\\\da-fA-FxX]+)([\\\\s\\\\S]*)([_]*_gPcd_BinaryPatch_([\\\\w]+))')\n    status = 0\n    pcds = []\n    for line in lines:\n        line = line.strip()\n        if status == 0 and (re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', line) or line == '# Symbols:'):\n            status = 1\n            continue\n        if status == 1 and len(line) != 0:\n            if '_gPcd_BinaryPatch_' in line:\n                m = valuePattern.match(line)\n                if m is not None:\n                    pcds.append((m.groups(0)[3], int(m.groups(0)[0], 16)))\n    return pcds",
            "def _parseForXcodeAndClang9(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    valuePattern = re.compile('^([\\\\da-fA-FxX]+)([\\\\s\\\\S]*)([_]*_gPcd_BinaryPatch_([\\\\w]+))')\n    status = 0\n    pcds = []\n    for line in lines:\n        line = line.strip()\n        if status == 0 and (re.match('^\\\\s*Address\\\\s*Size\\\\s*Align\\\\s*Out\\\\s*In\\\\s*Symbol\\\\s*$', line) or line == '# Symbols:'):\n            status = 1\n            continue\n        if status == 1 and len(line) != 0:\n            if '_gPcd_BinaryPatch_' in line:\n                m = valuePattern.match(line)\n                if m is not None:\n                    pcds.append((m.groups(0)[3], int(m.groups(0)[0], 16)))\n    return pcds"
        ]
    },
    {
        "func_name": "_parseForGCC",
        "original": "def _parseForGCC(lines, efifilepath):\n    \"\"\" Parse map file generated by GCC linker \"\"\"\n    dataPattern = re.compile('^.data._gPcd_BinaryPatch_([\\\\w_\\\\d]+)$')\n    status = 0\n    imageBase = -1\n    sections = []\n    bpcds = []\n    for (index, line) in enumerate(lines):\n        line = line.strip()\n        if status == 0 and line == 'Memory Configuration':\n            status = 1\n            continue\n        elif status == 1 and line == 'Linker script and memory map':\n            status = 2\n            continue\n        elif status == 2 and line == 'START GROUP':\n            status = 3\n            continue\n        if status == 3:\n            m = valuePatternGcc.match(line)\n            if m is not None:\n                sections.append(m.groups(0))\n        if status == 3:\n            m = dataPattern.match(line)\n            if m is not None:\n                if lines[index + 1]:\n                    PcdName = m.groups(0)[0]\n                    m = pcdPatternGcc.match(lines[index + 1].strip())\n                    if m is not None:\n                        bpcds.append((PcdName, int(m.groups(0)[0], 16), int(sections[-1][1], 16), sections[-1][0]))\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    redirection = 0\n    for efisec in efisecs:\n        for section in sections:\n            if section[0].strip() == efisec[0].strip() and section[0].strip() == '.text':\n                redirection = int(section[1], 16) - efisec[1]\n    pcds = []\n    for pcd in bpcds:\n        for efisec in efisecs:\n            if pcd[1] >= efisec[1] and pcd[1] < efisec[1] + efisec[3]:\n                pcds.append([pcd[0], efisec[2] + pcd[1] - efisec[1] - redirection, efisec[0]])\n    return pcds",
        "mutated": [
            "def _parseForGCC(lines, efifilepath):\n    if False:\n        i = 10\n    ' Parse map file generated by GCC linker '\n    dataPattern = re.compile('^.data._gPcd_BinaryPatch_([\\\\w_\\\\d]+)$')\n    status = 0\n    imageBase = -1\n    sections = []\n    bpcds = []\n    for (index, line) in enumerate(lines):\n        line = line.strip()\n        if status == 0 and line == 'Memory Configuration':\n            status = 1\n            continue\n        elif status == 1 and line == 'Linker script and memory map':\n            status = 2\n            continue\n        elif status == 2 and line == 'START GROUP':\n            status = 3\n            continue\n        if status == 3:\n            m = valuePatternGcc.match(line)\n            if m is not None:\n                sections.append(m.groups(0))\n        if status == 3:\n            m = dataPattern.match(line)\n            if m is not None:\n                if lines[index + 1]:\n                    PcdName = m.groups(0)[0]\n                    m = pcdPatternGcc.match(lines[index + 1].strip())\n                    if m is not None:\n                        bpcds.append((PcdName, int(m.groups(0)[0], 16), int(sections[-1][1], 16), sections[-1][0]))\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    redirection = 0\n    for efisec in efisecs:\n        for section in sections:\n            if section[0].strip() == efisec[0].strip() and section[0].strip() == '.text':\n                redirection = int(section[1], 16) - efisec[1]\n    pcds = []\n    for pcd in bpcds:\n        for efisec in efisecs:\n            if pcd[1] >= efisec[1] and pcd[1] < efisec[1] + efisec[3]:\n                pcds.append([pcd[0], efisec[2] + pcd[1] - efisec[1] - redirection, efisec[0]])\n    return pcds",
            "def _parseForGCC(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Parse map file generated by GCC linker '\n    dataPattern = re.compile('^.data._gPcd_BinaryPatch_([\\\\w_\\\\d]+)$')\n    status = 0\n    imageBase = -1\n    sections = []\n    bpcds = []\n    for (index, line) in enumerate(lines):\n        line = line.strip()\n        if status == 0 and line == 'Memory Configuration':\n            status = 1\n            continue\n        elif status == 1 and line == 'Linker script and memory map':\n            status = 2\n            continue\n        elif status == 2 and line == 'START GROUP':\n            status = 3\n            continue\n        if status == 3:\n            m = valuePatternGcc.match(line)\n            if m is not None:\n                sections.append(m.groups(0))\n        if status == 3:\n            m = dataPattern.match(line)\n            if m is not None:\n                if lines[index + 1]:\n                    PcdName = m.groups(0)[0]\n                    m = pcdPatternGcc.match(lines[index + 1].strip())\n                    if m is not None:\n                        bpcds.append((PcdName, int(m.groups(0)[0], 16), int(sections[-1][1], 16), sections[-1][0]))\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    redirection = 0\n    for efisec in efisecs:\n        for section in sections:\n            if section[0].strip() == efisec[0].strip() and section[0].strip() == '.text':\n                redirection = int(section[1], 16) - efisec[1]\n    pcds = []\n    for pcd in bpcds:\n        for efisec in efisecs:\n            if pcd[1] >= efisec[1] and pcd[1] < efisec[1] + efisec[3]:\n                pcds.append([pcd[0], efisec[2] + pcd[1] - efisec[1] - redirection, efisec[0]])\n    return pcds",
            "def _parseForGCC(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Parse map file generated by GCC linker '\n    dataPattern = re.compile('^.data._gPcd_BinaryPatch_([\\\\w_\\\\d]+)$')\n    status = 0\n    imageBase = -1\n    sections = []\n    bpcds = []\n    for (index, line) in enumerate(lines):\n        line = line.strip()\n        if status == 0 and line == 'Memory Configuration':\n            status = 1\n            continue\n        elif status == 1 and line == 'Linker script and memory map':\n            status = 2\n            continue\n        elif status == 2 and line == 'START GROUP':\n            status = 3\n            continue\n        if status == 3:\n            m = valuePatternGcc.match(line)\n            if m is not None:\n                sections.append(m.groups(0))\n        if status == 3:\n            m = dataPattern.match(line)\n            if m is not None:\n                if lines[index + 1]:\n                    PcdName = m.groups(0)[0]\n                    m = pcdPatternGcc.match(lines[index + 1].strip())\n                    if m is not None:\n                        bpcds.append((PcdName, int(m.groups(0)[0], 16), int(sections[-1][1], 16), sections[-1][0]))\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    redirection = 0\n    for efisec in efisecs:\n        for section in sections:\n            if section[0].strip() == efisec[0].strip() and section[0].strip() == '.text':\n                redirection = int(section[1], 16) - efisec[1]\n    pcds = []\n    for pcd in bpcds:\n        for efisec in efisecs:\n            if pcd[1] >= efisec[1] and pcd[1] < efisec[1] + efisec[3]:\n                pcds.append([pcd[0], efisec[2] + pcd[1] - efisec[1] - redirection, efisec[0]])\n    return pcds",
            "def _parseForGCC(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Parse map file generated by GCC linker '\n    dataPattern = re.compile('^.data._gPcd_BinaryPatch_([\\\\w_\\\\d]+)$')\n    status = 0\n    imageBase = -1\n    sections = []\n    bpcds = []\n    for (index, line) in enumerate(lines):\n        line = line.strip()\n        if status == 0 and line == 'Memory Configuration':\n            status = 1\n            continue\n        elif status == 1 and line == 'Linker script and memory map':\n            status = 2\n            continue\n        elif status == 2 and line == 'START GROUP':\n            status = 3\n            continue\n        if status == 3:\n            m = valuePatternGcc.match(line)\n            if m is not None:\n                sections.append(m.groups(0))\n        if status == 3:\n            m = dataPattern.match(line)\n            if m is not None:\n                if lines[index + 1]:\n                    PcdName = m.groups(0)[0]\n                    m = pcdPatternGcc.match(lines[index + 1].strip())\n                    if m is not None:\n                        bpcds.append((PcdName, int(m.groups(0)[0], 16), int(sections[-1][1], 16), sections[-1][0]))\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    redirection = 0\n    for efisec in efisecs:\n        for section in sections:\n            if section[0].strip() == efisec[0].strip() and section[0].strip() == '.text':\n                redirection = int(section[1], 16) - efisec[1]\n    pcds = []\n    for pcd in bpcds:\n        for efisec in efisecs:\n            if pcd[1] >= efisec[1] and pcd[1] < efisec[1] + efisec[3]:\n                pcds.append([pcd[0], efisec[2] + pcd[1] - efisec[1] - redirection, efisec[0]])\n    return pcds",
            "def _parseForGCC(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Parse map file generated by GCC linker '\n    dataPattern = re.compile('^.data._gPcd_BinaryPatch_([\\\\w_\\\\d]+)$')\n    status = 0\n    imageBase = -1\n    sections = []\n    bpcds = []\n    for (index, line) in enumerate(lines):\n        line = line.strip()\n        if status == 0 and line == 'Memory Configuration':\n            status = 1\n            continue\n        elif status == 1 and line == 'Linker script and memory map':\n            status = 2\n            continue\n        elif status == 2 and line == 'START GROUP':\n            status = 3\n            continue\n        if status == 3:\n            m = valuePatternGcc.match(line)\n            if m is not None:\n                sections.append(m.groups(0))\n        if status == 3:\n            m = dataPattern.match(line)\n            if m is not None:\n                if lines[index + 1]:\n                    PcdName = m.groups(0)[0]\n                    m = pcdPatternGcc.match(lines[index + 1].strip())\n                    if m is not None:\n                        bpcds.append((PcdName, int(m.groups(0)[0], 16), int(sections[-1][1], 16), sections[-1][0]))\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    redirection = 0\n    for efisec in efisecs:\n        for section in sections:\n            if section[0].strip() == efisec[0].strip() and section[0].strip() == '.text':\n                redirection = int(section[1], 16) - efisec[1]\n    pcds = []\n    for pcd in bpcds:\n        for efisec in efisecs:\n            if pcd[1] >= efisec[1] and pcd[1] < efisec[1] + efisec[3]:\n                pcds.append([pcd[0], efisec[2] + pcd[1] - efisec[1] - redirection, efisec[0]])\n    return pcds"
        ]
    },
    {
        "func_name": "_parseGeneral",
        "original": "def _parseGeneral(lines, efifilepath):\n    \"\"\" For MSFT, ICC, EBC\n    @param lines    line array for map file\n\n    @return a list which element hold (PcdName, Offset, SectionName)\n    \"\"\"\n    status = 0\n    secs = []\n    bPcds = []\n    symPattern = re.compile('^[_]+gPcd_BinaryPatch_([\\\\w]+)')\n    for line in lines:\n        line = line.strip()\n        if startPatternGeneral.match(line):\n            status = 1\n            continue\n        if addressPatternGeneral.match(line):\n            status = 2\n            continue\n        if line.startswith('entry point at'):\n            status = 3\n            continue\n        if status == 1 and len(line) != 0:\n            m = secReGeneral.match(line)\n            assert m is not None, 'Fail to parse the section in map file , line is %s' % line\n            (sec_no, sec_start, sec_length, sec_name, sec_class) = m.groups(0)\n            secs.append([int(sec_no, 16), int(sec_start, 16), int(sec_length, 16), sec_name, sec_class])\n        if status == 2 and len(line) != 0:\n            m = symRe.match(line)\n            assert m is not None, 'Fail to parse the symbol in map file, line is %s' % line\n            (sec_no, sym_offset, sym_name, vir_addr) = m.groups(0)\n            sec_no = int(sec_no, 16)\n            sym_offset = int(sym_offset, 16)\n            vir_addr = int(vir_addr, 16)\n            m2 = symPattern.match(sym_name)\n            if m2 is not None:\n                for sec in secs:\n                    if sec[0] == sec_no and (sym_offset >= sec[1] and sym_offset < sec[1] + sec[2]):\n                        bPcds.append([m2.groups(0)[0], sec[3], sym_offset, vir_addr, sec_no])\n    if len(bPcds) == 0:\n        return None\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    pcds = []\n    for pcd in bPcds:\n        index = 0\n        for efisec in efisecs:\n            index = index + 1\n            if pcd[1].strip() == efisec[0].strip():\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n            elif pcd[4] == index:\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n    return pcds",
        "mutated": [
            "def _parseGeneral(lines, efifilepath):\n    if False:\n        i = 10\n    ' For MSFT, ICC, EBC\\n    @param lines    line array for map file\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    status = 0\n    secs = []\n    bPcds = []\n    symPattern = re.compile('^[_]+gPcd_BinaryPatch_([\\\\w]+)')\n    for line in lines:\n        line = line.strip()\n        if startPatternGeneral.match(line):\n            status = 1\n            continue\n        if addressPatternGeneral.match(line):\n            status = 2\n            continue\n        if line.startswith('entry point at'):\n            status = 3\n            continue\n        if status == 1 and len(line) != 0:\n            m = secReGeneral.match(line)\n            assert m is not None, 'Fail to parse the section in map file , line is %s' % line\n            (sec_no, sec_start, sec_length, sec_name, sec_class) = m.groups(0)\n            secs.append([int(sec_no, 16), int(sec_start, 16), int(sec_length, 16), sec_name, sec_class])\n        if status == 2 and len(line) != 0:\n            m = symRe.match(line)\n            assert m is not None, 'Fail to parse the symbol in map file, line is %s' % line\n            (sec_no, sym_offset, sym_name, vir_addr) = m.groups(0)\n            sec_no = int(sec_no, 16)\n            sym_offset = int(sym_offset, 16)\n            vir_addr = int(vir_addr, 16)\n            m2 = symPattern.match(sym_name)\n            if m2 is not None:\n                for sec in secs:\n                    if sec[0] == sec_no and (sym_offset >= sec[1] and sym_offset < sec[1] + sec[2]):\n                        bPcds.append([m2.groups(0)[0], sec[3], sym_offset, vir_addr, sec_no])\n    if len(bPcds) == 0:\n        return None\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    pcds = []\n    for pcd in bPcds:\n        index = 0\n        for efisec in efisecs:\n            index = index + 1\n            if pcd[1].strip() == efisec[0].strip():\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n            elif pcd[4] == index:\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n    return pcds",
            "def _parseGeneral(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' For MSFT, ICC, EBC\\n    @param lines    line array for map file\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    status = 0\n    secs = []\n    bPcds = []\n    symPattern = re.compile('^[_]+gPcd_BinaryPatch_([\\\\w]+)')\n    for line in lines:\n        line = line.strip()\n        if startPatternGeneral.match(line):\n            status = 1\n            continue\n        if addressPatternGeneral.match(line):\n            status = 2\n            continue\n        if line.startswith('entry point at'):\n            status = 3\n            continue\n        if status == 1 and len(line) != 0:\n            m = secReGeneral.match(line)\n            assert m is not None, 'Fail to parse the section in map file , line is %s' % line\n            (sec_no, sec_start, sec_length, sec_name, sec_class) = m.groups(0)\n            secs.append([int(sec_no, 16), int(sec_start, 16), int(sec_length, 16), sec_name, sec_class])\n        if status == 2 and len(line) != 0:\n            m = symRe.match(line)\n            assert m is not None, 'Fail to parse the symbol in map file, line is %s' % line\n            (sec_no, sym_offset, sym_name, vir_addr) = m.groups(0)\n            sec_no = int(sec_no, 16)\n            sym_offset = int(sym_offset, 16)\n            vir_addr = int(vir_addr, 16)\n            m2 = symPattern.match(sym_name)\n            if m2 is not None:\n                for sec in secs:\n                    if sec[0] == sec_no and (sym_offset >= sec[1] and sym_offset < sec[1] + sec[2]):\n                        bPcds.append([m2.groups(0)[0], sec[3], sym_offset, vir_addr, sec_no])\n    if len(bPcds) == 0:\n        return None\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    pcds = []\n    for pcd in bPcds:\n        index = 0\n        for efisec in efisecs:\n            index = index + 1\n            if pcd[1].strip() == efisec[0].strip():\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n            elif pcd[4] == index:\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n    return pcds",
            "def _parseGeneral(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' For MSFT, ICC, EBC\\n    @param lines    line array for map file\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    status = 0\n    secs = []\n    bPcds = []\n    symPattern = re.compile('^[_]+gPcd_BinaryPatch_([\\\\w]+)')\n    for line in lines:\n        line = line.strip()\n        if startPatternGeneral.match(line):\n            status = 1\n            continue\n        if addressPatternGeneral.match(line):\n            status = 2\n            continue\n        if line.startswith('entry point at'):\n            status = 3\n            continue\n        if status == 1 and len(line) != 0:\n            m = secReGeneral.match(line)\n            assert m is not None, 'Fail to parse the section in map file , line is %s' % line\n            (sec_no, sec_start, sec_length, sec_name, sec_class) = m.groups(0)\n            secs.append([int(sec_no, 16), int(sec_start, 16), int(sec_length, 16), sec_name, sec_class])\n        if status == 2 and len(line) != 0:\n            m = symRe.match(line)\n            assert m is not None, 'Fail to parse the symbol in map file, line is %s' % line\n            (sec_no, sym_offset, sym_name, vir_addr) = m.groups(0)\n            sec_no = int(sec_no, 16)\n            sym_offset = int(sym_offset, 16)\n            vir_addr = int(vir_addr, 16)\n            m2 = symPattern.match(sym_name)\n            if m2 is not None:\n                for sec in secs:\n                    if sec[0] == sec_no and (sym_offset >= sec[1] and sym_offset < sec[1] + sec[2]):\n                        bPcds.append([m2.groups(0)[0], sec[3], sym_offset, vir_addr, sec_no])\n    if len(bPcds) == 0:\n        return None\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    pcds = []\n    for pcd in bPcds:\n        index = 0\n        for efisec in efisecs:\n            index = index + 1\n            if pcd[1].strip() == efisec[0].strip():\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n            elif pcd[4] == index:\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n    return pcds",
            "def _parseGeneral(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' For MSFT, ICC, EBC\\n    @param lines    line array for map file\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    status = 0\n    secs = []\n    bPcds = []\n    symPattern = re.compile('^[_]+gPcd_BinaryPatch_([\\\\w]+)')\n    for line in lines:\n        line = line.strip()\n        if startPatternGeneral.match(line):\n            status = 1\n            continue\n        if addressPatternGeneral.match(line):\n            status = 2\n            continue\n        if line.startswith('entry point at'):\n            status = 3\n            continue\n        if status == 1 and len(line) != 0:\n            m = secReGeneral.match(line)\n            assert m is not None, 'Fail to parse the section in map file , line is %s' % line\n            (sec_no, sec_start, sec_length, sec_name, sec_class) = m.groups(0)\n            secs.append([int(sec_no, 16), int(sec_start, 16), int(sec_length, 16), sec_name, sec_class])\n        if status == 2 and len(line) != 0:\n            m = symRe.match(line)\n            assert m is not None, 'Fail to parse the symbol in map file, line is %s' % line\n            (sec_no, sym_offset, sym_name, vir_addr) = m.groups(0)\n            sec_no = int(sec_no, 16)\n            sym_offset = int(sym_offset, 16)\n            vir_addr = int(vir_addr, 16)\n            m2 = symPattern.match(sym_name)\n            if m2 is not None:\n                for sec in secs:\n                    if sec[0] == sec_no and (sym_offset >= sec[1] and sym_offset < sec[1] + sec[2]):\n                        bPcds.append([m2.groups(0)[0], sec[3], sym_offset, vir_addr, sec_no])\n    if len(bPcds) == 0:\n        return None\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    pcds = []\n    for pcd in bPcds:\n        index = 0\n        for efisec in efisecs:\n            index = index + 1\n            if pcd[1].strip() == efisec[0].strip():\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n            elif pcd[4] == index:\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n    return pcds",
            "def _parseGeneral(lines, efifilepath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' For MSFT, ICC, EBC\\n    @param lines    line array for map file\\n\\n    @return a list which element hold (PcdName, Offset, SectionName)\\n    '\n    status = 0\n    secs = []\n    bPcds = []\n    symPattern = re.compile('^[_]+gPcd_BinaryPatch_([\\\\w]+)')\n    for line in lines:\n        line = line.strip()\n        if startPatternGeneral.match(line):\n            status = 1\n            continue\n        if addressPatternGeneral.match(line):\n            status = 2\n            continue\n        if line.startswith('entry point at'):\n            status = 3\n            continue\n        if status == 1 and len(line) != 0:\n            m = secReGeneral.match(line)\n            assert m is not None, 'Fail to parse the section in map file , line is %s' % line\n            (sec_no, sec_start, sec_length, sec_name, sec_class) = m.groups(0)\n            secs.append([int(sec_no, 16), int(sec_start, 16), int(sec_length, 16), sec_name, sec_class])\n        if status == 2 and len(line) != 0:\n            m = symRe.match(line)\n            assert m is not None, 'Fail to parse the symbol in map file, line is %s' % line\n            (sec_no, sym_offset, sym_name, vir_addr) = m.groups(0)\n            sec_no = int(sec_no, 16)\n            sym_offset = int(sym_offset, 16)\n            vir_addr = int(vir_addr, 16)\n            m2 = symPattern.match(sym_name)\n            if m2 is not None:\n                for sec in secs:\n                    if sec[0] == sec_no and (sym_offset >= sec[1] and sym_offset < sec[1] + sec[2]):\n                        bPcds.append([m2.groups(0)[0], sec[3], sym_offset, vir_addr, sec_no])\n    if len(bPcds) == 0:\n        return None\n    efisecs = PeImageClass(efifilepath).SectionHeaderList\n    if efisecs is None or len(efisecs) == 0:\n        return None\n    pcds = []\n    for pcd in bPcds:\n        index = 0\n        for efisec in efisecs:\n            index = index + 1\n            if pcd[1].strip() == efisec[0].strip():\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n            elif pcd[4] == index:\n                pcds.append([pcd[0], efisec[2] + pcd[2], efisec[0]])\n    return pcds"
        ]
    },
    {
        "func_name": "generatePcdTable",
        "original": "def generatePcdTable(list, pcdpath):\n    try:\n        f = open(pcdpath, 'w')\n    except:\n        pass\n    f.write('PCD Name                       Offset    Section Name\\r\\n')\n    for pcditem in list:\n        f.write('%-30s 0x%-08X %-6s\\r\\n' % (pcditem[0], pcditem[1], pcditem[2]))\n    f.close()",
        "mutated": [
            "def generatePcdTable(list, pcdpath):\n    if False:\n        i = 10\n    try:\n        f = open(pcdpath, 'w')\n    except:\n        pass\n    f.write('PCD Name                       Offset    Section Name\\r\\n')\n    for pcditem in list:\n        f.write('%-30s 0x%-08X %-6s\\r\\n' % (pcditem[0], pcditem[1], pcditem[2]))\n    f.close()",
            "def generatePcdTable(list, pcdpath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        f = open(pcdpath, 'w')\n    except:\n        pass\n    f.write('PCD Name                       Offset    Section Name\\r\\n')\n    for pcditem in list:\n        f.write('%-30s 0x%-08X %-6s\\r\\n' % (pcditem[0], pcditem[1], pcditem[2]))\n    f.close()",
            "def generatePcdTable(list, pcdpath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        f = open(pcdpath, 'w')\n    except:\n        pass\n    f.write('PCD Name                       Offset    Section Name\\r\\n')\n    for pcditem in list:\n        f.write('%-30s 0x%-08X %-6s\\r\\n' % (pcditem[0], pcditem[1], pcditem[2]))\n    f.close()",
            "def generatePcdTable(list, pcdpath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        f = open(pcdpath, 'w')\n    except:\n        pass\n    f.write('PCD Name                       Offset    Section Name\\r\\n')\n    for pcditem in list:\n        f.write('%-30s 0x%-08X %-6s\\r\\n' % (pcditem[0], pcditem[1], pcditem[2]))\n    f.close()",
            "def generatePcdTable(list, pcdpath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        f = open(pcdpath, 'w')\n    except:\n        pass\n    f.write('PCD Name                       Offset    Section Name\\r\\n')\n    for pcditem in list:\n        f.write('%-30s 0x%-08X %-6s\\r\\n' % (pcditem[0], pcditem[1], pcditem[2]))\n    f.close()"
        ]
    }
]