[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Only works on Windows systems\n    \"\"\"\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_firewall: module only available on Windows')\n    return __virtualname__",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_firewall: module only available on Windows')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_firewall: module only available on Windows')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_firewall: module only available on Windows')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_firewall: module only available on Windows')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_firewall: module only available on Windows')\n    return __virtualname__"
        ]
    },
    {
        "func_name": "get_config",
        "original": "def get_config():\n    \"\"\"\n    Get the status of all the firewall profiles\n\n    Returns:\n        dict: A dictionary of all profiles on the system\n\n    Raises:\n        CommandExecutionError: If the command fails\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' firewall.get_config\n    \"\"\"\n    profiles = {}\n    curr = None\n    cmd = ['netsh', 'advfirewall', 'show', 'allprofiles']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    for line in ret['stdout'].splitlines():\n        if not curr:\n            tmp = re.search('(.*) Profile Settings:', line)\n            if tmp:\n                curr = tmp.group(1)\n        elif line.startswith('State'):\n            profiles[curr] = line.split()[1] == 'ON'\n            curr = None\n    return profiles",
        "mutated": [
            "def get_config():\n    if False:\n        i = 10\n    \"\\n    Get the status of all the firewall profiles\\n\\n    Returns:\\n        dict: A dictionary of all profiles on the system\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_config\\n    \"\n    profiles = {}\n    curr = None\n    cmd = ['netsh', 'advfirewall', 'show', 'allprofiles']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    for line in ret['stdout'].splitlines():\n        if not curr:\n            tmp = re.search('(.*) Profile Settings:', line)\n            if tmp:\n                curr = tmp.group(1)\n        elif line.startswith('State'):\n            profiles[curr] = line.split()[1] == 'ON'\n            curr = None\n    return profiles",
            "def get_config():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get the status of all the firewall profiles\\n\\n    Returns:\\n        dict: A dictionary of all profiles on the system\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_config\\n    \"\n    profiles = {}\n    curr = None\n    cmd = ['netsh', 'advfirewall', 'show', 'allprofiles']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    for line in ret['stdout'].splitlines():\n        if not curr:\n            tmp = re.search('(.*) Profile Settings:', line)\n            if tmp:\n                curr = tmp.group(1)\n        elif line.startswith('State'):\n            profiles[curr] = line.split()[1] == 'ON'\n            curr = None\n    return profiles",
            "def get_config():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get the status of all the firewall profiles\\n\\n    Returns:\\n        dict: A dictionary of all profiles on the system\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_config\\n    \"\n    profiles = {}\n    curr = None\n    cmd = ['netsh', 'advfirewall', 'show', 'allprofiles']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    for line in ret['stdout'].splitlines():\n        if not curr:\n            tmp = re.search('(.*) Profile Settings:', line)\n            if tmp:\n                curr = tmp.group(1)\n        elif line.startswith('State'):\n            profiles[curr] = line.split()[1] == 'ON'\n            curr = None\n    return profiles",
            "def get_config():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get the status of all the firewall profiles\\n\\n    Returns:\\n        dict: A dictionary of all profiles on the system\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_config\\n    \"\n    profiles = {}\n    curr = None\n    cmd = ['netsh', 'advfirewall', 'show', 'allprofiles']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    for line in ret['stdout'].splitlines():\n        if not curr:\n            tmp = re.search('(.*) Profile Settings:', line)\n            if tmp:\n                curr = tmp.group(1)\n        elif line.startswith('State'):\n            profiles[curr] = line.split()[1] == 'ON'\n            curr = None\n    return profiles",
            "def get_config():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get the status of all the firewall profiles\\n\\n    Returns:\\n        dict: A dictionary of all profiles on the system\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_config\\n    \"\n    profiles = {}\n    curr = None\n    cmd = ['netsh', 'advfirewall', 'show', 'allprofiles']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    for line in ret['stdout'].splitlines():\n        if not curr:\n            tmp = re.search('(.*) Profile Settings:', line)\n            if tmp:\n                curr = tmp.group(1)\n        elif line.startswith('State'):\n            profiles[curr] = line.split()[1] == 'ON'\n            curr = None\n    return profiles"
        ]
    },
    {
        "func_name": "disable",
        "original": "def disable(profile='allprofiles'):\n    \"\"\"\n    Disable firewall profile\n\n    Args:\n        profile (Optional[str]): The name of the profile to disable. Default is\n            ``allprofiles``. Valid options are:\n\n            - allprofiles\n            - domainprofile\n            - privateprofile\n            - publicprofile\n\n    Returns:\n        bool: True if successful\n\n    Raises:\n        CommandExecutionError: If the command fails\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' firewall.disable\n    \"\"\"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'off']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
        "mutated": [
            "def disable(profile='allprofiles'):\n    if False:\n        i = 10\n    \"\\n    Disable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to disable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.disable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'off']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def disable(profile='allprofiles'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Disable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to disable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.disable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'off']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def disable(profile='allprofiles'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Disable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to disable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.disable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'off']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def disable(profile='allprofiles'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Disable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to disable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.disable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'off']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def disable(profile='allprofiles'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Disable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to disable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.disable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'off']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True"
        ]
    },
    {
        "func_name": "enable",
        "original": "def enable(profile='allprofiles'):\n    \"\"\"\n    .. versionadded:: 2015.5.0\n\n    Enable firewall profile\n\n    Args:\n        profile (Optional[str]): The name of the profile to enable. Default is\n            ``allprofiles``. Valid options are:\n\n            - allprofiles\n            - domainprofile\n            - privateprofile\n            - publicprofile\n\n    Returns:\n        bool: True if successful\n\n    Raises:\n        CommandExecutionError: If the command fails\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' firewall.enable\n    \"\"\"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'on']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
        "mutated": [
            "def enable(profile='allprofiles'):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Enable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to enable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.enable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'on']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def enable(profile='allprofiles'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Enable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to enable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.enable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'on']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def enable(profile='allprofiles'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Enable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to enable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.enable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'on']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def enable(profile='allprofiles'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Enable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to enable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.enable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'on']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def enable(profile='allprofiles'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Enable firewall profile\\n\\n    Args:\\n        profile (Optional[str]): The name of the profile to enable. Default is\\n            ``allprofiles``. Valid options are:\\n\\n            - allprofiles\\n            - domainprofile\\n            - privateprofile\\n            - publicprofile\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.enable\\n    \"\n    cmd = ['netsh', 'advfirewall', 'set', profile, 'state', 'on']\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True"
        ]
    },
    {
        "func_name": "get_rule",
        "original": "def get_rule(name='all'):\n    \"\"\"\n    .. versionadded:: 2015.5.0\n\n    Display all matching rules as specified by name\n\n    Args:\n        name (Optional[str]): The full name of the rule. ``all`` will return all\n            rules. Default is ``all``\n\n    Returns:\n        dict: A dictionary of all rules or rules that match the name exactly\n\n    Raises:\n        CommandExecutionError: If the command fails\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' firewall.get_rule 'MyAppPort'\n    \"\"\"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'show', 'rule', 'name={}'.format(name)]\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return {name: ret['stdout']}",
        "mutated": [
            "def get_rule(name='all'):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Display all matching rules as specified by name\\n\\n    Args:\\n        name (Optional[str]): The full name of the rule. ``all`` will return all\\n            rules. Default is ``all``\\n\\n    Returns:\\n        dict: A dictionary of all rules or rules that match the name exactly\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_rule 'MyAppPort'\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'show', 'rule', 'name={}'.format(name)]\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return {name: ret['stdout']}",
            "def get_rule(name='all'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Display all matching rules as specified by name\\n\\n    Args:\\n        name (Optional[str]): The full name of the rule. ``all`` will return all\\n            rules. Default is ``all``\\n\\n    Returns:\\n        dict: A dictionary of all rules or rules that match the name exactly\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_rule 'MyAppPort'\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'show', 'rule', 'name={}'.format(name)]\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return {name: ret['stdout']}",
            "def get_rule(name='all'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Display all matching rules as specified by name\\n\\n    Args:\\n        name (Optional[str]): The full name of the rule. ``all`` will return all\\n            rules. Default is ``all``\\n\\n    Returns:\\n        dict: A dictionary of all rules or rules that match the name exactly\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_rule 'MyAppPort'\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'show', 'rule', 'name={}'.format(name)]\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return {name: ret['stdout']}",
            "def get_rule(name='all'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Display all matching rules as specified by name\\n\\n    Args:\\n        name (Optional[str]): The full name of the rule. ``all`` will return all\\n            rules. Default is ``all``\\n\\n    Returns:\\n        dict: A dictionary of all rules or rules that match the name exactly\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_rule 'MyAppPort'\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'show', 'rule', 'name={}'.format(name)]\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return {name: ret['stdout']}",
            "def get_rule(name='all'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Display all matching rules as specified by name\\n\\n    Args:\\n        name (Optional[str]): The full name of the rule. ``all`` will return all\\n            rules. Default is ``all``\\n\\n    Returns:\\n        dict: A dictionary of all rules or rules that match the name exactly\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' firewall.get_rule 'MyAppPort'\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'show', 'rule', 'name={}'.format(name)]\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return {name: ret['stdout']}"
        ]
    },
    {
        "func_name": "add_rule",
        "original": "def add_rule(name, localport, protocol='tcp', action='allow', dir='in', remoteip='any'):\n    \"\"\"\n    .. versionadded:: 2015.5.0\n\n    Add a new inbound or outbound rule to the firewall policy\n\n    Args:\n\n        name (str): The name of the rule. Must be unique and cannot be \"all\".\n            Required.\n\n        localport (int): The port the rule applies to. Must be a number between\n            0 and 65535. Can be a range. Can specify multiple ports separated by\n            commas. Required.\n\n        protocol (Optional[str]): The protocol. Can be any of the following:\n\n            - A number between 0 and 255\n            - icmpv4\n            - icmpv6\n            - tcp\n            - udp\n            - any\n\n        action (Optional[str]): The action the rule performs. Can be any of the\n            following:\n\n            - allow\n            - block\n            - bypass\n\n        dir (Optional[str]): The direction. Can be ``in`` or ``out``.\n\n        remoteip (Optional [str]): The remote IP. Can be any of the following:\n\n            - any\n            - localsubnet\n            - dns\n            - dhcp\n            - wins\n            - defaultgateway\n            - Any valid IPv4 address (192.168.0.12)\n            - Any valid IPv6 address (2002:9b3b:1a31:4:208:74ff:fe39:6c43)\n            - Any valid subnet (192.168.1.0/24)\n            - Any valid range of IP addresses (192.168.0.1-192.168.0.12)\n            - A list of valid IP addresses\n\n            Can be combinations of the above separated by commas.\n\n    Returns:\n        bool: True if successful\n\n    Raises:\n        CommandExecutionError: If the command fails\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' firewall.add_rule 'test' '8080' 'tcp'\n        salt '*' firewall.add_rule 'test' '1' 'icmpv4'\n        salt '*' firewall.add_rule 'test_remote_ip' '8000' 'tcp' 'allow' 'in' '192.168.0.1'\n    \"\"\"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'add', 'rule', 'name={}'.format(name), 'protocol={}'.format(protocol), 'dir={}'.format(dir), 'action={}'.format(action), 'remoteip={}'.format(remoteip)]\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
        "mutated": [
            "def add_rule(name, localport, protocol='tcp', action='allow', dir='in', remoteip='any'):\n    if False:\n        i = 10\n    '\\n    .. versionadded:: 2015.5.0\\n\\n    Add a new inbound or outbound rule to the firewall policy\\n\\n    Args:\\n\\n        name (str): The name of the rule. Must be unique and cannot be \"all\".\\n            Required.\\n\\n        localport (int): The port the rule applies to. Must be a number between\\n            0 and 65535. Can be a range. Can specify multiple ports separated by\\n            commas. Required.\\n\\n        protocol (Optional[str]): The protocol. Can be any of the following:\\n\\n            - A number between 0 and 255\\n            - icmpv4\\n            - icmpv6\\n            - tcp\\n            - udp\\n            - any\\n\\n        action (Optional[str]): The action the rule performs. Can be any of the\\n            following:\\n\\n            - allow\\n            - block\\n            - bypass\\n\\n        dir (Optional[str]): The direction. Can be ``in`` or ``out``.\\n\\n        remoteip (Optional [str]): The remote IP. Can be any of the following:\\n\\n            - any\\n            - localsubnet\\n            - dns\\n            - dhcp\\n            - wins\\n            - defaultgateway\\n            - Any valid IPv4 address (192.168.0.12)\\n            - Any valid IPv6 address (2002:9b3b:1a31:4:208:74ff:fe39:6c43)\\n            - Any valid subnet (192.168.1.0/24)\\n            - Any valid range of IP addresses (192.168.0.1-192.168.0.12)\\n            - A list of valid IP addresses\\n\\n            Can be combinations of the above separated by commas.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'8080\\' \\'tcp\\'\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'1\\' \\'icmpv4\\'\\n        salt \\'*\\' firewall.add_rule \\'test_remote_ip\\' \\'8000\\' \\'tcp\\' \\'allow\\' \\'in\\' \\'192.168.0.1\\'\\n    '\n    cmd = ['netsh', 'advfirewall', 'firewall', 'add', 'rule', 'name={}'.format(name), 'protocol={}'.format(protocol), 'dir={}'.format(dir), 'action={}'.format(action), 'remoteip={}'.format(remoteip)]\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def add_rule(name, localport, protocol='tcp', action='allow', dir='in', remoteip='any'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionadded:: 2015.5.0\\n\\n    Add a new inbound or outbound rule to the firewall policy\\n\\n    Args:\\n\\n        name (str): The name of the rule. Must be unique and cannot be \"all\".\\n            Required.\\n\\n        localport (int): The port the rule applies to. Must be a number between\\n            0 and 65535. Can be a range. Can specify multiple ports separated by\\n            commas. Required.\\n\\n        protocol (Optional[str]): The protocol. Can be any of the following:\\n\\n            - A number between 0 and 255\\n            - icmpv4\\n            - icmpv6\\n            - tcp\\n            - udp\\n            - any\\n\\n        action (Optional[str]): The action the rule performs. Can be any of the\\n            following:\\n\\n            - allow\\n            - block\\n            - bypass\\n\\n        dir (Optional[str]): The direction. Can be ``in`` or ``out``.\\n\\n        remoteip (Optional [str]): The remote IP. Can be any of the following:\\n\\n            - any\\n            - localsubnet\\n            - dns\\n            - dhcp\\n            - wins\\n            - defaultgateway\\n            - Any valid IPv4 address (192.168.0.12)\\n            - Any valid IPv6 address (2002:9b3b:1a31:4:208:74ff:fe39:6c43)\\n            - Any valid subnet (192.168.1.0/24)\\n            - Any valid range of IP addresses (192.168.0.1-192.168.0.12)\\n            - A list of valid IP addresses\\n\\n            Can be combinations of the above separated by commas.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'8080\\' \\'tcp\\'\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'1\\' \\'icmpv4\\'\\n        salt \\'*\\' firewall.add_rule \\'test_remote_ip\\' \\'8000\\' \\'tcp\\' \\'allow\\' \\'in\\' \\'192.168.0.1\\'\\n    '\n    cmd = ['netsh', 'advfirewall', 'firewall', 'add', 'rule', 'name={}'.format(name), 'protocol={}'.format(protocol), 'dir={}'.format(dir), 'action={}'.format(action), 'remoteip={}'.format(remoteip)]\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def add_rule(name, localport, protocol='tcp', action='allow', dir='in', remoteip='any'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionadded:: 2015.5.0\\n\\n    Add a new inbound or outbound rule to the firewall policy\\n\\n    Args:\\n\\n        name (str): The name of the rule. Must be unique and cannot be \"all\".\\n            Required.\\n\\n        localport (int): The port the rule applies to. Must be a number between\\n            0 and 65535. Can be a range. Can specify multiple ports separated by\\n            commas. Required.\\n\\n        protocol (Optional[str]): The protocol. Can be any of the following:\\n\\n            - A number between 0 and 255\\n            - icmpv4\\n            - icmpv6\\n            - tcp\\n            - udp\\n            - any\\n\\n        action (Optional[str]): The action the rule performs. Can be any of the\\n            following:\\n\\n            - allow\\n            - block\\n            - bypass\\n\\n        dir (Optional[str]): The direction. Can be ``in`` or ``out``.\\n\\n        remoteip (Optional [str]): The remote IP. Can be any of the following:\\n\\n            - any\\n            - localsubnet\\n            - dns\\n            - dhcp\\n            - wins\\n            - defaultgateway\\n            - Any valid IPv4 address (192.168.0.12)\\n            - Any valid IPv6 address (2002:9b3b:1a31:4:208:74ff:fe39:6c43)\\n            - Any valid subnet (192.168.1.0/24)\\n            - Any valid range of IP addresses (192.168.0.1-192.168.0.12)\\n            - A list of valid IP addresses\\n\\n            Can be combinations of the above separated by commas.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'8080\\' \\'tcp\\'\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'1\\' \\'icmpv4\\'\\n        salt \\'*\\' firewall.add_rule \\'test_remote_ip\\' \\'8000\\' \\'tcp\\' \\'allow\\' \\'in\\' \\'192.168.0.1\\'\\n    '\n    cmd = ['netsh', 'advfirewall', 'firewall', 'add', 'rule', 'name={}'.format(name), 'protocol={}'.format(protocol), 'dir={}'.format(dir), 'action={}'.format(action), 'remoteip={}'.format(remoteip)]\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def add_rule(name, localport, protocol='tcp', action='allow', dir='in', remoteip='any'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionadded:: 2015.5.0\\n\\n    Add a new inbound or outbound rule to the firewall policy\\n\\n    Args:\\n\\n        name (str): The name of the rule. Must be unique and cannot be \"all\".\\n            Required.\\n\\n        localport (int): The port the rule applies to. Must be a number between\\n            0 and 65535. Can be a range. Can specify multiple ports separated by\\n            commas. Required.\\n\\n        protocol (Optional[str]): The protocol. Can be any of the following:\\n\\n            - A number between 0 and 255\\n            - icmpv4\\n            - icmpv6\\n            - tcp\\n            - udp\\n            - any\\n\\n        action (Optional[str]): The action the rule performs. Can be any of the\\n            following:\\n\\n            - allow\\n            - block\\n            - bypass\\n\\n        dir (Optional[str]): The direction. Can be ``in`` or ``out``.\\n\\n        remoteip (Optional [str]): The remote IP. Can be any of the following:\\n\\n            - any\\n            - localsubnet\\n            - dns\\n            - dhcp\\n            - wins\\n            - defaultgateway\\n            - Any valid IPv4 address (192.168.0.12)\\n            - Any valid IPv6 address (2002:9b3b:1a31:4:208:74ff:fe39:6c43)\\n            - Any valid subnet (192.168.1.0/24)\\n            - Any valid range of IP addresses (192.168.0.1-192.168.0.12)\\n            - A list of valid IP addresses\\n\\n            Can be combinations of the above separated by commas.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'8080\\' \\'tcp\\'\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'1\\' \\'icmpv4\\'\\n        salt \\'*\\' firewall.add_rule \\'test_remote_ip\\' \\'8000\\' \\'tcp\\' \\'allow\\' \\'in\\' \\'192.168.0.1\\'\\n    '\n    cmd = ['netsh', 'advfirewall', 'firewall', 'add', 'rule', 'name={}'.format(name), 'protocol={}'.format(protocol), 'dir={}'.format(dir), 'action={}'.format(action), 'remoteip={}'.format(remoteip)]\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def add_rule(name, localport, protocol='tcp', action='allow', dir='in', remoteip='any'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionadded:: 2015.5.0\\n\\n    Add a new inbound or outbound rule to the firewall policy\\n\\n    Args:\\n\\n        name (str): The name of the rule. Must be unique and cannot be \"all\".\\n            Required.\\n\\n        localport (int): The port the rule applies to. Must be a number between\\n            0 and 65535. Can be a range. Can specify multiple ports separated by\\n            commas. Required.\\n\\n        protocol (Optional[str]): The protocol. Can be any of the following:\\n\\n            - A number between 0 and 255\\n            - icmpv4\\n            - icmpv6\\n            - tcp\\n            - udp\\n            - any\\n\\n        action (Optional[str]): The action the rule performs. Can be any of the\\n            following:\\n\\n            - allow\\n            - block\\n            - bypass\\n\\n        dir (Optional[str]): The direction. Can be ``in`` or ``out``.\\n\\n        remoteip (Optional [str]): The remote IP. Can be any of the following:\\n\\n            - any\\n            - localsubnet\\n            - dns\\n            - dhcp\\n            - wins\\n            - defaultgateway\\n            - Any valid IPv4 address (192.168.0.12)\\n            - Any valid IPv6 address (2002:9b3b:1a31:4:208:74ff:fe39:6c43)\\n            - Any valid subnet (192.168.1.0/24)\\n            - Any valid range of IP addresses (192.168.0.1-192.168.0.12)\\n            - A list of valid IP addresses\\n\\n            Can be combinations of the above separated by commas.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'8080\\' \\'tcp\\'\\n        salt \\'*\\' firewall.add_rule \\'test\\' \\'1\\' \\'icmpv4\\'\\n        salt \\'*\\' firewall.add_rule \\'test_remote_ip\\' \\'8000\\' \\'tcp\\' \\'allow\\' \\'in\\' \\'192.168.0.1\\'\\n    '\n    cmd = ['netsh', 'advfirewall', 'firewall', 'add', 'rule', 'name={}'.format(name), 'protocol={}'.format(protocol), 'dir={}'.format(dir), 'action={}'.format(action), 'remoteip={}'.format(remoteip)]\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True"
        ]
    },
    {
        "func_name": "delete_rule",
        "original": "def delete_rule(name=None, localport=None, protocol=None, dir=None, remoteip=None):\n    \"\"\"\n    .. versionadded:: 2015.8.0\n\n    Delete an existing firewall rule identified by name and optionally by ports,\n    protocols, direction, and remote IP.\n\n    Args:\n\n        name (str): The name of the rule to delete. If the name ``all`` is used\n            you must specify additional parameters.\n\n        localport (Optional[str]): The port of the rule. If protocol is not\n            specified, protocol will be set to ``tcp``\n\n        protocol (Optional[str]): The protocol of the rule. Default is ``tcp``\n            when ``localport`` is specified\n\n        dir (Optional[str]): The direction of the rule.\n\n        remoteip (Optional[str]): The remote IP of the rule.\n\n    Returns:\n        bool: True if successful\n\n    Raises:\n        CommandExecutionError: If the command fails\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Delete incoming tcp port 8080 in the rule named 'test'\n        salt '*' firewall.delete_rule 'test' '8080' 'tcp' 'in'\n\n        # Delete the incoming tcp port 8000 from 192.168.0.1 in the rule named\n        # 'test_remote_ip'\n        salt '*' firewall.delete_rule 'test_remote_ip' '8000' 'tcp' 'in' '192.168.0.1'\n\n        # Delete all rules for local port 80:\n        salt '*' firewall.delete_rule all 80 tcp\n\n        # Delete a rule called 'allow80':\n        salt '*' firewall.delete_rule allow80\n    \"\"\"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'delete', 'rule']\n    if name:\n        cmd.append('name={}'.format(name))\n    if protocol:\n        cmd.append('protocol={}'.format(protocol))\n    if dir:\n        cmd.append('dir={}'.format(dir))\n    if remoteip:\n        cmd.append('remoteip={}'.format(remoteip))\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        if localport:\n            if not protocol:\n                cmd.append('protocol=tcp')\n            cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
        "mutated": [
            "def delete_rule(name=None, localport=None, protocol=None, dir=None, remoteip=None):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2015.8.0\\n\\n    Delete an existing firewall rule identified by name and optionally by ports,\\n    protocols, direction, and remote IP.\\n\\n    Args:\\n\\n        name (str): The name of the rule to delete. If the name ``all`` is used\\n            you must specify additional parameters.\\n\\n        localport (Optional[str]): The port of the rule. If protocol is not\\n            specified, protocol will be set to ``tcp``\\n\\n        protocol (Optional[str]): The protocol of the rule. Default is ``tcp``\\n            when ``localport`` is specified\\n\\n        dir (Optional[str]): The direction of the rule.\\n\\n        remoteip (Optional[str]): The remote IP of the rule.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Delete incoming tcp port 8080 in the rule named 'test'\\n        salt '*' firewall.delete_rule 'test' '8080' 'tcp' 'in'\\n\\n        # Delete the incoming tcp port 8000 from 192.168.0.1 in the rule named\\n        # 'test_remote_ip'\\n        salt '*' firewall.delete_rule 'test_remote_ip' '8000' 'tcp' 'in' '192.168.0.1'\\n\\n        # Delete all rules for local port 80:\\n        salt '*' firewall.delete_rule all 80 tcp\\n\\n        # Delete a rule called 'allow80':\\n        salt '*' firewall.delete_rule allow80\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'delete', 'rule']\n    if name:\n        cmd.append('name={}'.format(name))\n    if protocol:\n        cmd.append('protocol={}'.format(protocol))\n    if dir:\n        cmd.append('dir={}'.format(dir))\n    if remoteip:\n        cmd.append('remoteip={}'.format(remoteip))\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        if localport:\n            if not protocol:\n                cmd.append('protocol=tcp')\n            cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def delete_rule(name=None, localport=None, protocol=None, dir=None, remoteip=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2015.8.0\\n\\n    Delete an existing firewall rule identified by name and optionally by ports,\\n    protocols, direction, and remote IP.\\n\\n    Args:\\n\\n        name (str): The name of the rule to delete. If the name ``all`` is used\\n            you must specify additional parameters.\\n\\n        localport (Optional[str]): The port of the rule. If protocol is not\\n            specified, protocol will be set to ``tcp``\\n\\n        protocol (Optional[str]): The protocol of the rule. Default is ``tcp``\\n            when ``localport`` is specified\\n\\n        dir (Optional[str]): The direction of the rule.\\n\\n        remoteip (Optional[str]): The remote IP of the rule.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Delete incoming tcp port 8080 in the rule named 'test'\\n        salt '*' firewall.delete_rule 'test' '8080' 'tcp' 'in'\\n\\n        # Delete the incoming tcp port 8000 from 192.168.0.1 in the rule named\\n        # 'test_remote_ip'\\n        salt '*' firewall.delete_rule 'test_remote_ip' '8000' 'tcp' 'in' '192.168.0.1'\\n\\n        # Delete all rules for local port 80:\\n        salt '*' firewall.delete_rule all 80 tcp\\n\\n        # Delete a rule called 'allow80':\\n        salt '*' firewall.delete_rule allow80\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'delete', 'rule']\n    if name:\n        cmd.append('name={}'.format(name))\n    if protocol:\n        cmd.append('protocol={}'.format(protocol))\n    if dir:\n        cmd.append('dir={}'.format(dir))\n    if remoteip:\n        cmd.append('remoteip={}'.format(remoteip))\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        if localport:\n            if not protocol:\n                cmd.append('protocol=tcp')\n            cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def delete_rule(name=None, localport=None, protocol=None, dir=None, remoteip=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2015.8.0\\n\\n    Delete an existing firewall rule identified by name and optionally by ports,\\n    protocols, direction, and remote IP.\\n\\n    Args:\\n\\n        name (str): The name of the rule to delete. If the name ``all`` is used\\n            you must specify additional parameters.\\n\\n        localport (Optional[str]): The port of the rule. If protocol is not\\n            specified, protocol will be set to ``tcp``\\n\\n        protocol (Optional[str]): The protocol of the rule. Default is ``tcp``\\n            when ``localport`` is specified\\n\\n        dir (Optional[str]): The direction of the rule.\\n\\n        remoteip (Optional[str]): The remote IP of the rule.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Delete incoming tcp port 8080 in the rule named 'test'\\n        salt '*' firewall.delete_rule 'test' '8080' 'tcp' 'in'\\n\\n        # Delete the incoming tcp port 8000 from 192.168.0.1 in the rule named\\n        # 'test_remote_ip'\\n        salt '*' firewall.delete_rule 'test_remote_ip' '8000' 'tcp' 'in' '192.168.0.1'\\n\\n        # Delete all rules for local port 80:\\n        salt '*' firewall.delete_rule all 80 tcp\\n\\n        # Delete a rule called 'allow80':\\n        salt '*' firewall.delete_rule allow80\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'delete', 'rule']\n    if name:\n        cmd.append('name={}'.format(name))\n    if protocol:\n        cmd.append('protocol={}'.format(protocol))\n    if dir:\n        cmd.append('dir={}'.format(dir))\n    if remoteip:\n        cmd.append('remoteip={}'.format(remoteip))\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        if localport:\n            if not protocol:\n                cmd.append('protocol=tcp')\n            cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def delete_rule(name=None, localport=None, protocol=None, dir=None, remoteip=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2015.8.0\\n\\n    Delete an existing firewall rule identified by name and optionally by ports,\\n    protocols, direction, and remote IP.\\n\\n    Args:\\n\\n        name (str): The name of the rule to delete. If the name ``all`` is used\\n            you must specify additional parameters.\\n\\n        localport (Optional[str]): The port of the rule. If protocol is not\\n            specified, protocol will be set to ``tcp``\\n\\n        protocol (Optional[str]): The protocol of the rule. Default is ``tcp``\\n            when ``localport`` is specified\\n\\n        dir (Optional[str]): The direction of the rule.\\n\\n        remoteip (Optional[str]): The remote IP of the rule.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Delete incoming tcp port 8080 in the rule named 'test'\\n        salt '*' firewall.delete_rule 'test' '8080' 'tcp' 'in'\\n\\n        # Delete the incoming tcp port 8000 from 192.168.0.1 in the rule named\\n        # 'test_remote_ip'\\n        salt '*' firewall.delete_rule 'test_remote_ip' '8000' 'tcp' 'in' '192.168.0.1'\\n\\n        # Delete all rules for local port 80:\\n        salt '*' firewall.delete_rule all 80 tcp\\n\\n        # Delete a rule called 'allow80':\\n        salt '*' firewall.delete_rule allow80\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'delete', 'rule']\n    if name:\n        cmd.append('name={}'.format(name))\n    if protocol:\n        cmd.append('protocol={}'.format(protocol))\n    if dir:\n        cmd.append('dir={}'.format(dir))\n    if remoteip:\n        cmd.append('remoteip={}'.format(remoteip))\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        if localport:\n            if not protocol:\n                cmd.append('protocol=tcp')\n            cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True",
            "def delete_rule(name=None, localport=None, protocol=None, dir=None, remoteip=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2015.8.0\\n\\n    Delete an existing firewall rule identified by name and optionally by ports,\\n    protocols, direction, and remote IP.\\n\\n    Args:\\n\\n        name (str): The name of the rule to delete. If the name ``all`` is used\\n            you must specify additional parameters.\\n\\n        localport (Optional[str]): The port of the rule. If protocol is not\\n            specified, protocol will be set to ``tcp``\\n\\n        protocol (Optional[str]): The protocol of the rule. Default is ``tcp``\\n            when ``localport`` is specified\\n\\n        dir (Optional[str]): The direction of the rule.\\n\\n        remoteip (Optional[str]): The remote IP of the rule.\\n\\n    Returns:\\n        bool: True if successful\\n\\n    Raises:\\n        CommandExecutionError: If the command fails\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Delete incoming tcp port 8080 in the rule named 'test'\\n        salt '*' firewall.delete_rule 'test' '8080' 'tcp' 'in'\\n\\n        # Delete the incoming tcp port 8000 from 192.168.0.1 in the rule named\\n        # 'test_remote_ip'\\n        salt '*' firewall.delete_rule 'test_remote_ip' '8000' 'tcp' 'in' '192.168.0.1'\\n\\n        # Delete all rules for local port 80:\\n        salt '*' firewall.delete_rule all 80 tcp\\n\\n        # Delete a rule called 'allow80':\\n        salt '*' firewall.delete_rule allow80\\n    \"\n    cmd = ['netsh', 'advfirewall', 'firewall', 'delete', 'rule']\n    if name:\n        cmd.append('name={}'.format(name))\n    if protocol:\n        cmd.append('protocol={}'.format(protocol))\n    if dir:\n        cmd.append('dir={}'.format(dir))\n    if remoteip:\n        cmd.append('remoteip={}'.format(remoteip))\n    if protocol is None or ('icmpv4' not in protocol and 'icmpv6' not in protocol):\n        if localport:\n            if not protocol:\n                cmd.append('protocol=tcp')\n            cmd.append('localport={}'.format(localport))\n    ret = __salt__['cmd.run_all'](cmd, python_shell=False, ignore_retcode=True)\n    if ret['retcode'] != 0:\n        raise CommandExecutionError(ret['stdout'])\n    return True"
        ]
    },
    {
        "func_name": "rule_exists",
        "original": "def rule_exists(name):\n    \"\"\"\n    .. versionadded:: 2016.11.6\n\n    Checks if a firewall rule exists in the firewall policy\n\n    Args:\n        name (str): The name of the rule\n\n    Returns:\n        bool: True if exists, otherwise False\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Is there a rule named RemoteDesktop\n        salt '*' firewall.rule_exists RemoteDesktop\n    \"\"\"\n    try:\n        get_rule(name)\n        return True\n    except CommandExecutionError:\n        return False",
        "mutated": [
            "def rule_exists(name):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2016.11.6\\n\\n    Checks if a firewall rule exists in the firewall policy\\n\\n    Args:\\n        name (str): The name of the rule\\n\\n    Returns:\\n        bool: True if exists, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Is there a rule named RemoteDesktop\\n        salt '*' firewall.rule_exists RemoteDesktop\\n    \"\n    try:\n        get_rule(name)\n        return True\n    except CommandExecutionError:\n        return False",
            "def rule_exists(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2016.11.6\\n\\n    Checks if a firewall rule exists in the firewall policy\\n\\n    Args:\\n        name (str): The name of the rule\\n\\n    Returns:\\n        bool: True if exists, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Is there a rule named RemoteDesktop\\n        salt '*' firewall.rule_exists RemoteDesktop\\n    \"\n    try:\n        get_rule(name)\n        return True\n    except CommandExecutionError:\n        return False",
            "def rule_exists(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2016.11.6\\n\\n    Checks if a firewall rule exists in the firewall policy\\n\\n    Args:\\n        name (str): The name of the rule\\n\\n    Returns:\\n        bool: True if exists, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Is there a rule named RemoteDesktop\\n        salt '*' firewall.rule_exists RemoteDesktop\\n    \"\n    try:\n        get_rule(name)\n        return True\n    except CommandExecutionError:\n        return False",
            "def rule_exists(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2016.11.6\\n\\n    Checks if a firewall rule exists in the firewall policy\\n\\n    Args:\\n        name (str): The name of the rule\\n\\n    Returns:\\n        bool: True if exists, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Is there a rule named RemoteDesktop\\n        salt '*' firewall.rule_exists RemoteDesktop\\n    \"\n    try:\n        get_rule(name)\n        return True\n    except CommandExecutionError:\n        return False",
            "def rule_exists(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2016.11.6\\n\\n    Checks if a firewall rule exists in the firewall policy\\n\\n    Args:\\n        name (str): The name of the rule\\n\\n    Returns:\\n        bool: True if exists, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Is there a rule named RemoteDesktop\\n        salt '*' firewall.rule_exists RemoteDesktop\\n    \"\n    try:\n        get_rule(name)\n        return True\n    except CommandExecutionError:\n        return False"
        ]
    },
    {
        "func_name": "get_settings",
        "original": "def get_settings(profile, section, store='local'):\n    \"\"\"\n    Get the firewall property from the specified profile in the specified store\n    as returned by ``netsh advfirewall``.\n\n    .. versionadded:: 2018.3.4\n    .. versionadded:: 2019.2.0\n\n    Args:\n\n        profile (str):\n            The firewall profile to query. Valid options are:\n\n            - domain\n            - public\n            - private\n\n        section (str):\n            The property to query within the selected profile. Valid options\n            are:\n\n            - firewallpolicy : inbound/outbound behavior\n            - logging : firewall logging settings\n            - settings : firewall properties\n            - state : firewalls state (on | off)\n\n        store (str):\n            The store to use. This is either the local firewall policy or the\n            policy defined by local group policy. Valid options are:\n\n            - lgpo\n            - local\n\n            Default is ``local``\n\n    Returns:\n        dict: A dictionary containing the properties for the specified profile\n\n    Raises:\n        CommandExecutionError: If an error occurs\n        ValueError: If the parameters are incorrect\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Get the inbound/outbound firewall settings for connections on the\n        # local domain profile\n        salt * win_firewall.get_settings domain firewallpolicy\n\n        # Get the inbound/outbound firewall settings for connections on the\n        # domain profile as defined by local group policy\n        salt * win_firewall.get_settings domain firewallpolicy lgpo\n    \"\"\"\n    return salt.utils.win_lgpo_netsh.get_settings(profile=profile, section=section, store=store)",
        "mutated": [
            "def get_settings(profile, section, store='local'):\n    if False:\n        i = 10\n    '\\n    Get the firewall property from the specified profile in the specified store\\n    as returned by ``netsh advfirewall``.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        section (str):\\n            The property to query within the selected profile. Valid options\\n            are:\\n\\n            - firewallpolicy : inbound/outbound behavior\\n            - logging : firewall logging settings\\n            - settings : firewall properties\\n            - state : firewalls state (on | off)\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the properties for the specified profile\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # local domain profile\\n        salt * win_firewall.get_settings domain firewallpolicy\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # domain profile as defined by local group policy\\n        salt * win_firewall.get_settings domain firewallpolicy lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_settings(profile=profile, section=section, store=store)",
            "def get_settings(profile, section, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get the firewall property from the specified profile in the specified store\\n    as returned by ``netsh advfirewall``.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        section (str):\\n            The property to query within the selected profile. Valid options\\n            are:\\n\\n            - firewallpolicy : inbound/outbound behavior\\n            - logging : firewall logging settings\\n            - settings : firewall properties\\n            - state : firewalls state (on | off)\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the properties for the specified profile\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # local domain profile\\n        salt * win_firewall.get_settings domain firewallpolicy\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # domain profile as defined by local group policy\\n        salt * win_firewall.get_settings domain firewallpolicy lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_settings(profile=profile, section=section, store=store)",
            "def get_settings(profile, section, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get the firewall property from the specified profile in the specified store\\n    as returned by ``netsh advfirewall``.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        section (str):\\n            The property to query within the selected profile. Valid options\\n            are:\\n\\n            - firewallpolicy : inbound/outbound behavior\\n            - logging : firewall logging settings\\n            - settings : firewall properties\\n            - state : firewalls state (on | off)\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the properties for the specified profile\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # local domain profile\\n        salt * win_firewall.get_settings domain firewallpolicy\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # domain profile as defined by local group policy\\n        salt * win_firewall.get_settings domain firewallpolicy lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_settings(profile=profile, section=section, store=store)",
            "def get_settings(profile, section, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get the firewall property from the specified profile in the specified store\\n    as returned by ``netsh advfirewall``.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        section (str):\\n            The property to query within the selected profile. Valid options\\n            are:\\n\\n            - firewallpolicy : inbound/outbound behavior\\n            - logging : firewall logging settings\\n            - settings : firewall properties\\n            - state : firewalls state (on | off)\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the properties for the specified profile\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # local domain profile\\n        salt * win_firewall.get_settings domain firewallpolicy\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # domain profile as defined by local group policy\\n        salt * win_firewall.get_settings domain firewallpolicy lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_settings(profile=profile, section=section, store=store)",
            "def get_settings(profile, section, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get the firewall property from the specified profile in the specified store\\n    as returned by ``netsh advfirewall``.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        section (str):\\n            The property to query within the selected profile. Valid options\\n            are:\\n\\n            - firewallpolicy : inbound/outbound behavior\\n            - logging : firewall logging settings\\n            - settings : firewall properties\\n            - state : firewalls state (on | off)\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the properties for the specified profile\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # local domain profile\\n        salt * win_firewall.get_settings domain firewallpolicy\\n\\n        # Get the inbound/outbound firewall settings for connections on the\\n        # domain profile as defined by local group policy\\n        salt * win_firewall.get_settings domain firewallpolicy lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_settings(profile=profile, section=section, store=store)"
        ]
    },
    {
        "func_name": "get_all_settings",
        "original": "def get_all_settings(domain, store='local'):\n    \"\"\"\n    Gets all the properties for the specified profile in the specified store\n\n    .. versionadded:: 2018.3.4\n    .. versionadded:: 2019.2.0\n\n    Args:\n\n        profile (str):\n            The firewall profile to query. Valid options are:\n\n            - domain\n            - public\n            - private\n\n        store (str):\n            The store to use. This is either the local firewall policy or the\n            policy defined by local group policy. Valid options are:\n\n            - lgpo\n            - local\n\n            Default is ``local``\n\n    Returns:\n        dict: A dictionary containing the specified settings\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Get all firewall settings for connections on the domain profile\n        salt * win_firewall.get_all_settings domain\n\n        # Get all firewall settings for connections on the domain profile as\n        # defined by local group policy\n        salt * win_firewall.get_all_settings domain lgpo\n    \"\"\"\n    return salt.utils.win_lgpo_netsh.get_all_settings(profile=domain, store=store)",
        "mutated": [
            "def get_all_settings(domain, store='local'):\n    if False:\n        i = 10\n    '\\n    Gets all the properties for the specified profile in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for connections on the domain profile\\n        salt * win_firewall.get_all_settings domain\\n\\n        # Get all firewall settings for connections on the domain profile as\\n        # defined by local group policy\\n        salt * win_firewall.get_all_settings domain lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_settings(profile=domain, store=store)",
            "def get_all_settings(domain, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Gets all the properties for the specified profile in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for connections on the domain profile\\n        salt * win_firewall.get_all_settings domain\\n\\n        # Get all firewall settings for connections on the domain profile as\\n        # defined by local group policy\\n        salt * win_firewall.get_all_settings domain lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_settings(profile=domain, store=store)",
            "def get_all_settings(domain, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Gets all the properties for the specified profile in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for connections on the domain profile\\n        salt * win_firewall.get_all_settings domain\\n\\n        # Get all firewall settings for connections on the domain profile as\\n        # defined by local group policy\\n        salt * win_firewall.get_all_settings domain lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_settings(profile=domain, store=store)",
            "def get_all_settings(domain, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Gets all the properties for the specified profile in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for connections on the domain profile\\n        salt * win_firewall.get_all_settings domain\\n\\n        # Get all firewall settings for connections on the domain profile as\\n        # defined by local group policy\\n        salt * win_firewall.get_all_settings domain lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_settings(profile=domain, store=store)",
            "def get_all_settings(domain, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Gets all the properties for the specified profile in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for connections on the domain profile\\n        salt * win_firewall.get_all_settings domain\\n\\n        # Get all firewall settings for connections on the domain profile as\\n        # defined by local group policy\\n        salt * win_firewall.get_all_settings domain lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_settings(profile=domain, store=store)"
        ]
    },
    {
        "func_name": "get_all_profiles",
        "original": "def get_all_profiles(store='local'):\n    \"\"\"\n    Gets all properties for all profiles in the specified store\n\n    .. versionadded:: 2018.3.4\n    .. versionadded:: 2019.2.0\n\n    Args:\n\n        store (str):\n            The store to use. This is either the local firewall policy or the\n            policy defined by local group policy. Valid options are:\n\n            - lgpo\n            - local\n\n            Default is ``local``\n\n    Returns:\n        dict: A dictionary containing the specified settings for each profile\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Get all firewall settings for all profiles\n        salt * firewall.get_all_settings\n\n        # Get all firewall settings for all profiles as defined by local group\n        # policy\n\n        salt * firewall.get_all_settings lgpo\n    \"\"\"\n    return salt.utils.win_lgpo_netsh.get_all_profiles(store=store)",
        "mutated": [
            "def get_all_profiles(store='local'):\n    if False:\n        i = 10\n    '\\n    Gets all properties for all profiles in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings for each profile\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for all profiles\\n        salt * firewall.get_all_settings\\n\\n        # Get all firewall settings for all profiles as defined by local group\\n        # policy\\n\\n        salt * firewall.get_all_settings lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_profiles(store=store)",
            "def get_all_profiles(store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Gets all properties for all profiles in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings for each profile\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for all profiles\\n        salt * firewall.get_all_settings\\n\\n        # Get all firewall settings for all profiles as defined by local group\\n        # policy\\n\\n        salt * firewall.get_all_settings lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_profiles(store=store)",
            "def get_all_profiles(store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Gets all properties for all profiles in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings for each profile\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for all profiles\\n        salt * firewall.get_all_settings\\n\\n        # Get all firewall settings for all profiles as defined by local group\\n        # policy\\n\\n        salt * firewall.get_all_settings lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_profiles(store=store)",
            "def get_all_profiles(store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Gets all properties for all profiles in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings for each profile\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for all profiles\\n        salt * firewall.get_all_settings\\n\\n        # Get all firewall settings for all profiles as defined by local group\\n        # policy\\n\\n        salt * firewall.get_all_settings lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_profiles(store=store)",
            "def get_all_profiles(store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Gets all properties for all profiles in the specified store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        dict: A dictionary containing the specified settings for each profile\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Get all firewall settings for all profiles\\n        salt * firewall.get_all_settings\\n\\n        # Get all firewall settings for all profiles as defined by local group\\n        # policy\\n\\n        salt * firewall.get_all_settings lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.get_all_profiles(store=store)"
        ]
    },
    {
        "func_name": "set_firewall_settings",
        "original": "def set_firewall_settings(profile, inbound=None, outbound=None, store='local'):\n    \"\"\"\n    Set the firewall inbound/outbound settings for the specified profile and\n    store\n\n    .. versionadded:: 2018.3.4\n    .. versionadded:: 2019.2.0\n\n    Args:\n\n        profile (str):\n            The firewall profile to query. Valid options are:\n\n            - domain\n            - public\n            - private\n\n        inbound (str):\n            The inbound setting. If ``None`` is passed, the setting will remain\n            unchanged. Valid values are:\n\n            - blockinbound\n            - blockinboundalways\n            - allowinbound\n            - notconfigured\n\n            Default is ``None``\n\n        outbound (str):\n            The outbound setting. If ``None`` is passed, the setting will remain\n            unchanged. Valid values are:\n\n            - allowoutbound\n            - blockoutbound\n            - notconfigured\n\n            Default is ``None``\n\n        store (str):\n            The store to use. This is either the local firewall policy or the\n            policy defined by local group policy. Valid options are:\n\n            - lgpo\n            - local\n\n            Default is ``local``\n\n    Returns:\n        bool: ``True`` if successful\n\n    Raises:\n        CommandExecutionError: If an error occurs\n        ValueError: If the parameters are incorrect\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Set the inbound setting for the domain profile to block inbound\n        # connections\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound'\n\n        # Set the outbound setting for the domain profile to allow outbound\n        # connections\n        salt * firewall.set_firewall_settings domain='domain' outbound='allowoutbound'\n\n        # Set inbound/outbound settings for the domain profile in the group\n        # policy to block inbound and allow outbound\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound' outbound='allowoutbound' store='lgpo'\n    \"\"\"\n    return salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=inbound, outbound=outbound, store=store)",
        "mutated": [
            "def set_firewall_settings(profile, inbound=None, outbound=None, store='local'):\n    if False:\n        i = 10\n    \"\\n    Set the firewall inbound/outbound settings for the specified profile and\\n    store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        inbound (str):\\n            The inbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - blockinbound\\n            - blockinboundalways\\n            - allowinbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        outbound (str):\\n            The outbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - allowoutbound\\n            - blockoutbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Set the inbound setting for the domain profile to block inbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound'\\n\\n        # Set the outbound setting for the domain profile to allow outbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' outbound='allowoutbound'\\n\\n        # Set inbound/outbound settings for the domain profile in the group\\n        # policy to block inbound and allow outbound\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound' outbound='allowoutbound' store='lgpo'\\n    \"\n    return salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=inbound, outbound=outbound, store=store)",
            "def set_firewall_settings(profile, inbound=None, outbound=None, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Set the firewall inbound/outbound settings for the specified profile and\\n    store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        inbound (str):\\n            The inbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - blockinbound\\n            - blockinboundalways\\n            - allowinbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        outbound (str):\\n            The outbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - allowoutbound\\n            - blockoutbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Set the inbound setting for the domain profile to block inbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound'\\n\\n        # Set the outbound setting for the domain profile to allow outbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' outbound='allowoutbound'\\n\\n        # Set inbound/outbound settings for the domain profile in the group\\n        # policy to block inbound and allow outbound\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound' outbound='allowoutbound' store='lgpo'\\n    \"\n    return salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=inbound, outbound=outbound, store=store)",
            "def set_firewall_settings(profile, inbound=None, outbound=None, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Set the firewall inbound/outbound settings for the specified profile and\\n    store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        inbound (str):\\n            The inbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - blockinbound\\n            - blockinboundalways\\n            - allowinbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        outbound (str):\\n            The outbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - allowoutbound\\n            - blockoutbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Set the inbound setting for the domain profile to block inbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound'\\n\\n        # Set the outbound setting for the domain profile to allow outbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' outbound='allowoutbound'\\n\\n        # Set inbound/outbound settings for the domain profile in the group\\n        # policy to block inbound and allow outbound\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound' outbound='allowoutbound' store='lgpo'\\n    \"\n    return salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=inbound, outbound=outbound, store=store)",
            "def set_firewall_settings(profile, inbound=None, outbound=None, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Set the firewall inbound/outbound settings for the specified profile and\\n    store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        inbound (str):\\n            The inbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - blockinbound\\n            - blockinboundalways\\n            - allowinbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        outbound (str):\\n            The outbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - allowoutbound\\n            - blockoutbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Set the inbound setting for the domain profile to block inbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound'\\n\\n        # Set the outbound setting for the domain profile to allow outbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' outbound='allowoutbound'\\n\\n        # Set inbound/outbound settings for the domain profile in the group\\n        # policy to block inbound and allow outbound\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound' outbound='allowoutbound' store='lgpo'\\n    \"\n    return salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=inbound, outbound=outbound, store=store)",
            "def set_firewall_settings(profile, inbound=None, outbound=None, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Set the firewall inbound/outbound settings for the specified profile and\\n    store\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to query. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        inbound (str):\\n            The inbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - blockinbound\\n            - blockinboundalways\\n            - allowinbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        outbound (str):\\n            The outbound setting. If ``None`` is passed, the setting will remain\\n            unchanged. Valid values are:\\n\\n            - allowoutbound\\n            - blockoutbound\\n            - notconfigured\\n\\n            Default is ``None``\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Set the inbound setting for the domain profile to block inbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound'\\n\\n        # Set the outbound setting for the domain profile to allow outbound\\n        # connections\\n        salt * firewall.set_firewall_settings domain='domain' outbound='allowoutbound'\\n\\n        # Set inbound/outbound settings for the domain profile in the group\\n        # policy to block inbound and allow outbound\\n        salt * firewall.set_firewall_settings domain='domain' inbound='blockinbound' outbound='allowoutbound' store='lgpo'\\n    \"\n    return salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=inbound, outbound=outbound, store=store)"
        ]
    },
    {
        "func_name": "set_logging_settings",
        "original": "def set_logging_settings(profile, setting, value, store='local'):\n    \"\"\"\n    Configure logging settings for the Windows firewall.\n\n    .. versionadded:: 2018.3.4\n    .. versionadded:: 2019.2.0\n\n    Args:\n\n        profile (str):\n            The firewall profile to configure. Valid options are:\n\n            - domain\n            - public\n            - private\n\n        setting (str):\n            The logging setting to configure. Valid options are:\n\n            - allowedconnections\n            - droppedconnections\n            - filename\n            - maxfilesize\n\n        value (str):\n            The value to apply to the setting. Valid values are dependent upon\n            the setting being configured. Valid options are:\n\n            allowedconnections:\n\n                - enable\n                - disable\n                - notconfigured\n\n            droppedconnections:\n\n                - enable\n                - disable\n                - notconfigured\n\n            filename:\n\n                - Full path and name of the firewall log file\n                - notconfigured\n\n            maxfilesize:\n\n                - 1 - 32767\n                - notconfigured\n\n            .. note::\n                ``notconfigured`` can only be used when using the lgpo store\n\n        store (str):\n            The store to use. This is either the local firewall policy or the\n            policy defined by local group policy. Valid options are:\n\n            - lgpo\n            - local\n\n            Default is ``local``\n\n    Returns:\n        bool: ``True`` if successful\n\n    Raises:\n        CommandExecutionError: If an error occurs\n        ValueError: If the parameters are incorrect\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Log allowed connections and set that in local group policy\n        salt * firewall.set_logging_settings domain allowedconnections enable lgpo\n\n        # Don't log dropped connections\n        salt * firewall.set_logging_settings profile=private setting=droppedconnections value=disable\n\n        # Set the location of the log file\n        salt * firewall.set_logging_settings domain filename C:\\\\windows\\\\logs\\\\firewall.log\n\n        # You can also use environment variables\n        salt * firewall.set_logging_settings domain filename %systemroot%\\\\system32\\\\LogFiles\\\\Firewall\\\\pfirewall.log\n\n        # Set the max file size of the log to 2048 Kb\n        salt * firewall.set_logging_settings domain maxfilesize 2048\n    \"\"\"\n    return salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=setting, value=value, store=store)",
        "mutated": [
            "def set_logging_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n    \"\\n    Configure logging settings for the Windows firewall.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The logging setting to configure. Valid options are:\\n\\n            - allowedconnections\\n            - droppedconnections\\n            - filename\\n            - maxfilesize\\n\\n        value (str):\\n            The value to apply to the setting. Valid values are dependent upon\\n            the setting being configured. Valid options are:\\n\\n            allowedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            droppedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            filename:\\n\\n                - Full path and name of the firewall log file\\n                - notconfigured\\n\\n            maxfilesize:\\n\\n                - 1 - 32767\\n                - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Log allowed connections and set that in local group policy\\n        salt * firewall.set_logging_settings domain allowedconnections enable lgpo\\n\\n        # Don't log dropped connections\\n        salt * firewall.set_logging_settings profile=private setting=droppedconnections value=disable\\n\\n        # Set the location of the log file\\n        salt * firewall.set_logging_settings domain filename C:\\\\windows\\\\logs\\\\firewall.log\\n\\n        # You can also use environment variables\\n        salt * firewall.set_logging_settings domain filename %systemroot%\\\\system32\\\\LogFiles\\\\Firewall\\\\pfirewall.log\\n\\n        # Set the max file size of the log to 2048 Kb\\n        salt * firewall.set_logging_settings domain maxfilesize 2048\\n    \"\n    return salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=setting, value=value, store=store)",
            "def set_logging_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Configure logging settings for the Windows firewall.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The logging setting to configure. Valid options are:\\n\\n            - allowedconnections\\n            - droppedconnections\\n            - filename\\n            - maxfilesize\\n\\n        value (str):\\n            The value to apply to the setting. Valid values are dependent upon\\n            the setting being configured. Valid options are:\\n\\n            allowedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            droppedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            filename:\\n\\n                - Full path and name of the firewall log file\\n                - notconfigured\\n\\n            maxfilesize:\\n\\n                - 1 - 32767\\n                - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Log allowed connections and set that in local group policy\\n        salt * firewall.set_logging_settings domain allowedconnections enable lgpo\\n\\n        # Don't log dropped connections\\n        salt * firewall.set_logging_settings profile=private setting=droppedconnections value=disable\\n\\n        # Set the location of the log file\\n        salt * firewall.set_logging_settings domain filename C:\\\\windows\\\\logs\\\\firewall.log\\n\\n        # You can also use environment variables\\n        salt * firewall.set_logging_settings domain filename %systemroot%\\\\system32\\\\LogFiles\\\\Firewall\\\\pfirewall.log\\n\\n        # Set the max file size of the log to 2048 Kb\\n        salt * firewall.set_logging_settings domain maxfilesize 2048\\n    \"\n    return salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=setting, value=value, store=store)",
            "def set_logging_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Configure logging settings for the Windows firewall.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The logging setting to configure. Valid options are:\\n\\n            - allowedconnections\\n            - droppedconnections\\n            - filename\\n            - maxfilesize\\n\\n        value (str):\\n            The value to apply to the setting. Valid values are dependent upon\\n            the setting being configured. Valid options are:\\n\\n            allowedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            droppedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            filename:\\n\\n                - Full path and name of the firewall log file\\n                - notconfigured\\n\\n            maxfilesize:\\n\\n                - 1 - 32767\\n                - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Log allowed connections and set that in local group policy\\n        salt * firewall.set_logging_settings domain allowedconnections enable lgpo\\n\\n        # Don't log dropped connections\\n        salt * firewall.set_logging_settings profile=private setting=droppedconnections value=disable\\n\\n        # Set the location of the log file\\n        salt * firewall.set_logging_settings domain filename C:\\\\windows\\\\logs\\\\firewall.log\\n\\n        # You can also use environment variables\\n        salt * firewall.set_logging_settings domain filename %systemroot%\\\\system32\\\\LogFiles\\\\Firewall\\\\pfirewall.log\\n\\n        # Set the max file size of the log to 2048 Kb\\n        salt * firewall.set_logging_settings domain maxfilesize 2048\\n    \"\n    return salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=setting, value=value, store=store)",
            "def set_logging_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Configure logging settings for the Windows firewall.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The logging setting to configure. Valid options are:\\n\\n            - allowedconnections\\n            - droppedconnections\\n            - filename\\n            - maxfilesize\\n\\n        value (str):\\n            The value to apply to the setting. Valid values are dependent upon\\n            the setting being configured. Valid options are:\\n\\n            allowedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            droppedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            filename:\\n\\n                - Full path and name of the firewall log file\\n                - notconfigured\\n\\n            maxfilesize:\\n\\n                - 1 - 32767\\n                - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Log allowed connections and set that in local group policy\\n        salt * firewall.set_logging_settings domain allowedconnections enable lgpo\\n\\n        # Don't log dropped connections\\n        salt * firewall.set_logging_settings profile=private setting=droppedconnections value=disable\\n\\n        # Set the location of the log file\\n        salt * firewall.set_logging_settings domain filename C:\\\\windows\\\\logs\\\\firewall.log\\n\\n        # You can also use environment variables\\n        salt * firewall.set_logging_settings domain filename %systemroot%\\\\system32\\\\LogFiles\\\\Firewall\\\\pfirewall.log\\n\\n        # Set the max file size of the log to 2048 Kb\\n        salt * firewall.set_logging_settings domain maxfilesize 2048\\n    \"\n    return salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=setting, value=value, store=store)",
            "def set_logging_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Configure logging settings for the Windows firewall.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The logging setting to configure. Valid options are:\\n\\n            - allowedconnections\\n            - droppedconnections\\n            - filename\\n            - maxfilesize\\n\\n        value (str):\\n            The value to apply to the setting. Valid values are dependent upon\\n            the setting being configured. Valid options are:\\n\\n            allowedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            droppedconnections:\\n\\n                - enable\\n                - disable\\n                - notconfigured\\n\\n            filename:\\n\\n                - Full path and name of the firewall log file\\n                - notconfigured\\n\\n            maxfilesize:\\n\\n                - 1 - 32767\\n                - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Log allowed connections and set that in local group policy\\n        salt * firewall.set_logging_settings domain allowedconnections enable lgpo\\n\\n        # Don't log dropped connections\\n        salt * firewall.set_logging_settings profile=private setting=droppedconnections value=disable\\n\\n        # Set the location of the log file\\n        salt * firewall.set_logging_settings domain filename C:\\\\windows\\\\logs\\\\firewall.log\\n\\n        # You can also use environment variables\\n        salt * firewall.set_logging_settings domain filename %systemroot%\\\\system32\\\\LogFiles\\\\Firewall\\\\pfirewall.log\\n\\n        # Set the max file size of the log to 2048 Kb\\n        salt * firewall.set_logging_settings domain maxfilesize 2048\\n    \"\n    return salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=setting, value=value, store=store)"
        ]
    },
    {
        "func_name": "set_settings",
        "original": "def set_settings(profile, setting, value, store='local'):\n    \"\"\"\n    Configure firewall settings.\n\n    .. versionadded:: 2018.3.4\n    .. versionadded:: 2019.2.0\n\n    Args:\n\n        profile (str):\n            The firewall profile to configure. Valid options are:\n\n            - domain\n            - public\n            - private\n\n        setting (str):\n            The firewall setting to configure. Valid options are:\n\n            - localfirewallrules\n            - localconsecrules\n            - inboundusernotification\n            - remotemanagement\n            - unicastresponsetomulticast\n\n        value (str):\n            The value to apply to the setting. Valid options are\n\n            - enable\n            - disable\n            - notconfigured\n\n            .. note::\n                ``notconfigured`` can only be used when using the lgpo store\n\n        store (str):\n            The store to use. This is either the local firewall policy or the\n            policy defined by local group policy. Valid options are:\n\n            - lgpo\n            - local\n\n            Default is ``local``\n\n    Returns:\n        bool: ``True`` if successful\n\n    Raises:\n        CommandExecutionError: If an error occurs\n        ValueError: If the parameters are incorrect\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Merge local rules with those distributed through group policy\n        salt * firewall.set_settings domain localfirewallrules enable\n\n        # Allow remote management of Windows Firewall\n        salt * firewall.set_settings domain remotemanagement enable\n    \"\"\"\n    return salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=setting, value=value, store=store)",
        "mutated": [
            "def set_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n    '\\n    Configure firewall settings.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The firewall setting to configure. Valid options are:\\n\\n            - localfirewallrules\\n            - localconsecrules\\n            - inboundusernotification\\n            - remotemanagement\\n            - unicastresponsetomulticast\\n\\n        value (str):\\n            The value to apply to the setting. Valid options are\\n\\n            - enable\\n            - disable\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Merge local rules with those distributed through group policy\\n        salt * firewall.set_settings domain localfirewallrules enable\\n\\n        # Allow remote management of Windows Firewall\\n        salt * firewall.set_settings domain remotemanagement enable\\n    '\n    return salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=setting, value=value, store=store)",
            "def set_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Configure firewall settings.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The firewall setting to configure. Valid options are:\\n\\n            - localfirewallrules\\n            - localconsecrules\\n            - inboundusernotification\\n            - remotemanagement\\n            - unicastresponsetomulticast\\n\\n        value (str):\\n            The value to apply to the setting. Valid options are\\n\\n            - enable\\n            - disable\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Merge local rules with those distributed through group policy\\n        salt * firewall.set_settings domain localfirewallrules enable\\n\\n        # Allow remote management of Windows Firewall\\n        salt * firewall.set_settings domain remotemanagement enable\\n    '\n    return salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=setting, value=value, store=store)",
            "def set_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Configure firewall settings.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The firewall setting to configure. Valid options are:\\n\\n            - localfirewallrules\\n            - localconsecrules\\n            - inboundusernotification\\n            - remotemanagement\\n            - unicastresponsetomulticast\\n\\n        value (str):\\n            The value to apply to the setting. Valid options are\\n\\n            - enable\\n            - disable\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Merge local rules with those distributed through group policy\\n        salt * firewall.set_settings domain localfirewallrules enable\\n\\n        # Allow remote management of Windows Firewall\\n        salt * firewall.set_settings domain remotemanagement enable\\n    '\n    return salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=setting, value=value, store=store)",
            "def set_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Configure firewall settings.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The firewall setting to configure. Valid options are:\\n\\n            - localfirewallrules\\n            - localconsecrules\\n            - inboundusernotification\\n            - remotemanagement\\n            - unicastresponsetomulticast\\n\\n        value (str):\\n            The value to apply to the setting. Valid options are\\n\\n            - enable\\n            - disable\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Merge local rules with those distributed through group policy\\n        salt * firewall.set_settings domain localfirewallrules enable\\n\\n        # Allow remote management of Windows Firewall\\n        salt * firewall.set_settings domain remotemanagement enable\\n    '\n    return salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=setting, value=value, store=store)",
            "def set_settings(profile, setting, value, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Configure firewall settings.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        setting (str):\\n            The firewall setting to configure. Valid options are:\\n\\n            - localfirewallrules\\n            - localconsecrules\\n            - inboundusernotification\\n            - remotemanagement\\n            - unicastresponsetomulticast\\n\\n        value (str):\\n            The value to apply to the setting. Valid options are\\n\\n            - enable\\n            - disable\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Merge local rules with those distributed through group policy\\n        salt * firewall.set_settings domain localfirewallrules enable\\n\\n        # Allow remote management of Windows Firewall\\n        salt * firewall.set_settings domain remotemanagement enable\\n    '\n    return salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=setting, value=value, store=store)"
        ]
    },
    {
        "func_name": "set_state",
        "original": "def set_state(profile, state, store='local'):\n    \"\"\"\n    Configure the firewall state.\n\n    .. versionadded:: 2018.3.4\n    .. versionadded:: 2019.2.0\n\n    Args:\n\n        profile (str):\n            The firewall profile to configure. Valid options are:\n\n            - domain\n            - public\n            - private\n\n        state (str):\n            The firewall state. Valid options are:\n\n            - on\n            - off\n            - notconfigured\n\n            .. note::\n                ``notconfigured`` can only be used when using the lgpo store\n\n        store (str):\n            The store to use. This is either the local firewall policy or the\n            policy defined by local group policy. Valid options are:\n\n            - lgpo\n            - local\n\n            Default is ``local``\n\n    Returns:\n        bool: ``True`` if successful\n\n    Raises:\n        CommandExecutionError: If an error occurs\n        ValueError: If the parameters are incorrect\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Turn the firewall off when the domain profile is active\n        salt * firewall.set_state domain off\n\n        # Turn the firewall on when the public profile is active and set that in\n        # the local group policy\n        salt * firewall.set_state public on lgpo\n    \"\"\"\n    return salt.utils.win_lgpo_netsh.set_state(profile=profile, state=state, store=store)",
        "mutated": [
            "def set_state(profile, state, store='local'):\n    if False:\n        i = 10\n    '\\n    Configure the firewall state.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        state (str):\\n            The firewall state. Valid options are:\\n\\n            - on\\n            - off\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Turn the firewall off when the domain profile is active\\n        salt * firewall.set_state domain off\\n\\n        # Turn the firewall on when the public profile is active and set that in\\n        # the local group policy\\n        salt * firewall.set_state public on lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.set_state(profile=profile, state=state, store=store)",
            "def set_state(profile, state, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Configure the firewall state.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        state (str):\\n            The firewall state. Valid options are:\\n\\n            - on\\n            - off\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Turn the firewall off when the domain profile is active\\n        salt * firewall.set_state domain off\\n\\n        # Turn the firewall on when the public profile is active and set that in\\n        # the local group policy\\n        salt * firewall.set_state public on lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.set_state(profile=profile, state=state, store=store)",
            "def set_state(profile, state, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Configure the firewall state.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        state (str):\\n            The firewall state. Valid options are:\\n\\n            - on\\n            - off\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Turn the firewall off when the domain profile is active\\n        salt * firewall.set_state domain off\\n\\n        # Turn the firewall on when the public profile is active and set that in\\n        # the local group policy\\n        salt * firewall.set_state public on lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.set_state(profile=profile, state=state, store=store)",
            "def set_state(profile, state, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Configure the firewall state.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        state (str):\\n            The firewall state. Valid options are:\\n\\n            - on\\n            - off\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Turn the firewall off when the domain profile is active\\n        salt * firewall.set_state domain off\\n\\n        # Turn the firewall on when the public profile is active and set that in\\n        # the local group policy\\n        salt * firewall.set_state public on lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.set_state(profile=profile, state=state, store=store)",
            "def set_state(profile, state, store='local'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Configure the firewall state.\\n\\n    .. versionadded:: 2018.3.4\\n    .. versionadded:: 2019.2.0\\n\\n    Args:\\n\\n        profile (str):\\n            The firewall profile to configure. Valid options are:\\n\\n            - domain\\n            - public\\n            - private\\n\\n        state (str):\\n            The firewall state. Valid options are:\\n\\n            - on\\n            - off\\n            - notconfigured\\n\\n            .. note::\\n                ``notconfigured`` can only be used when using the lgpo store\\n\\n        store (str):\\n            The store to use. This is either the local firewall policy or the\\n            policy defined by local group policy. Valid options are:\\n\\n            - lgpo\\n            - local\\n\\n            Default is ``local``\\n\\n    Returns:\\n        bool: ``True`` if successful\\n\\n    Raises:\\n        CommandExecutionError: If an error occurs\\n        ValueError: If the parameters are incorrect\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Turn the firewall off when the domain profile is active\\n        salt * firewall.set_state domain off\\n\\n        # Turn the firewall on when the public profile is active and set that in\\n        # the local group policy\\n        salt * firewall.set_state public on lgpo\\n    '\n    return salt.utils.win_lgpo_netsh.set_state(profile=profile, state=state, store=store)"
        ]
    }
]