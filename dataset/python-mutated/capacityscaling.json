[
    {
        "func_name": "_detect_unboundedness",
        "original": "def _detect_unboundedness(R):\n    \"\"\"Detect infinite-capacity negative cycles.\"\"\"\n    G = nx.DiGraph()\n    G.add_nodes_from(R)\n    inf = R.graph['inf']\n    f_inf = float('inf')\n    for u in R:\n        for (v, e) in R[u].items():\n            w = f_inf\n            for (k, e) in e.items():\n                if e['capacity'] == inf:\n                    w = min(w, e['weight'])\n            if w != f_inf:\n                G.add_edge(u, v, weight=w)\n    if nx.negative_edge_cycle(G):\n        raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')",
        "mutated": [
            "def _detect_unboundedness(R):\n    if False:\n        i = 10\n    'Detect infinite-capacity negative cycles.'\n    G = nx.DiGraph()\n    G.add_nodes_from(R)\n    inf = R.graph['inf']\n    f_inf = float('inf')\n    for u in R:\n        for (v, e) in R[u].items():\n            w = f_inf\n            for (k, e) in e.items():\n                if e['capacity'] == inf:\n                    w = min(w, e['weight'])\n            if w != f_inf:\n                G.add_edge(u, v, weight=w)\n    if nx.negative_edge_cycle(G):\n        raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')",
            "def _detect_unboundedness(R):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Detect infinite-capacity negative cycles.'\n    G = nx.DiGraph()\n    G.add_nodes_from(R)\n    inf = R.graph['inf']\n    f_inf = float('inf')\n    for u in R:\n        for (v, e) in R[u].items():\n            w = f_inf\n            for (k, e) in e.items():\n                if e['capacity'] == inf:\n                    w = min(w, e['weight'])\n            if w != f_inf:\n                G.add_edge(u, v, weight=w)\n    if nx.negative_edge_cycle(G):\n        raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')",
            "def _detect_unboundedness(R):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Detect infinite-capacity negative cycles.'\n    G = nx.DiGraph()\n    G.add_nodes_from(R)\n    inf = R.graph['inf']\n    f_inf = float('inf')\n    for u in R:\n        for (v, e) in R[u].items():\n            w = f_inf\n            for (k, e) in e.items():\n                if e['capacity'] == inf:\n                    w = min(w, e['weight'])\n            if w != f_inf:\n                G.add_edge(u, v, weight=w)\n    if nx.negative_edge_cycle(G):\n        raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')",
            "def _detect_unboundedness(R):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Detect infinite-capacity negative cycles.'\n    G = nx.DiGraph()\n    G.add_nodes_from(R)\n    inf = R.graph['inf']\n    f_inf = float('inf')\n    for u in R:\n        for (v, e) in R[u].items():\n            w = f_inf\n            for (k, e) in e.items():\n                if e['capacity'] == inf:\n                    w = min(w, e['weight'])\n            if w != f_inf:\n                G.add_edge(u, v, weight=w)\n    if nx.negative_edge_cycle(G):\n        raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')",
            "def _detect_unboundedness(R):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Detect infinite-capacity negative cycles.'\n    G = nx.DiGraph()\n    G.add_nodes_from(R)\n    inf = R.graph['inf']\n    f_inf = float('inf')\n    for u in R:\n        for (v, e) in R[u].items():\n            w = f_inf\n            for (k, e) in e.items():\n                if e['capacity'] == inf:\n                    w = min(w, e['weight'])\n            if w != f_inf:\n                G.add_edge(u, v, weight=w)\n    if nx.negative_edge_cycle(G):\n        raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')"
        ]
    },
    {
        "func_name": "_build_residual_network",
        "original": "@not_implemented_for('undirected')\ndef _build_residual_network(G, demand, capacity, weight):\n    \"\"\"Build a residual network and initialize a zero flow.\"\"\"\n    if sum((G.nodes[u].get(demand, 0) for u in G)) != 0:\n        raise nx.NetworkXUnfeasible('Sum of the demands should be 0.')\n    R = nx.MultiDiGraph()\n    R.add_nodes_from(((u, {'excess': -G.nodes[u].get(demand, 0), 'potential': 0}) for u in G))\n    inf = float('inf')\n    for (u, v, e) in nx.selfloop_edges(G, data=True):\n        if e.get(weight, 0) < 0 and e.get(capacity, inf) == inf:\n            raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')\n    if G.is_multigraph():\n        edge_list = [(u, v, k, e) for (u, v, k, e) in G.edges(data=True, keys=True) if u != v and e.get(capacity, inf) > 0]\n    else:\n        edge_list = [(u, v, 0, e) for (u, v, e) in G.edges(data=True) if u != v and e.get(capacity, inf) > 0]\n    inf = max(sum((abs(R.nodes[u]['excess']) for u in R)), 2 * sum((e[capacity] for (u, v, k, e) in edge_list if capacity in e and e[capacity] != inf))) or 1\n    for (u, v, k, e) in edge_list:\n        r = min(e.get(capacity, inf), inf)\n        w = e.get(weight, 0)\n        R.add_edge(u, v, key=(k, True), capacity=r, weight=w, flow=0)\n        R.add_edge(v, u, key=(k, False), capacity=0, weight=-w, flow=0)\n    R.graph['inf'] = inf\n    _detect_unboundedness(R)\n    return R",
        "mutated": [
            "@not_implemented_for('undirected')\ndef _build_residual_network(G, demand, capacity, weight):\n    if False:\n        i = 10\n    'Build a residual network and initialize a zero flow.'\n    if sum((G.nodes[u].get(demand, 0) for u in G)) != 0:\n        raise nx.NetworkXUnfeasible('Sum of the demands should be 0.')\n    R = nx.MultiDiGraph()\n    R.add_nodes_from(((u, {'excess': -G.nodes[u].get(demand, 0), 'potential': 0}) for u in G))\n    inf = float('inf')\n    for (u, v, e) in nx.selfloop_edges(G, data=True):\n        if e.get(weight, 0) < 0 and e.get(capacity, inf) == inf:\n            raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')\n    if G.is_multigraph():\n        edge_list = [(u, v, k, e) for (u, v, k, e) in G.edges(data=True, keys=True) if u != v and e.get(capacity, inf) > 0]\n    else:\n        edge_list = [(u, v, 0, e) for (u, v, e) in G.edges(data=True) if u != v and e.get(capacity, inf) > 0]\n    inf = max(sum((abs(R.nodes[u]['excess']) for u in R)), 2 * sum((e[capacity] for (u, v, k, e) in edge_list if capacity in e and e[capacity] != inf))) or 1\n    for (u, v, k, e) in edge_list:\n        r = min(e.get(capacity, inf), inf)\n        w = e.get(weight, 0)\n        R.add_edge(u, v, key=(k, True), capacity=r, weight=w, flow=0)\n        R.add_edge(v, u, key=(k, False), capacity=0, weight=-w, flow=0)\n    R.graph['inf'] = inf\n    _detect_unboundedness(R)\n    return R",
            "@not_implemented_for('undirected')\ndef _build_residual_network(G, demand, capacity, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Build a residual network and initialize a zero flow.'\n    if sum((G.nodes[u].get(demand, 0) for u in G)) != 0:\n        raise nx.NetworkXUnfeasible('Sum of the demands should be 0.')\n    R = nx.MultiDiGraph()\n    R.add_nodes_from(((u, {'excess': -G.nodes[u].get(demand, 0), 'potential': 0}) for u in G))\n    inf = float('inf')\n    for (u, v, e) in nx.selfloop_edges(G, data=True):\n        if e.get(weight, 0) < 0 and e.get(capacity, inf) == inf:\n            raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')\n    if G.is_multigraph():\n        edge_list = [(u, v, k, e) for (u, v, k, e) in G.edges(data=True, keys=True) if u != v and e.get(capacity, inf) > 0]\n    else:\n        edge_list = [(u, v, 0, e) for (u, v, e) in G.edges(data=True) if u != v and e.get(capacity, inf) > 0]\n    inf = max(sum((abs(R.nodes[u]['excess']) for u in R)), 2 * sum((e[capacity] for (u, v, k, e) in edge_list if capacity in e and e[capacity] != inf))) or 1\n    for (u, v, k, e) in edge_list:\n        r = min(e.get(capacity, inf), inf)\n        w = e.get(weight, 0)\n        R.add_edge(u, v, key=(k, True), capacity=r, weight=w, flow=0)\n        R.add_edge(v, u, key=(k, False), capacity=0, weight=-w, flow=0)\n    R.graph['inf'] = inf\n    _detect_unboundedness(R)\n    return R",
            "@not_implemented_for('undirected')\ndef _build_residual_network(G, demand, capacity, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Build a residual network and initialize a zero flow.'\n    if sum((G.nodes[u].get(demand, 0) for u in G)) != 0:\n        raise nx.NetworkXUnfeasible('Sum of the demands should be 0.')\n    R = nx.MultiDiGraph()\n    R.add_nodes_from(((u, {'excess': -G.nodes[u].get(demand, 0), 'potential': 0}) for u in G))\n    inf = float('inf')\n    for (u, v, e) in nx.selfloop_edges(G, data=True):\n        if e.get(weight, 0) < 0 and e.get(capacity, inf) == inf:\n            raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')\n    if G.is_multigraph():\n        edge_list = [(u, v, k, e) for (u, v, k, e) in G.edges(data=True, keys=True) if u != v and e.get(capacity, inf) > 0]\n    else:\n        edge_list = [(u, v, 0, e) for (u, v, e) in G.edges(data=True) if u != v and e.get(capacity, inf) > 0]\n    inf = max(sum((abs(R.nodes[u]['excess']) for u in R)), 2 * sum((e[capacity] for (u, v, k, e) in edge_list if capacity in e and e[capacity] != inf))) or 1\n    for (u, v, k, e) in edge_list:\n        r = min(e.get(capacity, inf), inf)\n        w = e.get(weight, 0)\n        R.add_edge(u, v, key=(k, True), capacity=r, weight=w, flow=0)\n        R.add_edge(v, u, key=(k, False), capacity=0, weight=-w, flow=0)\n    R.graph['inf'] = inf\n    _detect_unboundedness(R)\n    return R",
            "@not_implemented_for('undirected')\ndef _build_residual_network(G, demand, capacity, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Build a residual network and initialize a zero flow.'\n    if sum((G.nodes[u].get(demand, 0) for u in G)) != 0:\n        raise nx.NetworkXUnfeasible('Sum of the demands should be 0.')\n    R = nx.MultiDiGraph()\n    R.add_nodes_from(((u, {'excess': -G.nodes[u].get(demand, 0), 'potential': 0}) for u in G))\n    inf = float('inf')\n    for (u, v, e) in nx.selfloop_edges(G, data=True):\n        if e.get(weight, 0) < 0 and e.get(capacity, inf) == inf:\n            raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')\n    if G.is_multigraph():\n        edge_list = [(u, v, k, e) for (u, v, k, e) in G.edges(data=True, keys=True) if u != v and e.get(capacity, inf) > 0]\n    else:\n        edge_list = [(u, v, 0, e) for (u, v, e) in G.edges(data=True) if u != v and e.get(capacity, inf) > 0]\n    inf = max(sum((abs(R.nodes[u]['excess']) for u in R)), 2 * sum((e[capacity] for (u, v, k, e) in edge_list if capacity in e and e[capacity] != inf))) or 1\n    for (u, v, k, e) in edge_list:\n        r = min(e.get(capacity, inf), inf)\n        w = e.get(weight, 0)\n        R.add_edge(u, v, key=(k, True), capacity=r, weight=w, flow=0)\n        R.add_edge(v, u, key=(k, False), capacity=0, weight=-w, flow=0)\n    R.graph['inf'] = inf\n    _detect_unboundedness(R)\n    return R",
            "@not_implemented_for('undirected')\ndef _build_residual_network(G, demand, capacity, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Build a residual network and initialize a zero flow.'\n    if sum((G.nodes[u].get(demand, 0) for u in G)) != 0:\n        raise nx.NetworkXUnfeasible('Sum of the demands should be 0.')\n    R = nx.MultiDiGraph()\n    R.add_nodes_from(((u, {'excess': -G.nodes[u].get(demand, 0), 'potential': 0}) for u in G))\n    inf = float('inf')\n    for (u, v, e) in nx.selfloop_edges(G, data=True):\n        if e.get(weight, 0) < 0 and e.get(capacity, inf) == inf:\n            raise nx.NetworkXUnbounded('Negative cost cycle of infinite capacity found. Min cost flow may be unbounded below.')\n    if G.is_multigraph():\n        edge_list = [(u, v, k, e) for (u, v, k, e) in G.edges(data=True, keys=True) if u != v and e.get(capacity, inf) > 0]\n    else:\n        edge_list = [(u, v, 0, e) for (u, v, e) in G.edges(data=True) if u != v and e.get(capacity, inf) > 0]\n    inf = max(sum((abs(R.nodes[u]['excess']) for u in R)), 2 * sum((e[capacity] for (u, v, k, e) in edge_list if capacity in e and e[capacity] != inf))) or 1\n    for (u, v, k, e) in edge_list:\n        r = min(e.get(capacity, inf), inf)\n        w = e.get(weight, 0)\n        R.add_edge(u, v, key=(k, True), capacity=r, weight=w, flow=0)\n        R.add_edge(v, u, key=(k, False), capacity=0, weight=-w, flow=0)\n    R.graph['inf'] = inf\n    _detect_unboundedness(R)\n    return R"
        ]
    },
    {
        "func_name": "_build_flow_dict",
        "original": "def _build_flow_dict(G, R, capacity, weight):\n    \"\"\"Build a flow dictionary from a residual network.\"\"\"\n    inf = float('inf')\n    flow_dict = {}\n    if G.is_multigraph():\n        for u in G:\n            flow_dict[u] = {}\n            for (v, es) in G[u].items():\n                flow_dict[u][v] = {k: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (k, e) in es.items()}\n            for (v, es) in R[u].items():\n                if v in flow_dict[u]:\n                    flow_dict[u][v].update(((k[0], e['flow']) for (k, e) in es.items() if e['flow'] > 0))\n    else:\n        for u in G:\n            flow_dict[u] = {v: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (v, e) in G[u].items()}\n            flow_dict[u].update(((v, e['flow']) for (v, es) in R[u].items() for e in es.values() if e['flow'] > 0))\n    return flow_dict",
        "mutated": [
            "def _build_flow_dict(G, R, capacity, weight):\n    if False:\n        i = 10\n    'Build a flow dictionary from a residual network.'\n    inf = float('inf')\n    flow_dict = {}\n    if G.is_multigraph():\n        for u in G:\n            flow_dict[u] = {}\n            for (v, es) in G[u].items():\n                flow_dict[u][v] = {k: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (k, e) in es.items()}\n            for (v, es) in R[u].items():\n                if v in flow_dict[u]:\n                    flow_dict[u][v].update(((k[0], e['flow']) for (k, e) in es.items() if e['flow'] > 0))\n    else:\n        for u in G:\n            flow_dict[u] = {v: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (v, e) in G[u].items()}\n            flow_dict[u].update(((v, e['flow']) for (v, es) in R[u].items() for e in es.values() if e['flow'] > 0))\n    return flow_dict",
            "def _build_flow_dict(G, R, capacity, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Build a flow dictionary from a residual network.'\n    inf = float('inf')\n    flow_dict = {}\n    if G.is_multigraph():\n        for u in G:\n            flow_dict[u] = {}\n            for (v, es) in G[u].items():\n                flow_dict[u][v] = {k: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (k, e) in es.items()}\n            for (v, es) in R[u].items():\n                if v in flow_dict[u]:\n                    flow_dict[u][v].update(((k[0], e['flow']) for (k, e) in es.items() if e['flow'] > 0))\n    else:\n        for u in G:\n            flow_dict[u] = {v: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (v, e) in G[u].items()}\n            flow_dict[u].update(((v, e['flow']) for (v, es) in R[u].items() for e in es.values() if e['flow'] > 0))\n    return flow_dict",
            "def _build_flow_dict(G, R, capacity, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Build a flow dictionary from a residual network.'\n    inf = float('inf')\n    flow_dict = {}\n    if G.is_multigraph():\n        for u in G:\n            flow_dict[u] = {}\n            for (v, es) in G[u].items():\n                flow_dict[u][v] = {k: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (k, e) in es.items()}\n            for (v, es) in R[u].items():\n                if v in flow_dict[u]:\n                    flow_dict[u][v].update(((k[0], e['flow']) for (k, e) in es.items() if e['flow'] > 0))\n    else:\n        for u in G:\n            flow_dict[u] = {v: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (v, e) in G[u].items()}\n            flow_dict[u].update(((v, e['flow']) for (v, es) in R[u].items() for e in es.values() if e['flow'] > 0))\n    return flow_dict",
            "def _build_flow_dict(G, R, capacity, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Build a flow dictionary from a residual network.'\n    inf = float('inf')\n    flow_dict = {}\n    if G.is_multigraph():\n        for u in G:\n            flow_dict[u] = {}\n            for (v, es) in G[u].items():\n                flow_dict[u][v] = {k: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (k, e) in es.items()}\n            for (v, es) in R[u].items():\n                if v in flow_dict[u]:\n                    flow_dict[u][v].update(((k[0], e['flow']) for (k, e) in es.items() if e['flow'] > 0))\n    else:\n        for u in G:\n            flow_dict[u] = {v: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (v, e) in G[u].items()}\n            flow_dict[u].update(((v, e['flow']) for (v, es) in R[u].items() for e in es.values() if e['flow'] > 0))\n    return flow_dict",
            "def _build_flow_dict(G, R, capacity, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Build a flow dictionary from a residual network.'\n    inf = float('inf')\n    flow_dict = {}\n    if G.is_multigraph():\n        for u in G:\n            flow_dict[u] = {}\n            for (v, es) in G[u].items():\n                flow_dict[u][v] = {k: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (k, e) in es.items()}\n            for (v, es) in R[u].items():\n                if v in flow_dict[u]:\n                    flow_dict[u][v].update(((k[0], e['flow']) for (k, e) in es.items() if e['flow'] > 0))\n    else:\n        for u in G:\n            flow_dict[u] = {v: 0 if u != v or e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] for (v, e) in G[u].items()}\n            flow_dict[u].update(((v, e['flow']) for (v, es) in R[u].items() for e in es.values() if e['flow'] > 0))\n    return flow_dict"
        ]
    },
    {
        "func_name": "capacity_scaling",
        "original": "@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef capacity_scaling(G, demand='demand', capacity='capacity', weight='weight', heap=BinaryHeap):\n    \"\"\"Find a minimum cost flow satisfying all demands in digraph G.\n\n    This is a capacity scaling successive shortest augmenting path algorithm.\n\n    G is a digraph with edge costs and capacities and in which nodes\n    have demand, i.e., they want to send or receive some amount of\n    flow. A negative demand means that the node wants to send flow, a\n    positive demand means that the node want to receive flow. A flow on\n    the digraph G satisfies all demand if the net flow into each node\n    is equal to the demand of that node.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\n        demands is to be found.\n\n    demand : string\n        Nodes of the graph G are expected to have an attribute demand\n        that indicates how much flow a node wants to send (negative\n        demand) or receive (positive demand). Note that the sum of the\n        demands should be 0 otherwise the problem in not feasible. If\n        this attribute is not present, a node is considered to have 0\n        demand. Default value: 'demand'.\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    weight : string\n        Edges of the graph G are expected to have an attribute weight\n        that indicates the cost incurred by sending one unit of flow on\n        that edge. If not present, the weight is considered to be 0.\n        Default value: 'weight'.\n\n    heap : class\n        Type of heap to be used in the algorithm. It should be a subclass of\n        :class:`MinHeap` or implement a compatible interface.\n\n        If a stock heap implementation is to be used, :class:`BinaryHeap` is\n        recommended over :class:`PairingHeap` for Python implementations without\n        optimized attribute accesses (e.g., CPython) despite a slower\n        asymptotic running time. For Python implementations with optimized\n        attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\n        performance. Default value: :class:`BinaryHeap`.\n\n    Returns\n    -------\n    flowCost : integer\n        Cost of a minimum cost flow satisfying all demands.\n\n    flowDict : dictionary\n        If G is a digraph, a dict-of-dicts keyed by nodes such that\n        flowDict[u][v] is the flow on edge (u, v).\n        If G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\n        so that flowDict[u][v][key] is the flow on edge (u, v, key).\n\n    Raises\n    ------\n    NetworkXError\n        This exception is raised if the input graph is not directed,\n        not connected.\n\n    NetworkXUnfeasible\n        This exception is raised in the following situations:\n\n            * The sum of the demands is not zero. Then, there is no\n              flow satisfying all demands.\n            * There is no flow satisfying all demand.\n\n    NetworkXUnbounded\n        This exception is raised if the digraph G has a cycle of\n        negative cost and infinite capacity. Then, the cost of a flow\n        satisfying all demands is unbounded below.\n\n    Notes\n    -----\n    This algorithm does not work if edge weights are floating-point numbers.\n\n    See also\n    --------\n    :meth:`network_simplex`\n\n    Examples\n    --------\n    A simple example of a min cost flow problem.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_node(\"a\", demand=-5)\n    >>> G.add_node(\"d\", demand=5)\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n    >>> flowCost, flowDict = nx.capacity_scaling(G)\n    >>> flowCost\n    24\n    >>> flowDict\n    {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\n\n    It is possible to change the name of the attributes used for the\n    algorithm.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_node(\"p\", spam=-4)\n    >>> G.add_node(\"q\", spam=2)\n    >>> G.add_node(\"a\", spam=-2)\n    >>> G.add_node(\"d\", spam=-1)\n    >>> G.add_node(\"t\", spam=2)\n    >>> G.add_node(\"w\", spam=3)\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\n    >>> flowCost, flowDict = nx.capacity_scaling(\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\n    ... )\n    >>> flowCost\n    37\n    >>> flowDict\n    {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}\n    \"\"\"\n    R = _build_residual_network(G, demand, capacity, weight)\n    inf = float('inf')\n    flow_cost = sum((0 if e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] * e[weight] for (u, v, e) in nx.selfloop_edges(G, data=True)))\n    wmax = max(chain([-inf], (e['capacity'] for (u, v, e) in R.edges(data=True))))\n    if wmax == -inf:\n        return (flow_cost, _build_flow_dict(G, R, capacity, weight))\n    R_nodes = R.nodes\n    R_succ = R.succ\n    delta = 2 ** int(log(wmax, 2))\n    while delta >= 1:\n        for u in R:\n            p_u = R_nodes[u]['potential']\n            for (v, es) in R_succ[u].items():\n                for (k, e) in es.items():\n                    flow = e['capacity'] - e['flow']\n                    if e['weight'] - p_u + R_nodes[v]['potential'] < 0:\n                        flow = e['capacity'] - e['flow']\n                        if flow >= delta:\n                            e['flow'] += flow\n                            R_succ[v][u][k[0], not k[1]]['flow'] -= flow\n                            R_nodes[u]['excess'] -= flow\n                            R_nodes[v]['excess'] += flow\n        S = set()\n        T = set()\n        S_add = S.add\n        S_remove = S.remove\n        T_add = T.add\n        T_remove = T.remove\n        for u in R:\n            excess = R_nodes[u]['excess']\n            if excess >= delta:\n                S_add(u)\n            elif excess <= -delta:\n                T_add(u)\n        while S and T:\n            s = arbitrary_element(S)\n            t = None\n            d = {}\n            pred = {s: None}\n            h = heap()\n            h_insert = h.insert\n            h_get = h.get\n            h_insert(s, 0)\n            while h:\n                (u, d_u) = h.pop()\n                d[u] = d_u\n                if u in T:\n                    t = u\n                    break\n                p_u = R_nodes[u]['potential']\n                for (v, es) in R_succ[u].items():\n                    if v in d:\n                        continue\n                    wmin = inf\n                    for (k, e) in es.items():\n                        if e['capacity'] - e['flow'] >= delta:\n                            w = e['weight']\n                            if w < wmin:\n                                wmin = w\n                                kmin = k\n                                emin = e\n                    if wmin == inf:\n                        continue\n                    d_v = d_u + wmin - p_u + R_nodes[v]['potential']\n                    if h_insert(v, d_v):\n                        pred[v] = (u, kmin, emin)\n            if t is not None:\n                while u != s:\n                    v = u\n                    (u, k, e) = pred[v]\n                    e['flow'] += delta\n                    R_succ[v][u][k[0], not k[1]]['flow'] -= delta\n                R_nodes[s]['excess'] -= delta\n                R_nodes[t]['excess'] += delta\n                if R_nodes[s]['excess'] < delta:\n                    S_remove(s)\n                if R_nodes[t]['excess'] > -delta:\n                    T_remove(t)\n                d_t = d[t]\n                for (u, d_u) in d.items():\n                    R_nodes[u]['potential'] -= d_u - d_t\n            else:\n                S_remove(s)\n        delta //= 2\n    if any((R.nodes[u]['excess'] != 0 for u in R)):\n        raise nx.NetworkXUnfeasible('No flow satisfying all demands.')\n    for u in R:\n        for (v, es) in R_succ[u].items():\n            for e in es.values():\n                flow = e['flow']\n                if flow > 0:\n                    flow_cost += flow * e['weight']\n    return (flow_cost, _build_flow_dict(G, R, capacity, weight))",
        "mutated": [
            "@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef capacity_scaling(G, demand='demand', capacity='capacity', weight='weight', heap=BinaryHeap):\n    if False:\n        i = 10\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a capacity scaling successive shortest augmenting path algorithm.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\\n        demands is to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    heap : class\\n        Type of heap to be used in the algorithm. It should be a subclass of\\n        :class:`MinHeap` or implement a compatible interface.\\n\\n        If a stock heap implementation is to be used, :class:`BinaryHeap` is\\n        recommended over :class:`PairingHeap` for Python implementations without\\n        optimized attribute accesses (e.g., CPython) despite a slower\\n        asymptotic running time. For Python implementations with optimized\\n        attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\\n        performance. Default value: :class:`BinaryHeap`.\\n\\n    Returns\\n    -------\\n    flowCost : integer\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        If G is a digraph, a dict-of-dicts keyed by nodes such that\\n        flowDict[u][v] is the flow on edge (u, v).\\n        If G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\\n        so that flowDict[u][v][key] is the flow on edge (u, v, key).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed,\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm does not work if edge weights are floating-point numbers.\\n\\n    See also\\n    --------\\n    :meth:`network_simplex`\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.capacity_scaling(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.capacity_scaling(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n    '\n    R = _build_residual_network(G, demand, capacity, weight)\n    inf = float('inf')\n    flow_cost = sum((0 if e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] * e[weight] for (u, v, e) in nx.selfloop_edges(G, data=True)))\n    wmax = max(chain([-inf], (e['capacity'] for (u, v, e) in R.edges(data=True))))\n    if wmax == -inf:\n        return (flow_cost, _build_flow_dict(G, R, capacity, weight))\n    R_nodes = R.nodes\n    R_succ = R.succ\n    delta = 2 ** int(log(wmax, 2))\n    while delta >= 1:\n        for u in R:\n            p_u = R_nodes[u]['potential']\n            for (v, es) in R_succ[u].items():\n                for (k, e) in es.items():\n                    flow = e['capacity'] - e['flow']\n                    if e['weight'] - p_u + R_nodes[v]['potential'] < 0:\n                        flow = e['capacity'] - e['flow']\n                        if flow >= delta:\n                            e['flow'] += flow\n                            R_succ[v][u][k[0], not k[1]]['flow'] -= flow\n                            R_nodes[u]['excess'] -= flow\n                            R_nodes[v]['excess'] += flow\n        S = set()\n        T = set()\n        S_add = S.add\n        S_remove = S.remove\n        T_add = T.add\n        T_remove = T.remove\n        for u in R:\n            excess = R_nodes[u]['excess']\n            if excess >= delta:\n                S_add(u)\n            elif excess <= -delta:\n                T_add(u)\n        while S and T:\n            s = arbitrary_element(S)\n            t = None\n            d = {}\n            pred = {s: None}\n            h = heap()\n            h_insert = h.insert\n            h_get = h.get\n            h_insert(s, 0)\n            while h:\n                (u, d_u) = h.pop()\n                d[u] = d_u\n                if u in T:\n                    t = u\n                    break\n                p_u = R_nodes[u]['potential']\n                for (v, es) in R_succ[u].items():\n                    if v in d:\n                        continue\n                    wmin = inf\n                    for (k, e) in es.items():\n                        if e['capacity'] - e['flow'] >= delta:\n                            w = e['weight']\n                            if w < wmin:\n                                wmin = w\n                                kmin = k\n                                emin = e\n                    if wmin == inf:\n                        continue\n                    d_v = d_u + wmin - p_u + R_nodes[v]['potential']\n                    if h_insert(v, d_v):\n                        pred[v] = (u, kmin, emin)\n            if t is not None:\n                while u != s:\n                    v = u\n                    (u, k, e) = pred[v]\n                    e['flow'] += delta\n                    R_succ[v][u][k[0], not k[1]]['flow'] -= delta\n                R_nodes[s]['excess'] -= delta\n                R_nodes[t]['excess'] += delta\n                if R_nodes[s]['excess'] < delta:\n                    S_remove(s)\n                if R_nodes[t]['excess'] > -delta:\n                    T_remove(t)\n                d_t = d[t]\n                for (u, d_u) in d.items():\n                    R_nodes[u]['potential'] -= d_u - d_t\n            else:\n                S_remove(s)\n        delta //= 2\n    if any((R.nodes[u]['excess'] != 0 for u in R)):\n        raise nx.NetworkXUnfeasible('No flow satisfying all demands.')\n    for u in R:\n        for (v, es) in R_succ[u].items():\n            for e in es.values():\n                flow = e['flow']\n                if flow > 0:\n                    flow_cost += flow * e['weight']\n    return (flow_cost, _build_flow_dict(G, R, capacity, weight))",
            "@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef capacity_scaling(G, demand='demand', capacity='capacity', weight='weight', heap=BinaryHeap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a capacity scaling successive shortest augmenting path algorithm.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\\n        demands is to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    heap : class\\n        Type of heap to be used in the algorithm. It should be a subclass of\\n        :class:`MinHeap` or implement a compatible interface.\\n\\n        If a stock heap implementation is to be used, :class:`BinaryHeap` is\\n        recommended over :class:`PairingHeap` for Python implementations without\\n        optimized attribute accesses (e.g., CPython) despite a slower\\n        asymptotic running time. For Python implementations with optimized\\n        attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\\n        performance. Default value: :class:`BinaryHeap`.\\n\\n    Returns\\n    -------\\n    flowCost : integer\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        If G is a digraph, a dict-of-dicts keyed by nodes such that\\n        flowDict[u][v] is the flow on edge (u, v).\\n        If G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\\n        so that flowDict[u][v][key] is the flow on edge (u, v, key).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed,\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm does not work if edge weights are floating-point numbers.\\n\\n    See also\\n    --------\\n    :meth:`network_simplex`\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.capacity_scaling(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.capacity_scaling(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n    '\n    R = _build_residual_network(G, demand, capacity, weight)\n    inf = float('inf')\n    flow_cost = sum((0 if e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] * e[weight] for (u, v, e) in nx.selfloop_edges(G, data=True)))\n    wmax = max(chain([-inf], (e['capacity'] for (u, v, e) in R.edges(data=True))))\n    if wmax == -inf:\n        return (flow_cost, _build_flow_dict(G, R, capacity, weight))\n    R_nodes = R.nodes\n    R_succ = R.succ\n    delta = 2 ** int(log(wmax, 2))\n    while delta >= 1:\n        for u in R:\n            p_u = R_nodes[u]['potential']\n            for (v, es) in R_succ[u].items():\n                for (k, e) in es.items():\n                    flow = e['capacity'] - e['flow']\n                    if e['weight'] - p_u + R_nodes[v]['potential'] < 0:\n                        flow = e['capacity'] - e['flow']\n                        if flow >= delta:\n                            e['flow'] += flow\n                            R_succ[v][u][k[0], not k[1]]['flow'] -= flow\n                            R_nodes[u]['excess'] -= flow\n                            R_nodes[v]['excess'] += flow\n        S = set()\n        T = set()\n        S_add = S.add\n        S_remove = S.remove\n        T_add = T.add\n        T_remove = T.remove\n        for u in R:\n            excess = R_nodes[u]['excess']\n            if excess >= delta:\n                S_add(u)\n            elif excess <= -delta:\n                T_add(u)\n        while S and T:\n            s = arbitrary_element(S)\n            t = None\n            d = {}\n            pred = {s: None}\n            h = heap()\n            h_insert = h.insert\n            h_get = h.get\n            h_insert(s, 0)\n            while h:\n                (u, d_u) = h.pop()\n                d[u] = d_u\n                if u in T:\n                    t = u\n                    break\n                p_u = R_nodes[u]['potential']\n                for (v, es) in R_succ[u].items():\n                    if v in d:\n                        continue\n                    wmin = inf\n                    for (k, e) in es.items():\n                        if e['capacity'] - e['flow'] >= delta:\n                            w = e['weight']\n                            if w < wmin:\n                                wmin = w\n                                kmin = k\n                                emin = e\n                    if wmin == inf:\n                        continue\n                    d_v = d_u + wmin - p_u + R_nodes[v]['potential']\n                    if h_insert(v, d_v):\n                        pred[v] = (u, kmin, emin)\n            if t is not None:\n                while u != s:\n                    v = u\n                    (u, k, e) = pred[v]\n                    e['flow'] += delta\n                    R_succ[v][u][k[0], not k[1]]['flow'] -= delta\n                R_nodes[s]['excess'] -= delta\n                R_nodes[t]['excess'] += delta\n                if R_nodes[s]['excess'] < delta:\n                    S_remove(s)\n                if R_nodes[t]['excess'] > -delta:\n                    T_remove(t)\n                d_t = d[t]\n                for (u, d_u) in d.items():\n                    R_nodes[u]['potential'] -= d_u - d_t\n            else:\n                S_remove(s)\n        delta //= 2\n    if any((R.nodes[u]['excess'] != 0 for u in R)):\n        raise nx.NetworkXUnfeasible('No flow satisfying all demands.')\n    for u in R:\n        for (v, es) in R_succ[u].items():\n            for e in es.values():\n                flow = e['flow']\n                if flow > 0:\n                    flow_cost += flow * e['weight']\n    return (flow_cost, _build_flow_dict(G, R, capacity, weight))",
            "@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef capacity_scaling(G, demand='demand', capacity='capacity', weight='weight', heap=BinaryHeap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a capacity scaling successive shortest augmenting path algorithm.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\\n        demands is to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    heap : class\\n        Type of heap to be used in the algorithm. It should be a subclass of\\n        :class:`MinHeap` or implement a compatible interface.\\n\\n        If a stock heap implementation is to be used, :class:`BinaryHeap` is\\n        recommended over :class:`PairingHeap` for Python implementations without\\n        optimized attribute accesses (e.g., CPython) despite a slower\\n        asymptotic running time. For Python implementations with optimized\\n        attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\\n        performance. Default value: :class:`BinaryHeap`.\\n\\n    Returns\\n    -------\\n    flowCost : integer\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        If G is a digraph, a dict-of-dicts keyed by nodes such that\\n        flowDict[u][v] is the flow on edge (u, v).\\n        If G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\\n        so that flowDict[u][v][key] is the flow on edge (u, v, key).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed,\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm does not work if edge weights are floating-point numbers.\\n\\n    See also\\n    --------\\n    :meth:`network_simplex`\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.capacity_scaling(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.capacity_scaling(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n    '\n    R = _build_residual_network(G, demand, capacity, weight)\n    inf = float('inf')\n    flow_cost = sum((0 if e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] * e[weight] for (u, v, e) in nx.selfloop_edges(G, data=True)))\n    wmax = max(chain([-inf], (e['capacity'] for (u, v, e) in R.edges(data=True))))\n    if wmax == -inf:\n        return (flow_cost, _build_flow_dict(G, R, capacity, weight))\n    R_nodes = R.nodes\n    R_succ = R.succ\n    delta = 2 ** int(log(wmax, 2))\n    while delta >= 1:\n        for u in R:\n            p_u = R_nodes[u]['potential']\n            for (v, es) in R_succ[u].items():\n                for (k, e) in es.items():\n                    flow = e['capacity'] - e['flow']\n                    if e['weight'] - p_u + R_nodes[v]['potential'] < 0:\n                        flow = e['capacity'] - e['flow']\n                        if flow >= delta:\n                            e['flow'] += flow\n                            R_succ[v][u][k[0], not k[1]]['flow'] -= flow\n                            R_nodes[u]['excess'] -= flow\n                            R_nodes[v]['excess'] += flow\n        S = set()\n        T = set()\n        S_add = S.add\n        S_remove = S.remove\n        T_add = T.add\n        T_remove = T.remove\n        for u in R:\n            excess = R_nodes[u]['excess']\n            if excess >= delta:\n                S_add(u)\n            elif excess <= -delta:\n                T_add(u)\n        while S and T:\n            s = arbitrary_element(S)\n            t = None\n            d = {}\n            pred = {s: None}\n            h = heap()\n            h_insert = h.insert\n            h_get = h.get\n            h_insert(s, 0)\n            while h:\n                (u, d_u) = h.pop()\n                d[u] = d_u\n                if u in T:\n                    t = u\n                    break\n                p_u = R_nodes[u]['potential']\n                for (v, es) in R_succ[u].items():\n                    if v in d:\n                        continue\n                    wmin = inf\n                    for (k, e) in es.items():\n                        if e['capacity'] - e['flow'] >= delta:\n                            w = e['weight']\n                            if w < wmin:\n                                wmin = w\n                                kmin = k\n                                emin = e\n                    if wmin == inf:\n                        continue\n                    d_v = d_u + wmin - p_u + R_nodes[v]['potential']\n                    if h_insert(v, d_v):\n                        pred[v] = (u, kmin, emin)\n            if t is not None:\n                while u != s:\n                    v = u\n                    (u, k, e) = pred[v]\n                    e['flow'] += delta\n                    R_succ[v][u][k[0], not k[1]]['flow'] -= delta\n                R_nodes[s]['excess'] -= delta\n                R_nodes[t]['excess'] += delta\n                if R_nodes[s]['excess'] < delta:\n                    S_remove(s)\n                if R_nodes[t]['excess'] > -delta:\n                    T_remove(t)\n                d_t = d[t]\n                for (u, d_u) in d.items():\n                    R_nodes[u]['potential'] -= d_u - d_t\n            else:\n                S_remove(s)\n        delta //= 2\n    if any((R.nodes[u]['excess'] != 0 for u in R)):\n        raise nx.NetworkXUnfeasible('No flow satisfying all demands.')\n    for u in R:\n        for (v, es) in R_succ[u].items():\n            for e in es.values():\n                flow = e['flow']\n                if flow > 0:\n                    flow_cost += flow * e['weight']\n    return (flow_cost, _build_flow_dict(G, R, capacity, weight))",
            "@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef capacity_scaling(G, demand='demand', capacity='capacity', weight='weight', heap=BinaryHeap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a capacity scaling successive shortest augmenting path algorithm.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\\n        demands is to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    heap : class\\n        Type of heap to be used in the algorithm. It should be a subclass of\\n        :class:`MinHeap` or implement a compatible interface.\\n\\n        If a stock heap implementation is to be used, :class:`BinaryHeap` is\\n        recommended over :class:`PairingHeap` for Python implementations without\\n        optimized attribute accesses (e.g., CPython) despite a slower\\n        asymptotic running time. For Python implementations with optimized\\n        attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\\n        performance. Default value: :class:`BinaryHeap`.\\n\\n    Returns\\n    -------\\n    flowCost : integer\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        If G is a digraph, a dict-of-dicts keyed by nodes such that\\n        flowDict[u][v] is the flow on edge (u, v).\\n        If G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\\n        so that flowDict[u][v][key] is the flow on edge (u, v, key).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed,\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm does not work if edge weights are floating-point numbers.\\n\\n    See also\\n    --------\\n    :meth:`network_simplex`\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.capacity_scaling(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.capacity_scaling(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n    '\n    R = _build_residual_network(G, demand, capacity, weight)\n    inf = float('inf')\n    flow_cost = sum((0 if e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] * e[weight] for (u, v, e) in nx.selfloop_edges(G, data=True)))\n    wmax = max(chain([-inf], (e['capacity'] for (u, v, e) in R.edges(data=True))))\n    if wmax == -inf:\n        return (flow_cost, _build_flow_dict(G, R, capacity, weight))\n    R_nodes = R.nodes\n    R_succ = R.succ\n    delta = 2 ** int(log(wmax, 2))\n    while delta >= 1:\n        for u in R:\n            p_u = R_nodes[u]['potential']\n            for (v, es) in R_succ[u].items():\n                for (k, e) in es.items():\n                    flow = e['capacity'] - e['flow']\n                    if e['weight'] - p_u + R_nodes[v]['potential'] < 0:\n                        flow = e['capacity'] - e['flow']\n                        if flow >= delta:\n                            e['flow'] += flow\n                            R_succ[v][u][k[0], not k[1]]['flow'] -= flow\n                            R_nodes[u]['excess'] -= flow\n                            R_nodes[v]['excess'] += flow\n        S = set()\n        T = set()\n        S_add = S.add\n        S_remove = S.remove\n        T_add = T.add\n        T_remove = T.remove\n        for u in R:\n            excess = R_nodes[u]['excess']\n            if excess >= delta:\n                S_add(u)\n            elif excess <= -delta:\n                T_add(u)\n        while S and T:\n            s = arbitrary_element(S)\n            t = None\n            d = {}\n            pred = {s: None}\n            h = heap()\n            h_insert = h.insert\n            h_get = h.get\n            h_insert(s, 0)\n            while h:\n                (u, d_u) = h.pop()\n                d[u] = d_u\n                if u in T:\n                    t = u\n                    break\n                p_u = R_nodes[u]['potential']\n                for (v, es) in R_succ[u].items():\n                    if v in d:\n                        continue\n                    wmin = inf\n                    for (k, e) in es.items():\n                        if e['capacity'] - e['flow'] >= delta:\n                            w = e['weight']\n                            if w < wmin:\n                                wmin = w\n                                kmin = k\n                                emin = e\n                    if wmin == inf:\n                        continue\n                    d_v = d_u + wmin - p_u + R_nodes[v]['potential']\n                    if h_insert(v, d_v):\n                        pred[v] = (u, kmin, emin)\n            if t is not None:\n                while u != s:\n                    v = u\n                    (u, k, e) = pred[v]\n                    e['flow'] += delta\n                    R_succ[v][u][k[0], not k[1]]['flow'] -= delta\n                R_nodes[s]['excess'] -= delta\n                R_nodes[t]['excess'] += delta\n                if R_nodes[s]['excess'] < delta:\n                    S_remove(s)\n                if R_nodes[t]['excess'] > -delta:\n                    T_remove(t)\n                d_t = d[t]\n                for (u, d_u) in d.items():\n                    R_nodes[u]['potential'] -= d_u - d_t\n            else:\n                S_remove(s)\n        delta //= 2\n    if any((R.nodes[u]['excess'] != 0 for u in R)):\n        raise nx.NetworkXUnfeasible('No flow satisfying all demands.')\n    for u in R:\n        for (v, es) in R_succ[u].items():\n            for e in es.values():\n                flow = e['flow']\n                if flow > 0:\n                    flow_cost += flow * e['weight']\n    return (flow_cost, _build_flow_dict(G, R, capacity, weight))",
            "@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef capacity_scaling(G, demand='demand', capacity='capacity', weight='weight', heap=BinaryHeap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a capacity scaling successive shortest augmenting path algorithm.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\\n        demands is to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    heap : class\\n        Type of heap to be used in the algorithm. It should be a subclass of\\n        :class:`MinHeap` or implement a compatible interface.\\n\\n        If a stock heap implementation is to be used, :class:`BinaryHeap` is\\n        recommended over :class:`PairingHeap` for Python implementations without\\n        optimized attribute accesses (e.g., CPython) despite a slower\\n        asymptotic running time. For Python implementations with optimized\\n        attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\\n        performance. Default value: :class:`BinaryHeap`.\\n\\n    Returns\\n    -------\\n    flowCost : integer\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        If G is a digraph, a dict-of-dicts keyed by nodes such that\\n        flowDict[u][v] is the flow on edge (u, v).\\n        If G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\\n        so that flowDict[u][v][key] is the flow on edge (u, v, key).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed,\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm does not work if edge weights are floating-point numbers.\\n\\n    See also\\n    --------\\n    :meth:`network_simplex`\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.capacity_scaling(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.capacity_scaling(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n    '\n    R = _build_residual_network(G, demand, capacity, weight)\n    inf = float('inf')\n    flow_cost = sum((0 if e.get(capacity, inf) <= 0 or e.get(weight, 0) >= 0 else e[capacity] * e[weight] for (u, v, e) in nx.selfloop_edges(G, data=True)))\n    wmax = max(chain([-inf], (e['capacity'] for (u, v, e) in R.edges(data=True))))\n    if wmax == -inf:\n        return (flow_cost, _build_flow_dict(G, R, capacity, weight))\n    R_nodes = R.nodes\n    R_succ = R.succ\n    delta = 2 ** int(log(wmax, 2))\n    while delta >= 1:\n        for u in R:\n            p_u = R_nodes[u]['potential']\n            for (v, es) in R_succ[u].items():\n                for (k, e) in es.items():\n                    flow = e['capacity'] - e['flow']\n                    if e['weight'] - p_u + R_nodes[v]['potential'] < 0:\n                        flow = e['capacity'] - e['flow']\n                        if flow >= delta:\n                            e['flow'] += flow\n                            R_succ[v][u][k[0], not k[1]]['flow'] -= flow\n                            R_nodes[u]['excess'] -= flow\n                            R_nodes[v]['excess'] += flow\n        S = set()\n        T = set()\n        S_add = S.add\n        S_remove = S.remove\n        T_add = T.add\n        T_remove = T.remove\n        for u in R:\n            excess = R_nodes[u]['excess']\n            if excess >= delta:\n                S_add(u)\n            elif excess <= -delta:\n                T_add(u)\n        while S and T:\n            s = arbitrary_element(S)\n            t = None\n            d = {}\n            pred = {s: None}\n            h = heap()\n            h_insert = h.insert\n            h_get = h.get\n            h_insert(s, 0)\n            while h:\n                (u, d_u) = h.pop()\n                d[u] = d_u\n                if u in T:\n                    t = u\n                    break\n                p_u = R_nodes[u]['potential']\n                for (v, es) in R_succ[u].items():\n                    if v in d:\n                        continue\n                    wmin = inf\n                    for (k, e) in es.items():\n                        if e['capacity'] - e['flow'] >= delta:\n                            w = e['weight']\n                            if w < wmin:\n                                wmin = w\n                                kmin = k\n                                emin = e\n                    if wmin == inf:\n                        continue\n                    d_v = d_u + wmin - p_u + R_nodes[v]['potential']\n                    if h_insert(v, d_v):\n                        pred[v] = (u, kmin, emin)\n            if t is not None:\n                while u != s:\n                    v = u\n                    (u, k, e) = pred[v]\n                    e['flow'] += delta\n                    R_succ[v][u][k[0], not k[1]]['flow'] -= delta\n                R_nodes[s]['excess'] -= delta\n                R_nodes[t]['excess'] += delta\n                if R_nodes[s]['excess'] < delta:\n                    S_remove(s)\n                if R_nodes[t]['excess'] > -delta:\n                    T_remove(t)\n                d_t = d[t]\n                for (u, d_u) in d.items():\n                    R_nodes[u]['potential'] -= d_u - d_t\n            else:\n                S_remove(s)\n        delta //= 2\n    if any((R.nodes[u]['excess'] != 0 for u in R)):\n        raise nx.NetworkXUnfeasible('No flow satisfying all demands.')\n    for u in R:\n        for (v, es) in R_succ[u].items():\n            for e in es.values():\n                flow = e['flow']\n                if flow > 0:\n                    flow_cost += flow * e['weight']\n    return (flow_cost, _build_flow_dict(G, R, capacity, weight))"
        ]
    }
]