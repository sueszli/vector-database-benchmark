[
    {
        "func_name": "get_CC_operators",
        "original": "def get_CC_operators():\n    \"\"\"\n    Returns a tuple (T1,T2) of unique operators.\n    \"\"\"\n    i = symbols('i', below_fermi=True, cls=Dummy)\n    a = symbols('a', above_fermi=True, cls=Dummy)\n    t_ai = AntiSymmetricTensor('t', (a,), (i,))\n    ai = NO(Fd(a) * F(i))\n    (i, j) = symbols('i,j', below_fermi=True, cls=Dummy)\n    (a, b) = symbols('a,b', above_fermi=True, cls=Dummy)\n    t_abij = AntiSymmetricTensor('t', (a, b), (i, j))\n    abji = NO(Fd(a) * Fd(b) * F(j) * F(i))\n    T1 = t_ai * ai\n    T2 = Rational(1, 4) * t_abij * abji\n    return (T1, T2)",
        "mutated": [
            "def get_CC_operators():\n    if False:\n        i = 10\n    '\\n    Returns a tuple (T1,T2) of unique operators.\\n    '\n    i = symbols('i', below_fermi=True, cls=Dummy)\n    a = symbols('a', above_fermi=True, cls=Dummy)\n    t_ai = AntiSymmetricTensor('t', (a,), (i,))\n    ai = NO(Fd(a) * F(i))\n    (i, j) = symbols('i,j', below_fermi=True, cls=Dummy)\n    (a, b) = symbols('a,b', above_fermi=True, cls=Dummy)\n    t_abij = AntiSymmetricTensor('t', (a, b), (i, j))\n    abji = NO(Fd(a) * Fd(b) * F(j) * F(i))\n    T1 = t_ai * ai\n    T2 = Rational(1, 4) * t_abij * abji\n    return (T1, T2)",
            "def get_CC_operators():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a tuple (T1,T2) of unique operators.\\n    '\n    i = symbols('i', below_fermi=True, cls=Dummy)\n    a = symbols('a', above_fermi=True, cls=Dummy)\n    t_ai = AntiSymmetricTensor('t', (a,), (i,))\n    ai = NO(Fd(a) * F(i))\n    (i, j) = symbols('i,j', below_fermi=True, cls=Dummy)\n    (a, b) = symbols('a,b', above_fermi=True, cls=Dummy)\n    t_abij = AntiSymmetricTensor('t', (a, b), (i, j))\n    abji = NO(Fd(a) * Fd(b) * F(j) * F(i))\n    T1 = t_ai * ai\n    T2 = Rational(1, 4) * t_abij * abji\n    return (T1, T2)",
            "def get_CC_operators():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a tuple (T1,T2) of unique operators.\\n    '\n    i = symbols('i', below_fermi=True, cls=Dummy)\n    a = symbols('a', above_fermi=True, cls=Dummy)\n    t_ai = AntiSymmetricTensor('t', (a,), (i,))\n    ai = NO(Fd(a) * F(i))\n    (i, j) = symbols('i,j', below_fermi=True, cls=Dummy)\n    (a, b) = symbols('a,b', above_fermi=True, cls=Dummy)\n    t_abij = AntiSymmetricTensor('t', (a, b), (i, j))\n    abji = NO(Fd(a) * Fd(b) * F(j) * F(i))\n    T1 = t_ai * ai\n    T2 = Rational(1, 4) * t_abij * abji\n    return (T1, T2)",
            "def get_CC_operators():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a tuple (T1,T2) of unique operators.\\n    '\n    i = symbols('i', below_fermi=True, cls=Dummy)\n    a = symbols('a', above_fermi=True, cls=Dummy)\n    t_ai = AntiSymmetricTensor('t', (a,), (i,))\n    ai = NO(Fd(a) * F(i))\n    (i, j) = symbols('i,j', below_fermi=True, cls=Dummy)\n    (a, b) = symbols('a,b', above_fermi=True, cls=Dummy)\n    t_abij = AntiSymmetricTensor('t', (a, b), (i, j))\n    abji = NO(Fd(a) * Fd(b) * F(j) * F(i))\n    T1 = t_ai * ai\n    T2 = Rational(1, 4) * t_abij * abji\n    return (T1, T2)",
            "def get_CC_operators():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a tuple (T1,T2) of unique operators.\\n    '\n    i = symbols('i', below_fermi=True, cls=Dummy)\n    a = symbols('a', above_fermi=True, cls=Dummy)\n    t_ai = AntiSymmetricTensor('t', (a,), (i,))\n    ai = NO(Fd(a) * F(i))\n    (i, j) = symbols('i,j', below_fermi=True, cls=Dummy)\n    (a, b) = symbols('a,b', above_fermi=True, cls=Dummy)\n    t_abij = AntiSymmetricTensor('t', (a, b), (i, j))\n    abji = NO(Fd(a) * Fd(b) * F(j) * F(i))\n    T1 = t_ai * ai\n    T2 = Rational(1, 4) * t_abij * abji\n    return (T1, T2)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    print()\n    print('Calculates the Coupled-Cluster energy- and amplitude equations')\n    print(\"See 'An Introduction to Coupled Cluster Theory' by\")\n    print('T. Daniel Crawford and Henry F. Schaefer III')\n    print('Reference to a Lecture Series: http://vergil.chemistry.gatech.edu/notes/sahan-cc-2010.pdf')\n    print()\n    (p, q, r, s) = symbols('p,q,r,s', cls=Dummy)\n    f = AntiSymmetricTensor('f', (p,), (q,))\n    pr = NO(Fd(p) * F(q))\n    v = AntiSymmetricTensor('v', (p, q), (r, s))\n    pqsr = NO(Fd(p) * Fd(q) * F(s) * F(r))\n    H = f * pr + Rational(1, 4) * v * pqsr\n    print('Using the hamiltonian:', latex(H))\n    print('Calculating 4 nested commutators')\n    C = Commutator\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 1...')\n    comm1 = wicks(C(H, T))\n    comm1 = evaluate_deltas(comm1)\n    comm1 = substitute_dummies(comm1)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 2...')\n    comm2 = wicks(C(comm1, T))\n    comm2 = evaluate_deltas(comm2)\n    comm2 = substitute_dummies(comm2)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 3...')\n    comm3 = wicks(C(comm2, T))\n    comm3 = evaluate_deltas(comm3)\n    comm3 = substitute_dummies(comm3)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 4...')\n    comm4 = wicks(C(comm3, T))\n    comm4 = evaluate_deltas(comm4)\n    comm4 = substitute_dummies(comm4)\n    print('construct Hausdorff expansion...')\n    eq = H + comm1 + comm2 / 2 + comm3 / 6 + comm4 / 24\n    eq = eq.expand()\n    eq = evaluate_deltas(eq)\n    eq = substitute_dummies(eq, new_indices=True, pretty_indices=pretty_dummies_dict)\n    print('*********************')\n    print()\n    print('extracting CC equations from full Hbar')\n    (i, j, k, l) = symbols('i,j,k,l', below_fermi=True)\n    (a, b, c, d) = symbols('a,b,c,d', above_fermi=True)\n    print()\n    print('CC Energy:')\n    print(latex(wicks(eq, simplify_dummies=True, keep_only_fully_contracted=True)))\n    print()\n    print('CC T1:')\n    eqT1 = wicks(NO(Fd(i) * F(a)) * eq, simplify_kronecker_deltas=True, keep_only_fully_contracted=True)\n    eqT1 = substitute_dummies(eqT1)\n    print(latex(eqT1))\n    print()\n    print('CC T2:')\n    eqT2 = wicks(NO(Fd(i) * Fd(j) * F(b) * F(a)) * eq, simplify_dummies=True, keep_only_fully_contracted=True, simplify_kronecker_deltas=True)\n    P = PermutationOperator\n    eqT2 = simplify_index_permutations(eqT2, [P(a, b), P(i, j)])\n    print(latex(eqT2))",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    print()\n    print('Calculates the Coupled-Cluster energy- and amplitude equations')\n    print(\"See 'An Introduction to Coupled Cluster Theory' by\")\n    print('T. Daniel Crawford and Henry F. Schaefer III')\n    print('Reference to a Lecture Series: http://vergil.chemistry.gatech.edu/notes/sahan-cc-2010.pdf')\n    print()\n    (p, q, r, s) = symbols('p,q,r,s', cls=Dummy)\n    f = AntiSymmetricTensor('f', (p,), (q,))\n    pr = NO(Fd(p) * F(q))\n    v = AntiSymmetricTensor('v', (p, q), (r, s))\n    pqsr = NO(Fd(p) * Fd(q) * F(s) * F(r))\n    H = f * pr + Rational(1, 4) * v * pqsr\n    print('Using the hamiltonian:', latex(H))\n    print('Calculating 4 nested commutators')\n    C = Commutator\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 1...')\n    comm1 = wicks(C(H, T))\n    comm1 = evaluate_deltas(comm1)\n    comm1 = substitute_dummies(comm1)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 2...')\n    comm2 = wicks(C(comm1, T))\n    comm2 = evaluate_deltas(comm2)\n    comm2 = substitute_dummies(comm2)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 3...')\n    comm3 = wicks(C(comm2, T))\n    comm3 = evaluate_deltas(comm3)\n    comm3 = substitute_dummies(comm3)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 4...')\n    comm4 = wicks(C(comm3, T))\n    comm4 = evaluate_deltas(comm4)\n    comm4 = substitute_dummies(comm4)\n    print('construct Hausdorff expansion...')\n    eq = H + comm1 + comm2 / 2 + comm3 / 6 + comm4 / 24\n    eq = eq.expand()\n    eq = evaluate_deltas(eq)\n    eq = substitute_dummies(eq, new_indices=True, pretty_indices=pretty_dummies_dict)\n    print('*********************')\n    print()\n    print('extracting CC equations from full Hbar')\n    (i, j, k, l) = symbols('i,j,k,l', below_fermi=True)\n    (a, b, c, d) = symbols('a,b,c,d', above_fermi=True)\n    print()\n    print('CC Energy:')\n    print(latex(wicks(eq, simplify_dummies=True, keep_only_fully_contracted=True)))\n    print()\n    print('CC T1:')\n    eqT1 = wicks(NO(Fd(i) * F(a)) * eq, simplify_kronecker_deltas=True, keep_only_fully_contracted=True)\n    eqT1 = substitute_dummies(eqT1)\n    print(latex(eqT1))\n    print()\n    print('CC T2:')\n    eqT2 = wicks(NO(Fd(i) * Fd(j) * F(b) * F(a)) * eq, simplify_dummies=True, keep_only_fully_contracted=True, simplify_kronecker_deltas=True)\n    P = PermutationOperator\n    eqT2 = simplify_index_permutations(eqT2, [P(a, b), P(i, j)])\n    print(latex(eqT2))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print()\n    print('Calculates the Coupled-Cluster energy- and amplitude equations')\n    print(\"See 'An Introduction to Coupled Cluster Theory' by\")\n    print('T. Daniel Crawford and Henry F. Schaefer III')\n    print('Reference to a Lecture Series: http://vergil.chemistry.gatech.edu/notes/sahan-cc-2010.pdf')\n    print()\n    (p, q, r, s) = symbols('p,q,r,s', cls=Dummy)\n    f = AntiSymmetricTensor('f', (p,), (q,))\n    pr = NO(Fd(p) * F(q))\n    v = AntiSymmetricTensor('v', (p, q), (r, s))\n    pqsr = NO(Fd(p) * Fd(q) * F(s) * F(r))\n    H = f * pr + Rational(1, 4) * v * pqsr\n    print('Using the hamiltonian:', latex(H))\n    print('Calculating 4 nested commutators')\n    C = Commutator\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 1...')\n    comm1 = wicks(C(H, T))\n    comm1 = evaluate_deltas(comm1)\n    comm1 = substitute_dummies(comm1)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 2...')\n    comm2 = wicks(C(comm1, T))\n    comm2 = evaluate_deltas(comm2)\n    comm2 = substitute_dummies(comm2)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 3...')\n    comm3 = wicks(C(comm2, T))\n    comm3 = evaluate_deltas(comm3)\n    comm3 = substitute_dummies(comm3)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 4...')\n    comm4 = wicks(C(comm3, T))\n    comm4 = evaluate_deltas(comm4)\n    comm4 = substitute_dummies(comm4)\n    print('construct Hausdorff expansion...')\n    eq = H + comm1 + comm2 / 2 + comm3 / 6 + comm4 / 24\n    eq = eq.expand()\n    eq = evaluate_deltas(eq)\n    eq = substitute_dummies(eq, new_indices=True, pretty_indices=pretty_dummies_dict)\n    print('*********************')\n    print()\n    print('extracting CC equations from full Hbar')\n    (i, j, k, l) = symbols('i,j,k,l', below_fermi=True)\n    (a, b, c, d) = symbols('a,b,c,d', above_fermi=True)\n    print()\n    print('CC Energy:')\n    print(latex(wicks(eq, simplify_dummies=True, keep_only_fully_contracted=True)))\n    print()\n    print('CC T1:')\n    eqT1 = wicks(NO(Fd(i) * F(a)) * eq, simplify_kronecker_deltas=True, keep_only_fully_contracted=True)\n    eqT1 = substitute_dummies(eqT1)\n    print(latex(eqT1))\n    print()\n    print('CC T2:')\n    eqT2 = wicks(NO(Fd(i) * Fd(j) * F(b) * F(a)) * eq, simplify_dummies=True, keep_only_fully_contracted=True, simplify_kronecker_deltas=True)\n    P = PermutationOperator\n    eqT2 = simplify_index_permutations(eqT2, [P(a, b), P(i, j)])\n    print(latex(eqT2))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print()\n    print('Calculates the Coupled-Cluster energy- and amplitude equations')\n    print(\"See 'An Introduction to Coupled Cluster Theory' by\")\n    print('T. Daniel Crawford and Henry F. Schaefer III')\n    print('Reference to a Lecture Series: http://vergil.chemistry.gatech.edu/notes/sahan-cc-2010.pdf')\n    print()\n    (p, q, r, s) = symbols('p,q,r,s', cls=Dummy)\n    f = AntiSymmetricTensor('f', (p,), (q,))\n    pr = NO(Fd(p) * F(q))\n    v = AntiSymmetricTensor('v', (p, q), (r, s))\n    pqsr = NO(Fd(p) * Fd(q) * F(s) * F(r))\n    H = f * pr + Rational(1, 4) * v * pqsr\n    print('Using the hamiltonian:', latex(H))\n    print('Calculating 4 nested commutators')\n    C = Commutator\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 1...')\n    comm1 = wicks(C(H, T))\n    comm1 = evaluate_deltas(comm1)\n    comm1 = substitute_dummies(comm1)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 2...')\n    comm2 = wicks(C(comm1, T))\n    comm2 = evaluate_deltas(comm2)\n    comm2 = substitute_dummies(comm2)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 3...')\n    comm3 = wicks(C(comm2, T))\n    comm3 = evaluate_deltas(comm3)\n    comm3 = substitute_dummies(comm3)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 4...')\n    comm4 = wicks(C(comm3, T))\n    comm4 = evaluate_deltas(comm4)\n    comm4 = substitute_dummies(comm4)\n    print('construct Hausdorff expansion...')\n    eq = H + comm1 + comm2 / 2 + comm3 / 6 + comm4 / 24\n    eq = eq.expand()\n    eq = evaluate_deltas(eq)\n    eq = substitute_dummies(eq, new_indices=True, pretty_indices=pretty_dummies_dict)\n    print('*********************')\n    print()\n    print('extracting CC equations from full Hbar')\n    (i, j, k, l) = symbols('i,j,k,l', below_fermi=True)\n    (a, b, c, d) = symbols('a,b,c,d', above_fermi=True)\n    print()\n    print('CC Energy:')\n    print(latex(wicks(eq, simplify_dummies=True, keep_only_fully_contracted=True)))\n    print()\n    print('CC T1:')\n    eqT1 = wicks(NO(Fd(i) * F(a)) * eq, simplify_kronecker_deltas=True, keep_only_fully_contracted=True)\n    eqT1 = substitute_dummies(eqT1)\n    print(latex(eqT1))\n    print()\n    print('CC T2:')\n    eqT2 = wicks(NO(Fd(i) * Fd(j) * F(b) * F(a)) * eq, simplify_dummies=True, keep_only_fully_contracted=True, simplify_kronecker_deltas=True)\n    P = PermutationOperator\n    eqT2 = simplify_index_permutations(eqT2, [P(a, b), P(i, j)])\n    print(latex(eqT2))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print()\n    print('Calculates the Coupled-Cluster energy- and amplitude equations')\n    print(\"See 'An Introduction to Coupled Cluster Theory' by\")\n    print('T. Daniel Crawford and Henry F. Schaefer III')\n    print('Reference to a Lecture Series: http://vergil.chemistry.gatech.edu/notes/sahan-cc-2010.pdf')\n    print()\n    (p, q, r, s) = symbols('p,q,r,s', cls=Dummy)\n    f = AntiSymmetricTensor('f', (p,), (q,))\n    pr = NO(Fd(p) * F(q))\n    v = AntiSymmetricTensor('v', (p, q), (r, s))\n    pqsr = NO(Fd(p) * Fd(q) * F(s) * F(r))\n    H = f * pr + Rational(1, 4) * v * pqsr\n    print('Using the hamiltonian:', latex(H))\n    print('Calculating 4 nested commutators')\n    C = Commutator\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 1...')\n    comm1 = wicks(C(H, T))\n    comm1 = evaluate_deltas(comm1)\n    comm1 = substitute_dummies(comm1)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 2...')\n    comm2 = wicks(C(comm1, T))\n    comm2 = evaluate_deltas(comm2)\n    comm2 = substitute_dummies(comm2)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 3...')\n    comm3 = wicks(C(comm2, T))\n    comm3 = evaluate_deltas(comm3)\n    comm3 = substitute_dummies(comm3)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 4...')\n    comm4 = wicks(C(comm3, T))\n    comm4 = evaluate_deltas(comm4)\n    comm4 = substitute_dummies(comm4)\n    print('construct Hausdorff expansion...')\n    eq = H + comm1 + comm2 / 2 + comm3 / 6 + comm4 / 24\n    eq = eq.expand()\n    eq = evaluate_deltas(eq)\n    eq = substitute_dummies(eq, new_indices=True, pretty_indices=pretty_dummies_dict)\n    print('*********************')\n    print()\n    print('extracting CC equations from full Hbar')\n    (i, j, k, l) = symbols('i,j,k,l', below_fermi=True)\n    (a, b, c, d) = symbols('a,b,c,d', above_fermi=True)\n    print()\n    print('CC Energy:')\n    print(latex(wicks(eq, simplify_dummies=True, keep_only_fully_contracted=True)))\n    print()\n    print('CC T1:')\n    eqT1 = wicks(NO(Fd(i) * F(a)) * eq, simplify_kronecker_deltas=True, keep_only_fully_contracted=True)\n    eqT1 = substitute_dummies(eqT1)\n    print(latex(eqT1))\n    print()\n    print('CC T2:')\n    eqT2 = wicks(NO(Fd(i) * Fd(j) * F(b) * F(a)) * eq, simplify_dummies=True, keep_only_fully_contracted=True, simplify_kronecker_deltas=True)\n    P = PermutationOperator\n    eqT2 = simplify_index_permutations(eqT2, [P(a, b), P(i, j)])\n    print(latex(eqT2))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print()\n    print('Calculates the Coupled-Cluster energy- and amplitude equations')\n    print(\"See 'An Introduction to Coupled Cluster Theory' by\")\n    print('T. Daniel Crawford and Henry F. Schaefer III')\n    print('Reference to a Lecture Series: http://vergil.chemistry.gatech.edu/notes/sahan-cc-2010.pdf')\n    print()\n    (p, q, r, s) = symbols('p,q,r,s', cls=Dummy)\n    f = AntiSymmetricTensor('f', (p,), (q,))\n    pr = NO(Fd(p) * F(q))\n    v = AntiSymmetricTensor('v', (p, q), (r, s))\n    pqsr = NO(Fd(p) * Fd(q) * F(s) * F(r))\n    H = f * pr + Rational(1, 4) * v * pqsr\n    print('Using the hamiltonian:', latex(H))\n    print('Calculating 4 nested commutators')\n    C = Commutator\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 1...')\n    comm1 = wicks(C(H, T))\n    comm1 = evaluate_deltas(comm1)\n    comm1 = substitute_dummies(comm1)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 2...')\n    comm2 = wicks(C(comm1, T))\n    comm2 = evaluate_deltas(comm2)\n    comm2 = substitute_dummies(comm2)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 3...')\n    comm3 = wicks(C(comm2, T))\n    comm3 = evaluate_deltas(comm3)\n    comm3 = substitute_dummies(comm3)\n    (T1, T2) = get_CC_operators()\n    T = T1 + T2\n    print('commutator 4...')\n    comm4 = wicks(C(comm3, T))\n    comm4 = evaluate_deltas(comm4)\n    comm4 = substitute_dummies(comm4)\n    print('construct Hausdorff expansion...')\n    eq = H + comm1 + comm2 / 2 + comm3 / 6 + comm4 / 24\n    eq = eq.expand()\n    eq = evaluate_deltas(eq)\n    eq = substitute_dummies(eq, new_indices=True, pretty_indices=pretty_dummies_dict)\n    print('*********************')\n    print()\n    print('extracting CC equations from full Hbar')\n    (i, j, k, l) = symbols('i,j,k,l', below_fermi=True)\n    (a, b, c, d) = symbols('a,b,c,d', above_fermi=True)\n    print()\n    print('CC Energy:')\n    print(latex(wicks(eq, simplify_dummies=True, keep_only_fully_contracted=True)))\n    print()\n    print('CC T1:')\n    eqT1 = wicks(NO(Fd(i) * F(a)) * eq, simplify_kronecker_deltas=True, keep_only_fully_contracted=True)\n    eqT1 = substitute_dummies(eqT1)\n    print(latex(eqT1))\n    print()\n    print('CC T2:')\n    eqT2 = wicks(NO(Fd(i) * Fd(j) * F(b) * F(a)) * eq, simplify_dummies=True, keep_only_fully_contracted=True, simplify_kronecker_deltas=True)\n    P = PermutationOperator\n    eqT2 = simplify_index_permutations(eqT2, [P(a, b), P(i, j)])\n    print(latex(eqT2))"
        ]
    }
]