[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_classes, train_cfg, test_cfg, pred_layer_cfg=None, enlarge_width=0.1, cls_loss=None, bbox_loss=None, bbox_coder=None, init_cfg=None):\n    super().__init__(init_cfg=init_cfg)\n    self.num_classes = num_classes\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.enlarge_width = enlarge_width\n    self.bbox_loss = build_loss(bbox_loss)\n    self.cls_loss = build_loss(cls_loss)\n    self.bbox_coder = build_bbox_coder(bbox_coder)\n    self.cls_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.cls_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_cls_out_channels())\n    self.reg_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.reg_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_reg_out_channels())",
        "mutated": [
            "def __init__(self, num_classes, train_cfg, test_cfg, pred_layer_cfg=None, enlarge_width=0.1, cls_loss=None, bbox_loss=None, bbox_coder=None, init_cfg=None):\n    if False:\n        i = 10\n    super().__init__(init_cfg=init_cfg)\n    self.num_classes = num_classes\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.enlarge_width = enlarge_width\n    self.bbox_loss = build_loss(bbox_loss)\n    self.cls_loss = build_loss(cls_loss)\n    self.bbox_coder = build_bbox_coder(bbox_coder)\n    self.cls_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.cls_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_cls_out_channels())\n    self.reg_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.reg_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_reg_out_channels())",
            "def __init__(self, num_classes, train_cfg, test_cfg, pred_layer_cfg=None, enlarge_width=0.1, cls_loss=None, bbox_loss=None, bbox_coder=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(init_cfg=init_cfg)\n    self.num_classes = num_classes\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.enlarge_width = enlarge_width\n    self.bbox_loss = build_loss(bbox_loss)\n    self.cls_loss = build_loss(cls_loss)\n    self.bbox_coder = build_bbox_coder(bbox_coder)\n    self.cls_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.cls_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_cls_out_channels())\n    self.reg_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.reg_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_reg_out_channels())",
            "def __init__(self, num_classes, train_cfg, test_cfg, pred_layer_cfg=None, enlarge_width=0.1, cls_loss=None, bbox_loss=None, bbox_coder=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(init_cfg=init_cfg)\n    self.num_classes = num_classes\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.enlarge_width = enlarge_width\n    self.bbox_loss = build_loss(bbox_loss)\n    self.cls_loss = build_loss(cls_loss)\n    self.bbox_coder = build_bbox_coder(bbox_coder)\n    self.cls_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.cls_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_cls_out_channels())\n    self.reg_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.reg_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_reg_out_channels())",
            "def __init__(self, num_classes, train_cfg, test_cfg, pred_layer_cfg=None, enlarge_width=0.1, cls_loss=None, bbox_loss=None, bbox_coder=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(init_cfg=init_cfg)\n    self.num_classes = num_classes\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.enlarge_width = enlarge_width\n    self.bbox_loss = build_loss(bbox_loss)\n    self.cls_loss = build_loss(cls_loss)\n    self.bbox_coder = build_bbox_coder(bbox_coder)\n    self.cls_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.cls_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_cls_out_channels())\n    self.reg_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.reg_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_reg_out_channels())",
            "def __init__(self, num_classes, train_cfg, test_cfg, pred_layer_cfg=None, enlarge_width=0.1, cls_loss=None, bbox_loss=None, bbox_coder=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(init_cfg=init_cfg)\n    self.num_classes = num_classes\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.enlarge_width = enlarge_width\n    self.bbox_loss = build_loss(bbox_loss)\n    self.cls_loss = build_loss(cls_loss)\n    self.bbox_coder = build_bbox_coder(bbox_coder)\n    self.cls_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.cls_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_cls_out_channels())\n    self.reg_layers = self._make_fc_layers(fc_cfg=pred_layer_cfg.reg_linear_channels, input_channels=pred_layer_cfg.in_channels, output_channels=self._get_reg_out_channels())"
        ]
    },
    {
        "func_name": "_make_fc_layers",
        "original": "def _make_fc_layers(self, fc_cfg, input_channels, output_channels):\n    \"\"\"Make fully connect layers.\n\n        Args:\n            fc_cfg (dict): Config of fully connect.\n            input_channels (int): Input channels for fc_layers.\n            output_channels (int): Input channels for fc_layers.\n\n        Returns:\n            nn.Sequential: Fully connect layers.\n        \"\"\"\n    fc_layers = []\n    c_in = input_channels\n    for k in range(0, fc_cfg.__len__()):\n        fc_layers.extend([nn.Linear(c_in, fc_cfg[k], bias=False), nn.BatchNorm1d(fc_cfg[k]), nn.ReLU()])\n        c_in = fc_cfg[k]\n    fc_layers.append(nn.Linear(c_in, output_channels, bias=True))\n    return nn.Sequential(*fc_layers)",
        "mutated": [
            "def _make_fc_layers(self, fc_cfg, input_channels, output_channels):\n    if False:\n        i = 10\n    'Make fully connect layers.\\n\\n        Args:\\n            fc_cfg (dict): Config of fully connect.\\n            input_channels (int): Input channels for fc_layers.\\n            output_channels (int): Input channels for fc_layers.\\n\\n        Returns:\\n            nn.Sequential: Fully connect layers.\\n        '\n    fc_layers = []\n    c_in = input_channels\n    for k in range(0, fc_cfg.__len__()):\n        fc_layers.extend([nn.Linear(c_in, fc_cfg[k], bias=False), nn.BatchNorm1d(fc_cfg[k]), nn.ReLU()])\n        c_in = fc_cfg[k]\n    fc_layers.append(nn.Linear(c_in, output_channels, bias=True))\n    return nn.Sequential(*fc_layers)",
            "def _make_fc_layers(self, fc_cfg, input_channels, output_channels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Make fully connect layers.\\n\\n        Args:\\n            fc_cfg (dict): Config of fully connect.\\n            input_channels (int): Input channels for fc_layers.\\n            output_channels (int): Input channels for fc_layers.\\n\\n        Returns:\\n            nn.Sequential: Fully connect layers.\\n        '\n    fc_layers = []\n    c_in = input_channels\n    for k in range(0, fc_cfg.__len__()):\n        fc_layers.extend([nn.Linear(c_in, fc_cfg[k], bias=False), nn.BatchNorm1d(fc_cfg[k]), nn.ReLU()])\n        c_in = fc_cfg[k]\n    fc_layers.append(nn.Linear(c_in, output_channels, bias=True))\n    return nn.Sequential(*fc_layers)",
            "def _make_fc_layers(self, fc_cfg, input_channels, output_channels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Make fully connect layers.\\n\\n        Args:\\n            fc_cfg (dict): Config of fully connect.\\n            input_channels (int): Input channels for fc_layers.\\n            output_channels (int): Input channels for fc_layers.\\n\\n        Returns:\\n            nn.Sequential: Fully connect layers.\\n        '\n    fc_layers = []\n    c_in = input_channels\n    for k in range(0, fc_cfg.__len__()):\n        fc_layers.extend([nn.Linear(c_in, fc_cfg[k], bias=False), nn.BatchNorm1d(fc_cfg[k]), nn.ReLU()])\n        c_in = fc_cfg[k]\n    fc_layers.append(nn.Linear(c_in, output_channels, bias=True))\n    return nn.Sequential(*fc_layers)",
            "def _make_fc_layers(self, fc_cfg, input_channels, output_channels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Make fully connect layers.\\n\\n        Args:\\n            fc_cfg (dict): Config of fully connect.\\n            input_channels (int): Input channels for fc_layers.\\n            output_channels (int): Input channels for fc_layers.\\n\\n        Returns:\\n            nn.Sequential: Fully connect layers.\\n        '\n    fc_layers = []\n    c_in = input_channels\n    for k in range(0, fc_cfg.__len__()):\n        fc_layers.extend([nn.Linear(c_in, fc_cfg[k], bias=False), nn.BatchNorm1d(fc_cfg[k]), nn.ReLU()])\n        c_in = fc_cfg[k]\n    fc_layers.append(nn.Linear(c_in, output_channels, bias=True))\n    return nn.Sequential(*fc_layers)",
            "def _make_fc_layers(self, fc_cfg, input_channels, output_channels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Make fully connect layers.\\n\\n        Args:\\n            fc_cfg (dict): Config of fully connect.\\n            input_channels (int): Input channels for fc_layers.\\n            output_channels (int): Input channels for fc_layers.\\n\\n        Returns:\\n            nn.Sequential: Fully connect layers.\\n        '\n    fc_layers = []\n    c_in = input_channels\n    for k in range(0, fc_cfg.__len__()):\n        fc_layers.extend([nn.Linear(c_in, fc_cfg[k], bias=False), nn.BatchNorm1d(fc_cfg[k]), nn.ReLU()])\n        c_in = fc_cfg[k]\n    fc_layers.append(nn.Linear(c_in, output_channels, bias=True))\n    return nn.Sequential(*fc_layers)"
        ]
    },
    {
        "func_name": "_get_cls_out_channels",
        "original": "def _get_cls_out_channels(self):\n    \"\"\"Return the channel number of classification outputs.\"\"\"\n    return self.num_classes",
        "mutated": [
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n    'Return the channel number of classification outputs.'\n    return self.num_classes",
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the channel number of classification outputs.'\n    return self.num_classes",
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the channel number of classification outputs.'\n    return self.num_classes",
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the channel number of classification outputs.'\n    return self.num_classes",
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the channel number of classification outputs.'\n    return self.num_classes"
        ]
    },
    {
        "func_name": "_get_reg_out_channels",
        "original": "def _get_reg_out_channels(self):\n    \"\"\"Return the channel number of regression outputs.\"\"\"\n    return self.bbox_coder.code_size",
        "mutated": [
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n    'Return the channel number of regression outputs.'\n    return self.bbox_coder.code_size",
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the channel number of regression outputs.'\n    return self.bbox_coder.code_size",
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the channel number of regression outputs.'\n    return self.bbox_coder.code_size",
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the channel number of regression outputs.'\n    return self.bbox_coder.code_size",
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the channel number of regression outputs.'\n    return self.bbox_coder.code_size"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, feat_dict):\n    \"\"\"Forward pass.\n\n        Args:\n            feat_dict (dict): Feature dict from backbone.\n\n        Returns:\n            tuple[list[torch.Tensor]]: Predicted boxes and classification\n                scores.\n        \"\"\"\n    point_features = feat_dict['fp_features']\n    point_features = point_features.permute(0, 2, 1).contiguous()\n    batch_size = point_features.shape[0]\n    feat_cls = point_features.view(-1, point_features.shape[-1])\n    feat_reg = point_features.view(-1, point_features.shape[-1])\n    point_cls_preds = self.cls_layers(feat_cls).reshape(batch_size, -1, self._get_cls_out_channels())\n    point_box_preds = self.reg_layers(feat_reg).reshape(batch_size, -1, self._get_reg_out_channels())\n    return (point_box_preds, point_cls_preds)",
        "mutated": [
            "def forward(self, feat_dict):\n    if False:\n        i = 10\n    'Forward pass.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            tuple[list[torch.Tensor]]: Predicted boxes and classification\\n                scores.\\n        '\n    point_features = feat_dict['fp_features']\n    point_features = point_features.permute(0, 2, 1).contiguous()\n    batch_size = point_features.shape[0]\n    feat_cls = point_features.view(-1, point_features.shape[-1])\n    feat_reg = point_features.view(-1, point_features.shape[-1])\n    point_cls_preds = self.cls_layers(feat_cls).reshape(batch_size, -1, self._get_cls_out_channels())\n    point_box_preds = self.reg_layers(feat_reg).reshape(batch_size, -1, self._get_reg_out_channels())\n    return (point_box_preds, point_cls_preds)",
            "def forward(self, feat_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Forward pass.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            tuple[list[torch.Tensor]]: Predicted boxes and classification\\n                scores.\\n        '\n    point_features = feat_dict['fp_features']\n    point_features = point_features.permute(0, 2, 1).contiguous()\n    batch_size = point_features.shape[0]\n    feat_cls = point_features.view(-1, point_features.shape[-1])\n    feat_reg = point_features.view(-1, point_features.shape[-1])\n    point_cls_preds = self.cls_layers(feat_cls).reshape(batch_size, -1, self._get_cls_out_channels())\n    point_box_preds = self.reg_layers(feat_reg).reshape(batch_size, -1, self._get_reg_out_channels())\n    return (point_box_preds, point_cls_preds)",
            "def forward(self, feat_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Forward pass.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            tuple[list[torch.Tensor]]: Predicted boxes and classification\\n                scores.\\n        '\n    point_features = feat_dict['fp_features']\n    point_features = point_features.permute(0, 2, 1).contiguous()\n    batch_size = point_features.shape[0]\n    feat_cls = point_features.view(-1, point_features.shape[-1])\n    feat_reg = point_features.view(-1, point_features.shape[-1])\n    point_cls_preds = self.cls_layers(feat_cls).reshape(batch_size, -1, self._get_cls_out_channels())\n    point_box_preds = self.reg_layers(feat_reg).reshape(batch_size, -1, self._get_reg_out_channels())\n    return (point_box_preds, point_cls_preds)",
            "def forward(self, feat_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Forward pass.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            tuple[list[torch.Tensor]]: Predicted boxes and classification\\n                scores.\\n        '\n    point_features = feat_dict['fp_features']\n    point_features = point_features.permute(0, 2, 1).contiguous()\n    batch_size = point_features.shape[0]\n    feat_cls = point_features.view(-1, point_features.shape[-1])\n    feat_reg = point_features.view(-1, point_features.shape[-1])\n    point_cls_preds = self.cls_layers(feat_cls).reshape(batch_size, -1, self._get_cls_out_channels())\n    point_box_preds = self.reg_layers(feat_reg).reshape(batch_size, -1, self._get_reg_out_channels())\n    return (point_box_preds, point_cls_preds)",
            "def forward(self, feat_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Forward pass.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            tuple[list[torch.Tensor]]: Predicted boxes and classification\\n                scores.\\n        '\n    point_features = feat_dict['fp_features']\n    point_features = point_features.permute(0, 2, 1).contiguous()\n    batch_size = point_features.shape[0]\n    feat_cls = point_features.view(-1, point_features.shape[-1])\n    feat_reg = point_features.view(-1, point_features.shape[-1])\n    point_cls_preds = self.cls_layers(feat_cls).reshape(batch_size, -1, self._get_cls_out_channels())\n    point_box_preds = self.reg_layers(feat_reg).reshape(batch_size, -1, self._get_reg_out_channels())\n    return (point_box_preds, point_cls_preds)"
        ]
    },
    {
        "func_name": "loss",
        "original": "@force_fp32(apply_to='bbox_preds')\ndef loss(self, bbox_preds, cls_preds, points, gt_bboxes_3d, gt_labels_3d, img_metas=None):\n    \"\"\"Compute loss.\n\n        Args:\n            bbox_preds (dict): Predictions from forward of PointRCNN RPN_Head.\n            cls_preds (dict): Classification from forward of PointRCNN\n                RPN_Head.\n            points (list[torch.Tensor]): Input points.\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\n                bboxes of each sample.\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\n            img_metas (list[dict], Optional): Contain pcd and img's meta info.\n                Defaults to None.\n\n        Returns:\n            dict: Losses of PointRCNN RPN module.\n        \"\"\"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets) = targets\n    bbox_loss = self.bbox_loss(bbox_preds, bbox_targets, box_loss_weights.unsqueeze(-1))\n    semantic_points = cls_preds.reshape(-1, self.num_classes)\n    semantic_targets = mask_targets\n    semantic_targets[negative_mask] = self.num_classes\n    semantic_points_label = semantic_targets\n    semantic_loss_weight = negative_mask.float() + positive_mask.float()\n    semantic_loss = self.cls_loss(semantic_points, semantic_points_label.reshape(-1), semantic_loss_weight.reshape(-1))\n    semantic_loss /= positive_mask.float().sum()\n    losses = dict(bbox_loss=bbox_loss, semantic_loss=semantic_loss)\n    return losses",
        "mutated": [
            "@force_fp32(apply_to='bbox_preds')\ndef loss(self, bbox_preds, cls_preds, points, gt_bboxes_3d, gt_labels_3d, img_metas=None):\n    if False:\n        i = 10\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of PointRCNN RPN_Head.\\n            cls_preds (dict): Classification from forward of PointRCNN\\n                RPN_Head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            img_metas (list[dict], Optional): Contain pcd and img's meta info.\\n                Defaults to None.\\n\\n        Returns:\\n            dict: Losses of PointRCNN RPN module.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets) = targets\n    bbox_loss = self.bbox_loss(bbox_preds, bbox_targets, box_loss_weights.unsqueeze(-1))\n    semantic_points = cls_preds.reshape(-1, self.num_classes)\n    semantic_targets = mask_targets\n    semantic_targets[negative_mask] = self.num_classes\n    semantic_points_label = semantic_targets\n    semantic_loss_weight = negative_mask.float() + positive_mask.float()\n    semantic_loss = self.cls_loss(semantic_points, semantic_points_label.reshape(-1), semantic_loss_weight.reshape(-1))\n    semantic_loss /= positive_mask.float().sum()\n    losses = dict(bbox_loss=bbox_loss, semantic_loss=semantic_loss)\n    return losses",
            "@force_fp32(apply_to='bbox_preds')\ndef loss(self, bbox_preds, cls_preds, points, gt_bboxes_3d, gt_labels_3d, img_metas=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of PointRCNN RPN_Head.\\n            cls_preds (dict): Classification from forward of PointRCNN\\n                RPN_Head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            img_metas (list[dict], Optional): Contain pcd and img's meta info.\\n                Defaults to None.\\n\\n        Returns:\\n            dict: Losses of PointRCNN RPN module.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets) = targets\n    bbox_loss = self.bbox_loss(bbox_preds, bbox_targets, box_loss_weights.unsqueeze(-1))\n    semantic_points = cls_preds.reshape(-1, self.num_classes)\n    semantic_targets = mask_targets\n    semantic_targets[negative_mask] = self.num_classes\n    semantic_points_label = semantic_targets\n    semantic_loss_weight = negative_mask.float() + positive_mask.float()\n    semantic_loss = self.cls_loss(semantic_points, semantic_points_label.reshape(-1), semantic_loss_weight.reshape(-1))\n    semantic_loss /= positive_mask.float().sum()\n    losses = dict(bbox_loss=bbox_loss, semantic_loss=semantic_loss)\n    return losses",
            "@force_fp32(apply_to='bbox_preds')\ndef loss(self, bbox_preds, cls_preds, points, gt_bboxes_3d, gt_labels_3d, img_metas=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of PointRCNN RPN_Head.\\n            cls_preds (dict): Classification from forward of PointRCNN\\n                RPN_Head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            img_metas (list[dict], Optional): Contain pcd and img's meta info.\\n                Defaults to None.\\n\\n        Returns:\\n            dict: Losses of PointRCNN RPN module.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets) = targets\n    bbox_loss = self.bbox_loss(bbox_preds, bbox_targets, box_loss_weights.unsqueeze(-1))\n    semantic_points = cls_preds.reshape(-1, self.num_classes)\n    semantic_targets = mask_targets\n    semantic_targets[negative_mask] = self.num_classes\n    semantic_points_label = semantic_targets\n    semantic_loss_weight = negative_mask.float() + positive_mask.float()\n    semantic_loss = self.cls_loss(semantic_points, semantic_points_label.reshape(-1), semantic_loss_weight.reshape(-1))\n    semantic_loss /= positive_mask.float().sum()\n    losses = dict(bbox_loss=bbox_loss, semantic_loss=semantic_loss)\n    return losses",
            "@force_fp32(apply_to='bbox_preds')\ndef loss(self, bbox_preds, cls_preds, points, gt_bboxes_3d, gt_labels_3d, img_metas=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of PointRCNN RPN_Head.\\n            cls_preds (dict): Classification from forward of PointRCNN\\n                RPN_Head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            img_metas (list[dict], Optional): Contain pcd and img's meta info.\\n                Defaults to None.\\n\\n        Returns:\\n            dict: Losses of PointRCNN RPN module.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets) = targets\n    bbox_loss = self.bbox_loss(bbox_preds, bbox_targets, box_loss_weights.unsqueeze(-1))\n    semantic_points = cls_preds.reshape(-1, self.num_classes)\n    semantic_targets = mask_targets\n    semantic_targets[negative_mask] = self.num_classes\n    semantic_points_label = semantic_targets\n    semantic_loss_weight = negative_mask.float() + positive_mask.float()\n    semantic_loss = self.cls_loss(semantic_points, semantic_points_label.reshape(-1), semantic_loss_weight.reshape(-1))\n    semantic_loss /= positive_mask.float().sum()\n    losses = dict(bbox_loss=bbox_loss, semantic_loss=semantic_loss)\n    return losses",
            "@force_fp32(apply_to='bbox_preds')\ndef loss(self, bbox_preds, cls_preds, points, gt_bboxes_3d, gt_labels_3d, img_metas=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of PointRCNN RPN_Head.\\n            cls_preds (dict): Classification from forward of PointRCNN\\n                RPN_Head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            img_metas (list[dict], Optional): Contain pcd and img's meta info.\\n                Defaults to None.\\n\\n        Returns:\\n            dict: Losses of PointRCNN RPN module.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets) = targets\n    bbox_loss = self.bbox_loss(bbox_preds, bbox_targets, box_loss_weights.unsqueeze(-1))\n    semantic_points = cls_preds.reshape(-1, self.num_classes)\n    semantic_targets = mask_targets\n    semantic_targets[negative_mask] = self.num_classes\n    semantic_points_label = semantic_targets\n    semantic_loss_weight = negative_mask.float() + positive_mask.float()\n    semantic_loss = self.cls_loss(semantic_points, semantic_points_label.reshape(-1), semantic_loss_weight.reshape(-1))\n    semantic_loss /= positive_mask.float().sum()\n    losses = dict(bbox_loss=bbox_loss, semantic_loss=semantic_loss)\n    return losses"
        ]
    },
    {
        "func_name": "get_targets",
        "original": "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d):\n    \"\"\"Generate targets of PointRCNN RPN head.\n\n        Args:\n            points (list[torch.Tensor]): Points of each batch.\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\n                bboxes of each batch.\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\n\n        Returns:\n            tuple[torch.Tensor]: Targets of PointRCNN RPN head.\n        \"\"\"\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d)\n    bbox_targets = torch.stack(bbox_targets)\n    mask_targets = torch.stack(mask_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets)",
        "mutated": [
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n    'Generate targets of PointRCNN RPN head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of PointRCNN RPN head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d)\n    bbox_targets = torch.stack(bbox_targets)\n    mask_targets = torch.stack(mask_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate targets of PointRCNN RPN head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of PointRCNN RPN head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d)\n    bbox_targets = torch.stack(bbox_targets)\n    mask_targets = torch.stack(mask_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate targets of PointRCNN RPN head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of PointRCNN RPN head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d)\n    bbox_targets = torch.stack(bbox_targets)\n    mask_targets = torch.stack(mask_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate targets of PointRCNN RPN head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of PointRCNN RPN head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d)\n    bbox_targets = torch.stack(bbox_targets)\n    mask_targets = torch.stack(mask_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate targets of PointRCNN RPN head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of PointRCNN RPN head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d)\n    bbox_targets = torch.stack(bbox_targets)\n    mask_targets = torch.stack(mask_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, box_loss_weights, point_targets)"
        ]
    },
    {
        "func_name": "get_targets_single",
        "original": "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d):\n    \"\"\"Generate targets of PointRCNN RPN head for single batch.\n\n        Args:\n            points (torch.Tensor): Points of each batch.\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\n                boxes of each batch.\n            gt_labels_3d (torch.Tensor): Labels of each batch.\n\n        Returns:\n            tuple[torch.Tensor]: Targets of ssd3d head.\n        \"\"\"\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    gt_bboxes_3d_tensor = gt_bboxes_3d.tensor.clone()\n    gt_bboxes_3d_tensor[..., 2] += gt_bboxes_3d_tensor[..., 5] / 2\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, points)\n    gt_bboxes_3d_tensor = gt_bboxes_3d_tensor[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    bbox_targets = self.bbox_coder.encode(gt_bboxes_3d_tensor, points[..., 0:3], mask_targets)\n    positive_mask = points_mask.max(1)[0] > 0\n    extend_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.enlarge_width)\n    (points_mask, _) = self._assign_targets_by_points_inside(extend_gt_bboxes_3d, points)\n    negative_mask = points_mask.max(1)[0] == 0\n    point_targets = points[..., 0:3]\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets)",
        "mutated": [
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n    'Generate targets of PointRCNN RPN head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    gt_bboxes_3d_tensor = gt_bboxes_3d.tensor.clone()\n    gt_bboxes_3d_tensor[..., 2] += gt_bboxes_3d_tensor[..., 5] / 2\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, points)\n    gt_bboxes_3d_tensor = gt_bboxes_3d_tensor[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    bbox_targets = self.bbox_coder.encode(gt_bboxes_3d_tensor, points[..., 0:3], mask_targets)\n    positive_mask = points_mask.max(1)[0] > 0\n    extend_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.enlarge_width)\n    (points_mask, _) = self._assign_targets_by_points_inside(extend_gt_bboxes_3d, points)\n    negative_mask = points_mask.max(1)[0] == 0\n    point_targets = points[..., 0:3]\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate targets of PointRCNN RPN head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    gt_bboxes_3d_tensor = gt_bboxes_3d.tensor.clone()\n    gt_bboxes_3d_tensor[..., 2] += gt_bboxes_3d_tensor[..., 5] / 2\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, points)\n    gt_bboxes_3d_tensor = gt_bboxes_3d_tensor[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    bbox_targets = self.bbox_coder.encode(gt_bboxes_3d_tensor, points[..., 0:3], mask_targets)\n    positive_mask = points_mask.max(1)[0] > 0\n    extend_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.enlarge_width)\n    (points_mask, _) = self._assign_targets_by_points_inside(extend_gt_bboxes_3d, points)\n    negative_mask = points_mask.max(1)[0] == 0\n    point_targets = points[..., 0:3]\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate targets of PointRCNN RPN head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    gt_bboxes_3d_tensor = gt_bboxes_3d.tensor.clone()\n    gt_bboxes_3d_tensor[..., 2] += gt_bboxes_3d_tensor[..., 5] / 2\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, points)\n    gt_bboxes_3d_tensor = gt_bboxes_3d_tensor[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    bbox_targets = self.bbox_coder.encode(gt_bboxes_3d_tensor, points[..., 0:3], mask_targets)\n    positive_mask = points_mask.max(1)[0] > 0\n    extend_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.enlarge_width)\n    (points_mask, _) = self._assign_targets_by_points_inside(extend_gt_bboxes_3d, points)\n    negative_mask = points_mask.max(1)[0] == 0\n    point_targets = points[..., 0:3]\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate targets of PointRCNN RPN head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    gt_bboxes_3d_tensor = gt_bboxes_3d.tensor.clone()\n    gt_bboxes_3d_tensor[..., 2] += gt_bboxes_3d_tensor[..., 5] / 2\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, points)\n    gt_bboxes_3d_tensor = gt_bboxes_3d_tensor[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    bbox_targets = self.bbox_coder.encode(gt_bboxes_3d_tensor, points[..., 0:3], mask_targets)\n    positive_mask = points_mask.max(1)[0] > 0\n    extend_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.enlarge_width)\n    (points_mask, _) = self._assign_targets_by_points_inside(extend_gt_bboxes_3d, points)\n    negative_mask = points_mask.max(1)[0] == 0\n    point_targets = points[..., 0:3]\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate targets of PointRCNN RPN head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    gt_bboxes_3d_tensor = gt_bboxes_3d.tensor.clone()\n    gt_bboxes_3d_tensor[..., 2] += gt_bboxes_3d_tensor[..., 5] / 2\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, points)\n    gt_bboxes_3d_tensor = gt_bboxes_3d_tensor[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    bbox_targets = self.bbox_coder.encode(gt_bboxes_3d_tensor, points[..., 0:3], mask_targets)\n    positive_mask = points_mask.max(1)[0] > 0\n    extend_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.enlarge_width)\n    (points_mask, _) = self._assign_targets_by_points_inside(extend_gt_bboxes_3d, points)\n    negative_mask = points_mask.max(1)[0] == 0\n    point_targets = points[..., 0:3]\n    return (bbox_targets, mask_targets, positive_mask, negative_mask, point_targets)"
        ]
    },
    {
        "func_name": "get_bboxes",
        "original": "def get_bboxes(self, points, bbox_preds, cls_preds, input_metas, rescale=False):\n    \"\"\"Generate bboxes from RPN head predictions.\n\n        Args:\n            points (torch.Tensor): Input points.\n            bbox_preds (dict): Regression predictions from PointRCNN head.\n            cls_preds (dict): Class scores predictions from PointRCNN head.\n            input_metas (list[dict]): Point cloud and image's meta info.\n            rescale (bool, optional): Whether to rescale bboxes.\n                Defaults to False.\n\n        Returns:\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\n        \"\"\"\n    sem_scores = cls_preds.sigmoid()\n    obj_scores = sem_scores.max(-1)[0]\n    object_class = sem_scores.argmax(dim=-1)\n    batch_size = sem_scores.shape[0]\n    results = list()\n    for b in range(batch_size):\n        bbox3d = self.bbox_coder.decode(bbox_preds[b], points[b, ..., :3], object_class[b])\n        mask = ~bbox3d.sum(dim=1).isinf()\n        (bbox_selected, score_selected, labels, cls_preds_selected) = self.class_agnostic_nms(obj_scores[b][mask], sem_scores[b][mask, :], bbox3d[mask, :], points[b, ..., :3][mask, :], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=True)\n        results.append((bbox, score_selected, labels, cls_preds_selected))\n    return results",
        "mutated": [
            "def get_bboxes(self, points, bbox_preds, cls_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n    \"Generate bboxes from RPN head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Regression predictions from PointRCNN head.\\n            cls_preds (dict): Class scores predictions from PointRCNN head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool, optional): Whether to rescale bboxes.\\n                Defaults to False.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = cls_preds.sigmoid()\n    obj_scores = sem_scores.max(-1)[0]\n    object_class = sem_scores.argmax(dim=-1)\n    batch_size = sem_scores.shape[0]\n    results = list()\n    for b in range(batch_size):\n        bbox3d = self.bbox_coder.decode(bbox_preds[b], points[b, ..., :3], object_class[b])\n        mask = ~bbox3d.sum(dim=1).isinf()\n        (bbox_selected, score_selected, labels, cls_preds_selected) = self.class_agnostic_nms(obj_scores[b][mask], sem_scores[b][mask, :], bbox3d[mask, :], points[b, ..., :3][mask, :], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=True)\n        results.append((bbox, score_selected, labels, cls_preds_selected))\n    return results",
            "def get_bboxes(self, points, bbox_preds, cls_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Generate bboxes from RPN head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Regression predictions from PointRCNN head.\\n            cls_preds (dict): Class scores predictions from PointRCNN head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool, optional): Whether to rescale bboxes.\\n                Defaults to False.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = cls_preds.sigmoid()\n    obj_scores = sem_scores.max(-1)[0]\n    object_class = sem_scores.argmax(dim=-1)\n    batch_size = sem_scores.shape[0]\n    results = list()\n    for b in range(batch_size):\n        bbox3d = self.bbox_coder.decode(bbox_preds[b], points[b, ..., :3], object_class[b])\n        mask = ~bbox3d.sum(dim=1).isinf()\n        (bbox_selected, score_selected, labels, cls_preds_selected) = self.class_agnostic_nms(obj_scores[b][mask], sem_scores[b][mask, :], bbox3d[mask, :], points[b, ..., :3][mask, :], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=True)\n        results.append((bbox, score_selected, labels, cls_preds_selected))\n    return results",
            "def get_bboxes(self, points, bbox_preds, cls_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Generate bboxes from RPN head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Regression predictions from PointRCNN head.\\n            cls_preds (dict): Class scores predictions from PointRCNN head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool, optional): Whether to rescale bboxes.\\n                Defaults to False.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = cls_preds.sigmoid()\n    obj_scores = sem_scores.max(-1)[0]\n    object_class = sem_scores.argmax(dim=-1)\n    batch_size = sem_scores.shape[0]\n    results = list()\n    for b in range(batch_size):\n        bbox3d = self.bbox_coder.decode(bbox_preds[b], points[b, ..., :3], object_class[b])\n        mask = ~bbox3d.sum(dim=1).isinf()\n        (bbox_selected, score_selected, labels, cls_preds_selected) = self.class_agnostic_nms(obj_scores[b][mask], sem_scores[b][mask, :], bbox3d[mask, :], points[b, ..., :3][mask, :], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=True)\n        results.append((bbox, score_selected, labels, cls_preds_selected))\n    return results",
            "def get_bboxes(self, points, bbox_preds, cls_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Generate bboxes from RPN head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Regression predictions from PointRCNN head.\\n            cls_preds (dict): Class scores predictions from PointRCNN head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool, optional): Whether to rescale bboxes.\\n                Defaults to False.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = cls_preds.sigmoid()\n    obj_scores = sem_scores.max(-1)[0]\n    object_class = sem_scores.argmax(dim=-1)\n    batch_size = sem_scores.shape[0]\n    results = list()\n    for b in range(batch_size):\n        bbox3d = self.bbox_coder.decode(bbox_preds[b], points[b, ..., :3], object_class[b])\n        mask = ~bbox3d.sum(dim=1).isinf()\n        (bbox_selected, score_selected, labels, cls_preds_selected) = self.class_agnostic_nms(obj_scores[b][mask], sem_scores[b][mask, :], bbox3d[mask, :], points[b, ..., :3][mask, :], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=True)\n        results.append((bbox, score_selected, labels, cls_preds_selected))\n    return results",
            "def get_bboxes(self, points, bbox_preds, cls_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Generate bboxes from RPN head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Regression predictions from PointRCNN head.\\n            cls_preds (dict): Class scores predictions from PointRCNN head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool, optional): Whether to rescale bboxes.\\n                Defaults to False.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = cls_preds.sigmoid()\n    obj_scores = sem_scores.max(-1)[0]\n    object_class = sem_scores.argmax(dim=-1)\n    batch_size = sem_scores.shape[0]\n    results = list()\n    for b in range(batch_size):\n        bbox3d = self.bbox_coder.decode(bbox_preds[b], points[b, ..., :3], object_class[b])\n        mask = ~bbox3d.sum(dim=1).isinf()\n        (bbox_selected, score_selected, labels, cls_preds_selected) = self.class_agnostic_nms(obj_scores[b][mask], sem_scores[b][mask, :], bbox3d[mask, :], points[b, ..., :3][mask, :], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=True)\n        results.append((bbox, score_selected, labels, cls_preds_selected))\n    return results"
        ]
    },
    {
        "func_name": "class_agnostic_nms",
        "original": "def class_agnostic_nms(self, obj_scores, sem_scores, bbox, points, input_meta):\n    \"\"\"Class agnostic nms.\n\n        Args:\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\n            bbox (torch.Tensor): Predicted bounding boxes.\n\n        Returns:\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\n        \"\"\"\n    nms_cfg = self.test_cfg.nms_cfg if not self.training else self.train_cfg.nms_cfg\n    if nms_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    num_bbox = bbox.shape[0]\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=True, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, LiDARInstance3DBoxes):\n        box_idx = bbox.points_in_boxes(points)\n        box_indices = box_idx.new_zeros([num_bbox + 1])\n        box_idx[box_idx == -1] = num_bbox\n        box_indices.scatter_add_(0, box_idx.long(), box_idx.new_ones(box_idx.shape))\n        box_indices = box_indices[:-1]\n        nonempty_box_mask = box_indices >= 0\n    elif isinstance(bbox, DepthInstance3DBoxes):\n        box_indices = bbox.points_in_boxes(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    bbox = bbox[nonempty_box_mask]\n    if self.test_cfg.score_thr is not None:\n        score_thr = self.test_cfg.score_thr\n        keep = obj_scores >= score_thr\n        obj_scores = obj_scores[keep]\n        sem_scores = sem_scores[keep]\n        bbox = bbox.tensor[keep]\n    if obj_scores.shape[0] > 0:\n        topk = min(nms_cfg.nms_pre, obj_scores.shape[0])\n        (obj_scores_nms, indices) = torch.topk(obj_scores, k=topk)\n        bbox_for_nms = xywhr2xyxyr(bbox[indices].bev)\n        sem_scores_nms = sem_scores[indices]\n        keep = nms_func(bbox_for_nms, obj_scores_nms, nms_cfg.iou_thr)\n        keep = keep[:nms_cfg.nms_post]\n        bbox_selected = bbox.tensor[indices][keep]\n        score_selected = obj_scores_nms[keep]\n        cls_preds = sem_scores_nms[keep]\n        labels = torch.argmax(cls_preds, -1)\n    else:\n        bbox_selected = bbox.tensor\n        score_selected = obj_scores.new_zeros([0])\n        labels = obj_scores.new_zeros([0])\n        cls_preds = obj_scores.new_zeros([0, sem_scores.shape[-1]])\n    return (bbox_selected, score_selected, labels, cls_preds)",
        "mutated": [
            "def class_agnostic_nms(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n    'Class agnostic nms.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        '\n    nms_cfg = self.test_cfg.nms_cfg if not self.training else self.train_cfg.nms_cfg\n    if nms_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    num_bbox = bbox.shape[0]\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=True, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, LiDARInstance3DBoxes):\n        box_idx = bbox.points_in_boxes(points)\n        box_indices = box_idx.new_zeros([num_bbox + 1])\n        box_idx[box_idx == -1] = num_bbox\n        box_indices.scatter_add_(0, box_idx.long(), box_idx.new_ones(box_idx.shape))\n        box_indices = box_indices[:-1]\n        nonempty_box_mask = box_indices >= 0\n    elif isinstance(bbox, DepthInstance3DBoxes):\n        box_indices = bbox.points_in_boxes(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    bbox = bbox[nonempty_box_mask]\n    if self.test_cfg.score_thr is not None:\n        score_thr = self.test_cfg.score_thr\n        keep = obj_scores >= score_thr\n        obj_scores = obj_scores[keep]\n        sem_scores = sem_scores[keep]\n        bbox = bbox.tensor[keep]\n    if obj_scores.shape[0] > 0:\n        topk = min(nms_cfg.nms_pre, obj_scores.shape[0])\n        (obj_scores_nms, indices) = torch.topk(obj_scores, k=topk)\n        bbox_for_nms = xywhr2xyxyr(bbox[indices].bev)\n        sem_scores_nms = sem_scores[indices]\n        keep = nms_func(bbox_for_nms, obj_scores_nms, nms_cfg.iou_thr)\n        keep = keep[:nms_cfg.nms_post]\n        bbox_selected = bbox.tensor[indices][keep]\n        score_selected = obj_scores_nms[keep]\n        cls_preds = sem_scores_nms[keep]\n        labels = torch.argmax(cls_preds, -1)\n    else:\n        bbox_selected = bbox.tensor\n        score_selected = obj_scores.new_zeros([0])\n        labels = obj_scores.new_zeros([0])\n        cls_preds = obj_scores.new_zeros([0, sem_scores.shape[-1]])\n    return (bbox_selected, score_selected, labels, cls_preds)",
            "def class_agnostic_nms(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Class agnostic nms.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        '\n    nms_cfg = self.test_cfg.nms_cfg if not self.training else self.train_cfg.nms_cfg\n    if nms_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    num_bbox = bbox.shape[0]\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=True, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, LiDARInstance3DBoxes):\n        box_idx = bbox.points_in_boxes(points)\n        box_indices = box_idx.new_zeros([num_bbox + 1])\n        box_idx[box_idx == -1] = num_bbox\n        box_indices.scatter_add_(0, box_idx.long(), box_idx.new_ones(box_idx.shape))\n        box_indices = box_indices[:-1]\n        nonempty_box_mask = box_indices >= 0\n    elif isinstance(bbox, DepthInstance3DBoxes):\n        box_indices = bbox.points_in_boxes(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    bbox = bbox[nonempty_box_mask]\n    if self.test_cfg.score_thr is not None:\n        score_thr = self.test_cfg.score_thr\n        keep = obj_scores >= score_thr\n        obj_scores = obj_scores[keep]\n        sem_scores = sem_scores[keep]\n        bbox = bbox.tensor[keep]\n    if obj_scores.shape[0] > 0:\n        topk = min(nms_cfg.nms_pre, obj_scores.shape[0])\n        (obj_scores_nms, indices) = torch.topk(obj_scores, k=topk)\n        bbox_for_nms = xywhr2xyxyr(bbox[indices].bev)\n        sem_scores_nms = sem_scores[indices]\n        keep = nms_func(bbox_for_nms, obj_scores_nms, nms_cfg.iou_thr)\n        keep = keep[:nms_cfg.nms_post]\n        bbox_selected = bbox.tensor[indices][keep]\n        score_selected = obj_scores_nms[keep]\n        cls_preds = sem_scores_nms[keep]\n        labels = torch.argmax(cls_preds, -1)\n    else:\n        bbox_selected = bbox.tensor\n        score_selected = obj_scores.new_zeros([0])\n        labels = obj_scores.new_zeros([0])\n        cls_preds = obj_scores.new_zeros([0, sem_scores.shape[-1]])\n    return (bbox_selected, score_selected, labels, cls_preds)",
            "def class_agnostic_nms(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Class agnostic nms.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        '\n    nms_cfg = self.test_cfg.nms_cfg if not self.training else self.train_cfg.nms_cfg\n    if nms_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    num_bbox = bbox.shape[0]\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=True, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, LiDARInstance3DBoxes):\n        box_idx = bbox.points_in_boxes(points)\n        box_indices = box_idx.new_zeros([num_bbox + 1])\n        box_idx[box_idx == -1] = num_bbox\n        box_indices.scatter_add_(0, box_idx.long(), box_idx.new_ones(box_idx.shape))\n        box_indices = box_indices[:-1]\n        nonempty_box_mask = box_indices >= 0\n    elif isinstance(bbox, DepthInstance3DBoxes):\n        box_indices = bbox.points_in_boxes(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    bbox = bbox[nonempty_box_mask]\n    if self.test_cfg.score_thr is not None:\n        score_thr = self.test_cfg.score_thr\n        keep = obj_scores >= score_thr\n        obj_scores = obj_scores[keep]\n        sem_scores = sem_scores[keep]\n        bbox = bbox.tensor[keep]\n    if obj_scores.shape[0] > 0:\n        topk = min(nms_cfg.nms_pre, obj_scores.shape[0])\n        (obj_scores_nms, indices) = torch.topk(obj_scores, k=topk)\n        bbox_for_nms = xywhr2xyxyr(bbox[indices].bev)\n        sem_scores_nms = sem_scores[indices]\n        keep = nms_func(bbox_for_nms, obj_scores_nms, nms_cfg.iou_thr)\n        keep = keep[:nms_cfg.nms_post]\n        bbox_selected = bbox.tensor[indices][keep]\n        score_selected = obj_scores_nms[keep]\n        cls_preds = sem_scores_nms[keep]\n        labels = torch.argmax(cls_preds, -1)\n    else:\n        bbox_selected = bbox.tensor\n        score_selected = obj_scores.new_zeros([0])\n        labels = obj_scores.new_zeros([0])\n        cls_preds = obj_scores.new_zeros([0, sem_scores.shape[-1]])\n    return (bbox_selected, score_selected, labels, cls_preds)",
            "def class_agnostic_nms(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Class agnostic nms.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        '\n    nms_cfg = self.test_cfg.nms_cfg if not self.training else self.train_cfg.nms_cfg\n    if nms_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    num_bbox = bbox.shape[0]\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=True, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, LiDARInstance3DBoxes):\n        box_idx = bbox.points_in_boxes(points)\n        box_indices = box_idx.new_zeros([num_bbox + 1])\n        box_idx[box_idx == -1] = num_bbox\n        box_indices.scatter_add_(0, box_idx.long(), box_idx.new_ones(box_idx.shape))\n        box_indices = box_indices[:-1]\n        nonempty_box_mask = box_indices >= 0\n    elif isinstance(bbox, DepthInstance3DBoxes):\n        box_indices = bbox.points_in_boxes(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    bbox = bbox[nonempty_box_mask]\n    if self.test_cfg.score_thr is not None:\n        score_thr = self.test_cfg.score_thr\n        keep = obj_scores >= score_thr\n        obj_scores = obj_scores[keep]\n        sem_scores = sem_scores[keep]\n        bbox = bbox.tensor[keep]\n    if obj_scores.shape[0] > 0:\n        topk = min(nms_cfg.nms_pre, obj_scores.shape[0])\n        (obj_scores_nms, indices) = torch.topk(obj_scores, k=topk)\n        bbox_for_nms = xywhr2xyxyr(bbox[indices].bev)\n        sem_scores_nms = sem_scores[indices]\n        keep = nms_func(bbox_for_nms, obj_scores_nms, nms_cfg.iou_thr)\n        keep = keep[:nms_cfg.nms_post]\n        bbox_selected = bbox.tensor[indices][keep]\n        score_selected = obj_scores_nms[keep]\n        cls_preds = sem_scores_nms[keep]\n        labels = torch.argmax(cls_preds, -1)\n    else:\n        bbox_selected = bbox.tensor\n        score_selected = obj_scores.new_zeros([0])\n        labels = obj_scores.new_zeros([0])\n        cls_preds = obj_scores.new_zeros([0, sem_scores.shape[-1]])\n    return (bbox_selected, score_selected, labels, cls_preds)",
            "def class_agnostic_nms(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Class agnostic nms.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        '\n    nms_cfg = self.test_cfg.nms_cfg if not self.training else self.train_cfg.nms_cfg\n    if nms_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    num_bbox = bbox.shape[0]\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=True, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, LiDARInstance3DBoxes):\n        box_idx = bbox.points_in_boxes(points)\n        box_indices = box_idx.new_zeros([num_bbox + 1])\n        box_idx[box_idx == -1] = num_bbox\n        box_indices.scatter_add_(0, box_idx.long(), box_idx.new_ones(box_idx.shape))\n        box_indices = box_indices[:-1]\n        nonempty_box_mask = box_indices >= 0\n    elif isinstance(bbox, DepthInstance3DBoxes):\n        box_indices = bbox.points_in_boxes(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    bbox = bbox[nonempty_box_mask]\n    if self.test_cfg.score_thr is not None:\n        score_thr = self.test_cfg.score_thr\n        keep = obj_scores >= score_thr\n        obj_scores = obj_scores[keep]\n        sem_scores = sem_scores[keep]\n        bbox = bbox.tensor[keep]\n    if obj_scores.shape[0] > 0:\n        topk = min(nms_cfg.nms_pre, obj_scores.shape[0])\n        (obj_scores_nms, indices) = torch.topk(obj_scores, k=topk)\n        bbox_for_nms = xywhr2xyxyr(bbox[indices].bev)\n        sem_scores_nms = sem_scores[indices]\n        keep = nms_func(bbox_for_nms, obj_scores_nms, nms_cfg.iou_thr)\n        keep = keep[:nms_cfg.nms_post]\n        bbox_selected = bbox.tensor[indices][keep]\n        score_selected = obj_scores_nms[keep]\n        cls_preds = sem_scores_nms[keep]\n        labels = torch.argmax(cls_preds, -1)\n    else:\n        bbox_selected = bbox.tensor\n        score_selected = obj_scores.new_zeros([0])\n        labels = obj_scores.new_zeros([0])\n        cls_preds = obj_scores.new_zeros([0, sem_scores.shape[-1]])\n    return (bbox_selected, score_selected, labels, cls_preds)"
        ]
    },
    {
        "func_name": "_assign_targets_by_points_inside",
        "original": "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    \"\"\"Compute assignment by checking whether point is inside bbox.\n\n        Args:\n            bboxes_3d (:obj:`BaseInstance3DBoxes`): Instance of bounding boxes.\n            points (torch.Tensor): Points of a batch.\n\n        Returns:\n            tuple[torch.Tensor]: Flags indicating whether each point is\n                inside bbox and the index of box where each point are in.\n        \"\"\"\n    num_bbox = bboxes_3d.tensor.shape[0]\n    if isinstance(bboxes_3d, LiDARInstance3DBoxes):\n        assignment = bboxes_3d.points_in_boxes(points[:, 0:3]).long()\n        points_mask = assignment.new_zeros([assignment.shape[0], num_bbox + 1])\n        assignment[assignment == -1] = num_bbox\n        points_mask.scatter_(1, assignment.unsqueeze(1), 1)\n        points_mask = points_mask[:, :-1]\n        assignment[assignment == num_bbox] = num_bbox - 1\n    elif isinstance(bboxes_3d, DepthInstance3DBoxes):\n        points_mask = bboxes_3d.points_in_boxes(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
        "mutated": [
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (:obj:`BaseInstance3DBoxes`): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    num_bbox = bboxes_3d.tensor.shape[0]\n    if isinstance(bboxes_3d, LiDARInstance3DBoxes):\n        assignment = bboxes_3d.points_in_boxes(points[:, 0:3]).long()\n        points_mask = assignment.new_zeros([assignment.shape[0], num_bbox + 1])\n        assignment[assignment == -1] = num_bbox\n        points_mask.scatter_(1, assignment.unsqueeze(1), 1)\n        points_mask = points_mask[:, :-1]\n        assignment[assignment == num_bbox] = num_bbox - 1\n    elif isinstance(bboxes_3d, DepthInstance3DBoxes):\n        points_mask = bboxes_3d.points_in_boxes(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (:obj:`BaseInstance3DBoxes`): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    num_bbox = bboxes_3d.tensor.shape[0]\n    if isinstance(bboxes_3d, LiDARInstance3DBoxes):\n        assignment = bboxes_3d.points_in_boxes(points[:, 0:3]).long()\n        points_mask = assignment.new_zeros([assignment.shape[0], num_bbox + 1])\n        assignment[assignment == -1] = num_bbox\n        points_mask.scatter_(1, assignment.unsqueeze(1), 1)\n        points_mask = points_mask[:, :-1]\n        assignment[assignment == num_bbox] = num_bbox - 1\n    elif isinstance(bboxes_3d, DepthInstance3DBoxes):\n        points_mask = bboxes_3d.points_in_boxes(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (:obj:`BaseInstance3DBoxes`): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    num_bbox = bboxes_3d.tensor.shape[0]\n    if isinstance(bboxes_3d, LiDARInstance3DBoxes):\n        assignment = bboxes_3d.points_in_boxes(points[:, 0:3]).long()\n        points_mask = assignment.new_zeros([assignment.shape[0], num_bbox + 1])\n        assignment[assignment == -1] = num_bbox\n        points_mask.scatter_(1, assignment.unsqueeze(1), 1)\n        points_mask = points_mask[:, :-1]\n        assignment[assignment == num_bbox] = num_bbox - 1\n    elif isinstance(bboxes_3d, DepthInstance3DBoxes):\n        points_mask = bboxes_3d.points_in_boxes(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (:obj:`BaseInstance3DBoxes`): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    num_bbox = bboxes_3d.tensor.shape[0]\n    if isinstance(bboxes_3d, LiDARInstance3DBoxes):\n        assignment = bboxes_3d.points_in_boxes(points[:, 0:3]).long()\n        points_mask = assignment.new_zeros([assignment.shape[0], num_bbox + 1])\n        assignment[assignment == -1] = num_bbox\n        points_mask.scatter_(1, assignment.unsqueeze(1), 1)\n        points_mask = points_mask[:, :-1]\n        assignment[assignment == num_bbox] = num_bbox - 1\n    elif isinstance(bboxes_3d, DepthInstance3DBoxes):\n        points_mask = bboxes_3d.points_in_boxes(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (:obj:`BaseInstance3DBoxes`): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    num_bbox = bboxes_3d.tensor.shape[0]\n    if isinstance(bboxes_3d, LiDARInstance3DBoxes):\n        assignment = bboxes_3d.points_in_boxes(points[:, 0:3]).long()\n        points_mask = assignment.new_zeros([assignment.shape[0], num_bbox + 1])\n        assignment[assignment == -1] = num_bbox\n        points_mask.scatter_(1, assignment.unsqueeze(1), 1)\n        points_mask = points_mask[:, :-1]\n        assignment[assignment == num_bbox] = num_bbox - 1\n    elif isinstance(bboxes_3d, DepthInstance3DBoxes):\n        points_mask = bboxes_3d.points_in_boxes(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)"
        ]
    }
]