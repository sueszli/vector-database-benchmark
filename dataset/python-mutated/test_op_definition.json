[
    {
        "func_name": "the_op_fn",
        "original": "def the_op_fn(_, inputs):\n    assert inputs['x'] == 5\n    yield Output(inputs['x'] + 1, output_name='the_output')",
        "mutated": [
            "def the_op_fn(_, inputs):\n    if False:\n        i = 10\n    assert inputs['x'] == 5\n    yield Output(inputs['x'] + 1, output_name='the_output')",
            "def the_op_fn(_, inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert inputs['x'] == 5\n    yield Output(inputs['x'] + 1, output_name='the_output')",
            "def the_op_fn(_, inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert inputs['x'] == 5\n    yield Output(inputs['x'] + 1, output_name='the_output')",
            "def the_op_fn(_, inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert inputs['x'] == 5\n    yield Output(inputs['x'] + 1, output_name='the_output')",
            "def the_op_fn(_, inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert inputs['x'] == 5\n    yield Output(inputs['x'] + 1, output_name='the_output')"
        ]
    },
    {
        "func_name": "the_job",
        "original": "@job\ndef the_job(x):\n    op_def(x)",
        "mutated": [
            "@job\ndef the_job(x):\n    if False:\n        i = 10\n    op_def(x)",
            "@job\ndef the_job(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    op_def(x)",
            "@job\ndef the_job(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    op_def(x)",
            "@job\ndef the_job(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    op_def(x)",
            "@job\ndef the_job(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    op_def(x)"
        ]
    },
    {
        "func_name": "test_op_def_direct",
        "original": "def test_op_def_direct():\n\n    def the_op_fn(_, inputs):\n        assert inputs['x'] == 5\n        yield Output(inputs['x'] + 1, output_name='the_output')\n    op_def = OpDefinition(the_op_fn, 'the_op', ins={'x': In(dagster_type=int)}, outs={'the_output': Out(int)})\n\n    @job\n    def the_job(x):\n        op_def(x)\n    result = the_job.execute_in_process(input_values={'x': 5})\n    assert result.success",
        "mutated": [
            "def test_op_def_direct():\n    if False:\n        i = 10\n\n    def the_op_fn(_, inputs):\n        assert inputs['x'] == 5\n        yield Output(inputs['x'] + 1, output_name='the_output')\n    op_def = OpDefinition(the_op_fn, 'the_op', ins={'x': In(dagster_type=int)}, outs={'the_output': Out(int)})\n\n    @job\n    def the_job(x):\n        op_def(x)\n    result = the_job.execute_in_process(input_values={'x': 5})\n    assert result.success",
            "def test_op_def_direct():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def the_op_fn(_, inputs):\n        assert inputs['x'] == 5\n        yield Output(inputs['x'] + 1, output_name='the_output')\n    op_def = OpDefinition(the_op_fn, 'the_op', ins={'x': In(dagster_type=int)}, outs={'the_output': Out(int)})\n\n    @job\n    def the_job(x):\n        op_def(x)\n    result = the_job.execute_in_process(input_values={'x': 5})\n    assert result.success",
            "def test_op_def_direct():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def the_op_fn(_, inputs):\n        assert inputs['x'] == 5\n        yield Output(inputs['x'] + 1, output_name='the_output')\n    op_def = OpDefinition(the_op_fn, 'the_op', ins={'x': In(dagster_type=int)}, outs={'the_output': Out(int)})\n\n    @job\n    def the_job(x):\n        op_def(x)\n    result = the_job.execute_in_process(input_values={'x': 5})\n    assert result.success",
            "def test_op_def_direct():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def the_op_fn(_, inputs):\n        assert inputs['x'] == 5\n        yield Output(inputs['x'] + 1, output_name='the_output')\n    op_def = OpDefinition(the_op_fn, 'the_op', ins={'x': In(dagster_type=int)}, outs={'the_output': Out(int)})\n\n    @job\n    def the_job(x):\n        op_def(x)\n    result = the_job.execute_in_process(input_values={'x': 5})\n    assert result.success",
            "def test_op_def_direct():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def the_op_fn(_, inputs):\n        assert inputs['x'] == 5\n        yield Output(inputs['x'] + 1, output_name='the_output')\n    op_def = OpDefinition(the_op_fn, 'the_op', ins={'x': In(dagster_type=int)}, outs={'the_output': Out(int)})\n\n    @job\n    def the_job(x):\n        op_def(x)\n    result = the_job.execute_in_process(input_values={'x': 5})\n    assert result.success"
        ]
    },
    {
        "func_name": "implicit",
        "original": "@op(out={'a': Out(Nothing), 'b': Out(Nothing)})\ndef implicit():\n    pass",
        "mutated": [
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing)})\ndef implicit():\n    if False:\n        i = 10\n    pass",
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing)})\ndef implicit():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing)})\ndef implicit():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing)})\ndef implicit():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing)})\ndef implicit():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "implicit_job",
        "original": "@job\ndef implicit_job():\n    implicit()",
        "mutated": [
            "@job\ndef implicit_job():\n    if False:\n        i = 10\n    implicit()",
            "@job\ndef implicit_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    implicit()",
            "@job\ndef implicit_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    implicit()",
            "@job\ndef implicit_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    implicit()",
            "@job\ndef implicit_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    implicit()"
        ]
    },
    {
        "func_name": "optional",
        "original": "@op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\ndef optional():\n    pass",
        "mutated": [
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\ndef optional():\n    if False:\n        i = 10\n    pass",
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\ndef optional():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\ndef optional():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\ndef optional():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "@op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\ndef optional():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "optional_job",
        "original": "@job\ndef optional_job():\n    optional()",
        "mutated": [
            "@job\ndef optional_job():\n    if False:\n        i = 10\n    optional()",
            "@job\ndef optional_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    optional()",
            "@job\ndef optional_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    optional()",
            "@job\ndef optional_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    optional()",
            "@job\ndef optional_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    optional()"
        ]
    },
    {
        "func_name": "untyped",
        "original": "@op(out={'a': Out(), 'b': Out()})\ndef untyped():\n    pass",
        "mutated": [
            "@op(out={'a': Out(), 'b': Out()})\ndef untyped():\n    if False:\n        i = 10\n    pass",
            "@op(out={'a': Out(), 'b': Out()})\ndef untyped():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "@op(out={'a': Out(), 'b': Out()})\ndef untyped():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "@op(out={'a': Out(), 'b': Out()})\ndef untyped():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "@op(out={'a': Out(), 'b': Out()})\ndef untyped():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "untyped_job",
        "original": "@job\ndef untyped_job():\n    untyped()",
        "mutated": [
            "@job\ndef untyped_job():\n    if False:\n        i = 10\n    untyped()",
            "@job\ndef untyped_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    untyped()",
            "@job\ndef untyped_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    untyped()",
            "@job\ndef untyped_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    untyped()",
            "@job\ndef untyped_job():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    untyped()"
        ]
    },
    {
        "func_name": "test_multi_out_implicit_none",
        "original": "def test_multi_out_implicit_none():\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing)})\n    def implicit():\n        pass\n    implicit()\n\n    @job\n    def implicit_job():\n        implicit()\n    result = implicit_job.execute_in_process()\n    assert result.success\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\n    def optional():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional()\n\n    @job\n    def optional_job():\n        optional()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional_job.execute_in_process()\n\n    @op(out={'a': Out(), 'b': Out()})\n    def untyped():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped()\n\n    @job\n    def untyped_job():\n        untyped()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped_job.execute_in_process()",
        "mutated": [
            "def test_multi_out_implicit_none():\n    if False:\n        i = 10\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing)})\n    def implicit():\n        pass\n    implicit()\n\n    @job\n    def implicit_job():\n        implicit()\n    result = implicit_job.execute_in_process()\n    assert result.success\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\n    def optional():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional()\n\n    @job\n    def optional_job():\n        optional()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional_job.execute_in_process()\n\n    @op(out={'a': Out(), 'b': Out()})\n    def untyped():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped()\n\n    @job\n    def untyped_job():\n        untyped()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped_job.execute_in_process()",
            "def test_multi_out_implicit_none():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing)})\n    def implicit():\n        pass\n    implicit()\n\n    @job\n    def implicit_job():\n        implicit()\n    result = implicit_job.execute_in_process()\n    assert result.success\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\n    def optional():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional()\n\n    @job\n    def optional_job():\n        optional()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional_job.execute_in_process()\n\n    @op(out={'a': Out(), 'b': Out()})\n    def untyped():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped()\n\n    @job\n    def untyped_job():\n        untyped()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped_job.execute_in_process()",
            "def test_multi_out_implicit_none():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing)})\n    def implicit():\n        pass\n    implicit()\n\n    @job\n    def implicit_job():\n        implicit()\n    result = implicit_job.execute_in_process()\n    assert result.success\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\n    def optional():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional()\n\n    @job\n    def optional_job():\n        optional()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional_job.execute_in_process()\n\n    @op(out={'a': Out(), 'b': Out()})\n    def untyped():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped()\n\n    @job\n    def untyped_job():\n        untyped()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped_job.execute_in_process()",
            "def test_multi_out_implicit_none():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing)})\n    def implicit():\n        pass\n    implicit()\n\n    @job\n    def implicit_job():\n        implicit()\n    result = implicit_job.execute_in_process()\n    assert result.success\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\n    def optional():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional()\n\n    @job\n    def optional_job():\n        optional()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional_job.execute_in_process()\n\n    @op(out={'a': Out(), 'b': Out()})\n    def untyped():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped()\n\n    @job\n    def untyped_job():\n        untyped()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped_job.execute_in_process()",
            "def test_multi_out_implicit_none():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing)})\n    def implicit():\n        pass\n    implicit()\n\n    @job\n    def implicit_job():\n        implicit()\n    result = implicit_job.execute_in_process()\n    assert result.success\n\n    @op(out={'a': Out(Nothing), 'b': Out(Nothing, is_required=False)})\n    def optional():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional()\n\n    @job\n    def optional_job():\n        optional()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        optional_job.execute_in_process()\n\n    @op(out={'a': Out(), 'b': Out()})\n    def untyped():\n        pass\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped()\n\n    @job\n    def untyped_job():\n        untyped()\n    with pytest.raises(DagsterInvariantViolationError, match='has multiple outputs, but only one output was returned'):\n        untyped_job.execute_in_process()"
        ]
    }
]