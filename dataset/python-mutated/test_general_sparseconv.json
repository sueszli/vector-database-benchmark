[
    {
        "func_name": "sparse_conv_infeats",
        "original": "def sparse_conv_infeats(inp_features):\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
        "mutated": [
            "def sparse_conv_infeats(inp_features):\n    if False:\n        i = 10\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_infeats(inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_infeats(inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_infeats(inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_infeats(inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)"
        ]
    },
    {
        "func_name": "sparse_conv_filter",
        "original": "def sparse_conv_filter(filters):\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
        "mutated": [
            "def sparse_conv_filter(filters):\n    if False:\n        i = 10\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_filter(filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_filter(filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_filter(filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_filter(filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)"
        ]
    },
    {
        "func_name": "sparse_conv_filter_backprop",
        "original": "def sparse_conv_filter_backprop(out_features_gradient, filters):\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
        "mutated": [
            "def sparse_conv_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)"
        ]
    },
    {
        "func_name": "sparse_conv_infeat_backprop",
        "original": "def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
        "mutated": [
            "def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)"
        ]
    },
    {
        "func_name": "sparse_conv_transpose_filter",
        "original": "def sparse_conv_transpose_filter(filters):\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
        "mutated": [
            "def sparse_conv_transpose_filter(filters):\n    if False:\n        i = 10\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_filter(filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_filter(filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_filter(filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_filter(filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)"
        ]
    },
    {
        "func_name": "sparse_conv_transpose_infeats",
        "original": "def sparse_conv_transpose_infeats(inp_features):\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
        "mutated": [
            "def sparse_conv_transpose_infeats(inp_features):\n    if False:\n        i = 10\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_infeats(inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_infeats(inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_infeats(inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_infeats(inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)"
        ]
    },
    {
        "func_name": "sparse_conv_transpose_filter_backprop",
        "original": "def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
        "mutated": [
            "def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)"
        ]
    },
    {
        "func_name": "sparse_conv_transpose_infeat_backprop",
        "original": "def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
        "mutated": [
            "def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)",
            "def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)"
        ]
    },
    {
        "func_name": "test_sparseconv_gradient",
        "original": "@pytest.mark.parametrize('kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization', [(1, 2, 7, True, False, False), (2, 1, 1, False, False, False), (3, 5, 3, False, True, True), (33, 3, 4, False, True, False)])\n@mltest.parametrize.ml\n@pytest.mark.parametrize('dtype', [np.float32])\ndef test_sparseconv_gradient(ml, dtype, kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization):\n    if dtype == np.float64:\n        tolerance = {'atol': 1e-05, 'rtol': 0.01, 'epsilon': 1e-06}\n    elif dtype == np.float32:\n        tolerance = {'atol': 0.01, 'rtol': 0.1, 'epsilon': 0.001}\n    rng = np.random.RandomState(123)\n    conv_attrs = {'normalize': with_normalization}\n    filters = rng.random(size=(kernel_size, in_channels, out_channels)).astype(dtype)\n    num_inp = 33\n    num_out = 16\n    inp_features = rng.uniform(size=(num_inp, in_channels)).astype(dtype)\n    if with_inp_importance:\n        inp_importance = rng.random(num_inp).astype(dtype)\n    else:\n        inp_importance = np.empty((0,)).astype(dtype)\n    neighbors_row_splits = np.zeros((num_out + 1,), dtype=np.int64)\n    for i in range(num_out):\n        neighbors_row_splits[i + 1] = rng.randint(kernel_size + 1) + neighbors_row_splits[i]\n    neighbors_index = np.zeros((neighbors_row_splits[-1],), dtype=np.int32)\n    neighbors_kernel_index = np.zeros((neighbors_row_splits[-1],), dtype=np.uint8)\n    for i in range(num_out):\n        start = neighbors_row_splits[i]\n        end = neighbors_row_splits[i + 1]\n        neighbors_kernel_index[start:end] = rng.choice(kernel_size, [end - start], replace=False)\n        neighbors_index[start:end] = rng.choice(num_inp, [end - start], replace=False)\n    arange = np.arange(neighbors_index.shape[0])\n    (inv_neighbors_index, inv_neighbors_row_splits, inv_arange) = mltest.run_op(ml, ml.device, False, ml.ops.invert_neighbors_list, num_inp, neighbors_index, neighbors_row_splits, arange)\n    inv_neighbors_kernel_index = neighbors_kernel_index[inv_arange]\n    if with_neighbors_importance:\n        neighbors_importance = rng.random(neighbors_index.shape[0]).astype(dtype) - 0.5\n        neighbors_importance_sum = mltest.run_op(ml, ml.device, False, ml.ops.reduce_subarrays_sum, neighbors_importance, neighbors_row_splits)\n        inv_neighbors_importance = neighbors_importance[inv_arange]\n    else:\n        neighbors_importance = np.empty((0,), dtype=dtype)\n        neighbors_importance_sum = np.empty((0,), dtype=dtype)\n        inv_neighbors_importance = np.empty((0,), dtype=dtype)\n\n    def sparse_conv_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n    y_arr = sparse_conv_infeats(inp_features)\n    dbg = {}\n    filter_gradient_OK = check_gradients(filters, sparse_conv_filter, sparse_conv_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert filter_gradient_OK\n    feature_gradient_OK = check_gradients(inp_features, sparse_conv_infeats, sparse_conv_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert feature_gradient_OK\n    transpose_filter_gradient_OK = check_gradients(filters.transpose([0, 2, 1]), sparse_conv_transpose_filter, sparse_conv_transpose_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_filter_gradient_OK\n    transpose_feature_gradient_OK = check_gradients(y_arr, sparse_conv_transpose_infeats, sparse_conv_transpose_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_feature_gradient_OK",
        "mutated": [
            "@pytest.mark.parametrize('kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization', [(1, 2, 7, True, False, False), (2, 1, 1, False, False, False), (3, 5, 3, False, True, True), (33, 3, 4, False, True, False)])\n@mltest.parametrize.ml\n@pytest.mark.parametrize('dtype', [np.float32])\ndef test_sparseconv_gradient(ml, dtype, kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization):\n    if False:\n        i = 10\n    if dtype == np.float64:\n        tolerance = {'atol': 1e-05, 'rtol': 0.01, 'epsilon': 1e-06}\n    elif dtype == np.float32:\n        tolerance = {'atol': 0.01, 'rtol': 0.1, 'epsilon': 0.001}\n    rng = np.random.RandomState(123)\n    conv_attrs = {'normalize': with_normalization}\n    filters = rng.random(size=(kernel_size, in_channels, out_channels)).astype(dtype)\n    num_inp = 33\n    num_out = 16\n    inp_features = rng.uniform(size=(num_inp, in_channels)).astype(dtype)\n    if with_inp_importance:\n        inp_importance = rng.random(num_inp).astype(dtype)\n    else:\n        inp_importance = np.empty((0,)).astype(dtype)\n    neighbors_row_splits = np.zeros((num_out + 1,), dtype=np.int64)\n    for i in range(num_out):\n        neighbors_row_splits[i + 1] = rng.randint(kernel_size + 1) + neighbors_row_splits[i]\n    neighbors_index = np.zeros((neighbors_row_splits[-1],), dtype=np.int32)\n    neighbors_kernel_index = np.zeros((neighbors_row_splits[-1],), dtype=np.uint8)\n    for i in range(num_out):\n        start = neighbors_row_splits[i]\n        end = neighbors_row_splits[i + 1]\n        neighbors_kernel_index[start:end] = rng.choice(kernel_size, [end - start], replace=False)\n        neighbors_index[start:end] = rng.choice(num_inp, [end - start], replace=False)\n    arange = np.arange(neighbors_index.shape[0])\n    (inv_neighbors_index, inv_neighbors_row_splits, inv_arange) = mltest.run_op(ml, ml.device, False, ml.ops.invert_neighbors_list, num_inp, neighbors_index, neighbors_row_splits, arange)\n    inv_neighbors_kernel_index = neighbors_kernel_index[inv_arange]\n    if with_neighbors_importance:\n        neighbors_importance = rng.random(neighbors_index.shape[0]).astype(dtype) - 0.5\n        neighbors_importance_sum = mltest.run_op(ml, ml.device, False, ml.ops.reduce_subarrays_sum, neighbors_importance, neighbors_row_splits)\n        inv_neighbors_importance = neighbors_importance[inv_arange]\n    else:\n        neighbors_importance = np.empty((0,), dtype=dtype)\n        neighbors_importance_sum = np.empty((0,), dtype=dtype)\n        inv_neighbors_importance = np.empty((0,), dtype=dtype)\n\n    def sparse_conv_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n    y_arr = sparse_conv_infeats(inp_features)\n    dbg = {}\n    filter_gradient_OK = check_gradients(filters, sparse_conv_filter, sparse_conv_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert filter_gradient_OK\n    feature_gradient_OK = check_gradients(inp_features, sparse_conv_infeats, sparse_conv_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert feature_gradient_OK\n    transpose_filter_gradient_OK = check_gradients(filters.transpose([0, 2, 1]), sparse_conv_transpose_filter, sparse_conv_transpose_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_filter_gradient_OK\n    transpose_feature_gradient_OK = check_gradients(y_arr, sparse_conv_transpose_infeats, sparse_conv_transpose_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_feature_gradient_OK",
            "@pytest.mark.parametrize('kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization', [(1, 2, 7, True, False, False), (2, 1, 1, False, False, False), (3, 5, 3, False, True, True), (33, 3, 4, False, True, False)])\n@mltest.parametrize.ml\n@pytest.mark.parametrize('dtype', [np.float32])\ndef test_sparseconv_gradient(ml, dtype, kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if dtype == np.float64:\n        tolerance = {'atol': 1e-05, 'rtol': 0.01, 'epsilon': 1e-06}\n    elif dtype == np.float32:\n        tolerance = {'atol': 0.01, 'rtol': 0.1, 'epsilon': 0.001}\n    rng = np.random.RandomState(123)\n    conv_attrs = {'normalize': with_normalization}\n    filters = rng.random(size=(kernel_size, in_channels, out_channels)).astype(dtype)\n    num_inp = 33\n    num_out = 16\n    inp_features = rng.uniform(size=(num_inp, in_channels)).astype(dtype)\n    if with_inp_importance:\n        inp_importance = rng.random(num_inp).astype(dtype)\n    else:\n        inp_importance = np.empty((0,)).astype(dtype)\n    neighbors_row_splits = np.zeros((num_out + 1,), dtype=np.int64)\n    for i in range(num_out):\n        neighbors_row_splits[i + 1] = rng.randint(kernel_size + 1) + neighbors_row_splits[i]\n    neighbors_index = np.zeros((neighbors_row_splits[-1],), dtype=np.int32)\n    neighbors_kernel_index = np.zeros((neighbors_row_splits[-1],), dtype=np.uint8)\n    for i in range(num_out):\n        start = neighbors_row_splits[i]\n        end = neighbors_row_splits[i + 1]\n        neighbors_kernel_index[start:end] = rng.choice(kernel_size, [end - start], replace=False)\n        neighbors_index[start:end] = rng.choice(num_inp, [end - start], replace=False)\n    arange = np.arange(neighbors_index.shape[0])\n    (inv_neighbors_index, inv_neighbors_row_splits, inv_arange) = mltest.run_op(ml, ml.device, False, ml.ops.invert_neighbors_list, num_inp, neighbors_index, neighbors_row_splits, arange)\n    inv_neighbors_kernel_index = neighbors_kernel_index[inv_arange]\n    if with_neighbors_importance:\n        neighbors_importance = rng.random(neighbors_index.shape[0]).astype(dtype) - 0.5\n        neighbors_importance_sum = mltest.run_op(ml, ml.device, False, ml.ops.reduce_subarrays_sum, neighbors_importance, neighbors_row_splits)\n        inv_neighbors_importance = neighbors_importance[inv_arange]\n    else:\n        neighbors_importance = np.empty((0,), dtype=dtype)\n        neighbors_importance_sum = np.empty((0,), dtype=dtype)\n        inv_neighbors_importance = np.empty((0,), dtype=dtype)\n\n    def sparse_conv_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n    y_arr = sparse_conv_infeats(inp_features)\n    dbg = {}\n    filter_gradient_OK = check_gradients(filters, sparse_conv_filter, sparse_conv_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert filter_gradient_OK\n    feature_gradient_OK = check_gradients(inp_features, sparse_conv_infeats, sparse_conv_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert feature_gradient_OK\n    transpose_filter_gradient_OK = check_gradients(filters.transpose([0, 2, 1]), sparse_conv_transpose_filter, sparse_conv_transpose_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_filter_gradient_OK\n    transpose_feature_gradient_OK = check_gradients(y_arr, sparse_conv_transpose_infeats, sparse_conv_transpose_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_feature_gradient_OK",
            "@pytest.mark.parametrize('kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization', [(1, 2, 7, True, False, False), (2, 1, 1, False, False, False), (3, 5, 3, False, True, True), (33, 3, 4, False, True, False)])\n@mltest.parametrize.ml\n@pytest.mark.parametrize('dtype', [np.float32])\ndef test_sparseconv_gradient(ml, dtype, kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if dtype == np.float64:\n        tolerance = {'atol': 1e-05, 'rtol': 0.01, 'epsilon': 1e-06}\n    elif dtype == np.float32:\n        tolerance = {'atol': 0.01, 'rtol': 0.1, 'epsilon': 0.001}\n    rng = np.random.RandomState(123)\n    conv_attrs = {'normalize': with_normalization}\n    filters = rng.random(size=(kernel_size, in_channels, out_channels)).astype(dtype)\n    num_inp = 33\n    num_out = 16\n    inp_features = rng.uniform(size=(num_inp, in_channels)).astype(dtype)\n    if with_inp_importance:\n        inp_importance = rng.random(num_inp).astype(dtype)\n    else:\n        inp_importance = np.empty((0,)).astype(dtype)\n    neighbors_row_splits = np.zeros((num_out + 1,), dtype=np.int64)\n    for i in range(num_out):\n        neighbors_row_splits[i + 1] = rng.randint(kernel_size + 1) + neighbors_row_splits[i]\n    neighbors_index = np.zeros((neighbors_row_splits[-1],), dtype=np.int32)\n    neighbors_kernel_index = np.zeros((neighbors_row_splits[-1],), dtype=np.uint8)\n    for i in range(num_out):\n        start = neighbors_row_splits[i]\n        end = neighbors_row_splits[i + 1]\n        neighbors_kernel_index[start:end] = rng.choice(kernel_size, [end - start], replace=False)\n        neighbors_index[start:end] = rng.choice(num_inp, [end - start], replace=False)\n    arange = np.arange(neighbors_index.shape[0])\n    (inv_neighbors_index, inv_neighbors_row_splits, inv_arange) = mltest.run_op(ml, ml.device, False, ml.ops.invert_neighbors_list, num_inp, neighbors_index, neighbors_row_splits, arange)\n    inv_neighbors_kernel_index = neighbors_kernel_index[inv_arange]\n    if with_neighbors_importance:\n        neighbors_importance = rng.random(neighbors_index.shape[0]).astype(dtype) - 0.5\n        neighbors_importance_sum = mltest.run_op(ml, ml.device, False, ml.ops.reduce_subarrays_sum, neighbors_importance, neighbors_row_splits)\n        inv_neighbors_importance = neighbors_importance[inv_arange]\n    else:\n        neighbors_importance = np.empty((0,), dtype=dtype)\n        neighbors_importance_sum = np.empty((0,), dtype=dtype)\n        inv_neighbors_importance = np.empty((0,), dtype=dtype)\n\n    def sparse_conv_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n    y_arr = sparse_conv_infeats(inp_features)\n    dbg = {}\n    filter_gradient_OK = check_gradients(filters, sparse_conv_filter, sparse_conv_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert filter_gradient_OK\n    feature_gradient_OK = check_gradients(inp_features, sparse_conv_infeats, sparse_conv_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert feature_gradient_OK\n    transpose_filter_gradient_OK = check_gradients(filters.transpose([0, 2, 1]), sparse_conv_transpose_filter, sparse_conv_transpose_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_filter_gradient_OK\n    transpose_feature_gradient_OK = check_gradients(y_arr, sparse_conv_transpose_infeats, sparse_conv_transpose_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_feature_gradient_OK",
            "@pytest.mark.parametrize('kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization', [(1, 2, 7, True, False, False), (2, 1, 1, False, False, False), (3, 5, 3, False, True, True), (33, 3, 4, False, True, False)])\n@mltest.parametrize.ml\n@pytest.mark.parametrize('dtype', [np.float32])\ndef test_sparseconv_gradient(ml, dtype, kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if dtype == np.float64:\n        tolerance = {'atol': 1e-05, 'rtol': 0.01, 'epsilon': 1e-06}\n    elif dtype == np.float32:\n        tolerance = {'atol': 0.01, 'rtol': 0.1, 'epsilon': 0.001}\n    rng = np.random.RandomState(123)\n    conv_attrs = {'normalize': with_normalization}\n    filters = rng.random(size=(kernel_size, in_channels, out_channels)).astype(dtype)\n    num_inp = 33\n    num_out = 16\n    inp_features = rng.uniform(size=(num_inp, in_channels)).astype(dtype)\n    if with_inp_importance:\n        inp_importance = rng.random(num_inp).astype(dtype)\n    else:\n        inp_importance = np.empty((0,)).astype(dtype)\n    neighbors_row_splits = np.zeros((num_out + 1,), dtype=np.int64)\n    for i in range(num_out):\n        neighbors_row_splits[i + 1] = rng.randint(kernel_size + 1) + neighbors_row_splits[i]\n    neighbors_index = np.zeros((neighbors_row_splits[-1],), dtype=np.int32)\n    neighbors_kernel_index = np.zeros((neighbors_row_splits[-1],), dtype=np.uint8)\n    for i in range(num_out):\n        start = neighbors_row_splits[i]\n        end = neighbors_row_splits[i + 1]\n        neighbors_kernel_index[start:end] = rng.choice(kernel_size, [end - start], replace=False)\n        neighbors_index[start:end] = rng.choice(num_inp, [end - start], replace=False)\n    arange = np.arange(neighbors_index.shape[0])\n    (inv_neighbors_index, inv_neighbors_row_splits, inv_arange) = mltest.run_op(ml, ml.device, False, ml.ops.invert_neighbors_list, num_inp, neighbors_index, neighbors_row_splits, arange)\n    inv_neighbors_kernel_index = neighbors_kernel_index[inv_arange]\n    if with_neighbors_importance:\n        neighbors_importance = rng.random(neighbors_index.shape[0]).astype(dtype) - 0.5\n        neighbors_importance_sum = mltest.run_op(ml, ml.device, False, ml.ops.reduce_subarrays_sum, neighbors_importance, neighbors_row_splits)\n        inv_neighbors_importance = neighbors_importance[inv_arange]\n    else:\n        neighbors_importance = np.empty((0,), dtype=dtype)\n        neighbors_importance_sum = np.empty((0,), dtype=dtype)\n        inv_neighbors_importance = np.empty((0,), dtype=dtype)\n\n    def sparse_conv_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n    y_arr = sparse_conv_infeats(inp_features)\n    dbg = {}\n    filter_gradient_OK = check_gradients(filters, sparse_conv_filter, sparse_conv_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert filter_gradient_OK\n    feature_gradient_OK = check_gradients(inp_features, sparse_conv_infeats, sparse_conv_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert feature_gradient_OK\n    transpose_filter_gradient_OK = check_gradients(filters.transpose([0, 2, 1]), sparse_conv_transpose_filter, sparse_conv_transpose_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_filter_gradient_OK\n    transpose_feature_gradient_OK = check_gradients(y_arr, sparse_conv_transpose_infeats, sparse_conv_transpose_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_feature_gradient_OK",
            "@pytest.mark.parametrize('kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization', [(1, 2, 7, True, False, False), (2, 1, 1, False, False, False), (3, 5, 3, False, True, True), (33, 3, 4, False, True, False)])\n@mltest.parametrize.ml\n@pytest.mark.parametrize('dtype', [np.float32])\ndef test_sparseconv_gradient(ml, dtype, kernel_size, out_channels, in_channels, with_inp_importance, with_neighbors_importance, with_normalization):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if dtype == np.float64:\n        tolerance = {'atol': 1e-05, 'rtol': 0.01, 'epsilon': 1e-06}\n    elif dtype == np.float32:\n        tolerance = {'atol': 0.01, 'rtol': 0.1, 'epsilon': 0.001}\n    rng = np.random.RandomState(123)\n    conv_attrs = {'normalize': with_normalization}\n    filters = rng.random(size=(kernel_size, in_channels, out_channels)).astype(dtype)\n    num_inp = 33\n    num_out = 16\n    inp_features = rng.uniform(size=(num_inp, in_channels)).astype(dtype)\n    if with_inp_importance:\n        inp_importance = rng.random(num_inp).astype(dtype)\n    else:\n        inp_importance = np.empty((0,)).astype(dtype)\n    neighbors_row_splits = np.zeros((num_out + 1,), dtype=np.int64)\n    for i in range(num_out):\n        neighbors_row_splits[i + 1] = rng.randint(kernel_size + 1) + neighbors_row_splits[i]\n    neighbors_index = np.zeros((neighbors_row_splits[-1],), dtype=np.int32)\n    neighbors_kernel_index = np.zeros((neighbors_row_splits[-1],), dtype=np.uint8)\n    for i in range(num_out):\n        start = neighbors_row_splits[i]\n        end = neighbors_row_splits[i + 1]\n        neighbors_kernel_index[start:end] = rng.choice(kernel_size, [end - start], replace=False)\n        neighbors_index[start:end] = rng.choice(num_inp, [end - start], replace=False)\n    arange = np.arange(neighbors_index.shape[0])\n    (inv_neighbors_index, inv_neighbors_row_splits, inv_arange) = mltest.run_op(ml, ml.device, False, ml.ops.invert_neighbors_list, num_inp, neighbors_index, neighbors_row_splits, arange)\n    inv_neighbors_kernel_index = neighbors_kernel_index[inv_arange]\n    if with_neighbors_importance:\n        neighbors_importance = rng.random(neighbors_index.shape[0]).astype(dtype) - 0.5\n        neighbors_importance_sum = mltest.run_op(ml, ml.device, False, ml.ops.reduce_subarrays_sum, neighbors_importance, neighbors_row_splits)\n        inv_neighbors_importance = neighbors_importance[inv_arange]\n    else:\n        neighbors_importance = np.empty((0,), dtype=dtype)\n        neighbors_importance_sum = np.empty((0,), dtype=dtype)\n        inv_neighbors_importance = np.empty((0,), dtype=dtype)\n\n    def sparse_conv_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv, filters, inp_features, inp_importance, neighbors_index, neighbors_kernel_index, neighbors_importance, neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, filters, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv, inp_features, '', out_features_gradient, filters=filters, inp_features=inp_features, inp_importance=inp_importance, neighbors_index=neighbors_index, neighbors_kernel_index=neighbors_kernel_index, neighbors_importance=neighbors_importance, neighbors_row_splits=neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter(filters):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, inp_importance, y_arr, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeats(inp_features):\n        return mltest.run_op(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters.transpose([0, 2, 1]), inp_importance, inp_features, neighbors_index, neighbors_importance_sum, neighbors_row_splits, inv_neighbors_index, inv_neighbors_kernel_index, inv_neighbors_importance, inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_filter_backprop(out_features_gradient, filters):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, filters, '', out_features_gradient, filters=filters, out_importance=inp_importance, inp_features=y_arr, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n\n    def sparse_conv_transpose_infeat_backprop(out_features_gradient, inp_features):\n        return mltest.run_op_grad(ml, ml.device, True, ml.ops.sparse_conv_transpose, inp_features, '', out_features_gradient, filters=filters.transpose([0, 2, 1]), out_importance=inp_importance, inp_features=inp_features, inp_neighbors_index=neighbors_index, inp_neighbors_importance_sum=neighbors_importance_sum, inp_neighbors_row_splits=neighbors_row_splits, neighbors_index=inv_neighbors_index, neighbors_kernel_index=inv_neighbors_kernel_index, neighbors_importance=inv_neighbors_importance, neighbors_row_splits=inv_neighbors_row_splits, **conv_attrs)\n    y_arr = sparse_conv_infeats(inp_features)\n    dbg = {}\n    filter_gradient_OK = check_gradients(filters, sparse_conv_filter, sparse_conv_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert filter_gradient_OK\n    feature_gradient_OK = check_gradients(inp_features, sparse_conv_infeats, sparse_conv_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert feature_gradient_OK\n    transpose_filter_gradient_OK = check_gradients(filters.transpose([0, 2, 1]), sparse_conv_transpose_filter, sparse_conv_transpose_filter_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_filter_gradient_OK\n    transpose_feature_gradient_OK = check_gradients(y_arr, sparse_conv_transpose_infeats, sparse_conv_transpose_infeat_backprop, debug_outputs=dbg, **tolerance)\n    assert transpose_feature_gradient_OK"
        ]
    }
]