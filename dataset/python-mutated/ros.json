[
    {
        "func_name": "_ros_sort",
        "original": "def _ros_sort(df, observations, censorship, warn=False):\n    \"\"\"\n    This function prepares a dataframe for ROS.\n\n    It sorts ascending with\n    left-censored observations first. Censored observations larger than\n    the maximum uncensored observations are removed from the dataframe.\n\n    Parameters\n    ----------\n    df : DataFrame\n\n    observations : str\n        Name of the column in the dataframe that contains observed\n        values. Censored values should be set to the detection (upper)\n        limit.\n\n    censorship : str\n        Name of the column in the dataframe that indicates that a\n        observation is left-censored. (i.e., True -> censored,\n        False -> uncensored)\n\n    Returns\n    ------\n    sorted_df : DataFrame\n        The sorted dataframe with all columns dropped except the\n        observation and censorship columns.\n    \"\"\"\n    censored = df[df[censorship]].sort_values(observations, axis=0)\n    uncensored = df[~df[censorship]].sort_values(observations, axis=0)\n    if censored[observations].max() > uncensored[observations].max():\n        censored = censored[censored[observations] <= uncensored[observations].max()]\n        if warn:\n            msg = 'Dropping censored observations greater than the max uncensored observation.'\n            warnings.warn(msg)\n    combined = pd.concat([censored, uncensored], axis=0)\n    return combined[[observations, censorship]].reset_index(drop=True)",
        "mutated": [
            "def _ros_sort(df, observations, censorship, warn=False):\n    if False:\n        i = 10\n    '\\n    This function prepares a dataframe for ROS.\\n\\n    It sorts ascending with\\n    left-censored observations first. Censored observations larger than\\n    the maximum uncensored observations are removed from the dataframe.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    ------\\n    sorted_df : DataFrame\\n        The sorted dataframe with all columns dropped except the\\n        observation and censorship columns.\\n    '\n    censored = df[df[censorship]].sort_values(observations, axis=0)\n    uncensored = df[~df[censorship]].sort_values(observations, axis=0)\n    if censored[observations].max() > uncensored[observations].max():\n        censored = censored[censored[observations] <= uncensored[observations].max()]\n        if warn:\n            msg = 'Dropping censored observations greater than the max uncensored observation.'\n            warnings.warn(msg)\n    combined = pd.concat([censored, uncensored], axis=0)\n    return combined[[observations, censorship]].reset_index(drop=True)",
            "def _ros_sort(df, observations, censorship, warn=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This function prepares a dataframe for ROS.\\n\\n    It sorts ascending with\\n    left-censored observations first. Censored observations larger than\\n    the maximum uncensored observations are removed from the dataframe.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    ------\\n    sorted_df : DataFrame\\n        The sorted dataframe with all columns dropped except the\\n        observation and censorship columns.\\n    '\n    censored = df[df[censorship]].sort_values(observations, axis=0)\n    uncensored = df[~df[censorship]].sort_values(observations, axis=0)\n    if censored[observations].max() > uncensored[observations].max():\n        censored = censored[censored[observations] <= uncensored[observations].max()]\n        if warn:\n            msg = 'Dropping censored observations greater than the max uncensored observation.'\n            warnings.warn(msg)\n    combined = pd.concat([censored, uncensored], axis=0)\n    return combined[[observations, censorship]].reset_index(drop=True)",
            "def _ros_sort(df, observations, censorship, warn=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This function prepares a dataframe for ROS.\\n\\n    It sorts ascending with\\n    left-censored observations first. Censored observations larger than\\n    the maximum uncensored observations are removed from the dataframe.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    ------\\n    sorted_df : DataFrame\\n        The sorted dataframe with all columns dropped except the\\n        observation and censorship columns.\\n    '\n    censored = df[df[censorship]].sort_values(observations, axis=0)\n    uncensored = df[~df[censorship]].sort_values(observations, axis=0)\n    if censored[observations].max() > uncensored[observations].max():\n        censored = censored[censored[observations] <= uncensored[observations].max()]\n        if warn:\n            msg = 'Dropping censored observations greater than the max uncensored observation.'\n            warnings.warn(msg)\n    combined = pd.concat([censored, uncensored], axis=0)\n    return combined[[observations, censorship]].reset_index(drop=True)",
            "def _ros_sort(df, observations, censorship, warn=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This function prepares a dataframe for ROS.\\n\\n    It sorts ascending with\\n    left-censored observations first. Censored observations larger than\\n    the maximum uncensored observations are removed from the dataframe.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    ------\\n    sorted_df : DataFrame\\n        The sorted dataframe with all columns dropped except the\\n        observation and censorship columns.\\n    '\n    censored = df[df[censorship]].sort_values(observations, axis=0)\n    uncensored = df[~df[censorship]].sort_values(observations, axis=0)\n    if censored[observations].max() > uncensored[observations].max():\n        censored = censored[censored[observations] <= uncensored[observations].max()]\n        if warn:\n            msg = 'Dropping censored observations greater than the max uncensored observation.'\n            warnings.warn(msg)\n    combined = pd.concat([censored, uncensored], axis=0)\n    return combined[[observations, censorship]].reset_index(drop=True)",
            "def _ros_sort(df, observations, censorship, warn=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This function prepares a dataframe for ROS.\\n\\n    It sorts ascending with\\n    left-censored observations first. Censored observations larger than\\n    the maximum uncensored observations are removed from the dataframe.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    ------\\n    sorted_df : DataFrame\\n        The sorted dataframe with all columns dropped except the\\n        observation and censorship columns.\\n    '\n    censored = df[df[censorship]].sort_values(observations, axis=0)\n    uncensored = df[~df[censorship]].sort_values(observations, axis=0)\n    if censored[observations].max() > uncensored[observations].max():\n        censored = censored[censored[observations] <= uncensored[observations].max()]\n        if warn:\n            msg = 'Dropping censored observations greater than the max uncensored observation.'\n            warnings.warn(msg)\n    combined = pd.concat([censored, uncensored], axis=0)\n    return combined[[observations, censorship]].reset_index(drop=True)"
        ]
    },
    {
        "func_name": "nuncen_above",
        "original": "def nuncen_above(row):\n    \"\"\" A, the number of uncensored obs above the given threshold.\n        \"\"\"\n    above = df[observations] >= row['lower_dl']\n    below = df[observations] < row['upper_dl']\n    detect = ~df[censorship]\n    return df[above & below & detect].shape[0]",
        "mutated": [
            "def nuncen_above(row):\n    if False:\n        i = 10\n    ' A, the number of uncensored obs above the given threshold.\\n        '\n    above = df[observations] >= row['lower_dl']\n    below = df[observations] < row['upper_dl']\n    detect = ~df[censorship]\n    return df[above & below & detect].shape[0]",
            "def nuncen_above(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' A, the number of uncensored obs above the given threshold.\\n        '\n    above = df[observations] >= row['lower_dl']\n    below = df[observations] < row['upper_dl']\n    detect = ~df[censorship]\n    return df[above & below & detect].shape[0]",
            "def nuncen_above(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' A, the number of uncensored obs above the given threshold.\\n        '\n    above = df[observations] >= row['lower_dl']\n    below = df[observations] < row['upper_dl']\n    detect = ~df[censorship]\n    return df[above & below & detect].shape[0]",
            "def nuncen_above(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' A, the number of uncensored obs above the given threshold.\\n        '\n    above = df[observations] >= row['lower_dl']\n    below = df[observations] < row['upper_dl']\n    detect = ~df[censorship]\n    return df[above & below & detect].shape[0]",
            "def nuncen_above(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' A, the number of uncensored obs above the given threshold.\\n        '\n    above = df[observations] >= row['lower_dl']\n    below = df[observations] < row['upper_dl']\n    detect = ~df[censorship]\n    return df[above & below & detect].shape[0]"
        ]
    },
    {
        "func_name": "nobs_below",
        "original": "def nobs_below(row):\n    \"\"\" B, the number of observations (cen & uncen) below the given\n        threshold\n        \"\"\"\n    less_than = df[observations] < row['lower_dl']\n    less_thanequal = df[observations] <= row['lower_dl']\n    uncensored = ~df[censorship]\n    censored = df[censorship]\n    LTE_censored = df[less_thanequal & censored].shape[0]\n    LT_uncensored = df[less_than & uncensored].shape[0]\n    return LTE_censored + LT_uncensored",
        "mutated": [
            "def nobs_below(row):\n    if False:\n        i = 10\n    ' B, the number of observations (cen & uncen) below the given\\n        threshold\\n        '\n    less_than = df[observations] < row['lower_dl']\n    less_thanequal = df[observations] <= row['lower_dl']\n    uncensored = ~df[censorship]\n    censored = df[censorship]\n    LTE_censored = df[less_thanequal & censored].shape[0]\n    LT_uncensored = df[less_than & uncensored].shape[0]\n    return LTE_censored + LT_uncensored",
            "def nobs_below(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' B, the number of observations (cen & uncen) below the given\\n        threshold\\n        '\n    less_than = df[observations] < row['lower_dl']\n    less_thanequal = df[observations] <= row['lower_dl']\n    uncensored = ~df[censorship]\n    censored = df[censorship]\n    LTE_censored = df[less_thanequal & censored].shape[0]\n    LT_uncensored = df[less_than & uncensored].shape[0]\n    return LTE_censored + LT_uncensored",
            "def nobs_below(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' B, the number of observations (cen & uncen) below the given\\n        threshold\\n        '\n    less_than = df[observations] < row['lower_dl']\n    less_thanequal = df[observations] <= row['lower_dl']\n    uncensored = ~df[censorship]\n    censored = df[censorship]\n    LTE_censored = df[less_thanequal & censored].shape[0]\n    LT_uncensored = df[less_than & uncensored].shape[0]\n    return LTE_censored + LT_uncensored",
            "def nobs_below(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' B, the number of observations (cen & uncen) below the given\\n        threshold\\n        '\n    less_than = df[observations] < row['lower_dl']\n    less_thanequal = df[observations] <= row['lower_dl']\n    uncensored = ~df[censorship]\n    censored = df[censorship]\n    LTE_censored = df[less_thanequal & censored].shape[0]\n    LT_uncensored = df[less_than & uncensored].shape[0]\n    return LTE_censored + LT_uncensored",
            "def nobs_below(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' B, the number of observations (cen & uncen) below the given\\n        threshold\\n        '\n    less_than = df[observations] < row['lower_dl']\n    less_thanequal = df[observations] <= row['lower_dl']\n    uncensored = ~df[censorship]\n    censored = df[censorship]\n    LTE_censored = df[less_thanequal & censored].shape[0]\n    LT_uncensored = df[less_than & uncensored].shape[0]\n    return LTE_censored + LT_uncensored"
        ]
    },
    {
        "func_name": "ncen_equal",
        "original": "def ncen_equal(row):\n    \"\"\" C, the number of censored observations at the given\n        threshold.\n        \"\"\"\n    censored_index = df[censorship]\n    censored_data = df[observations][censored_index]\n    censored_below = censored_data == row['lower_dl']\n    return censored_below.sum()",
        "mutated": [
            "def ncen_equal(row):\n    if False:\n        i = 10\n    ' C, the number of censored observations at the given\\n        threshold.\\n        '\n    censored_index = df[censorship]\n    censored_data = df[observations][censored_index]\n    censored_below = censored_data == row['lower_dl']\n    return censored_below.sum()",
            "def ncen_equal(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' C, the number of censored observations at the given\\n        threshold.\\n        '\n    censored_index = df[censorship]\n    censored_data = df[observations][censored_index]\n    censored_below = censored_data == row['lower_dl']\n    return censored_below.sum()",
            "def ncen_equal(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' C, the number of censored observations at the given\\n        threshold.\\n        '\n    censored_index = df[censorship]\n    censored_data = df[observations][censored_index]\n    censored_below = censored_data == row['lower_dl']\n    return censored_below.sum()",
            "def ncen_equal(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' C, the number of censored observations at the given\\n        threshold.\\n        '\n    censored_index = df[censorship]\n    censored_data = df[observations][censored_index]\n    censored_below = censored_data == row['lower_dl']\n    return censored_below.sum()",
            "def ncen_equal(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' C, the number of censored observations at the given\\n        threshold.\\n        '\n    censored_index = df[censorship]\n    censored_data = df[observations][censored_index]\n    censored_below = censored_data == row['lower_dl']\n    return censored_below.sum()"
        ]
    },
    {
        "func_name": "set_upper_limit",
        "original": "def set_upper_limit(cohn):\n    \"\"\" Sets the upper_dl DL for each row of the Cohn dataframe. \"\"\"\n    if cohn.shape[0] > 1:\n        return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n    else:\n        return [np.inf]",
        "mutated": [
            "def set_upper_limit(cohn):\n    if False:\n        i = 10\n    ' Sets the upper_dl DL for each row of the Cohn dataframe. '\n    if cohn.shape[0] > 1:\n        return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n    else:\n        return [np.inf]",
            "def set_upper_limit(cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Sets the upper_dl DL for each row of the Cohn dataframe. '\n    if cohn.shape[0] > 1:\n        return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n    else:\n        return [np.inf]",
            "def set_upper_limit(cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Sets the upper_dl DL for each row of the Cohn dataframe. '\n    if cohn.shape[0] > 1:\n        return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n    else:\n        return [np.inf]",
            "def set_upper_limit(cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Sets the upper_dl DL for each row of the Cohn dataframe. '\n    if cohn.shape[0] > 1:\n        return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n    else:\n        return [np.inf]",
            "def set_upper_limit(cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Sets the upper_dl DL for each row of the Cohn dataframe. '\n    if cohn.shape[0] > 1:\n        return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n    else:\n        return [np.inf]"
        ]
    },
    {
        "func_name": "compute_PE",
        "original": "def compute_PE(A, B):\n    \"\"\" Computes the probability of excedance for each row of the\n        Cohn dataframe. \"\"\"\n    N = len(A)\n    PE = np.empty(N, dtype='float64')\n    PE[-1] = 0.0\n    for j in range(N - 2, -1, -1):\n        PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n    return PE",
        "mutated": [
            "def compute_PE(A, B):\n    if False:\n        i = 10\n    ' Computes the probability of excedance for each row of the\\n        Cohn dataframe. '\n    N = len(A)\n    PE = np.empty(N, dtype='float64')\n    PE[-1] = 0.0\n    for j in range(N - 2, -1, -1):\n        PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n    return PE",
            "def compute_PE(A, B):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Computes the probability of excedance for each row of the\\n        Cohn dataframe. '\n    N = len(A)\n    PE = np.empty(N, dtype='float64')\n    PE[-1] = 0.0\n    for j in range(N - 2, -1, -1):\n        PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n    return PE",
            "def compute_PE(A, B):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Computes the probability of excedance for each row of the\\n        Cohn dataframe. '\n    N = len(A)\n    PE = np.empty(N, dtype='float64')\n    PE[-1] = 0.0\n    for j in range(N - 2, -1, -1):\n        PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n    return PE",
            "def compute_PE(A, B):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Computes the probability of excedance for each row of the\\n        Cohn dataframe. '\n    N = len(A)\n    PE = np.empty(N, dtype='float64')\n    PE[-1] = 0.0\n    for j in range(N - 2, -1, -1):\n        PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n    return PE",
            "def compute_PE(A, B):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Computes the probability of excedance for each row of the\\n        Cohn dataframe. '\n    N = len(A)\n    PE = np.empty(N, dtype='float64')\n    PE[-1] = 0.0\n    for j in range(N - 2, -1, -1):\n        PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n    return PE"
        ]
    },
    {
        "func_name": "cohn_numbers",
        "original": "def cohn_numbers(df, observations, censorship):\n    \"\"\"\n    Computes the Cohn numbers for the detection limits in the dataset.\n\n    The Cohn Numbers are:\n\n        - :math:`A_j =` the number of uncensored obs above the jth\n          threshold.\n        - :math:`B_j =` the number of observations (cen & uncen) below\n          the jth threshold.\n        - :math:`C_j =` the number of censored observations at the jth\n          threshold.\n        - :math:`\\\\mathrm{PE}_j =` the probability of exceeding the jth\n          threshold\n        - :math:`\\\\mathrm{DL}_j =` the unique, sorted detection limits\n        - :math:`\\\\mathrm{DL}_{j+1} = \\\\mathrm{DL}_j` shifted down a\n          single index (row)\n\n    Parameters\n    ----------\n    dataframe : DataFrame\n\n    observations : str\n        Name of the column in the dataframe that contains observed\n        values. Censored values should be set to the detection (upper)\n        limit.\n\n    censorship : str\n        Name of the column in the dataframe that indicates that a\n        observation is left-censored. (i.e., True -> censored,\n        False -> uncensored)\n\n    Returns\n    -------\n    cohn : DataFrame\n    \"\"\"\n\n    def nuncen_above(row):\n        \"\"\" A, the number of uncensored obs above the given threshold.\n        \"\"\"\n        above = df[observations] >= row['lower_dl']\n        below = df[observations] < row['upper_dl']\n        detect = ~df[censorship]\n        return df[above & below & detect].shape[0]\n\n    def nobs_below(row):\n        \"\"\" B, the number of observations (cen & uncen) below the given\n        threshold\n        \"\"\"\n        less_than = df[observations] < row['lower_dl']\n        less_thanequal = df[observations] <= row['lower_dl']\n        uncensored = ~df[censorship]\n        censored = df[censorship]\n        LTE_censored = df[less_thanequal & censored].shape[0]\n        LT_uncensored = df[less_than & uncensored].shape[0]\n        return LTE_censored + LT_uncensored\n\n    def ncen_equal(row):\n        \"\"\" C, the number of censored observations at the given\n        threshold.\n        \"\"\"\n        censored_index = df[censorship]\n        censored_data = df[observations][censored_index]\n        censored_below = censored_data == row['lower_dl']\n        return censored_below.sum()\n\n    def set_upper_limit(cohn):\n        \"\"\" Sets the upper_dl DL for each row of the Cohn dataframe. \"\"\"\n        if cohn.shape[0] > 1:\n            return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n        else:\n            return [np.inf]\n\n    def compute_PE(A, B):\n        \"\"\" Computes the probability of excedance for each row of the\n        Cohn dataframe. \"\"\"\n        N = len(A)\n        PE = np.empty(N, dtype='float64')\n        PE[-1] = 0.0\n        for j in range(N - 2, -1, -1):\n            PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n        return PE\n    censored_data = df[censorship]\n    DLs = pd.unique(df.loc[censored_data, observations])\n    DLs.sort()\n    if DLs.shape[0] > 0:\n        if df[observations].min() < DLs.min():\n            DLs = np.hstack([df[observations].min(), DLs])\n        cohn = pd.DataFrame(DLs, columns=['lower_dl'])\n        cohn.loc[:, 'upper_dl'] = set_upper_limit(cohn)\n        cohn.loc[:, 'nuncen_above'] = cohn.apply(nuncen_above, axis=1)\n        cohn.loc[:, 'nobs_below'] = cohn.apply(nobs_below, axis=1)\n        cohn.loc[:, 'ncen_equal'] = cohn.apply(ncen_equal, axis=1)\n        cohn = cohn.reindex(range(DLs.shape[0] + 1))\n        cohn.loc[:, 'prob_exceedance'] = compute_PE(cohn['nuncen_above'], cohn['nobs_below'])\n    else:\n        dl_cols = ['lower_dl', 'upper_dl', 'nuncen_above', 'nobs_below', 'ncen_equal', 'prob_exceedance']\n        cohn = pd.DataFrame(np.empty((0, len(dl_cols))), columns=dl_cols)\n    return cohn",
        "mutated": [
            "def cohn_numbers(df, observations, censorship):\n    if False:\n        i = 10\n    '\\n    Computes the Cohn numbers for the detection limits in the dataset.\\n\\n    The Cohn Numbers are:\\n\\n        - :math:`A_j =` the number of uncensored obs above the jth\\n          threshold.\\n        - :math:`B_j =` the number of observations (cen & uncen) below\\n          the jth threshold.\\n        - :math:`C_j =` the number of censored observations at the jth\\n          threshold.\\n        - :math:`\\\\mathrm{PE}_j =` the probability of exceeding the jth\\n          threshold\\n        - :math:`\\\\mathrm{DL}_j =` the unique, sorted detection limits\\n        - :math:`\\\\mathrm{DL}_{j+1} = \\\\mathrm{DL}_j` shifted down a\\n          single index (row)\\n\\n    Parameters\\n    ----------\\n    dataframe : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    cohn : DataFrame\\n    '\n\n    def nuncen_above(row):\n        \"\"\" A, the number of uncensored obs above the given threshold.\n        \"\"\"\n        above = df[observations] >= row['lower_dl']\n        below = df[observations] < row['upper_dl']\n        detect = ~df[censorship]\n        return df[above & below & detect].shape[0]\n\n    def nobs_below(row):\n        \"\"\" B, the number of observations (cen & uncen) below the given\n        threshold\n        \"\"\"\n        less_than = df[observations] < row['lower_dl']\n        less_thanequal = df[observations] <= row['lower_dl']\n        uncensored = ~df[censorship]\n        censored = df[censorship]\n        LTE_censored = df[less_thanequal & censored].shape[0]\n        LT_uncensored = df[less_than & uncensored].shape[0]\n        return LTE_censored + LT_uncensored\n\n    def ncen_equal(row):\n        \"\"\" C, the number of censored observations at the given\n        threshold.\n        \"\"\"\n        censored_index = df[censorship]\n        censored_data = df[observations][censored_index]\n        censored_below = censored_data == row['lower_dl']\n        return censored_below.sum()\n\n    def set_upper_limit(cohn):\n        \"\"\" Sets the upper_dl DL for each row of the Cohn dataframe. \"\"\"\n        if cohn.shape[0] > 1:\n            return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n        else:\n            return [np.inf]\n\n    def compute_PE(A, B):\n        \"\"\" Computes the probability of excedance for each row of the\n        Cohn dataframe. \"\"\"\n        N = len(A)\n        PE = np.empty(N, dtype='float64')\n        PE[-1] = 0.0\n        for j in range(N - 2, -1, -1):\n            PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n        return PE\n    censored_data = df[censorship]\n    DLs = pd.unique(df.loc[censored_data, observations])\n    DLs.sort()\n    if DLs.shape[0] > 0:\n        if df[observations].min() < DLs.min():\n            DLs = np.hstack([df[observations].min(), DLs])\n        cohn = pd.DataFrame(DLs, columns=['lower_dl'])\n        cohn.loc[:, 'upper_dl'] = set_upper_limit(cohn)\n        cohn.loc[:, 'nuncen_above'] = cohn.apply(nuncen_above, axis=1)\n        cohn.loc[:, 'nobs_below'] = cohn.apply(nobs_below, axis=1)\n        cohn.loc[:, 'ncen_equal'] = cohn.apply(ncen_equal, axis=1)\n        cohn = cohn.reindex(range(DLs.shape[0] + 1))\n        cohn.loc[:, 'prob_exceedance'] = compute_PE(cohn['nuncen_above'], cohn['nobs_below'])\n    else:\n        dl_cols = ['lower_dl', 'upper_dl', 'nuncen_above', 'nobs_below', 'ncen_equal', 'prob_exceedance']\n        cohn = pd.DataFrame(np.empty((0, len(dl_cols))), columns=dl_cols)\n    return cohn",
            "def cohn_numbers(df, observations, censorship):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the Cohn numbers for the detection limits in the dataset.\\n\\n    The Cohn Numbers are:\\n\\n        - :math:`A_j =` the number of uncensored obs above the jth\\n          threshold.\\n        - :math:`B_j =` the number of observations (cen & uncen) below\\n          the jth threshold.\\n        - :math:`C_j =` the number of censored observations at the jth\\n          threshold.\\n        - :math:`\\\\mathrm{PE}_j =` the probability of exceeding the jth\\n          threshold\\n        - :math:`\\\\mathrm{DL}_j =` the unique, sorted detection limits\\n        - :math:`\\\\mathrm{DL}_{j+1} = \\\\mathrm{DL}_j` shifted down a\\n          single index (row)\\n\\n    Parameters\\n    ----------\\n    dataframe : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    cohn : DataFrame\\n    '\n\n    def nuncen_above(row):\n        \"\"\" A, the number of uncensored obs above the given threshold.\n        \"\"\"\n        above = df[observations] >= row['lower_dl']\n        below = df[observations] < row['upper_dl']\n        detect = ~df[censorship]\n        return df[above & below & detect].shape[0]\n\n    def nobs_below(row):\n        \"\"\" B, the number of observations (cen & uncen) below the given\n        threshold\n        \"\"\"\n        less_than = df[observations] < row['lower_dl']\n        less_thanequal = df[observations] <= row['lower_dl']\n        uncensored = ~df[censorship]\n        censored = df[censorship]\n        LTE_censored = df[less_thanequal & censored].shape[0]\n        LT_uncensored = df[less_than & uncensored].shape[0]\n        return LTE_censored + LT_uncensored\n\n    def ncen_equal(row):\n        \"\"\" C, the number of censored observations at the given\n        threshold.\n        \"\"\"\n        censored_index = df[censorship]\n        censored_data = df[observations][censored_index]\n        censored_below = censored_data == row['lower_dl']\n        return censored_below.sum()\n\n    def set_upper_limit(cohn):\n        \"\"\" Sets the upper_dl DL for each row of the Cohn dataframe. \"\"\"\n        if cohn.shape[0] > 1:\n            return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n        else:\n            return [np.inf]\n\n    def compute_PE(A, B):\n        \"\"\" Computes the probability of excedance for each row of the\n        Cohn dataframe. \"\"\"\n        N = len(A)\n        PE = np.empty(N, dtype='float64')\n        PE[-1] = 0.0\n        for j in range(N - 2, -1, -1):\n            PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n        return PE\n    censored_data = df[censorship]\n    DLs = pd.unique(df.loc[censored_data, observations])\n    DLs.sort()\n    if DLs.shape[0] > 0:\n        if df[observations].min() < DLs.min():\n            DLs = np.hstack([df[observations].min(), DLs])\n        cohn = pd.DataFrame(DLs, columns=['lower_dl'])\n        cohn.loc[:, 'upper_dl'] = set_upper_limit(cohn)\n        cohn.loc[:, 'nuncen_above'] = cohn.apply(nuncen_above, axis=1)\n        cohn.loc[:, 'nobs_below'] = cohn.apply(nobs_below, axis=1)\n        cohn.loc[:, 'ncen_equal'] = cohn.apply(ncen_equal, axis=1)\n        cohn = cohn.reindex(range(DLs.shape[0] + 1))\n        cohn.loc[:, 'prob_exceedance'] = compute_PE(cohn['nuncen_above'], cohn['nobs_below'])\n    else:\n        dl_cols = ['lower_dl', 'upper_dl', 'nuncen_above', 'nobs_below', 'ncen_equal', 'prob_exceedance']\n        cohn = pd.DataFrame(np.empty((0, len(dl_cols))), columns=dl_cols)\n    return cohn",
            "def cohn_numbers(df, observations, censorship):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the Cohn numbers for the detection limits in the dataset.\\n\\n    The Cohn Numbers are:\\n\\n        - :math:`A_j =` the number of uncensored obs above the jth\\n          threshold.\\n        - :math:`B_j =` the number of observations (cen & uncen) below\\n          the jth threshold.\\n        - :math:`C_j =` the number of censored observations at the jth\\n          threshold.\\n        - :math:`\\\\mathrm{PE}_j =` the probability of exceeding the jth\\n          threshold\\n        - :math:`\\\\mathrm{DL}_j =` the unique, sorted detection limits\\n        - :math:`\\\\mathrm{DL}_{j+1} = \\\\mathrm{DL}_j` shifted down a\\n          single index (row)\\n\\n    Parameters\\n    ----------\\n    dataframe : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    cohn : DataFrame\\n    '\n\n    def nuncen_above(row):\n        \"\"\" A, the number of uncensored obs above the given threshold.\n        \"\"\"\n        above = df[observations] >= row['lower_dl']\n        below = df[observations] < row['upper_dl']\n        detect = ~df[censorship]\n        return df[above & below & detect].shape[0]\n\n    def nobs_below(row):\n        \"\"\" B, the number of observations (cen & uncen) below the given\n        threshold\n        \"\"\"\n        less_than = df[observations] < row['lower_dl']\n        less_thanequal = df[observations] <= row['lower_dl']\n        uncensored = ~df[censorship]\n        censored = df[censorship]\n        LTE_censored = df[less_thanequal & censored].shape[0]\n        LT_uncensored = df[less_than & uncensored].shape[0]\n        return LTE_censored + LT_uncensored\n\n    def ncen_equal(row):\n        \"\"\" C, the number of censored observations at the given\n        threshold.\n        \"\"\"\n        censored_index = df[censorship]\n        censored_data = df[observations][censored_index]\n        censored_below = censored_data == row['lower_dl']\n        return censored_below.sum()\n\n    def set_upper_limit(cohn):\n        \"\"\" Sets the upper_dl DL for each row of the Cohn dataframe. \"\"\"\n        if cohn.shape[0] > 1:\n            return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n        else:\n            return [np.inf]\n\n    def compute_PE(A, B):\n        \"\"\" Computes the probability of excedance for each row of the\n        Cohn dataframe. \"\"\"\n        N = len(A)\n        PE = np.empty(N, dtype='float64')\n        PE[-1] = 0.0\n        for j in range(N - 2, -1, -1):\n            PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n        return PE\n    censored_data = df[censorship]\n    DLs = pd.unique(df.loc[censored_data, observations])\n    DLs.sort()\n    if DLs.shape[0] > 0:\n        if df[observations].min() < DLs.min():\n            DLs = np.hstack([df[observations].min(), DLs])\n        cohn = pd.DataFrame(DLs, columns=['lower_dl'])\n        cohn.loc[:, 'upper_dl'] = set_upper_limit(cohn)\n        cohn.loc[:, 'nuncen_above'] = cohn.apply(nuncen_above, axis=1)\n        cohn.loc[:, 'nobs_below'] = cohn.apply(nobs_below, axis=1)\n        cohn.loc[:, 'ncen_equal'] = cohn.apply(ncen_equal, axis=1)\n        cohn = cohn.reindex(range(DLs.shape[0] + 1))\n        cohn.loc[:, 'prob_exceedance'] = compute_PE(cohn['nuncen_above'], cohn['nobs_below'])\n    else:\n        dl_cols = ['lower_dl', 'upper_dl', 'nuncen_above', 'nobs_below', 'ncen_equal', 'prob_exceedance']\n        cohn = pd.DataFrame(np.empty((0, len(dl_cols))), columns=dl_cols)\n    return cohn",
            "def cohn_numbers(df, observations, censorship):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the Cohn numbers for the detection limits in the dataset.\\n\\n    The Cohn Numbers are:\\n\\n        - :math:`A_j =` the number of uncensored obs above the jth\\n          threshold.\\n        - :math:`B_j =` the number of observations (cen & uncen) below\\n          the jth threshold.\\n        - :math:`C_j =` the number of censored observations at the jth\\n          threshold.\\n        - :math:`\\\\mathrm{PE}_j =` the probability of exceeding the jth\\n          threshold\\n        - :math:`\\\\mathrm{DL}_j =` the unique, sorted detection limits\\n        - :math:`\\\\mathrm{DL}_{j+1} = \\\\mathrm{DL}_j` shifted down a\\n          single index (row)\\n\\n    Parameters\\n    ----------\\n    dataframe : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    cohn : DataFrame\\n    '\n\n    def nuncen_above(row):\n        \"\"\" A, the number of uncensored obs above the given threshold.\n        \"\"\"\n        above = df[observations] >= row['lower_dl']\n        below = df[observations] < row['upper_dl']\n        detect = ~df[censorship]\n        return df[above & below & detect].shape[0]\n\n    def nobs_below(row):\n        \"\"\" B, the number of observations (cen & uncen) below the given\n        threshold\n        \"\"\"\n        less_than = df[observations] < row['lower_dl']\n        less_thanequal = df[observations] <= row['lower_dl']\n        uncensored = ~df[censorship]\n        censored = df[censorship]\n        LTE_censored = df[less_thanequal & censored].shape[0]\n        LT_uncensored = df[less_than & uncensored].shape[0]\n        return LTE_censored + LT_uncensored\n\n    def ncen_equal(row):\n        \"\"\" C, the number of censored observations at the given\n        threshold.\n        \"\"\"\n        censored_index = df[censorship]\n        censored_data = df[observations][censored_index]\n        censored_below = censored_data == row['lower_dl']\n        return censored_below.sum()\n\n    def set_upper_limit(cohn):\n        \"\"\" Sets the upper_dl DL for each row of the Cohn dataframe. \"\"\"\n        if cohn.shape[0] > 1:\n            return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n        else:\n            return [np.inf]\n\n    def compute_PE(A, B):\n        \"\"\" Computes the probability of excedance for each row of the\n        Cohn dataframe. \"\"\"\n        N = len(A)\n        PE = np.empty(N, dtype='float64')\n        PE[-1] = 0.0\n        for j in range(N - 2, -1, -1):\n            PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n        return PE\n    censored_data = df[censorship]\n    DLs = pd.unique(df.loc[censored_data, observations])\n    DLs.sort()\n    if DLs.shape[0] > 0:\n        if df[observations].min() < DLs.min():\n            DLs = np.hstack([df[observations].min(), DLs])\n        cohn = pd.DataFrame(DLs, columns=['lower_dl'])\n        cohn.loc[:, 'upper_dl'] = set_upper_limit(cohn)\n        cohn.loc[:, 'nuncen_above'] = cohn.apply(nuncen_above, axis=1)\n        cohn.loc[:, 'nobs_below'] = cohn.apply(nobs_below, axis=1)\n        cohn.loc[:, 'ncen_equal'] = cohn.apply(ncen_equal, axis=1)\n        cohn = cohn.reindex(range(DLs.shape[0] + 1))\n        cohn.loc[:, 'prob_exceedance'] = compute_PE(cohn['nuncen_above'], cohn['nobs_below'])\n    else:\n        dl_cols = ['lower_dl', 'upper_dl', 'nuncen_above', 'nobs_below', 'ncen_equal', 'prob_exceedance']\n        cohn = pd.DataFrame(np.empty((0, len(dl_cols))), columns=dl_cols)\n    return cohn",
            "def cohn_numbers(df, observations, censorship):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the Cohn numbers for the detection limits in the dataset.\\n\\n    The Cohn Numbers are:\\n\\n        - :math:`A_j =` the number of uncensored obs above the jth\\n          threshold.\\n        - :math:`B_j =` the number of observations (cen & uncen) below\\n          the jth threshold.\\n        - :math:`C_j =` the number of censored observations at the jth\\n          threshold.\\n        - :math:`\\\\mathrm{PE}_j =` the probability of exceeding the jth\\n          threshold\\n        - :math:`\\\\mathrm{DL}_j =` the unique, sorted detection limits\\n        - :math:`\\\\mathrm{DL}_{j+1} = \\\\mathrm{DL}_j` shifted down a\\n          single index (row)\\n\\n    Parameters\\n    ----------\\n    dataframe : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    cohn : DataFrame\\n    '\n\n    def nuncen_above(row):\n        \"\"\" A, the number of uncensored obs above the given threshold.\n        \"\"\"\n        above = df[observations] >= row['lower_dl']\n        below = df[observations] < row['upper_dl']\n        detect = ~df[censorship]\n        return df[above & below & detect].shape[0]\n\n    def nobs_below(row):\n        \"\"\" B, the number of observations (cen & uncen) below the given\n        threshold\n        \"\"\"\n        less_than = df[observations] < row['lower_dl']\n        less_thanequal = df[observations] <= row['lower_dl']\n        uncensored = ~df[censorship]\n        censored = df[censorship]\n        LTE_censored = df[less_thanequal & censored].shape[0]\n        LT_uncensored = df[less_than & uncensored].shape[0]\n        return LTE_censored + LT_uncensored\n\n    def ncen_equal(row):\n        \"\"\" C, the number of censored observations at the given\n        threshold.\n        \"\"\"\n        censored_index = df[censorship]\n        censored_data = df[observations][censored_index]\n        censored_below = censored_data == row['lower_dl']\n        return censored_below.sum()\n\n    def set_upper_limit(cohn):\n        \"\"\" Sets the upper_dl DL for each row of the Cohn dataframe. \"\"\"\n        if cohn.shape[0] > 1:\n            return cohn['lower_dl'].shift(-1).fillna(value=np.inf)\n        else:\n            return [np.inf]\n\n    def compute_PE(A, B):\n        \"\"\" Computes the probability of excedance for each row of the\n        Cohn dataframe. \"\"\"\n        N = len(A)\n        PE = np.empty(N, dtype='float64')\n        PE[-1] = 0.0\n        for j in range(N - 2, -1, -1):\n            PE[j] = PE[j + 1] + (1 - PE[j + 1]) * A[j] / (A[j] + B[j])\n        return PE\n    censored_data = df[censorship]\n    DLs = pd.unique(df.loc[censored_data, observations])\n    DLs.sort()\n    if DLs.shape[0] > 0:\n        if df[observations].min() < DLs.min():\n            DLs = np.hstack([df[observations].min(), DLs])\n        cohn = pd.DataFrame(DLs, columns=['lower_dl'])\n        cohn.loc[:, 'upper_dl'] = set_upper_limit(cohn)\n        cohn.loc[:, 'nuncen_above'] = cohn.apply(nuncen_above, axis=1)\n        cohn.loc[:, 'nobs_below'] = cohn.apply(nobs_below, axis=1)\n        cohn.loc[:, 'ncen_equal'] = cohn.apply(ncen_equal, axis=1)\n        cohn = cohn.reindex(range(DLs.shape[0] + 1))\n        cohn.loc[:, 'prob_exceedance'] = compute_PE(cohn['nuncen_above'], cohn['nobs_below'])\n    else:\n        dl_cols = ['lower_dl', 'upper_dl', 'nuncen_above', 'nobs_below', 'ncen_equal', 'prob_exceedance']\n        cohn = pd.DataFrame(np.empty((0, len(dl_cols))), columns=dl_cols)\n    return cohn"
        ]
    },
    {
        "func_name": "_detection_limit_index",
        "original": "def _detection_limit_index(obs, cohn):\n    \"\"\"\n    Locates the corresponding detection limit for each observation.\n\n    Basically, creates an array of indices for the detection limits\n    (Cohn numbers) corresponding to each data point.\n\n    Parameters\n    ----------\n    obs : float\n        A single observation from the larger dataset.\n\n    cohn : DataFrame\n        DataFrame of Cohn numbers.\n\n    Returns\n    -------\n    det_limit_index : int\n        The index of the corresponding detection limit in `cohn`\n\n    See Also\n    --------\n    cohn_numbers\n    \"\"\"\n    if cohn.shape[0] > 0:\n        (index,) = np.where(cohn['lower_dl'] <= obs)\n        det_limit_index = index[-1]\n    else:\n        det_limit_index = 0\n    return det_limit_index",
        "mutated": [
            "def _detection_limit_index(obs, cohn):\n    if False:\n        i = 10\n    '\\n    Locates the corresponding detection limit for each observation.\\n\\n    Basically, creates an array of indices for the detection limits\\n    (Cohn numbers) corresponding to each data point.\\n\\n    Parameters\\n    ----------\\n    obs : float\\n        A single observation from the larger dataset.\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    det_limit_index : int\\n        The index of the corresponding detection limit in `cohn`\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    '\n    if cohn.shape[0] > 0:\n        (index,) = np.where(cohn['lower_dl'] <= obs)\n        det_limit_index = index[-1]\n    else:\n        det_limit_index = 0\n    return det_limit_index",
            "def _detection_limit_index(obs, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Locates the corresponding detection limit for each observation.\\n\\n    Basically, creates an array of indices for the detection limits\\n    (Cohn numbers) corresponding to each data point.\\n\\n    Parameters\\n    ----------\\n    obs : float\\n        A single observation from the larger dataset.\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    det_limit_index : int\\n        The index of the corresponding detection limit in `cohn`\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    '\n    if cohn.shape[0] > 0:\n        (index,) = np.where(cohn['lower_dl'] <= obs)\n        det_limit_index = index[-1]\n    else:\n        det_limit_index = 0\n    return det_limit_index",
            "def _detection_limit_index(obs, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Locates the corresponding detection limit for each observation.\\n\\n    Basically, creates an array of indices for the detection limits\\n    (Cohn numbers) corresponding to each data point.\\n\\n    Parameters\\n    ----------\\n    obs : float\\n        A single observation from the larger dataset.\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    det_limit_index : int\\n        The index of the corresponding detection limit in `cohn`\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    '\n    if cohn.shape[0] > 0:\n        (index,) = np.where(cohn['lower_dl'] <= obs)\n        det_limit_index = index[-1]\n    else:\n        det_limit_index = 0\n    return det_limit_index",
            "def _detection_limit_index(obs, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Locates the corresponding detection limit for each observation.\\n\\n    Basically, creates an array of indices for the detection limits\\n    (Cohn numbers) corresponding to each data point.\\n\\n    Parameters\\n    ----------\\n    obs : float\\n        A single observation from the larger dataset.\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    det_limit_index : int\\n        The index of the corresponding detection limit in `cohn`\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    '\n    if cohn.shape[0] > 0:\n        (index,) = np.where(cohn['lower_dl'] <= obs)\n        det_limit_index = index[-1]\n    else:\n        det_limit_index = 0\n    return det_limit_index",
            "def _detection_limit_index(obs, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Locates the corresponding detection limit for each observation.\\n\\n    Basically, creates an array of indices for the detection limits\\n    (Cohn numbers) corresponding to each data point.\\n\\n    Parameters\\n    ----------\\n    obs : float\\n        A single observation from the larger dataset.\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    det_limit_index : int\\n        The index of the corresponding detection limit in `cohn`\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    '\n    if cohn.shape[0] > 0:\n        (index,) = np.where(cohn['lower_dl'] <= obs)\n        det_limit_index = index[-1]\n    else:\n        det_limit_index = 0\n    return det_limit_index"
        ]
    },
    {
        "func_name": "_ros_group_rank",
        "original": "def _ros_group_rank(df, dl_idx, censorship):\n    \"\"\"\n    Ranks each observation within the data groups.\n\n    In this case, the groups are defined by the record's detection\n    limit index and censorship status.\n\n    Parameters\n    ----------\n    df : DataFrame\n\n    dl_idx : str\n        Name of the column in the dataframe the index of the\n        observations' corresponding detection limit in the `cohn`\n        dataframe.\n\n    censorship : str\n        Name of the column in the dataframe that indicates that a\n        observation is left-censored. (i.e., True -> censored,\n        False -> uncensored)\n\n    Returns\n    -------\n    ranks : ndarray\n        Array of ranks for the dataset.\n    \"\"\"\n    ranks = df.copy()\n    ranks.loc[:, 'rank'] = 1\n    ranks = ranks.groupby(by=[dl_idx, censorship])['rank'].transform(lambda g: g.cumsum())\n    return ranks",
        "mutated": [
            "def _ros_group_rank(df, dl_idx, censorship):\n    if False:\n        i = 10\n    \"\\n    Ranks each observation within the data groups.\\n\\n    In this case, the groups are defined by the record's detection\\n    limit index and censorship status.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    dl_idx : str\\n        Name of the column in the dataframe the index of the\\n        observations' corresponding detection limit in the `cohn`\\n        dataframe.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    ranks : ndarray\\n        Array of ranks for the dataset.\\n    \"\n    ranks = df.copy()\n    ranks.loc[:, 'rank'] = 1\n    ranks = ranks.groupby(by=[dl_idx, censorship])['rank'].transform(lambda g: g.cumsum())\n    return ranks",
            "def _ros_group_rank(df, dl_idx, censorship):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Ranks each observation within the data groups.\\n\\n    In this case, the groups are defined by the record's detection\\n    limit index and censorship status.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    dl_idx : str\\n        Name of the column in the dataframe the index of the\\n        observations' corresponding detection limit in the `cohn`\\n        dataframe.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    ranks : ndarray\\n        Array of ranks for the dataset.\\n    \"\n    ranks = df.copy()\n    ranks.loc[:, 'rank'] = 1\n    ranks = ranks.groupby(by=[dl_idx, censorship])['rank'].transform(lambda g: g.cumsum())\n    return ranks",
            "def _ros_group_rank(df, dl_idx, censorship):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Ranks each observation within the data groups.\\n\\n    In this case, the groups are defined by the record's detection\\n    limit index and censorship status.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    dl_idx : str\\n        Name of the column in the dataframe the index of the\\n        observations' corresponding detection limit in the `cohn`\\n        dataframe.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    ranks : ndarray\\n        Array of ranks for the dataset.\\n    \"\n    ranks = df.copy()\n    ranks.loc[:, 'rank'] = 1\n    ranks = ranks.groupby(by=[dl_idx, censorship])['rank'].transform(lambda g: g.cumsum())\n    return ranks",
            "def _ros_group_rank(df, dl_idx, censorship):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Ranks each observation within the data groups.\\n\\n    In this case, the groups are defined by the record's detection\\n    limit index and censorship status.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    dl_idx : str\\n        Name of the column in the dataframe the index of the\\n        observations' corresponding detection limit in the `cohn`\\n        dataframe.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    ranks : ndarray\\n        Array of ranks for the dataset.\\n    \"\n    ranks = df.copy()\n    ranks.loc[:, 'rank'] = 1\n    ranks = ranks.groupby(by=[dl_idx, censorship])['rank'].transform(lambda g: g.cumsum())\n    return ranks",
            "def _ros_group_rank(df, dl_idx, censorship):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Ranks each observation within the data groups.\\n\\n    In this case, the groups are defined by the record's detection\\n    limit index and censorship status.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    dl_idx : str\\n        Name of the column in the dataframe the index of the\\n        observations' corresponding detection limit in the `cohn`\\n        dataframe.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    Returns\\n    -------\\n    ranks : ndarray\\n        Array of ranks for the dataset.\\n    \"\n    ranks = df.copy()\n    ranks.loc[:, 'rank'] = 1\n    ranks = ranks.groupby(by=[dl_idx, censorship])['rank'].transform(lambda g: g.cumsum())\n    return ranks"
        ]
    },
    {
        "func_name": "_ros_plot_pos",
        "original": "def _ros_plot_pos(row, censorship, cohn):\n    \"\"\"\n    ROS-specific plotting positions.\n\n    Computes the plotting position for an observation based on its rank,\n    censorship status, and detection limit index.\n\n    Parameters\n    ----------\n    row : {Series, dict}\n        Full observation (row) from a censored dataset. Requires a\n        'rank', 'detection_limit', and `censorship` column.\n\n    censorship : str\n        Name of the column in the dataframe that indicates that a\n        observation is left-censored. (i.e., True -> censored,\n        False -> uncensored)\n\n    cohn : DataFrame\n        DataFrame of Cohn numbers.\n\n    Returns\n    -------\n    plotting_position : float\n\n    See Also\n    --------\n    cohn_numbers\n    \"\"\"\n    DL_index = row['det_limit_index']\n    rank = row['rank']\n    censored = row[censorship]\n    dl_1 = cohn.iloc[DL_index]\n    dl_2 = cohn.iloc[DL_index + 1]\n    if censored:\n        return (1 - dl_1['prob_exceedance']) * rank / (dl_1['ncen_equal'] + 1)\n    else:\n        return 1 - dl_1['prob_exceedance'] + (dl_1['prob_exceedance'] - dl_2['prob_exceedance']) * rank / (dl_1['nuncen_above'] + 1)",
        "mutated": [
            "def _ros_plot_pos(row, censorship, cohn):\n    if False:\n        i = 10\n    \"\\n    ROS-specific plotting positions.\\n\\n    Computes the plotting position for an observation based on its rank,\\n    censorship status, and detection limit index.\\n\\n    Parameters\\n    ----------\\n    row : {Series, dict}\\n        Full observation (row) from a censored dataset. Requires a\\n        'rank', 'detection_limit', and `censorship` column.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    DL_index = row['det_limit_index']\n    rank = row['rank']\n    censored = row[censorship]\n    dl_1 = cohn.iloc[DL_index]\n    dl_2 = cohn.iloc[DL_index + 1]\n    if censored:\n        return (1 - dl_1['prob_exceedance']) * rank / (dl_1['ncen_equal'] + 1)\n    else:\n        return 1 - dl_1['prob_exceedance'] + (dl_1['prob_exceedance'] - dl_2['prob_exceedance']) * rank / (dl_1['nuncen_above'] + 1)",
            "def _ros_plot_pos(row, censorship, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    ROS-specific plotting positions.\\n\\n    Computes the plotting position for an observation based on its rank,\\n    censorship status, and detection limit index.\\n\\n    Parameters\\n    ----------\\n    row : {Series, dict}\\n        Full observation (row) from a censored dataset. Requires a\\n        'rank', 'detection_limit', and `censorship` column.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    DL_index = row['det_limit_index']\n    rank = row['rank']\n    censored = row[censorship]\n    dl_1 = cohn.iloc[DL_index]\n    dl_2 = cohn.iloc[DL_index + 1]\n    if censored:\n        return (1 - dl_1['prob_exceedance']) * rank / (dl_1['ncen_equal'] + 1)\n    else:\n        return 1 - dl_1['prob_exceedance'] + (dl_1['prob_exceedance'] - dl_2['prob_exceedance']) * rank / (dl_1['nuncen_above'] + 1)",
            "def _ros_plot_pos(row, censorship, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    ROS-specific plotting positions.\\n\\n    Computes the plotting position for an observation based on its rank,\\n    censorship status, and detection limit index.\\n\\n    Parameters\\n    ----------\\n    row : {Series, dict}\\n        Full observation (row) from a censored dataset. Requires a\\n        'rank', 'detection_limit', and `censorship` column.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    DL_index = row['det_limit_index']\n    rank = row['rank']\n    censored = row[censorship]\n    dl_1 = cohn.iloc[DL_index]\n    dl_2 = cohn.iloc[DL_index + 1]\n    if censored:\n        return (1 - dl_1['prob_exceedance']) * rank / (dl_1['ncen_equal'] + 1)\n    else:\n        return 1 - dl_1['prob_exceedance'] + (dl_1['prob_exceedance'] - dl_2['prob_exceedance']) * rank / (dl_1['nuncen_above'] + 1)",
            "def _ros_plot_pos(row, censorship, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    ROS-specific plotting positions.\\n\\n    Computes the plotting position for an observation based on its rank,\\n    censorship status, and detection limit index.\\n\\n    Parameters\\n    ----------\\n    row : {Series, dict}\\n        Full observation (row) from a censored dataset. Requires a\\n        'rank', 'detection_limit', and `censorship` column.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    DL_index = row['det_limit_index']\n    rank = row['rank']\n    censored = row[censorship]\n    dl_1 = cohn.iloc[DL_index]\n    dl_2 = cohn.iloc[DL_index + 1]\n    if censored:\n        return (1 - dl_1['prob_exceedance']) * rank / (dl_1['ncen_equal'] + 1)\n    else:\n        return 1 - dl_1['prob_exceedance'] + (dl_1['prob_exceedance'] - dl_2['prob_exceedance']) * rank / (dl_1['nuncen_above'] + 1)",
            "def _ros_plot_pos(row, censorship, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    ROS-specific plotting positions.\\n\\n    Computes the plotting position for an observation based on its rank,\\n    censorship status, and detection limit index.\\n\\n    Parameters\\n    ----------\\n    row : {Series, dict}\\n        Full observation (row) from a censored dataset. Requires a\\n        'rank', 'detection_limit', and `censorship` column.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    DL_index = row['det_limit_index']\n    rank = row['rank']\n    censored = row[censorship]\n    dl_1 = cohn.iloc[DL_index]\n    dl_2 = cohn.iloc[DL_index + 1]\n    if censored:\n        return (1 - dl_1['prob_exceedance']) * rank / (dl_1['ncen_equal'] + 1)\n    else:\n        return 1 - dl_1['prob_exceedance'] + (dl_1['prob_exceedance'] - dl_2['prob_exceedance']) * rank / (dl_1['nuncen_above'] + 1)"
        ]
    },
    {
        "func_name": "_norm_plot_pos",
        "original": "def _norm_plot_pos(observations):\n    \"\"\"\n    Computes standard normal (Gaussian) plotting positions using scipy.\n\n    Parameters\n    ----------\n    observations : array_like\n        Sequence of observed quantities.\n\n    Returns\n    -------\n    plotting_position : array of floats\n    \"\"\"\n    (ppos, sorted_res) = stats.probplot(observations, fit=False)\n    return stats.norm.cdf(ppos)",
        "mutated": [
            "def _norm_plot_pos(observations):\n    if False:\n        i = 10\n    '\\n    Computes standard normal (Gaussian) plotting positions using scipy.\\n\\n    Parameters\\n    ----------\\n    observations : array_like\\n        Sequence of observed quantities.\\n\\n    Returns\\n    -------\\n    plotting_position : array of floats\\n    '\n    (ppos, sorted_res) = stats.probplot(observations, fit=False)\n    return stats.norm.cdf(ppos)",
            "def _norm_plot_pos(observations):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes standard normal (Gaussian) plotting positions using scipy.\\n\\n    Parameters\\n    ----------\\n    observations : array_like\\n        Sequence of observed quantities.\\n\\n    Returns\\n    -------\\n    plotting_position : array of floats\\n    '\n    (ppos, sorted_res) = stats.probplot(observations, fit=False)\n    return stats.norm.cdf(ppos)",
            "def _norm_plot_pos(observations):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes standard normal (Gaussian) plotting positions using scipy.\\n\\n    Parameters\\n    ----------\\n    observations : array_like\\n        Sequence of observed quantities.\\n\\n    Returns\\n    -------\\n    plotting_position : array of floats\\n    '\n    (ppos, sorted_res) = stats.probplot(observations, fit=False)\n    return stats.norm.cdf(ppos)",
            "def _norm_plot_pos(observations):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes standard normal (Gaussian) plotting positions using scipy.\\n\\n    Parameters\\n    ----------\\n    observations : array_like\\n        Sequence of observed quantities.\\n\\n    Returns\\n    -------\\n    plotting_position : array of floats\\n    '\n    (ppos, sorted_res) = stats.probplot(observations, fit=False)\n    return stats.norm.cdf(ppos)",
            "def _norm_plot_pos(observations):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes standard normal (Gaussian) plotting positions using scipy.\\n\\n    Parameters\\n    ----------\\n    observations : array_like\\n        Sequence of observed quantities.\\n\\n    Returns\\n    -------\\n    plotting_position : array of floats\\n    '\n    (ppos, sorted_res) = stats.probplot(observations, fit=False)\n    return stats.norm.cdf(ppos)"
        ]
    },
    {
        "func_name": "plotting_positions",
        "original": "def plotting_positions(df, censorship, cohn):\n    \"\"\"\n    Compute the plotting positions for the observations.\n\n    The ROS-specific plotting postions are based on the observations'\n    rank, censorship status, and corresponding detection limit.\n\n    Parameters\n    ----------\n    df : DataFrame\n\n    censorship : str\n        Name of the column in the dataframe that indicates that a\n        observation is left-censored. (i.e., True -> censored,\n        False -> uncensored)\n\n    cohn : DataFrame\n        DataFrame of Cohn numbers.\n\n    Returns\n    -------\n    plotting_position : array of float\n\n    See Also\n    --------\n    cohn_numbers\n    \"\"\"\n    plot_pos = df.apply(lambda r: _ros_plot_pos(r, censorship, cohn), axis=1)\n    ND_plotpos = plot_pos[df[censorship]]\n    ND_plotpos_arr = np.require(ND_plotpos, requirements='W')\n    ND_plotpos_arr.sort()\n    plot_pos.loc[df[censorship].index[df[censorship]]] = ND_plotpos_arr\n    return plot_pos",
        "mutated": [
            "def plotting_positions(df, censorship, cohn):\n    if False:\n        i = 10\n    \"\\n    Compute the plotting positions for the observations.\\n\\n    The ROS-specific plotting postions are based on the observations'\\n    rank, censorship status, and corresponding detection limit.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : array of float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    plot_pos = df.apply(lambda r: _ros_plot_pos(r, censorship, cohn), axis=1)\n    ND_plotpos = plot_pos[df[censorship]]\n    ND_plotpos_arr = np.require(ND_plotpos, requirements='W')\n    ND_plotpos_arr.sort()\n    plot_pos.loc[df[censorship].index[df[censorship]]] = ND_plotpos_arr\n    return plot_pos",
            "def plotting_positions(df, censorship, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute the plotting positions for the observations.\\n\\n    The ROS-specific plotting postions are based on the observations'\\n    rank, censorship status, and corresponding detection limit.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : array of float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    plot_pos = df.apply(lambda r: _ros_plot_pos(r, censorship, cohn), axis=1)\n    ND_plotpos = plot_pos[df[censorship]]\n    ND_plotpos_arr = np.require(ND_plotpos, requirements='W')\n    ND_plotpos_arr.sort()\n    plot_pos.loc[df[censorship].index[df[censorship]]] = ND_plotpos_arr\n    return plot_pos",
            "def plotting_positions(df, censorship, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute the plotting positions for the observations.\\n\\n    The ROS-specific plotting postions are based on the observations'\\n    rank, censorship status, and corresponding detection limit.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : array of float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    plot_pos = df.apply(lambda r: _ros_plot_pos(r, censorship, cohn), axis=1)\n    ND_plotpos = plot_pos[df[censorship]]\n    ND_plotpos_arr = np.require(ND_plotpos, requirements='W')\n    ND_plotpos_arr.sort()\n    plot_pos.loc[df[censorship].index[df[censorship]]] = ND_plotpos_arr\n    return plot_pos",
            "def plotting_positions(df, censorship, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute the plotting positions for the observations.\\n\\n    The ROS-specific plotting postions are based on the observations'\\n    rank, censorship status, and corresponding detection limit.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : array of float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    plot_pos = df.apply(lambda r: _ros_plot_pos(r, censorship, cohn), axis=1)\n    ND_plotpos = plot_pos[df[censorship]]\n    ND_plotpos_arr = np.require(ND_plotpos, requirements='W')\n    ND_plotpos_arr.sort()\n    plot_pos.loc[df[censorship].index[df[censorship]]] = ND_plotpos_arr\n    return plot_pos",
            "def plotting_positions(df, censorship, cohn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute the plotting positions for the observations.\\n\\n    The ROS-specific plotting postions are based on the observations'\\n    rank, censorship status, and corresponding detection limit.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    cohn : DataFrame\\n        DataFrame of Cohn numbers.\\n\\n    Returns\\n    -------\\n    plotting_position : array of float\\n\\n    See Also\\n    --------\\n    cohn_numbers\\n    \"\n    plot_pos = df.apply(lambda r: _ros_plot_pos(r, censorship, cohn), axis=1)\n    ND_plotpos = plot_pos[df[censorship]]\n    ND_plotpos_arr = np.require(ND_plotpos, requirements='W')\n    ND_plotpos_arr.sort()\n    plot_pos.loc[df[censorship].index[df[censorship]]] = ND_plotpos_arr\n    return plot_pos"
        ]
    },
    {
        "func_name": "_impute",
        "original": "def _impute(df, observations, censorship, transform_in, transform_out):\n    \"\"\"\n    Executes the basic regression on order stat (ROS) proceedure.\n\n    Uses ROS to impute censored from the best-fit line of a\n    probability plot of the uncensored values.\n\n    Parameters\n    ----------\n    df : DataFrame\n    observations : str\n        Name of the column in the dataframe that contains observed\n        values. Censored values should be set to the detection (upper)\n        limit.\n    censorship : str\n        Name of the column in the dataframe that indicates that a\n        observation is left-censored. (i.e., True -> censored,\n        False -> uncensored)\n    transform_in, transform_out : callable\n        Transformations to be applied to the data prior to fitting\n        the line and after estimated values from that line. Typically,\n        `np.log` and `np.exp` are used, respectively.\n\n    Returns\n    -------\n    estimated : DataFrame\n        A new dataframe with two new columns: \"estimated\" and \"final\".\n        The \"estimated\" column contains of the values inferred from the\n        best-fit line. The \"final\" column contains the estimated values\n        only where the original observations were censored, and the original\n        observations everwhere else.\n    \"\"\"\n    uncensored_mask = ~df[censorship]\n    censored_mask = df[censorship]\n    fit_params = stats.linregress(df['Zprelim'][uncensored_mask], transform_in(df[observations][uncensored_mask]))\n    (slope, intercept) = fit_params[:2]\n    df.loc[:, 'estimated'] = transform_out(slope * df['Zprelim'][censored_mask] + intercept)\n    df.loc[:, 'final'] = np.where(df[censorship], df['estimated'], df[observations])\n    return df",
        "mutated": [
            "def _impute(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n    '\\n    Executes the basic regression on order stat (ROS) proceedure.\\n\\n    Uses ROS to impute censored from the best-fit line of a\\n    probability plot of the uncensored values.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    uncensored_mask = ~df[censorship]\n    censored_mask = df[censorship]\n    fit_params = stats.linregress(df['Zprelim'][uncensored_mask], transform_in(df[observations][uncensored_mask]))\n    (slope, intercept) = fit_params[:2]\n    df.loc[:, 'estimated'] = transform_out(slope * df['Zprelim'][censored_mask] + intercept)\n    df.loc[:, 'final'] = np.where(df[censorship], df['estimated'], df[observations])\n    return df",
            "def _impute(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Executes the basic regression on order stat (ROS) proceedure.\\n\\n    Uses ROS to impute censored from the best-fit line of a\\n    probability plot of the uncensored values.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    uncensored_mask = ~df[censorship]\n    censored_mask = df[censorship]\n    fit_params = stats.linregress(df['Zprelim'][uncensored_mask], transform_in(df[observations][uncensored_mask]))\n    (slope, intercept) = fit_params[:2]\n    df.loc[:, 'estimated'] = transform_out(slope * df['Zprelim'][censored_mask] + intercept)\n    df.loc[:, 'final'] = np.where(df[censorship], df['estimated'], df[observations])\n    return df",
            "def _impute(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Executes the basic regression on order stat (ROS) proceedure.\\n\\n    Uses ROS to impute censored from the best-fit line of a\\n    probability plot of the uncensored values.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    uncensored_mask = ~df[censorship]\n    censored_mask = df[censorship]\n    fit_params = stats.linregress(df['Zprelim'][uncensored_mask], transform_in(df[observations][uncensored_mask]))\n    (slope, intercept) = fit_params[:2]\n    df.loc[:, 'estimated'] = transform_out(slope * df['Zprelim'][censored_mask] + intercept)\n    df.loc[:, 'final'] = np.where(df[censorship], df['estimated'], df[observations])\n    return df",
            "def _impute(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Executes the basic regression on order stat (ROS) proceedure.\\n\\n    Uses ROS to impute censored from the best-fit line of a\\n    probability plot of the uncensored values.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    uncensored_mask = ~df[censorship]\n    censored_mask = df[censorship]\n    fit_params = stats.linregress(df['Zprelim'][uncensored_mask], transform_in(df[observations][uncensored_mask]))\n    (slope, intercept) = fit_params[:2]\n    df.loc[:, 'estimated'] = transform_out(slope * df['Zprelim'][censored_mask] + intercept)\n    df.loc[:, 'final'] = np.where(df[censorship], df['estimated'], df[observations])\n    return df",
            "def _impute(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Executes the basic regression on order stat (ROS) proceedure.\\n\\n    Uses ROS to impute censored from the best-fit line of a\\n    probability plot of the uncensored values.\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    uncensored_mask = ~df[censorship]\n    censored_mask = df[censorship]\n    fit_params = stats.linregress(df['Zprelim'][uncensored_mask], transform_in(df[observations][uncensored_mask]))\n    (slope, intercept) = fit_params[:2]\n    df.loc[:, 'estimated'] = transform_out(slope * df['Zprelim'][censored_mask] + intercept)\n    df.loc[:, 'final'] = np.where(df[censorship], df['estimated'], df[observations])\n    return df"
        ]
    },
    {
        "func_name": "_do_ros",
        "original": "def _do_ros(df, observations, censorship, transform_in, transform_out):\n    \"\"\"\n    DataFrame-centric function to impute censored valies with ROS.\n\n    Prepares a dataframe for, and then esimates the values of a censored\n    dataset using Regression on Order Statistics\n\n    Parameters\n    ----------\n    df : DataFrame\n\n    observations : str\n        Name of the column in the dataframe that contains observed\n        values. Censored values should be set to the detection (upper)\n        limit.\n\n    censorship : str\n        Name of the column in the dataframe that indicates that a\n        observation is left-censored. (i.e., True -> censored,\n        False -> uncensored)\n\n    transform_in, transform_out : callable\n        Transformations to be applied to the data prior to fitting\n        the line and after estimated values from that line. Typically,\n        `np.log` and `np.exp` are used, respectively.\n\n    Returns\n    -------\n    estimated : DataFrame\n        A new dataframe with two new columns: \"estimated\" and \"final\".\n        The \"estimated\" column contains of the values inferred from the\n        best-fit line. The \"final\" column contains the estimated values\n        only where the original observations were censored, and the original\n        observations everwhere else.\n    \"\"\"\n    cohn = cohn_numbers(df, observations=observations, censorship=censorship)\n    modeled = _ros_sort(df, observations=observations, censorship=censorship)\n    modeled.loc[:, 'det_limit_index'] = modeled[observations].apply(_detection_limit_index, args=(cohn,))\n    modeled.loc[:, 'rank'] = _ros_group_rank(modeled, 'det_limit_index', censorship)\n    modeled.loc[:, 'plot_pos'] = plotting_positions(modeled, censorship, cohn)\n    modeled.loc[:, 'Zprelim'] = stats.norm.ppf(modeled['plot_pos'])\n    return _impute(modeled, observations, censorship, transform_in, transform_out)",
        "mutated": [
            "def _do_ros(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n    '\\n    DataFrame-centric function to impute censored valies with ROS.\\n\\n    Prepares a dataframe for, and then esimates the values of a censored\\n    dataset using Regression on Order Statistics\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    cohn = cohn_numbers(df, observations=observations, censorship=censorship)\n    modeled = _ros_sort(df, observations=observations, censorship=censorship)\n    modeled.loc[:, 'det_limit_index'] = modeled[observations].apply(_detection_limit_index, args=(cohn,))\n    modeled.loc[:, 'rank'] = _ros_group_rank(modeled, 'det_limit_index', censorship)\n    modeled.loc[:, 'plot_pos'] = plotting_positions(modeled, censorship, cohn)\n    modeled.loc[:, 'Zprelim'] = stats.norm.ppf(modeled['plot_pos'])\n    return _impute(modeled, observations, censorship, transform_in, transform_out)",
            "def _do_ros(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    DataFrame-centric function to impute censored valies with ROS.\\n\\n    Prepares a dataframe for, and then esimates the values of a censored\\n    dataset using Regression on Order Statistics\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    cohn = cohn_numbers(df, observations=observations, censorship=censorship)\n    modeled = _ros_sort(df, observations=observations, censorship=censorship)\n    modeled.loc[:, 'det_limit_index'] = modeled[observations].apply(_detection_limit_index, args=(cohn,))\n    modeled.loc[:, 'rank'] = _ros_group_rank(modeled, 'det_limit_index', censorship)\n    modeled.loc[:, 'plot_pos'] = plotting_positions(modeled, censorship, cohn)\n    modeled.loc[:, 'Zprelim'] = stats.norm.ppf(modeled['plot_pos'])\n    return _impute(modeled, observations, censorship, transform_in, transform_out)",
            "def _do_ros(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    DataFrame-centric function to impute censored valies with ROS.\\n\\n    Prepares a dataframe for, and then esimates the values of a censored\\n    dataset using Regression on Order Statistics\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    cohn = cohn_numbers(df, observations=observations, censorship=censorship)\n    modeled = _ros_sort(df, observations=observations, censorship=censorship)\n    modeled.loc[:, 'det_limit_index'] = modeled[observations].apply(_detection_limit_index, args=(cohn,))\n    modeled.loc[:, 'rank'] = _ros_group_rank(modeled, 'det_limit_index', censorship)\n    modeled.loc[:, 'plot_pos'] = plotting_positions(modeled, censorship, cohn)\n    modeled.loc[:, 'Zprelim'] = stats.norm.ppf(modeled['plot_pos'])\n    return _impute(modeled, observations, censorship, transform_in, transform_out)",
            "def _do_ros(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    DataFrame-centric function to impute censored valies with ROS.\\n\\n    Prepares a dataframe for, and then esimates the values of a censored\\n    dataset using Regression on Order Statistics\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    cohn = cohn_numbers(df, observations=observations, censorship=censorship)\n    modeled = _ros_sort(df, observations=observations, censorship=censorship)\n    modeled.loc[:, 'det_limit_index'] = modeled[observations].apply(_detection_limit_index, args=(cohn,))\n    modeled.loc[:, 'rank'] = _ros_group_rank(modeled, 'det_limit_index', censorship)\n    modeled.loc[:, 'plot_pos'] = plotting_positions(modeled, censorship, cohn)\n    modeled.loc[:, 'Zprelim'] = stats.norm.ppf(modeled['plot_pos'])\n    return _impute(modeled, observations, censorship, transform_in, transform_out)",
            "def _do_ros(df, observations, censorship, transform_in, transform_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    DataFrame-centric function to impute censored valies with ROS.\\n\\n    Prepares a dataframe for, and then esimates the values of a censored\\n    dataset using Regression on Order Statistics\\n\\n    Parameters\\n    ----------\\n    df : DataFrame\\n\\n    observations : str\\n        Name of the column in the dataframe that contains observed\\n        values. Censored values should be set to the detection (upper)\\n        limit.\\n\\n    censorship : str\\n        Name of the column in the dataframe that indicates that a\\n        observation is left-censored. (i.e., True -> censored,\\n        False -> uncensored)\\n\\n    transform_in, transform_out : callable\\n        Transformations to be applied to the data prior to fitting\\n        the line and after estimated values from that line. Typically,\\n        `np.log` and `np.exp` are used, respectively.\\n\\n    Returns\\n    -------\\n    estimated : DataFrame\\n        A new dataframe with two new columns: \"estimated\" and \"final\".\\n        The \"estimated\" column contains of the values inferred from the\\n        best-fit line. The \"final\" column contains the estimated values\\n        only where the original observations were censored, and the original\\n        observations everwhere else.\\n    '\n    cohn = cohn_numbers(df, observations=observations, censorship=censorship)\n    modeled = _ros_sort(df, observations=observations, censorship=censorship)\n    modeled.loc[:, 'det_limit_index'] = modeled[observations].apply(_detection_limit_index, args=(cohn,))\n    modeled.loc[:, 'rank'] = _ros_group_rank(modeled, 'det_limit_index', censorship)\n    modeled.loc[:, 'plot_pos'] = plotting_positions(modeled, censorship, cohn)\n    modeled.loc[:, 'Zprelim'] = stats.norm.ppf(modeled['plot_pos'])\n    return _impute(modeled, observations, censorship, transform_in, transform_out)"
        ]
    },
    {
        "func_name": "impute_ros",
        "original": "def impute_ros(observations, censorship, df=None, min_uncensored=2, max_fraction_censored=0.8, substitution_fraction=0.5, transform_in=np.log, transform_out=np.exp, as_array=True):\n    \"\"\"\n    Impute censored dataset using Regression on Order Statistics (ROS).\n\n    Method described in *Nondetects and Data Analysis* by Dennis R.\n    Helsel (John Wiley, 2005) to estimate the left-censored (non-detect)\n    values of a dataset. When there is insufficient non-censorded data,\n    simple substitution is used.\n\n    Parameters\n    ----------\n    observations : str or array-like\n        Label of the column or the float array of censored observations\n\n    censorship : str\n        Label of the column or the bool array of the censorship\n        status of the observations.\n\n          * True if censored,\n          * False if uncensored\n\n    df : DataFrame, optional\n        If `observations` and `censorship` are labels, this is the\n        DataFrame that contains those columns.\n\n    min_uncensored : int (default is 2)\n        The minimum number of uncensored values required before ROS\n        can be used to impute the censored observations. When this\n        criterion is not met, simple substituion is used instead.\n\n    max_fraction_censored : float (default is 0.8)\n        The maximum fraction of censored data below which ROS can be\n        used to impute the censored observations. When this fraction is\n        exceeded, simple substituion is used instead.\n\n    substitution_fraction : float (default is 0.5)\n        The fraction of the detection limit to be used during simple\n        substitution of the censored values.\n\n    transform_in : callable (default is np.log)\n        Transformation to be applied to the values prior to fitting a\n        line to the plotting positions vs. uncensored values.\n\n    transform_out : callable (default is np.exp)\n        Transformation to be applied to the imputed censored values\n        estimated from the previously computed best-fit line.\n\n    as_array : bool (default is True)\n        When True, a numpy array of the imputed observations is\n        returned. Otherwise, a modified copy of the original dataframe\n        with all of the intermediate calculations is returned.\n\n    Returns\n    -------\n    imputed : {ndarray, DataFrame}\n        The final observations where the censored values have either been\n        imputed through ROS or substituted as a fraction of the\n        detection limit.\n\n    Notes\n    -----\n    This function requires pandas 0.14 or more recent.\n    \"\"\"\n    if df is None:\n        df = pd.DataFrame({'obs': observations, 'cen': censorship})\n        observations = 'obs'\n        censorship = 'cen'\n    N_observations = df.shape[0]\n    N_censored = df[censorship].astype(int).sum()\n    N_uncensored = N_observations - N_censored\n    fraction_censored = N_censored / N_observations\n    if N_censored == 0:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n    elif N_uncensored < min_uncensored or fraction_censored > max_fraction_censored:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n        output.loc[df[censorship], 'final'] *= substitution_fraction\n    else:\n        output = _do_ros(df, observations, censorship, transform_in, transform_out)\n    if as_array:\n        output = output['final'].values\n    return output",
        "mutated": [
            "def impute_ros(observations, censorship, df=None, min_uncensored=2, max_fraction_censored=0.8, substitution_fraction=0.5, transform_in=np.log, transform_out=np.exp, as_array=True):\n    if False:\n        i = 10\n    '\\n    Impute censored dataset using Regression on Order Statistics (ROS).\\n\\n    Method described in *Nondetects and Data Analysis* by Dennis R.\\n    Helsel (John Wiley, 2005) to estimate the left-censored (non-detect)\\n    values of a dataset. When there is insufficient non-censorded data,\\n    simple substitution is used.\\n\\n    Parameters\\n    ----------\\n    observations : str or array-like\\n        Label of the column or the float array of censored observations\\n\\n    censorship : str\\n        Label of the column or the bool array of the censorship\\n        status of the observations.\\n\\n          * True if censored,\\n          * False if uncensored\\n\\n    df : DataFrame, optional\\n        If `observations` and `censorship` are labels, this is the\\n        DataFrame that contains those columns.\\n\\n    min_uncensored : int (default is 2)\\n        The minimum number of uncensored values required before ROS\\n        can be used to impute the censored observations. When this\\n        criterion is not met, simple substituion is used instead.\\n\\n    max_fraction_censored : float (default is 0.8)\\n        The maximum fraction of censored data below which ROS can be\\n        used to impute the censored observations. When this fraction is\\n        exceeded, simple substituion is used instead.\\n\\n    substitution_fraction : float (default is 0.5)\\n        The fraction of the detection limit to be used during simple\\n        substitution of the censored values.\\n\\n    transform_in : callable (default is np.log)\\n        Transformation to be applied to the values prior to fitting a\\n        line to the plotting positions vs. uncensored values.\\n\\n    transform_out : callable (default is np.exp)\\n        Transformation to be applied to the imputed censored values\\n        estimated from the previously computed best-fit line.\\n\\n    as_array : bool (default is True)\\n        When True, a numpy array of the imputed observations is\\n        returned. Otherwise, a modified copy of the original dataframe\\n        with all of the intermediate calculations is returned.\\n\\n    Returns\\n    -------\\n    imputed : {ndarray, DataFrame}\\n        The final observations where the censored values have either been\\n        imputed through ROS or substituted as a fraction of the\\n        detection limit.\\n\\n    Notes\\n    -----\\n    This function requires pandas 0.14 or more recent.\\n    '\n    if df is None:\n        df = pd.DataFrame({'obs': observations, 'cen': censorship})\n        observations = 'obs'\n        censorship = 'cen'\n    N_observations = df.shape[0]\n    N_censored = df[censorship].astype(int).sum()\n    N_uncensored = N_observations - N_censored\n    fraction_censored = N_censored / N_observations\n    if N_censored == 0:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n    elif N_uncensored < min_uncensored or fraction_censored > max_fraction_censored:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n        output.loc[df[censorship], 'final'] *= substitution_fraction\n    else:\n        output = _do_ros(df, observations, censorship, transform_in, transform_out)\n    if as_array:\n        output = output['final'].values\n    return output",
            "def impute_ros(observations, censorship, df=None, min_uncensored=2, max_fraction_censored=0.8, substitution_fraction=0.5, transform_in=np.log, transform_out=np.exp, as_array=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Impute censored dataset using Regression on Order Statistics (ROS).\\n\\n    Method described in *Nondetects and Data Analysis* by Dennis R.\\n    Helsel (John Wiley, 2005) to estimate the left-censored (non-detect)\\n    values of a dataset. When there is insufficient non-censorded data,\\n    simple substitution is used.\\n\\n    Parameters\\n    ----------\\n    observations : str or array-like\\n        Label of the column or the float array of censored observations\\n\\n    censorship : str\\n        Label of the column or the bool array of the censorship\\n        status of the observations.\\n\\n          * True if censored,\\n          * False if uncensored\\n\\n    df : DataFrame, optional\\n        If `observations` and `censorship` are labels, this is the\\n        DataFrame that contains those columns.\\n\\n    min_uncensored : int (default is 2)\\n        The minimum number of uncensored values required before ROS\\n        can be used to impute the censored observations. When this\\n        criterion is not met, simple substituion is used instead.\\n\\n    max_fraction_censored : float (default is 0.8)\\n        The maximum fraction of censored data below which ROS can be\\n        used to impute the censored observations. When this fraction is\\n        exceeded, simple substituion is used instead.\\n\\n    substitution_fraction : float (default is 0.5)\\n        The fraction of the detection limit to be used during simple\\n        substitution of the censored values.\\n\\n    transform_in : callable (default is np.log)\\n        Transformation to be applied to the values prior to fitting a\\n        line to the plotting positions vs. uncensored values.\\n\\n    transform_out : callable (default is np.exp)\\n        Transformation to be applied to the imputed censored values\\n        estimated from the previously computed best-fit line.\\n\\n    as_array : bool (default is True)\\n        When True, a numpy array of the imputed observations is\\n        returned. Otherwise, a modified copy of the original dataframe\\n        with all of the intermediate calculations is returned.\\n\\n    Returns\\n    -------\\n    imputed : {ndarray, DataFrame}\\n        The final observations where the censored values have either been\\n        imputed through ROS or substituted as a fraction of the\\n        detection limit.\\n\\n    Notes\\n    -----\\n    This function requires pandas 0.14 or more recent.\\n    '\n    if df is None:\n        df = pd.DataFrame({'obs': observations, 'cen': censorship})\n        observations = 'obs'\n        censorship = 'cen'\n    N_observations = df.shape[0]\n    N_censored = df[censorship].astype(int).sum()\n    N_uncensored = N_observations - N_censored\n    fraction_censored = N_censored / N_observations\n    if N_censored == 0:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n    elif N_uncensored < min_uncensored or fraction_censored > max_fraction_censored:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n        output.loc[df[censorship], 'final'] *= substitution_fraction\n    else:\n        output = _do_ros(df, observations, censorship, transform_in, transform_out)\n    if as_array:\n        output = output['final'].values\n    return output",
            "def impute_ros(observations, censorship, df=None, min_uncensored=2, max_fraction_censored=0.8, substitution_fraction=0.5, transform_in=np.log, transform_out=np.exp, as_array=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Impute censored dataset using Regression on Order Statistics (ROS).\\n\\n    Method described in *Nondetects and Data Analysis* by Dennis R.\\n    Helsel (John Wiley, 2005) to estimate the left-censored (non-detect)\\n    values of a dataset. When there is insufficient non-censorded data,\\n    simple substitution is used.\\n\\n    Parameters\\n    ----------\\n    observations : str or array-like\\n        Label of the column or the float array of censored observations\\n\\n    censorship : str\\n        Label of the column or the bool array of the censorship\\n        status of the observations.\\n\\n          * True if censored,\\n          * False if uncensored\\n\\n    df : DataFrame, optional\\n        If `observations` and `censorship` are labels, this is the\\n        DataFrame that contains those columns.\\n\\n    min_uncensored : int (default is 2)\\n        The minimum number of uncensored values required before ROS\\n        can be used to impute the censored observations. When this\\n        criterion is not met, simple substituion is used instead.\\n\\n    max_fraction_censored : float (default is 0.8)\\n        The maximum fraction of censored data below which ROS can be\\n        used to impute the censored observations. When this fraction is\\n        exceeded, simple substituion is used instead.\\n\\n    substitution_fraction : float (default is 0.5)\\n        The fraction of the detection limit to be used during simple\\n        substitution of the censored values.\\n\\n    transform_in : callable (default is np.log)\\n        Transformation to be applied to the values prior to fitting a\\n        line to the plotting positions vs. uncensored values.\\n\\n    transform_out : callable (default is np.exp)\\n        Transformation to be applied to the imputed censored values\\n        estimated from the previously computed best-fit line.\\n\\n    as_array : bool (default is True)\\n        When True, a numpy array of the imputed observations is\\n        returned. Otherwise, a modified copy of the original dataframe\\n        with all of the intermediate calculations is returned.\\n\\n    Returns\\n    -------\\n    imputed : {ndarray, DataFrame}\\n        The final observations where the censored values have either been\\n        imputed through ROS or substituted as a fraction of the\\n        detection limit.\\n\\n    Notes\\n    -----\\n    This function requires pandas 0.14 or more recent.\\n    '\n    if df is None:\n        df = pd.DataFrame({'obs': observations, 'cen': censorship})\n        observations = 'obs'\n        censorship = 'cen'\n    N_observations = df.shape[0]\n    N_censored = df[censorship].astype(int).sum()\n    N_uncensored = N_observations - N_censored\n    fraction_censored = N_censored / N_observations\n    if N_censored == 0:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n    elif N_uncensored < min_uncensored or fraction_censored > max_fraction_censored:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n        output.loc[df[censorship], 'final'] *= substitution_fraction\n    else:\n        output = _do_ros(df, observations, censorship, transform_in, transform_out)\n    if as_array:\n        output = output['final'].values\n    return output",
            "def impute_ros(observations, censorship, df=None, min_uncensored=2, max_fraction_censored=0.8, substitution_fraction=0.5, transform_in=np.log, transform_out=np.exp, as_array=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Impute censored dataset using Regression on Order Statistics (ROS).\\n\\n    Method described in *Nondetects and Data Analysis* by Dennis R.\\n    Helsel (John Wiley, 2005) to estimate the left-censored (non-detect)\\n    values of a dataset. When there is insufficient non-censorded data,\\n    simple substitution is used.\\n\\n    Parameters\\n    ----------\\n    observations : str or array-like\\n        Label of the column or the float array of censored observations\\n\\n    censorship : str\\n        Label of the column or the bool array of the censorship\\n        status of the observations.\\n\\n          * True if censored,\\n          * False if uncensored\\n\\n    df : DataFrame, optional\\n        If `observations` and `censorship` are labels, this is the\\n        DataFrame that contains those columns.\\n\\n    min_uncensored : int (default is 2)\\n        The minimum number of uncensored values required before ROS\\n        can be used to impute the censored observations. When this\\n        criterion is not met, simple substituion is used instead.\\n\\n    max_fraction_censored : float (default is 0.8)\\n        The maximum fraction of censored data below which ROS can be\\n        used to impute the censored observations. When this fraction is\\n        exceeded, simple substituion is used instead.\\n\\n    substitution_fraction : float (default is 0.5)\\n        The fraction of the detection limit to be used during simple\\n        substitution of the censored values.\\n\\n    transform_in : callable (default is np.log)\\n        Transformation to be applied to the values prior to fitting a\\n        line to the plotting positions vs. uncensored values.\\n\\n    transform_out : callable (default is np.exp)\\n        Transformation to be applied to the imputed censored values\\n        estimated from the previously computed best-fit line.\\n\\n    as_array : bool (default is True)\\n        When True, a numpy array of the imputed observations is\\n        returned. Otherwise, a modified copy of the original dataframe\\n        with all of the intermediate calculations is returned.\\n\\n    Returns\\n    -------\\n    imputed : {ndarray, DataFrame}\\n        The final observations where the censored values have either been\\n        imputed through ROS or substituted as a fraction of the\\n        detection limit.\\n\\n    Notes\\n    -----\\n    This function requires pandas 0.14 or more recent.\\n    '\n    if df is None:\n        df = pd.DataFrame({'obs': observations, 'cen': censorship})\n        observations = 'obs'\n        censorship = 'cen'\n    N_observations = df.shape[0]\n    N_censored = df[censorship].astype(int).sum()\n    N_uncensored = N_observations - N_censored\n    fraction_censored = N_censored / N_observations\n    if N_censored == 0:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n    elif N_uncensored < min_uncensored or fraction_censored > max_fraction_censored:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n        output.loc[df[censorship], 'final'] *= substitution_fraction\n    else:\n        output = _do_ros(df, observations, censorship, transform_in, transform_out)\n    if as_array:\n        output = output['final'].values\n    return output",
            "def impute_ros(observations, censorship, df=None, min_uncensored=2, max_fraction_censored=0.8, substitution_fraction=0.5, transform_in=np.log, transform_out=np.exp, as_array=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Impute censored dataset using Regression on Order Statistics (ROS).\\n\\n    Method described in *Nondetects and Data Analysis* by Dennis R.\\n    Helsel (John Wiley, 2005) to estimate the left-censored (non-detect)\\n    values of a dataset. When there is insufficient non-censorded data,\\n    simple substitution is used.\\n\\n    Parameters\\n    ----------\\n    observations : str or array-like\\n        Label of the column or the float array of censored observations\\n\\n    censorship : str\\n        Label of the column or the bool array of the censorship\\n        status of the observations.\\n\\n          * True if censored,\\n          * False if uncensored\\n\\n    df : DataFrame, optional\\n        If `observations` and `censorship` are labels, this is the\\n        DataFrame that contains those columns.\\n\\n    min_uncensored : int (default is 2)\\n        The minimum number of uncensored values required before ROS\\n        can be used to impute the censored observations. When this\\n        criterion is not met, simple substituion is used instead.\\n\\n    max_fraction_censored : float (default is 0.8)\\n        The maximum fraction of censored data below which ROS can be\\n        used to impute the censored observations. When this fraction is\\n        exceeded, simple substituion is used instead.\\n\\n    substitution_fraction : float (default is 0.5)\\n        The fraction of the detection limit to be used during simple\\n        substitution of the censored values.\\n\\n    transform_in : callable (default is np.log)\\n        Transformation to be applied to the values prior to fitting a\\n        line to the plotting positions vs. uncensored values.\\n\\n    transform_out : callable (default is np.exp)\\n        Transformation to be applied to the imputed censored values\\n        estimated from the previously computed best-fit line.\\n\\n    as_array : bool (default is True)\\n        When True, a numpy array of the imputed observations is\\n        returned. Otherwise, a modified copy of the original dataframe\\n        with all of the intermediate calculations is returned.\\n\\n    Returns\\n    -------\\n    imputed : {ndarray, DataFrame}\\n        The final observations where the censored values have either been\\n        imputed through ROS or substituted as a fraction of the\\n        detection limit.\\n\\n    Notes\\n    -----\\n    This function requires pandas 0.14 or more recent.\\n    '\n    if df is None:\n        df = pd.DataFrame({'obs': observations, 'cen': censorship})\n        observations = 'obs'\n        censorship = 'cen'\n    N_observations = df.shape[0]\n    N_censored = df[censorship].astype(int).sum()\n    N_uncensored = N_observations - N_censored\n    fraction_censored = N_censored / N_observations\n    if N_censored == 0:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n    elif N_uncensored < min_uncensored or fraction_censored > max_fraction_censored:\n        output = df[[observations, censorship]].copy()\n        output.loc[:, 'final'] = df[observations]\n        output.loc[df[censorship], 'final'] *= substitution_fraction\n    else:\n        output = _do_ros(df, observations, censorship, transform_in, transform_out)\n    if as_array:\n        output = output['final'].values\n    return output"
        ]
    }
]