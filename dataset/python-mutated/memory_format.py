import torch

def convert_conv2d_weight_memory_format(module, memory_format):
    if False:
        return 10
    'Convert ``memory_format`` of ``nn.Conv2d.weight`` to ``memory_format``.\n\n    The conversion recursively applies to nested ``nn.Module``, including ``module``.\n    Note that it only changes the memory_format, but not the semantics of each dimensions.\n    This function is used to facilitate the computation to adopt NHWC kernels, which\n    provides considerable speed up for fp16 data on CUDA devices with compute capability >= 7.0\n\n    .. note::\n        Calling ``model.to(memory_format=torch.channels_last)`` is more aggressive\n        than the utility function ``convert_conv2d_weight_memory_format``. Any\n        layer with 4d weight will be affected by ``model.to``, which does not\n        necessarily benefit from conversion to specified ``memory_format``.\n        One place we are confident in is that NHWC(channels_last) conversion for\n        convolution in cuDNN, As it is beneficial to run convolution in NHWC,\n        even in cases where we have to apply permutation to input tensors.\n\n        Hence our strategy here is to convert only the weight of convolution to\n        channels_last. This ensures that;\n        1. Fast convolution kernels will be used, the benefit of which could\n        outweigh overhead of permutation (if input is not in the same format)\n        2. No unnecessary permutations are applied on layers that do not benefit\n        from memory_format conversion.\n\n        The optimal case is that, layers between convolution layers are channels\n        last compatible. Input tensor would be permuted to channels last when it\n        encounters the first convolution layer and stay in that memory format.\n        Hence following convolutions will not need to permute its input tensor.\n\n        In case where a channels last incompatible layer is between convolution\n        layers, we need to permute the input tensor back to contiguous format\n        for that layer. The input tensor will go through the remaining layers in\n        contiguous format and be permuted to channels last when it encounters\n        another convolution layer. There\'s no point in propagating that\n        permutation to an earlier layer, as most layers are quite agnostic to\n        ``memory_format``.\n\n        This claim might change when PyTorch supports fusion of permutation, as\n        there might have been a better spot to fuse the permutation other than\n        immediately before a convolution.\n\n    Args:\n        module (nn.Module): ``nn.Conv2d`` & ``nn.ConvTranspose2d`` or container\n                            ``nn.Module``\n        memory_format: user specified ``memory_format``,\n            e.g. ``torch.channels_last`` or ``torch.contiguous_format``\n\n    Returns:\n        The original module with updated ``nn.Conv2d``\n\n    Example:\n        >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)\n        >>> # xdoctest: +REQUIRES(env:CUBLAS_WORKSPACE_CONFIG)\n        >>> input = torch.randint(1, 10, (2, 8, 4, 4), dtype=torch.float16, device="cuda")\n        >>> model = nn.Sequential(\n        >>>     nn.Conv2d(8, 4, 3)).cuda().half()\n        >>> # This is identical to:\n        >>> # nn.utils.convert_conv2d_weight_memory_format(model, torch.channels_last)\n        >>> model = nn.utils.convert_conv2d_weight_memory_format(model, torch.channels_last)\n        >>> out = model(input)\n    '
    if isinstance(module, (torch.nn.Conv2d, torch.nn.ConvTranspose2d)):
        weight_data = module.weight.detach().clone().contiguous(memory_format=memory_format)
        module.weight.data = weight_data.resize_(weight_data.size(), memory_format=memory_format)
    for child in module.children():
        convert_conv2d_weight_memory_format(child, memory_format)
    return module