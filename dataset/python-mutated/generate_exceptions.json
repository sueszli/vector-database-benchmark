[
    {
        "func_name": "_get_error_name",
        "original": "def _get_error_name(sqlstatename, msgtype, sqlstate):\n    if sqlstate in _namemap:\n        return _namemap[sqlstate]\n    parts = string.capwords(sqlstatename.replace('_', ' ')).split(' ')\n    if parts[-1] in {'Exception', 'Failure'}:\n        parts[-1] = 'Error'\n    if parts[-1] != 'Error' and msgtype != 'W':\n        parts.append('Error')\n    for (i, part) in enumerate(parts):\n        if part == 'Fdw':\n            parts[i] = 'FDW'\n        elif part == 'Io':\n            parts[i] = 'IO'\n        elif part == 'Plpgsql':\n            parts[i] = 'PLPGSQL'\n        elif part == 'Sql':\n            parts[i] = 'SQL'\n    errname = ''.join(parts)\n    if hasattr(builtins, errname):\n        errname = 'Postgres' + errname\n    return errname",
        "mutated": [
            "def _get_error_name(sqlstatename, msgtype, sqlstate):\n    if False:\n        i = 10\n    if sqlstate in _namemap:\n        return _namemap[sqlstate]\n    parts = string.capwords(sqlstatename.replace('_', ' ')).split(' ')\n    if parts[-1] in {'Exception', 'Failure'}:\n        parts[-1] = 'Error'\n    if parts[-1] != 'Error' and msgtype != 'W':\n        parts.append('Error')\n    for (i, part) in enumerate(parts):\n        if part == 'Fdw':\n            parts[i] = 'FDW'\n        elif part == 'Io':\n            parts[i] = 'IO'\n        elif part == 'Plpgsql':\n            parts[i] = 'PLPGSQL'\n        elif part == 'Sql':\n            parts[i] = 'SQL'\n    errname = ''.join(parts)\n    if hasattr(builtins, errname):\n        errname = 'Postgres' + errname\n    return errname",
            "def _get_error_name(sqlstatename, msgtype, sqlstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if sqlstate in _namemap:\n        return _namemap[sqlstate]\n    parts = string.capwords(sqlstatename.replace('_', ' ')).split(' ')\n    if parts[-1] in {'Exception', 'Failure'}:\n        parts[-1] = 'Error'\n    if parts[-1] != 'Error' and msgtype != 'W':\n        parts.append('Error')\n    for (i, part) in enumerate(parts):\n        if part == 'Fdw':\n            parts[i] = 'FDW'\n        elif part == 'Io':\n            parts[i] = 'IO'\n        elif part == 'Plpgsql':\n            parts[i] = 'PLPGSQL'\n        elif part == 'Sql':\n            parts[i] = 'SQL'\n    errname = ''.join(parts)\n    if hasattr(builtins, errname):\n        errname = 'Postgres' + errname\n    return errname",
            "def _get_error_name(sqlstatename, msgtype, sqlstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if sqlstate in _namemap:\n        return _namemap[sqlstate]\n    parts = string.capwords(sqlstatename.replace('_', ' ')).split(' ')\n    if parts[-1] in {'Exception', 'Failure'}:\n        parts[-1] = 'Error'\n    if parts[-1] != 'Error' and msgtype != 'W':\n        parts.append('Error')\n    for (i, part) in enumerate(parts):\n        if part == 'Fdw':\n            parts[i] = 'FDW'\n        elif part == 'Io':\n            parts[i] = 'IO'\n        elif part == 'Plpgsql':\n            parts[i] = 'PLPGSQL'\n        elif part == 'Sql':\n            parts[i] = 'SQL'\n    errname = ''.join(parts)\n    if hasattr(builtins, errname):\n        errname = 'Postgres' + errname\n    return errname",
            "def _get_error_name(sqlstatename, msgtype, sqlstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if sqlstate in _namemap:\n        return _namemap[sqlstate]\n    parts = string.capwords(sqlstatename.replace('_', ' ')).split(' ')\n    if parts[-1] in {'Exception', 'Failure'}:\n        parts[-1] = 'Error'\n    if parts[-1] != 'Error' and msgtype != 'W':\n        parts.append('Error')\n    for (i, part) in enumerate(parts):\n        if part == 'Fdw':\n            parts[i] = 'FDW'\n        elif part == 'Io':\n            parts[i] = 'IO'\n        elif part == 'Plpgsql':\n            parts[i] = 'PLPGSQL'\n        elif part == 'Sql':\n            parts[i] = 'SQL'\n    errname = ''.join(parts)\n    if hasattr(builtins, errname):\n        errname = 'Postgres' + errname\n    return errname",
            "def _get_error_name(sqlstatename, msgtype, sqlstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if sqlstate in _namemap:\n        return _namemap[sqlstate]\n    parts = string.capwords(sqlstatename.replace('_', ' ')).split(' ')\n    if parts[-1] in {'Exception', 'Failure'}:\n        parts[-1] = 'Error'\n    if parts[-1] != 'Error' and msgtype != 'W':\n        parts.append('Error')\n    for (i, part) in enumerate(parts):\n        if part == 'Fdw':\n            parts[i] = 'FDW'\n        elif part == 'Io':\n            parts[i] = 'IO'\n        elif part == 'Plpgsql':\n            parts[i] = 'PLPGSQL'\n        elif part == 'Sql':\n            parts[i] = 'SQL'\n    errname = ''.join(parts)\n    if hasattr(builtins, errname):\n        errname = 'Postgres' + errname\n    return errname"
        ]
    },
    {
        "func_name": "_add_class",
        "original": "def _add_class(clsname, base, sqlstate, docstring):\n    if sqlstate:\n        sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n    else:\n        sqlstate = ''\n    txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n    if not sqlstate and (not docstring):\n        txt += 'pass'\n    if len(txt.splitlines()[0]) > 79:\n        txt = txt.replace('(', '(\\n        ', 1)\n    classes.append(txt)\n    clsnames.add(clsname)",
        "mutated": [
            "def _add_class(clsname, base, sqlstate, docstring):\n    if False:\n        i = 10\n    if sqlstate:\n        sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n    else:\n        sqlstate = ''\n    txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n    if not sqlstate and (not docstring):\n        txt += 'pass'\n    if len(txt.splitlines()[0]) > 79:\n        txt = txt.replace('(', '(\\n        ', 1)\n    classes.append(txt)\n    clsnames.add(clsname)",
            "def _add_class(clsname, base, sqlstate, docstring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if sqlstate:\n        sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n    else:\n        sqlstate = ''\n    txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n    if not sqlstate and (not docstring):\n        txt += 'pass'\n    if len(txt.splitlines()[0]) > 79:\n        txt = txt.replace('(', '(\\n        ', 1)\n    classes.append(txt)\n    clsnames.add(clsname)",
            "def _add_class(clsname, base, sqlstate, docstring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if sqlstate:\n        sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n    else:\n        sqlstate = ''\n    txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n    if not sqlstate and (not docstring):\n        txt += 'pass'\n    if len(txt.splitlines()[0]) > 79:\n        txt = txt.replace('(', '(\\n        ', 1)\n    classes.append(txt)\n    clsnames.add(clsname)",
            "def _add_class(clsname, base, sqlstate, docstring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if sqlstate:\n        sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n    else:\n        sqlstate = ''\n    txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n    if not sqlstate and (not docstring):\n        txt += 'pass'\n    if len(txt.splitlines()[0]) > 79:\n        txt = txt.replace('(', '(\\n        ', 1)\n    classes.append(txt)\n    clsnames.add(clsname)",
            "def _add_class(clsname, base, sqlstate, docstring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if sqlstate:\n        sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n    else:\n        sqlstate = ''\n    txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n    if not sqlstate and (not docstring):\n        txt += 'pass'\n    if len(txt.splitlines()[0]) > 79:\n        txt = txt.replace('(', '(\\n        ', 1)\n    classes.append(txt)\n    clsnames.add(clsname)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    parser = argparse.ArgumentParser(description='generate _exceptions.py from postgres/errcodes.txt')\n    parser.add_argument('errcodesfile', type=str, help='path to errcodes.txt in PostgreSQL source')\n    args = parser.parse_args()\n    with open(args.errcodesfile, 'r') as errcodes_f:\n        errcodes = errcodes_f.read()\n    section_re = re.compile('^Section: .*')\n    tpl = 'class {clsname}({base}):\\n    {docstring}{sqlstate}'\n    new_section = True\n    section_class = None\n    buf = '# GENERATED FROM postgresql/src/backend/utils/errcodes.txt\\n' + '# DO NOT MODIFY, use tools/generate_exceptions.py to update\\n\\n' + 'from ._base import *  # NOQA\\nfrom . import _base\\n\\n\\n'\n    classes = []\n    clsnames = set()\n\n    def _add_class(clsname, base, sqlstate, docstring):\n        if sqlstate:\n            sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n        else:\n            sqlstate = ''\n        txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        if not sqlstate and (not docstring):\n            txt += 'pass'\n        if len(txt.splitlines()[0]) > 79:\n            txt = txt.replace('(', '(\\n        ', 1)\n        classes.append(txt)\n        clsnames.add(clsname)\n    for line in errcodes.splitlines():\n        if not line.strip() or line.startswith('#'):\n            continue\n        if section_re.match(line):\n            new_section = True\n            continue\n        parts = re.split('\\\\s+', line)\n        if len(parts) < 4:\n            continue\n        sqlstate = parts[0]\n        msgtype = parts[1]\n        name = parts[3]\n        clsname = _get_error_name(name, msgtype, sqlstate)\n        if clsname in {'SuccessfulCompletionError'}:\n            continue\n        if clsname in clsnames:\n            raise ValueError('duplicate exception class name: {}'.format(clsname))\n        if new_section:\n            section_class = clsname\n            if clsname == 'PostgresWarning':\n                base = '_base.PostgresLogMessage, Warning'\n            elif msgtype == 'W':\n                base = 'PostgresWarning'\n            else:\n                base = '_base.PostgresError'\n            new_section = False\n        else:\n            base = section_class\n        existing = apg_exc.PostgresMessageMeta.get_message_class_for_sqlstate(sqlstate)\n        if existing and existing is not apg_exc.UnknownPostgresError and existing.__doc__:\n            docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n        else:\n            docstring = ''\n        _add_class(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        subclasses = _subclassmap.get(sqlstate, [])\n        for subclass in subclasses:\n            existing = getattr(apg_exc, subclass, None)\n            if existing and existing.__doc__:\n                docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n            else:\n                docstring = ''\n            _add_class(clsname=subclass, base=clsname, sqlstate=None, docstring=docstring)\n    buf += '\\n\\n\\n'.join(classes)\n    _all = textwrap.wrap(', '.join(('{!r}'.format(c) for c in sorted(clsnames))))\n    buf += '\\n\\n\\n__all__ = (\\n    {}\\n)'.format('\\n    '.join(_all))\n    buf += '\\n\\n__all__ += _base.__all__'\n    print(buf)",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(description='generate _exceptions.py from postgres/errcodes.txt')\n    parser.add_argument('errcodesfile', type=str, help='path to errcodes.txt in PostgreSQL source')\n    args = parser.parse_args()\n    with open(args.errcodesfile, 'r') as errcodes_f:\n        errcodes = errcodes_f.read()\n    section_re = re.compile('^Section: .*')\n    tpl = 'class {clsname}({base}):\\n    {docstring}{sqlstate}'\n    new_section = True\n    section_class = None\n    buf = '# GENERATED FROM postgresql/src/backend/utils/errcodes.txt\\n' + '# DO NOT MODIFY, use tools/generate_exceptions.py to update\\n\\n' + 'from ._base import *  # NOQA\\nfrom . import _base\\n\\n\\n'\n    classes = []\n    clsnames = set()\n\n    def _add_class(clsname, base, sqlstate, docstring):\n        if sqlstate:\n            sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n        else:\n            sqlstate = ''\n        txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        if not sqlstate and (not docstring):\n            txt += 'pass'\n        if len(txt.splitlines()[0]) > 79:\n            txt = txt.replace('(', '(\\n        ', 1)\n        classes.append(txt)\n        clsnames.add(clsname)\n    for line in errcodes.splitlines():\n        if not line.strip() or line.startswith('#'):\n            continue\n        if section_re.match(line):\n            new_section = True\n            continue\n        parts = re.split('\\\\s+', line)\n        if len(parts) < 4:\n            continue\n        sqlstate = parts[0]\n        msgtype = parts[1]\n        name = parts[3]\n        clsname = _get_error_name(name, msgtype, sqlstate)\n        if clsname in {'SuccessfulCompletionError'}:\n            continue\n        if clsname in clsnames:\n            raise ValueError('duplicate exception class name: {}'.format(clsname))\n        if new_section:\n            section_class = clsname\n            if clsname == 'PostgresWarning':\n                base = '_base.PostgresLogMessage, Warning'\n            elif msgtype == 'W':\n                base = 'PostgresWarning'\n            else:\n                base = '_base.PostgresError'\n            new_section = False\n        else:\n            base = section_class\n        existing = apg_exc.PostgresMessageMeta.get_message_class_for_sqlstate(sqlstate)\n        if existing and existing is not apg_exc.UnknownPostgresError and existing.__doc__:\n            docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n        else:\n            docstring = ''\n        _add_class(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        subclasses = _subclassmap.get(sqlstate, [])\n        for subclass in subclasses:\n            existing = getattr(apg_exc, subclass, None)\n            if existing and existing.__doc__:\n                docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n            else:\n                docstring = ''\n            _add_class(clsname=subclass, base=clsname, sqlstate=None, docstring=docstring)\n    buf += '\\n\\n\\n'.join(classes)\n    _all = textwrap.wrap(', '.join(('{!r}'.format(c) for c in sorted(clsnames))))\n    buf += '\\n\\n\\n__all__ = (\\n    {}\\n)'.format('\\n    '.join(_all))\n    buf += '\\n\\n__all__ += _base.__all__'\n    print(buf)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(description='generate _exceptions.py from postgres/errcodes.txt')\n    parser.add_argument('errcodesfile', type=str, help='path to errcodes.txt in PostgreSQL source')\n    args = parser.parse_args()\n    with open(args.errcodesfile, 'r') as errcodes_f:\n        errcodes = errcodes_f.read()\n    section_re = re.compile('^Section: .*')\n    tpl = 'class {clsname}({base}):\\n    {docstring}{sqlstate}'\n    new_section = True\n    section_class = None\n    buf = '# GENERATED FROM postgresql/src/backend/utils/errcodes.txt\\n' + '# DO NOT MODIFY, use tools/generate_exceptions.py to update\\n\\n' + 'from ._base import *  # NOQA\\nfrom . import _base\\n\\n\\n'\n    classes = []\n    clsnames = set()\n\n    def _add_class(clsname, base, sqlstate, docstring):\n        if sqlstate:\n            sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n        else:\n            sqlstate = ''\n        txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        if not sqlstate and (not docstring):\n            txt += 'pass'\n        if len(txt.splitlines()[0]) > 79:\n            txt = txt.replace('(', '(\\n        ', 1)\n        classes.append(txt)\n        clsnames.add(clsname)\n    for line in errcodes.splitlines():\n        if not line.strip() or line.startswith('#'):\n            continue\n        if section_re.match(line):\n            new_section = True\n            continue\n        parts = re.split('\\\\s+', line)\n        if len(parts) < 4:\n            continue\n        sqlstate = parts[0]\n        msgtype = parts[1]\n        name = parts[3]\n        clsname = _get_error_name(name, msgtype, sqlstate)\n        if clsname in {'SuccessfulCompletionError'}:\n            continue\n        if clsname in clsnames:\n            raise ValueError('duplicate exception class name: {}'.format(clsname))\n        if new_section:\n            section_class = clsname\n            if clsname == 'PostgresWarning':\n                base = '_base.PostgresLogMessage, Warning'\n            elif msgtype == 'W':\n                base = 'PostgresWarning'\n            else:\n                base = '_base.PostgresError'\n            new_section = False\n        else:\n            base = section_class\n        existing = apg_exc.PostgresMessageMeta.get_message_class_for_sqlstate(sqlstate)\n        if existing and existing is not apg_exc.UnknownPostgresError and existing.__doc__:\n            docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n        else:\n            docstring = ''\n        _add_class(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        subclasses = _subclassmap.get(sqlstate, [])\n        for subclass in subclasses:\n            existing = getattr(apg_exc, subclass, None)\n            if existing and existing.__doc__:\n                docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n            else:\n                docstring = ''\n            _add_class(clsname=subclass, base=clsname, sqlstate=None, docstring=docstring)\n    buf += '\\n\\n\\n'.join(classes)\n    _all = textwrap.wrap(', '.join(('{!r}'.format(c) for c in sorted(clsnames))))\n    buf += '\\n\\n\\n__all__ = (\\n    {}\\n)'.format('\\n    '.join(_all))\n    buf += '\\n\\n__all__ += _base.__all__'\n    print(buf)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(description='generate _exceptions.py from postgres/errcodes.txt')\n    parser.add_argument('errcodesfile', type=str, help='path to errcodes.txt in PostgreSQL source')\n    args = parser.parse_args()\n    with open(args.errcodesfile, 'r') as errcodes_f:\n        errcodes = errcodes_f.read()\n    section_re = re.compile('^Section: .*')\n    tpl = 'class {clsname}({base}):\\n    {docstring}{sqlstate}'\n    new_section = True\n    section_class = None\n    buf = '# GENERATED FROM postgresql/src/backend/utils/errcodes.txt\\n' + '# DO NOT MODIFY, use tools/generate_exceptions.py to update\\n\\n' + 'from ._base import *  # NOQA\\nfrom . import _base\\n\\n\\n'\n    classes = []\n    clsnames = set()\n\n    def _add_class(clsname, base, sqlstate, docstring):\n        if sqlstate:\n            sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n        else:\n            sqlstate = ''\n        txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        if not sqlstate and (not docstring):\n            txt += 'pass'\n        if len(txt.splitlines()[0]) > 79:\n            txt = txt.replace('(', '(\\n        ', 1)\n        classes.append(txt)\n        clsnames.add(clsname)\n    for line in errcodes.splitlines():\n        if not line.strip() or line.startswith('#'):\n            continue\n        if section_re.match(line):\n            new_section = True\n            continue\n        parts = re.split('\\\\s+', line)\n        if len(parts) < 4:\n            continue\n        sqlstate = parts[0]\n        msgtype = parts[1]\n        name = parts[3]\n        clsname = _get_error_name(name, msgtype, sqlstate)\n        if clsname in {'SuccessfulCompletionError'}:\n            continue\n        if clsname in clsnames:\n            raise ValueError('duplicate exception class name: {}'.format(clsname))\n        if new_section:\n            section_class = clsname\n            if clsname == 'PostgresWarning':\n                base = '_base.PostgresLogMessage, Warning'\n            elif msgtype == 'W':\n                base = 'PostgresWarning'\n            else:\n                base = '_base.PostgresError'\n            new_section = False\n        else:\n            base = section_class\n        existing = apg_exc.PostgresMessageMeta.get_message_class_for_sqlstate(sqlstate)\n        if existing and existing is not apg_exc.UnknownPostgresError and existing.__doc__:\n            docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n        else:\n            docstring = ''\n        _add_class(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        subclasses = _subclassmap.get(sqlstate, [])\n        for subclass in subclasses:\n            existing = getattr(apg_exc, subclass, None)\n            if existing and existing.__doc__:\n                docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n            else:\n                docstring = ''\n            _add_class(clsname=subclass, base=clsname, sqlstate=None, docstring=docstring)\n    buf += '\\n\\n\\n'.join(classes)\n    _all = textwrap.wrap(', '.join(('{!r}'.format(c) for c in sorted(clsnames))))\n    buf += '\\n\\n\\n__all__ = (\\n    {}\\n)'.format('\\n    '.join(_all))\n    buf += '\\n\\n__all__ += _base.__all__'\n    print(buf)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(description='generate _exceptions.py from postgres/errcodes.txt')\n    parser.add_argument('errcodesfile', type=str, help='path to errcodes.txt in PostgreSQL source')\n    args = parser.parse_args()\n    with open(args.errcodesfile, 'r') as errcodes_f:\n        errcodes = errcodes_f.read()\n    section_re = re.compile('^Section: .*')\n    tpl = 'class {clsname}({base}):\\n    {docstring}{sqlstate}'\n    new_section = True\n    section_class = None\n    buf = '# GENERATED FROM postgresql/src/backend/utils/errcodes.txt\\n' + '# DO NOT MODIFY, use tools/generate_exceptions.py to update\\n\\n' + 'from ._base import *  # NOQA\\nfrom . import _base\\n\\n\\n'\n    classes = []\n    clsnames = set()\n\n    def _add_class(clsname, base, sqlstate, docstring):\n        if sqlstate:\n            sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n        else:\n            sqlstate = ''\n        txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        if not sqlstate and (not docstring):\n            txt += 'pass'\n        if len(txt.splitlines()[0]) > 79:\n            txt = txt.replace('(', '(\\n        ', 1)\n        classes.append(txt)\n        clsnames.add(clsname)\n    for line in errcodes.splitlines():\n        if not line.strip() or line.startswith('#'):\n            continue\n        if section_re.match(line):\n            new_section = True\n            continue\n        parts = re.split('\\\\s+', line)\n        if len(parts) < 4:\n            continue\n        sqlstate = parts[0]\n        msgtype = parts[1]\n        name = parts[3]\n        clsname = _get_error_name(name, msgtype, sqlstate)\n        if clsname in {'SuccessfulCompletionError'}:\n            continue\n        if clsname in clsnames:\n            raise ValueError('duplicate exception class name: {}'.format(clsname))\n        if new_section:\n            section_class = clsname\n            if clsname == 'PostgresWarning':\n                base = '_base.PostgresLogMessage, Warning'\n            elif msgtype == 'W':\n                base = 'PostgresWarning'\n            else:\n                base = '_base.PostgresError'\n            new_section = False\n        else:\n            base = section_class\n        existing = apg_exc.PostgresMessageMeta.get_message_class_for_sqlstate(sqlstate)\n        if existing and existing is not apg_exc.UnknownPostgresError and existing.__doc__:\n            docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n        else:\n            docstring = ''\n        _add_class(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        subclasses = _subclassmap.get(sqlstate, [])\n        for subclass in subclasses:\n            existing = getattr(apg_exc, subclass, None)\n            if existing and existing.__doc__:\n                docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n            else:\n                docstring = ''\n            _add_class(clsname=subclass, base=clsname, sqlstate=None, docstring=docstring)\n    buf += '\\n\\n\\n'.join(classes)\n    _all = textwrap.wrap(', '.join(('{!r}'.format(c) for c in sorted(clsnames))))\n    buf += '\\n\\n\\n__all__ = (\\n    {}\\n)'.format('\\n    '.join(_all))\n    buf += '\\n\\n__all__ += _base.__all__'\n    print(buf)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(description='generate _exceptions.py from postgres/errcodes.txt')\n    parser.add_argument('errcodesfile', type=str, help='path to errcodes.txt in PostgreSQL source')\n    args = parser.parse_args()\n    with open(args.errcodesfile, 'r') as errcodes_f:\n        errcodes = errcodes_f.read()\n    section_re = re.compile('^Section: .*')\n    tpl = 'class {clsname}({base}):\\n    {docstring}{sqlstate}'\n    new_section = True\n    section_class = None\n    buf = '# GENERATED FROM postgresql/src/backend/utils/errcodes.txt\\n' + '# DO NOT MODIFY, use tools/generate_exceptions.py to update\\n\\n' + 'from ._base import *  # NOQA\\nfrom . import _base\\n\\n\\n'\n    classes = []\n    clsnames = set()\n\n    def _add_class(clsname, base, sqlstate, docstring):\n        if sqlstate:\n            sqlstate = \"sqlstate = '{}'\".format(sqlstate)\n        else:\n            sqlstate = ''\n        txt = tpl.format(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        if not sqlstate and (not docstring):\n            txt += 'pass'\n        if len(txt.splitlines()[0]) > 79:\n            txt = txt.replace('(', '(\\n        ', 1)\n        classes.append(txt)\n        clsnames.add(clsname)\n    for line in errcodes.splitlines():\n        if not line.strip() or line.startswith('#'):\n            continue\n        if section_re.match(line):\n            new_section = True\n            continue\n        parts = re.split('\\\\s+', line)\n        if len(parts) < 4:\n            continue\n        sqlstate = parts[0]\n        msgtype = parts[1]\n        name = parts[3]\n        clsname = _get_error_name(name, msgtype, sqlstate)\n        if clsname in {'SuccessfulCompletionError'}:\n            continue\n        if clsname in clsnames:\n            raise ValueError('duplicate exception class name: {}'.format(clsname))\n        if new_section:\n            section_class = clsname\n            if clsname == 'PostgresWarning':\n                base = '_base.PostgresLogMessage, Warning'\n            elif msgtype == 'W':\n                base = 'PostgresWarning'\n            else:\n                base = '_base.PostgresError'\n            new_section = False\n        else:\n            base = section_class\n        existing = apg_exc.PostgresMessageMeta.get_message_class_for_sqlstate(sqlstate)\n        if existing and existing is not apg_exc.UnknownPostgresError and existing.__doc__:\n            docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n        else:\n            docstring = ''\n        _add_class(clsname=clsname, base=base, sqlstate=sqlstate, docstring=docstring)\n        subclasses = _subclassmap.get(sqlstate, [])\n        for subclass in subclasses:\n            existing = getattr(apg_exc, subclass, None)\n            if existing and existing.__doc__:\n                docstring = '\"\"\"{}\"\"\"\\n\\n    '.format(existing.__doc__)\n            else:\n                docstring = ''\n            _add_class(clsname=subclass, base=clsname, sqlstate=None, docstring=docstring)\n    buf += '\\n\\n\\n'.join(classes)\n    _all = textwrap.wrap(', '.join(('{!r}'.format(c) for c in sorted(clsnames))))\n    buf += '\\n\\n\\n__all__ = (\\n    {}\\n)'.format('\\n    '.join(_all))\n    buf += '\\n\\n__all__ += _base.__all__'\n    print(buf)"
        ]
    }
]