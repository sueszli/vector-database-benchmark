[
    {
        "func_name": "_update_upstream_block_uuids",
        "original": "def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n    uuid = controller_child.get('uuid')\n    metrics = controller_child.get('metrics') or {}\n    upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n    for up_block_uuid in upstream_block_uuids:\n        arr = children_inner.get(up_block_uuid) or []\n        block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n        blocks_to_not_override[uuid] = True\n        for d_child in arr:\n            child_uuid = d_child['uuid']\n            block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n            block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n            blocks_to_not_override[child_uuid] = True\n        up_controller = controllers_inner.get(up_block_uuid)\n        if up_controller:\n            _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)",
        "mutated": [
            "def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n    if False:\n        i = 10\n    uuid = controller_child.get('uuid')\n    metrics = controller_child.get('metrics') or {}\n    upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n    for up_block_uuid in upstream_block_uuids:\n        arr = children_inner.get(up_block_uuid) or []\n        block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n        blocks_to_not_override[uuid] = True\n        for d_child in arr:\n            child_uuid = d_child['uuid']\n            block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n            block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n            blocks_to_not_override[child_uuid] = True\n        up_controller = controllers_inner.get(up_block_uuid)\n        if up_controller:\n            _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)",
            "def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    uuid = controller_child.get('uuid')\n    metrics = controller_child.get('metrics') or {}\n    upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n    for up_block_uuid in upstream_block_uuids:\n        arr = children_inner.get(up_block_uuid) or []\n        block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n        blocks_to_not_override[uuid] = True\n        for d_child in arr:\n            child_uuid = d_child['uuid']\n            block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n            block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n            blocks_to_not_override[child_uuid] = True\n        up_controller = controllers_inner.get(up_block_uuid)\n        if up_controller:\n            _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)",
            "def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    uuid = controller_child.get('uuid')\n    metrics = controller_child.get('metrics') or {}\n    upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n    for up_block_uuid in upstream_block_uuids:\n        arr = children_inner.get(up_block_uuid) or []\n        block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n        blocks_to_not_override[uuid] = True\n        for d_child in arr:\n            child_uuid = d_child['uuid']\n            block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n            block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n            blocks_to_not_override[child_uuid] = True\n        up_controller = controllers_inner.get(up_block_uuid)\n        if up_controller:\n            _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)",
            "def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    uuid = controller_child.get('uuid')\n    metrics = controller_child.get('metrics') or {}\n    upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n    for up_block_uuid in upstream_block_uuids:\n        arr = children_inner.get(up_block_uuid) or []\n        block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n        blocks_to_not_override[uuid] = True\n        for d_child in arr:\n            child_uuid = d_child['uuid']\n            block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n            block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n            blocks_to_not_override[child_uuid] = True\n        up_controller = controllers_inner.get(up_block_uuid)\n        if up_controller:\n            _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)",
            "def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    uuid = controller_child.get('uuid')\n    metrics = controller_child.get('metrics') or {}\n    upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n    for up_block_uuid in upstream_block_uuids:\n        arr = children_inner.get(up_block_uuid) or []\n        block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n        blocks_to_not_override[uuid] = True\n        for d_child in arr:\n            child_uuid = d_child['uuid']\n            block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n            block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n            blocks_to_not_override[child_uuid] = True\n        up_controller = controllers_inner.get(up_block_uuid)\n        if up_controller:\n            _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)"
        ]
    },
    {
        "func_name": "collection",
        "original": "@classmethod\n@safe_db_query\ndef collection(self, query_arg, meta, user, **kwargs):\n    parent_model = kwargs.get('parent_model')\n    block_count_by_base_uuid = {}\n    block_dicts_by_uuid = {}\n    data_integration_sets_by_uuid = {}\n    dynamic_block_count_by_base_uuid = {}\n    dynamic_block_uuids_by_base_uuid = {}\n    sources_destinations_by_block_uuid = {}\n    if isinstance(parent_model, Pipeline):\n        for (block_uuid, block) in parent_model.blocks_by_uuid.items():\n            block_dicts_by_uuid[block_uuid] = block.to_dict()\n    if isinstance(parent_model, PipelineRun):\n        block_mapping = {}\n        pipeline = parent_model.pipeline\n        is_data_integration_pipeline = pipeline and PipelineType.INTEGRATION == pipeline.type\n        if is_data_integration_pipeline:\n            original_blocks_mapping = {}\n            for block_run in parent_model.block_runs:\n                block_run_block_uuid = block_run.block_uuid\n                block = pipeline.get_block(block_run_block_uuid)\n                if not block:\n                    continue\n                if block.uuid not in original_blocks_mapping:\n                    original_blocks_mapping[block.uuid] = {}\n                block_dict = block.to_dict()\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n                original_blocks_mapping[block.uuid][block_run_block_uuid] = block_dict\n            for (block_run_block_uuid, block_dict) in block_dicts_by_uuid.items():\n                block_uuid = block_dict.get('uuid')\n                block_uuid_parts = block_run_block_uuid.split(':')\n                group_parts = [part for part in block_uuid_parts if part != block_uuid]\n                group_uuid = ':'.join(group_parts)\n                for key in ['downstream_blocks', 'upstream_blocks']:\n                    uuids = []\n                    for block_uuid2 in block_dict.get(key):\n                        mapping = original_blocks_mapping.get(block_uuid2)\n                        if mapping:\n                            for uuid2 in list(mapping.keys()):\n                                if uuid2 == ':'.join([block_uuid2, group_uuid]):\n                                    uuids.append(uuid2)\n                        else:\n                            uuids.append(block_uuid2)\n                    block_dict[key] = uuids\n                if len(group_parts) >= 1:\n                    block_dict['tags'] = [group_parts[0]]\n                if len(group_parts) >= 2:\n                    block_dict['description'] = group_parts[1]\n                block_dict['name'] = block_uuid\n                block_dict['uuid'] = block_run_block_uuid\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n            return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)\n        for block_run in parent_model.block_runs:\n            block_run_block_uuid = block_run.block_uuid\n            if block_run_block_uuid not in block_mapping:\n                block_mapping[block_run_block_uuid] = dict(block_run=block_run, uuids=[])\n            block = pipeline.get_block(block_run_block_uuid)\n            if not block:\n                continue\n            if block.uuid not in block_count_by_base_uuid:\n                block_count_by_base_uuid[block.uuid] = 0\n            block_count_by_base_uuid[block.uuid] += 1\n            block_dict = block.to_dict()\n            if 'tags' not in block_dict:\n                block_dict['tags'] = []\n            block_dict['uuid'] = block_run_block_uuid\n            metrics = block_run.metrics\n            if metrics and block.is_data_integration():\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                controller_block_uuid = metrics.get('controller_block_uuid')\n                original = metrics.get('original')\n                original_block_uuid = metrics.get('original_block_uuid')\n                tags = []\n                if original:\n                    if BlockType.DATA_LOADER == block.type:\n                        block_dict['description'] = 'Source'\n                    elif BlockType.DATA_EXPORTER == block.type:\n                        block_dict['description'] = 'Destination'\n                elif controller and (not child):\n                    block_dict['description'] = 'Controller'\n                else:\n                    block_dict['name'] = original_block_uuid\n                if child:\n                    parts = block_run_block_uuid.split(':')\n                    source_destination = None\n                    stream = None\n                    index = None\n                    if len(parts) >= 2:\n                        source_destination = parts[1]\n                        for b_uuid in [controller_block_uuid, original_block_uuid]:\n                            if b_uuid not in sources_destinations_by_block_uuid:\n                                sources_destinations_by_block_uuid[b_uuid] = []\n                            if source_destination not in sources_destinations_by_block_uuid[b_uuid]:\n                                sources_destinations_by_block_uuid[b_uuid].append(source_destination)\n                    if len(parts) >= 3:\n                        stream = parts[2]\n                    block_mapping[block_run_block_uuid]['uuids'].append(controller_block_uuid)\n                    if controller:\n                        block_dict['description'] = 'Controller'\n                    else:\n                        if len(parts) >= 4:\n                            index = str(parts[3])\n                        block_dict['description'] = index\n                        if original_block_uuid not in block_mapping:\n                            block_mapping[original_block_uuid] = dict(uuids=[])\n                        block_mapping[original_block_uuid]['uuids'].append(block_run_block_uuid)\n                    tags.append(stream)\n                if tags:\n                    block_dict['tags'] = tags\n                if original_block_uuid:\n                    if original_block_uuid not in data_integration_sets_by_uuid:\n                        data_integration_sets_by_uuid[original_block_uuid] = dict(children={}, controller=None, controllers={}, original=None)\n                    data = merge_dict(block_dict, dict(metrics=metrics))\n                    if original:\n                        data_integration_sets_by_uuid[original_block_uuid]['original'] = data\n                    elif child:\n                        if controller:\n                            data_integration_sets_by_uuid[original_block_uuid]['controllers'][block_run_block_uuid] = data\n                        elif controller_block_uuid:\n                            if controller_block_uuid not in data_integration_sets_by_uuid[original_block_uuid]['children']:\n                                data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid] = []\n                            data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid].append(data)\n                    elif controller:\n                        data_integration_sets_by_uuid[original_block_uuid]['controller'] = data\n            if is_dynamic_block_child(block):\n                if block.uuid not in dynamic_block_count_by_base_uuid:\n                    dynamic_block_count_by_base_uuid[block.uuid] = 0\n                dynamic_block_count_by_base_uuid[block.uuid] += 1\n                if block.uuid not in dynamic_block_uuids_by_base_uuid:\n                    dynamic_block_uuids_by_base_uuid[block.uuid] = []\n                dynamic_block_uuids_by_base_uuid[block.uuid].append(block_run_block_uuid)\n                parts = block_run_block_uuid.split(':')\n                parts_length = len(parts)\n                if parts_length >= 2:\n                    block_dict['description'] = ':'.join(parts[1:])\n                    e_i = parts_length - 1\n                    parts_new = parts[1:e_i]\n                    for upstream_block in block.upstream_blocks:\n                        if is_dynamic_block_child(upstream_block):\n                            parts_new = [upstream_block.uuid] + parts_new\n                            block_mapping[block_run_block_uuid]['uuids'].append(':'.join(parts_new))\n                if should_reduce_output(block):\n                    for db in block.downstream_blocks:\n                        if db.uuid not in block_mapping:\n                            block_mapping[db.uuid] = dict(uuids=[])\n                        block_mapping[db.uuid]['uuids'].append(block_run_block_uuid)\n                else:\n                    for db in block.downstream_blocks:\n                        db_uuid = ':'.join([db.uuid] + parts[1:])\n                        if db_uuid not in block_mapping:\n                            block_mapping[db_uuid] = dict(uuids=[])\n                        block_mapping[db_uuid]['uuids'].append(block_run_block_uuid)\n            if block.replicated_block:\n                block_dict['name'] = block.uuid\n                block_dict['description'] = block.replicated_block\n            block_dict['tags'] += block.tags()\n            block_dicts_by_uuid[block_run_block_uuid] = block_dict\n        for (block_uuid, block_dict) in block_dicts_by_uuid.items():\n            for key in ['downstream_blocks', 'upstream_blocks']:\n                arr = block_dict.get(key) or []\n                for block_uuid_base in arr:\n                    block = pipeline.get_block(block_uuid_base)\n                    if block is None:\n                        continue\n                    if block.replicated_block and (not is_dynamic_block_child(block)):\n                        blocks_arr = block_dicts_by_uuid[block_uuid].get(key) or []\n                        block_dicts_by_uuid[block_uuid][key] = [uuid for uuid in blocks_arr if uuid != block_uuid_base]\n                        block_dicts_by_uuid[block_uuid][key].append(block.uuid_replicated)\n        blocks_to_not_override = {}\n        for (original_block_uuid, set_dict) in data_integration_sets_by_uuid.items():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            controllers_not_parallel = list(filter(lambda x: not (x.get('metrics') or {}).get('run_in_parallel'), controllers.values()))\n            controller_child_end = find(lambda x: not (x.get('metrics') or {}).get('downstream_block_uuids'), controllers_not_parallel)\n\n            def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n                uuid = controller_child.get('uuid')\n                metrics = controller_child.get('metrics') or {}\n                upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n                for up_block_uuid in upstream_block_uuids:\n                    arr = children_inner.get(up_block_uuid) or []\n                    block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n                    blocks_to_not_override[uuid] = True\n                    for d_child in arr:\n                        child_uuid = d_child['uuid']\n                        block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n                        block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n                        blocks_to_not_override[child_uuid] = True\n                    up_controller = controllers_inner.get(up_block_uuid)\n                    if up_controller:\n                        _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)\n            if controller_child_end:\n                _update_upstream_block_uuids(controller_child_end, controllers, children)\n                controller_child_end_uuid = controller_child_end.get('uuid')\n                children_end = children.get(controller_child_end_uuid) or []\n                block_dicts_by_uuid[original_block_uuid]['upstream_blocks'] = [d['uuid'] for d in children_end]\n                blocks_to_not_override[original_block_uuid] = True\n                downstream_blocks = block_dicts_by_uuid[original_block_uuid].get('downstream_blocks') or []\n                for down_uuid in downstream_blocks:\n                    blocks_to_not_override[down_uuid] = True\n                for up_uuid in block_dicts_by_uuid[original_block_uuid]['upstream_blocks']:\n                    block_dicts_by_uuid[up_uuid]['upstream_blocks'] = [controller_child_end_uuid]\n                    block_dicts_by_uuid[up_uuid]['downstream_blocks'] = [original_block_uuid]\n                    blocks_to_not_override[up_uuid] = True\n            controller_child_start = find(lambda x: not (x.get('metrics') or {}).get('upstream_block_uuids'), controllers_not_parallel)\n            if controller_child_start:\n                controller_child_start_uuid = controller_child_start['uuid']\n                block_dicts_by_uuid[controller_child_start_uuid]['upstream_blocks'] = [controller.get('uuid')]\n                blocks_to_not_override[controller_child_start_uuid] = True\n        for (block_uuid, mapping) in block_mapping.items():\n            block = pipeline.get_block(block_uuid)\n            if not block:\n                continue\n            if block_uuid not in block_dicts_by_uuid:\n                continue\n            block_run = mapping.get('block_run')\n            metrics = block_run.metrics if block_run else None\n            upstream_block_uuids = mapping['uuids']\n            child = False\n            controller = False\n            original = False\n            is_data_integration = block.is_data_integration()\n            if metrics and is_data_integration:\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                original = metrics.get('original')\n            if original or (controller and (not child)):\n                if block_uuid in sources_destinations_by_block_uuid:\n                    if 'tags' not in block_dicts_by_uuid[block_uuid]:\n                        block_dicts_by_uuid[block_uuid] = []\n                    block_dicts_by_uuid[block_uuid]['tags'].append(sources_destinations_by_block_uuid[block_uuid])\n            if block_uuid in blocks_to_not_override:\n                continue\n            if original:\n                block_dicts_by_uuid[block_uuid]['upstream_blocks'] = []\n            for ub_uuid in upstream_block_uuids:\n                if ub_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                    continue\n                if is_data_integration:\n                    if child:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [ub_uuid]\n                        continue\n                    elif original:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                else:\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                ub_block = pipeline.get_block(ub_uuid)\n                if ub_block and is_dynamic_block_child(ub_block) and (ub_block.uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']):\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks'] if uuid != ub_block.uuid]\n            for up_block_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                if up_block_uuid not in block_dicts_by_uuid:\n                    continue\n                if block_uuid not in block_dicts_by_uuid[up_block_uuid]:\n                    if block_uuid not in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        block_dicts_by_uuid[up_block_uuid]['downstream_blocks'].append(block_uuid)\n                up_block = pipeline.get_block(up_block_uuid)\n                if up_block and is_dynamic_block(up_block):\n                    for db_block_uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        db_block = pipeline.get_block(db_block_uuid)\n                        if db_block and is_dynamic_block_child(db_block):\n                            block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] if uuid != db_block.uuid]\n        for set_dict in data_integration_sets_by_uuid.values():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            original = set_dict.get('original') or {}\n            for controller_uuid in [controller.get('uuid')] + list(controllers.keys()):\n                if controller_uuid in block_dicts_by_uuid:\n                    block_run = block_mapping.get(controller_uuid, {}).get('block_run')\n                    if block_run and block_run.started_at:\n                        block_dict = block_dicts_by_uuid[controller_uuid]\n                        downstream_started_ats = []\n                        for db_uuid in block_dict.get('downstream_blocks') or []:\n                            db_block_run = block_mapping.get(db_uuid, {}).get('block_run')\n                            if db_block_run and db_block_run.started_at:\n                                downstream_started_ats.append(db_block_run.started_at)\n                        if downstream_started_ats:\n                            started_at_e = max(downstream_started_ats)\n                            block_dicts_by_uuid[controller_uuid]['runtime'] = started_at_e.timestamp() - block_run.started_at.timestamp()\n        dynamic_blocks_beyond_1 = {}\n        for (base_uuid, count) in dynamic_block_count_by_base_uuid.items():\n            if count >= 2:\n                dynamic_blocks_beyond_1[base_uuid] = count\n        total_blocks = sum(list(block_count_by_base_uuid.values()))\n        total_blocks_dynamic_beyond_1 = sum(list(dynamic_blocks_beyond_1.values()))\n        if total_blocks > MAX_BLOCKS_FOR_TREE:\n            remove_this_much = total_blocks - MAX_BLOCKS_FOR_TREE\n            if total_blocks_dynamic_beyond_1 > remove_this_much:\n                keep_this_much = total_blocks_dynamic_beyond_1 - remove_this_much\n                percent_to_keep = keep_this_much / total_blocks_dynamic_beyond_1\n                for (base_uuid, count) in dynamic_blocks_beyond_1.items():\n                    uuids = dynamic_block_uuids_by_base_uuid.get(base_uuid) or []\n                    keep_count = max(math.floor(percent_to_keep * count), 1)\n                    uuids_to_remove = uuids[keep_count:]\n                    for uuid in uuids_to_remove:\n                        if uuid not in block_dicts_by_uuid:\n                            continue\n                        block_dict = block_dicts_by_uuid[uuid]\n                        for (uuids_to_loop, key_to_remove_from) in [('upstream_blocks', 'downstream_blocks'), ('downstream_blocks', 'upstream_blocks')]:\n                            for uuids_inner in block_dict[uuids_to_loop]:\n                                if uuids_inner not in block_dicts_by_uuid:\n                                    continue\n                                arr = block_dicts_by_uuid[uuids_inner][key_to_remove_from]\n                                block_dicts_by_uuid[uuids_inner][key_to_remove_from] = [i for i in arr if i != uuid]\n                        block_dicts_by_uuid.pop(uuid, None)\n    return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)",
        "mutated": [
            "@classmethod\n@safe_db_query\ndef collection(self, query_arg, meta, user, **kwargs):\n    if False:\n        i = 10\n    parent_model = kwargs.get('parent_model')\n    block_count_by_base_uuid = {}\n    block_dicts_by_uuid = {}\n    data_integration_sets_by_uuid = {}\n    dynamic_block_count_by_base_uuid = {}\n    dynamic_block_uuids_by_base_uuid = {}\n    sources_destinations_by_block_uuid = {}\n    if isinstance(parent_model, Pipeline):\n        for (block_uuid, block) in parent_model.blocks_by_uuid.items():\n            block_dicts_by_uuid[block_uuid] = block.to_dict()\n    if isinstance(parent_model, PipelineRun):\n        block_mapping = {}\n        pipeline = parent_model.pipeline\n        is_data_integration_pipeline = pipeline and PipelineType.INTEGRATION == pipeline.type\n        if is_data_integration_pipeline:\n            original_blocks_mapping = {}\n            for block_run in parent_model.block_runs:\n                block_run_block_uuid = block_run.block_uuid\n                block = pipeline.get_block(block_run_block_uuid)\n                if not block:\n                    continue\n                if block.uuid not in original_blocks_mapping:\n                    original_blocks_mapping[block.uuid] = {}\n                block_dict = block.to_dict()\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n                original_blocks_mapping[block.uuid][block_run_block_uuid] = block_dict\n            for (block_run_block_uuid, block_dict) in block_dicts_by_uuid.items():\n                block_uuid = block_dict.get('uuid')\n                block_uuid_parts = block_run_block_uuid.split(':')\n                group_parts = [part for part in block_uuid_parts if part != block_uuid]\n                group_uuid = ':'.join(group_parts)\n                for key in ['downstream_blocks', 'upstream_blocks']:\n                    uuids = []\n                    for block_uuid2 in block_dict.get(key):\n                        mapping = original_blocks_mapping.get(block_uuid2)\n                        if mapping:\n                            for uuid2 in list(mapping.keys()):\n                                if uuid2 == ':'.join([block_uuid2, group_uuid]):\n                                    uuids.append(uuid2)\n                        else:\n                            uuids.append(block_uuid2)\n                    block_dict[key] = uuids\n                if len(group_parts) >= 1:\n                    block_dict['tags'] = [group_parts[0]]\n                if len(group_parts) >= 2:\n                    block_dict['description'] = group_parts[1]\n                block_dict['name'] = block_uuid\n                block_dict['uuid'] = block_run_block_uuid\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n            return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)\n        for block_run in parent_model.block_runs:\n            block_run_block_uuid = block_run.block_uuid\n            if block_run_block_uuid not in block_mapping:\n                block_mapping[block_run_block_uuid] = dict(block_run=block_run, uuids=[])\n            block = pipeline.get_block(block_run_block_uuid)\n            if not block:\n                continue\n            if block.uuid not in block_count_by_base_uuid:\n                block_count_by_base_uuid[block.uuid] = 0\n            block_count_by_base_uuid[block.uuid] += 1\n            block_dict = block.to_dict()\n            if 'tags' not in block_dict:\n                block_dict['tags'] = []\n            block_dict['uuid'] = block_run_block_uuid\n            metrics = block_run.metrics\n            if metrics and block.is_data_integration():\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                controller_block_uuid = metrics.get('controller_block_uuid')\n                original = metrics.get('original')\n                original_block_uuid = metrics.get('original_block_uuid')\n                tags = []\n                if original:\n                    if BlockType.DATA_LOADER == block.type:\n                        block_dict['description'] = 'Source'\n                    elif BlockType.DATA_EXPORTER == block.type:\n                        block_dict['description'] = 'Destination'\n                elif controller and (not child):\n                    block_dict['description'] = 'Controller'\n                else:\n                    block_dict['name'] = original_block_uuid\n                if child:\n                    parts = block_run_block_uuid.split(':')\n                    source_destination = None\n                    stream = None\n                    index = None\n                    if len(parts) >= 2:\n                        source_destination = parts[1]\n                        for b_uuid in [controller_block_uuid, original_block_uuid]:\n                            if b_uuid not in sources_destinations_by_block_uuid:\n                                sources_destinations_by_block_uuid[b_uuid] = []\n                            if source_destination not in sources_destinations_by_block_uuid[b_uuid]:\n                                sources_destinations_by_block_uuid[b_uuid].append(source_destination)\n                    if len(parts) >= 3:\n                        stream = parts[2]\n                    block_mapping[block_run_block_uuid]['uuids'].append(controller_block_uuid)\n                    if controller:\n                        block_dict['description'] = 'Controller'\n                    else:\n                        if len(parts) >= 4:\n                            index = str(parts[3])\n                        block_dict['description'] = index\n                        if original_block_uuid not in block_mapping:\n                            block_mapping[original_block_uuid] = dict(uuids=[])\n                        block_mapping[original_block_uuid]['uuids'].append(block_run_block_uuid)\n                    tags.append(stream)\n                if tags:\n                    block_dict['tags'] = tags\n                if original_block_uuid:\n                    if original_block_uuid not in data_integration_sets_by_uuid:\n                        data_integration_sets_by_uuid[original_block_uuid] = dict(children={}, controller=None, controllers={}, original=None)\n                    data = merge_dict(block_dict, dict(metrics=metrics))\n                    if original:\n                        data_integration_sets_by_uuid[original_block_uuid]['original'] = data\n                    elif child:\n                        if controller:\n                            data_integration_sets_by_uuid[original_block_uuid]['controllers'][block_run_block_uuid] = data\n                        elif controller_block_uuid:\n                            if controller_block_uuid not in data_integration_sets_by_uuid[original_block_uuid]['children']:\n                                data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid] = []\n                            data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid].append(data)\n                    elif controller:\n                        data_integration_sets_by_uuid[original_block_uuid]['controller'] = data\n            if is_dynamic_block_child(block):\n                if block.uuid not in dynamic_block_count_by_base_uuid:\n                    dynamic_block_count_by_base_uuid[block.uuid] = 0\n                dynamic_block_count_by_base_uuid[block.uuid] += 1\n                if block.uuid not in dynamic_block_uuids_by_base_uuid:\n                    dynamic_block_uuids_by_base_uuid[block.uuid] = []\n                dynamic_block_uuids_by_base_uuid[block.uuid].append(block_run_block_uuid)\n                parts = block_run_block_uuid.split(':')\n                parts_length = len(parts)\n                if parts_length >= 2:\n                    block_dict['description'] = ':'.join(parts[1:])\n                    e_i = parts_length - 1\n                    parts_new = parts[1:e_i]\n                    for upstream_block in block.upstream_blocks:\n                        if is_dynamic_block_child(upstream_block):\n                            parts_new = [upstream_block.uuid] + parts_new\n                            block_mapping[block_run_block_uuid]['uuids'].append(':'.join(parts_new))\n                if should_reduce_output(block):\n                    for db in block.downstream_blocks:\n                        if db.uuid not in block_mapping:\n                            block_mapping[db.uuid] = dict(uuids=[])\n                        block_mapping[db.uuid]['uuids'].append(block_run_block_uuid)\n                else:\n                    for db in block.downstream_blocks:\n                        db_uuid = ':'.join([db.uuid] + parts[1:])\n                        if db_uuid not in block_mapping:\n                            block_mapping[db_uuid] = dict(uuids=[])\n                        block_mapping[db_uuid]['uuids'].append(block_run_block_uuid)\n            if block.replicated_block:\n                block_dict['name'] = block.uuid\n                block_dict['description'] = block.replicated_block\n            block_dict['tags'] += block.tags()\n            block_dicts_by_uuid[block_run_block_uuid] = block_dict\n        for (block_uuid, block_dict) in block_dicts_by_uuid.items():\n            for key in ['downstream_blocks', 'upstream_blocks']:\n                arr = block_dict.get(key) or []\n                for block_uuid_base in arr:\n                    block = pipeline.get_block(block_uuid_base)\n                    if block is None:\n                        continue\n                    if block.replicated_block and (not is_dynamic_block_child(block)):\n                        blocks_arr = block_dicts_by_uuid[block_uuid].get(key) or []\n                        block_dicts_by_uuid[block_uuid][key] = [uuid for uuid in blocks_arr if uuid != block_uuid_base]\n                        block_dicts_by_uuid[block_uuid][key].append(block.uuid_replicated)\n        blocks_to_not_override = {}\n        for (original_block_uuid, set_dict) in data_integration_sets_by_uuid.items():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            controllers_not_parallel = list(filter(lambda x: not (x.get('metrics') or {}).get('run_in_parallel'), controllers.values()))\n            controller_child_end = find(lambda x: not (x.get('metrics') or {}).get('downstream_block_uuids'), controllers_not_parallel)\n\n            def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n                uuid = controller_child.get('uuid')\n                metrics = controller_child.get('metrics') or {}\n                upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n                for up_block_uuid in upstream_block_uuids:\n                    arr = children_inner.get(up_block_uuid) or []\n                    block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n                    blocks_to_not_override[uuid] = True\n                    for d_child in arr:\n                        child_uuid = d_child['uuid']\n                        block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n                        block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n                        blocks_to_not_override[child_uuid] = True\n                    up_controller = controllers_inner.get(up_block_uuid)\n                    if up_controller:\n                        _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)\n            if controller_child_end:\n                _update_upstream_block_uuids(controller_child_end, controllers, children)\n                controller_child_end_uuid = controller_child_end.get('uuid')\n                children_end = children.get(controller_child_end_uuid) or []\n                block_dicts_by_uuid[original_block_uuid]['upstream_blocks'] = [d['uuid'] for d in children_end]\n                blocks_to_not_override[original_block_uuid] = True\n                downstream_blocks = block_dicts_by_uuid[original_block_uuid].get('downstream_blocks') or []\n                for down_uuid in downstream_blocks:\n                    blocks_to_not_override[down_uuid] = True\n                for up_uuid in block_dicts_by_uuid[original_block_uuid]['upstream_blocks']:\n                    block_dicts_by_uuid[up_uuid]['upstream_blocks'] = [controller_child_end_uuid]\n                    block_dicts_by_uuid[up_uuid]['downstream_blocks'] = [original_block_uuid]\n                    blocks_to_not_override[up_uuid] = True\n            controller_child_start = find(lambda x: not (x.get('metrics') or {}).get('upstream_block_uuids'), controllers_not_parallel)\n            if controller_child_start:\n                controller_child_start_uuid = controller_child_start['uuid']\n                block_dicts_by_uuid[controller_child_start_uuid]['upstream_blocks'] = [controller.get('uuid')]\n                blocks_to_not_override[controller_child_start_uuid] = True\n        for (block_uuid, mapping) in block_mapping.items():\n            block = pipeline.get_block(block_uuid)\n            if not block:\n                continue\n            if block_uuid not in block_dicts_by_uuid:\n                continue\n            block_run = mapping.get('block_run')\n            metrics = block_run.metrics if block_run else None\n            upstream_block_uuids = mapping['uuids']\n            child = False\n            controller = False\n            original = False\n            is_data_integration = block.is_data_integration()\n            if metrics and is_data_integration:\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                original = metrics.get('original')\n            if original or (controller and (not child)):\n                if block_uuid in sources_destinations_by_block_uuid:\n                    if 'tags' not in block_dicts_by_uuid[block_uuid]:\n                        block_dicts_by_uuid[block_uuid] = []\n                    block_dicts_by_uuid[block_uuid]['tags'].append(sources_destinations_by_block_uuid[block_uuid])\n            if block_uuid in blocks_to_not_override:\n                continue\n            if original:\n                block_dicts_by_uuid[block_uuid]['upstream_blocks'] = []\n            for ub_uuid in upstream_block_uuids:\n                if ub_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                    continue\n                if is_data_integration:\n                    if child:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [ub_uuid]\n                        continue\n                    elif original:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                else:\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                ub_block = pipeline.get_block(ub_uuid)\n                if ub_block and is_dynamic_block_child(ub_block) and (ub_block.uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']):\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks'] if uuid != ub_block.uuid]\n            for up_block_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                if up_block_uuid not in block_dicts_by_uuid:\n                    continue\n                if block_uuid not in block_dicts_by_uuid[up_block_uuid]:\n                    if block_uuid not in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        block_dicts_by_uuid[up_block_uuid]['downstream_blocks'].append(block_uuid)\n                up_block = pipeline.get_block(up_block_uuid)\n                if up_block and is_dynamic_block(up_block):\n                    for db_block_uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        db_block = pipeline.get_block(db_block_uuid)\n                        if db_block and is_dynamic_block_child(db_block):\n                            block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] if uuid != db_block.uuid]\n        for set_dict in data_integration_sets_by_uuid.values():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            original = set_dict.get('original') or {}\n            for controller_uuid in [controller.get('uuid')] + list(controllers.keys()):\n                if controller_uuid in block_dicts_by_uuid:\n                    block_run = block_mapping.get(controller_uuid, {}).get('block_run')\n                    if block_run and block_run.started_at:\n                        block_dict = block_dicts_by_uuid[controller_uuid]\n                        downstream_started_ats = []\n                        for db_uuid in block_dict.get('downstream_blocks') or []:\n                            db_block_run = block_mapping.get(db_uuid, {}).get('block_run')\n                            if db_block_run and db_block_run.started_at:\n                                downstream_started_ats.append(db_block_run.started_at)\n                        if downstream_started_ats:\n                            started_at_e = max(downstream_started_ats)\n                            block_dicts_by_uuid[controller_uuid]['runtime'] = started_at_e.timestamp() - block_run.started_at.timestamp()\n        dynamic_blocks_beyond_1 = {}\n        for (base_uuid, count) in dynamic_block_count_by_base_uuid.items():\n            if count >= 2:\n                dynamic_blocks_beyond_1[base_uuid] = count\n        total_blocks = sum(list(block_count_by_base_uuid.values()))\n        total_blocks_dynamic_beyond_1 = sum(list(dynamic_blocks_beyond_1.values()))\n        if total_blocks > MAX_BLOCKS_FOR_TREE:\n            remove_this_much = total_blocks - MAX_BLOCKS_FOR_TREE\n            if total_blocks_dynamic_beyond_1 > remove_this_much:\n                keep_this_much = total_blocks_dynamic_beyond_1 - remove_this_much\n                percent_to_keep = keep_this_much / total_blocks_dynamic_beyond_1\n                for (base_uuid, count) in dynamic_blocks_beyond_1.items():\n                    uuids = dynamic_block_uuids_by_base_uuid.get(base_uuid) or []\n                    keep_count = max(math.floor(percent_to_keep * count), 1)\n                    uuids_to_remove = uuids[keep_count:]\n                    for uuid in uuids_to_remove:\n                        if uuid not in block_dicts_by_uuid:\n                            continue\n                        block_dict = block_dicts_by_uuid[uuid]\n                        for (uuids_to_loop, key_to_remove_from) in [('upstream_blocks', 'downstream_blocks'), ('downstream_blocks', 'upstream_blocks')]:\n                            for uuids_inner in block_dict[uuids_to_loop]:\n                                if uuids_inner not in block_dicts_by_uuid:\n                                    continue\n                                arr = block_dicts_by_uuid[uuids_inner][key_to_remove_from]\n                                block_dicts_by_uuid[uuids_inner][key_to_remove_from] = [i for i in arr if i != uuid]\n                        block_dicts_by_uuid.pop(uuid, None)\n    return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)",
            "@classmethod\n@safe_db_query\ndef collection(self, query_arg, meta, user, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parent_model = kwargs.get('parent_model')\n    block_count_by_base_uuid = {}\n    block_dicts_by_uuid = {}\n    data_integration_sets_by_uuid = {}\n    dynamic_block_count_by_base_uuid = {}\n    dynamic_block_uuids_by_base_uuid = {}\n    sources_destinations_by_block_uuid = {}\n    if isinstance(parent_model, Pipeline):\n        for (block_uuid, block) in parent_model.blocks_by_uuid.items():\n            block_dicts_by_uuid[block_uuid] = block.to_dict()\n    if isinstance(parent_model, PipelineRun):\n        block_mapping = {}\n        pipeline = parent_model.pipeline\n        is_data_integration_pipeline = pipeline and PipelineType.INTEGRATION == pipeline.type\n        if is_data_integration_pipeline:\n            original_blocks_mapping = {}\n            for block_run in parent_model.block_runs:\n                block_run_block_uuid = block_run.block_uuid\n                block = pipeline.get_block(block_run_block_uuid)\n                if not block:\n                    continue\n                if block.uuid not in original_blocks_mapping:\n                    original_blocks_mapping[block.uuid] = {}\n                block_dict = block.to_dict()\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n                original_blocks_mapping[block.uuid][block_run_block_uuid] = block_dict\n            for (block_run_block_uuid, block_dict) in block_dicts_by_uuid.items():\n                block_uuid = block_dict.get('uuid')\n                block_uuid_parts = block_run_block_uuid.split(':')\n                group_parts = [part for part in block_uuid_parts if part != block_uuid]\n                group_uuid = ':'.join(group_parts)\n                for key in ['downstream_blocks', 'upstream_blocks']:\n                    uuids = []\n                    for block_uuid2 in block_dict.get(key):\n                        mapping = original_blocks_mapping.get(block_uuid2)\n                        if mapping:\n                            for uuid2 in list(mapping.keys()):\n                                if uuid2 == ':'.join([block_uuid2, group_uuid]):\n                                    uuids.append(uuid2)\n                        else:\n                            uuids.append(block_uuid2)\n                    block_dict[key] = uuids\n                if len(group_parts) >= 1:\n                    block_dict['tags'] = [group_parts[0]]\n                if len(group_parts) >= 2:\n                    block_dict['description'] = group_parts[1]\n                block_dict['name'] = block_uuid\n                block_dict['uuid'] = block_run_block_uuid\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n            return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)\n        for block_run in parent_model.block_runs:\n            block_run_block_uuid = block_run.block_uuid\n            if block_run_block_uuid not in block_mapping:\n                block_mapping[block_run_block_uuid] = dict(block_run=block_run, uuids=[])\n            block = pipeline.get_block(block_run_block_uuid)\n            if not block:\n                continue\n            if block.uuid not in block_count_by_base_uuid:\n                block_count_by_base_uuid[block.uuid] = 0\n            block_count_by_base_uuid[block.uuid] += 1\n            block_dict = block.to_dict()\n            if 'tags' not in block_dict:\n                block_dict['tags'] = []\n            block_dict['uuid'] = block_run_block_uuid\n            metrics = block_run.metrics\n            if metrics and block.is_data_integration():\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                controller_block_uuid = metrics.get('controller_block_uuid')\n                original = metrics.get('original')\n                original_block_uuid = metrics.get('original_block_uuid')\n                tags = []\n                if original:\n                    if BlockType.DATA_LOADER == block.type:\n                        block_dict['description'] = 'Source'\n                    elif BlockType.DATA_EXPORTER == block.type:\n                        block_dict['description'] = 'Destination'\n                elif controller and (not child):\n                    block_dict['description'] = 'Controller'\n                else:\n                    block_dict['name'] = original_block_uuid\n                if child:\n                    parts = block_run_block_uuid.split(':')\n                    source_destination = None\n                    stream = None\n                    index = None\n                    if len(parts) >= 2:\n                        source_destination = parts[1]\n                        for b_uuid in [controller_block_uuid, original_block_uuid]:\n                            if b_uuid not in sources_destinations_by_block_uuid:\n                                sources_destinations_by_block_uuid[b_uuid] = []\n                            if source_destination not in sources_destinations_by_block_uuid[b_uuid]:\n                                sources_destinations_by_block_uuid[b_uuid].append(source_destination)\n                    if len(parts) >= 3:\n                        stream = parts[2]\n                    block_mapping[block_run_block_uuid]['uuids'].append(controller_block_uuid)\n                    if controller:\n                        block_dict['description'] = 'Controller'\n                    else:\n                        if len(parts) >= 4:\n                            index = str(parts[3])\n                        block_dict['description'] = index\n                        if original_block_uuid not in block_mapping:\n                            block_mapping[original_block_uuid] = dict(uuids=[])\n                        block_mapping[original_block_uuid]['uuids'].append(block_run_block_uuid)\n                    tags.append(stream)\n                if tags:\n                    block_dict['tags'] = tags\n                if original_block_uuid:\n                    if original_block_uuid not in data_integration_sets_by_uuid:\n                        data_integration_sets_by_uuid[original_block_uuid] = dict(children={}, controller=None, controllers={}, original=None)\n                    data = merge_dict(block_dict, dict(metrics=metrics))\n                    if original:\n                        data_integration_sets_by_uuid[original_block_uuid]['original'] = data\n                    elif child:\n                        if controller:\n                            data_integration_sets_by_uuid[original_block_uuid]['controllers'][block_run_block_uuid] = data\n                        elif controller_block_uuid:\n                            if controller_block_uuid not in data_integration_sets_by_uuid[original_block_uuid]['children']:\n                                data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid] = []\n                            data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid].append(data)\n                    elif controller:\n                        data_integration_sets_by_uuid[original_block_uuid]['controller'] = data\n            if is_dynamic_block_child(block):\n                if block.uuid not in dynamic_block_count_by_base_uuid:\n                    dynamic_block_count_by_base_uuid[block.uuid] = 0\n                dynamic_block_count_by_base_uuid[block.uuid] += 1\n                if block.uuid not in dynamic_block_uuids_by_base_uuid:\n                    dynamic_block_uuids_by_base_uuid[block.uuid] = []\n                dynamic_block_uuids_by_base_uuid[block.uuid].append(block_run_block_uuid)\n                parts = block_run_block_uuid.split(':')\n                parts_length = len(parts)\n                if parts_length >= 2:\n                    block_dict['description'] = ':'.join(parts[1:])\n                    e_i = parts_length - 1\n                    parts_new = parts[1:e_i]\n                    for upstream_block in block.upstream_blocks:\n                        if is_dynamic_block_child(upstream_block):\n                            parts_new = [upstream_block.uuid] + parts_new\n                            block_mapping[block_run_block_uuid]['uuids'].append(':'.join(parts_new))\n                if should_reduce_output(block):\n                    for db in block.downstream_blocks:\n                        if db.uuid not in block_mapping:\n                            block_mapping[db.uuid] = dict(uuids=[])\n                        block_mapping[db.uuid]['uuids'].append(block_run_block_uuid)\n                else:\n                    for db in block.downstream_blocks:\n                        db_uuid = ':'.join([db.uuid] + parts[1:])\n                        if db_uuid not in block_mapping:\n                            block_mapping[db_uuid] = dict(uuids=[])\n                        block_mapping[db_uuid]['uuids'].append(block_run_block_uuid)\n            if block.replicated_block:\n                block_dict['name'] = block.uuid\n                block_dict['description'] = block.replicated_block\n            block_dict['tags'] += block.tags()\n            block_dicts_by_uuid[block_run_block_uuid] = block_dict\n        for (block_uuid, block_dict) in block_dicts_by_uuid.items():\n            for key in ['downstream_blocks', 'upstream_blocks']:\n                arr = block_dict.get(key) or []\n                for block_uuid_base in arr:\n                    block = pipeline.get_block(block_uuid_base)\n                    if block is None:\n                        continue\n                    if block.replicated_block and (not is_dynamic_block_child(block)):\n                        blocks_arr = block_dicts_by_uuid[block_uuid].get(key) or []\n                        block_dicts_by_uuid[block_uuid][key] = [uuid for uuid in blocks_arr if uuid != block_uuid_base]\n                        block_dicts_by_uuid[block_uuid][key].append(block.uuid_replicated)\n        blocks_to_not_override = {}\n        for (original_block_uuid, set_dict) in data_integration_sets_by_uuid.items():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            controllers_not_parallel = list(filter(lambda x: not (x.get('metrics') or {}).get('run_in_parallel'), controllers.values()))\n            controller_child_end = find(lambda x: not (x.get('metrics') or {}).get('downstream_block_uuids'), controllers_not_parallel)\n\n            def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n                uuid = controller_child.get('uuid')\n                metrics = controller_child.get('metrics') or {}\n                upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n                for up_block_uuid in upstream_block_uuids:\n                    arr = children_inner.get(up_block_uuid) or []\n                    block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n                    blocks_to_not_override[uuid] = True\n                    for d_child in arr:\n                        child_uuid = d_child['uuid']\n                        block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n                        block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n                        blocks_to_not_override[child_uuid] = True\n                    up_controller = controllers_inner.get(up_block_uuid)\n                    if up_controller:\n                        _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)\n            if controller_child_end:\n                _update_upstream_block_uuids(controller_child_end, controllers, children)\n                controller_child_end_uuid = controller_child_end.get('uuid')\n                children_end = children.get(controller_child_end_uuid) or []\n                block_dicts_by_uuid[original_block_uuid]['upstream_blocks'] = [d['uuid'] for d in children_end]\n                blocks_to_not_override[original_block_uuid] = True\n                downstream_blocks = block_dicts_by_uuid[original_block_uuid].get('downstream_blocks') or []\n                for down_uuid in downstream_blocks:\n                    blocks_to_not_override[down_uuid] = True\n                for up_uuid in block_dicts_by_uuid[original_block_uuid]['upstream_blocks']:\n                    block_dicts_by_uuid[up_uuid]['upstream_blocks'] = [controller_child_end_uuid]\n                    block_dicts_by_uuid[up_uuid]['downstream_blocks'] = [original_block_uuid]\n                    blocks_to_not_override[up_uuid] = True\n            controller_child_start = find(lambda x: not (x.get('metrics') or {}).get('upstream_block_uuids'), controllers_not_parallel)\n            if controller_child_start:\n                controller_child_start_uuid = controller_child_start['uuid']\n                block_dicts_by_uuid[controller_child_start_uuid]['upstream_blocks'] = [controller.get('uuid')]\n                blocks_to_not_override[controller_child_start_uuid] = True\n        for (block_uuid, mapping) in block_mapping.items():\n            block = pipeline.get_block(block_uuid)\n            if not block:\n                continue\n            if block_uuid not in block_dicts_by_uuid:\n                continue\n            block_run = mapping.get('block_run')\n            metrics = block_run.metrics if block_run else None\n            upstream_block_uuids = mapping['uuids']\n            child = False\n            controller = False\n            original = False\n            is_data_integration = block.is_data_integration()\n            if metrics and is_data_integration:\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                original = metrics.get('original')\n            if original or (controller and (not child)):\n                if block_uuid in sources_destinations_by_block_uuid:\n                    if 'tags' not in block_dicts_by_uuid[block_uuid]:\n                        block_dicts_by_uuid[block_uuid] = []\n                    block_dicts_by_uuid[block_uuid]['tags'].append(sources_destinations_by_block_uuid[block_uuid])\n            if block_uuid in blocks_to_not_override:\n                continue\n            if original:\n                block_dicts_by_uuid[block_uuid]['upstream_blocks'] = []\n            for ub_uuid in upstream_block_uuids:\n                if ub_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                    continue\n                if is_data_integration:\n                    if child:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [ub_uuid]\n                        continue\n                    elif original:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                else:\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                ub_block = pipeline.get_block(ub_uuid)\n                if ub_block and is_dynamic_block_child(ub_block) and (ub_block.uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']):\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks'] if uuid != ub_block.uuid]\n            for up_block_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                if up_block_uuid not in block_dicts_by_uuid:\n                    continue\n                if block_uuid not in block_dicts_by_uuid[up_block_uuid]:\n                    if block_uuid not in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        block_dicts_by_uuid[up_block_uuid]['downstream_blocks'].append(block_uuid)\n                up_block = pipeline.get_block(up_block_uuid)\n                if up_block and is_dynamic_block(up_block):\n                    for db_block_uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        db_block = pipeline.get_block(db_block_uuid)\n                        if db_block and is_dynamic_block_child(db_block):\n                            block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] if uuid != db_block.uuid]\n        for set_dict in data_integration_sets_by_uuid.values():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            original = set_dict.get('original') or {}\n            for controller_uuid in [controller.get('uuid')] + list(controllers.keys()):\n                if controller_uuid in block_dicts_by_uuid:\n                    block_run = block_mapping.get(controller_uuid, {}).get('block_run')\n                    if block_run and block_run.started_at:\n                        block_dict = block_dicts_by_uuid[controller_uuid]\n                        downstream_started_ats = []\n                        for db_uuid in block_dict.get('downstream_blocks') or []:\n                            db_block_run = block_mapping.get(db_uuid, {}).get('block_run')\n                            if db_block_run and db_block_run.started_at:\n                                downstream_started_ats.append(db_block_run.started_at)\n                        if downstream_started_ats:\n                            started_at_e = max(downstream_started_ats)\n                            block_dicts_by_uuid[controller_uuid]['runtime'] = started_at_e.timestamp() - block_run.started_at.timestamp()\n        dynamic_blocks_beyond_1 = {}\n        for (base_uuid, count) in dynamic_block_count_by_base_uuid.items():\n            if count >= 2:\n                dynamic_blocks_beyond_1[base_uuid] = count\n        total_blocks = sum(list(block_count_by_base_uuid.values()))\n        total_blocks_dynamic_beyond_1 = sum(list(dynamic_blocks_beyond_1.values()))\n        if total_blocks > MAX_BLOCKS_FOR_TREE:\n            remove_this_much = total_blocks - MAX_BLOCKS_FOR_TREE\n            if total_blocks_dynamic_beyond_1 > remove_this_much:\n                keep_this_much = total_blocks_dynamic_beyond_1 - remove_this_much\n                percent_to_keep = keep_this_much / total_blocks_dynamic_beyond_1\n                for (base_uuid, count) in dynamic_blocks_beyond_1.items():\n                    uuids = dynamic_block_uuids_by_base_uuid.get(base_uuid) or []\n                    keep_count = max(math.floor(percent_to_keep * count), 1)\n                    uuids_to_remove = uuids[keep_count:]\n                    for uuid in uuids_to_remove:\n                        if uuid not in block_dicts_by_uuid:\n                            continue\n                        block_dict = block_dicts_by_uuid[uuid]\n                        for (uuids_to_loop, key_to_remove_from) in [('upstream_blocks', 'downstream_blocks'), ('downstream_blocks', 'upstream_blocks')]:\n                            for uuids_inner in block_dict[uuids_to_loop]:\n                                if uuids_inner not in block_dicts_by_uuid:\n                                    continue\n                                arr = block_dicts_by_uuid[uuids_inner][key_to_remove_from]\n                                block_dicts_by_uuid[uuids_inner][key_to_remove_from] = [i for i in arr if i != uuid]\n                        block_dicts_by_uuid.pop(uuid, None)\n    return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)",
            "@classmethod\n@safe_db_query\ndef collection(self, query_arg, meta, user, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parent_model = kwargs.get('parent_model')\n    block_count_by_base_uuid = {}\n    block_dicts_by_uuid = {}\n    data_integration_sets_by_uuid = {}\n    dynamic_block_count_by_base_uuid = {}\n    dynamic_block_uuids_by_base_uuid = {}\n    sources_destinations_by_block_uuid = {}\n    if isinstance(parent_model, Pipeline):\n        for (block_uuid, block) in parent_model.blocks_by_uuid.items():\n            block_dicts_by_uuid[block_uuid] = block.to_dict()\n    if isinstance(parent_model, PipelineRun):\n        block_mapping = {}\n        pipeline = parent_model.pipeline\n        is_data_integration_pipeline = pipeline and PipelineType.INTEGRATION == pipeline.type\n        if is_data_integration_pipeline:\n            original_blocks_mapping = {}\n            for block_run in parent_model.block_runs:\n                block_run_block_uuid = block_run.block_uuid\n                block = pipeline.get_block(block_run_block_uuid)\n                if not block:\n                    continue\n                if block.uuid not in original_blocks_mapping:\n                    original_blocks_mapping[block.uuid] = {}\n                block_dict = block.to_dict()\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n                original_blocks_mapping[block.uuid][block_run_block_uuid] = block_dict\n            for (block_run_block_uuid, block_dict) in block_dicts_by_uuid.items():\n                block_uuid = block_dict.get('uuid')\n                block_uuid_parts = block_run_block_uuid.split(':')\n                group_parts = [part for part in block_uuid_parts if part != block_uuid]\n                group_uuid = ':'.join(group_parts)\n                for key in ['downstream_blocks', 'upstream_blocks']:\n                    uuids = []\n                    for block_uuid2 in block_dict.get(key):\n                        mapping = original_blocks_mapping.get(block_uuid2)\n                        if mapping:\n                            for uuid2 in list(mapping.keys()):\n                                if uuid2 == ':'.join([block_uuid2, group_uuid]):\n                                    uuids.append(uuid2)\n                        else:\n                            uuids.append(block_uuid2)\n                    block_dict[key] = uuids\n                if len(group_parts) >= 1:\n                    block_dict['tags'] = [group_parts[0]]\n                if len(group_parts) >= 2:\n                    block_dict['description'] = group_parts[1]\n                block_dict['name'] = block_uuid\n                block_dict['uuid'] = block_run_block_uuid\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n            return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)\n        for block_run in parent_model.block_runs:\n            block_run_block_uuid = block_run.block_uuid\n            if block_run_block_uuid not in block_mapping:\n                block_mapping[block_run_block_uuid] = dict(block_run=block_run, uuids=[])\n            block = pipeline.get_block(block_run_block_uuid)\n            if not block:\n                continue\n            if block.uuid not in block_count_by_base_uuid:\n                block_count_by_base_uuid[block.uuid] = 0\n            block_count_by_base_uuid[block.uuid] += 1\n            block_dict = block.to_dict()\n            if 'tags' not in block_dict:\n                block_dict['tags'] = []\n            block_dict['uuid'] = block_run_block_uuid\n            metrics = block_run.metrics\n            if metrics and block.is_data_integration():\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                controller_block_uuid = metrics.get('controller_block_uuid')\n                original = metrics.get('original')\n                original_block_uuid = metrics.get('original_block_uuid')\n                tags = []\n                if original:\n                    if BlockType.DATA_LOADER == block.type:\n                        block_dict['description'] = 'Source'\n                    elif BlockType.DATA_EXPORTER == block.type:\n                        block_dict['description'] = 'Destination'\n                elif controller and (not child):\n                    block_dict['description'] = 'Controller'\n                else:\n                    block_dict['name'] = original_block_uuid\n                if child:\n                    parts = block_run_block_uuid.split(':')\n                    source_destination = None\n                    stream = None\n                    index = None\n                    if len(parts) >= 2:\n                        source_destination = parts[1]\n                        for b_uuid in [controller_block_uuid, original_block_uuid]:\n                            if b_uuid not in sources_destinations_by_block_uuid:\n                                sources_destinations_by_block_uuid[b_uuid] = []\n                            if source_destination not in sources_destinations_by_block_uuid[b_uuid]:\n                                sources_destinations_by_block_uuid[b_uuid].append(source_destination)\n                    if len(parts) >= 3:\n                        stream = parts[2]\n                    block_mapping[block_run_block_uuid]['uuids'].append(controller_block_uuid)\n                    if controller:\n                        block_dict['description'] = 'Controller'\n                    else:\n                        if len(parts) >= 4:\n                            index = str(parts[3])\n                        block_dict['description'] = index\n                        if original_block_uuid not in block_mapping:\n                            block_mapping[original_block_uuid] = dict(uuids=[])\n                        block_mapping[original_block_uuid]['uuids'].append(block_run_block_uuid)\n                    tags.append(stream)\n                if tags:\n                    block_dict['tags'] = tags\n                if original_block_uuid:\n                    if original_block_uuid not in data_integration_sets_by_uuid:\n                        data_integration_sets_by_uuid[original_block_uuid] = dict(children={}, controller=None, controllers={}, original=None)\n                    data = merge_dict(block_dict, dict(metrics=metrics))\n                    if original:\n                        data_integration_sets_by_uuid[original_block_uuid]['original'] = data\n                    elif child:\n                        if controller:\n                            data_integration_sets_by_uuid[original_block_uuid]['controllers'][block_run_block_uuid] = data\n                        elif controller_block_uuid:\n                            if controller_block_uuid not in data_integration_sets_by_uuid[original_block_uuid]['children']:\n                                data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid] = []\n                            data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid].append(data)\n                    elif controller:\n                        data_integration_sets_by_uuid[original_block_uuid]['controller'] = data\n            if is_dynamic_block_child(block):\n                if block.uuid not in dynamic_block_count_by_base_uuid:\n                    dynamic_block_count_by_base_uuid[block.uuid] = 0\n                dynamic_block_count_by_base_uuid[block.uuid] += 1\n                if block.uuid not in dynamic_block_uuids_by_base_uuid:\n                    dynamic_block_uuids_by_base_uuid[block.uuid] = []\n                dynamic_block_uuids_by_base_uuid[block.uuid].append(block_run_block_uuid)\n                parts = block_run_block_uuid.split(':')\n                parts_length = len(parts)\n                if parts_length >= 2:\n                    block_dict['description'] = ':'.join(parts[1:])\n                    e_i = parts_length - 1\n                    parts_new = parts[1:e_i]\n                    for upstream_block in block.upstream_blocks:\n                        if is_dynamic_block_child(upstream_block):\n                            parts_new = [upstream_block.uuid] + parts_new\n                            block_mapping[block_run_block_uuid]['uuids'].append(':'.join(parts_new))\n                if should_reduce_output(block):\n                    for db in block.downstream_blocks:\n                        if db.uuid not in block_mapping:\n                            block_mapping[db.uuid] = dict(uuids=[])\n                        block_mapping[db.uuid]['uuids'].append(block_run_block_uuid)\n                else:\n                    for db in block.downstream_blocks:\n                        db_uuid = ':'.join([db.uuid] + parts[1:])\n                        if db_uuid not in block_mapping:\n                            block_mapping[db_uuid] = dict(uuids=[])\n                        block_mapping[db_uuid]['uuids'].append(block_run_block_uuid)\n            if block.replicated_block:\n                block_dict['name'] = block.uuid\n                block_dict['description'] = block.replicated_block\n            block_dict['tags'] += block.tags()\n            block_dicts_by_uuid[block_run_block_uuid] = block_dict\n        for (block_uuid, block_dict) in block_dicts_by_uuid.items():\n            for key in ['downstream_blocks', 'upstream_blocks']:\n                arr = block_dict.get(key) or []\n                for block_uuid_base in arr:\n                    block = pipeline.get_block(block_uuid_base)\n                    if block is None:\n                        continue\n                    if block.replicated_block and (not is_dynamic_block_child(block)):\n                        blocks_arr = block_dicts_by_uuid[block_uuid].get(key) or []\n                        block_dicts_by_uuid[block_uuid][key] = [uuid for uuid in blocks_arr if uuid != block_uuid_base]\n                        block_dicts_by_uuid[block_uuid][key].append(block.uuid_replicated)\n        blocks_to_not_override = {}\n        for (original_block_uuid, set_dict) in data_integration_sets_by_uuid.items():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            controllers_not_parallel = list(filter(lambda x: not (x.get('metrics') or {}).get('run_in_parallel'), controllers.values()))\n            controller_child_end = find(lambda x: not (x.get('metrics') or {}).get('downstream_block_uuids'), controllers_not_parallel)\n\n            def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n                uuid = controller_child.get('uuid')\n                metrics = controller_child.get('metrics') or {}\n                upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n                for up_block_uuid in upstream_block_uuids:\n                    arr = children_inner.get(up_block_uuid) or []\n                    block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n                    blocks_to_not_override[uuid] = True\n                    for d_child in arr:\n                        child_uuid = d_child['uuid']\n                        block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n                        block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n                        blocks_to_not_override[child_uuid] = True\n                    up_controller = controllers_inner.get(up_block_uuid)\n                    if up_controller:\n                        _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)\n            if controller_child_end:\n                _update_upstream_block_uuids(controller_child_end, controllers, children)\n                controller_child_end_uuid = controller_child_end.get('uuid')\n                children_end = children.get(controller_child_end_uuid) or []\n                block_dicts_by_uuid[original_block_uuid]['upstream_blocks'] = [d['uuid'] for d in children_end]\n                blocks_to_not_override[original_block_uuid] = True\n                downstream_blocks = block_dicts_by_uuid[original_block_uuid].get('downstream_blocks') or []\n                for down_uuid in downstream_blocks:\n                    blocks_to_not_override[down_uuid] = True\n                for up_uuid in block_dicts_by_uuid[original_block_uuid]['upstream_blocks']:\n                    block_dicts_by_uuid[up_uuid]['upstream_blocks'] = [controller_child_end_uuid]\n                    block_dicts_by_uuid[up_uuid]['downstream_blocks'] = [original_block_uuid]\n                    blocks_to_not_override[up_uuid] = True\n            controller_child_start = find(lambda x: not (x.get('metrics') or {}).get('upstream_block_uuids'), controllers_not_parallel)\n            if controller_child_start:\n                controller_child_start_uuid = controller_child_start['uuid']\n                block_dicts_by_uuid[controller_child_start_uuid]['upstream_blocks'] = [controller.get('uuid')]\n                blocks_to_not_override[controller_child_start_uuid] = True\n        for (block_uuid, mapping) in block_mapping.items():\n            block = pipeline.get_block(block_uuid)\n            if not block:\n                continue\n            if block_uuid not in block_dicts_by_uuid:\n                continue\n            block_run = mapping.get('block_run')\n            metrics = block_run.metrics if block_run else None\n            upstream_block_uuids = mapping['uuids']\n            child = False\n            controller = False\n            original = False\n            is_data_integration = block.is_data_integration()\n            if metrics and is_data_integration:\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                original = metrics.get('original')\n            if original or (controller and (not child)):\n                if block_uuid in sources_destinations_by_block_uuid:\n                    if 'tags' not in block_dicts_by_uuid[block_uuid]:\n                        block_dicts_by_uuid[block_uuid] = []\n                    block_dicts_by_uuid[block_uuid]['tags'].append(sources_destinations_by_block_uuid[block_uuid])\n            if block_uuid in blocks_to_not_override:\n                continue\n            if original:\n                block_dicts_by_uuid[block_uuid]['upstream_blocks'] = []\n            for ub_uuid in upstream_block_uuids:\n                if ub_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                    continue\n                if is_data_integration:\n                    if child:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [ub_uuid]\n                        continue\n                    elif original:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                else:\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                ub_block = pipeline.get_block(ub_uuid)\n                if ub_block and is_dynamic_block_child(ub_block) and (ub_block.uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']):\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks'] if uuid != ub_block.uuid]\n            for up_block_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                if up_block_uuid not in block_dicts_by_uuid:\n                    continue\n                if block_uuid not in block_dicts_by_uuid[up_block_uuid]:\n                    if block_uuid not in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        block_dicts_by_uuid[up_block_uuid]['downstream_blocks'].append(block_uuid)\n                up_block = pipeline.get_block(up_block_uuid)\n                if up_block and is_dynamic_block(up_block):\n                    for db_block_uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        db_block = pipeline.get_block(db_block_uuid)\n                        if db_block and is_dynamic_block_child(db_block):\n                            block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] if uuid != db_block.uuid]\n        for set_dict in data_integration_sets_by_uuid.values():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            original = set_dict.get('original') or {}\n            for controller_uuid in [controller.get('uuid')] + list(controllers.keys()):\n                if controller_uuid in block_dicts_by_uuid:\n                    block_run = block_mapping.get(controller_uuid, {}).get('block_run')\n                    if block_run and block_run.started_at:\n                        block_dict = block_dicts_by_uuid[controller_uuid]\n                        downstream_started_ats = []\n                        for db_uuid in block_dict.get('downstream_blocks') or []:\n                            db_block_run = block_mapping.get(db_uuid, {}).get('block_run')\n                            if db_block_run and db_block_run.started_at:\n                                downstream_started_ats.append(db_block_run.started_at)\n                        if downstream_started_ats:\n                            started_at_e = max(downstream_started_ats)\n                            block_dicts_by_uuid[controller_uuid]['runtime'] = started_at_e.timestamp() - block_run.started_at.timestamp()\n        dynamic_blocks_beyond_1 = {}\n        for (base_uuid, count) in dynamic_block_count_by_base_uuid.items():\n            if count >= 2:\n                dynamic_blocks_beyond_1[base_uuid] = count\n        total_blocks = sum(list(block_count_by_base_uuid.values()))\n        total_blocks_dynamic_beyond_1 = sum(list(dynamic_blocks_beyond_1.values()))\n        if total_blocks > MAX_BLOCKS_FOR_TREE:\n            remove_this_much = total_blocks - MAX_BLOCKS_FOR_TREE\n            if total_blocks_dynamic_beyond_1 > remove_this_much:\n                keep_this_much = total_blocks_dynamic_beyond_1 - remove_this_much\n                percent_to_keep = keep_this_much / total_blocks_dynamic_beyond_1\n                for (base_uuid, count) in dynamic_blocks_beyond_1.items():\n                    uuids = dynamic_block_uuids_by_base_uuid.get(base_uuid) or []\n                    keep_count = max(math.floor(percent_to_keep * count), 1)\n                    uuids_to_remove = uuids[keep_count:]\n                    for uuid in uuids_to_remove:\n                        if uuid not in block_dicts_by_uuid:\n                            continue\n                        block_dict = block_dicts_by_uuid[uuid]\n                        for (uuids_to_loop, key_to_remove_from) in [('upstream_blocks', 'downstream_blocks'), ('downstream_blocks', 'upstream_blocks')]:\n                            for uuids_inner in block_dict[uuids_to_loop]:\n                                if uuids_inner not in block_dicts_by_uuid:\n                                    continue\n                                arr = block_dicts_by_uuid[uuids_inner][key_to_remove_from]\n                                block_dicts_by_uuid[uuids_inner][key_to_remove_from] = [i for i in arr if i != uuid]\n                        block_dicts_by_uuid.pop(uuid, None)\n    return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)",
            "@classmethod\n@safe_db_query\ndef collection(self, query_arg, meta, user, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parent_model = kwargs.get('parent_model')\n    block_count_by_base_uuid = {}\n    block_dicts_by_uuid = {}\n    data_integration_sets_by_uuid = {}\n    dynamic_block_count_by_base_uuid = {}\n    dynamic_block_uuids_by_base_uuid = {}\n    sources_destinations_by_block_uuid = {}\n    if isinstance(parent_model, Pipeline):\n        for (block_uuid, block) in parent_model.blocks_by_uuid.items():\n            block_dicts_by_uuid[block_uuid] = block.to_dict()\n    if isinstance(parent_model, PipelineRun):\n        block_mapping = {}\n        pipeline = parent_model.pipeline\n        is_data_integration_pipeline = pipeline and PipelineType.INTEGRATION == pipeline.type\n        if is_data_integration_pipeline:\n            original_blocks_mapping = {}\n            for block_run in parent_model.block_runs:\n                block_run_block_uuid = block_run.block_uuid\n                block = pipeline.get_block(block_run_block_uuid)\n                if not block:\n                    continue\n                if block.uuid not in original_blocks_mapping:\n                    original_blocks_mapping[block.uuid] = {}\n                block_dict = block.to_dict()\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n                original_blocks_mapping[block.uuid][block_run_block_uuid] = block_dict\n            for (block_run_block_uuid, block_dict) in block_dicts_by_uuid.items():\n                block_uuid = block_dict.get('uuid')\n                block_uuid_parts = block_run_block_uuid.split(':')\n                group_parts = [part for part in block_uuid_parts if part != block_uuid]\n                group_uuid = ':'.join(group_parts)\n                for key in ['downstream_blocks', 'upstream_blocks']:\n                    uuids = []\n                    for block_uuid2 in block_dict.get(key):\n                        mapping = original_blocks_mapping.get(block_uuid2)\n                        if mapping:\n                            for uuid2 in list(mapping.keys()):\n                                if uuid2 == ':'.join([block_uuid2, group_uuid]):\n                                    uuids.append(uuid2)\n                        else:\n                            uuids.append(block_uuid2)\n                    block_dict[key] = uuids\n                if len(group_parts) >= 1:\n                    block_dict['tags'] = [group_parts[0]]\n                if len(group_parts) >= 2:\n                    block_dict['description'] = group_parts[1]\n                block_dict['name'] = block_uuid\n                block_dict['uuid'] = block_run_block_uuid\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n            return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)\n        for block_run in parent_model.block_runs:\n            block_run_block_uuid = block_run.block_uuid\n            if block_run_block_uuid not in block_mapping:\n                block_mapping[block_run_block_uuid] = dict(block_run=block_run, uuids=[])\n            block = pipeline.get_block(block_run_block_uuid)\n            if not block:\n                continue\n            if block.uuid not in block_count_by_base_uuid:\n                block_count_by_base_uuid[block.uuid] = 0\n            block_count_by_base_uuid[block.uuid] += 1\n            block_dict = block.to_dict()\n            if 'tags' not in block_dict:\n                block_dict['tags'] = []\n            block_dict['uuid'] = block_run_block_uuid\n            metrics = block_run.metrics\n            if metrics and block.is_data_integration():\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                controller_block_uuid = metrics.get('controller_block_uuid')\n                original = metrics.get('original')\n                original_block_uuid = metrics.get('original_block_uuid')\n                tags = []\n                if original:\n                    if BlockType.DATA_LOADER == block.type:\n                        block_dict['description'] = 'Source'\n                    elif BlockType.DATA_EXPORTER == block.type:\n                        block_dict['description'] = 'Destination'\n                elif controller and (not child):\n                    block_dict['description'] = 'Controller'\n                else:\n                    block_dict['name'] = original_block_uuid\n                if child:\n                    parts = block_run_block_uuid.split(':')\n                    source_destination = None\n                    stream = None\n                    index = None\n                    if len(parts) >= 2:\n                        source_destination = parts[1]\n                        for b_uuid in [controller_block_uuid, original_block_uuid]:\n                            if b_uuid not in sources_destinations_by_block_uuid:\n                                sources_destinations_by_block_uuid[b_uuid] = []\n                            if source_destination not in sources_destinations_by_block_uuid[b_uuid]:\n                                sources_destinations_by_block_uuid[b_uuid].append(source_destination)\n                    if len(parts) >= 3:\n                        stream = parts[2]\n                    block_mapping[block_run_block_uuid]['uuids'].append(controller_block_uuid)\n                    if controller:\n                        block_dict['description'] = 'Controller'\n                    else:\n                        if len(parts) >= 4:\n                            index = str(parts[3])\n                        block_dict['description'] = index\n                        if original_block_uuid not in block_mapping:\n                            block_mapping[original_block_uuid] = dict(uuids=[])\n                        block_mapping[original_block_uuid]['uuids'].append(block_run_block_uuid)\n                    tags.append(stream)\n                if tags:\n                    block_dict['tags'] = tags\n                if original_block_uuid:\n                    if original_block_uuid not in data_integration_sets_by_uuid:\n                        data_integration_sets_by_uuid[original_block_uuid] = dict(children={}, controller=None, controllers={}, original=None)\n                    data = merge_dict(block_dict, dict(metrics=metrics))\n                    if original:\n                        data_integration_sets_by_uuid[original_block_uuid]['original'] = data\n                    elif child:\n                        if controller:\n                            data_integration_sets_by_uuid[original_block_uuid]['controllers'][block_run_block_uuid] = data\n                        elif controller_block_uuid:\n                            if controller_block_uuid not in data_integration_sets_by_uuid[original_block_uuid]['children']:\n                                data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid] = []\n                            data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid].append(data)\n                    elif controller:\n                        data_integration_sets_by_uuid[original_block_uuid]['controller'] = data\n            if is_dynamic_block_child(block):\n                if block.uuid not in dynamic_block_count_by_base_uuid:\n                    dynamic_block_count_by_base_uuid[block.uuid] = 0\n                dynamic_block_count_by_base_uuid[block.uuid] += 1\n                if block.uuid not in dynamic_block_uuids_by_base_uuid:\n                    dynamic_block_uuids_by_base_uuid[block.uuid] = []\n                dynamic_block_uuids_by_base_uuid[block.uuid].append(block_run_block_uuid)\n                parts = block_run_block_uuid.split(':')\n                parts_length = len(parts)\n                if parts_length >= 2:\n                    block_dict['description'] = ':'.join(parts[1:])\n                    e_i = parts_length - 1\n                    parts_new = parts[1:e_i]\n                    for upstream_block in block.upstream_blocks:\n                        if is_dynamic_block_child(upstream_block):\n                            parts_new = [upstream_block.uuid] + parts_new\n                            block_mapping[block_run_block_uuid]['uuids'].append(':'.join(parts_new))\n                if should_reduce_output(block):\n                    for db in block.downstream_blocks:\n                        if db.uuid not in block_mapping:\n                            block_mapping[db.uuid] = dict(uuids=[])\n                        block_mapping[db.uuid]['uuids'].append(block_run_block_uuid)\n                else:\n                    for db in block.downstream_blocks:\n                        db_uuid = ':'.join([db.uuid] + parts[1:])\n                        if db_uuid not in block_mapping:\n                            block_mapping[db_uuid] = dict(uuids=[])\n                        block_mapping[db_uuid]['uuids'].append(block_run_block_uuid)\n            if block.replicated_block:\n                block_dict['name'] = block.uuid\n                block_dict['description'] = block.replicated_block\n            block_dict['tags'] += block.tags()\n            block_dicts_by_uuid[block_run_block_uuid] = block_dict\n        for (block_uuid, block_dict) in block_dicts_by_uuid.items():\n            for key in ['downstream_blocks', 'upstream_blocks']:\n                arr = block_dict.get(key) or []\n                for block_uuid_base in arr:\n                    block = pipeline.get_block(block_uuid_base)\n                    if block is None:\n                        continue\n                    if block.replicated_block and (not is_dynamic_block_child(block)):\n                        blocks_arr = block_dicts_by_uuid[block_uuid].get(key) or []\n                        block_dicts_by_uuid[block_uuid][key] = [uuid for uuid in blocks_arr if uuid != block_uuid_base]\n                        block_dicts_by_uuid[block_uuid][key].append(block.uuid_replicated)\n        blocks_to_not_override = {}\n        for (original_block_uuid, set_dict) in data_integration_sets_by_uuid.items():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            controllers_not_parallel = list(filter(lambda x: not (x.get('metrics') or {}).get('run_in_parallel'), controllers.values()))\n            controller_child_end = find(lambda x: not (x.get('metrics') or {}).get('downstream_block_uuids'), controllers_not_parallel)\n\n            def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n                uuid = controller_child.get('uuid')\n                metrics = controller_child.get('metrics') or {}\n                upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n                for up_block_uuid in upstream_block_uuids:\n                    arr = children_inner.get(up_block_uuid) or []\n                    block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n                    blocks_to_not_override[uuid] = True\n                    for d_child in arr:\n                        child_uuid = d_child['uuid']\n                        block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n                        block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n                        blocks_to_not_override[child_uuid] = True\n                    up_controller = controllers_inner.get(up_block_uuid)\n                    if up_controller:\n                        _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)\n            if controller_child_end:\n                _update_upstream_block_uuids(controller_child_end, controllers, children)\n                controller_child_end_uuid = controller_child_end.get('uuid')\n                children_end = children.get(controller_child_end_uuid) or []\n                block_dicts_by_uuid[original_block_uuid]['upstream_blocks'] = [d['uuid'] for d in children_end]\n                blocks_to_not_override[original_block_uuid] = True\n                downstream_blocks = block_dicts_by_uuid[original_block_uuid].get('downstream_blocks') or []\n                for down_uuid in downstream_blocks:\n                    blocks_to_not_override[down_uuid] = True\n                for up_uuid in block_dicts_by_uuid[original_block_uuid]['upstream_blocks']:\n                    block_dicts_by_uuid[up_uuid]['upstream_blocks'] = [controller_child_end_uuid]\n                    block_dicts_by_uuid[up_uuid]['downstream_blocks'] = [original_block_uuid]\n                    blocks_to_not_override[up_uuid] = True\n            controller_child_start = find(lambda x: not (x.get('metrics') or {}).get('upstream_block_uuids'), controllers_not_parallel)\n            if controller_child_start:\n                controller_child_start_uuid = controller_child_start['uuid']\n                block_dicts_by_uuid[controller_child_start_uuid]['upstream_blocks'] = [controller.get('uuid')]\n                blocks_to_not_override[controller_child_start_uuid] = True\n        for (block_uuid, mapping) in block_mapping.items():\n            block = pipeline.get_block(block_uuid)\n            if not block:\n                continue\n            if block_uuid not in block_dicts_by_uuid:\n                continue\n            block_run = mapping.get('block_run')\n            metrics = block_run.metrics if block_run else None\n            upstream_block_uuids = mapping['uuids']\n            child = False\n            controller = False\n            original = False\n            is_data_integration = block.is_data_integration()\n            if metrics and is_data_integration:\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                original = metrics.get('original')\n            if original or (controller and (not child)):\n                if block_uuid in sources_destinations_by_block_uuid:\n                    if 'tags' not in block_dicts_by_uuid[block_uuid]:\n                        block_dicts_by_uuid[block_uuid] = []\n                    block_dicts_by_uuid[block_uuid]['tags'].append(sources_destinations_by_block_uuid[block_uuid])\n            if block_uuid in blocks_to_not_override:\n                continue\n            if original:\n                block_dicts_by_uuid[block_uuid]['upstream_blocks'] = []\n            for ub_uuid in upstream_block_uuids:\n                if ub_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                    continue\n                if is_data_integration:\n                    if child:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [ub_uuid]\n                        continue\n                    elif original:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                else:\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                ub_block = pipeline.get_block(ub_uuid)\n                if ub_block and is_dynamic_block_child(ub_block) and (ub_block.uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']):\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks'] if uuid != ub_block.uuid]\n            for up_block_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                if up_block_uuid not in block_dicts_by_uuid:\n                    continue\n                if block_uuid not in block_dicts_by_uuid[up_block_uuid]:\n                    if block_uuid not in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        block_dicts_by_uuid[up_block_uuid]['downstream_blocks'].append(block_uuid)\n                up_block = pipeline.get_block(up_block_uuid)\n                if up_block and is_dynamic_block(up_block):\n                    for db_block_uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        db_block = pipeline.get_block(db_block_uuid)\n                        if db_block and is_dynamic_block_child(db_block):\n                            block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] if uuid != db_block.uuid]\n        for set_dict in data_integration_sets_by_uuid.values():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            original = set_dict.get('original') or {}\n            for controller_uuid in [controller.get('uuid')] + list(controllers.keys()):\n                if controller_uuid in block_dicts_by_uuid:\n                    block_run = block_mapping.get(controller_uuid, {}).get('block_run')\n                    if block_run and block_run.started_at:\n                        block_dict = block_dicts_by_uuid[controller_uuid]\n                        downstream_started_ats = []\n                        for db_uuid in block_dict.get('downstream_blocks') or []:\n                            db_block_run = block_mapping.get(db_uuid, {}).get('block_run')\n                            if db_block_run and db_block_run.started_at:\n                                downstream_started_ats.append(db_block_run.started_at)\n                        if downstream_started_ats:\n                            started_at_e = max(downstream_started_ats)\n                            block_dicts_by_uuid[controller_uuid]['runtime'] = started_at_e.timestamp() - block_run.started_at.timestamp()\n        dynamic_blocks_beyond_1 = {}\n        for (base_uuid, count) in dynamic_block_count_by_base_uuid.items():\n            if count >= 2:\n                dynamic_blocks_beyond_1[base_uuid] = count\n        total_blocks = sum(list(block_count_by_base_uuid.values()))\n        total_blocks_dynamic_beyond_1 = sum(list(dynamic_blocks_beyond_1.values()))\n        if total_blocks > MAX_BLOCKS_FOR_TREE:\n            remove_this_much = total_blocks - MAX_BLOCKS_FOR_TREE\n            if total_blocks_dynamic_beyond_1 > remove_this_much:\n                keep_this_much = total_blocks_dynamic_beyond_1 - remove_this_much\n                percent_to_keep = keep_this_much / total_blocks_dynamic_beyond_1\n                for (base_uuid, count) in dynamic_blocks_beyond_1.items():\n                    uuids = dynamic_block_uuids_by_base_uuid.get(base_uuid) or []\n                    keep_count = max(math.floor(percent_to_keep * count), 1)\n                    uuids_to_remove = uuids[keep_count:]\n                    for uuid in uuids_to_remove:\n                        if uuid not in block_dicts_by_uuid:\n                            continue\n                        block_dict = block_dicts_by_uuid[uuid]\n                        for (uuids_to_loop, key_to_remove_from) in [('upstream_blocks', 'downstream_blocks'), ('downstream_blocks', 'upstream_blocks')]:\n                            for uuids_inner in block_dict[uuids_to_loop]:\n                                if uuids_inner not in block_dicts_by_uuid:\n                                    continue\n                                arr = block_dicts_by_uuid[uuids_inner][key_to_remove_from]\n                                block_dicts_by_uuid[uuids_inner][key_to_remove_from] = [i for i in arr if i != uuid]\n                        block_dicts_by_uuid.pop(uuid, None)\n    return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)",
            "@classmethod\n@safe_db_query\ndef collection(self, query_arg, meta, user, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parent_model = kwargs.get('parent_model')\n    block_count_by_base_uuid = {}\n    block_dicts_by_uuid = {}\n    data_integration_sets_by_uuid = {}\n    dynamic_block_count_by_base_uuid = {}\n    dynamic_block_uuids_by_base_uuid = {}\n    sources_destinations_by_block_uuid = {}\n    if isinstance(parent_model, Pipeline):\n        for (block_uuid, block) in parent_model.blocks_by_uuid.items():\n            block_dicts_by_uuid[block_uuid] = block.to_dict()\n    if isinstance(parent_model, PipelineRun):\n        block_mapping = {}\n        pipeline = parent_model.pipeline\n        is_data_integration_pipeline = pipeline and PipelineType.INTEGRATION == pipeline.type\n        if is_data_integration_pipeline:\n            original_blocks_mapping = {}\n            for block_run in parent_model.block_runs:\n                block_run_block_uuid = block_run.block_uuid\n                block = pipeline.get_block(block_run_block_uuid)\n                if not block:\n                    continue\n                if block.uuid not in original_blocks_mapping:\n                    original_blocks_mapping[block.uuid] = {}\n                block_dict = block.to_dict()\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n                original_blocks_mapping[block.uuid][block_run_block_uuid] = block_dict\n            for (block_run_block_uuid, block_dict) in block_dicts_by_uuid.items():\n                block_uuid = block_dict.get('uuid')\n                block_uuid_parts = block_run_block_uuid.split(':')\n                group_parts = [part for part in block_uuid_parts if part != block_uuid]\n                group_uuid = ':'.join(group_parts)\n                for key in ['downstream_blocks', 'upstream_blocks']:\n                    uuids = []\n                    for block_uuid2 in block_dict.get(key):\n                        mapping = original_blocks_mapping.get(block_uuid2)\n                        if mapping:\n                            for uuid2 in list(mapping.keys()):\n                                if uuid2 == ':'.join([block_uuid2, group_uuid]):\n                                    uuids.append(uuid2)\n                        else:\n                            uuids.append(block_uuid2)\n                    block_dict[key] = uuids\n                if len(group_parts) >= 1:\n                    block_dict['tags'] = [group_parts[0]]\n                if len(group_parts) >= 2:\n                    block_dict['description'] = group_parts[1]\n                block_dict['name'] = block_uuid\n                block_dict['uuid'] = block_run_block_uuid\n                block_dicts_by_uuid[block_run_block_uuid] = block_dict\n            return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)\n        for block_run in parent_model.block_runs:\n            block_run_block_uuid = block_run.block_uuid\n            if block_run_block_uuid not in block_mapping:\n                block_mapping[block_run_block_uuid] = dict(block_run=block_run, uuids=[])\n            block = pipeline.get_block(block_run_block_uuid)\n            if not block:\n                continue\n            if block.uuid not in block_count_by_base_uuid:\n                block_count_by_base_uuid[block.uuid] = 0\n            block_count_by_base_uuid[block.uuid] += 1\n            block_dict = block.to_dict()\n            if 'tags' not in block_dict:\n                block_dict['tags'] = []\n            block_dict['uuid'] = block_run_block_uuid\n            metrics = block_run.metrics\n            if metrics and block.is_data_integration():\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                controller_block_uuid = metrics.get('controller_block_uuid')\n                original = metrics.get('original')\n                original_block_uuid = metrics.get('original_block_uuid')\n                tags = []\n                if original:\n                    if BlockType.DATA_LOADER == block.type:\n                        block_dict['description'] = 'Source'\n                    elif BlockType.DATA_EXPORTER == block.type:\n                        block_dict['description'] = 'Destination'\n                elif controller and (not child):\n                    block_dict['description'] = 'Controller'\n                else:\n                    block_dict['name'] = original_block_uuid\n                if child:\n                    parts = block_run_block_uuid.split(':')\n                    source_destination = None\n                    stream = None\n                    index = None\n                    if len(parts) >= 2:\n                        source_destination = parts[1]\n                        for b_uuid in [controller_block_uuid, original_block_uuid]:\n                            if b_uuid not in sources_destinations_by_block_uuid:\n                                sources_destinations_by_block_uuid[b_uuid] = []\n                            if source_destination not in sources_destinations_by_block_uuid[b_uuid]:\n                                sources_destinations_by_block_uuid[b_uuid].append(source_destination)\n                    if len(parts) >= 3:\n                        stream = parts[2]\n                    block_mapping[block_run_block_uuid]['uuids'].append(controller_block_uuid)\n                    if controller:\n                        block_dict['description'] = 'Controller'\n                    else:\n                        if len(parts) >= 4:\n                            index = str(parts[3])\n                        block_dict['description'] = index\n                        if original_block_uuid not in block_mapping:\n                            block_mapping[original_block_uuid] = dict(uuids=[])\n                        block_mapping[original_block_uuid]['uuids'].append(block_run_block_uuid)\n                    tags.append(stream)\n                if tags:\n                    block_dict['tags'] = tags\n                if original_block_uuid:\n                    if original_block_uuid not in data_integration_sets_by_uuid:\n                        data_integration_sets_by_uuid[original_block_uuid] = dict(children={}, controller=None, controllers={}, original=None)\n                    data = merge_dict(block_dict, dict(metrics=metrics))\n                    if original:\n                        data_integration_sets_by_uuid[original_block_uuid]['original'] = data\n                    elif child:\n                        if controller:\n                            data_integration_sets_by_uuid[original_block_uuid]['controllers'][block_run_block_uuid] = data\n                        elif controller_block_uuid:\n                            if controller_block_uuid not in data_integration_sets_by_uuid[original_block_uuid]['children']:\n                                data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid] = []\n                            data_integration_sets_by_uuid[original_block_uuid]['children'][controller_block_uuid].append(data)\n                    elif controller:\n                        data_integration_sets_by_uuid[original_block_uuid]['controller'] = data\n            if is_dynamic_block_child(block):\n                if block.uuid not in dynamic_block_count_by_base_uuid:\n                    dynamic_block_count_by_base_uuid[block.uuid] = 0\n                dynamic_block_count_by_base_uuid[block.uuid] += 1\n                if block.uuid not in dynamic_block_uuids_by_base_uuid:\n                    dynamic_block_uuids_by_base_uuid[block.uuid] = []\n                dynamic_block_uuids_by_base_uuid[block.uuid].append(block_run_block_uuid)\n                parts = block_run_block_uuid.split(':')\n                parts_length = len(parts)\n                if parts_length >= 2:\n                    block_dict['description'] = ':'.join(parts[1:])\n                    e_i = parts_length - 1\n                    parts_new = parts[1:e_i]\n                    for upstream_block in block.upstream_blocks:\n                        if is_dynamic_block_child(upstream_block):\n                            parts_new = [upstream_block.uuid] + parts_new\n                            block_mapping[block_run_block_uuid]['uuids'].append(':'.join(parts_new))\n                if should_reduce_output(block):\n                    for db in block.downstream_blocks:\n                        if db.uuid not in block_mapping:\n                            block_mapping[db.uuid] = dict(uuids=[])\n                        block_mapping[db.uuid]['uuids'].append(block_run_block_uuid)\n                else:\n                    for db in block.downstream_blocks:\n                        db_uuid = ':'.join([db.uuid] + parts[1:])\n                        if db_uuid not in block_mapping:\n                            block_mapping[db_uuid] = dict(uuids=[])\n                        block_mapping[db_uuid]['uuids'].append(block_run_block_uuid)\n            if block.replicated_block:\n                block_dict['name'] = block.uuid\n                block_dict['description'] = block.replicated_block\n            block_dict['tags'] += block.tags()\n            block_dicts_by_uuid[block_run_block_uuid] = block_dict\n        for (block_uuid, block_dict) in block_dicts_by_uuid.items():\n            for key in ['downstream_blocks', 'upstream_blocks']:\n                arr = block_dict.get(key) or []\n                for block_uuid_base in arr:\n                    block = pipeline.get_block(block_uuid_base)\n                    if block is None:\n                        continue\n                    if block.replicated_block and (not is_dynamic_block_child(block)):\n                        blocks_arr = block_dicts_by_uuid[block_uuid].get(key) or []\n                        block_dicts_by_uuid[block_uuid][key] = [uuid for uuid in blocks_arr if uuid != block_uuid_base]\n                        block_dicts_by_uuid[block_uuid][key].append(block.uuid_replicated)\n        blocks_to_not_override = {}\n        for (original_block_uuid, set_dict) in data_integration_sets_by_uuid.items():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            controllers_not_parallel = list(filter(lambda x: not (x.get('metrics') or {}).get('run_in_parallel'), controllers.values()))\n            controller_child_end = find(lambda x: not (x.get('metrics') or {}).get('downstream_block_uuids'), controllers_not_parallel)\n\n            def _update_upstream_block_uuids(controller_child: Dict, controllers_inner, children_inner):\n                uuid = controller_child.get('uuid')\n                metrics = controller_child.get('metrics') or {}\n                upstream_block_uuids = metrics.get('upstream_block_uuids') or []\n                for up_block_uuid in upstream_block_uuids:\n                    arr = children_inner.get(up_block_uuid) or []\n                    block_dicts_by_uuid[uuid]['upstream_blocks'] = [d['uuid'] for d in arr]\n                    blocks_to_not_override[uuid] = True\n                    for d_child in arr:\n                        child_uuid = d_child['uuid']\n                        block_dicts_by_uuid[child_uuid]['upstream_blocks'] = [up_block_uuid]\n                        block_dicts_by_uuid[child_uuid]['downstream_blocks'] = [uuid]\n                        blocks_to_not_override[child_uuid] = True\n                    up_controller = controllers_inner.get(up_block_uuid)\n                    if up_controller:\n                        _update_upstream_block_uuids(up_controller, controllers_inner, children_inner)\n            if controller_child_end:\n                _update_upstream_block_uuids(controller_child_end, controllers, children)\n                controller_child_end_uuid = controller_child_end.get('uuid')\n                children_end = children.get(controller_child_end_uuid) or []\n                block_dicts_by_uuid[original_block_uuid]['upstream_blocks'] = [d['uuid'] for d in children_end]\n                blocks_to_not_override[original_block_uuid] = True\n                downstream_blocks = block_dicts_by_uuid[original_block_uuid].get('downstream_blocks') or []\n                for down_uuid in downstream_blocks:\n                    blocks_to_not_override[down_uuid] = True\n                for up_uuid in block_dicts_by_uuid[original_block_uuid]['upstream_blocks']:\n                    block_dicts_by_uuid[up_uuid]['upstream_blocks'] = [controller_child_end_uuid]\n                    block_dicts_by_uuid[up_uuid]['downstream_blocks'] = [original_block_uuid]\n                    blocks_to_not_override[up_uuid] = True\n            controller_child_start = find(lambda x: not (x.get('metrics') or {}).get('upstream_block_uuids'), controllers_not_parallel)\n            if controller_child_start:\n                controller_child_start_uuid = controller_child_start['uuid']\n                block_dicts_by_uuid[controller_child_start_uuid]['upstream_blocks'] = [controller.get('uuid')]\n                blocks_to_not_override[controller_child_start_uuid] = True\n        for (block_uuid, mapping) in block_mapping.items():\n            block = pipeline.get_block(block_uuid)\n            if not block:\n                continue\n            if block_uuid not in block_dicts_by_uuid:\n                continue\n            block_run = mapping.get('block_run')\n            metrics = block_run.metrics if block_run else None\n            upstream_block_uuids = mapping['uuids']\n            child = False\n            controller = False\n            original = False\n            is_data_integration = block.is_data_integration()\n            if metrics and is_data_integration:\n                child = metrics.get('child')\n                controller = metrics.get('controller')\n                original = metrics.get('original')\n            if original or (controller and (not child)):\n                if block_uuid in sources_destinations_by_block_uuid:\n                    if 'tags' not in block_dicts_by_uuid[block_uuid]:\n                        block_dicts_by_uuid[block_uuid] = []\n                    block_dicts_by_uuid[block_uuid]['tags'].append(sources_destinations_by_block_uuid[block_uuid])\n            if block_uuid in blocks_to_not_override:\n                continue\n            if original:\n                block_dicts_by_uuid[block_uuid]['upstream_blocks'] = []\n            for ub_uuid in upstream_block_uuids:\n                if ub_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                    continue\n                if is_data_integration:\n                    if child:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [ub_uuid]\n                        continue\n                    elif original:\n                        block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                else:\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'].append(ub_uuid)\n                ub_block = pipeline.get_block(ub_uuid)\n                if ub_block and is_dynamic_block_child(ub_block) and (ub_block.uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']):\n                    block_dicts_by_uuid[block_uuid]['upstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks'] if uuid != ub_block.uuid]\n            for up_block_uuid in block_dicts_by_uuid[block_uuid]['upstream_blocks']:\n                if up_block_uuid not in block_dicts_by_uuid:\n                    continue\n                if block_uuid not in block_dicts_by_uuid[up_block_uuid]:\n                    if block_uuid not in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        block_dicts_by_uuid[up_block_uuid]['downstream_blocks'].append(block_uuid)\n                up_block = pipeline.get_block(up_block_uuid)\n                if up_block and is_dynamic_block(up_block):\n                    for db_block_uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks']:\n                        db_block = pipeline.get_block(db_block_uuid)\n                        if db_block and is_dynamic_block_child(db_block):\n                            block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] = [uuid for uuid in block_dicts_by_uuid[up_block_uuid]['downstream_blocks'] if uuid != db_block.uuid]\n        for set_dict in data_integration_sets_by_uuid.values():\n            children = set_dict.get('children') or {}\n            controller = set_dict.get('controller') or {}\n            controllers = set_dict.get('controllers') or {}\n            original = set_dict.get('original') or {}\n            for controller_uuid in [controller.get('uuid')] + list(controllers.keys()):\n                if controller_uuid in block_dicts_by_uuid:\n                    block_run = block_mapping.get(controller_uuid, {}).get('block_run')\n                    if block_run and block_run.started_at:\n                        block_dict = block_dicts_by_uuid[controller_uuid]\n                        downstream_started_ats = []\n                        for db_uuid in block_dict.get('downstream_blocks') or []:\n                            db_block_run = block_mapping.get(db_uuid, {}).get('block_run')\n                            if db_block_run and db_block_run.started_at:\n                                downstream_started_ats.append(db_block_run.started_at)\n                        if downstream_started_ats:\n                            started_at_e = max(downstream_started_ats)\n                            block_dicts_by_uuid[controller_uuid]['runtime'] = started_at_e.timestamp() - block_run.started_at.timestamp()\n        dynamic_blocks_beyond_1 = {}\n        for (base_uuid, count) in dynamic_block_count_by_base_uuid.items():\n            if count >= 2:\n                dynamic_blocks_beyond_1[base_uuid] = count\n        total_blocks = sum(list(block_count_by_base_uuid.values()))\n        total_blocks_dynamic_beyond_1 = sum(list(dynamic_blocks_beyond_1.values()))\n        if total_blocks > MAX_BLOCKS_FOR_TREE:\n            remove_this_much = total_blocks - MAX_BLOCKS_FOR_TREE\n            if total_blocks_dynamic_beyond_1 > remove_this_much:\n                keep_this_much = total_blocks_dynamic_beyond_1 - remove_this_much\n                percent_to_keep = keep_this_much / total_blocks_dynamic_beyond_1\n                for (base_uuid, count) in dynamic_blocks_beyond_1.items():\n                    uuids = dynamic_block_uuids_by_base_uuid.get(base_uuid) or []\n                    keep_count = max(math.floor(percent_to_keep * count), 1)\n                    uuids_to_remove = uuids[keep_count:]\n                    for uuid in uuids_to_remove:\n                        if uuid not in block_dicts_by_uuid:\n                            continue\n                        block_dict = block_dicts_by_uuid[uuid]\n                        for (uuids_to_loop, key_to_remove_from) in [('upstream_blocks', 'downstream_blocks'), ('downstream_blocks', 'upstream_blocks')]:\n                            for uuids_inner in block_dict[uuids_to_loop]:\n                                if uuids_inner not in block_dicts_by_uuid:\n                                    continue\n                                arr = block_dicts_by_uuid[uuids_inner][key_to_remove_from]\n                                block_dicts_by_uuid[uuids_inner][key_to_remove_from] = [i for i in arr if i != uuid]\n                        block_dicts_by_uuid.pop(uuid, None)\n    return self.build_result_set(block_dicts_by_uuid.values(), user, **kwargs)"
        ]
    },
    {
        "func_name": "member",
        "original": "@classmethod\n@safe_db_query\ndef member(self, pk, user, **kwargs):\n    error = ApiError.RESOURCE_INVALID.copy()\n    query = kwargs.get('query', {})\n    extension_uuid = query.get('extension_uuid', [None])\n    if extension_uuid:\n        extension_uuid = extension_uuid[0]\n    block_type = query.get('block_type', [None])\n    if block_type:\n        block_type = block_type[0]\n    pipeline = kwargs.get('parent_model')\n    if pipeline:\n        block = pipeline.get_block(pk, block_type=block_type, extension_uuid=extension_uuid)\n        if block:\n            return self(block, user, **kwargs)\n        else:\n            if extension_uuid:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid} for extension {extension_uuid}.'\n            else:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid}.'\n            error.update(message=message)\n            raise ApiError(error)\n    block_type_and_uuid = urllib.parse.unquote(pk)\n    parts = block_type_and_uuid.split('/')\n    if len(parts) < 2:\n        error.update(message='The url path should be in block_type/block_uuid format.')\n        raise ApiError(error)\n    block_type = parts[0]\n    block_uuid_with_extension = '/'.join(parts[1:])\n    parts2 = block_uuid_with_extension.split('.')\n    language = None\n    if len(parts2) >= 2:\n        block_uuid = '.'.join(parts2[:-1])\n        language = FILE_EXTENSION_TO_BLOCK_LANGUAGE[parts2[-1]]\n    else:\n        block_uuid = block_uuid_with_extension\n    block_language = query.get('block_language', [None])\n    if block_language:\n        block_language = block_language[0]\n    if block_language:\n        language = block_language\n    if BlockType.DBT == block_type:\n        from mage_ai.data_preparation.models.block.dbt import DBTBlock\n        block = DBTBlock(block_uuid, block_uuid, block_type, configuration=dict(file_path=block_uuid_with_extension), language=language)\n    else:\n        block = Block.get_block(block_uuid, block_uuid, block_type, language=language)\n    if not block.exists():\n        error.update(ApiError.RESOURCE_NOT_FOUND)\n        raise ApiError(error)\n    return self(block, user, **kwargs)",
        "mutated": [
            "@classmethod\n@safe_db_query\ndef member(self, pk, user, **kwargs):\n    if False:\n        i = 10\n    error = ApiError.RESOURCE_INVALID.copy()\n    query = kwargs.get('query', {})\n    extension_uuid = query.get('extension_uuid', [None])\n    if extension_uuid:\n        extension_uuid = extension_uuid[0]\n    block_type = query.get('block_type', [None])\n    if block_type:\n        block_type = block_type[0]\n    pipeline = kwargs.get('parent_model')\n    if pipeline:\n        block = pipeline.get_block(pk, block_type=block_type, extension_uuid=extension_uuid)\n        if block:\n            return self(block, user, **kwargs)\n        else:\n            if extension_uuid:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid} for extension {extension_uuid}.'\n            else:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid}.'\n            error.update(message=message)\n            raise ApiError(error)\n    block_type_and_uuid = urllib.parse.unquote(pk)\n    parts = block_type_and_uuid.split('/')\n    if len(parts) < 2:\n        error.update(message='The url path should be in block_type/block_uuid format.')\n        raise ApiError(error)\n    block_type = parts[0]\n    block_uuid_with_extension = '/'.join(parts[1:])\n    parts2 = block_uuid_with_extension.split('.')\n    language = None\n    if len(parts2) >= 2:\n        block_uuid = '.'.join(parts2[:-1])\n        language = FILE_EXTENSION_TO_BLOCK_LANGUAGE[parts2[-1]]\n    else:\n        block_uuid = block_uuid_with_extension\n    block_language = query.get('block_language', [None])\n    if block_language:\n        block_language = block_language[0]\n    if block_language:\n        language = block_language\n    if BlockType.DBT == block_type:\n        from mage_ai.data_preparation.models.block.dbt import DBTBlock\n        block = DBTBlock(block_uuid, block_uuid, block_type, configuration=dict(file_path=block_uuid_with_extension), language=language)\n    else:\n        block = Block.get_block(block_uuid, block_uuid, block_type, language=language)\n    if not block.exists():\n        error.update(ApiError.RESOURCE_NOT_FOUND)\n        raise ApiError(error)\n    return self(block, user, **kwargs)",
            "@classmethod\n@safe_db_query\ndef member(self, pk, user, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    error = ApiError.RESOURCE_INVALID.copy()\n    query = kwargs.get('query', {})\n    extension_uuid = query.get('extension_uuid', [None])\n    if extension_uuid:\n        extension_uuid = extension_uuid[0]\n    block_type = query.get('block_type', [None])\n    if block_type:\n        block_type = block_type[0]\n    pipeline = kwargs.get('parent_model')\n    if pipeline:\n        block = pipeline.get_block(pk, block_type=block_type, extension_uuid=extension_uuid)\n        if block:\n            return self(block, user, **kwargs)\n        else:\n            if extension_uuid:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid} for extension {extension_uuid}.'\n            else:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid}.'\n            error.update(message=message)\n            raise ApiError(error)\n    block_type_and_uuid = urllib.parse.unquote(pk)\n    parts = block_type_and_uuid.split('/')\n    if len(parts) < 2:\n        error.update(message='The url path should be in block_type/block_uuid format.')\n        raise ApiError(error)\n    block_type = parts[0]\n    block_uuid_with_extension = '/'.join(parts[1:])\n    parts2 = block_uuid_with_extension.split('.')\n    language = None\n    if len(parts2) >= 2:\n        block_uuid = '.'.join(parts2[:-1])\n        language = FILE_EXTENSION_TO_BLOCK_LANGUAGE[parts2[-1]]\n    else:\n        block_uuid = block_uuid_with_extension\n    block_language = query.get('block_language', [None])\n    if block_language:\n        block_language = block_language[0]\n    if block_language:\n        language = block_language\n    if BlockType.DBT == block_type:\n        from mage_ai.data_preparation.models.block.dbt import DBTBlock\n        block = DBTBlock(block_uuid, block_uuid, block_type, configuration=dict(file_path=block_uuid_with_extension), language=language)\n    else:\n        block = Block.get_block(block_uuid, block_uuid, block_type, language=language)\n    if not block.exists():\n        error.update(ApiError.RESOURCE_NOT_FOUND)\n        raise ApiError(error)\n    return self(block, user, **kwargs)",
            "@classmethod\n@safe_db_query\ndef member(self, pk, user, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    error = ApiError.RESOURCE_INVALID.copy()\n    query = kwargs.get('query', {})\n    extension_uuid = query.get('extension_uuid', [None])\n    if extension_uuid:\n        extension_uuid = extension_uuid[0]\n    block_type = query.get('block_type', [None])\n    if block_type:\n        block_type = block_type[0]\n    pipeline = kwargs.get('parent_model')\n    if pipeline:\n        block = pipeline.get_block(pk, block_type=block_type, extension_uuid=extension_uuid)\n        if block:\n            return self(block, user, **kwargs)\n        else:\n            if extension_uuid:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid} for extension {extension_uuid}.'\n            else:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid}.'\n            error.update(message=message)\n            raise ApiError(error)\n    block_type_and_uuid = urllib.parse.unquote(pk)\n    parts = block_type_and_uuid.split('/')\n    if len(parts) < 2:\n        error.update(message='The url path should be in block_type/block_uuid format.')\n        raise ApiError(error)\n    block_type = parts[0]\n    block_uuid_with_extension = '/'.join(parts[1:])\n    parts2 = block_uuid_with_extension.split('.')\n    language = None\n    if len(parts2) >= 2:\n        block_uuid = '.'.join(parts2[:-1])\n        language = FILE_EXTENSION_TO_BLOCK_LANGUAGE[parts2[-1]]\n    else:\n        block_uuid = block_uuid_with_extension\n    block_language = query.get('block_language', [None])\n    if block_language:\n        block_language = block_language[0]\n    if block_language:\n        language = block_language\n    if BlockType.DBT == block_type:\n        from mage_ai.data_preparation.models.block.dbt import DBTBlock\n        block = DBTBlock(block_uuid, block_uuid, block_type, configuration=dict(file_path=block_uuid_with_extension), language=language)\n    else:\n        block = Block.get_block(block_uuid, block_uuid, block_type, language=language)\n    if not block.exists():\n        error.update(ApiError.RESOURCE_NOT_FOUND)\n        raise ApiError(error)\n    return self(block, user, **kwargs)",
            "@classmethod\n@safe_db_query\ndef member(self, pk, user, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    error = ApiError.RESOURCE_INVALID.copy()\n    query = kwargs.get('query', {})\n    extension_uuid = query.get('extension_uuid', [None])\n    if extension_uuid:\n        extension_uuid = extension_uuid[0]\n    block_type = query.get('block_type', [None])\n    if block_type:\n        block_type = block_type[0]\n    pipeline = kwargs.get('parent_model')\n    if pipeline:\n        block = pipeline.get_block(pk, block_type=block_type, extension_uuid=extension_uuid)\n        if block:\n            return self(block, user, **kwargs)\n        else:\n            if extension_uuid:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid} for extension {extension_uuid}.'\n            else:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid}.'\n            error.update(message=message)\n            raise ApiError(error)\n    block_type_and_uuid = urllib.parse.unquote(pk)\n    parts = block_type_and_uuid.split('/')\n    if len(parts) < 2:\n        error.update(message='The url path should be in block_type/block_uuid format.')\n        raise ApiError(error)\n    block_type = parts[0]\n    block_uuid_with_extension = '/'.join(parts[1:])\n    parts2 = block_uuid_with_extension.split('.')\n    language = None\n    if len(parts2) >= 2:\n        block_uuid = '.'.join(parts2[:-1])\n        language = FILE_EXTENSION_TO_BLOCK_LANGUAGE[parts2[-1]]\n    else:\n        block_uuid = block_uuid_with_extension\n    block_language = query.get('block_language', [None])\n    if block_language:\n        block_language = block_language[0]\n    if block_language:\n        language = block_language\n    if BlockType.DBT == block_type:\n        from mage_ai.data_preparation.models.block.dbt import DBTBlock\n        block = DBTBlock(block_uuid, block_uuid, block_type, configuration=dict(file_path=block_uuid_with_extension), language=language)\n    else:\n        block = Block.get_block(block_uuid, block_uuid, block_type, language=language)\n    if not block.exists():\n        error.update(ApiError.RESOURCE_NOT_FOUND)\n        raise ApiError(error)\n    return self(block, user, **kwargs)",
            "@classmethod\n@safe_db_query\ndef member(self, pk, user, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    error = ApiError.RESOURCE_INVALID.copy()\n    query = kwargs.get('query', {})\n    extension_uuid = query.get('extension_uuid', [None])\n    if extension_uuid:\n        extension_uuid = extension_uuid[0]\n    block_type = query.get('block_type', [None])\n    if block_type:\n        block_type = block_type[0]\n    pipeline = kwargs.get('parent_model')\n    if pipeline:\n        block = pipeline.get_block(pk, block_type=block_type, extension_uuid=extension_uuid)\n        if block:\n            return self(block, user, **kwargs)\n        else:\n            if extension_uuid:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid} for extension {extension_uuid}.'\n            else:\n                message = f'Block {pk} does not exist in pipeline {pipeline.uuid}.'\n            error.update(message=message)\n            raise ApiError(error)\n    block_type_and_uuid = urllib.parse.unquote(pk)\n    parts = block_type_and_uuid.split('/')\n    if len(parts) < 2:\n        error.update(message='The url path should be in block_type/block_uuid format.')\n        raise ApiError(error)\n    block_type = parts[0]\n    block_uuid_with_extension = '/'.join(parts[1:])\n    parts2 = block_uuid_with_extension.split('.')\n    language = None\n    if len(parts2) >= 2:\n        block_uuid = '.'.join(parts2[:-1])\n        language = FILE_EXTENSION_TO_BLOCK_LANGUAGE[parts2[-1]]\n    else:\n        block_uuid = block_uuid_with_extension\n    block_language = query.get('block_language', [None])\n    if block_language:\n        block_language = block_language[0]\n    if block_language:\n        language = block_language\n    if BlockType.DBT == block_type:\n        from mage_ai.data_preparation.models.block.dbt import DBTBlock\n        block = DBTBlock(block_uuid, block_uuid, block_type, configuration=dict(file_path=block_uuid_with_extension), language=language)\n    else:\n        block = Block.get_block(block_uuid, block_uuid, block_type, language=language)\n    if not block.exists():\n        error.update(ApiError.RESOURCE_NOT_FOUND)\n        raise ApiError(error)\n    return self(block, user, **kwargs)"
        ]
    }
]