[
    {
        "func_name": "market_implied_prior_returns",
        "original": "def market_implied_prior_returns(market_caps, risk_aversion, cov_matrix, risk_free_rate=0.02):\n    \"\"\"\n    Compute the prior estimate of returns implied by the market weights.\n    In other words, given each asset's contribution to the risk of the market\n    portfolio, how much are we expecting to be compensated?\n\n    .. math::\n\n        \\\\Pi = \\\\delta \\\\Sigma w_{mkt}\n\n    :param market_caps: market capitalisations of all assets\n    :type market_caps: {ticker: cap} dict or pd.Series\n    :param risk_aversion: risk aversion parameter\n    :type risk_aversion: positive float\n    :param cov_matrix: covariance matrix of asset returns\n    :type cov_matrix: pd.DataFrame\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\n                           You should use the appropriate time period, corresponding\n                           to the covariance matrix.\n    :type risk_free_rate: float, optional\n    :return: prior estimate of returns as implied by the market caps\n    :rtype: pd.Series\n    \"\"\"\n    if not isinstance(cov_matrix, pd.DataFrame):\n        warnings.warn('If cov_matrix is not a dataframe, market cap index must be aligned to cov_matrix', RuntimeWarning)\n    mcaps = pd.Series(market_caps)\n    mkt_weights = mcaps / mcaps.sum()\n    return risk_aversion * cov_matrix.dot(mkt_weights) + risk_free_rate",
        "mutated": [
            "def market_implied_prior_returns(market_caps, risk_aversion, cov_matrix, risk_free_rate=0.02):\n    if False:\n        i = 10\n    \"\\n    Compute the prior estimate of returns implied by the market weights.\\n    In other words, given each asset's contribution to the risk of the market\\n    portfolio, how much are we expecting to be compensated?\\n\\n    .. math::\\n\\n        \\\\Pi = \\\\delta \\\\Sigma w_{mkt}\\n\\n    :param market_caps: market capitalisations of all assets\\n    :type market_caps: {ticker: cap} dict or pd.Series\\n    :param risk_aversion: risk aversion parameter\\n    :type risk_aversion: positive float\\n    :param cov_matrix: covariance matrix of asset returns\\n    :type cov_matrix: pd.DataFrame\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           You should use the appropriate time period, corresponding\\n                           to the covariance matrix.\\n    :type risk_free_rate: float, optional\\n    :return: prior estimate of returns as implied by the market caps\\n    :rtype: pd.Series\\n    \"\n    if not isinstance(cov_matrix, pd.DataFrame):\n        warnings.warn('If cov_matrix is not a dataframe, market cap index must be aligned to cov_matrix', RuntimeWarning)\n    mcaps = pd.Series(market_caps)\n    mkt_weights = mcaps / mcaps.sum()\n    return risk_aversion * cov_matrix.dot(mkt_weights) + risk_free_rate",
            "def market_implied_prior_returns(market_caps, risk_aversion, cov_matrix, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute the prior estimate of returns implied by the market weights.\\n    In other words, given each asset's contribution to the risk of the market\\n    portfolio, how much are we expecting to be compensated?\\n\\n    .. math::\\n\\n        \\\\Pi = \\\\delta \\\\Sigma w_{mkt}\\n\\n    :param market_caps: market capitalisations of all assets\\n    :type market_caps: {ticker: cap} dict or pd.Series\\n    :param risk_aversion: risk aversion parameter\\n    :type risk_aversion: positive float\\n    :param cov_matrix: covariance matrix of asset returns\\n    :type cov_matrix: pd.DataFrame\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           You should use the appropriate time period, corresponding\\n                           to the covariance matrix.\\n    :type risk_free_rate: float, optional\\n    :return: prior estimate of returns as implied by the market caps\\n    :rtype: pd.Series\\n    \"\n    if not isinstance(cov_matrix, pd.DataFrame):\n        warnings.warn('If cov_matrix is not a dataframe, market cap index must be aligned to cov_matrix', RuntimeWarning)\n    mcaps = pd.Series(market_caps)\n    mkt_weights = mcaps / mcaps.sum()\n    return risk_aversion * cov_matrix.dot(mkt_weights) + risk_free_rate",
            "def market_implied_prior_returns(market_caps, risk_aversion, cov_matrix, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute the prior estimate of returns implied by the market weights.\\n    In other words, given each asset's contribution to the risk of the market\\n    portfolio, how much are we expecting to be compensated?\\n\\n    .. math::\\n\\n        \\\\Pi = \\\\delta \\\\Sigma w_{mkt}\\n\\n    :param market_caps: market capitalisations of all assets\\n    :type market_caps: {ticker: cap} dict or pd.Series\\n    :param risk_aversion: risk aversion parameter\\n    :type risk_aversion: positive float\\n    :param cov_matrix: covariance matrix of asset returns\\n    :type cov_matrix: pd.DataFrame\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           You should use the appropriate time period, corresponding\\n                           to the covariance matrix.\\n    :type risk_free_rate: float, optional\\n    :return: prior estimate of returns as implied by the market caps\\n    :rtype: pd.Series\\n    \"\n    if not isinstance(cov_matrix, pd.DataFrame):\n        warnings.warn('If cov_matrix is not a dataframe, market cap index must be aligned to cov_matrix', RuntimeWarning)\n    mcaps = pd.Series(market_caps)\n    mkt_weights = mcaps / mcaps.sum()\n    return risk_aversion * cov_matrix.dot(mkt_weights) + risk_free_rate",
            "def market_implied_prior_returns(market_caps, risk_aversion, cov_matrix, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute the prior estimate of returns implied by the market weights.\\n    In other words, given each asset's contribution to the risk of the market\\n    portfolio, how much are we expecting to be compensated?\\n\\n    .. math::\\n\\n        \\\\Pi = \\\\delta \\\\Sigma w_{mkt}\\n\\n    :param market_caps: market capitalisations of all assets\\n    :type market_caps: {ticker: cap} dict or pd.Series\\n    :param risk_aversion: risk aversion parameter\\n    :type risk_aversion: positive float\\n    :param cov_matrix: covariance matrix of asset returns\\n    :type cov_matrix: pd.DataFrame\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           You should use the appropriate time period, corresponding\\n                           to the covariance matrix.\\n    :type risk_free_rate: float, optional\\n    :return: prior estimate of returns as implied by the market caps\\n    :rtype: pd.Series\\n    \"\n    if not isinstance(cov_matrix, pd.DataFrame):\n        warnings.warn('If cov_matrix is not a dataframe, market cap index must be aligned to cov_matrix', RuntimeWarning)\n    mcaps = pd.Series(market_caps)\n    mkt_weights = mcaps / mcaps.sum()\n    return risk_aversion * cov_matrix.dot(mkt_weights) + risk_free_rate",
            "def market_implied_prior_returns(market_caps, risk_aversion, cov_matrix, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute the prior estimate of returns implied by the market weights.\\n    In other words, given each asset's contribution to the risk of the market\\n    portfolio, how much are we expecting to be compensated?\\n\\n    .. math::\\n\\n        \\\\Pi = \\\\delta \\\\Sigma w_{mkt}\\n\\n    :param market_caps: market capitalisations of all assets\\n    :type market_caps: {ticker: cap} dict or pd.Series\\n    :param risk_aversion: risk aversion parameter\\n    :type risk_aversion: positive float\\n    :param cov_matrix: covariance matrix of asset returns\\n    :type cov_matrix: pd.DataFrame\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           You should use the appropriate time period, corresponding\\n                           to the covariance matrix.\\n    :type risk_free_rate: float, optional\\n    :return: prior estimate of returns as implied by the market caps\\n    :rtype: pd.Series\\n    \"\n    if not isinstance(cov_matrix, pd.DataFrame):\n        warnings.warn('If cov_matrix is not a dataframe, market cap index must be aligned to cov_matrix', RuntimeWarning)\n    mcaps = pd.Series(market_caps)\n    mkt_weights = mcaps / mcaps.sum()\n    return risk_aversion * cov_matrix.dot(mkt_weights) + risk_free_rate"
        ]
    },
    {
        "func_name": "market_implied_risk_aversion",
        "original": "def market_implied_risk_aversion(market_prices, frequency=252, risk_free_rate=0.02):\n    \"\"\"\n    Calculate the market-implied risk-aversion parameter (i.e market price of risk)\n    based on market prices. For example, if the market has excess returns of 10% a year\n    with 5% variance, the risk-aversion parameter is 2, i.e you have to be compensated 2x\n    the variance.\n\n    .. math::\n\n        \\\\delta = \\\\frac{R - R_f}{\\\\sigma^2}\n\n    :param market_prices: the (daily) prices of the market portfolio, e.g SPY.\n    :type market_prices: pd.Series with DatetimeIndex.\n    :param frequency: number of time periods in a year, defaults to 252 (the number\n                      of trading days in a year)\n    :type frequency: int, optional\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\n                            The period of the risk-free rate should correspond to the\n                            frequency of expected returns.\n    :type risk_free_rate: float, optional\n    :raises TypeError: if market_prices cannot be parsed\n    :return: market-implied risk aversion\n    :rtype: float\n    \"\"\"\n    if not isinstance(market_prices, (pd.Series, pd.DataFrame)):\n        raise TypeError('Please format market_prices as a pd.Series')\n    rets = market_prices.pct_change().dropna()\n    r = rets.mean() * frequency\n    var = rets.var() * frequency\n    return (r - risk_free_rate) / var",
        "mutated": [
            "def market_implied_risk_aversion(market_prices, frequency=252, risk_free_rate=0.02):\n    if False:\n        i = 10\n    '\\n    Calculate the market-implied risk-aversion parameter (i.e market price of risk)\\n    based on market prices. For example, if the market has excess returns of 10% a year\\n    with 5% variance, the risk-aversion parameter is 2, i.e you have to be compensated 2x\\n    the variance.\\n\\n    .. math::\\n\\n        \\\\delta = \\\\frac{R - R_f}{\\\\sigma^2}\\n\\n    :param market_prices: the (daily) prices of the market portfolio, e.g SPY.\\n    :type market_prices: pd.Series with DatetimeIndex.\\n    :param frequency: number of time periods in a year, defaults to 252 (the number\\n                      of trading days in a year)\\n    :type frequency: int, optional\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                            The period of the risk-free rate should correspond to the\\n                            frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :raises TypeError: if market_prices cannot be parsed\\n    :return: market-implied risk aversion\\n    :rtype: float\\n    '\n    if not isinstance(market_prices, (pd.Series, pd.DataFrame)):\n        raise TypeError('Please format market_prices as a pd.Series')\n    rets = market_prices.pct_change().dropna()\n    r = rets.mean() * frequency\n    var = rets.var() * frequency\n    return (r - risk_free_rate) / var",
            "def market_implied_risk_aversion(market_prices, frequency=252, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the market-implied risk-aversion parameter (i.e market price of risk)\\n    based on market prices. For example, if the market has excess returns of 10% a year\\n    with 5% variance, the risk-aversion parameter is 2, i.e you have to be compensated 2x\\n    the variance.\\n\\n    .. math::\\n\\n        \\\\delta = \\\\frac{R - R_f}{\\\\sigma^2}\\n\\n    :param market_prices: the (daily) prices of the market portfolio, e.g SPY.\\n    :type market_prices: pd.Series with DatetimeIndex.\\n    :param frequency: number of time periods in a year, defaults to 252 (the number\\n                      of trading days in a year)\\n    :type frequency: int, optional\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                            The period of the risk-free rate should correspond to the\\n                            frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :raises TypeError: if market_prices cannot be parsed\\n    :return: market-implied risk aversion\\n    :rtype: float\\n    '\n    if not isinstance(market_prices, (pd.Series, pd.DataFrame)):\n        raise TypeError('Please format market_prices as a pd.Series')\n    rets = market_prices.pct_change().dropna()\n    r = rets.mean() * frequency\n    var = rets.var() * frequency\n    return (r - risk_free_rate) / var",
            "def market_implied_risk_aversion(market_prices, frequency=252, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the market-implied risk-aversion parameter (i.e market price of risk)\\n    based on market prices. For example, if the market has excess returns of 10% a year\\n    with 5% variance, the risk-aversion parameter is 2, i.e you have to be compensated 2x\\n    the variance.\\n\\n    .. math::\\n\\n        \\\\delta = \\\\frac{R - R_f}{\\\\sigma^2}\\n\\n    :param market_prices: the (daily) prices of the market portfolio, e.g SPY.\\n    :type market_prices: pd.Series with DatetimeIndex.\\n    :param frequency: number of time periods in a year, defaults to 252 (the number\\n                      of trading days in a year)\\n    :type frequency: int, optional\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                            The period of the risk-free rate should correspond to the\\n                            frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :raises TypeError: if market_prices cannot be parsed\\n    :return: market-implied risk aversion\\n    :rtype: float\\n    '\n    if not isinstance(market_prices, (pd.Series, pd.DataFrame)):\n        raise TypeError('Please format market_prices as a pd.Series')\n    rets = market_prices.pct_change().dropna()\n    r = rets.mean() * frequency\n    var = rets.var() * frequency\n    return (r - risk_free_rate) / var",
            "def market_implied_risk_aversion(market_prices, frequency=252, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the market-implied risk-aversion parameter (i.e market price of risk)\\n    based on market prices. For example, if the market has excess returns of 10% a year\\n    with 5% variance, the risk-aversion parameter is 2, i.e you have to be compensated 2x\\n    the variance.\\n\\n    .. math::\\n\\n        \\\\delta = \\\\frac{R - R_f}{\\\\sigma^2}\\n\\n    :param market_prices: the (daily) prices of the market portfolio, e.g SPY.\\n    :type market_prices: pd.Series with DatetimeIndex.\\n    :param frequency: number of time periods in a year, defaults to 252 (the number\\n                      of trading days in a year)\\n    :type frequency: int, optional\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                            The period of the risk-free rate should correspond to the\\n                            frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :raises TypeError: if market_prices cannot be parsed\\n    :return: market-implied risk aversion\\n    :rtype: float\\n    '\n    if not isinstance(market_prices, (pd.Series, pd.DataFrame)):\n        raise TypeError('Please format market_prices as a pd.Series')\n    rets = market_prices.pct_change().dropna()\n    r = rets.mean() * frequency\n    var = rets.var() * frequency\n    return (r - risk_free_rate) / var",
            "def market_implied_risk_aversion(market_prices, frequency=252, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the market-implied risk-aversion parameter (i.e market price of risk)\\n    based on market prices. For example, if the market has excess returns of 10% a year\\n    with 5% variance, the risk-aversion parameter is 2, i.e you have to be compensated 2x\\n    the variance.\\n\\n    .. math::\\n\\n        \\\\delta = \\\\frac{R - R_f}{\\\\sigma^2}\\n\\n    :param market_prices: the (daily) prices of the market portfolio, e.g SPY.\\n    :type market_prices: pd.Series with DatetimeIndex.\\n    :param frequency: number of time periods in a year, defaults to 252 (the number\\n                      of trading days in a year)\\n    :type frequency: int, optional\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                            The period of the risk-free rate should correspond to the\\n                            frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :raises TypeError: if market_prices cannot be parsed\\n    :return: market-implied risk aversion\\n    :rtype: float\\n    '\n    if not isinstance(market_prices, (pd.Series, pd.DataFrame)):\n        raise TypeError('Please format market_prices as a pd.Series')\n    rets = market_prices.pct_change().dropna()\n    r = rets.mean() * frequency\n    var = rets.var() * frequency\n    return (r - risk_free_rate) / var"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, cov_matrix, pi=None, absolute_views=None, Q=None, P=None, omega=None, view_confidences=None, tau=0.05, risk_aversion=1, **kwargs):\n    \"\"\"\n        :param cov_matrix: NxN covariance matrix of returns\n        :type cov_matrix: pd.DataFrame or np.ndarray\n        :param pi: Nx1 prior estimate of returns, defaults to None.\n                   If pi=\"market\", calculate a market-implied prior (requires market_caps\n                   to be passed).\n                   If pi=\"equal\", use an equal-weighted prior.\n        :type pi: np.ndarray, pd.Series, optional\n        :param absolute_views: a collection of K absolute views on a subset of assets,\n                               defaults to None. If this is provided, we do not need P, Q.\n        :type absolute_views: pd.Series or dict, optional\n        :param Q: Kx1 views vector, defaults to None\n        :type Q: np.ndarray or pd.DataFrame, optional\n        :param P: KxN picking matrix, defaults to None\n        :type P: np.ndarray or pd.DataFrame, optional\n        :param omega: KxK view uncertainty matrix (diagonal), defaults to None\n                      Can instead pass \"idzorek\" to use Idzorek's method (requires\n                      you to pass view_confidences). If omega=\"default\" or None,\n                      we set the uncertainty proportional to the variance.\n        :type omega: np.ndarray or Pd.DataFrame, or string, optional\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\n                                required to compute omega via Idzorek's method.\n        :type view_confidences: np.ndarray, pd.Series, list, optional\n        :param tau: the weight-on-views scalar (default is 0.05)\n        :type tau: float, optional\n        :param risk_aversion: risk aversion parameter, defaults to 1\n        :type risk_aversion: positive float, optional\n        :param market_caps: (kwarg) market caps for the assets, required if pi=\"market\"\n        :type market_caps: np.ndarray, pd.Series, optional\n        :param risk_free_rate: (kwarg) risk_free_rate is needed in some methods\n        :type risk_free_rate: float, defaults to 0.02\n        \"\"\"\n    if sys.version_info[1] == 5:\n        warnings.warn('When using python 3.5 you must explicitly construct the Black-Litterman inputs')\n    self._raw_cov_matrix = cov_matrix\n    if isinstance(cov_matrix, np.ndarray):\n        self.cov_matrix = cov_matrix\n        super().__init__(len(cov_matrix), list(range(len(cov_matrix))))\n    else:\n        self.cov_matrix = cov_matrix.values\n        super().__init__(len(cov_matrix), cov_matrix.columns)\n    if absolute_views is not None:\n        (self.Q, self.P) = self._parse_views(absolute_views)\n    else:\n        self._set_Q_P(Q, P)\n    self._set_risk_aversion(risk_aversion)\n    self._set_pi(pi, **kwargs)\n    self._set_tau(tau)\n    self._check_attribute_dimensions()\n    self._set_omega(omega, view_confidences)\n    self._tau_sigma_P = None\n    self._A = None\n    self.posterior_rets = None\n    self.posterior_cov = None",
        "mutated": [
            "def __init__(self, cov_matrix, pi=None, absolute_views=None, Q=None, P=None, omega=None, view_confidences=None, tau=0.05, risk_aversion=1, **kwargs):\n    if False:\n        i = 10\n    '\\n        :param cov_matrix: NxN covariance matrix of returns\\n        :type cov_matrix: pd.DataFrame or np.ndarray\\n        :param pi: Nx1 prior estimate of returns, defaults to None.\\n                   If pi=\"market\", calculate a market-implied prior (requires market_caps\\n                   to be passed).\\n                   If pi=\"equal\", use an equal-weighted prior.\\n        :type pi: np.ndarray, pd.Series, optional\\n        :param absolute_views: a collection of K absolute views on a subset of assets,\\n                               defaults to None. If this is provided, we do not need P, Q.\\n        :type absolute_views: pd.Series or dict, optional\\n        :param Q: Kx1 views vector, defaults to None\\n        :type Q: np.ndarray or pd.DataFrame, optional\\n        :param P: KxN picking matrix, defaults to None\\n        :type P: np.ndarray or pd.DataFrame, optional\\n        :param omega: KxK view uncertainty matrix (diagonal), defaults to None\\n                      Can instead pass \"idzorek\" to use Idzorek\\'s method (requires\\n                      you to pass view_confidences). If omega=\"default\" or None,\\n                      we set the uncertainty proportional to the variance.\\n        :type omega: np.ndarray or Pd.DataFrame, or string, optional\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek\\'s method.\\n        :type view_confidences: np.ndarray, pd.Series, list, optional\\n        :param tau: the weight-on-views scalar (default is 0.05)\\n        :type tau: float, optional\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :param market_caps: (kwarg) market caps for the assets, required if pi=\"market\"\\n        :type market_caps: np.ndarray, pd.Series, optional\\n        :param risk_free_rate: (kwarg) risk_free_rate is needed in some methods\\n        :type risk_free_rate: float, defaults to 0.02\\n        '\n    if sys.version_info[1] == 5:\n        warnings.warn('When using python 3.5 you must explicitly construct the Black-Litterman inputs')\n    self._raw_cov_matrix = cov_matrix\n    if isinstance(cov_matrix, np.ndarray):\n        self.cov_matrix = cov_matrix\n        super().__init__(len(cov_matrix), list(range(len(cov_matrix))))\n    else:\n        self.cov_matrix = cov_matrix.values\n        super().__init__(len(cov_matrix), cov_matrix.columns)\n    if absolute_views is not None:\n        (self.Q, self.P) = self._parse_views(absolute_views)\n    else:\n        self._set_Q_P(Q, P)\n    self._set_risk_aversion(risk_aversion)\n    self._set_pi(pi, **kwargs)\n    self._set_tau(tau)\n    self._check_attribute_dimensions()\n    self._set_omega(omega, view_confidences)\n    self._tau_sigma_P = None\n    self._A = None\n    self.posterior_rets = None\n    self.posterior_cov = None",
            "def __init__(self, cov_matrix, pi=None, absolute_views=None, Q=None, P=None, omega=None, view_confidences=None, tau=0.05, risk_aversion=1, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :param cov_matrix: NxN covariance matrix of returns\\n        :type cov_matrix: pd.DataFrame or np.ndarray\\n        :param pi: Nx1 prior estimate of returns, defaults to None.\\n                   If pi=\"market\", calculate a market-implied prior (requires market_caps\\n                   to be passed).\\n                   If pi=\"equal\", use an equal-weighted prior.\\n        :type pi: np.ndarray, pd.Series, optional\\n        :param absolute_views: a collection of K absolute views on a subset of assets,\\n                               defaults to None. If this is provided, we do not need P, Q.\\n        :type absolute_views: pd.Series or dict, optional\\n        :param Q: Kx1 views vector, defaults to None\\n        :type Q: np.ndarray or pd.DataFrame, optional\\n        :param P: KxN picking matrix, defaults to None\\n        :type P: np.ndarray or pd.DataFrame, optional\\n        :param omega: KxK view uncertainty matrix (diagonal), defaults to None\\n                      Can instead pass \"idzorek\" to use Idzorek\\'s method (requires\\n                      you to pass view_confidences). If omega=\"default\" or None,\\n                      we set the uncertainty proportional to the variance.\\n        :type omega: np.ndarray or Pd.DataFrame, or string, optional\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek\\'s method.\\n        :type view_confidences: np.ndarray, pd.Series, list, optional\\n        :param tau: the weight-on-views scalar (default is 0.05)\\n        :type tau: float, optional\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :param market_caps: (kwarg) market caps for the assets, required if pi=\"market\"\\n        :type market_caps: np.ndarray, pd.Series, optional\\n        :param risk_free_rate: (kwarg) risk_free_rate is needed in some methods\\n        :type risk_free_rate: float, defaults to 0.02\\n        '\n    if sys.version_info[1] == 5:\n        warnings.warn('When using python 3.5 you must explicitly construct the Black-Litterman inputs')\n    self._raw_cov_matrix = cov_matrix\n    if isinstance(cov_matrix, np.ndarray):\n        self.cov_matrix = cov_matrix\n        super().__init__(len(cov_matrix), list(range(len(cov_matrix))))\n    else:\n        self.cov_matrix = cov_matrix.values\n        super().__init__(len(cov_matrix), cov_matrix.columns)\n    if absolute_views is not None:\n        (self.Q, self.P) = self._parse_views(absolute_views)\n    else:\n        self._set_Q_P(Q, P)\n    self._set_risk_aversion(risk_aversion)\n    self._set_pi(pi, **kwargs)\n    self._set_tau(tau)\n    self._check_attribute_dimensions()\n    self._set_omega(omega, view_confidences)\n    self._tau_sigma_P = None\n    self._A = None\n    self.posterior_rets = None\n    self.posterior_cov = None",
            "def __init__(self, cov_matrix, pi=None, absolute_views=None, Q=None, P=None, omega=None, view_confidences=None, tau=0.05, risk_aversion=1, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :param cov_matrix: NxN covariance matrix of returns\\n        :type cov_matrix: pd.DataFrame or np.ndarray\\n        :param pi: Nx1 prior estimate of returns, defaults to None.\\n                   If pi=\"market\", calculate a market-implied prior (requires market_caps\\n                   to be passed).\\n                   If pi=\"equal\", use an equal-weighted prior.\\n        :type pi: np.ndarray, pd.Series, optional\\n        :param absolute_views: a collection of K absolute views on a subset of assets,\\n                               defaults to None. If this is provided, we do not need P, Q.\\n        :type absolute_views: pd.Series or dict, optional\\n        :param Q: Kx1 views vector, defaults to None\\n        :type Q: np.ndarray or pd.DataFrame, optional\\n        :param P: KxN picking matrix, defaults to None\\n        :type P: np.ndarray or pd.DataFrame, optional\\n        :param omega: KxK view uncertainty matrix (diagonal), defaults to None\\n                      Can instead pass \"idzorek\" to use Idzorek\\'s method (requires\\n                      you to pass view_confidences). If omega=\"default\" or None,\\n                      we set the uncertainty proportional to the variance.\\n        :type omega: np.ndarray or Pd.DataFrame, or string, optional\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek\\'s method.\\n        :type view_confidences: np.ndarray, pd.Series, list, optional\\n        :param tau: the weight-on-views scalar (default is 0.05)\\n        :type tau: float, optional\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :param market_caps: (kwarg) market caps for the assets, required if pi=\"market\"\\n        :type market_caps: np.ndarray, pd.Series, optional\\n        :param risk_free_rate: (kwarg) risk_free_rate is needed in some methods\\n        :type risk_free_rate: float, defaults to 0.02\\n        '\n    if sys.version_info[1] == 5:\n        warnings.warn('When using python 3.5 you must explicitly construct the Black-Litterman inputs')\n    self._raw_cov_matrix = cov_matrix\n    if isinstance(cov_matrix, np.ndarray):\n        self.cov_matrix = cov_matrix\n        super().__init__(len(cov_matrix), list(range(len(cov_matrix))))\n    else:\n        self.cov_matrix = cov_matrix.values\n        super().__init__(len(cov_matrix), cov_matrix.columns)\n    if absolute_views is not None:\n        (self.Q, self.P) = self._parse_views(absolute_views)\n    else:\n        self._set_Q_P(Q, P)\n    self._set_risk_aversion(risk_aversion)\n    self._set_pi(pi, **kwargs)\n    self._set_tau(tau)\n    self._check_attribute_dimensions()\n    self._set_omega(omega, view_confidences)\n    self._tau_sigma_P = None\n    self._A = None\n    self.posterior_rets = None\n    self.posterior_cov = None",
            "def __init__(self, cov_matrix, pi=None, absolute_views=None, Q=None, P=None, omega=None, view_confidences=None, tau=0.05, risk_aversion=1, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :param cov_matrix: NxN covariance matrix of returns\\n        :type cov_matrix: pd.DataFrame or np.ndarray\\n        :param pi: Nx1 prior estimate of returns, defaults to None.\\n                   If pi=\"market\", calculate a market-implied prior (requires market_caps\\n                   to be passed).\\n                   If pi=\"equal\", use an equal-weighted prior.\\n        :type pi: np.ndarray, pd.Series, optional\\n        :param absolute_views: a collection of K absolute views on a subset of assets,\\n                               defaults to None. If this is provided, we do not need P, Q.\\n        :type absolute_views: pd.Series or dict, optional\\n        :param Q: Kx1 views vector, defaults to None\\n        :type Q: np.ndarray or pd.DataFrame, optional\\n        :param P: KxN picking matrix, defaults to None\\n        :type P: np.ndarray or pd.DataFrame, optional\\n        :param omega: KxK view uncertainty matrix (diagonal), defaults to None\\n                      Can instead pass \"idzorek\" to use Idzorek\\'s method (requires\\n                      you to pass view_confidences). If omega=\"default\" or None,\\n                      we set the uncertainty proportional to the variance.\\n        :type omega: np.ndarray or Pd.DataFrame, or string, optional\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek\\'s method.\\n        :type view_confidences: np.ndarray, pd.Series, list, optional\\n        :param tau: the weight-on-views scalar (default is 0.05)\\n        :type tau: float, optional\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :param market_caps: (kwarg) market caps for the assets, required if pi=\"market\"\\n        :type market_caps: np.ndarray, pd.Series, optional\\n        :param risk_free_rate: (kwarg) risk_free_rate is needed in some methods\\n        :type risk_free_rate: float, defaults to 0.02\\n        '\n    if sys.version_info[1] == 5:\n        warnings.warn('When using python 3.5 you must explicitly construct the Black-Litterman inputs')\n    self._raw_cov_matrix = cov_matrix\n    if isinstance(cov_matrix, np.ndarray):\n        self.cov_matrix = cov_matrix\n        super().__init__(len(cov_matrix), list(range(len(cov_matrix))))\n    else:\n        self.cov_matrix = cov_matrix.values\n        super().__init__(len(cov_matrix), cov_matrix.columns)\n    if absolute_views is not None:\n        (self.Q, self.P) = self._parse_views(absolute_views)\n    else:\n        self._set_Q_P(Q, P)\n    self._set_risk_aversion(risk_aversion)\n    self._set_pi(pi, **kwargs)\n    self._set_tau(tau)\n    self._check_attribute_dimensions()\n    self._set_omega(omega, view_confidences)\n    self._tau_sigma_P = None\n    self._A = None\n    self.posterior_rets = None\n    self.posterior_cov = None",
            "def __init__(self, cov_matrix, pi=None, absolute_views=None, Q=None, P=None, omega=None, view_confidences=None, tau=0.05, risk_aversion=1, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :param cov_matrix: NxN covariance matrix of returns\\n        :type cov_matrix: pd.DataFrame or np.ndarray\\n        :param pi: Nx1 prior estimate of returns, defaults to None.\\n                   If pi=\"market\", calculate a market-implied prior (requires market_caps\\n                   to be passed).\\n                   If pi=\"equal\", use an equal-weighted prior.\\n        :type pi: np.ndarray, pd.Series, optional\\n        :param absolute_views: a collection of K absolute views on a subset of assets,\\n                               defaults to None. If this is provided, we do not need P, Q.\\n        :type absolute_views: pd.Series or dict, optional\\n        :param Q: Kx1 views vector, defaults to None\\n        :type Q: np.ndarray or pd.DataFrame, optional\\n        :param P: KxN picking matrix, defaults to None\\n        :type P: np.ndarray or pd.DataFrame, optional\\n        :param omega: KxK view uncertainty matrix (diagonal), defaults to None\\n                      Can instead pass \"idzorek\" to use Idzorek\\'s method (requires\\n                      you to pass view_confidences). If omega=\"default\" or None,\\n                      we set the uncertainty proportional to the variance.\\n        :type omega: np.ndarray or Pd.DataFrame, or string, optional\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek\\'s method.\\n        :type view_confidences: np.ndarray, pd.Series, list, optional\\n        :param tau: the weight-on-views scalar (default is 0.05)\\n        :type tau: float, optional\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :param market_caps: (kwarg) market caps for the assets, required if pi=\"market\"\\n        :type market_caps: np.ndarray, pd.Series, optional\\n        :param risk_free_rate: (kwarg) risk_free_rate is needed in some methods\\n        :type risk_free_rate: float, defaults to 0.02\\n        '\n    if sys.version_info[1] == 5:\n        warnings.warn('When using python 3.5 you must explicitly construct the Black-Litterman inputs')\n    self._raw_cov_matrix = cov_matrix\n    if isinstance(cov_matrix, np.ndarray):\n        self.cov_matrix = cov_matrix\n        super().__init__(len(cov_matrix), list(range(len(cov_matrix))))\n    else:\n        self.cov_matrix = cov_matrix.values\n        super().__init__(len(cov_matrix), cov_matrix.columns)\n    if absolute_views is not None:\n        (self.Q, self.P) = self._parse_views(absolute_views)\n    else:\n        self._set_Q_P(Q, P)\n    self._set_risk_aversion(risk_aversion)\n    self._set_pi(pi, **kwargs)\n    self._set_tau(tau)\n    self._check_attribute_dimensions()\n    self._set_omega(omega, view_confidences)\n    self._tau_sigma_P = None\n    self._A = None\n    self.posterior_rets = None\n    self.posterior_cov = None"
        ]
    },
    {
        "func_name": "_parse_views",
        "original": "def _parse_views(self, absolute_views):\n    \"\"\"\n        Given a collection (dict or series) of absolute views, construct\n        the appropriate views vector and picking matrix. The views must\n        be a subset of the tickers in the covariance matrix.\n\n        {\"AAPL\": 0.20, \"GOOG\": 0.12, \"XOM\": -0.30}\n\n        :param absolute_views: absolute views on asset performances\n        :type absolute_views: dict, pd.Series\n        \"\"\"\n    if not isinstance(absolute_views, (dict, pd.Series)):\n        raise TypeError('views should be a dict or pd.Series')\n    views = pd.Series(absolute_views)\n    k = len(views)\n    Q = np.zeros((k, 1))\n    P = np.zeros((k, self.n_assets))\n    for (i, view_ticker) in enumerate(views.keys()):\n        try:\n            Q[i] = views[view_ticker]\n            P[i, list(self.tickers).index(view_ticker)] = 1\n        except ValueError:\n            raise ValueError('Providing a view on an asset not in the universe')\n    return (Q, P)",
        "mutated": [
            "def _parse_views(self, absolute_views):\n    if False:\n        i = 10\n    '\\n        Given a collection (dict or series) of absolute views, construct\\n        the appropriate views vector and picking matrix. The views must\\n        be a subset of the tickers in the covariance matrix.\\n\\n        {\"AAPL\": 0.20, \"GOOG\": 0.12, \"XOM\": -0.30}\\n\\n        :param absolute_views: absolute views on asset performances\\n        :type absolute_views: dict, pd.Series\\n        '\n    if not isinstance(absolute_views, (dict, pd.Series)):\n        raise TypeError('views should be a dict or pd.Series')\n    views = pd.Series(absolute_views)\n    k = len(views)\n    Q = np.zeros((k, 1))\n    P = np.zeros((k, self.n_assets))\n    for (i, view_ticker) in enumerate(views.keys()):\n        try:\n            Q[i] = views[view_ticker]\n            P[i, list(self.tickers).index(view_ticker)] = 1\n        except ValueError:\n            raise ValueError('Providing a view on an asset not in the universe')\n    return (Q, P)",
            "def _parse_views(self, absolute_views):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Given a collection (dict or series) of absolute views, construct\\n        the appropriate views vector and picking matrix. The views must\\n        be a subset of the tickers in the covariance matrix.\\n\\n        {\"AAPL\": 0.20, \"GOOG\": 0.12, \"XOM\": -0.30}\\n\\n        :param absolute_views: absolute views on asset performances\\n        :type absolute_views: dict, pd.Series\\n        '\n    if not isinstance(absolute_views, (dict, pd.Series)):\n        raise TypeError('views should be a dict or pd.Series')\n    views = pd.Series(absolute_views)\n    k = len(views)\n    Q = np.zeros((k, 1))\n    P = np.zeros((k, self.n_assets))\n    for (i, view_ticker) in enumerate(views.keys()):\n        try:\n            Q[i] = views[view_ticker]\n            P[i, list(self.tickers).index(view_ticker)] = 1\n        except ValueError:\n            raise ValueError('Providing a view on an asset not in the universe')\n    return (Q, P)",
            "def _parse_views(self, absolute_views):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Given a collection (dict or series) of absolute views, construct\\n        the appropriate views vector and picking matrix. The views must\\n        be a subset of the tickers in the covariance matrix.\\n\\n        {\"AAPL\": 0.20, \"GOOG\": 0.12, \"XOM\": -0.30}\\n\\n        :param absolute_views: absolute views on asset performances\\n        :type absolute_views: dict, pd.Series\\n        '\n    if not isinstance(absolute_views, (dict, pd.Series)):\n        raise TypeError('views should be a dict or pd.Series')\n    views = pd.Series(absolute_views)\n    k = len(views)\n    Q = np.zeros((k, 1))\n    P = np.zeros((k, self.n_assets))\n    for (i, view_ticker) in enumerate(views.keys()):\n        try:\n            Q[i] = views[view_ticker]\n            P[i, list(self.tickers).index(view_ticker)] = 1\n        except ValueError:\n            raise ValueError('Providing a view on an asset not in the universe')\n    return (Q, P)",
            "def _parse_views(self, absolute_views):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Given a collection (dict or series) of absolute views, construct\\n        the appropriate views vector and picking matrix. The views must\\n        be a subset of the tickers in the covariance matrix.\\n\\n        {\"AAPL\": 0.20, \"GOOG\": 0.12, \"XOM\": -0.30}\\n\\n        :param absolute_views: absolute views on asset performances\\n        :type absolute_views: dict, pd.Series\\n        '\n    if not isinstance(absolute_views, (dict, pd.Series)):\n        raise TypeError('views should be a dict or pd.Series')\n    views = pd.Series(absolute_views)\n    k = len(views)\n    Q = np.zeros((k, 1))\n    P = np.zeros((k, self.n_assets))\n    for (i, view_ticker) in enumerate(views.keys()):\n        try:\n            Q[i] = views[view_ticker]\n            P[i, list(self.tickers).index(view_ticker)] = 1\n        except ValueError:\n            raise ValueError('Providing a view on an asset not in the universe')\n    return (Q, P)",
            "def _parse_views(self, absolute_views):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Given a collection (dict or series) of absolute views, construct\\n        the appropriate views vector and picking matrix. The views must\\n        be a subset of the tickers in the covariance matrix.\\n\\n        {\"AAPL\": 0.20, \"GOOG\": 0.12, \"XOM\": -0.30}\\n\\n        :param absolute_views: absolute views on asset performances\\n        :type absolute_views: dict, pd.Series\\n        '\n    if not isinstance(absolute_views, (dict, pd.Series)):\n        raise TypeError('views should be a dict or pd.Series')\n    views = pd.Series(absolute_views)\n    k = len(views)\n    Q = np.zeros((k, 1))\n    P = np.zeros((k, self.n_assets))\n    for (i, view_ticker) in enumerate(views.keys()):\n        try:\n            Q[i] = views[view_ticker]\n            P[i, list(self.tickers).index(view_ticker)] = 1\n        except ValueError:\n            raise ValueError('Providing a view on an asset not in the universe')\n    return (Q, P)"
        ]
    },
    {
        "func_name": "_set_Q_P",
        "original": "def _set_Q_P(self, Q, P):\n    if isinstance(Q, (pd.Series, pd.DataFrame)):\n        self.Q = Q.values.reshape(-1, 1)\n    elif isinstance(Q, np.ndarray):\n        self.Q = Q.reshape(-1, 1)\n    else:\n        raise TypeError('Q must be an array or dataframe')\n    if isinstance(P, pd.DataFrame):\n        self.P = P.values\n    elif isinstance(P, np.ndarray):\n        self.P = P\n    elif len(self.Q) == self.n_assets:\n        self.P = np.eye(self.n_assets)\n    else:\n        raise TypeError('P must be an array or dataframe')",
        "mutated": [
            "def _set_Q_P(self, Q, P):\n    if False:\n        i = 10\n    if isinstance(Q, (pd.Series, pd.DataFrame)):\n        self.Q = Q.values.reshape(-1, 1)\n    elif isinstance(Q, np.ndarray):\n        self.Q = Q.reshape(-1, 1)\n    else:\n        raise TypeError('Q must be an array or dataframe')\n    if isinstance(P, pd.DataFrame):\n        self.P = P.values\n    elif isinstance(P, np.ndarray):\n        self.P = P\n    elif len(self.Q) == self.n_assets:\n        self.P = np.eye(self.n_assets)\n    else:\n        raise TypeError('P must be an array or dataframe')",
            "def _set_Q_P(self, Q, P):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(Q, (pd.Series, pd.DataFrame)):\n        self.Q = Q.values.reshape(-1, 1)\n    elif isinstance(Q, np.ndarray):\n        self.Q = Q.reshape(-1, 1)\n    else:\n        raise TypeError('Q must be an array or dataframe')\n    if isinstance(P, pd.DataFrame):\n        self.P = P.values\n    elif isinstance(P, np.ndarray):\n        self.P = P\n    elif len(self.Q) == self.n_assets:\n        self.P = np.eye(self.n_assets)\n    else:\n        raise TypeError('P must be an array or dataframe')",
            "def _set_Q_P(self, Q, P):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(Q, (pd.Series, pd.DataFrame)):\n        self.Q = Q.values.reshape(-1, 1)\n    elif isinstance(Q, np.ndarray):\n        self.Q = Q.reshape(-1, 1)\n    else:\n        raise TypeError('Q must be an array or dataframe')\n    if isinstance(P, pd.DataFrame):\n        self.P = P.values\n    elif isinstance(P, np.ndarray):\n        self.P = P\n    elif len(self.Q) == self.n_assets:\n        self.P = np.eye(self.n_assets)\n    else:\n        raise TypeError('P must be an array or dataframe')",
            "def _set_Q_P(self, Q, P):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(Q, (pd.Series, pd.DataFrame)):\n        self.Q = Q.values.reshape(-1, 1)\n    elif isinstance(Q, np.ndarray):\n        self.Q = Q.reshape(-1, 1)\n    else:\n        raise TypeError('Q must be an array or dataframe')\n    if isinstance(P, pd.DataFrame):\n        self.P = P.values\n    elif isinstance(P, np.ndarray):\n        self.P = P\n    elif len(self.Q) == self.n_assets:\n        self.P = np.eye(self.n_assets)\n    else:\n        raise TypeError('P must be an array or dataframe')",
            "def _set_Q_P(self, Q, P):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(Q, (pd.Series, pd.DataFrame)):\n        self.Q = Q.values.reshape(-1, 1)\n    elif isinstance(Q, np.ndarray):\n        self.Q = Q.reshape(-1, 1)\n    else:\n        raise TypeError('Q must be an array or dataframe')\n    if isinstance(P, pd.DataFrame):\n        self.P = P.values\n    elif isinstance(P, np.ndarray):\n        self.P = P\n    elif len(self.Q) == self.n_assets:\n        self.P = np.eye(self.n_assets)\n    else:\n        raise TypeError('P must be an array or dataframe')"
        ]
    },
    {
        "func_name": "_set_pi",
        "original": "def _set_pi(self, pi, **kwargs):\n    if pi is None:\n        warnings.warn('Running Black-Litterman with no prior.')\n        self.pi = np.zeros((self.n_assets, 1))\n    elif isinstance(pi, (pd.Series, pd.DataFrame)):\n        self.pi = pi.values.reshape(-1, 1)\n    elif isinstance(pi, np.ndarray):\n        self.pi = pi.reshape(-1, 1)\n    elif pi == 'market':\n        if 'market_caps' not in kwargs:\n            raise ValueError('Please pass a series/array of market caps via the market_caps keyword argument')\n        market_caps = kwargs.get('market_caps')\n        risk_free_rate = kwargs.get('risk_free_rate', 0)\n        market_prior = market_implied_prior_returns(market_caps, self.risk_aversion, self._raw_cov_matrix, risk_free_rate)\n        self.pi = market_prior.values.reshape(-1, 1)\n    elif pi == 'equal':\n        self.pi = np.ones((self.n_assets, 1)) / self.n_assets\n    else:\n        raise TypeError('pi must be an array or series')",
        "mutated": [
            "def _set_pi(self, pi, **kwargs):\n    if False:\n        i = 10\n    if pi is None:\n        warnings.warn('Running Black-Litterman with no prior.')\n        self.pi = np.zeros((self.n_assets, 1))\n    elif isinstance(pi, (pd.Series, pd.DataFrame)):\n        self.pi = pi.values.reshape(-1, 1)\n    elif isinstance(pi, np.ndarray):\n        self.pi = pi.reshape(-1, 1)\n    elif pi == 'market':\n        if 'market_caps' not in kwargs:\n            raise ValueError('Please pass a series/array of market caps via the market_caps keyword argument')\n        market_caps = kwargs.get('market_caps')\n        risk_free_rate = kwargs.get('risk_free_rate', 0)\n        market_prior = market_implied_prior_returns(market_caps, self.risk_aversion, self._raw_cov_matrix, risk_free_rate)\n        self.pi = market_prior.values.reshape(-1, 1)\n    elif pi == 'equal':\n        self.pi = np.ones((self.n_assets, 1)) / self.n_assets\n    else:\n        raise TypeError('pi must be an array or series')",
            "def _set_pi(self, pi, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if pi is None:\n        warnings.warn('Running Black-Litterman with no prior.')\n        self.pi = np.zeros((self.n_assets, 1))\n    elif isinstance(pi, (pd.Series, pd.DataFrame)):\n        self.pi = pi.values.reshape(-1, 1)\n    elif isinstance(pi, np.ndarray):\n        self.pi = pi.reshape(-1, 1)\n    elif pi == 'market':\n        if 'market_caps' not in kwargs:\n            raise ValueError('Please pass a series/array of market caps via the market_caps keyword argument')\n        market_caps = kwargs.get('market_caps')\n        risk_free_rate = kwargs.get('risk_free_rate', 0)\n        market_prior = market_implied_prior_returns(market_caps, self.risk_aversion, self._raw_cov_matrix, risk_free_rate)\n        self.pi = market_prior.values.reshape(-1, 1)\n    elif pi == 'equal':\n        self.pi = np.ones((self.n_assets, 1)) / self.n_assets\n    else:\n        raise TypeError('pi must be an array or series')",
            "def _set_pi(self, pi, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if pi is None:\n        warnings.warn('Running Black-Litterman with no prior.')\n        self.pi = np.zeros((self.n_assets, 1))\n    elif isinstance(pi, (pd.Series, pd.DataFrame)):\n        self.pi = pi.values.reshape(-1, 1)\n    elif isinstance(pi, np.ndarray):\n        self.pi = pi.reshape(-1, 1)\n    elif pi == 'market':\n        if 'market_caps' not in kwargs:\n            raise ValueError('Please pass a series/array of market caps via the market_caps keyword argument')\n        market_caps = kwargs.get('market_caps')\n        risk_free_rate = kwargs.get('risk_free_rate', 0)\n        market_prior = market_implied_prior_returns(market_caps, self.risk_aversion, self._raw_cov_matrix, risk_free_rate)\n        self.pi = market_prior.values.reshape(-1, 1)\n    elif pi == 'equal':\n        self.pi = np.ones((self.n_assets, 1)) / self.n_assets\n    else:\n        raise TypeError('pi must be an array or series')",
            "def _set_pi(self, pi, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if pi is None:\n        warnings.warn('Running Black-Litterman with no prior.')\n        self.pi = np.zeros((self.n_assets, 1))\n    elif isinstance(pi, (pd.Series, pd.DataFrame)):\n        self.pi = pi.values.reshape(-1, 1)\n    elif isinstance(pi, np.ndarray):\n        self.pi = pi.reshape(-1, 1)\n    elif pi == 'market':\n        if 'market_caps' not in kwargs:\n            raise ValueError('Please pass a series/array of market caps via the market_caps keyword argument')\n        market_caps = kwargs.get('market_caps')\n        risk_free_rate = kwargs.get('risk_free_rate', 0)\n        market_prior = market_implied_prior_returns(market_caps, self.risk_aversion, self._raw_cov_matrix, risk_free_rate)\n        self.pi = market_prior.values.reshape(-1, 1)\n    elif pi == 'equal':\n        self.pi = np.ones((self.n_assets, 1)) / self.n_assets\n    else:\n        raise TypeError('pi must be an array or series')",
            "def _set_pi(self, pi, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if pi is None:\n        warnings.warn('Running Black-Litterman with no prior.')\n        self.pi = np.zeros((self.n_assets, 1))\n    elif isinstance(pi, (pd.Series, pd.DataFrame)):\n        self.pi = pi.values.reshape(-1, 1)\n    elif isinstance(pi, np.ndarray):\n        self.pi = pi.reshape(-1, 1)\n    elif pi == 'market':\n        if 'market_caps' not in kwargs:\n            raise ValueError('Please pass a series/array of market caps via the market_caps keyword argument')\n        market_caps = kwargs.get('market_caps')\n        risk_free_rate = kwargs.get('risk_free_rate', 0)\n        market_prior = market_implied_prior_returns(market_caps, self.risk_aversion, self._raw_cov_matrix, risk_free_rate)\n        self.pi = market_prior.values.reshape(-1, 1)\n    elif pi == 'equal':\n        self.pi = np.ones((self.n_assets, 1)) / self.n_assets\n    else:\n        raise TypeError('pi must be an array or series')"
        ]
    },
    {
        "func_name": "_set_tau",
        "original": "def _set_tau(self, tau):\n    if tau <= 0 or tau > 1:\n        raise ValueError('tau should be between 0 and 1')\n    self.tau = tau",
        "mutated": [
            "def _set_tau(self, tau):\n    if False:\n        i = 10\n    if tau <= 0 or tau > 1:\n        raise ValueError('tau should be between 0 and 1')\n    self.tau = tau",
            "def _set_tau(self, tau):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if tau <= 0 or tau > 1:\n        raise ValueError('tau should be between 0 and 1')\n    self.tau = tau",
            "def _set_tau(self, tau):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if tau <= 0 or tau > 1:\n        raise ValueError('tau should be between 0 and 1')\n    self.tau = tau",
            "def _set_tau(self, tau):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if tau <= 0 or tau > 1:\n        raise ValueError('tau should be between 0 and 1')\n    self.tau = tau",
            "def _set_tau(self, tau):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if tau <= 0 or tau > 1:\n        raise ValueError('tau should be between 0 and 1')\n    self.tau = tau"
        ]
    },
    {
        "func_name": "_set_risk_aversion",
        "original": "def _set_risk_aversion(self, risk_aversion):\n    if risk_aversion <= 0:\n        raise ValueError('risk_aversion should be a positive float')\n    self.risk_aversion = risk_aversion",
        "mutated": [
            "def _set_risk_aversion(self, risk_aversion):\n    if False:\n        i = 10\n    if risk_aversion <= 0:\n        raise ValueError('risk_aversion should be a positive float')\n    self.risk_aversion = risk_aversion",
            "def _set_risk_aversion(self, risk_aversion):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if risk_aversion <= 0:\n        raise ValueError('risk_aversion should be a positive float')\n    self.risk_aversion = risk_aversion",
            "def _set_risk_aversion(self, risk_aversion):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if risk_aversion <= 0:\n        raise ValueError('risk_aversion should be a positive float')\n    self.risk_aversion = risk_aversion",
            "def _set_risk_aversion(self, risk_aversion):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if risk_aversion <= 0:\n        raise ValueError('risk_aversion should be a positive float')\n    self.risk_aversion = risk_aversion",
            "def _set_risk_aversion(self, risk_aversion):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if risk_aversion <= 0:\n        raise ValueError('risk_aversion should be a positive float')\n    self.risk_aversion = risk_aversion"
        ]
    },
    {
        "func_name": "_set_omega",
        "original": "def _set_omega(self, omega, view_confidences):\n    if isinstance(omega, pd.DataFrame):\n        self.omega = omega.values\n    elif isinstance(omega, np.ndarray):\n        self.omega = omega\n    elif omega == 'idzorek':\n        if view_confidences is None:\n            raise ValueError(\"To use Idzorek's method, please supply a vector of percentage confidence levels for each view.\")\n        if not isinstance(view_confidences, np.ndarray):\n            try:\n                view_confidences = np.array(view_confidences).reshape(-1, 1)\n                assert view_confidences.shape[0] == self.Q.shape[0]\n                assert np.issubdtype(view_confidences.dtype, np.number)\n            except AssertionError:\n                raise ValueError('view_confidences should be a numpy 1D array or vector with the same length as the number of views.')\n        self.omega = BlackLittermanModel.idzorek_method(view_confidences, self.cov_matrix, self.pi, self.Q, self.P, self.tau, self.risk_aversion)\n    elif omega is None or omega == 'default':\n        self.omega = BlackLittermanModel.default_omega(self.cov_matrix, self.P, self.tau)\n    else:\n        raise TypeError('self.omega must be a square array, dataframe, or string')\n    K = len(self.Q)\n    assert self.omega.shape == (K, K), 'omega must have dimensions KxK'",
        "mutated": [
            "def _set_omega(self, omega, view_confidences):\n    if False:\n        i = 10\n    if isinstance(omega, pd.DataFrame):\n        self.omega = omega.values\n    elif isinstance(omega, np.ndarray):\n        self.omega = omega\n    elif omega == 'idzorek':\n        if view_confidences is None:\n            raise ValueError(\"To use Idzorek's method, please supply a vector of percentage confidence levels for each view.\")\n        if not isinstance(view_confidences, np.ndarray):\n            try:\n                view_confidences = np.array(view_confidences).reshape(-1, 1)\n                assert view_confidences.shape[0] == self.Q.shape[0]\n                assert np.issubdtype(view_confidences.dtype, np.number)\n            except AssertionError:\n                raise ValueError('view_confidences should be a numpy 1D array or vector with the same length as the number of views.')\n        self.omega = BlackLittermanModel.idzorek_method(view_confidences, self.cov_matrix, self.pi, self.Q, self.P, self.tau, self.risk_aversion)\n    elif omega is None or omega == 'default':\n        self.omega = BlackLittermanModel.default_omega(self.cov_matrix, self.P, self.tau)\n    else:\n        raise TypeError('self.omega must be a square array, dataframe, or string')\n    K = len(self.Q)\n    assert self.omega.shape == (K, K), 'omega must have dimensions KxK'",
            "def _set_omega(self, omega, view_confidences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(omega, pd.DataFrame):\n        self.omega = omega.values\n    elif isinstance(omega, np.ndarray):\n        self.omega = omega\n    elif omega == 'idzorek':\n        if view_confidences is None:\n            raise ValueError(\"To use Idzorek's method, please supply a vector of percentage confidence levels for each view.\")\n        if not isinstance(view_confidences, np.ndarray):\n            try:\n                view_confidences = np.array(view_confidences).reshape(-1, 1)\n                assert view_confidences.shape[0] == self.Q.shape[0]\n                assert np.issubdtype(view_confidences.dtype, np.number)\n            except AssertionError:\n                raise ValueError('view_confidences should be a numpy 1D array or vector with the same length as the number of views.')\n        self.omega = BlackLittermanModel.idzorek_method(view_confidences, self.cov_matrix, self.pi, self.Q, self.P, self.tau, self.risk_aversion)\n    elif omega is None or omega == 'default':\n        self.omega = BlackLittermanModel.default_omega(self.cov_matrix, self.P, self.tau)\n    else:\n        raise TypeError('self.omega must be a square array, dataframe, or string')\n    K = len(self.Q)\n    assert self.omega.shape == (K, K), 'omega must have dimensions KxK'",
            "def _set_omega(self, omega, view_confidences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(omega, pd.DataFrame):\n        self.omega = omega.values\n    elif isinstance(omega, np.ndarray):\n        self.omega = omega\n    elif omega == 'idzorek':\n        if view_confidences is None:\n            raise ValueError(\"To use Idzorek's method, please supply a vector of percentage confidence levels for each view.\")\n        if not isinstance(view_confidences, np.ndarray):\n            try:\n                view_confidences = np.array(view_confidences).reshape(-1, 1)\n                assert view_confidences.shape[0] == self.Q.shape[0]\n                assert np.issubdtype(view_confidences.dtype, np.number)\n            except AssertionError:\n                raise ValueError('view_confidences should be a numpy 1D array or vector with the same length as the number of views.')\n        self.omega = BlackLittermanModel.idzorek_method(view_confidences, self.cov_matrix, self.pi, self.Q, self.P, self.tau, self.risk_aversion)\n    elif omega is None or omega == 'default':\n        self.omega = BlackLittermanModel.default_omega(self.cov_matrix, self.P, self.tau)\n    else:\n        raise TypeError('self.omega must be a square array, dataframe, or string')\n    K = len(self.Q)\n    assert self.omega.shape == (K, K), 'omega must have dimensions KxK'",
            "def _set_omega(self, omega, view_confidences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(omega, pd.DataFrame):\n        self.omega = omega.values\n    elif isinstance(omega, np.ndarray):\n        self.omega = omega\n    elif omega == 'idzorek':\n        if view_confidences is None:\n            raise ValueError(\"To use Idzorek's method, please supply a vector of percentage confidence levels for each view.\")\n        if not isinstance(view_confidences, np.ndarray):\n            try:\n                view_confidences = np.array(view_confidences).reshape(-1, 1)\n                assert view_confidences.shape[0] == self.Q.shape[0]\n                assert np.issubdtype(view_confidences.dtype, np.number)\n            except AssertionError:\n                raise ValueError('view_confidences should be a numpy 1D array or vector with the same length as the number of views.')\n        self.omega = BlackLittermanModel.idzorek_method(view_confidences, self.cov_matrix, self.pi, self.Q, self.P, self.tau, self.risk_aversion)\n    elif omega is None or omega == 'default':\n        self.omega = BlackLittermanModel.default_omega(self.cov_matrix, self.P, self.tau)\n    else:\n        raise TypeError('self.omega must be a square array, dataframe, or string')\n    K = len(self.Q)\n    assert self.omega.shape == (K, K), 'omega must have dimensions KxK'",
            "def _set_omega(self, omega, view_confidences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(omega, pd.DataFrame):\n        self.omega = omega.values\n    elif isinstance(omega, np.ndarray):\n        self.omega = omega\n    elif omega == 'idzorek':\n        if view_confidences is None:\n            raise ValueError(\"To use Idzorek's method, please supply a vector of percentage confidence levels for each view.\")\n        if not isinstance(view_confidences, np.ndarray):\n            try:\n                view_confidences = np.array(view_confidences).reshape(-1, 1)\n                assert view_confidences.shape[0] == self.Q.shape[0]\n                assert np.issubdtype(view_confidences.dtype, np.number)\n            except AssertionError:\n                raise ValueError('view_confidences should be a numpy 1D array or vector with the same length as the number of views.')\n        self.omega = BlackLittermanModel.idzorek_method(view_confidences, self.cov_matrix, self.pi, self.Q, self.P, self.tau, self.risk_aversion)\n    elif omega is None or omega == 'default':\n        self.omega = BlackLittermanModel.default_omega(self.cov_matrix, self.P, self.tau)\n    else:\n        raise TypeError('self.omega must be a square array, dataframe, or string')\n    K = len(self.Q)\n    assert self.omega.shape == (K, K), 'omega must have dimensions KxK'"
        ]
    },
    {
        "func_name": "_check_attribute_dimensions",
        "original": "def _check_attribute_dimensions(self):\n    \"\"\"\n        Helper method to ensure that all of the attributes created by the initialiser\n        have the correct dimensions, to avoid linear algebra errors later on.\n\n        :raises ValueError: if there are incorrect dimensions.\n        \"\"\"\n    N = self.n_assets\n    K = len(self.Q)\n    assert self.pi.shape == (N, 1), 'pi must have dimensions Nx1'\n    assert self.P.shape == (K, N), 'P must have dimensions KxN'\n    assert self.cov_matrix.shape == (N, N), 'cov_matrix must have shape NxN'",
        "mutated": [
            "def _check_attribute_dimensions(self):\n    if False:\n        i = 10\n    '\\n        Helper method to ensure that all of the attributes created by the initialiser\\n        have the correct dimensions, to avoid linear algebra errors later on.\\n\\n        :raises ValueError: if there are incorrect dimensions.\\n        '\n    N = self.n_assets\n    K = len(self.Q)\n    assert self.pi.shape == (N, 1), 'pi must have dimensions Nx1'\n    assert self.P.shape == (K, N), 'P must have dimensions KxN'\n    assert self.cov_matrix.shape == (N, N), 'cov_matrix must have shape NxN'",
            "def _check_attribute_dimensions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Helper method to ensure that all of the attributes created by the initialiser\\n        have the correct dimensions, to avoid linear algebra errors later on.\\n\\n        :raises ValueError: if there are incorrect dimensions.\\n        '\n    N = self.n_assets\n    K = len(self.Q)\n    assert self.pi.shape == (N, 1), 'pi must have dimensions Nx1'\n    assert self.P.shape == (K, N), 'P must have dimensions KxN'\n    assert self.cov_matrix.shape == (N, N), 'cov_matrix must have shape NxN'",
            "def _check_attribute_dimensions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Helper method to ensure that all of the attributes created by the initialiser\\n        have the correct dimensions, to avoid linear algebra errors later on.\\n\\n        :raises ValueError: if there are incorrect dimensions.\\n        '\n    N = self.n_assets\n    K = len(self.Q)\n    assert self.pi.shape == (N, 1), 'pi must have dimensions Nx1'\n    assert self.P.shape == (K, N), 'P must have dimensions KxN'\n    assert self.cov_matrix.shape == (N, N), 'cov_matrix must have shape NxN'",
            "def _check_attribute_dimensions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Helper method to ensure that all of the attributes created by the initialiser\\n        have the correct dimensions, to avoid linear algebra errors later on.\\n\\n        :raises ValueError: if there are incorrect dimensions.\\n        '\n    N = self.n_assets\n    K = len(self.Q)\n    assert self.pi.shape == (N, 1), 'pi must have dimensions Nx1'\n    assert self.P.shape == (K, N), 'P must have dimensions KxN'\n    assert self.cov_matrix.shape == (N, N), 'cov_matrix must have shape NxN'",
            "def _check_attribute_dimensions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Helper method to ensure that all of the attributes created by the initialiser\\n        have the correct dimensions, to avoid linear algebra errors later on.\\n\\n        :raises ValueError: if there are incorrect dimensions.\\n        '\n    N = self.n_assets\n    K = len(self.Q)\n    assert self.pi.shape == (N, 1), 'pi must have dimensions Nx1'\n    assert self.P.shape == (K, N), 'P must have dimensions KxN'\n    assert self.cov_matrix.shape == (N, N), 'cov_matrix must have shape NxN'"
        ]
    },
    {
        "func_name": "default_omega",
        "original": "@staticmethod\ndef default_omega(cov_matrix, P, tau):\n    \"\"\"\n        If the uncertainty matrix omega is not provided, we calculate using the method of\n        He and Litterman (1999), such that the ratio omega/tau is proportional to the\n        variance of the view portfolio.\n\n        :return: KxK diagonal uncertainty matrix\n        :rtype: np.ndarray\n        \"\"\"\n    return np.diag(np.diag(tau * P @ cov_matrix @ P.T))",
        "mutated": [
            "@staticmethod\ndef default_omega(cov_matrix, P, tau):\n    if False:\n        i = 10\n    '\\n        If the uncertainty matrix omega is not provided, we calculate using the method of\\n        He and Litterman (1999), such that the ratio omega/tau is proportional to the\\n        variance of the view portfolio.\\n\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        '\n    return np.diag(np.diag(tau * P @ cov_matrix @ P.T))",
            "@staticmethod\ndef default_omega(cov_matrix, P, tau):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        If the uncertainty matrix omega is not provided, we calculate using the method of\\n        He and Litterman (1999), such that the ratio omega/tau is proportional to the\\n        variance of the view portfolio.\\n\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        '\n    return np.diag(np.diag(tau * P @ cov_matrix @ P.T))",
            "@staticmethod\ndef default_omega(cov_matrix, P, tau):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        If the uncertainty matrix omega is not provided, we calculate using the method of\\n        He and Litterman (1999), such that the ratio omega/tau is proportional to the\\n        variance of the view portfolio.\\n\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        '\n    return np.diag(np.diag(tau * P @ cov_matrix @ P.T))",
            "@staticmethod\ndef default_omega(cov_matrix, P, tau):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        If the uncertainty matrix omega is not provided, we calculate using the method of\\n        He and Litterman (1999), such that the ratio omega/tau is proportional to the\\n        variance of the view portfolio.\\n\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        '\n    return np.diag(np.diag(tau * P @ cov_matrix @ P.T))",
            "@staticmethod\ndef default_omega(cov_matrix, P, tau):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        If the uncertainty matrix omega is not provided, we calculate using the method of\\n        He and Litterman (1999), such that the ratio omega/tau is proportional to the\\n        variance of the view portfolio.\\n\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        '\n    return np.diag(np.diag(tau * P @ cov_matrix @ P.T))"
        ]
    },
    {
        "func_name": "idzorek_method",
        "original": "@staticmethod\ndef idzorek_method(view_confidences, cov_matrix, pi, Q, P, tau, risk_aversion=1):\n    \"\"\"\n        Use Idzorek's method to create the uncertainty matrix given user-specified\n        percentage confidences. We use the closed-form solution described by\n        Jay Walters in The Black-Litterman Model in Detail (2014).\n\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\n                                required to compute omega via Idzorek's method.\n        :type view_confidences: np.ndarray, pd.Series, list,, optional\n        :return: KxK diagonal uncertainty matrix\n        :rtype: np.ndarray\n        \"\"\"\n    view_omegas = []\n    for view_idx in range(len(Q)):\n        conf = view_confidences[view_idx]\n        if conf < 0 or conf > 1:\n            raise ValueError('View confidences must be between 0 and 1')\n        if conf == 0:\n            view_omegas.append(1000000.0)\n            continue\n        P_view = P[view_idx].reshape(1, -1)\n        alpha = (1 - conf) / conf\n        omega = tau * alpha * P_view @ cov_matrix @ P_view.T\n        view_omegas.append(omega.item())\n    return np.diag(view_omegas)",
        "mutated": [
            "@staticmethod\ndef idzorek_method(view_confidences, cov_matrix, pi, Q, P, tau, risk_aversion=1):\n    if False:\n        i = 10\n    \"\\n        Use Idzorek's method to create the uncertainty matrix given user-specified\\n        percentage confidences. We use the closed-form solution described by\\n        Jay Walters in The Black-Litterman Model in Detail (2014).\\n\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek's method.\\n        :type view_confidences: np.ndarray, pd.Series, list,, optional\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        \"\n    view_omegas = []\n    for view_idx in range(len(Q)):\n        conf = view_confidences[view_idx]\n        if conf < 0 or conf > 1:\n            raise ValueError('View confidences must be between 0 and 1')\n        if conf == 0:\n            view_omegas.append(1000000.0)\n            continue\n        P_view = P[view_idx].reshape(1, -1)\n        alpha = (1 - conf) / conf\n        omega = tau * alpha * P_view @ cov_matrix @ P_view.T\n        view_omegas.append(omega.item())\n    return np.diag(view_omegas)",
            "@staticmethod\ndef idzorek_method(view_confidences, cov_matrix, pi, Q, P, tau, risk_aversion=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Use Idzorek's method to create the uncertainty matrix given user-specified\\n        percentage confidences. We use the closed-form solution described by\\n        Jay Walters in The Black-Litterman Model in Detail (2014).\\n\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek's method.\\n        :type view_confidences: np.ndarray, pd.Series, list,, optional\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        \"\n    view_omegas = []\n    for view_idx in range(len(Q)):\n        conf = view_confidences[view_idx]\n        if conf < 0 or conf > 1:\n            raise ValueError('View confidences must be between 0 and 1')\n        if conf == 0:\n            view_omegas.append(1000000.0)\n            continue\n        P_view = P[view_idx].reshape(1, -1)\n        alpha = (1 - conf) / conf\n        omega = tau * alpha * P_view @ cov_matrix @ P_view.T\n        view_omegas.append(omega.item())\n    return np.diag(view_omegas)",
            "@staticmethod\ndef idzorek_method(view_confidences, cov_matrix, pi, Q, P, tau, risk_aversion=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Use Idzorek's method to create the uncertainty matrix given user-specified\\n        percentage confidences. We use the closed-form solution described by\\n        Jay Walters in The Black-Litterman Model in Detail (2014).\\n\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek's method.\\n        :type view_confidences: np.ndarray, pd.Series, list,, optional\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        \"\n    view_omegas = []\n    for view_idx in range(len(Q)):\n        conf = view_confidences[view_idx]\n        if conf < 0 or conf > 1:\n            raise ValueError('View confidences must be between 0 and 1')\n        if conf == 0:\n            view_omegas.append(1000000.0)\n            continue\n        P_view = P[view_idx].reshape(1, -1)\n        alpha = (1 - conf) / conf\n        omega = tau * alpha * P_view @ cov_matrix @ P_view.T\n        view_omegas.append(omega.item())\n    return np.diag(view_omegas)",
            "@staticmethod\ndef idzorek_method(view_confidences, cov_matrix, pi, Q, P, tau, risk_aversion=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Use Idzorek's method to create the uncertainty matrix given user-specified\\n        percentage confidences. We use the closed-form solution described by\\n        Jay Walters in The Black-Litterman Model in Detail (2014).\\n\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek's method.\\n        :type view_confidences: np.ndarray, pd.Series, list,, optional\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        \"\n    view_omegas = []\n    for view_idx in range(len(Q)):\n        conf = view_confidences[view_idx]\n        if conf < 0 or conf > 1:\n            raise ValueError('View confidences must be between 0 and 1')\n        if conf == 0:\n            view_omegas.append(1000000.0)\n            continue\n        P_view = P[view_idx].reshape(1, -1)\n        alpha = (1 - conf) / conf\n        omega = tau * alpha * P_view @ cov_matrix @ P_view.T\n        view_omegas.append(omega.item())\n    return np.diag(view_omegas)",
            "@staticmethod\ndef idzorek_method(view_confidences, cov_matrix, pi, Q, P, tau, risk_aversion=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Use Idzorek's method to create the uncertainty matrix given user-specified\\n        percentage confidences. We use the closed-form solution described by\\n        Jay Walters in The Black-Litterman Model in Detail (2014).\\n\\n        :param view_confidences: Kx1 vector of percentage view confidences (between 0 and 1),\\n                                required to compute omega via Idzorek's method.\\n        :type view_confidences: np.ndarray, pd.Series, list,, optional\\n        :return: KxK diagonal uncertainty matrix\\n        :rtype: np.ndarray\\n        \"\n    view_omegas = []\n    for view_idx in range(len(Q)):\n        conf = view_confidences[view_idx]\n        if conf < 0 or conf > 1:\n            raise ValueError('View confidences must be between 0 and 1')\n        if conf == 0:\n            view_omegas.append(1000000.0)\n            continue\n        P_view = P[view_idx].reshape(1, -1)\n        alpha = (1 - conf) / conf\n        omega = tau * alpha * P_view @ cov_matrix @ P_view.T\n        view_omegas.append(omega.item())\n    return np.diag(view_omegas)"
        ]
    },
    {
        "func_name": "bl_returns",
        "original": "def bl_returns(self):\n    \"\"\"\n        Calculate the posterior estimate of the returns vector,\n        given views on some assets.\n\n        :return: posterior returns vector\n        :rtype: pd.Series\n        \"\"\"\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self.Q - self.P @ self.pi\n    post_rets = self.pi + self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    return pd.Series(post_rets.flatten(), index=self.tickers)",
        "mutated": [
            "def bl_returns(self):\n    if False:\n        i = 10\n    '\\n        Calculate the posterior estimate of the returns vector,\\n        given views on some assets.\\n\\n        :return: posterior returns vector\\n        :rtype: pd.Series\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self.Q - self.P @ self.pi\n    post_rets = self.pi + self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    return pd.Series(post_rets.flatten(), index=self.tickers)",
            "def bl_returns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Calculate the posterior estimate of the returns vector,\\n        given views on some assets.\\n\\n        :return: posterior returns vector\\n        :rtype: pd.Series\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self.Q - self.P @ self.pi\n    post_rets = self.pi + self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    return pd.Series(post_rets.flatten(), index=self.tickers)",
            "def bl_returns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Calculate the posterior estimate of the returns vector,\\n        given views on some assets.\\n\\n        :return: posterior returns vector\\n        :rtype: pd.Series\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self.Q - self.P @ self.pi\n    post_rets = self.pi + self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    return pd.Series(post_rets.flatten(), index=self.tickers)",
            "def bl_returns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Calculate the posterior estimate of the returns vector,\\n        given views on some assets.\\n\\n        :return: posterior returns vector\\n        :rtype: pd.Series\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self.Q - self.P @ self.pi\n    post_rets = self.pi + self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    return pd.Series(post_rets.flatten(), index=self.tickers)",
            "def bl_returns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Calculate the posterior estimate of the returns vector,\\n        given views on some assets.\\n\\n        :return: posterior returns vector\\n        :rtype: pd.Series\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self.Q - self.P @ self.pi\n    post_rets = self.pi + self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    return pd.Series(post_rets.flatten(), index=self.tickers)"
        ]
    },
    {
        "func_name": "bl_cov",
        "original": "def bl_cov(self):\n    \"\"\"\n        Calculate the posterior estimate of the covariance matrix,\n        given views on some assets. Based on He and Litterman (2002).\n        It is assumed that omega is diagonal. If this is not the case,\n        please manually set omega_inv.\n\n        :return: posterior covariance matrix\n        :rtype: pd.DataFrame\n        \"\"\"\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self._tau_sigma_P.T\n    M = self.tau * self.cov_matrix - self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    posterior_cov = self.cov_matrix + M\n    return pd.DataFrame(posterior_cov, index=self.tickers, columns=self.tickers)",
        "mutated": [
            "def bl_cov(self):\n    if False:\n        i = 10\n    '\\n        Calculate the posterior estimate of the covariance matrix,\\n        given views on some assets. Based on He and Litterman (2002).\\n        It is assumed that omega is diagonal. If this is not the case,\\n        please manually set omega_inv.\\n\\n        :return: posterior covariance matrix\\n        :rtype: pd.DataFrame\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self._tau_sigma_P.T\n    M = self.tau * self.cov_matrix - self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    posterior_cov = self.cov_matrix + M\n    return pd.DataFrame(posterior_cov, index=self.tickers, columns=self.tickers)",
            "def bl_cov(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Calculate the posterior estimate of the covariance matrix,\\n        given views on some assets. Based on He and Litterman (2002).\\n        It is assumed that omega is diagonal. If this is not the case,\\n        please manually set omega_inv.\\n\\n        :return: posterior covariance matrix\\n        :rtype: pd.DataFrame\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self._tau_sigma_P.T\n    M = self.tau * self.cov_matrix - self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    posterior_cov = self.cov_matrix + M\n    return pd.DataFrame(posterior_cov, index=self.tickers, columns=self.tickers)",
            "def bl_cov(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Calculate the posterior estimate of the covariance matrix,\\n        given views on some assets. Based on He and Litterman (2002).\\n        It is assumed that omega is diagonal. If this is not the case,\\n        please manually set omega_inv.\\n\\n        :return: posterior covariance matrix\\n        :rtype: pd.DataFrame\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self._tau_sigma_P.T\n    M = self.tau * self.cov_matrix - self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    posterior_cov = self.cov_matrix + M\n    return pd.DataFrame(posterior_cov, index=self.tickers, columns=self.tickers)",
            "def bl_cov(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Calculate the posterior estimate of the covariance matrix,\\n        given views on some assets. Based on He and Litterman (2002).\\n        It is assumed that omega is diagonal. If this is not the case,\\n        please manually set omega_inv.\\n\\n        :return: posterior covariance matrix\\n        :rtype: pd.DataFrame\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self._tau_sigma_P.T\n    M = self.tau * self.cov_matrix - self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    posterior_cov = self.cov_matrix + M\n    return pd.DataFrame(posterior_cov, index=self.tickers, columns=self.tickers)",
            "def bl_cov(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Calculate the posterior estimate of the covariance matrix,\\n        given views on some assets. Based on He and Litterman (2002).\\n        It is assumed that omega is diagonal. If this is not the case,\\n        please manually set omega_inv.\\n\\n        :return: posterior covariance matrix\\n        :rtype: pd.DataFrame\\n        '\n    if self._tau_sigma_P is None:\n        self._tau_sigma_P = self.tau * self.cov_matrix @ self.P.T\n    if self._A is None:\n        self._A = self.P @ self._tau_sigma_P + self.omega\n    b = self._tau_sigma_P.T\n    M = self.tau * self.cov_matrix - self._tau_sigma_P @ np.linalg.solve(self._A, b)\n    posterior_cov = self.cov_matrix + M\n    return pd.DataFrame(posterior_cov, index=self.tickers, columns=self.tickers)"
        ]
    },
    {
        "func_name": "bl_weights",
        "original": "def bl_weights(self, risk_aversion=None):\n    \"\"\"\n        Compute the weights implied by the posterior returns, given the\n        market price of risk. Technically this can be applied to any\n        estimate of the expected returns, and is in fact a special case\n        of mean-variance optimization\n\n        .. math::\n\n            w = (\\\\delta \\\\Sigma)^{-1} E(R)\n\n        :param risk_aversion: risk aversion parameter, defaults to 1\n        :type risk_aversion: positive float, optional\n        :return: asset weights implied by returns\n        :rtype: OrderedDict\n        \"\"\"\n    if risk_aversion is None:\n        risk_aversion = self.risk_aversion\n    self.posterior_rets = self.bl_returns()\n    A = risk_aversion * self.cov_matrix\n    b = self.posterior_rets\n    raw_weights = np.linalg.solve(A, b)\n    self.weights = raw_weights / raw_weights.sum()\n    return self._make_output_weights()",
        "mutated": [
            "def bl_weights(self, risk_aversion=None):\n    if False:\n        i = 10\n    '\\n        Compute the weights implied by the posterior returns, given the\\n        market price of risk. Technically this can be applied to any\\n        estimate of the expected returns, and is in fact a special case\\n        of mean-variance optimization\\n\\n        .. math::\\n\\n            w = (\\\\delta \\\\Sigma)^{-1} E(R)\\n\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :return: asset weights implied by returns\\n        :rtype: OrderedDict\\n        '\n    if risk_aversion is None:\n        risk_aversion = self.risk_aversion\n    self.posterior_rets = self.bl_returns()\n    A = risk_aversion * self.cov_matrix\n    b = self.posterior_rets\n    raw_weights = np.linalg.solve(A, b)\n    self.weights = raw_weights / raw_weights.sum()\n    return self._make_output_weights()",
            "def bl_weights(self, risk_aversion=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Compute the weights implied by the posterior returns, given the\\n        market price of risk. Technically this can be applied to any\\n        estimate of the expected returns, and is in fact a special case\\n        of mean-variance optimization\\n\\n        .. math::\\n\\n            w = (\\\\delta \\\\Sigma)^{-1} E(R)\\n\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :return: asset weights implied by returns\\n        :rtype: OrderedDict\\n        '\n    if risk_aversion is None:\n        risk_aversion = self.risk_aversion\n    self.posterior_rets = self.bl_returns()\n    A = risk_aversion * self.cov_matrix\n    b = self.posterior_rets\n    raw_weights = np.linalg.solve(A, b)\n    self.weights = raw_weights / raw_weights.sum()\n    return self._make_output_weights()",
            "def bl_weights(self, risk_aversion=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Compute the weights implied by the posterior returns, given the\\n        market price of risk. Technically this can be applied to any\\n        estimate of the expected returns, and is in fact a special case\\n        of mean-variance optimization\\n\\n        .. math::\\n\\n            w = (\\\\delta \\\\Sigma)^{-1} E(R)\\n\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :return: asset weights implied by returns\\n        :rtype: OrderedDict\\n        '\n    if risk_aversion is None:\n        risk_aversion = self.risk_aversion\n    self.posterior_rets = self.bl_returns()\n    A = risk_aversion * self.cov_matrix\n    b = self.posterior_rets\n    raw_weights = np.linalg.solve(A, b)\n    self.weights = raw_weights / raw_weights.sum()\n    return self._make_output_weights()",
            "def bl_weights(self, risk_aversion=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Compute the weights implied by the posterior returns, given the\\n        market price of risk. Technically this can be applied to any\\n        estimate of the expected returns, and is in fact a special case\\n        of mean-variance optimization\\n\\n        .. math::\\n\\n            w = (\\\\delta \\\\Sigma)^{-1} E(R)\\n\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :return: asset weights implied by returns\\n        :rtype: OrderedDict\\n        '\n    if risk_aversion is None:\n        risk_aversion = self.risk_aversion\n    self.posterior_rets = self.bl_returns()\n    A = risk_aversion * self.cov_matrix\n    b = self.posterior_rets\n    raw_weights = np.linalg.solve(A, b)\n    self.weights = raw_weights / raw_weights.sum()\n    return self._make_output_weights()",
            "def bl_weights(self, risk_aversion=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Compute the weights implied by the posterior returns, given the\\n        market price of risk. Technically this can be applied to any\\n        estimate of the expected returns, and is in fact a special case\\n        of mean-variance optimization\\n\\n        .. math::\\n\\n            w = (\\\\delta \\\\Sigma)^{-1} E(R)\\n\\n        :param risk_aversion: risk aversion parameter, defaults to 1\\n        :type risk_aversion: positive float, optional\\n        :return: asset weights implied by returns\\n        :rtype: OrderedDict\\n        '\n    if risk_aversion is None:\n        risk_aversion = self.risk_aversion\n    self.posterior_rets = self.bl_returns()\n    A = risk_aversion * self.cov_matrix\n    b = self.posterior_rets\n    raw_weights = np.linalg.solve(A, b)\n    self.weights = raw_weights / raw_weights.sum()\n    return self._make_output_weights()"
        ]
    },
    {
        "func_name": "optimize",
        "original": "def optimize(self, risk_aversion=None):\n    \"\"\"\n        Alias for bl_weights for consistency with other methods.\n        \"\"\"\n    return self.bl_weights(risk_aversion)",
        "mutated": [
            "def optimize(self, risk_aversion=None):\n    if False:\n        i = 10\n    '\\n        Alias for bl_weights for consistency with other methods.\\n        '\n    return self.bl_weights(risk_aversion)",
            "def optimize(self, risk_aversion=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Alias for bl_weights for consistency with other methods.\\n        '\n    return self.bl_weights(risk_aversion)",
            "def optimize(self, risk_aversion=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Alias for bl_weights for consistency with other methods.\\n        '\n    return self.bl_weights(risk_aversion)",
            "def optimize(self, risk_aversion=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Alias for bl_weights for consistency with other methods.\\n        '\n    return self.bl_weights(risk_aversion)",
            "def optimize(self, risk_aversion=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Alias for bl_weights for consistency with other methods.\\n        '\n    return self.bl_weights(risk_aversion)"
        ]
    },
    {
        "func_name": "portfolio_performance",
        "original": "def portfolio_performance(self, verbose=False, risk_free_rate=0.02):\n    \"\"\"\n        After optimising, calculate (and optionally print) the performance of the optimal\n        portfolio. Currently calculates expected return, volatility, and the Sharpe ratio.\n        This method uses the BL posterior returns and covariance matrix.\n\n        :param verbose: whether performance should be printed, defaults to False\n        :type verbose: bool, optional\n        :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\n                               The period of the risk-free rate should correspond to the\n                               frequency of expected returns.\n        :type risk_free_rate: float, optional\n        :raises ValueError: if weights have not been calculated yet\n        :return: expected return, volatility, Sharpe ratio.\n        :rtype: (float, float, float)\n        \"\"\"\n    if self.posterior_cov is None:\n        self.posterior_cov = self.bl_cov()\n    return base_optimizer.portfolio_performance(self.weights, self.posterior_rets, self.posterior_cov, verbose, risk_free_rate)",
        "mutated": [
            "def portfolio_performance(self, verbose=False, risk_free_rate=0.02):\n    if False:\n        i = 10\n    '\\n        After optimising, calculate (and optionally print) the performance of the optimal\\n        portfolio. Currently calculates expected return, volatility, and the Sharpe ratio.\\n        This method uses the BL posterior returns and covariance matrix.\\n\\n        :param verbose: whether performance should be printed, defaults to False\\n        :type verbose: bool, optional\\n        :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                               The period of the risk-free rate should correspond to the\\n                               frequency of expected returns.\\n        :type risk_free_rate: float, optional\\n        :raises ValueError: if weights have not been calculated yet\\n        :return: expected return, volatility, Sharpe ratio.\\n        :rtype: (float, float, float)\\n        '\n    if self.posterior_cov is None:\n        self.posterior_cov = self.bl_cov()\n    return base_optimizer.portfolio_performance(self.weights, self.posterior_rets, self.posterior_cov, verbose, risk_free_rate)",
            "def portfolio_performance(self, verbose=False, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        After optimising, calculate (and optionally print) the performance of the optimal\\n        portfolio. Currently calculates expected return, volatility, and the Sharpe ratio.\\n        This method uses the BL posterior returns and covariance matrix.\\n\\n        :param verbose: whether performance should be printed, defaults to False\\n        :type verbose: bool, optional\\n        :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                               The period of the risk-free rate should correspond to the\\n                               frequency of expected returns.\\n        :type risk_free_rate: float, optional\\n        :raises ValueError: if weights have not been calculated yet\\n        :return: expected return, volatility, Sharpe ratio.\\n        :rtype: (float, float, float)\\n        '\n    if self.posterior_cov is None:\n        self.posterior_cov = self.bl_cov()\n    return base_optimizer.portfolio_performance(self.weights, self.posterior_rets, self.posterior_cov, verbose, risk_free_rate)",
            "def portfolio_performance(self, verbose=False, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        After optimising, calculate (and optionally print) the performance of the optimal\\n        portfolio. Currently calculates expected return, volatility, and the Sharpe ratio.\\n        This method uses the BL posterior returns and covariance matrix.\\n\\n        :param verbose: whether performance should be printed, defaults to False\\n        :type verbose: bool, optional\\n        :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                               The period of the risk-free rate should correspond to the\\n                               frequency of expected returns.\\n        :type risk_free_rate: float, optional\\n        :raises ValueError: if weights have not been calculated yet\\n        :return: expected return, volatility, Sharpe ratio.\\n        :rtype: (float, float, float)\\n        '\n    if self.posterior_cov is None:\n        self.posterior_cov = self.bl_cov()\n    return base_optimizer.portfolio_performance(self.weights, self.posterior_rets, self.posterior_cov, verbose, risk_free_rate)",
            "def portfolio_performance(self, verbose=False, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        After optimising, calculate (and optionally print) the performance of the optimal\\n        portfolio. Currently calculates expected return, volatility, and the Sharpe ratio.\\n        This method uses the BL posterior returns and covariance matrix.\\n\\n        :param verbose: whether performance should be printed, defaults to False\\n        :type verbose: bool, optional\\n        :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                               The period of the risk-free rate should correspond to the\\n                               frequency of expected returns.\\n        :type risk_free_rate: float, optional\\n        :raises ValueError: if weights have not been calculated yet\\n        :return: expected return, volatility, Sharpe ratio.\\n        :rtype: (float, float, float)\\n        '\n    if self.posterior_cov is None:\n        self.posterior_cov = self.bl_cov()\n    return base_optimizer.portfolio_performance(self.weights, self.posterior_rets, self.posterior_cov, verbose, risk_free_rate)",
            "def portfolio_performance(self, verbose=False, risk_free_rate=0.02):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        After optimising, calculate (and optionally print) the performance of the optimal\\n        portfolio. Currently calculates expected return, volatility, and the Sharpe ratio.\\n        This method uses the BL posterior returns and covariance matrix.\\n\\n        :param verbose: whether performance should be printed, defaults to False\\n        :type verbose: bool, optional\\n        :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                               The period of the risk-free rate should correspond to the\\n                               frequency of expected returns.\\n        :type risk_free_rate: float, optional\\n        :raises ValueError: if weights have not been calculated yet\\n        :return: expected return, volatility, Sharpe ratio.\\n        :rtype: (float, float, float)\\n        '\n    if self.posterior_cov is None:\n        self.posterior_cov = self.bl_cov()\n    return base_optimizer.portfolio_performance(self.weights, self.posterior_rets, self.posterior_cov, verbose, risk_free_rate)"
        ]
    }
]