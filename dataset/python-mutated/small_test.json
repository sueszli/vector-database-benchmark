[
    {
        "func_name": "test_biased_game",
        "original": "def test_biased_game(self, trials=100, atol=1e-05, rtol=1e-05, seed=1234):\n    \"\"\"Test best responses to sampled opp. actions in BiasedGame are biased.\"\"\"\n    game = small.BiasedGame(seed)\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        dirichlet_alpha = np.ones(game.num_strategies()[0])\n        dist = random.dirichlet(dirichlet_alpha)\n        sample_best_responses = np.argmax(game.payoff_tensor()[0], axis=0)\n        estimated_best_response = np.dot(sample_best_responses, dist)\n        true_best_response = game.best_response(dist)\n        successes += [not np.allclose(estimated_best_response, true_best_response, rtol, atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('bias rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'best responses should be biased more often')",
        "mutated": [
            "def test_biased_game(self, trials=100, atol=1e-05, rtol=1e-05, seed=1234):\n    if False:\n        i = 10\n    'Test best responses to sampled opp. actions in BiasedGame are biased.'\n    game = small.BiasedGame(seed)\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        dirichlet_alpha = np.ones(game.num_strategies()[0])\n        dist = random.dirichlet(dirichlet_alpha)\n        sample_best_responses = np.argmax(game.payoff_tensor()[0], axis=0)\n        estimated_best_response = np.dot(sample_best_responses, dist)\n        true_best_response = game.best_response(dist)\n        successes += [not np.allclose(estimated_best_response, true_best_response, rtol, atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('bias rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'best responses should be biased more often')",
            "def test_biased_game(self, trials=100, atol=1e-05, rtol=1e-05, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test best responses to sampled opp. actions in BiasedGame are biased.'\n    game = small.BiasedGame(seed)\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        dirichlet_alpha = np.ones(game.num_strategies()[0])\n        dist = random.dirichlet(dirichlet_alpha)\n        sample_best_responses = np.argmax(game.payoff_tensor()[0], axis=0)\n        estimated_best_response = np.dot(sample_best_responses, dist)\n        true_best_response = game.best_response(dist)\n        successes += [not np.allclose(estimated_best_response, true_best_response, rtol, atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('bias rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'best responses should be biased more often')",
            "def test_biased_game(self, trials=100, atol=1e-05, rtol=1e-05, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test best responses to sampled opp. actions in BiasedGame are biased.'\n    game = small.BiasedGame(seed)\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        dirichlet_alpha = np.ones(game.num_strategies()[0])\n        dist = random.dirichlet(dirichlet_alpha)\n        sample_best_responses = np.argmax(game.payoff_tensor()[0], axis=0)\n        estimated_best_response = np.dot(sample_best_responses, dist)\n        true_best_response = game.best_response(dist)\n        successes += [not np.allclose(estimated_best_response, true_best_response, rtol, atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('bias rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'best responses should be biased more often')",
            "def test_biased_game(self, trials=100, atol=1e-05, rtol=1e-05, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test best responses to sampled opp. actions in BiasedGame are biased.'\n    game = small.BiasedGame(seed)\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        dirichlet_alpha = np.ones(game.num_strategies()[0])\n        dist = random.dirichlet(dirichlet_alpha)\n        sample_best_responses = np.argmax(game.payoff_tensor()[0], axis=0)\n        estimated_best_response = np.dot(sample_best_responses, dist)\n        true_best_response = game.best_response(dist)\n        successes += [not np.allclose(estimated_best_response, true_best_response, rtol, atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('bias rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'best responses should be biased more often')",
            "def test_biased_game(self, trials=100, atol=1e-05, rtol=1e-05, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test best responses to sampled opp. actions in BiasedGame are biased.'\n    game = small.BiasedGame(seed)\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        dirichlet_alpha = np.ones(game.num_strategies()[0])\n        dist = random.dirichlet(dirichlet_alpha)\n        sample_best_responses = np.argmax(game.payoff_tensor()[0], axis=0)\n        estimated_best_response = np.dot(sample_best_responses, dist)\n        true_best_response = game.best_response(dist)\n        successes += [not np.allclose(estimated_best_response, true_best_response, rtol, atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('bias rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'best responses should be biased more often')"
        ]
    },
    {
        "func_name": "simp_to_euc",
        "original": "@staticmethod\ndef simp_to_euc(a, b, center):\n    \"\"\"Transforms a point [a, b] on the simplex to Euclidean space.\n\n      /\\\\   ^ b\n     /  \\\\  |\n    /____\\\\ --> a\n\n    Args:\n      a: horizonal deviation from center\n      b: vertical deviation from center\n      center: center of ref frame given in [x, y, z] Euclidean coordinates\n    Returns:\n      1-d np.array of len 3, i.e., np.array([x, y, z])\n    \"\"\"\n    transform = np.array([[0.5, -0.5, 0], [-0.5, -0.5, 1], [1, 1, 1]]).T\n    transform /= np.linalg.norm(transform, axis=0)\n    return transform.dot(np.array([a, b, 0])) + center",
        "mutated": [
            "@staticmethod\ndef simp_to_euc(a, b, center):\n    if False:\n        i = 10\n    'Transforms a point [a, b] on the simplex to Euclidean space.\\n\\n      /\\\\   ^ b\\n     /  \\\\  |\\n    /____\\\\ --> a\\n\\n    Args:\\n      a: horizonal deviation from center\\n      b: vertical deviation from center\\n      center: center of ref frame given in [x, y, z] Euclidean coordinates\\n    Returns:\\n      1-d np.array of len 3, i.e., np.array([x, y, z])\\n    '\n    transform = np.array([[0.5, -0.5, 0], [-0.5, -0.5, 1], [1, 1, 1]]).T\n    transform /= np.linalg.norm(transform, axis=0)\n    return transform.dot(np.array([a, b, 0])) + center",
            "@staticmethod\ndef simp_to_euc(a, b, center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Transforms a point [a, b] on the simplex to Euclidean space.\\n\\n      /\\\\   ^ b\\n     /  \\\\  |\\n    /____\\\\ --> a\\n\\n    Args:\\n      a: horizonal deviation from center\\n      b: vertical deviation from center\\n      center: center of ref frame given in [x, y, z] Euclidean coordinates\\n    Returns:\\n      1-d np.array of len 3, i.e., np.array([x, y, z])\\n    '\n    transform = np.array([[0.5, -0.5, 0], [-0.5, -0.5, 1], [1, 1, 1]]).T\n    transform /= np.linalg.norm(transform, axis=0)\n    return transform.dot(np.array([a, b, 0])) + center",
            "@staticmethod\ndef simp_to_euc(a, b, center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Transforms a point [a, b] on the simplex to Euclidean space.\\n\\n      /\\\\   ^ b\\n     /  \\\\  |\\n    /____\\\\ --> a\\n\\n    Args:\\n      a: horizonal deviation from center\\n      b: vertical deviation from center\\n      center: center of ref frame given in [x, y, z] Euclidean coordinates\\n    Returns:\\n      1-d np.array of len 3, i.e., np.array([x, y, z])\\n    '\n    transform = np.array([[0.5, -0.5, 0], [-0.5, -0.5, 1], [1, 1, 1]]).T\n    transform /= np.linalg.norm(transform, axis=0)\n    return transform.dot(np.array([a, b, 0])) + center",
            "@staticmethod\ndef simp_to_euc(a, b, center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Transforms a point [a, b] on the simplex to Euclidean space.\\n\\n      /\\\\   ^ b\\n     /  \\\\  |\\n    /____\\\\ --> a\\n\\n    Args:\\n      a: horizonal deviation from center\\n      b: vertical deviation from center\\n      center: center of ref frame given in [x, y, z] Euclidean coordinates\\n    Returns:\\n      1-d np.array of len 3, i.e., np.array([x, y, z])\\n    '\n    transform = np.array([[0.5, -0.5, 0], [-0.5, -0.5, 1], [1, 1, 1]]).T\n    transform /= np.linalg.norm(transform, axis=0)\n    return transform.dot(np.array([a, b, 0])) + center",
            "@staticmethod\ndef simp_to_euc(a, b, center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Transforms a point [a, b] on the simplex to Euclidean space.\\n\\n      /\\\\   ^ b\\n     /  \\\\  |\\n    /____\\\\ --> a\\n\\n    Args:\\n      a: horizonal deviation from center\\n      b: vertical deviation from center\\n      center: center of ref frame given in [x, y, z] Euclidean coordinates\\n    Returns:\\n      1-d np.array of len 3, i.e., np.array([x, y, z])\\n    '\n    transform = np.array([[0.5, -0.5, 0], [-0.5, -0.5, 1], [1, 1, 1]]).T\n    transform /= np.linalg.norm(transform, axis=0)\n    return transform.dot(np.array([a, b, 0])) + center"
        ]
    },
    {
        "func_name": "test_spiral_game",
        "original": "@parameterized.named_parameters(('up_down', 0.0, 0.1, 0.0, -0.1, -1.0), ('left_right', -0.1, 0.0, 0.1, 0.0, -1.0), ('up_left', 0.0, 0.1, -0.1, 0.0, 0.0), ('up_right', 0.0, 0.1, 0.1, 0.0, 0.0), ('down_left', 0.0, -0.1, -0.1, 0.0, 0.0), ('down_right', 0.0, -0.1, 0.1, 0.0, 0.0))\ndef test_spiral_game(self, dx_1, dy_1, dx_2, dy_2, expected_cos_sim, trials=100, eps=0.1, seed=1234):\n    \"\"\"Test that gradients on simplex rotate around SpiralGame's center.\"\"\"\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        (dx, dy) = eps * (random.rand(2) * 2 - 1)\n        center = self.simp_to_euc(dx, dy, np.ones(3) / 3.0)\n        game = small.SpiralGame(center, seed)\n        pt = game.payoff_tensor()[0]\n        point_1 = self.simp_to_euc(dx_1, dy_1, game.center)\n        point_2 = self.simp_to_euc(dx_2, dy_2, game.center)\n        grad_1 = simplex.project_grad(pt.dot(point_1))\n        grad_2 = simplex.project_grad(pt.dot(point_2))\n        norm = np.linalg.norm(grad_1) * np.linalg.norm(grad_2)\n        cos_sim = grad_1.dot(grad_2) / norm\n        successes += [np.abs(cos_sim - expected_cos_sim) < 1e-05]\n    perc = 100 * np.mean(successes)\n    logging.info('alignment success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'gradient field should exhibit cycles')",
        "mutated": [
            "@parameterized.named_parameters(('up_down', 0.0, 0.1, 0.0, -0.1, -1.0), ('left_right', -0.1, 0.0, 0.1, 0.0, -1.0), ('up_left', 0.0, 0.1, -0.1, 0.0, 0.0), ('up_right', 0.0, 0.1, 0.1, 0.0, 0.0), ('down_left', 0.0, -0.1, -0.1, 0.0, 0.0), ('down_right', 0.0, -0.1, 0.1, 0.0, 0.0))\ndef test_spiral_game(self, dx_1, dy_1, dx_2, dy_2, expected_cos_sim, trials=100, eps=0.1, seed=1234):\n    if False:\n        i = 10\n    \"Test that gradients on simplex rotate around SpiralGame's center.\"\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        (dx, dy) = eps * (random.rand(2) * 2 - 1)\n        center = self.simp_to_euc(dx, dy, np.ones(3) / 3.0)\n        game = small.SpiralGame(center, seed)\n        pt = game.payoff_tensor()[0]\n        point_1 = self.simp_to_euc(dx_1, dy_1, game.center)\n        point_2 = self.simp_to_euc(dx_2, dy_2, game.center)\n        grad_1 = simplex.project_grad(pt.dot(point_1))\n        grad_2 = simplex.project_grad(pt.dot(point_2))\n        norm = np.linalg.norm(grad_1) * np.linalg.norm(grad_2)\n        cos_sim = grad_1.dot(grad_2) / norm\n        successes += [np.abs(cos_sim - expected_cos_sim) < 1e-05]\n    perc = 100 * np.mean(successes)\n    logging.info('alignment success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'gradient field should exhibit cycles')",
            "@parameterized.named_parameters(('up_down', 0.0, 0.1, 0.0, -0.1, -1.0), ('left_right', -0.1, 0.0, 0.1, 0.0, -1.0), ('up_left', 0.0, 0.1, -0.1, 0.0, 0.0), ('up_right', 0.0, 0.1, 0.1, 0.0, 0.0), ('down_left', 0.0, -0.1, -0.1, 0.0, 0.0), ('down_right', 0.0, -0.1, 0.1, 0.0, 0.0))\ndef test_spiral_game(self, dx_1, dy_1, dx_2, dy_2, expected_cos_sim, trials=100, eps=0.1, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Test that gradients on simplex rotate around SpiralGame's center.\"\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        (dx, dy) = eps * (random.rand(2) * 2 - 1)\n        center = self.simp_to_euc(dx, dy, np.ones(3) / 3.0)\n        game = small.SpiralGame(center, seed)\n        pt = game.payoff_tensor()[0]\n        point_1 = self.simp_to_euc(dx_1, dy_1, game.center)\n        point_2 = self.simp_to_euc(dx_2, dy_2, game.center)\n        grad_1 = simplex.project_grad(pt.dot(point_1))\n        grad_2 = simplex.project_grad(pt.dot(point_2))\n        norm = np.linalg.norm(grad_1) * np.linalg.norm(grad_2)\n        cos_sim = grad_1.dot(grad_2) / norm\n        successes += [np.abs(cos_sim - expected_cos_sim) < 1e-05]\n    perc = 100 * np.mean(successes)\n    logging.info('alignment success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'gradient field should exhibit cycles')",
            "@parameterized.named_parameters(('up_down', 0.0, 0.1, 0.0, -0.1, -1.0), ('left_right', -0.1, 0.0, 0.1, 0.0, -1.0), ('up_left', 0.0, 0.1, -0.1, 0.0, 0.0), ('up_right', 0.0, 0.1, 0.1, 0.0, 0.0), ('down_left', 0.0, -0.1, -0.1, 0.0, 0.0), ('down_right', 0.0, -0.1, 0.1, 0.0, 0.0))\ndef test_spiral_game(self, dx_1, dy_1, dx_2, dy_2, expected_cos_sim, trials=100, eps=0.1, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Test that gradients on simplex rotate around SpiralGame's center.\"\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        (dx, dy) = eps * (random.rand(2) * 2 - 1)\n        center = self.simp_to_euc(dx, dy, np.ones(3) / 3.0)\n        game = small.SpiralGame(center, seed)\n        pt = game.payoff_tensor()[0]\n        point_1 = self.simp_to_euc(dx_1, dy_1, game.center)\n        point_2 = self.simp_to_euc(dx_2, dy_2, game.center)\n        grad_1 = simplex.project_grad(pt.dot(point_1))\n        grad_2 = simplex.project_grad(pt.dot(point_2))\n        norm = np.linalg.norm(grad_1) * np.linalg.norm(grad_2)\n        cos_sim = grad_1.dot(grad_2) / norm\n        successes += [np.abs(cos_sim - expected_cos_sim) < 1e-05]\n    perc = 100 * np.mean(successes)\n    logging.info('alignment success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'gradient field should exhibit cycles')",
            "@parameterized.named_parameters(('up_down', 0.0, 0.1, 0.0, -0.1, -1.0), ('left_right', -0.1, 0.0, 0.1, 0.0, -1.0), ('up_left', 0.0, 0.1, -0.1, 0.0, 0.0), ('up_right', 0.0, 0.1, 0.1, 0.0, 0.0), ('down_left', 0.0, -0.1, -0.1, 0.0, 0.0), ('down_right', 0.0, -0.1, 0.1, 0.0, 0.0))\ndef test_spiral_game(self, dx_1, dy_1, dx_2, dy_2, expected_cos_sim, trials=100, eps=0.1, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Test that gradients on simplex rotate around SpiralGame's center.\"\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        (dx, dy) = eps * (random.rand(2) * 2 - 1)\n        center = self.simp_to_euc(dx, dy, np.ones(3) / 3.0)\n        game = small.SpiralGame(center, seed)\n        pt = game.payoff_tensor()[0]\n        point_1 = self.simp_to_euc(dx_1, dy_1, game.center)\n        point_2 = self.simp_to_euc(dx_2, dy_2, game.center)\n        grad_1 = simplex.project_grad(pt.dot(point_1))\n        grad_2 = simplex.project_grad(pt.dot(point_2))\n        norm = np.linalg.norm(grad_1) * np.linalg.norm(grad_2)\n        cos_sim = grad_1.dot(grad_2) / norm\n        successes += [np.abs(cos_sim - expected_cos_sim) < 1e-05]\n    perc = 100 * np.mean(successes)\n    logging.info('alignment success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'gradient field should exhibit cycles')",
            "@parameterized.named_parameters(('up_down', 0.0, 0.1, 0.0, -0.1, -1.0), ('left_right', -0.1, 0.0, 0.1, 0.0, -1.0), ('up_left', 0.0, 0.1, -0.1, 0.0, 0.0), ('up_right', 0.0, 0.1, 0.1, 0.0, 0.0), ('down_left', 0.0, -0.1, -0.1, 0.0, 0.0), ('down_right', 0.0, -0.1, 0.1, 0.0, 0.0))\ndef test_spiral_game(self, dx_1, dy_1, dx_2, dy_2, expected_cos_sim, trials=100, eps=0.1, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Test that gradients on simplex rotate around SpiralGame's center.\"\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        (dx, dy) = eps * (random.rand(2) * 2 - 1)\n        center = self.simp_to_euc(dx, dy, np.ones(3) / 3.0)\n        game = small.SpiralGame(center, seed)\n        pt = game.payoff_tensor()[0]\n        point_1 = self.simp_to_euc(dx_1, dy_1, game.center)\n        point_2 = self.simp_to_euc(dx_2, dy_2, game.center)\n        grad_1 = simplex.project_grad(pt.dot(point_1))\n        grad_2 = simplex.project_grad(pt.dot(point_2))\n        norm = np.linalg.norm(grad_1) * np.linalg.norm(grad_2)\n        cos_sim = grad_1.dot(grad_2) / norm\n        successes += [np.abs(cos_sim - expected_cos_sim) < 1e-05]\n    perc = 100 * np.mean(successes)\n    logging.info('alignment success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 99.0, 'gradient field should exhibit cycles')"
        ]
    }
]