[
    {
        "func_name": "__init__",
        "original": "def __init__(self, fx_vol_surface=None, premium_output=market_constants.fx_options_premium_output, delta_output=market_constants.fx_options_delta_output):\n    self._calendar = Calendar()\n    self._fx_vol_surface = fx_vol_surface\n    self._fx_forwards_pricer = FXForwardsPricer()\n    self._premium_output = premium_output\n    self._delta_output = delta_output",
        "mutated": [
            "def __init__(self, fx_vol_surface=None, premium_output=market_constants.fx_options_premium_output, delta_output=market_constants.fx_options_delta_output):\n    if False:\n        i = 10\n    self._calendar = Calendar()\n    self._fx_vol_surface = fx_vol_surface\n    self._fx_forwards_pricer = FXForwardsPricer()\n    self._premium_output = premium_output\n    self._delta_output = delta_output",
            "def __init__(self, fx_vol_surface=None, premium_output=market_constants.fx_options_premium_output, delta_output=market_constants.fx_options_delta_output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._calendar = Calendar()\n    self._fx_vol_surface = fx_vol_surface\n    self._fx_forwards_pricer = FXForwardsPricer()\n    self._premium_output = premium_output\n    self._delta_output = delta_output",
            "def __init__(self, fx_vol_surface=None, premium_output=market_constants.fx_options_premium_output, delta_output=market_constants.fx_options_delta_output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._calendar = Calendar()\n    self._fx_vol_surface = fx_vol_surface\n    self._fx_forwards_pricer = FXForwardsPricer()\n    self._premium_output = premium_output\n    self._delta_output = delta_output",
            "def __init__(self, fx_vol_surface=None, premium_output=market_constants.fx_options_premium_output, delta_output=market_constants.fx_options_delta_output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._calendar = Calendar()\n    self._fx_vol_surface = fx_vol_surface\n    self._fx_forwards_pricer = FXForwardsPricer()\n    self._premium_output = premium_output\n    self._delta_output = delta_output",
            "def __init__(self, fx_vol_surface=None, premium_output=market_constants.fx_options_premium_output, delta_output=market_constants.fx_options_delta_output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._calendar = Calendar()\n    self._fx_vol_surface = fx_vol_surface\n    self._fx_forwards_pricer = FXForwardsPricer()\n    self._premium_output = premium_output\n    self._delta_output = delta_output"
        ]
    },
    {
        "func_name": "_price_option",
        "original": "def _price_option(contract_type_, contract_type_fin_):\n    for i in range(len(expiry_date)):\n        built_vol_surface = False\n        if isinstance(strike[i], str):\n            if not built_vol_surface:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n                fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                built_vol_surface = True\n            if strike[i] == 'atm':\n                strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                if use_atm_quoted:\n                    vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                else:\n                    vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n            elif strike[i] == 'atms':\n                strike[i] = fx_vol_surface.get_spot()\n            elif strike[i] == 'atmf':\n                strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n            elif strike[i] == '25d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n            elif strike[i] == '10d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n        if not built_vol_surface:\n            try:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n            except:\n                logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n        if np.isnan(vol[i]):\n            if tenor is None:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n            else:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n        model = FinModelBlackScholes(float(vol[i]))\n        logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n        option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n        spot[i] = fx_vol_surface.get_spot()\n        ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n        option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n        delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]",
        "mutated": [
            "def _price_option(contract_type_, contract_type_fin_):\n    if False:\n        i = 10\n    for i in range(len(expiry_date)):\n        built_vol_surface = False\n        if isinstance(strike[i], str):\n            if not built_vol_surface:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n                fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                built_vol_surface = True\n            if strike[i] == 'atm':\n                strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                if use_atm_quoted:\n                    vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                else:\n                    vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n            elif strike[i] == 'atms':\n                strike[i] = fx_vol_surface.get_spot()\n            elif strike[i] == 'atmf':\n                strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n            elif strike[i] == '25d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n            elif strike[i] == '10d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n        if not built_vol_surface:\n            try:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n            except:\n                logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n        if np.isnan(vol[i]):\n            if tenor is None:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n            else:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n        model = FinModelBlackScholes(float(vol[i]))\n        logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n        option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n        spot[i] = fx_vol_surface.get_spot()\n        ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n        option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n        delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]",
            "def _price_option(contract_type_, contract_type_fin_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for i in range(len(expiry_date)):\n        built_vol_surface = False\n        if isinstance(strike[i], str):\n            if not built_vol_surface:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n                fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                built_vol_surface = True\n            if strike[i] == 'atm':\n                strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                if use_atm_quoted:\n                    vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                else:\n                    vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n            elif strike[i] == 'atms':\n                strike[i] = fx_vol_surface.get_spot()\n            elif strike[i] == 'atmf':\n                strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n            elif strike[i] == '25d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n            elif strike[i] == '10d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n        if not built_vol_surface:\n            try:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n            except:\n                logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n        if np.isnan(vol[i]):\n            if tenor is None:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n            else:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n        model = FinModelBlackScholes(float(vol[i]))\n        logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n        option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n        spot[i] = fx_vol_surface.get_spot()\n        ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n        option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n        delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]",
            "def _price_option(contract_type_, contract_type_fin_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for i in range(len(expiry_date)):\n        built_vol_surface = False\n        if isinstance(strike[i], str):\n            if not built_vol_surface:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n                fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                built_vol_surface = True\n            if strike[i] == 'atm':\n                strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                if use_atm_quoted:\n                    vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                else:\n                    vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n            elif strike[i] == 'atms':\n                strike[i] = fx_vol_surface.get_spot()\n            elif strike[i] == 'atmf':\n                strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n            elif strike[i] == '25d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n            elif strike[i] == '10d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n        if not built_vol_surface:\n            try:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n            except:\n                logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n        if np.isnan(vol[i]):\n            if tenor is None:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n            else:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n        model = FinModelBlackScholes(float(vol[i]))\n        logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n        option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n        spot[i] = fx_vol_surface.get_spot()\n        ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n        option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n        delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]",
            "def _price_option(contract_type_, contract_type_fin_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for i in range(len(expiry_date)):\n        built_vol_surface = False\n        if isinstance(strike[i], str):\n            if not built_vol_surface:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n                fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                built_vol_surface = True\n            if strike[i] == 'atm':\n                strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                if use_atm_quoted:\n                    vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                else:\n                    vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n            elif strike[i] == 'atms':\n                strike[i] = fx_vol_surface.get_spot()\n            elif strike[i] == 'atmf':\n                strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n            elif strike[i] == '25d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n            elif strike[i] == '10d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n        if not built_vol_surface:\n            try:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n            except:\n                logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n        if np.isnan(vol[i]):\n            if tenor is None:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n            else:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n        model = FinModelBlackScholes(float(vol[i]))\n        logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n        option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n        spot[i] = fx_vol_surface.get_spot()\n        ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n        option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n        delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]",
            "def _price_option(contract_type_, contract_type_fin_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for i in range(len(expiry_date)):\n        built_vol_surface = False\n        if isinstance(strike[i], str):\n            if not built_vol_surface:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n                fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                built_vol_surface = True\n            if strike[i] == 'atm':\n                strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                if use_atm_quoted:\n                    vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                else:\n                    vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n            elif strike[i] == 'atms':\n                strike[i] = fx_vol_surface.get_spot()\n            elif strike[i] == 'atmf':\n                strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n            elif strike[i] == '25d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n            elif strike[i] == '10d-otm':\n                if 'call' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                elif 'put' in contract_type_:\n                    strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                    vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n        if not built_vol_surface:\n            try:\n                fx_vol_surface.build_vol_surface(horizon_date[i])\n            except:\n                logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n        if np.isnan(vol[i]):\n            if tenor is None:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n            else:\n                vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n        model = FinModelBlackScholes(float(vol[i]))\n        logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n        option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n        spot[i] = fx_vol_surface.get_spot()\n        ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n        option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n        'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n        delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]"
        ]
    },
    {
        "func_name": "price_instrument",
        "original": "def price_instrument(self, cross, horizon_date, strike, expiry_date=None, vol=None, notional=1000000, contract_type='european-call', tenor=None, fx_vol_surface=None, premium_output=None, delta_output=None, depo_tenor=None, use_atm_quoted=False, return_as_df=True):\n    \"\"\"Prices FX options for horizon dates/expiry dates given by the user from FX spot rates, FX volatility surface\n        and deposit rates.\n\n        Parameters\n        ----------\n        cross : str\n            Currency pair\n\n        horizon_date : DateTimeIndex\n            Horizon dates for options\n\n        strike : np.ndarray, float or str\n            Strike of option\n\n            eg. 'atm' - at-the-money\n            eg. 'atmf' - at-the-money forward\n            eg. 'atms' - at-the-money spot\n            eg. '25d-otm' - out-of-the-money 25d\n            eg. '10d-otm\n\n        expiry_date : DateTimeIndex (optional)\n            Expiry dates for options\n\n        vol : np.ndarray (optional)\n            Umplied vol for options\n\n        notional : float\n            Notional in base currency of the option\n\n        contract_type : str\n            What type of option are we pricing?\n\n            eg. 'european-call'\n\n        tenor : str (optional)\n            Tenor of option\n\n        fx_vol_surface : FXVolSurface\n            Interpolates FX vol surface\n\n        premium_output : str\n            'pct-for' (in base currency pct) or 'pct-dom' (in terms currency pct)\n\n        delta_output : bool\n            Also output delta of options\n\n        depo_tenor : str\n            Tenor of the deposit to use in the option pricing\n\n        use_atm_quoted : bool\n            True - takes the direct market quote\n            False - uses interpolated version\n\n        return_as_df : bool\n            True - returns output as DataFrame\n            False - returns output as np.ndarray\n\n        Returns\n        -------\n        DataFrame\n        \"\"\"\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if premium_output is None:\n        premium_output = self._premium_output\n    if delta_output is None:\n        delta_output = self._delta_output\n    logger = LoggerManager().getLogger(__name__)\n    field = fx_vol_surface._field\n    if isinstance(horizon_date, pd.Timestamp):\n        horizon_date = pd.DatetimeIndex([horizon_date])\n    else:\n        horizon_date = pd.DatetimeIndex(horizon_date)\n    if expiry_date is not None:\n        if isinstance(expiry_date, pd.Timestamp):\n            expiry_date = pd.DatetimeIndex([expiry_date])\n        else:\n            expiry_date = pd.DatetimeIndex(expiry_date)\n    else:\n        expiry_date = self._calendar.get_expiry_date_from_horizon_date(horizon_date, tenor, cal=cross)\n    if not isinstance(strike, np.ndarray):\n        old_strike = strike\n        if isinstance(strike, str):\n            strike = np.empty(len(horizon_date), dtype=object)\n        else:\n            strike = np.empty(len(horizon_date))\n        strike.fill(old_strike)\n    if not isinstance(vol, np.ndarray):\n        if vol is None:\n            vol = np.nan\n        old_vol = vol\n        vol = np.empty(len(horizon_date))\n        vol.fill(old_vol)\n    option_values = np.zeros(len(horizon_date))\n    spot = np.zeros(len(horizon_date))\n    delta = np.zeros(len(horizon_date))\n    intrinsic_values = np.zeros(len(horizon_date))\n\n    def _price_option(contract_type_, contract_type_fin_):\n        for i in range(len(expiry_date)):\n            built_vol_surface = False\n            if isinstance(strike[i], str):\n                if not built_vol_surface:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                    fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                    built_vol_surface = True\n                if strike[i] == 'atm':\n                    strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                    if use_atm_quoted:\n                        vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                    else:\n                        vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n                elif strike[i] == 'atms':\n                    strike[i] = fx_vol_surface.get_spot()\n                elif strike[i] == 'atmf':\n                    strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n                elif strike[i] == '25d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n                elif strike[i] == '10d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n            if not built_vol_surface:\n                try:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                except:\n                    logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n            if np.isnan(vol[i]):\n                if tenor is None:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n                else:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n            model = FinModelBlackScholes(float(vol[i]))\n            logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n            option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n            spot[i] = fx_vol_surface.get_spot()\n            ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n            option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n            delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]\n    if contract_type == 'european-call':\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-put':\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-straddle' or contract_type == 'european-strangle':\n        contract_type = 'european-call'\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n        contract_type = 'european-put'\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    if return_as_df:\n        option_prices_df = pd.DataFrame(index=horizon_date)\n        option_prices_df[cross + '-option-price.' + field] = option_values\n        option_prices_df[cross + '.' + field] = spot\n        option_prices_df[cross + '-strike.' + field] = strike\n        option_prices_df[cross + '-vol.' + field] = vol\n        option_prices_df[cross + '-delta.' + field] = delta\n        option_prices_df[cross + '.expiry-date'] = expiry_date\n        option_prices_df[cross + '-intrinsic-value.' + field] = intrinsic_values\n        return option_prices_df\n    return (option_values, spot, strike, vol, delta, expiry_date, intrinsic_values)",
        "mutated": [
            "def price_instrument(self, cross, horizon_date, strike, expiry_date=None, vol=None, notional=1000000, contract_type='european-call', tenor=None, fx_vol_surface=None, premium_output=None, delta_output=None, depo_tenor=None, use_atm_quoted=False, return_as_df=True):\n    if False:\n        i = 10\n    \"Prices FX options for horizon dates/expiry dates given by the user from FX spot rates, FX volatility surface\\n        and deposit rates.\\n\\n        Parameters\\n        ----------\\n        cross : str\\n            Currency pair\\n\\n        horizon_date : DateTimeIndex\\n            Horizon dates for options\\n\\n        strike : np.ndarray, float or str\\n            Strike of option\\n\\n            eg. 'atm' - at-the-money\\n            eg. 'atmf' - at-the-money forward\\n            eg. 'atms' - at-the-money spot\\n            eg. '25d-otm' - out-of-the-money 25d\\n            eg. '10d-otm\\n\\n        expiry_date : DateTimeIndex (optional)\\n            Expiry dates for options\\n\\n        vol : np.ndarray (optional)\\n            Umplied vol for options\\n\\n        notional : float\\n            Notional in base currency of the option\\n\\n        contract_type : str\\n            What type of option are we pricing?\\n\\n            eg. 'european-call'\\n\\n        tenor : str (optional)\\n            Tenor of option\\n\\n        fx_vol_surface : FXVolSurface\\n            Interpolates FX vol surface\\n\\n        premium_output : str\\n            'pct-for' (in base currency pct) or 'pct-dom' (in terms currency pct)\\n\\n        delta_output : bool\\n            Also output delta of options\\n\\n        depo_tenor : str\\n            Tenor of the deposit to use in the option pricing\\n\\n        use_atm_quoted : bool\\n            True - takes the direct market quote\\n            False - uses interpolated version\\n\\n        return_as_df : bool\\n            True - returns output as DataFrame\\n            False - returns output as np.ndarray\\n\\n        Returns\\n        -------\\n        DataFrame\\n        \"\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if premium_output is None:\n        premium_output = self._premium_output\n    if delta_output is None:\n        delta_output = self._delta_output\n    logger = LoggerManager().getLogger(__name__)\n    field = fx_vol_surface._field\n    if isinstance(horizon_date, pd.Timestamp):\n        horizon_date = pd.DatetimeIndex([horizon_date])\n    else:\n        horizon_date = pd.DatetimeIndex(horizon_date)\n    if expiry_date is not None:\n        if isinstance(expiry_date, pd.Timestamp):\n            expiry_date = pd.DatetimeIndex([expiry_date])\n        else:\n            expiry_date = pd.DatetimeIndex(expiry_date)\n    else:\n        expiry_date = self._calendar.get_expiry_date_from_horizon_date(horizon_date, tenor, cal=cross)\n    if not isinstance(strike, np.ndarray):\n        old_strike = strike\n        if isinstance(strike, str):\n            strike = np.empty(len(horizon_date), dtype=object)\n        else:\n            strike = np.empty(len(horizon_date))\n        strike.fill(old_strike)\n    if not isinstance(vol, np.ndarray):\n        if vol is None:\n            vol = np.nan\n        old_vol = vol\n        vol = np.empty(len(horizon_date))\n        vol.fill(old_vol)\n    option_values = np.zeros(len(horizon_date))\n    spot = np.zeros(len(horizon_date))\n    delta = np.zeros(len(horizon_date))\n    intrinsic_values = np.zeros(len(horizon_date))\n\n    def _price_option(contract_type_, contract_type_fin_):\n        for i in range(len(expiry_date)):\n            built_vol_surface = False\n            if isinstance(strike[i], str):\n                if not built_vol_surface:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                    fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                    built_vol_surface = True\n                if strike[i] == 'atm':\n                    strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                    if use_atm_quoted:\n                        vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                    else:\n                        vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n                elif strike[i] == 'atms':\n                    strike[i] = fx_vol_surface.get_spot()\n                elif strike[i] == 'atmf':\n                    strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n                elif strike[i] == '25d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n                elif strike[i] == '10d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n            if not built_vol_surface:\n                try:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                except:\n                    logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n            if np.isnan(vol[i]):\n                if tenor is None:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n                else:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n            model = FinModelBlackScholes(float(vol[i]))\n            logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n            option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n            spot[i] = fx_vol_surface.get_spot()\n            ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n            option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n            delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]\n    if contract_type == 'european-call':\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-put':\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-straddle' or contract_type == 'european-strangle':\n        contract_type = 'european-call'\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n        contract_type = 'european-put'\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    if return_as_df:\n        option_prices_df = pd.DataFrame(index=horizon_date)\n        option_prices_df[cross + '-option-price.' + field] = option_values\n        option_prices_df[cross + '.' + field] = spot\n        option_prices_df[cross + '-strike.' + field] = strike\n        option_prices_df[cross + '-vol.' + field] = vol\n        option_prices_df[cross + '-delta.' + field] = delta\n        option_prices_df[cross + '.expiry-date'] = expiry_date\n        option_prices_df[cross + '-intrinsic-value.' + field] = intrinsic_values\n        return option_prices_df\n    return (option_values, spot, strike, vol, delta, expiry_date, intrinsic_values)",
            "def price_instrument(self, cross, horizon_date, strike, expiry_date=None, vol=None, notional=1000000, contract_type='european-call', tenor=None, fx_vol_surface=None, premium_output=None, delta_output=None, depo_tenor=None, use_atm_quoted=False, return_as_df=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Prices FX options for horizon dates/expiry dates given by the user from FX spot rates, FX volatility surface\\n        and deposit rates.\\n\\n        Parameters\\n        ----------\\n        cross : str\\n            Currency pair\\n\\n        horizon_date : DateTimeIndex\\n            Horizon dates for options\\n\\n        strike : np.ndarray, float or str\\n            Strike of option\\n\\n            eg. 'atm' - at-the-money\\n            eg. 'atmf' - at-the-money forward\\n            eg. 'atms' - at-the-money spot\\n            eg. '25d-otm' - out-of-the-money 25d\\n            eg. '10d-otm\\n\\n        expiry_date : DateTimeIndex (optional)\\n            Expiry dates for options\\n\\n        vol : np.ndarray (optional)\\n            Umplied vol for options\\n\\n        notional : float\\n            Notional in base currency of the option\\n\\n        contract_type : str\\n            What type of option are we pricing?\\n\\n            eg. 'european-call'\\n\\n        tenor : str (optional)\\n            Tenor of option\\n\\n        fx_vol_surface : FXVolSurface\\n            Interpolates FX vol surface\\n\\n        premium_output : str\\n            'pct-for' (in base currency pct) or 'pct-dom' (in terms currency pct)\\n\\n        delta_output : bool\\n            Also output delta of options\\n\\n        depo_tenor : str\\n            Tenor of the deposit to use in the option pricing\\n\\n        use_atm_quoted : bool\\n            True - takes the direct market quote\\n            False - uses interpolated version\\n\\n        return_as_df : bool\\n            True - returns output as DataFrame\\n            False - returns output as np.ndarray\\n\\n        Returns\\n        -------\\n        DataFrame\\n        \"\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if premium_output is None:\n        premium_output = self._premium_output\n    if delta_output is None:\n        delta_output = self._delta_output\n    logger = LoggerManager().getLogger(__name__)\n    field = fx_vol_surface._field\n    if isinstance(horizon_date, pd.Timestamp):\n        horizon_date = pd.DatetimeIndex([horizon_date])\n    else:\n        horizon_date = pd.DatetimeIndex(horizon_date)\n    if expiry_date is not None:\n        if isinstance(expiry_date, pd.Timestamp):\n            expiry_date = pd.DatetimeIndex([expiry_date])\n        else:\n            expiry_date = pd.DatetimeIndex(expiry_date)\n    else:\n        expiry_date = self._calendar.get_expiry_date_from_horizon_date(horizon_date, tenor, cal=cross)\n    if not isinstance(strike, np.ndarray):\n        old_strike = strike\n        if isinstance(strike, str):\n            strike = np.empty(len(horizon_date), dtype=object)\n        else:\n            strike = np.empty(len(horizon_date))\n        strike.fill(old_strike)\n    if not isinstance(vol, np.ndarray):\n        if vol is None:\n            vol = np.nan\n        old_vol = vol\n        vol = np.empty(len(horizon_date))\n        vol.fill(old_vol)\n    option_values = np.zeros(len(horizon_date))\n    spot = np.zeros(len(horizon_date))\n    delta = np.zeros(len(horizon_date))\n    intrinsic_values = np.zeros(len(horizon_date))\n\n    def _price_option(contract_type_, contract_type_fin_):\n        for i in range(len(expiry_date)):\n            built_vol_surface = False\n            if isinstance(strike[i], str):\n                if not built_vol_surface:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                    fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                    built_vol_surface = True\n                if strike[i] == 'atm':\n                    strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                    if use_atm_quoted:\n                        vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                    else:\n                        vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n                elif strike[i] == 'atms':\n                    strike[i] = fx_vol_surface.get_spot()\n                elif strike[i] == 'atmf':\n                    strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n                elif strike[i] == '25d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n                elif strike[i] == '10d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n            if not built_vol_surface:\n                try:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                except:\n                    logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n            if np.isnan(vol[i]):\n                if tenor is None:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n                else:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n            model = FinModelBlackScholes(float(vol[i]))\n            logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n            option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n            spot[i] = fx_vol_surface.get_spot()\n            ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n            option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n            delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]\n    if contract_type == 'european-call':\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-put':\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-straddle' or contract_type == 'european-strangle':\n        contract_type = 'european-call'\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n        contract_type = 'european-put'\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    if return_as_df:\n        option_prices_df = pd.DataFrame(index=horizon_date)\n        option_prices_df[cross + '-option-price.' + field] = option_values\n        option_prices_df[cross + '.' + field] = spot\n        option_prices_df[cross + '-strike.' + field] = strike\n        option_prices_df[cross + '-vol.' + field] = vol\n        option_prices_df[cross + '-delta.' + field] = delta\n        option_prices_df[cross + '.expiry-date'] = expiry_date\n        option_prices_df[cross + '-intrinsic-value.' + field] = intrinsic_values\n        return option_prices_df\n    return (option_values, spot, strike, vol, delta, expiry_date, intrinsic_values)",
            "def price_instrument(self, cross, horizon_date, strike, expiry_date=None, vol=None, notional=1000000, contract_type='european-call', tenor=None, fx_vol_surface=None, premium_output=None, delta_output=None, depo_tenor=None, use_atm_quoted=False, return_as_df=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Prices FX options for horizon dates/expiry dates given by the user from FX spot rates, FX volatility surface\\n        and deposit rates.\\n\\n        Parameters\\n        ----------\\n        cross : str\\n            Currency pair\\n\\n        horizon_date : DateTimeIndex\\n            Horizon dates for options\\n\\n        strike : np.ndarray, float or str\\n            Strike of option\\n\\n            eg. 'atm' - at-the-money\\n            eg. 'atmf' - at-the-money forward\\n            eg. 'atms' - at-the-money spot\\n            eg. '25d-otm' - out-of-the-money 25d\\n            eg. '10d-otm\\n\\n        expiry_date : DateTimeIndex (optional)\\n            Expiry dates for options\\n\\n        vol : np.ndarray (optional)\\n            Umplied vol for options\\n\\n        notional : float\\n            Notional in base currency of the option\\n\\n        contract_type : str\\n            What type of option are we pricing?\\n\\n            eg. 'european-call'\\n\\n        tenor : str (optional)\\n            Tenor of option\\n\\n        fx_vol_surface : FXVolSurface\\n            Interpolates FX vol surface\\n\\n        premium_output : str\\n            'pct-for' (in base currency pct) or 'pct-dom' (in terms currency pct)\\n\\n        delta_output : bool\\n            Also output delta of options\\n\\n        depo_tenor : str\\n            Tenor of the deposit to use in the option pricing\\n\\n        use_atm_quoted : bool\\n            True - takes the direct market quote\\n            False - uses interpolated version\\n\\n        return_as_df : bool\\n            True - returns output as DataFrame\\n            False - returns output as np.ndarray\\n\\n        Returns\\n        -------\\n        DataFrame\\n        \"\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if premium_output is None:\n        premium_output = self._premium_output\n    if delta_output is None:\n        delta_output = self._delta_output\n    logger = LoggerManager().getLogger(__name__)\n    field = fx_vol_surface._field\n    if isinstance(horizon_date, pd.Timestamp):\n        horizon_date = pd.DatetimeIndex([horizon_date])\n    else:\n        horizon_date = pd.DatetimeIndex(horizon_date)\n    if expiry_date is not None:\n        if isinstance(expiry_date, pd.Timestamp):\n            expiry_date = pd.DatetimeIndex([expiry_date])\n        else:\n            expiry_date = pd.DatetimeIndex(expiry_date)\n    else:\n        expiry_date = self._calendar.get_expiry_date_from_horizon_date(horizon_date, tenor, cal=cross)\n    if not isinstance(strike, np.ndarray):\n        old_strike = strike\n        if isinstance(strike, str):\n            strike = np.empty(len(horizon_date), dtype=object)\n        else:\n            strike = np.empty(len(horizon_date))\n        strike.fill(old_strike)\n    if not isinstance(vol, np.ndarray):\n        if vol is None:\n            vol = np.nan\n        old_vol = vol\n        vol = np.empty(len(horizon_date))\n        vol.fill(old_vol)\n    option_values = np.zeros(len(horizon_date))\n    spot = np.zeros(len(horizon_date))\n    delta = np.zeros(len(horizon_date))\n    intrinsic_values = np.zeros(len(horizon_date))\n\n    def _price_option(contract_type_, contract_type_fin_):\n        for i in range(len(expiry_date)):\n            built_vol_surface = False\n            if isinstance(strike[i], str):\n                if not built_vol_surface:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                    fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                    built_vol_surface = True\n                if strike[i] == 'atm':\n                    strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                    if use_atm_quoted:\n                        vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                    else:\n                        vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n                elif strike[i] == 'atms':\n                    strike[i] = fx_vol_surface.get_spot()\n                elif strike[i] == 'atmf':\n                    strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n                elif strike[i] == '25d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n                elif strike[i] == '10d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n            if not built_vol_surface:\n                try:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                except:\n                    logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n            if np.isnan(vol[i]):\n                if tenor is None:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n                else:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n            model = FinModelBlackScholes(float(vol[i]))\n            logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n            option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n            spot[i] = fx_vol_surface.get_spot()\n            ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n            option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n            delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]\n    if contract_type == 'european-call':\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-put':\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-straddle' or contract_type == 'european-strangle':\n        contract_type = 'european-call'\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n        contract_type = 'european-put'\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    if return_as_df:\n        option_prices_df = pd.DataFrame(index=horizon_date)\n        option_prices_df[cross + '-option-price.' + field] = option_values\n        option_prices_df[cross + '.' + field] = spot\n        option_prices_df[cross + '-strike.' + field] = strike\n        option_prices_df[cross + '-vol.' + field] = vol\n        option_prices_df[cross + '-delta.' + field] = delta\n        option_prices_df[cross + '.expiry-date'] = expiry_date\n        option_prices_df[cross + '-intrinsic-value.' + field] = intrinsic_values\n        return option_prices_df\n    return (option_values, spot, strike, vol, delta, expiry_date, intrinsic_values)",
            "def price_instrument(self, cross, horizon_date, strike, expiry_date=None, vol=None, notional=1000000, contract_type='european-call', tenor=None, fx_vol_surface=None, premium_output=None, delta_output=None, depo_tenor=None, use_atm_quoted=False, return_as_df=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Prices FX options for horizon dates/expiry dates given by the user from FX spot rates, FX volatility surface\\n        and deposit rates.\\n\\n        Parameters\\n        ----------\\n        cross : str\\n            Currency pair\\n\\n        horizon_date : DateTimeIndex\\n            Horizon dates for options\\n\\n        strike : np.ndarray, float or str\\n            Strike of option\\n\\n            eg. 'atm' - at-the-money\\n            eg. 'atmf' - at-the-money forward\\n            eg. 'atms' - at-the-money spot\\n            eg. '25d-otm' - out-of-the-money 25d\\n            eg. '10d-otm\\n\\n        expiry_date : DateTimeIndex (optional)\\n            Expiry dates for options\\n\\n        vol : np.ndarray (optional)\\n            Umplied vol for options\\n\\n        notional : float\\n            Notional in base currency of the option\\n\\n        contract_type : str\\n            What type of option are we pricing?\\n\\n            eg. 'european-call'\\n\\n        tenor : str (optional)\\n            Tenor of option\\n\\n        fx_vol_surface : FXVolSurface\\n            Interpolates FX vol surface\\n\\n        premium_output : str\\n            'pct-for' (in base currency pct) or 'pct-dom' (in terms currency pct)\\n\\n        delta_output : bool\\n            Also output delta of options\\n\\n        depo_tenor : str\\n            Tenor of the deposit to use in the option pricing\\n\\n        use_atm_quoted : bool\\n            True - takes the direct market quote\\n            False - uses interpolated version\\n\\n        return_as_df : bool\\n            True - returns output as DataFrame\\n            False - returns output as np.ndarray\\n\\n        Returns\\n        -------\\n        DataFrame\\n        \"\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if premium_output is None:\n        premium_output = self._premium_output\n    if delta_output is None:\n        delta_output = self._delta_output\n    logger = LoggerManager().getLogger(__name__)\n    field = fx_vol_surface._field\n    if isinstance(horizon_date, pd.Timestamp):\n        horizon_date = pd.DatetimeIndex([horizon_date])\n    else:\n        horizon_date = pd.DatetimeIndex(horizon_date)\n    if expiry_date is not None:\n        if isinstance(expiry_date, pd.Timestamp):\n            expiry_date = pd.DatetimeIndex([expiry_date])\n        else:\n            expiry_date = pd.DatetimeIndex(expiry_date)\n    else:\n        expiry_date = self._calendar.get_expiry_date_from_horizon_date(horizon_date, tenor, cal=cross)\n    if not isinstance(strike, np.ndarray):\n        old_strike = strike\n        if isinstance(strike, str):\n            strike = np.empty(len(horizon_date), dtype=object)\n        else:\n            strike = np.empty(len(horizon_date))\n        strike.fill(old_strike)\n    if not isinstance(vol, np.ndarray):\n        if vol is None:\n            vol = np.nan\n        old_vol = vol\n        vol = np.empty(len(horizon_date))\n        vol.fill(old_vol)\n    option_values = np.zeros(len(horizon_date))\n    spot = np.zeros(len(horizon_date))\n    delta = np.zeros(len(horizon_date))\n    intrinsic_values = np.zeros(len(horizon_date))\n\n    def _price_option(contract_type_, contract_type_fin_):\n        for i in range(len(expiry_date)):\n            built_vol_surface = False\n            if isinstance(strike[i], str):\n                if not built_vol_surface:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                    fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                    built_vol_surface = True\n                if strike[i] == 'atm':\n                    strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                    if use_atm_quoted:\n                        vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                    else:\n                        vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n                elif strike[i] == 'atms':\n                    strike[i] = fx_vol_surface.get_spot()\n                elif strike[i] == 'atmf':\n                    strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n                elif strike[i] == '25d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n                elif strike[i] == '10d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n            if not built_vol_surface:\n                try:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                except:\n                    logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n            if np.isnan(vol[i]):\n                if tenor is None:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n                else:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n            model = FinModelBlackScholes(float(vol[i]))\n            logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n            option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n            spot[i] = fx_vol_surface.get_spot()\n            ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n            option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n            delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]\n    if contract_type == 'european-call':\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-put':\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-straddle' or contract_type == 'european-strangle':\n        contract_type = 'european-call'\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n        contract_type = 'european-put'\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    if return_as_df:\n        option_prices_df = pd.DataFrame(index=horizon_date)\n        option_prices_df[cross + '-option-price.' + field] = option_values\n        option_prices_df[cross + '.' + field] = spot\n        option_prices_df[cross + '-strike.' + field] = strike\n        option_prices_df[cross + '-vol.' + field] = vol\n        option_prices_df[cross + '-delta.' + field] = delta\n        option_prices_df[cross + '.expiry-date'] = expiry_date\n        option_prices_df[cross + '-intrinsic-value.' + field] = intrinsic_values\n        return option_prices_df\n    return (option_values, spot, strike, vol, delta, expiry_date, intrinsic_values)",
            "def price_instrument(self, cross, horizon_date, strike, expiry_date=None, vol=None, notional=1000000, contract_type='european-call', tenor=None, fx_vol_surface=None, premium_output=None, delta_output=None, depo_tenor=None, use_atm_quoted=False, return_as_df=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Prices FX options for horizon dates/expiry dates given by the user from FX spot rates, FX volatility surface\\n        and deposit rates.\\n\\n        Parameters\\n        ----------\\n        cross : str\\n            Currency pair\\n\\n        horizon_date : DateTimeIndex\\n            Horizon dates for options\\n\\n        strike : np.ndarray, float or str\\n            Strike of option\\n\\n            eg. 'atm' - at-the-money\\n            eg. 'atmf' - at-the-money forward\\n            eg. 'atms' - at-the-money spot\\n            eg. '25d-otm' - out-of-the-money 25d\\n            eg. '10d-otm\\n\\n        expiry_date : DateTimeIndex (optional)\\n            Expiry dates for options\\n\\n        vol : np.ndarray (optional)\\n            Umplied vol for options\\n\\n        notional : float\\n            Notional in base currency of the option\\n\\n        contract_type : str\\n            What type of option are we pricing?\\n\\n            eg. 'european-call'\\n\\n        tenor : str (optional)\\n            Tenor of option\\n\\n        fx_vol_surface : FXVolSurface\\n            Interpolates FX vol surface\\n\\n        premium_output : str\\n            'pct-for' (in base currency pct) or 'pct-dom' (in terms currency pct)\\n\\n        delta_output : bool\\n            Also output delta of options\\n\\n        depo_tenor : str\\n            Tenor of the deposit to use in the option pricing\\n\\n        use_atm_quoted : bool\\n            True - takes the direct market quote\\n            False - uses interpolated version\\n\\n        return_as_df : bool\\n            True - returns output as DataFrame\\n            False - returns output as np.ndarray\\n\\n        Returns\\n        -------\\n        DataFrame\\n        \"\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if premium_output is None:\n        premium_output = self._premium_output\n    if delta_output is None:\n        delta_output = self._delta_output\n    logger = LoggerManager().getLogger(__name__)\n    field = fx_vol_surface._field\n    if isinstance(horizon_date, pd.Timestamp):\n        horizon_date = pd.DatetimeIndex([horizon_date])\n    else:\n        horizon_date = pd.DatetimeIndex(horizon_date)\n    if expiry_date is not None:\n        if isinstance(expiry_date, pd.Timestamp):\n            expiry_date = pd.DatetimeIndex([expiry_date])\n        else:\n            expiry_date = pd.DatetimeIndex(expiry_date)\n    else:\n        expiry_date = self._calendar.get_expiry_date_from_horizon_date(horizon_date, tenor, cal=cross)\n    if not isinstance(strike, np.ndarray):\n        old_strike = strike\n        if isinstance(strike, str):\n            strike = np.empty(len(horizon_date), dtype=object)\n        else:\n            strike = np.empty(len(horizon_date))\n        strike.fill(old_strike)\n    if not isinstance(vol, np.ndarray):\n        if vol is None:\n            vol = np.nan\n        old_vol = vol\n        vol = np.empty(len(horizon_date))\n        vol.fill(old_vol)\n    option_values = np.zeros(len(horizon_date))\n    spot = np.zeros(len(horizon_date))\n    delta = np.zeros(len(horizon_date))\n    intrinsic_values = np.zeros(len(horizon_date))\n\n    def _price_option(contract_type_, contract_type_fin_):\n        for i in range(len(expiry_date)):\n            built_vol_surface = False\n            if isinstance(strike[i], str):\n                if not built_vol_surface:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                    fx_vol_surface.extract_vol_surface(num_strike_intervals=None)\n                    built_vol_surface = True\n                if strike[i] == 'atm':\n                    strike[i] = fx_vol_surface.get_atm_strike(tenor)\n                    if use_atm_quoted:\n                        vol[i] = fx_vol_surface.get_atm_quoted_vol(tenor) / 100.0\n                    else:\n                        vol[i] = fx_vol_surface.get_atm_vol(tenor) / 100.0\n                elif strike[i] == 'atms':\n                    strike[i] = fx_vol_surface.get_spot()\n                elif strike[i] == 'atmf':\n                    strike[i] = float(fx_vol_surface.get_all_market_data()[cross + '.close'][horizon_date[i]]) + float(fx_vol_surface.get_all_market_data()[cross + tenor + '.close'][horizon_date[i]]) / self._fx_forwards_pricer.get_forwards_divisor(cross[3:6])\n                elif strike[i] == '25d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_25d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_25d_put_vol(tenor) / 100.0\n                elif strike[i] == '10d-otm':\n                    if 'call' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_call_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_call_vol(tenor) / 100.0\n                    elif 'put' in contract_type_:\n                        strike[i] = fx_vol_surface.get_10d_put_strike(tenor)\n                        vol[i] = fx_vol_surface.get_10d_put_vol(tenor) / 100.0\n            if not built_vol_surface:\n                try:\n                    fx_vol_surface.build_vol_surface(horizon_date[i])\n                except:\n                    logger.warn('Failed to build vol surface for ' + str(horizon_date) + \", won't be able to interpolate vol\")\n            if np.isnan(vol[i]):\n                if tenor is None:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=expiry_date[i], tenor=None)\n                else:\n                    vol[i] = fx_vol_surface.calculate_vol_for_strike_expiry(strike[i], expiry_date=None, tenor=tenor)\n            model = FinModelBlackScholes(float(vol[i]))\n            logger.info('Pricing ' + contract_type_ + ' option, horizon date = ' + str(horizon_date[i]) + ', expiry date = ' + str(expiry_date[i]))\n            option = FinFXVanillaOption(self._findate(expiry_date[i]), strike[i], cross, contract_type_fin_, notional, cross[0:3])\n            spot[i] = fx_vol_surface.get_spot()\n            ' FinancePy will return the value in the following dictionary for values\\n                    {\\'v\\': vdf,\\n                    \"cash_dom\": cash_dom,\\n                    \"cash_for\": cash_for,\\n                    \"pips_dom\": pips_dom,\\n                    \"pips_for\": pips_for,\\n                    \"pct_dom\": pct_dom,\\n                    \"pct_for\": pct_for,\\n                    \"not_dom\": notional_dom,\\n                    \"not_for\": notional_for,\\n                    \"ccy_dom\": self._domName,\\n                    \"ccy_for\": self._forName}\\n                '\n            option_values[i] = option_values[i] + option.value(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            intrinsic_values[i] = intrinsic_values[i] + option.value(self._findate(expiry_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[premium_output.replace('-', '_')]\n            'FinancePy returns this dictionary for deltas\\n                    {\"pips_spot_delta\": pips_spot_delta,\\n                    \"pips_fwd_delta\": pips_fwd_delta,\\n                    \"pct_spot_delta_prem_adj\": pct_spot_delta_prem_adj,\\n                    \"pct_fwd_delta_prem_adj\": pct_fwd_delta_prem_adj}\\n                '\n            delta[i] = delta[i] + option.delta(self._findate(horizon_date[i]), spot[i], fx_vol_surface.get_dom_discount_curve(), fx_vol_surface.get_for_discount_curve(), model)[delta_output.replace('-', '_')]\n    if contract_type == 'european-call':\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-put':\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    elif contract_type == 'european-straddle' or contract_type == 'european-strangle':\n        contract_type = 'european-call'\n        contract_type_fin = FinOptionTypes.EUROPEAN_CALL\n        _price_option(contract_type, contract_type_fin)\n        contract_type = 'european-put'\n        contract_type_fin = FinOptionTypes.EUROPEAN_PUT\n        _price_option(contract_type, contract_type_fin)\n    if return_as_df:\n        option_prices_df = pd.DataFrame(index=horizon_date)\n        option_prices_df[cross + '-option-price.' + field] = option_values\n        option_prices_df[cross + '.' + field] = spot\n        option_prices_df[cross + '-strike.' + field] = strike\n        option_prices_df[cross + '-vol.' + field] = vol\n        option_prices_df[cross + '-delta.' + field] = delta\n        option_prices_df[cross + '.expiry-date'] = expiry_date\n        option_prices_df[cross + '-intrinsic-value.' + field] = intrinsic_values\n        return option_prices_df\n    return (option_values, spot, strike, vol, delta, expiry_date, intrinsic_values)"
        ]
    },
    {
        "func_name": "get_day_count_conv",
        "original": "def get_day_count_conv(self, currency):\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
        "mutated": [
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0"
        ]
    },
    {
        "func_name": "_findate",
        "original": "def _findate(self, timestamp):\n    return FinDate(timestamp.day, timestamp.month, timestamp.year, hh=timestamp.hour, mm=timestamp.minute, ss=timestamp.second)",
        "mutated": [
            "def _findate(self, timestamp):\n    if False:\n        i = 10\n    return FinDate(timestamp.day, timestamp.month, timestamp.year, hh=timestamp.hour, mm=timestamp.minute, ss=timestamp.second)",
            "def _findate(self, timestamp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return FinDate(timestamp.day, timestamp.month, timestamp.year, hh=timestamp.hour, mm=timestamp.minute, ss=timestamp.second)",
            "def _findate(self, timestamp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return FinDate(timestamp.day, timestamp.month, timestamp.year, hh=timestamp.hour, mm=timestamp.minute, ss=timestamp.second)",
            "def _findate(self, timestamp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return FinDate(timestamp.day, timestamp.month, timestamp.year, hh=timestamp.hour, mm=timestamp.minute, ss=timestamp.second)",
            "def _findate(self, timestamp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return FinDate(timestamp.day, timestamp.month, timestamp.year, hh=timestamp.hour, mm=timestamp.minute, ss=timestamp.second)"
        ]
    }
]