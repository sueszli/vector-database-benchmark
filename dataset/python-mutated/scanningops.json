[
    {
        "func_name": "optimize_in_single_dimension",
        "original": "@staticmethod\ndef optimize_in_single_dimension(pvalues: np.ndarray, a_max: float, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, float]:\n    \"\"\"\n        Optimizes over all subsets of nodes for a given subset of images or over all subsets of images for a given\n        subset of nodes.\n\n        :param pvalues: pvalue ranges.\n        :param a_max: Determines the significance level threshold.\n        :param image_to_node: Informs the direction for optimization.\n        :param score_function: Scoring function.\n        :return: (best_score_so_far, subset, best_alpha).\n        \"\"\"\n    alpha_thresholds = np.unique(pvalues[:, :, 1])\n    last_alpha_index = int(np.searchsorted(alpha_thresholds, a_max))\n    alpha_thresholds = alpha_thresholds[0:last_alpha_index]\n    step_for_50 = len(alpha_thresholds) / 50\n    alpha_thresholds = alpha_thresholds[0::int(step_for_50) + 1]\n    alpha_thresholds = np.append(alpha_thresholds, a_max)\n    if image_to_node:\n        number_of_elements = pvalues.shape[1]\n        size_of_given = pvalues.shape[0]\n        unsort_priority = np.zeros((pvalues.shape[1], alpha_thresholds.shape[0]))\n    else:\n        number_of_elements = pvalues.shape[0]\n        size_of_given = pvalues.shape[1]\n        unsort_priority = np.zeros((pvalues.shape[0], alpha_thresholds.shape[0]))\n    for elem_indx in range(0, number_of_elements):\n        if image_to_node:\n            arg_sort_max = np.argsort(pvalues[:, elem_indx, 1])\n            completely_included = np.searchsorted(pvalues[:, elem_indx, 1][arg_sort_max], alpha_thresholds, side='right')\n        else:\n            arg_sort_max = np.argsort(pvalues[elem_indx, :, 1])\n            completely_included = np.searchsorted(pvalues[elem_indx, :, 1][arg_sort_max], alpha_thresholds, side='right')\n        unsort_priority[elem_indx, :] = completely_included\n    arg_sort_priority = np.argsort(-unsort_priority, axis=0)\n    best_score_so_far = -10000\n    best_alpha = -2\n    alpha_count = 0\n    for alpha_threshold in alpha_thresholds:\n        alpha_v = np.ones(number_of_elements) * alpha_threshold\n        n_alpha_v = np.cumsum(unsort_priority[:, alpha_count][arg_sort_priority][:, alpha_count])\n        count_increments_this = np.ones(number_of_elements) * size_of_given\n        n_v = np.cumsum(count_increments_this)\n        vector_of_scores = score_function(n_alpha_v, n_v, alpha_v)\n        best_score_for_this_alpha_idx = np.argmax(vector_of_scores)\n        best_score_for_this_alpha = vector_of_scores[best_score_for_this_alpha_idx]\n        if best_score_for_this_alpha > best_score_so_far:\n            best_score_so_far = best_score_for_this_alpha\n            best_size = best_score_for_this_alpha_idx + 1\n            best_alpha = alpha_threshold\n            best_alpha_count = alpha_count\n        alpha_count = alpha_count + 1\n    unsort = arg_sort_priority[:, best_alpha_count]\n    subset = np.zeros(best_size).astype(int)\n    for loc in range(0, best_size):\n        subset[loc] = unsort[loc]\n    return (best_score_so_far, subset, best_alpha)",
        "mutated": [
            "@staticmethod\ndef optimize_in_single_dimension(pvalues: np.ndarray, a_max: float, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, float]:\n    if False:\n        i = 10\n    '\\n        Optimizes over all subsets of nodes for a given subset of images or over all subsets of images for a given\\n        subset of nodes.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, subset, best_alpha).\\n        '\n    alpha_thresholds = np.unique(pvalues[:, :, 1])\n    last_alpha_index = int(np.searchsorted(alpha_thresholds, a_max))\n    alpha_thresholds = alpha_thresholds[0:last_alpha_index]\n    step_for_50 = len(alpha_thresholds) / 50\n    alpha_thresholds = alpha_thresholds[0::int(step_for_50) + 1]\n    alpha_thresholds = np.append(alpha_thresholds, a_max)\n    if image_to_node:\n        number_of_elements = pvalues.shape[1]\n        size_of_given = pvalues.shape[0]\n        unsort_priority = np.zeros((pvalues.shape[1], alpha_thresholds.shape[0]))\n    else:\n        number_of_elements = pvalues.shape[0]\n        size_of_given = pvalues.shape[1]\n        unsort_priority = np.zeros((pvalues.shape[0], alpha_thresholds.shape[0]))\n    for elem_indx in range(0, number_of_elements):\n        if image_to_node:\n            arg_sort_max = np.argsort(pvalues[:, elem_indx, 1])\n            completely_included = np.searchsorted(pvalues[:, elem_indx, 1][arg_sort_max], alpha_thresholds, side='right')\n        else:\n            arg_sort_max = np.argsort(pvalues[elem_indx, :, 1])\n            completely_included = np.searchsorted(pvalues[elem_indx, :, 1][arg_sort_max], alpha_thresholds, side='right')\n        unsort_priority[elem_indx, :] = completely_included\n    arg_sort_priority = np.argsort(-unsort_priority, axis=0)\n    best_score_so_far = -10000\n    best_alpha = -2\n    alpha_count = 0\n    for alpha_threshold in alpha_thresholds:\n        alpha_v = np.ones(number_of_elements) * alpha_threshold\n        n_alpha_v = np.cumsum(unsort_priority[:, alpha_count][arg_sort_priority][:, alpha_count])\n        count_increments_this = np.ones(number_of_elements) * size_of_given\n        n_v = np.cumsum(count_increments_this)\n        vector_of_scores = score_function(n_alpha_v, n_v, alpha_v)\n        best_score_for_this_alpha_idx = np.argmax(vector_of_scores)\n        best_score_for_this_alpha = vector_of_scores[best_score_for_this_alpha_idx]\n        if best_score_for_this_alpha > best_score_so_far:\n            best_score_so_far = best_score_for_this_alpha\n            best_size = best_score_for_this_alpha_idx + 1\n            best_alpha = alpha_threshold\n            best_alpha_count = alpha_count\n        alpha_count = alpha_count + 1\n    unsort = arg_sort_priority[:, best_alpha_count]\n    subset = np.zeros(best_size).astype(int)\n    for loc in range(0, best_size):\n        subset[loc] = unsort[loc]\n    return (best_score_so_far, subset, best_alpha)",
            "@staticmethod\ndef optimize_in_single_dimension(pvalues: np.ndarray, a_max: float, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Optimizes over all subsets of nodes for a given subset of images or over all subsets of images for a given\\n        subset of nodes.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, subset, best_alpha).\\n        '\n    alpha_thresholds = np.unique(pvalues[:, :, 1])\n    last_alpha_index = int(np.searchsorted(alpha_thresholds, a_max))\n    alpha_thresholds = alpha_thresholds[0:last_alpha_index]\n    step_for_50 = len(alpha_thresholds) / 50\n    alpha_thresholds = alpha_thresholds[0::int(step_for_50) + 1]\n    alpha_thresholds = np.append(alpha_thresholds, a_max)\n    if image_to_node:\n        number_of_elements = pvalues.shape[1]\n        size_of_given = pvalues.shape[0]\n        unsort_priority = np.zeros((pvalues.shape[1], alpha_thresholds.shape[0]))\n    else:\n        number_of_elements = pvalues.shape[0]\n        size_of_given = pvalues.shape[1]\n        unsort_priority = np.zeros((pvalues.shape[0], alpha_thresholds.shape[0]))\n    for elem_indx in range(0, number_of_elements):\n        if image_to_node:\n            arg_sort_max = np.argsort(pvalues[:, elem_indx, 1])\n            completely_included = np.searchsorted(pvalues[:, elem_indx, 1][arg_sort_max], alpha_thresholds, side='right')\n        else:\n            arg_sort_max = np.argsort(pvalues[elem_indx, :, 1])\n            completely_included = np.searchsorted(pvalues[elem_indx, :, 1][arg_sort_max], alpha_thresholds, side='right')\n        unsort_priority[elem_indx, :] = completely_included\n    arg_sort_priority = np.argsort(-unsort_priority, axis=0)\n    best_score_so_far = -10000\n    best_alpha = -2\n    alpha_count = 0\n    for alpha_threshold in alpha_thresholds:\n        alpha_v = np.ones(number_of_elements) * alpha_threshold\n        n_alpha_v = np.cumsum(unsort_priority[:, alpha_count][arg_sort_priority][:, alpha_count])\n        count_increments_this = np.ones(number_of_elements) * size_of_given\n        n_v = np.cumsum(count_increments_this)\n        vector_of_scores = score_function(n_alpha_v, n_v, alpha_v)\n        best_score_for_this_alpha_idx = np.argmax(vector_of_scores)\n        best_score_for_this_alpha = vector_of_scores[best_score_for_this_alpha_idx]\n        if best_score_for_this_alpha > best_score_so_far:\n            best_score_so_far = best_score_for_this_alpha\n            best_size = best_score_for_this_alpha_idx + 1\n            best_alpha = alpha_threshold\n            best_alpha_count = alpha_count\n        alpha_count = alpha_count + 1\n    unsort = arg_sort_priority[:, best_alpha_count]\n    subset = np.zeros(best_size).astype(int)\n    for loc in range(0, best_size):\n        subset[loc] = unsort[loc]\n    return (best_score_so_far, subset, best_alpha)",
            "@staticmethod\ndef optimize_in_single_dimension(pvalues: np.ndarray, a_max: float, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Optimizes over all subsets of nodes for a given subset of images or over all subsets of images for a given\\n        subset of nodes.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, subset, best_alpha).\\n        '\n    alpha_thresholds = np.unique(pvalues[:, :, 1])\n    last_alpha_index = int(np.searchsorted(alpha_thresholds, a_max))\n    alpha_thresholds = alpha_thresholds[0:last_alpha_index]\n    step_for_50 = len(alpha_thresholds) / 50\n    alpha_thresholds = alpha_thresholds[0::int(step_for_50) + 1]\n    alpha_thresholds = np.append(alpha_thresholds, a_max)\n    if image_to_node:\n        number_of_elements = pvalues.shape[1]\n        size_of_given = pvalues.shape[0]\n        unsort_priority = np.zeros((pvalues.shape[1], alpha_thresholds.shape[0]))\n    else:\n        number_of_elements = pvalues.shape[0]\n        size_of_given = pvalues.shape[1]\n        unsort_priority = np.zeros((pvalues.shape[0], alpha_thresholds.shape[0]))\n    for elem_indx in range(0, number_of_elements):\n        if image_to_node:\n            arg_sort_max = np.argsort(pvalues[:, elem_indx, 1])\n            completely_included = np.searchsorted(pvalues[:, elem_indx, 1][arg_sort_max], alpha_thresholds, side='right')\n        else:\n            arg_sort_max = np.argsort(pvalues[elem_indx, :, 1])\n            completely_included = np.searchsorted(pvalues[elem_indx, :, 1][arg_sort_max], alpha_thresholds, side='right')\n        unsort_priority[elem_indx, :] = completely_included\n    arg_sort_priority = np.argsort(-unsort_priority, axis=0)\n    best_score_so_far = -10000\n    best_alpha = -2\n    alpha_count = 0\n    for alpha_threshold in alpha_thresholds:\n        alpha_v = np.ones(number_of_elements) * alpha_threshold\n        n_alpha_v = np.cumsum(unsort_priority[:, alpha_count][arg_sort_priority][:, alpha_count])\n        count_increments_this = np.ones(number_of_elements) * size_of_given\n        n_v = np.cumsum(count_increments_this)\n        vector_of_scores = score_function(n_alpha_v, n_v, alpha_v)\n        best_score_for_this_alpha_idx = np.argmax(vector_of_scores)\n        best_score_for_this_alpha = vector_of_scores[best_score_for_this_alpha_idx]\n        if best_score_for_this_alpha > best_score_so_far:\n            best_score_so_far = best_score_for_this_alpha\n            best_size = best_score_for_this_alpha_idx + 1\n            best_alpha = alpha_threshold\n            best_alpha_count = alpha_count\n        alpha_count = alpha_count + 1\n    unsort = arg_sort_priority[:, best_alpha_count]\n    subset = np.zeros(best_size).astype(int)\n    for loc in range(0, best_size):\n        subset[loc] = unsort[loc]\n    return (best_score_so_far, subset, best_alpha)",
            "@staticmethod\ndef optimize_in_single_dimension(pvalues: np.ndarray, a_max: float, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Optimizes over all subsets of nodes for a given subset of images or over all subsets of images for a given\\n        subset of nodes.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, subset, best_alpha).\\n        '\n    alpha_thresholds = np.unique(pvalues[:, :, 1])\n    last_alpha_index = int(np.searchsorted(alpha_thresholds, a_max))\n    alpha_thresholds = alpha_thresholds[0:last_alpha_index]\n    step_for_50 = len(alpha_thresholds) / 50\n    alpha_thresholds = alpha_thresholds[0::int(step_for_50) + 1]\n    alpha_thresholds = np.append(alpha_thresholds, a_max)\n    if image_to_node:\n        number_of_elements = pvalues.shape[1]\n        size_of_given = pvalues.shape[0]\n        unsort_priority = np.zeros((pvalues.shape[1], alpha_thresholds.shape[0]))\n    else:\n        number_of_elements = pvalues.shape[0]\n        size_of_given = pvalues.shape[1]\n        unsort_priority = np.zeros((pvalues.shape[0], alpha_thresholds.shape[0]))\n    for elem_indx in range(0, number_of_elements):\n        if image_to_node:\n            arg_sort_max = np.argsort(pvalues[:, elem_indx, 1])\n            completely_included = np.searchsorted(pvalues[:, elem_indx, 1][arg_sort_max], alpha_thresholds, side='right')\n        else:\n            arg_sort_max = np.argsort(pvalues[elem_indx, :, 1])\n            completely_included = np.searchsorted(pvalues[elem_indx, :, 1][arg_sort_max], alpha_thresholds, side='right')\n        unsort_priority[elem_indx, :] = completely_included\n    arg_sort_priority = np.argsort(-unsort_priority, axis=0)\n    best_score_so_far = -10000\n    best_alpha = -2\n    alpha_count = 0\n    for alpha_threshold in alpha_thresholds:\n        alpha_v = np.ones(number_of_elements) * alpha_threshold\n        n_alpha_v = np.cumsum(unsort_priority[:, alpha_count][arg_sort_priority][:, alpha_count])\n        count_increments_this = np.ones(number_of_elements) * size_of_given\n        n_v = np.cumsum(count_increments_this)\n        vector_of_scores = score_function(n_alpha_v, n_v, alpha_v)\n        best_score_for_this_alpha_idx = np.argmax(vector_of_scores)\n        best_score_for_this_alpha = vector_of_scores[best_score_for_this_alpha_idx]\n        if best_score_for_this_alpha > best_score_so_far:\n            best_score_so_far = best_score_for_this_alpha\n            best_size = best_score_for_this_alpha_idx + 1\n            best_alpha = alpha_threshold\n            best_alpha_count = alpha_count\n        alpha_count = alpha_count + 1\n    unsort = arg_sort_priority[:, best_alpha_count]\n    subset = np.zeros(best_size).astype(int)\n    for loc in range(0, best_size):\n        subset[loc] = unsort[loc]\n    return (best_score_so_far, subset, best_alpha)",
            "@staticmethod\ndef optimize_in_single_dimension(pvalues: np.ndarray, a_max: float, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Optimizes over all subsets of nodes for a given subset of images or over all subsets of images for a given\\n        subset of nodes.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, subset, best_alpha).\\n        '\n    alpha_thresholds = np.unique(pvalues[:, :, 1])\n    last_alpha_index = int(np.searchsorted(alpha_thresholds, a_max))\n    alpha_thresholds = alpha_thresholds[0:last_alpha_index]\n    step_for_50 = len(alpha_thresholds) / 50\n    alpha_thresholds = alpha_thresholds[0::int(step_for_50) + 1]\n    alpha_thresholds = np.append(alpha_thresholds, a_max)\n    if image_to_node:\n        number_of_elements = pvalues.shape[1]\n        size_of_given = pvalues.shape[0]\n        unsort_priority = np.zeros((pvalues.shape[1], alpha_thresholds.shape[0]))\n    else:\n        number_of_elements = pvalues.shape[0]\n        size_of_given = pvalues.shape[1]\n        unsort_priority = np.zeros((pvalues.shape[0], alpha_thresholds.shape[0]))\n    for elem_indx in range(0, number_of_elements):\n        if image_to_node:\n            arg_sort_max = np.argsort(pvalues[:, elem_indx, 1])\n            completely_included = np.searchsorted(pvalues[:, elem_indx, 1][arg_sort_max], alpha_thresholds, side='right')\n        else:\n            arg_sort_max = np.argsort(pvalues[elem_indx, :, 1])\n            completely_included = np.searchsorted(pvalues[elem_indx, :, 1][arg_sort_max], alpha_thresholds, side='right')\n        unsort_priority[elem_indx, :] = completely_included\n    arg_sort_priority = np.argsort(-unsort_priority, axis=0)\n    best_score_so_far = -10000\n    best_alpha = -2\n    alpha_count = 0\n    for alpha_threshold in alpha_thresholds:\n        alpha_v = np.ones(number_of_elements) * alpha_threshold\n        n_alpha_v = np.cumsum(unsort_priority[:, alpha_count][arg_sort_priority][:, alpha_count])\n        count_increments_this = np.ones(number_of_elements) * size_of_given\n        n_v = np.cumsum(count_increments_this)\n        vector_of_scores = score_function(n_alpha_v, n_v, alpha_v)\n        best_score_for_this_alpha_idx = np.argmax(vector_of_scores)\n        best_score_for_this_alpha = vector_of_scores[best_score_for_this_alpha_idx]\n        if best_score_for_this_alpha > best_score_so_far:\n            best_score_so_far = best_score_for_this_alpha\n            best_size = best_score_for_this_alpha_idx + 1\n            best_alpha = alpha_threshold\n            best_alpha_count = alpha_count\n        alpha_count = alpha_count + 1\n    unsort = arg_sort_priority[:, best_alpha_count]\n    subset = np.zeros(best_size).astype(int)\n    for loc in range(0, best_size):\n        subset[loc] = unsort[loc]\n    return (best_score_so_far, subset, best_alpha)"
        ]
    },
    {
        "func_name": "single_restart",
        "original": "@staticmethod\ndef single_restart(pvalues: np.ndarray, a_max: float, indices_of_seeds: np.ndarray, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, np.ndarray, float]:\n    \"\"\"\n        Here we control the iteration between images->nodes and nodes->images. It starts with a fixed subset of nodes by\n        default.\n\n        :param pvalues: pvalue ranges.\n        :param a_max: Determines the significance level threshold.\n        :param indices_of_seeds: Indices of initial sets of images or nodes to perform optimization.\n        :param image_to_node: Informs the direction for optimization.\n        :param score_function: Scoring function.\n        :return: (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha).\n        \"\"\"\n    best_score_so_far = -100000.0\n    count = 0\n    while True:\n        if count == 0:\n            if image_to_node:\n                sub_of_images = indices_of_seeds\n            else:\n                sub_of_nodes = indices_of_seeds\n        if image_to_node:\n            (score_from_optimization, sub_of_nodes, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[sub_of_images, :, :], a_max, image_to_node, score_function)\n        else:\n            (score_from_optimization, sub_of_images, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[:, sub_of_nodes, :], a_max, image_to_node, score_function)\n        if score_from_optimization > best_score_so_far:\n            best_score_so_far = score_from_optimization\n            best_sub_of_nodes = sub_of_nodes\n            best_sub_of_images = sub_of_images\n            best_alpha = optimal_alpha\n            image_to_node = not image_to_node\n            count = count + 1\n        else:\n            return (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha)",
        "mutated": [
            "@staticmethod\ndef single_restart(pvalues: np.ndarray, a_max: float, indices_of_seeds: np.ndarray, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, np.ndarray, float]:\n    if False:\n        i = 10\n    '\\n        Here we control the iteration between images->nodes and nodes->images. It starts with a fixed subset of nodes by\\n        default.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param indices_of_seeds: Indices of initial sets of images or nodes to perform optimization.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha).\\n        '\n    best_score_so_far = -100000.0\n    count = 0\n    while True:\n        if count == 0:\n            if image_to_node:\n                sub_of_images = indices_of_seeds\n            else:\n                sub_of_nodes = indices_of_seeds\n        if image_to_node:\n            (score_from_optimization, sub_of_nodes, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[sub_of_images, :, :], a_max, image_to_node, score_function)\n        else:\n            (score_from_optimization, sub_of_images, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[:, sub_of_nodes, :], a_max, image_to_node, score_function)\n        if score_from_optimization > best_score_so_far:\n            best_score_so_far = score_from_optimization\n            best_sub_of_nodes = sub_of_nodes\n            best_sub_of_images = sub_of_images\n            best_alpha = optimal_alpha\n            image_to_node = not image_to_node\n            count = count + 1\n        else:\n            return (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha)",
            "@staticmethod\ndef single_restart(pvalues: np.ndarray, a_max: float, indices_of_seeds: np.ndarray, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, np.ndarray, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Here we control the iteration between images->nodes and nodes->images. It starts with a fixed subset of nodes by\\n        default.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param indices_of_seeds: Indices of initial sets of images or nodes to perform optimization.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha).\\n        '\n    best_score_so_far = -100000.0\n    count = 0\n    while True:\n        if count == 0:\n            if image_to_node:\n                sub_of_images = indices_of_seeds\n            else:\n                sub_of_nodes = indices_of_seeds\n        if image_to_node:\n            (score_from_optimization, sub_of_nodes, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[sub_of_images, :, :], a_max, image_to_node, score_function)\n        else:\n            (score_from_optimization, sub_of_images, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[:, sub_of_nodes, :], a_max, image_to_node, score_function)\n        if score_from_optimization > best_score_so_far:\n            best_score_so_far = score_from_optimization\n            best_sub_of_nodes = sub_of_nodes\n            best_sub_of_images = sub_of_images\n            best_alpha = optimal_alpha\n            image_to_node = not image_to_node\n            count = count + 1\n        else:\n            return (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha)",
            "@staticmethod\ndef single_restart(pvalues: np.ndarray, a_max: float, indices_of_seeds: np.ndarray, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, np.ndarray, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Here we control the iteration between images->nodes and nodes->images. It starts with a fixed subset of nodes by\\n        default.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param indices_of_seeds: Indices of initial sets of images or nodes to perform optimization.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha).\\n        '\n    best_score_so_far = -100000.0\n    count = 0\n    while True:\n        if count == 0:\n            if image_to_node:\n                sub_of_images = indices_of_seeds\n            else:\n                sub_of_nodes = indices_of_seeds\n        if image_to_node:\n            (score_from_optimization, sub_of_nodes, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[sub_of_images, :, :], a_max, image_to_node, score_function)\n        else:\n            (score_from_optimization, sub_of_images, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[:, sub_of_nodes, :], a_max, image_to_node, score_function)\n        if score_from_optimization > best_score_so_far:\n            best_score_so_far = score_from_optimization\n            best_sub_of_nodes = sub_of_nodes\n            best_sub_of_images = sub_of_images\n            best_alpha = optimal_alpha\n            image_to_node = not image_to_node\n            count = count + 1\n        else:\n            return (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha)",
            "@staticmethod\ndef single_restart(pvalues: np.ndarray, a_max: float, indices_of_seeds: np.ndarray, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, np.ndarray, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Here we control the iteration between images->nodes and nodes->images. It starts with a fixed subset of nodes by\\n        default.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param indices_of_seeds: Indices of initial sets of images or nodes to perform optimization.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha).\\n        '\n    best_score_so_far = -100000.0\n    count = 0\n    while True:\n        if count == 0:\n            if image_to_node:\n                sub_of_images = indices_of_seeds\n            else:\n                sub_of_nodes = indices_of_seeds\n        if image_to_node:\n            (score_from_optimization, sub_of_nodes, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[sub_of_images, :, :], a_max, image_to_node, score_function)\n        else:\n            (score_from_optimization, sub_of_images, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[:, sub_of_nodes, :], a_max, image_to_node, score_function)\n        if score_from_optimization > best_score_so_far:\n            best_score_so_far = score_from_optimization\n            best_sub_of_nodes = sub_of_nodes\n            best_sub_of_images = sub_of_images\n            best_alpha = optimal_alpha\n            image_to_node = not image_to_node\n            count = count + 1\n        else:\n            return (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha)",
            "@staticmethod\ndef single_restart(pvalues: np.ndarray, a_max: float, indices_of_seeds: np.ndarray, image_to_node: bool, score_function: Callable[[np.ndarray, np.ndarray, np.ndarray], np.ndarray]) -> Tuple[float, np.ndarray, np.ndarray, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Here we control the iteration between images->nodes and nodes->images. It starts with a fixed subset of nodes by\\n        default.\\n\\n        :param pvalues: pvalue ranges.\\n        :param a_max: Determines the significance level threshold.\\n        :param indices_of_seeds: Indices of initial sets of images or nodes to perform optimization.\\n        :param image_to_node: Informs the direction for optimization.\\n        :param score_function: Scoring function.\\n        :return: (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha).\\n        '\n    best_score_so_far = -100000.0\n    count = 0\n    while True:\n        if count == 0:\n            if image_to_node:\n                sub_of_images = indices_of_seeds\n            else:\n                sub_of_nodes = indices_of_seeds\n        if image_to_node:\n            (score_from_optimization, sub_of_nodes, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[sub_of_images, :, :], a_max, image_to_node, score_function)\n        else:\n            (score_from_optimization, sub_of_images, optimal_alpha) = ScanningOps.optimize_in_single_dimension(pvalues[:, sub_of_nodes, :], a_max, image_to_node, score_function)\n        if score_from_optimization > best_score_so_far:\n            best_score_so_far = score_from_optimization\n            best_sub_of_nodes = sub_of_nodes\n            best_sub_of_images = sub_of_images\n            best_alpha = optimal_alpha\n            image_to_node = not image_to_node\n            count = count + 1\n        else:\n            return (best_score_so_far, best_sub_of_images, best_sub_of_nodes, best_alpha)"
        ]
    }
]