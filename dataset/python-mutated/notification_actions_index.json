[
    {
        "func_name": "get",
        "original": "@extend_schema(operation_id='List Spike Protection Notifications', parameters=[GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, OrganizationParams.PROJECT_SLUG, NotificationParams.TRIGGER_TYPE], responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef get(self, request: Request, organization: Organization) -> Response:\n    \"\"\"\n        Returns all Spike Protection Notification Actions for an organization.\n\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\n        For example, organization owners and managers can receive an email when a spike occurs.\n\n        You can use either the `project` or `projectSlug` query parameter to filter for certain projects. Note that if both are present, `projectSlug` takes priority.\n        \"\"\"\n    queryset = NotificationAction.objects.filter(organization_id=organization.id)\n    project_query = Q(projects__in=self.get_projects(request, organization)) if self.get_requested_project_ids_unchecked(request) else Q(projects=None) | Q(projects__in=self.get_projects(request, organization))\n    queryset = queryset.filter(project_query).distinct()\n    trigger_type_query = request.GET.getlist('triggerType')\n    if trigger_type_query:\n        triggers: Dict[str, int] = {v: k for (k, v) in NotificationAction.get_trigger_types()}\n        trigger_types = map(lambda t: triggers.get(t), trigger_type_query)\n        queryset = queryset.filter(trigger_type__in=trigger_types)\n    logger.info('notification_action.get_all', extra={'organization_id': organization.id, 'trigger_type_query': trigger_type_query, 'project_query': self.get_requested_project_ids_unchecked(request)})\n    return self.paginate(request=request, queryset=queryset, on_results=lambda action: serialize(action, request.user), paginator_cls=OffsetPaginator)",
        "mutated": [
            "@extend_schema(operation_id='List Spike Protection Notifications', parameters=[GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, OrganizationParams.PROJECT_SLUG, NotificationParams.TRIGGER_TYPE], responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef get(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n    '\\n        Returns all Spike Protection Notification Actions for an organization.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n\\n        You can use either the `project` or `projectSlug` query parameter to filter for certain projects. Note that if both are present, `projectSlug` takes priority.\\n        '\n    queryset = NotificationAction.objects.filter(organization_id=organization.id)\n    project_query = Q(projects__in=self.get_projects(request, organization)) if self.get_requested_project_ids_unchecked(request) else Q(projects=None) | Q(projects__in=self.get_projects(request, organization))\n    queryset = queryset.filter(project_query).distinct()\n    trigger_type_query = request.GET.getlist('triggerType')\n    if trigger_type_query:\n        triggers: Dict[str, int] = {v: k for (k, v) in NotificationAction.get_trigger_types()}\n        trigger_types = map(lambda t: triggers.get(t), trigger_type_query)\n        queryset = queryset.filter(trigger_type__in=trigger_types)\n    logger.info('notification_action.get_all', extra={'organization_id': organization.id, 'trigger_type_query': trigger_type_query, 'project_query': self.get_requested_project_ids_unchecked(request)})\n    return self.paginate(request=request, queryset=queryset, on_results=lambda action: serialize(action, request.user), paginator_cls=OffsetPaginator)",
            "@extend_schema(operation_id='List Spike Protection Notifications', parameters=[GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, OrganizationParams.PROJECT_SLUG, NotificationParams.TRIGGER_TYPE], responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef get(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns all Spike Protection Notification Actions for an organization.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n\\n        You can use either the `project` or `projectSlug` query parameter to filter for certain projects. Note that if both are present, `projectSlug` takes priority.\\n        '\n    queryset = NotificationAction.objects.filter(organization_id=organization.id)\n    project_query = Q(projects__in=self.get_projects(request, organization)) if self.get_requested_project_ids_unchecked(request) else Q(projects=None) | Q(projects__in=self.get_projects(request, organization))\n    queryset = queryset.filter(project_query).distinct()\n    trigger_type_query = request.GET.getlist('triggerType')\n    if trigger_type_query:\n        triggers: Dict[str, int] = {v: k for (k, v) in NotificationAction.get_trigger_types()}\n        trigger_types = map(lambda t: triggers.get(t), trigger_type_query)\n        queryset = queryset.filter(trigger_type__in=trigger_types)\n    logger.info('notification_action.get_all', extra={'organization_id': organization.id, 'trigger_type_query': trigger_type_query, 'project_query': self.get_requested_project_ids_unchecked(request)})\n    return self.paginate(request=request, queryset=queryset, on_results=lambda action: serialize(action, request.user), paginator_cls=OffsetPaginator)",
            "@extend_schema(operation_id='List Spike Protection Notifications', parameters=[GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, OrganizationParams.PROJECT_SLUG, NotificationParams.TRIGGER_TYPE], responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef get(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns all Spike Protection Notification Actions for an organization.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n\\n        You can use either the `project` or `projectSlug` query parameter to filter for certain projects. Note that if both are present, `projectSlug` takes priority.\\n        '\n    queryset = NotificationAction.objects.filter(organization_id=organization.id)\n    project_query = Q(projects__in=self.get_projects(request, organization)) if self.get_requested_project_ids_unchecked(request) else Q(projects=None) | Q(projects__in=self.get_projects(request, organization))\n    queryset = queryset.filter(project_query).distinct()\n    trigger_type_query = request.GET.getlist('triggerType')\n    if trigger_type_query:\n        triggers: Dict[str, int] = {v: k for (k, v) in NotificationAction.get_trigger_types()}\n        trigger_types = map(lambda t: triggers.get(t), trigger_type_query)\n        queryset = queryset.filter(trigger_type__in=trigger_types)\n    logger.info('notification_action.get_all', extra={'organization_id': organization.id, 'trigger_type_query': trigger_type_query, 'project_query': self.get_requested_project_ids_unchecked(request)})\n    return self.paginate(request=request, queryset=queryset, on_results=lambda action: serialize(action, request.user), paginator_cls=OffsetPaginator)",
            "@extend_schema(operation_id='List Spike Protection Notifications', parameters=[GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, OrganizationParams.PROJECT_SLUG, NotificationParams.TRIGGER_TYPE], responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef get(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns all Spike Protection Notification Actions for an organization.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n\\n        You can use either the `project` or `projectSlug` query parameter to filter for certain projects. Note that if both are present, `projectSlug` takes priority.\\n        '\n    queryset = NotificationAction.objects.filter(organization_id=organization.id)\n    project_query = Q(projects__in=self.get_projects(request, organization)) if self.get_requested_project_ids_unchecked(request) else Q(projects=None) | Q(projects__in=self.get_projects(request, organization))\n    queryset = queryset.filter(project_query).distinct()\n    trigger_type_query = request.GET.getlist('triggerType')\n    if trigger_type_query:\n        triggers: Dict[str, int] = {v: k for (k, v) in NotificationAction.get_trigger_types()}\n        trigger_types = map(lambda t: triggers.get(t), trigger_type_query)\n        queryset = queryset.filter(trigger_type__in=trigger_types)\n    logger.info('notification_action.get_all', extra={'organization_id': organization.id, 'trigger_type_query': trigger_type_query, 'project_query': self.get_requested_project_ids_unchecked(request)})\n    return self.paginate(request=request, queryset=queryset, on_results=lambda action: serialize(action, request.user), paginator_cls=OffsetPaginator)",
            "@extend_schema(operation_id='List Spike Protection Notifications', parameters=[GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, OrganizationParams.PROJECT_SLUG, NotificationParams.TRIGGER_TYPE], responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef get(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns all Spike Protection Notification Actions for an organization.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n\\n        You can use either the `project` or `projectSlug` query parameter to filter for certain projects. Note that if both are present, `projectSlug` takes priority.\\n        '\n    queryset = NotificationAction.objects.filter(organization_id=organization.id)\n    project_query = Q(projects__in=self.get_projects(request, organization)) if self.get_requested_project_ids_unchecked(request) else Q(projects=None) | Q(projects__in=self.get_projects(request, organization))\n    queryset = queryset.filter(project_query).distinct()\n    trigger_type_query = request.GET.getlist('triggerType')\n    if trigger_type_query:\n        triggers: Dict[str, int] = {v: k for (k, v) in NotificationAction.get_trigger_types()}\n        trigger_types = map(lambda t: triggers.get(t), trigger_type_query)\n        queryset = queryset.filter(trigger_type__in=trigger_types)\n    logger.info('notification_action.get_all', extra={'organization_id': organization.id, 'trigger_type_query': trigger_type_query, 'project_query': self.get_requested_project_ids_unchecked(request)})\n    return self.paginate(request=request, queryset=queryset, on_results=lambda action: serialize(action, request.user), paginator_cls=OffsetPaginator)"
        ]
    },
    {
        "func_name": "post",
        "original": "@extend_schema(operation_id='Create a Spike Protection Notification Action', parameters=[GlobalParams.ORG_SLUG], request=NotificationActionSerializer, responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef post(self, request: Request, organization: Organization) -> Response:\n    \"\"\"\n        Creates a new Notification Action for Spike Protection.\n\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\n        For example, organization owners and managers can receive an email when a spike occurs.\n        \"\"\"\n    if not request.access.has_scope('project:write'):\n        requested_projects = request.data.get('projects', [])\n        projects = self.get_projects(request, organization)\n        project_slugs = [project.slug for project in projects]\n        missing_access_projects = set(requested_projects).difference(set(project_slugs))\n        if missing_access_projects:\n            raise PermissionDenied(detail='You do not have permission to create notification actions for projects ' + str(list(missing_access_projects)))\n        team_admin_has_access = all([request.access.has_project_scope(project, 'project:write') for project in projects])\n        if not team_admin_has_access or not projects:\n            raise PermissionDenied\n    serializer = NotificationActionSerializer(context={'access': request.access, 'organization': organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    action = serializer.save()\n    logger.info('notification_action.create', extra={'organization_id': organization.id, 'action_id': action.id})\n    self.create_audit_entry(request=request, organization=organization, target_object=action.id, event=audit_log.get_event_id('NOTIFICATION_ACTION_ADD'), data=action.get_audit_log_data())\n    return Response(serialize(action, request.user), status=status.HTTP_201_CREATED)",
        "mutated": [
            "@extend_schema(operation_id='Create a Spike Protection Notification Action', parameters=[GlobalParams.ORG_SLUG], request=NotificationActionSerializer, responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef post(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n    '\\n        Creates a new Notification Action for Spike Protection.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n        '\n    if not request.access.has_scope('project:write'):\n        requested_projects = request.data.get('projects', [])\n        projects = self.get_projects(request, organization)\n        project_slugs = [project.slug for project in projects]\n        missing_access_projects = set(requested_projects).difference(set(project_slugs))\n        if missing_access_projects:\n            raise PermissionDenied(detail='You do not have permission to create notification actions for projects ' + str(list(missing_access_projects)))\n        team_admin_has_access = all([request.access.has_project_scope(project, 'project:write') for project in projects])\n        if not team_admin_has_access or not projects:\n            raise PermissionDenied\n    serializer = NotificationActionSerializer(context={'access': request.access, 'organization': organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    action = serializer.save()\n    logger.info('notification_action.create', extra={'organization_id': organization.id, 'action_id': action.id})\n    self.create_audit_entry(request=request, organization=organization, target_object=action.id, event=audit_log.get_event_id('NOTIFICATION_ACTION_ADD'), data=action.get_audit_log_data())\n    return Response(serialize(action, request.user), status=status.HTTP_201_CREATED)",
            "@extend_schema(operation_id='Create a Spike Protection Notification Action', parameters=[GlobalParams.ORG_SLUG], request=NotificationActionSerializer, responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef post(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Creates a new Notification Action for Spike Protection.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n        '\n    if not request.access.has_scope('project:write'):\n        requested_projects = request.data.get('projects', [])\n        projects = self.get_projects(request, organization)\n        project_slugs = [project.slug for project in projects]\n        missing_access_projects = set(requested_projects).difference(set(project_slugs))\n        if missing_access_projects:\n            raise PermissionDenied(detail='You do not have permission to create notification actions for projects ' + str(list(missing_access_projects)))\n        team_admin_has_access = all([request.access.has_project_scope(project, 'project:write') for project in projects])\n        if not team_admin_has_access or not projects:\n            raise PermissionDenied\n    serializer = NotificationActionSerializer(context={'access': request.access, 'organization': organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    action = serializer.save()\n    logger.info('notification_action.create', extra={'organization_id': organization.id, 'action_id': action.id})\n    self.create_audit_entry(request=request, organization=organization, target_object=action.id, event=audit_log.get_event_id('NOTIFICATION_ACTION_ADD'), data=action.get_audit_log_data())\n    return Response(serialize(action, request.user), status=status.HTTP_201_CREATED)",
            "@extend_schema(operation_id='Create a Spike Protection Notification Action', parameters=[GlobalParams.ORG_SLUG], request=NotificationActionSerializer, responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef post(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Creates a new Notification Action for Spike Protection.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n        '\n    if not request.access.has_scope('project:write'):\n        requested_projects = request.data.get('projects', [])\n        projects = self.get_projects(request, organization)\n        project_slugs = [project.slug for project in projects]\n        missing_access_projects = set(requested_projects).difference(set(project_slugs))\n        if missing_access_projects:\n            raise PermissionDenied(detail='You do not have permission to create notification actions for projects ' + str(list(missing_access_projects)))\n        team_admin_has_access = all([request.access.has_project_scope(project, 'project:write') for project in projects])\n        if not team_admin_has_access or not projects:\n            raise PermissionDenied\n    serializer = NotificationActionSerializer(context={'access': request.access, 'organization': organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    action = serializer.save()\n    logger.info('notification_action.create', extra={'organization_id': organization.id, 'action_id': action.id})\n    self.create_audit_entry(request=request, organization=organization, target_object=action.id, event=audit_log.get_event_id('NOTIFICATION_ACTION_ADD'), data=action.get_audit_log_data())\n    return Response(serialize(action, request.user), status=status.HTTP_201_CREATED)",
            "@extend_schema(operation_id='Create a Spike Protection Notification Action', parameters=[GlobalParams.ORG_SLUG], request=NotificationActionSerializer, responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef post(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Creates a new Notification Action for Spike Protection.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n        '\n    if not request.access.has_scope('project:write'):\n        requested_projects = request.data.get('projects', [])\n        projects = self.get_projects(request, organization)\n        project_slugs = [project.slug for project in projects]\n        missing_access_projects = set(requested_projects).difference(set(project_slugs))\n        if missing_access_projects:\n            raise PermissionDenied(detail='You do not have permission to create notification actions for projects ' + str(list(missing_access_projects)))\n        team_admin_has_access = all([request.access.has_project_scope(project, 'project:write') for project in projects])\n        if not team_admin_has_access or not projects:\n            raise PermissionDenied\n    serializer = NotificationActionSerializer(context={'access': request.access, 'organization': organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    action = serializer.save()\n    logger.info('notification_action.create', extra={'organization_id': organization.id, 'action_id': action.id})\n    self.create_audit_entry(request=request, organization=organization, target_object=action.id, event=audit_log.get_event_id('NOTIFICATION_ACTION_ADD'), data=action.get_audit_log_data())\n    return Response(serialize(action, request.user), status=status.HTTP_201_CREATED)",
            "@extend_schema(operation_id='Create a Spike Protection Notification Action', parameters=[GlobalParams.ORG_SLUG], request=NotificationActionSerializer, responses={201: OutgoingNotificationActionSerializer, 400: RESPONSE_BAD_REQUEST, 403: RESPONSE_FORBIDDEN}, examples=notification_examples.CREATE_NOTIFICATION_ACTION)\ndef post(self, request: Request, organization: Organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Creates a new Notification Action for Spike Protection.\\n\\n        Notification Actions notify a set of members when an action has been triggered through a notification service such as Slack or Sentry.\\n        For example, organization owners and managers can receive an email when a spike occurs.\\n        '\n    if not request.access.has_scope('project:write'):\n        requested_projects = request.data.get('projects', [])\n        projects = self.get_projects(request, organization)\n        project_slugs = [project.slug for project in projects]\n        missing_access_projects = set(requested_projects).difference(set(project_slugs))\n        if missing_access_projects:\n            raise PermissionDenied(detail='You do not have permission to create notification actions for projects ' + str(list(missing_access_projects)))\n        team_admin_has_access = all([request.access.has_project_scope(project, 'project:write') for project in projects])\n        if not team_admin_has_access or not projects:\n            raise PermissionDenied\n    serializer = NotificationActionSerializer(context={'access': request.access, 'organization': organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    action = serializer.save()\n    logger.info('notification_action.create', extra={'organization_id': organization.id, 'action_id': action.id})\n    self.create_audit_entry(request=request, organization=organization, target_object=action.id, event=audit_log.get_event_id('NOTIFICATION_ACTION_ADD'), data=action.get_audit_log_data())\n    return Response(serialize(action, request.user), status=status.HTTP_201_CREATED)"
        ]
    }
]