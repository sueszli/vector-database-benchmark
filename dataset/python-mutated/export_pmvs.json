[
    {
        "func_name": "run_dataset",
        "original": "def run_dataset(data: DataSet, points, image_list, output, undistorted) -> None:\n    \"\"\"Export reconstruction to PLY format\n\n    Args:\n        points: export points\n        image_list: export only the shots included in this file (path to .txt file)\n        output: output pmvs directory\n        undistorted: export the undistorted reconstruction\n\n    \"\"\"\n    udata = data.undistorted_dataset()\n    base_output_path = output if output else os.path.join(data.data_path, 'pmvs')\n    io.mkdir_p(base_output_path)\n    logger.info('Converting dataset [%s] to PMVS dir [%s]' % (data.data_path, base_output_path))\n    if undistorted:\n        reconstructions = udata.load_undistorted_reconstruction()\n    else:\n        reconstructions = data.load_reconstruction()\n    try:\n        if undistorted:\n            tracks_manager = udata.load_undistorted_tracks_manager()\n        else:\n            tracks_manager = data.load_tracks_manager()\n        image_graph = tracking.as_weighted_graph(tracks_manager)\n    except IOError:\n        image_graph = None\n        tracks_manager = None\n    export_only = None\n    if image_list:\n        export_only = {}\n        with open(image_list, 'r') as f:\n            for image in f:\n                export_only[image.strip()] = True\n    for (h, reconstruction) in enumerate(reconstructions):\n        export(reconstruction, h, image_graph, tracks_manager, base_output_path, data, undistorted, udata, points, export_only)",
        "mutated": [
            "def run_dataset(data: DataSet, points, image_list, output, undistorted) -> None:\n    if False:\n        i = 10\n    'Export reconstruction to PLY format\\n\\n    Args:\\n        points: export points\\n        image_list: export only the shots included in this file (path to .txt file)\\n        output: output pmvs directory\\n        undistorted: export the undistorted reconstruction\\n\\n    '\n    udata = data.undistorted_dataset()\n    base_output_path = output if output else os.path.join(data.data_path, 'pmvs')\n    io.mkdir_p(base_output_path)\n    logger.info('Converting dataset [%s] to PMVS dir [%s]' % (data.data_path, base_output_path))\n    if undistorted:\n        reconstructions = udata.load_undistorted_reconstruction()\n    else:\n        reconstructions = data.load_reconstruction()\n    try:\n        if undistorted:\n            tracks_manager = udata.load_undistorted_tracks_manager()\n        else:\n            tracks_manager = data.load_tracks_manager()\n        image_graph = tracking.as_weighted_graph(tracks_manager)\n    except IOError:\n        image_graph = None\n        tracks_manager = None\n    export_only = None\n    if image_list:\n        export_only = {}\n        with open(image_list, 'r') as f:\n            for image in f:\n                export_only[image.strip()] = True\n    for (h, reconstruction) in enumerate(reconstructions):\n        export(reconstruction, h, image_graph, tracks_manager, base_output_path, data, undistorted, udata, points, export_only)",
            "def run_dataset(data: DataSet, points, image_list, output, undistorted) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Export reconstruction to PLY format\\n\\n    Args:\\n        points: export points\\n        image_list: export only the shots included in this file (path to .txt file)\\n        output: output pmvs directory\\n        undistorted: export the undistorted reconstruction\\n\\n    '\n    udata = data.undistorted_dataset()\n    base_output_path = output if output else os.path.join(data.data_path, 'pmvs')\n    io.mkdir_p(base_output_path)\n    logger.info('Converting dataset [%s] to PMVS dir [%s]' % (data.data_path, base_output_path))\n    if undistorted:\n        reconstructions = udata.load_undistorted_reconstruction()\n    else:\n        reconstructions = data.load_reconstruction()\n    try:\n        if undistorted:\n            tracks_manager = udata.load_undistorted_tracks_manager()\n        else:\n            tracks_manager = data.load_tracks_manager()\n        image_graph = tracking.as_weighted_graph(tracks_manager)\n    except IOError:\n        image_graph = None\n        tracks_manager = None\n    export_only = None\n    if image_list:\n        export_only = {}\n        with open(image_list, 'r') as f:\n            for image in f:\n                export_only[image.strip()] = True\n    for (h, reconstruction) in enumerate(reconstructions):\n        export(reconstruction, h, image_graph, tracks_manager, base_output_path, data, undistorted, udata, points, export_only)",
            "def run_dataset(data: DataSet, points, image_list, output, undistorted) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Export reconstruction to PLY format\\n\\n    Args:\\n        points: export points\\n        image_list: export only the shots included in this file (path to .txt file)\\n        output: output pmvs directory\\n        undistorted: export the undistorted reconstruction\\n\\n    '\n    udata = data.undistorted_dataset()\n    base_output_path = output if output else os.path.join(data.data_path, 'pmvs')\n    io.mkdir_p(base_output_path)\n    logger.info('Converting dataset [%s] to PMVS dir [%s]' % (data.data_path, base_output_path))\n    if undistorted:\n        reconstructions = udata.load_undistorted_reconstruction()\n    else:\n        reconstructions = data.load_reconstruction()\n    try:\n        if undistorted:\n            tracks_manager = udata.load_undistorted_tracks_manager()\n        else:\n            tracks_manager = data.load_tracks_manager()\n        image_graph = tracking.as_weighted_graph(tracks_manager)\n    except IOError:\n        image_graph = None\n        tracks_manager = None\n    export_only = None\n    if image_list:\n        export_only = {}\n        with open(image_list, 'r') as f:\n            for image in f:\n                export_only[image.strip()] = True\n    for (h, reconstruction) in enumerate(reconstructions):\n        export(reconstruction, h, image_graph, tracks_manager, base_output_path, data, undistorted, udata, points, export_only)",
            "def run_dataset(data: DataSet, points, image_list, output, undistorted) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Export reconstruction to PLY format\\n\\n    Args:\\n        points: export points\\n        image_list: export only the shots included in this file (path to .txt file)\\n        output: output pmvs directory\\n        undistorted: export the undistorted reconstruction\\n\\n    '\n    udata = data.undistorted_dataset()\n    base_output_path = output if output else os.path.join(data.data_path, 'pmvs')\n    io.mkdir_p(base_output_path)\n    logger.info('Converting dataset [%s] to PMVS dir [%s]' % (data.data_path, base_output_path))\n    if undistorted:\n        reconstructions = udata.load_undistorted_reconstruction()\n    else:\n        reconstructions = data.load_reconstruction()\n    try:\n        if undistorted:\n            tracks_manager = udata.load_undistorted_tracks_manager()\n        else:\n            tracks_manager = data.load_tracks_manager()\n        image_graph = tracking.as_weighted_graph(tracks_manager)\n    except IOError:\n        image_graph = None\n        tracks_manager = None\n    export_only = None\n    if image_list:\n        export_only = {}\n        with open(image_list, 'r') as f:\n            for image in f:\n                export_only[image.strip()] = True\n    for (h, reconstruction) in enumerate(reconstructions):\n        export(reconstruction, h, image_graph, tracks_manager, base_output_path, data, undistorted, udata, points, export_only)",
            "def run_dataset(data: DataSet, points, image_list, output, undistorted) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Export reconstruction to PLY format\\n\\n    Args:\\n        points: export points\\n        image_list: export only the shots included in this file (path to .txt file)\\n        output: output pmvs directory\\n        undistorted: export the undistorted reconstruction\\n\\n    '\n    udata = data.undistorted_dataset()\n    base_output_path = output if output else os.path.join(data.data_path, 'pmvs')\n    io.mkdir_p(base_output_path)\n    logger.info('Converting dataset [%s] to PMVS dir [%s]' % (data.data_path, base_output_path))\n    if undistorted:\n        reconstructions = udata.load_undistorted_reconstruction()\n    else:\n        reconstructions = data.load_reconstruction()\n    try:\n        if undistorted:\n            tracks_manager = udata.load_undistorted_tracks_manager()\n        else:\n            tracks_manager = data.load_tracks_manager()\n        image_graph = tracking.as_weighted_graph(tracks_manager)\n    except IOError:\n        image_graph = None\n        tracks_manager = None\n    export_only = None\n    if image_list:\n        export_only = {}\n        with open(image_list, 'r') as f:\n            for image in f:\n                export_only[image.strip()] = True\n    for (h, reconstruction) in enumerate(reconstructions):\n        export(reconstruction, h, image_graph, tracks_manager, base_output_path, data, undistorted, udata, points, export_only)"
        ]
    },
    {
        "func_name": "export",
        "original": "def export(reconstruction, index, image_graph, tracks_manager, base_output_path, data: DataSet, undistorted, udata: UndistortedDataSet, with_points, export_only) -> None:\n    logger.info('Reconstruction %d' % index)\n    output_path = os.path.join(base_output_path, 'recon%d' % index)\n    io.mkdir_p(output_path)\n    io.mkdir_p(os.path.join(output_path, 'visualize'))\n    io.mkdir_p(os.path.join(output_path, 'txt'))\n    io.mkdir_p(os.path.join(output_path, 'models'))\n    shot_index = {image: i for (i, image) in enumerate(reconstruction.shots)}\n    fvis = open(os.path.join(output_path, 'vis.dat'), 'w')\n    fvis.write('VISDATA\\n')\n    fvis.write('%d\\n' % len(shot_index))\n    for (image, i) in shot_index.items():\n        shot = reconstruction.shots[image]\n        base = '%08d' % i\n        logger.info('Image: %s %s' % (image, base))\n        if image_graph:\n            adj_indices = []\n            for adj_image in image_graph[image]:\n                weight = image_graph[image][adj_image]['weight']\n                if weight > 0 and adj_image in shot_index:\n                    adj_indices.append(shot_index[adj_image])\n            num_covisible = len(adj_indices)\n            fvis.write('%d ' % i)\n            fvis.write('%d ' % num_covisible)\n            for ai in adj_indices:\n                fvis.write('%d ' % ai)\n            fvis.write('\\n')\n        camera = shot.camera\n        if undistorted:\n            undistorted_image = udata.load_undistorted_image(image)\n        else:\n            original_image = data.load_image(image)[:, :, ::-1]\n            (original_h, original_w) = original_image.shape[:2]\n            K = camera.get_K_in_pixel_coordinates(original_w, original_h)\n            distortion = np.array([camera.k1, camera.k2, 0, 0])\n            undistorted_image = cv2.undistort(original_image, K, distortion)\n        resized_image = features.resized_image(undistorted_image, data.config['feature_process_size'])\n        new_image_path = os.path.join(output_path, 'visualize', base + '.jpg')\n        cv2.imwrite(new_image_path, resized_image)\n        (resized_h, resized_w) = resized_image.shape[:2]\n        resized_K = camera.get_K_in_pixel_coordinates(resized_w, resized_h)\n        P = resized_K.dot(shot.pose.get_world_to_cam()[:3])\n        new_txt = os.path.join(output_path, 'txt', base + '.txt')\n        with open(new_txt, 'wb') as f:\n            np.savetxt(f, P, str('%f'), header='CONTOUR')\n    fvis.close()\n    with open(os.path.join(output_path, 'pmvs_txt'), 'w') as f:\n        f.write('level 1\\n')\n        f.write('csize 2\\n')\n        f.write('threshold 0.7\\n')\n        f.write('wsize 7\\n')\n        f.write('minImageNum 3\\n')\n        f.write('CPU 8\\n')\n        f.write('setEdge 0\\n')\n        f.write('useBound 0\\n')\n        f.write('useVisData {}\\n'.format(int(image_graph is not None)))\n        f.write('sequence -1\\n')\n        f.write('timages -1 0 %d\\n' % len(shot_index))\n        f.write('oimages 0\\n')",
        "mutated": [
            "def export(reconstruction, index, image_graph, tracks_manager, base_output_path, data: DataSet, undistorted, udata: UndistortedDataSet, with_points, export_only) -> None:\n    if False:\n        i = 10\n    logger.info('Reconstruction %d' % index)\n    output_path = os.path.join(base_output_path, 'recon%d' % index)\n    io.mkdir_p(output_path)\n    io.mkdir_p(os.path.join(output_path, 'visualize'))\n    io.mkdir_p(os.path.join(output_path, 'txt'))\n    io.mkdir_p(os.path.join(output_path, 'models'))\n    shot_index = {image: i for (i, image) in enumerate(reconstruction.shots)}\n    fvis = open(os.path.join(output_path, 'vis.dat'), 'w')\n    fvis.write('VISDATA\\n')\n    fvis.write('%d\\n' % len(shot_index))\n    for (image, i) in shot_index.items():\n        shot = reconstruction.shots[image]\n        base = '%08d' % i\n        logger.info('Image: %s %s' % (image, base))\n        if image_graph:\n            adj_indices = []\n            for adj_image in image_graph[image]:\n                weight = image_graph[image][adj_image]['weight']\n                if weight > 0 and adj_image in shot_index:\n                    adj_indices.append(shot_index[adj_image])\n            num_covisible = len(adj_indices)\n            fvis.write('%d ' % i)\n            fvis.write('%d ' % num_covisible)\n            for ai in adj_indices:\n                fvis.write('%d ' % ai)\n            fvis.write('\\n')\n        camera = shot.camera\n        if undistorted:\n            undistorted_image = udata.load_undistorted_image(image)\n        else:\n            original_image = data.load_image(image)[:, :, ::-1]\n            (original_h, original_w) = original_image.shape[:2]\n            K = camera.get_K_in_pixel_coordinates(original_w, original_h)\n            distortion = np.array([camera.k1, camera.k2, 0, 0])\n            undistorted_image = cv2.undistort(original_image, K, distortion)\n        resized_image = features.resized_image(undistorted_image, data.config['feature_process_size'])\n        new_image_path = os.path.join(output_path, 'visualize', base + '.jpg')\n        cv2.imwrite(new_image_path, resized_image)\n        (resized_h, resized_w) = resized_image.shape[:2]\n        resized_K = camera.get_K_in_pixel_coordinates(resized_w, resized_h)\n        P = resized_K.dot(shot.pose.get_world_to_cam()[:3])\n        new_txt = os.path.join(output_path, 'txt', base + '.txt')\n        with open(new_txt, 'wb') as f:\n            np.savetxt(f, P, str('%f'), header='CONTOUR')\n    fvis.close()\n    with open(os.path.join(output_path, 'pmvs_txt'), 'w') as f:\n        f.write('level 1\\n')\n        f.write('csize 2\\n')\n        f.write('threshold 0.7\\n')\n        f.write('wsize 7\\n')\n        f.write('minImageNum 3\\n')\n        f.write('CPU 8\\n')\n        f.write('setEdge 0\\n')\n        f.write('useBound 0\\n')\n        f.write('useVisData {}\\n'.format(int(image_graph is not None)))\n        f.write('sequence -1\\n')\n        f.write('timages -1 0 %d\\n' % len(shot_index))\n        f.write('oimages 0\\n')",
            "def export(reconstruction, index, image_graph, tracks_manager, base_output_path, data: DataSet, undistorted, udata: UndistortedDataSet, with_points, export_only) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logger.info('Reconstruction %d' % index)\n    output_path = os.path.join(base_output_path, 'recon%d' % index)\n    io.mkdir_p(output_path)\n    io.mkdir_p(os.path.join(output_path, 'visualize'))\n    io.mkdir_p(os.path.join(output_path, 'txt'))\n    io.mkdir_p(os.path.join(output_path, 'models'))\n    shot_index = {image: i for (i, image) in enumerate(reconstruction.shots)}\n    fvis = open(os.path.join(output_path, 'vis.dat'), 'w')\n    fvis.write('VISDATA\\n')\n    fvis.write('%d\\n' % len(shot_index))\n    for (image, i) in shot_index.items():\n        shot = reconstruction.shots[image]\n        base = '%08d' % i\n        logger.info('Image: %s %s' % (image, base))\n        if image_graph:\n            adj_indices = []\n            for adj_image in image_graph[image]:\n                weight = image_graph[image][adj_image]['weight']\n                if weight > 0 and adj_image in shot_index:\n                    adj_indices.append(shot_index[adj_image])\n            num_covisible = len(adj_indices)\n            fvis.write('%d ' % i)\n            fvis.write('%d ' % num_covisible)\n            for ai in adj_indices:\n                fvis.write('%d ' % ai)\n            fvis.write('\\n')\n        camera = shot.camera\n        if undistorted:\n            undistorted_image = udata.load_undistorted_image(image)\n        else:\n            original_image = data.load_image(image)[:, :, ::-1]\n            (original_h, original_w) = original_image.shape[:2]\n            K = camera.get_K_in_pixel_coordinates(original_w, original_h)\n            distortion = np.array([camera.k1, camera.k2, 0, 0])\n            undistorted_image = cv2.undistort(original_image, K, distortion)\n        resized_image = features.resized_image(undistorted_image, data.config['feature_process_size'])\n        new_image_path = os.path.join(output_path, 'visualize', base + '.jpg')\n        cv2.imwrite(new_image_path, resized_image)\n        (resized_h, resized_w) = resized_image.shape[:2]\n        resized_K = camera.get_K_in_pixel_coordinates(resized_w, resized_h)\n        P = resized_K.dot(shot.pose.get_world_to_cam()[:3])\n        new_txt = os.path.join(output_path, 'txt', base + '.txt')\n        with open(new_txt, 'wb') as f:\n            np.savetxt(f, P, str('%f'), header='CONTOUR')\n    fvis.close()\n    with open(os.path.join(output_path, 'pmvs_txt'), 'w') as f:\n        f.write('level 1\\n')\n        f.write('csize 2\\n')\n        f.write('threshold 0.7\\n')\n        f.write('wsize 7\\n')\n        f.write('minImageNum 3\\n')\n        f.write('CPU 8\\n')\n        f.write('setEdge 0\\n')\n        f.write('useBound 0\\n')\n        f.write('useVisData {}\\n'.format(int(image_graph is not None)))\n        f.write('sequence -1\\n')\n        f.write('timages -1 0 %d\\n' % len(shot_index))\n        f.write('oimages 0\\n')",
            "def export(reconstruction, index, image_graph, tracks_manager, base_output_path, data: DataSet, undistorted, udata: UndistortedDataSet, with_points, export_only) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logger.info('Reconstruction %d' % index)\n    output_path = os.path.join(base_output_path, 'recon%d' % index)\n    io.mkdir_p(output_path)\n    io.mkdir_p(os.path.join(output_path, 'visualize'))\n    io.mkdir_p(os.path.join(output_path, 'txt'))\n    io.mkdir_p(os.path.join(output_path, 'models'))\n    shot_index = {image: i for (i, image) in enumerate(reconstruction.shots)}\n    fvis = open(os.path.join(output_path, 'vis.dat'), 'w')\n    fvis.write('VISDATA\\n')\n    fvis.write('%d\\n' % len(shot_index))\n    for (image, i) in shot_index.items():\n        shot = reconstruction.shots[image]\n        base = '%08d' % i\n        logger.info('Image: %s %s' % (image, base))\n        if image_graph:\n            adj_indices = []\n            for adj_image in image_graph[image]:\n                weight = image_graph[image][adj_image]['weight']\n                if weight > 0 and adj_image in shot_index:\n                    adj_indices.append(shot_index[adj_image])\n            num_covisible = len(adj_indices)\n            fvis.write('%d ' % i)\n            fvis.write('%d ' % num_covisible)\n            for ai in adj_indices:\n                fvis.write('%d ' % ai)\n            fvis.write('\\n')\n        camera = shot.camera\n        if undistorted:\n            undistorted_image = udata.load_undistorted_image(image)\n        else:\n            original_image = data.load_image(image)[:, :, ::-1]\n            (original_h, original_w) = original_image.shape[:2]\n            K = camera.get_K_in_pixel_coordinates(original_w, original_h)\n            distortion = np.array([camera.k1, camera.k2, 0, 0])\n            undistorted_image = cv2.undistort(original_image, K, distortion)\n        resized_image = features.resized_image(undistorted_image, data.config['feature_process_size'])\n        new_image_path = os.path.join(output_path, 'visualize', base + '.jpg')\n        cv2.imwrite(new_image_path, resized_image)\n        (resized_h, resized_w) = resized_image.shape[:2]\n        resized_K = camera.get_K_in_pixel_coordinates(resized_w, resized_h)\n        P = resized_K.dot(shot.pose.get_world_to_cam()[:3])\n        new_txt = os.path.join(output_path, 'txt', base + '.txt')\n        with open(new_txt, 'wb') as f:\n            np.savetxt(f, P, str('%f'), header='CONTOUR')\n    fvis.close()\n    with open(os.path.join(output_path, 'pmvs_txt'), 'w') as f:\n        f.write('level 1\\n')\n        f.write('csize 2\\n')\n        f.write('threshold 0.7\\n')\n        f.write('wsize 7\\n')\n        f.write('minImageNum 3\\n')\n        f.write('CPU 8\\n')\n        f.write('setEdge 0\\n')\n        f.write('useBound 0\\n')\n        f.write('useVisData {}\\n'.format(int(image_graph is not None)))\n        f.write('sequence -1\\n')\n        f.write('timages -1 0 %d\\n' % len(shot_index))\n        f.write('oimages 0\\n')",
            "def export(reconstruction, index, image_graph, tracks_manager, base_output_path, data: DataSet, undistorted, udata: UndistortedDataSet, with_points, export_only) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logger.info('Reconstruction %d' % index)\n    output_path = os.path.join(base_output_path, 'recon%d' % index)\n    io.mkdir_p(output_path)\n    io.mkdir_p(os.path.join(output_path, 'visualize'))\n    io.mkdir_p(os.path.join(output_path, 'txt'))\n    io.mkdir_p(os.path.join(output_path, 'models'))\n    shot_index = {image: i for (i, image) in enumerate(reconstruction.shots)}\n    fvis = open(os.path.join(output_path, 'vis.dat'), 'w')\n    fvis.write('VISDATA\\n')\n    fvis.write('%d\\n' % len(shot_index))\n    for (image, i) in shot_index.items():\n        shot = reconstruction.shots[image]\n        base = '%08d' % i\n        logger.info('Image: %s %s' % (image, base))\n        if image_graph:\n            adj_indices = []\n            for adj_image in image_graph[image]:\n                weight = image_graph[image][adj_image]['weight']\n                if weight > 0 and adj_image in shot_index:\n                    adj_indices.append(shot_index[adj_image])\n            num_covisible = len(adj_indices)\n            fvis.write('%d ' % i)\n            fvis.write('%d ' % num_covisible)\n            for ai in adj_indices:\n                fvis.write('%d ' % ai)\n            fvis.write('\\n')\n        camera = shot.camera\n        if undistorted:\n            undistorted_image = udata.load_undistorted_image(image)\n        else:\n            original_image = data.load_image(image)[:, :, ::-1]\n            (original_h, original_w) = original_image.shape[:2]\n            K = camera.get_K_in_pixel_coordinates(original_w, original_h)\n            distortion = np.array([camera.k1, camera.k2, 0, 0])\n            undistorted_image = cv2.undistort(original_image, K, distortion)\n        resized_image = features.resized_image(undistorted_image, data.config['feature_process_size'])\n        new_image_path = os.path.join(output_path, 'visualize', base + '.jpg')\n        cv2.imwrite(new_image_path, resized_image)\n        (resized_h, resized_w) = resized_image.shape[:2]\n        resized_K = camera.get_K_in_pixel_coordinates(resized_w, resized_h)\n        P = resized_K.dot(shot.pose.get_world_to_cam()[:3])\n        new_txt = os.path.join(output_path, 'txt', base + '.txt')\n        with open(new_txt, 'wb') as f:\n            np.savetxt(f, P, str('%f'), header='CONTOUR')\n    fvis.close()\n    with open(os.path.join(output_path, 'pmvs_txt'), 'w') as f:\n        f.write('level 1\\n')\n        f.write('csize 2\\n')\n        f.write('threshold 0.7\\n')\n        f.write('wsize 7\\n')\n        f.write('minImageNum 3\\n')\n        f.write('CPU 8\\n')\n        f.write('setEdge 0\\n')\n        f.write('useBound 0\\n')\n        f.write('useVisData {}\\n'.format(int(image_graph is not None)))\n        f.write('sequence -1\\n')\n        f.write('timages -1 0 %d\\n' % len(shot_index))\n        f.write('oimages 0\\n')",
            "def export(reconstruction, index, image_graph, tracks_manager, base_output_path, data: DataSet, undistorted, udata: UndistortedDataSet, with_points, export_only) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logger.info('Reconstruction %d' % index)\n    output_path = os.path.join(base_output_path, 'recon%d' % index)\n    io.mkdir_p(output_path)\n    io.mkdir_p(os.path.join(output_path, 'visualize'))\n    io.mkdir_p(os.path.join(output_path, 'txt'))\n    io.mkdir_p(os.path.join(output_path, 'models'))\n    shot_index = {image: i for (i, image) in enumerate(reconstruction.shots)}\n    fvis = open(os.path.join(output_path, 'vis.dat'), 'w')\n    fvis.write('VISDATA\\n')\n    fvis.write('%d\\n' % len(shot_index))\n    for (image, i) in shot_index.items():\n        shot = reconstruction.shots[image]\n        base = '%08d' % i\n        logger.info('Image: %s %s' % (image, base))\n        if image_graph:\n            adj_indices = []\n            for adj_image in image_graph[image]:\n                weight = image_graph[image][adj_image]['weight']\n                if weight > 0 and adj_image in shot_index:\n                    adj_indices.append(shot_index[adj_image])\n            num_covisible = len(adj_indices)\n            fvis.write('%d ' % i)\n            fvis.write('%d ' % num_covisible)\n            for ai in adj_indices:\n                fvis.write('%d ' % ai)\n            fvis.write('\\n')\n        camera = shot.camera\n        if undistorted:\n            undistorted_image = udata.load_undistorted_image(image)\n        else:\n            original_image = data.load_image(image)[:, :, ::-1]\n            (original_h, original_w) = original_image.shape[:2]\n            K = camera.get_K_in_pixel_coordinates(original_w, original_h)\n            distortion = np.array([camera.k1, camera.k2, 0, 0])\n            undistorted_image = cv2.undistort(original_image, K, distortion)\n        resized_image = features.resized_image(undistorted_image, data.config['feature_process_size'])\n        new_image_path = os.path.join(output_path, 'visualize', base + '.jpg')\n        cv2.imwrite(new_image_path, resized_image)\n        (resized_h, resized_w) = resized_image.shape[:2]\n        resized_K = camera.get_K_in_pixel_coordinates(resized_w, resized_h)\n        P = resized_K.dot(shot.pose.get_world_to_cam()[:3])\n        new_txt = os.path.join(output_path, 'txt', base + '.txt')\n        with open(new_txt, 'wb') as f:\n            np.savetxt(f, P, str('%f'), header='CONTOUR')\n    fvis.close()\n    with open(os.path.join(output_path, 'pmvs_txt'), 'w') as f:\n        f.write('level 1\\n')\n        f.write('csize 2\\n')\n        f.write('threshold 0.7\\n')\n        f.write('wsize 7\\n')\n        f.write('minImageNum 3\\n')\n        f.write('CPU 8\\n')\n        f.write('setEdge 0\\n')\n        f.write('useBound 0\\n')\n        f.write('useVisData {}\\n'.format(int(image_graph is not None)))\n        f.write('sequence -1\\n')\n        f.write('timages -1 0 %d\\n' % len(shot_index))\n        f.write('oimages 0\\n')"
        ]
    }
]