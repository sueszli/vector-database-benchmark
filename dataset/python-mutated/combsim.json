[
    {
        "func_name": "combsimp",
        "original": "@timethis('combsimp')\ndef combsimp(expr):\n    \"\"\"\n    Simplify combinatorial expressions.\n\n    Explanation\n    ===========\n\n    This function takes as input an expression containing factorials,\n    binomials, Pochhammer symbol and other \"combinatorial\" functions,\n    and tries to minimize the number of those functions and reduce\n    the size of their arguments.\n\n    The algorithm works by rewriting all combinatorial functions as\n    gamma functions and applying gammasimp() except simplification\n    steps that may make an integer argument non-integer. See docstring\n    of gammasimp for more information.\n\n    Then it rewrites expression in terms of factorials and binomials by\n    rewriting gammas as factorials and converting (a+b)!/a!b! into\n    binomials.\n\n    If expression has gamma functions or combinatorial functions\n    with non-integer argument, it is automatically passed to gammasimp.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify import combsimp\n    >>> from sympy import factorial, binomial, symbols\n    >>> n, k = symbols('n k', integer = True)\n\n    >>> combsimp(factorial(n)/factorial(n - 3))\n    n*(n - 2)*(n - 1)\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\n    (n + 1)/(k + 1)\n\n    \"\"\"\n    expr = expr.rewrite(gamma, piecewise=False)\n    if any((isinstance(node, gamma) and (not node.args[0].is_integer) for node in preorder_traversal(expr))):\n        return gammasimp(expr)\n    expr = _gammasimp(expr, as_comb=True)\n    expr = _gamma_as_comb(expr)\n    return expr",
        "mutated": [
            "@timethis('combsimp')\ndef combsimp(expr):\n    if False:\n        i = 10\n    '\\n    Simplify combinatorial expressions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing factorials,\\n    binomials, Pochhammer symbol and other \"combinatorial\" functions,\\n    and tries to minimize the number of those functions and reduce\\n    the size of their arguments.\\n\\n    The algorithm works by rewriting all combinatorial functions as\\n    gamma functions and applying gammasimp() except simplification\\n    steps that may make an integer argument non-integer. See docstring\\n    of gammasimp for more information.\\n\\n    Then it rewrites expression in terms of factorials and binomials by\\n    rewriting gammas as factorials and converting (a+b)!/a!b! into\\n    binomials.\\n\\n    If expression has gamma functions or combinatorial functions\\n    with non-integer argument, it is automatically passed to gammasimp.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import combsimp\\n    >>> from sympy import factorial, binomial, symbols\\n    >>> n, k = symbols(\\'n k\\', integer = True)\\n\\n    >>> combsimp(factorial(n)/factorial(n - 3))\\n    n*(n - 2)*(n - 1)\\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\\n    (n + 1)/(k + 1)\\n\\n    '\n    expr = expr.rewrite(gamma, piecewise=False)\n    if any((isinstance(node, gamma) and (not node.args[0].is_integer) for node in preorder_traversal(expr))):\n        return gammasimp(expr)\n    expr = _gammasimp(expr, as_comb=True)\n    expr = _gamma_as_comb(expr)\n    return expr",
            "@timethis('combsimp')\ndef combsimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Simplify combinatorial expressions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing factorials,\\n    binomials, Pochhammer symbol and other \"combinatorial\" functions,\\n    and tries to minimize the number of those functions and reduce\\n    the size of their arguments.\\n\\n    The algorithm works by rewriting all combinatorial functions as\\n    gamma functions and applying gammasimp() except simplification\\n    steps that may make an integer argument non-integer. See docstring\\n    of gammasimp for more information.\\n\\n    Then it rewrites expression in terms of factorials and binomials by\\n    rewriting gammas as factorials and converting (a+b)!/a!b! into\\n    binomials.\\n\\n    If expression has gamma functions or combinatorial functions\\n    with non-integer argument, it is automatically passed to gammasimp.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import combsimp\\n    >>> from sympy import factorial, binomial, symbols\\n    >>> n, k = symbols(\\'n k\\', integer = True)\\n\\n    >>> combsimp(factorial(n)/factorial(n - 3))\\n    n*(n - 2)*(n - 1)\\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\\n    (n + 1)/(k + 1)\\n\\n    '\n    expr = expr.rewrite(gamma, piecewise=False)\n    if any((isinstance(node, gamma) and (not node.args[0].is_integer) for node in preorder_traversal(expr))):\n        return gammasimp(expr)\n    expr = _gammasimp(expr, as_comb=True)\n    expr = _gamma_as_comb(expr)\n    return expr",
            "@timethis('combsimp')\ndef combsimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Simplify combinatorial expressions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing factorials,\\n    binomials, Pochhammer symbol and other \"combinatorial\" functions,\\n    and tries to minimize the number of those functions and reduce\\n    the size of their arguments.\\n\\n    The algorithm works by rewriting all combinatorial functions as\\n    gamma functions and applying gammasimp() except simplification\\n    steps that may make an integer argument non-integer. See docstring\\n    of gammasimp for more information.\\n\\n    Then it rewrites expression in terms of factorials and binomials by\\n    rewriting gammas as factorials and converting (a+b)!/a!b! into\\n    binomials.\\n\\n    If expression has gamma functions or combinatorial functions\\n    with non-integer argument, it is automatically passed to gammasimp.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import combsimp\\n    >>> from sympy import factorial, binomial, symbols\\n    >>> n, k = symbols(\\'n k\\', integer = True)\\n\\n    >>> combsimp(factorial(n)/factorial(n - 3))\\n    n*(n - 2)*(n - 1)\\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\\n    (n + 1)/(k + 1)\\n\\n    '\n    expr = expr.rewrite(gamma, piecewise=False)\n    if any((isinstance(node, gamma) and (not node.args[0].is_integer) for node in preorder_traversal(expr))):\n        return gammasimp(expr)\n    expr = _gammasimp(expr, as_comb=True)\n    expr = _gamma_as_comb(expr)\n    return expr",
            "@timethis('combsimp')\ndef combsimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Simplify combinatorial expressions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing factorials,\\n    binomials, Pochhammer symbol and other \"combinatorial\" functions,\\n    and tries to minimize the number of those functions and reduce\\n    the size of their arguments.\\n\\n    The algorithm works by rewriting all combinatorial functions as\\n    gamma functions and applying gammasimp() except simplification\\n    steps that may make an integer argument non-integer. See docstring\\n    of gammasimp for more information.\\n\\n    Then it rewrites expression in terms of factorials and binomials by\\n    rewriting gammas as factorials and converting (a+b)!/a!b! into\\n    binomials.\\n\\n    If expression has gamma functions or combinatorial functions\\n    with non-integer argument, it is automatically passed to gammasimp.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import combsimp\\n    >>> from sympy import factorial, binomial, symbols\\n    >>> n, k = symbols(\\'n k\\', integer = True)\\n\\n    >>> combsimp(factorial(n)/factorial(n - 3))\\n    n*(n - 2)*(n - 1)\\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\\n    (n + 1)/(k + 1)\\n\\n    '\n    expr = expr.rewrite(gamma, piecewise=False)\n    if any((isinstance(node, gamma) and (not node.args[0].is_integer) for node in preorder_traversal(expr))):\n        return gammasimp(expr)\n    expr = _gammasimp(expr, as_comb=True)\n    expr = _gamma_as_comb(expr)\n    return expr",
            "@timethis('combsimp')\ndef combsimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Simplify combinatorial expressions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing factorials,\\n    binomials, Pochhammer symbol and other \"combinatorial\" functions,\\n    and tries to minimize the number of those functions and reduce\\n    the size of their arguments.\\n\\n    The algorithm works by rewriting all combinatorial functions as\\n    gamma functions and applying gammasimp() except simplification\\n    steps that may make an integer argument non-integer. See docstring\\n    of gammasimp for more information.\\n\\n    Then it rewrites expression in terms of factorials and binomials by\\n    rewriting gammas as factorials and converting (a+b)!/a!b! into\\n    binomials.\\n\\n    If expression has gamma functions or combinatorial functions\\n    with non-integer argument, it is automatically passed to gammasimp.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import combsimp\\n    >>> from sympy import factorial, binomial, symbols\\n    >>> n, k = symbols(\\'n k\\', integer = True)\\n\\n    >>> combsimp(factorial(n)/factorial(n - 3))\\n    n*(n - 2)*(n - 1)\\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\\n    (n + 1)/(k + 1)\\n\\n    '\n    expr = expr.rewrite(gamma, piecewise=False)\n    if any((isinstance(node, gamma) and (not node.args[0].is_integer) for node in preorder_traversal(expr))):\n        return gammasimp(expr)\n    expr = _gammasimp(expr, as_comb=True)\n    expr = _gamma_as_comb(expr)\n    return expr"
        ]
    },
    {
        "func_name": "f",
        "original": "def f(rv):\n    if not rv.is_Mul:\n        return rv\n    rvd = rv.as_powers_dict()\n    nd_fact_args = [[], []]\n    for k in rvd:\n        if isinstance(k, factorial) and rvd[k].is_Integer:\n            if rvd[k].is_positive:\n                nd_fact_args[0].extend([k.args[0]] * rvd[k])\n            else:\n                nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n            rvd[k] = 0\n    if not nd_fact_args[0] or not nd_fact_args[1]:\n        return rv\n    hit = False\n    for m in range(2):\n        i = 0\n        while i < len(nd_fact_args[m]):\n            ai = nd_fact_args[m][i]\n            for j in range(i + 1, len(nd_fact_args[m])):\n                aj = nd_fact_args[m][j]\n                sum = ai + aj\n                if sum in nd_fact_args[1 - m]:\n                    hit = True\n                    nd_fact_args[1 - m].remove(sum)\n                    del nd_fact_args[m][j]\n                    del nd_fact_args[m][i]\n                    rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                    break\n            else:\n                i += 1\n    if hit:\n        return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n    return rv",
        "mutated": [
            "def f(rv):\n    if False:\n        i = 10\n    if not rv.is_Mul:\n        return rv\n    rvd = rv.as_powers_dict()\n    nd_fact_args = [[], []]\n    for k in rvd:\n        if isinstance(k, factorial) and rvd[k].is_Integer:\n            if rvd[k].is_positive:\n                nd_fact_args[0].extend([k.args[0]] * rvd[k])\n            else:\n                nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n            rvd[k] = 0\n    if not nd_fact_args[0] or not nd_fact_args[1]:\n        return rv\n    hit = False\n    for m in range(2):\n        i = 0\n        while i < len(nd_fact_args[m]):\n            ai = nd_fact_args[m][i]\n            for j in range(i + 1, len(nd_fact_args[m])):\n                aj = nd_fact_args[m][j]\n                sum = ai + aj\n                if sum in nd_fact_args[1 - m]:\n                    hit = True\n                    nd_fact_args[1 - m].remove(sum)\n                    del nd_fact_args[m][j]\n                    del nd_fact_args[m][i]\n                    rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                    break\n            else:\n                i += 1\n    if hit:\n        return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n    return rv",
            "def f(rv):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not rv.is_Mul:\n        return rv\n    rvd = rv.as_powers_dict()\n    nd_fact_args = [[], []]\n    for k in rvd:\n        if isinstance(k, factorial) and rvd[k].is_Integer:\n            if rvd[k].is_positive:\n                nd_fact_args[0].extend([k.args[0]] * rvd[k])\n            else:\n                nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n            rvd[k] = 0\n    if not nd_fact_args[0] or not nd_fact_args[1]:\n        return rv\n    hit = False\n    for m in range(2):\n        i = 0\n        while i < len(nd_fact_args[m]):\n            ai = nd_fact_args[m][i]\n            for j in range(i + 1, len(nd_fact_args[m])):\n                aj = nd_fact_args[m][j]\n                sum = ai + aj\n                if sum in nd_fact_args[1 - m]:\n                    hit = True\n                    nd_fact_args[1 - m].remove(sum)\n                    del nd_fact_args[m][j]\n                    del nd_fact_args[m][i]\n                    rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                    break\n            else:\n                i += 1\n    if hit:\n        return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n    return rv",
            "def f(rv):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not rv.is_Mul:\n        return rv\n    rvd = rv.as_powers_dict()\n    nd_fact_args = [[], []]\n    for k in rvd:\n        if isinstance(k, factorial) and rvd[k].is_Integer:\n            if rvd[k].is_positive:\n                nd_fact_args[0].extend([k.args[0]] * rvd[k])\n            else:\n                nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n            rvd[k] = 0\n    if not nd_fact_args[0] or not nd_fact_args[1]:\n        return rv\n    hit = False\n    for m in range(2):\n        i = 0\n        while i < len(nd_fact_args[m]):\n            ai = nd_fact_args[m][i]\n            for j in range(i + 1, len(nd_fact_args[m])):\n                aj = nd_fact_args[m][j]\n                sum = ai + aj\n                if sum in nd_fact_args[1 - m]:\n                    hit = True\n                    nd_fact_args[1 - m].remove(sum)\n                    del nd_fact_args[m][j]\n                    del nd_fact_args[m][i]\n                    rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                    break\n            else:\n                i += 1\n    if hit:\n        return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n    return rv",
            "def f(rv):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not rv.is_Mul:\n        return rv\n    rvd = rv.as_powers_dict()\n    nd_fact_args = [[], []]\n    for k in rvd:\n        if isinstance(k, factorial) and rvd[k].is_Integer:\n            if rvd[k].is_positive:\n                nd_fact_args[0].extend([k.args[0]] * rvd[k])\n            else:\n                nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n            rvd[k] = 0\n    if not nd_fact_args[0] or not nd_fact_args[1]:\n        return rv\n    hit = False\n    for m in range(2):\n        i = 0\n        while i < len(nd_fact_args[m]):\n            ai = nd_fact_args[m][i]\n            for j in range(i + 1, len(nd_fact_args[m])):\n                aj = nd_fact_args[m][j]\n                sum = ai + aj\n                if sum in nd_fact_args[1 - m]:\n                    hit = True\n                    nd_fact_args[1 - m].remove(sum)\n                    del nd_fact_args[m][j]\n                    del nd_fact_args[m][i]\n                    rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                    break\n            else:\n                i += 1\n    if hit:\n        return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n    return rv",
            "def f(rv):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not rv.is_Mul:\n        return rv\n    rvd = rv.as_powers_dict()\n    nd_fact_args = [[], []]\n    for k in rvd:\n        if isinstance(k, factorial) and rvd[k].is_Integer:\n            if rvd[k].is_positive:\n                nd_fact_args[0].extend([k.args[0]] * rvd[k])\n            else:\n                nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n            rvd[k] = 0\n    if not nd_fact_args[0] or not nd_fact_args[1]:\n        return rv\n    hit = False\n    for m in range(2):\n        i = 0\n        while i < len(nd_fact_args[m]):\n            ai = nd_fact_args[m][i]\n            for j in range(i + 1, len(nd_fact_args[m])):\n                aj = nd_fact_args[m][j]\n                sum = ai + aj\n                if sum in nd_fact_args[1 - m]:\n                    hit = True\n                    nd_fact_args[1 - m].remove(sum)\n                    del nd_fact_args[m][j]\n                    del nd_fact_args[m][i]\n                    rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                    break\n            else:\n                i += 1\n    if hit:\n        return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n    return rv"
        ]
    },
    {
        "func_name": "_gamma_as_comb",
        "original": "def _gamma_as_comb(expr):\n    \"\"\"\n    Helper function for combsimp.\n\n    Rewrites expression in terms of factorials and binomials\n    \"\"\"\n    expr = expr.rewrite(factorial)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        nd_fact_args = [[], []]\n        for k in rvd:\n            if isinstance(k, factorial) and rvd[k].is_Integer:\n                if rvd[k].is_positive:\n                    nd_fact_args[0].extend([k.args[0]] * rvd[k])\n                else:\n                    nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n                rvd[k] = 0\n        if not nd_fact_args[0] or not nd_fact_args[1]:\n            return rv\n        hit = False\n        for m in range(2):\n            i = 0\n            while i < len(nd_fact_args[m]):\n                ai = nd_fact_args[m][i]\n                for j in range(i + 1, len(nd_fact_args[m])):\n                    aj = nd_fact_args[m][j]\n                    sum = ai + aj\n                    if sum in nd_fact_args[1 - m]:\n                        hit = True\n                        nd_fact_args[1 - m].remove(sum)\n                        del nd_fact_args[m][j]\n                        del nd_fact_args[m][i]\n                        rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                        break\n                else:\n                    i += 1\n        if hit:\n            return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n        return rv\n    return bottom_up(expr, f)",
        "mutated": [
            "def _gamma_as_comb(expr):\n    if False:\n        i = 10\n    '\\n    Helper function for combsimp.\\n\\n    Rewrites expression in terms of factorials and binomials\\n    '\n    expr = expr.rewrite(factorial)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        nd_fact_args = [[], []]\n        for k in rvd:\n            if isinstance(k, factorial) and rvd[k].is_Integer:\n                if rvd[k].is_positive:\n                    nd_fact_args[0].extend([k.args[0]] * rvd[k])\n                else:\n                    nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n                rvd[k] = 0\n        if not nd_fact_args[0] or not nd_fact_args[1]:\n            return rv\n        hit = False\n        for m in range(2):\n            i = 0\n            while i < len(nd_fact_args[m]):\n                ai = nd_fact_args[m][i]\n                for j in range(i + 1, len(nd_fact_args[m])):\n                    aj = nd_fact_args[m][j]\n                    sum = ai + aj\n                    if sum in nd_fact_args[1 - m]:\n                        hit = True\n                        nd_fact_args[1 - m].remove(sum)\n                        del nd_fact_args[m][j]\n                        del nd_fact_args[m][i]\n                        rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                        break\n                else:\n                    i += 1\n        if hit:\n            return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n        return rv\n    return bottom_up(expr, f)",
            "def _gamma_as_comb(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function for combsimp.\\n\\n    Rewrites expression in terms of factorials and binomials\\n    '\n    expr = expr.rewrite(factorial)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        nd_fact_args = [[], []]\n        for k in rvd:\n            if isinstance(k, factorial) and rvd[k].is_Integer:\n                if rvd[k].is_positive:\n                    nd_fact_args[0].extend([k.args[0]] * rvd[k])\n                else:\n                    nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n                rvd[k] = 0\n        if not nd_fact_args[0] or not nd_fact_args[1]:\n            return rv\n        hit = False\n        for m in range(2):\n            i = 0\n            while i < len(nd_fact_args[m]):\n                ai = nd_fact_args[m][i]\n                for j in range(i + 1, len(nd_fact_args[m])):\n                    aj = nd_fact_args[m][j]\n                    sum = ai + aj\n                    if sum in nd_fact_args[1 - m]:\n                        hit = True\n                        nd_fact_args[1 - m].remove(sum)\n                        del nd_fact_args[m][j]\n                        del nd_fact_args[m][i]\n                        rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                        break\n                else:\n                    i += 1\n        if hit:\n            return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n        return rv\n    return bottom_up(expr, f)",
            "def _gamma_as_comb(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function for combsimp.\\n\\n    Rewrites expression in terms of factorials and binomials\\n    '\n    expr = expr.rewrite(factorial)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        nd_fact_args = [[], []]\n        for k in rvd:\n            if isinstance(k, factorial) and rvd[k].is_Integer:\n                if rvd[k].is_positive:\n                    nd_fact_args[0].extend([k.args[0]] * rvd[k])\n                else:\n                    nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n                rvd[k] = 0\n        if not nd_fact_args[0] or not nd_fact_args[1]:\n            return rv\n        hit = False\n        for m in range(2):\n            i = 0\n            while i < len(nd_fact_args[m]):\n                ai = nd_fact_args[m][i]\n                for j in range(i + 1, len(nd_fact_args[m])):\n                    aj = nd_fact_args[m][j]\n                    sum = ai + aj\n                    if sum in nd_fact_args[1 - m]:\n                        hit = True\n                        nd_fact_args[1 - m].remove(sum)\n                        del nd_fact_args[m][j]\n                        del nd_fact_args[m][i]\n                        rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                        break\n                else:\n                    i += 1\n        if hit:\n            return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n        return rv\n    return bottom_up(expr, f)",
            "def _gamma_as_comb(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function for combsimp.\\n\\n    Rewrites expression in terms of factorials and binomials\\n    '\n    expr = expr.rewrite(factorial)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        nd_fact_args = [[], []]\n        for k in rvd:\n            if isinstance(k, factorial) and rvd[k].is_Integer:\n                if rvd[k].is_positive:\n                    nd_fact_args[0].extend([k.args[0]] * rvd[k])\n                else:\n                    nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n                rvd[k] = 0\n        if not nd_fact_args[0] or not nd_fact_args[1]:\n            return rv\n        hit = False\n        for m in range(2):\n            i = 0\n            while i < len(nd_fact_args[m]):\n                ai = nd_fact_args[m][i]\n                for j in range(i + 1, len(nd_fact_args[m])):\n                    aj = nd_fact_args[m][j]\n                    sum = ai + aj\n                    if sum in nd_fact_args[1 - m]:\n                        hit = True\n                        nd_fact_args[1 - m].remove(sum)\n                        del nd_fact_args[m][j]\n                        del nd_fact_args[m][i]\n                        rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                        break\n                else:\n                    i += 1\n        if hit:\n            return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n        return rv\n    return bottom_up(expr, f)",
            "def _gamma_as_comb(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function for combsimp.\\n\\n    Rewrites expression in terms of factorials and binomials\\n    '\n    expr = expr.rewrite(factorial)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        nd_fact_args = [[], []]\n        for k in rvd:\n            if isinstance(k, factorial) and rvd[k].is_Integer:\n                if rvd[k].is_positive:\n                    nd_fact_args[0].extend([k.args[0]] * rvd[k])\n                else:\n                    nd_fact_args[1].extend([k.args[0]] * -rvd[k])\n                rvd[k] = 0\n        if not nd_fact_args[0] or not nd_fact_args[1]:\n            return rv\n        hit = False\n        for m in range(2):\n            i = 0\n            while i < len(nd_fact_args[m]):\n                ai = nd_fact_args[m][i]\n                for j in range(i + 1, len(nd_fact_args[m])):\n                    aj = nd_fact_args[m][j]\n                    sum = ai + aj\n                    if sum in nd_fact_args[1 - m]:\n                        hit = True\n                        nd_fact_args[1 - m].remove(sum)\n                        del nd_fact_args[m][j]\n                        del nd_fact_args[m][i]\n                        rvd[binomial(sum, ai if count_ops(ai) < count_ops(aj) else aj)] += -1 if m == 0 else 1\n                        break\n                else:\n                    i += 1\n        if hit:\n            return Mul(*[k ** rvd[k] for k in rvd] + [factorial(k) for k in nd_fact_args[0]]) / Mul(*[factorial(k) for k in nd_fact_args[1]])\n        return rv\n    return bottom_up(expr, f)"
        ]
    }
]