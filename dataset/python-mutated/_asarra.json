[
    {
        "func_name": "require",
        "original": "@set_array_function_like_doc\n@set_module('numpy')\ndef require(a, dtype=None, requirements=None, *, like=None):\n    \"\"\"\n    Return an ndarray of the provided type that satisfies requirements.\n\n    This function is useful to be sure that an array with the correct flags\n    is returned for passing to compiled code (perhaps through ctypes).\n\n    Parameters\n    ----------\n    a : array_like\n       The object to be converted to a type-and-requirement-satisfying array.\n    dtype : data-type\n       The required data-type. If None preserve the current dtype. If your\n       application requires the data to be in native byteorder, include\n       a byteorder specification as a part of the dtype specification.\n    requirements : str or sequence of str\n       The requirements list can be any of the following\n\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\n       * 'WRITEABLE' ('W')    - ensure a writable array\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\n       * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        Array with specified requirements and type if given.\n\n    See Also\n    --------\n    asarray : Convert input to an ndarray.\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Notes\n    -----\n    The returned array will be guaranteed to have the listed requirements\n    by making a copy if needed.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x.flags\n      C_CONTIGUOUS : True\n      F_CONTIGUOUS : False\n      OWNDATA : False\n      WRITEABLE : True\n      ALIGNED : True\n      WRITEBACKIFCOPY : False\n\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n    >>> y.flags\n      C_CONTIGUOUS : False\n      F_CONTIGUOUS : True\n      OWNDATA : True\n      WRITEABLE : True\n      ALIGNED : True\n      WRITEBACKIFCOPY : False\n\n    \"\"\"\n    if like is not None:\n        return _require_with_like(like, a, dtype=dtype, requirements=requirements)\n    if not requirements:\n        return asanyarray(a, dtype=dtype)\n    requirements = {POSSIBLE_FLAGS[x.upper()] for x in requirements}\n    if 'E' in requirements:\n        requirements.remove('E')\n        subok = False\n    else:\n        subok = True\n    order = 'A'\n    if requirements >= {'C', 'F'}:\n        raise ValueError('Cannot specify both \"C\" and \"F\" order')\n    elif 'F' in requirements:\n        order = 'F'\n        requirements.remove('F')\n    elif 'C' in requirements:\n        order = 'C'\n        requirements.remove('C')\n    arr = array(a, dtype=dtype, order=order, copy=False, subok=subok)\n    for prop in requirements:\n        if not arr.flags[prop]:\n            return arr.copy(order)\n    return arr",
        "mutated": [
            "@set_array_function_like_doc\n@set_module('numpy')\ndef require(a, dtype=None, requirements=None, *, like=None):\n    if False:\n        i = 10\n    \"\\n    Return an ndarray of the provided type that satisfies requirements.\\n\\n    This function is useful to be sure that an array with the correct flags\\n    is returned for passing to compiled code (perhaps through ctypes).\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n       The object to be converted to a type-and-requirement-satisfying array.\\n    dtype : data-type\\n       The required data-type. If None preserve the current dtype. If your\\n       application requires the data to be in native byteorder, include\\n       a byteorder specification as a part of the dtype specification.\\n    requirements : str or sequence of str\\n       The requirements list can be any of the following\\n\\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\\n       * 'WRITEABLE' ('W')    - ensure a writable array\\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\\n       * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass\\n    ${ARRAY_FUNCTION_LIKE}\\n\\n        .. versionadded:: 1.20.0\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array with specified requirements and type if given.\\n\\n    See Also\\n    --------\\n    asarray : Convert input to an ndarray.\\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\\n    ascontiguousarray : Convert input to a contiguous array.\\n    asfortranarray : Convert input to an ndarray with column-major\\n                     memory order.\\n    ndarray.flags : Information about the memory layout of the array.\\n\\n    Notes\\n    -----\\n    The returned array will be guaranteed to have the listed requirements\\n    by making a copy if needed.\\n\\n    Examples\\n    --------\\n    >>> x = np.arange(6).reshape(2,3)\\n    >>> x.flags\\n      C_CONTIGUOUS : True\\n      F_CONTIGUOUS : False\\n      OWNDATA : False\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\\n    >>> y.flags\\n      C_CONTIGUOUS : False\\n      F_CONTIGUOUS : True\\n      OWNDATA : True\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    \"\n    if like is not None:\n        return _require_with_like(like, a, dtype=dtype, requirements=requirements)\n    if not requirements:\n        return asanyarray(a, dtype=dtype)\n    requirements = {POSSIBLE_FLAGS[x.upper()] for x in requirements}\n    if 'E' in requirements:\n        requirements.remove('E')\n        subok = False\n    else:\n        subok = True\n    order = 'A'\n    if requirements >= {'C', 'F'}:\n        raise ValueError('Cannot specify both \"C\" and \"F\" order')\n    elif 'F' in requirements:\n        order = 'F'\n        requirements.remove('F')\n    elif 'C' in requirements:\n        order = 'C'\n        requirements.remove('C')\n    arr = array(a, dtype=dtype, order=order, copy=False, subok=subok)\n    for prop in requirements:\n        if not arr.flags[prop]:\n            return arr.copy(order)\n    return arr",
            "@set_array_function_like_doc\n@set_module('numpy')\ndef require(a, dtype=None, requirements=None, *, like=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return an ndarray of the provided type that satisfies requirements.\\n\\n    This function is useful to be sure that an array with the correct flags\\n    is returned for passing to compiled code (perhaps through ctypes).\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n       The object to be converted to a type-and-requirement-satisfying array.\\n    dtype : data-type\\n       The required data-type. If None preserve the current dtype. If your\\n       application requires the data to be in native byteorder, include\\n       a byteorder specification as a part of the dtype specification.\\n    requirements : str or sequence of str\\n       The requirements list can be any of the following\\n\\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\\n       * 'WRITEABLE' ('W')    - ensure a writable array\\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\\n       * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass\\n    ${ARRAY_FUNCTION_LIKE}\\n\\n        .. versionadded:: 1.20.0\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array with specified requirements and type if given.\\n\\n    See Also\\n    --------\\n    asarray : Convert input to an ndarray.\\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\\n    ascontiguousarray : Convert input to a contiguous array.\\n    asfortranarray : Convert input to an ndarray with column-major\\n                     memory order.\\n    ndarray.flags : Information about the memory layout of the array.\\n\\n    Notes\\n    -----\\n    The returned array will be guaranteed to have the listed requirements\\n    by making a copy if needed.\\n\\n    Examples\\n    --------\\n    >>> x = np.arange(6).reshape(2,3)\\n    >>> x.flags\\n      C_CONTIGUOUS : True\\n      F_CONTIGUOUS : False\\n      OWNDATA : False\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\\n    >>> y.flags\\n      C_CONTIGUOUS : False\\n      F_CONTIGUOUS : True\\n      OWNDATA : True\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    \"\n    if like is not None:\n        return _require_with_like(like, a, dtype=dtype, requirements=requirements)\n    if not requirements:\n        return asanyarray(a, dtype=dtype)\n    requirements = {POSSIBLE_FLAGS[x.upper()] for x in requirements}\n    if 'E' in requirements:\n        requirements.remove('E')\n        subok = False\n    else:\n        subok = True\n    order = 'A'\n    if requirements >= {'C', 'F'}:\n        raise ValueError('Cannot specify both \"C\" and \"F\" order')\n    elif 'F' in requirements:\n        order = 'F'\n        requirements.remove('F')\n    elif 'C' in requirements:\n        order = 'C'\n        requirements.remove('C')\n    arr = array(a, dtype=dtype, order=order, copy=False, subok=subok)\n    for prop in requirements:\n        if not arr.flags[prop]:\n            return arr.copy(order)\n    return arr",
            "@set_array_function_like_doc\n@set_module('numpy')\ndef require(a, dtype=None, requirements=None, *, like=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return an ndarray of the provided type that satisfies requirements.\\n\\n    This function is useful to be sure that an array with the correct flags\\n    is returned for passing to compiled code (perhaps through ctypes).\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n       The object to be converted to a type-and-requirement-satisfying array.\\n    dtype : data-type\\n       The required data-type. If None preserve the current dtype. If your\\n       application requires the data to be in native byteorder, include\\n       a byteorder specification as a part of the dtype specification.\\n    requirements : str or sequence of str\\n       The requirements list can be any of the following\\n\\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\\n       * 'WRITEABLE' ('W')    - ensure a writable array\\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\\n       * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass\\n    ${ARRAY_FUNCTION_LIKE}\\n\\n        .. versionadded:: 1.20.0\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array with specified requirements and type if given.\\n\\n    See Also\\n    --------\\n    asarray : Convert input to an ndarray.\\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\\n    ascontiguousarray : Convert input to a contiguous array.\\n    asfortranarray : Convert input to an ndarray with column-major\\n                     memory order.\\n    ndarray.flags : Information about the memory layout of the array.\\n\\n    Notes\\n    -----\\n    The returned array will be guaranteed to have the listed requirements\\n    by making a copy if needed.\\n\\n    Examples\\n    --------\\n    >>> x = np.arange(6).reshape(2,3)\\n    >>> x.flags\\n      C_CONTIGUOUS : True\\n      F_CONTIGUOUS : False\\n      OWNDATA : False\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\\n    >>> y.flags\\n      C_CONTIGUOUS : False\\n      F_CONTIGUOUS : True\\n      OWNDATA : True\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    \"\n    if like is not None:\n        return _require_with_like(like, a, dtype=dtype, requirements=requirements)\n    if not requirements:\n        return asanyarray(a, dtype=dtype)\n    requirements = {POSSIBLE_FLAGS[x.upper()] for x in requirements}\n    if 'E' in requirements:\n        requirements.remove('E')\n        subok = False\n    else:\n        subok = True\n    order = 'A'\n    if requirements >= {'C', 'F'}:\n        raise ValueError('Cannot specify both \"C\" and \"F\" order')\n    elif 'F' in requirements:\n        order = 'F'\n        requirements.remove('F')\n    elif 'C' in requirements:\n        order = 'C'\n        requirements.remove('C')\n    arr = array(a, dtype=dtype, order=order, copy=False, subok=subok)\n    for prop in requirements:\n        if not arr.flags[prop]:\n            return arr.copy(order)\n    return arr",
            "@set_array_function_like_doc\n@set_module('numpy')\ndef require(a, dtype=None, requirements=None, *, like=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return an ndarray of the provided type that satisfies requirements.\\n\\n    This function is useful to be sure that an array with the correct flags\\n    is returned for passing to compiled code (perhaps through ctypes).\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n       The object to be converted to a type-and-requirement-satisfying array.\\n    dtype : data-type\\n       The required data-type. If None preserve the current dtype. If your\\n       application requires the data to be in native byteorder, include\\n       a byteorder specification as a part of the dtype specification.\\n    requirements : str or sequence of str\\n       The requirements list can be any of the following\\n\\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\\n       * 'WRITEABLE' ('W')    - ensure a writable array\\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\\n       * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass\\n    ${ARRAY_FUNCTION_LIKE}\\n\\n        .. versionadded:: 1.20.0\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array with specified requirements and type if given.\\n\\n    See Also\\n    --------\\n    asarray : Convert input to an ndarray.\\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\\n    ascontiguousarray : Convert input to a contiguous array.\\n    asfortranarray : Convert input to an ndarray with column-major\\n                     memory order.\\n    ndarray.flags : Information about the memory layout of the array.\\n\\n    Notes\\n    -----\\n    The returned array will be guaranteed to have the listed requirements\\n    by making a copy if needed.\\n\\n    Examples\\n    --------\\n    >>> x = np.arange(6).reshape(2,3)\\n    >>> x.flags\\n      C_CONTIGUOUS : True\\n      F_CONTIGUOUS : False\\n      OWNDATA : False\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\\n    >>> y.flags\\n      C_CONTIGUOUS : False\\n      F_CONTIGUOUS : True\\n      OWNDATA : True\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    \"\n    if like is not None:\n        return _require_with_like(like, a, dtype=dtype, requirements=requirements)\n    if not requirements:\n        return asanyarray(a, dtype=dtype)\n    requirements = {POSSIBLE_FLAGS[x.upper()] for x in requirements}\n    if 'E' in requirements:\n        requirements.remove('E')\n        subok = False\n    else:\n        subok = True\n    order = 'A'\n    if requirements >= {'C', 'F'}:\n        raise ValueError('Cannot specify both \"C\" and \"F\" order')\n    elif 'F' in requirements:\n        order = 'F'\n        requirements.remove('F')\n    elif 'C' in requirements:\n        order = 'C'\n        requirements.remove('C')\n    arr = array(a, dtype=dtype, order=order, copy=False, subok=subok)\n    for prop in requirements:\n        if not arr.flags[prop]:\n            return arr.copy(order)\n    return arr",
            "@set_array_function_like_doc\n@set_module('numpy')\ndef require(a, dtype=None, requirements=None, *, like=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return an ndarray of the provided type that satisfies requirements.\\n\\n    This function is useful to be sure that an array with the correct flags\\n    is returned for passing to compiled code (perhaps through ctypes).\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n       The object to be converted to a type-and-requirement-satisfying array.\\n    dtype : data-type\\n       The required data-type. If None preserve the current dtype. If your\\n       application requires the data to be in native byteorder, include\\n       a byteorder specification as a part of the dtype specification.\\n    requirements : str or sequence of str\\n       The requirements list can be any of the following\\n\\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\\n       * 'WRITEABLE' ('W')    - ensure a writable array\\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\\n       * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass\\n    ${ARRAY_FUNCTION_LIKE}\\n\\n        .. versionadded:: 1.20.0\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array with specified requirements and type if given.\\n\\n    See Also\\n    --------\\n    asarray : Convert input to an ndarray.\\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\\n    ascontiguousarray : Convert input to a contiguous array.\\n    asfortranarray : Convert input to an ndarray with column-major\\n                     memory order.\\n    ndarray.flags : Information about the memory layout of the array.\\n\\n    Notes\\n    -----\\n    The returned array will be guaranteed to have the listed requirements\\n    by making a copy if needed.\\n\\n    Examples\\n    --------\\n    >>> x = np.arange(6).reshape(2,3)\\n    >>> x.flags\\n      C_CONTIGUOUS : True\\n      F_CONTIGUOUS : False\\n      OWNDATA : False\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\\n    >>> y.flags\\n      C_CONTIGUOUS : False\\n      F_CONTIGUOUS : True\\n      OWNDATA : True\\n      WRITEABLE : True\\n      ALIGNED : True\\n      WRITEBACKIFCOPY : False\\n\\n    \"\n    if like is not None:\n        return _require_with_like(like, a, dtype=dtype, requirements=requirements)\n    if not requirements:\n        return asanyarray(a, dtype=dtype)\n    requirements = {POSSIBLE_FLAGS[x.upper()] for x in requirements}\n    if 'E' in requirements:\n        requirements.remove('E')\n        subok = False\n    else:\n        subok = True\n    order = 'A'\n    if requirements >= {'C', 'F'}:\n        raise ValueError('Cannot specify both \"C\" and \"F\" order')\n    elif 'F' in requirements:\n        order = 'F'\n        requirements.remove('F')\n    elif 'C' in requirements:\n        order = 'C'\n        requirements.remove('C')\n    arr = array(a, dtype=dtype, order=order, copy=False, subok=subok)\n    for prop in requirements:\n        if not arr.flags[prop]:\n            return arr.copy(order)\n    return arr"
        ]
    }
]