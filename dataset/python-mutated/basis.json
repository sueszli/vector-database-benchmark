[
    {
        "func_name": "_apply_Dedekind_criterion",
        "original": "def _apply_Dedekind_criterion(T, p):\n    \"\"\"\n    Apply the \"Dedekind criterion\" to test whether the order needs to be\n    enlarged relative to a given prime *p*.\n    \"\"\"\n    x = T.gen\n    T_bar = Poly(T, modulus=p)\n    (lc, fl) = T_bar.factor_list()\n    assert lc == 1\n    g_bar = Poly(1, x, modulus=p)\n    for (ti_bar, _) in fl:\n        g_bar *= ti_bar\n    h_bar = T_bar // g_bar\n    g = Poly(g_bar, domain=ZZ)\n    h = Poly(h_bar, domain=ZZ)\n    f = (g * h - T) // p\n    f_bar = Poly(f, modulus=p)\n    Z_bar = f_bar\n    for b in [g_bar, h_bar]:\n        Z_bar = Z_bar.gcd(b)\n    U_bar = T_bar // Z_bar\n    m = Z_bar.degree()\n    return (U_bar, m)",
        "mutated": [
            "def _apply_Dedekind_criterion(T, p):\n    if False:\n        i = 10\n    '\\n    Apply the \"Dedekind criterion\" to test whether the order needs to be\\n    enlarged relative to a given prime *p*.\\n    '\n    x = T.gen\n    T_bar = Poly(T, modulus=p)\n    (lc, fl) = T_bar.factor_list()\n    assert lc == 1\n    g_bar = Poly(1, x, modulus=p)\n    for (ti_bar, _) in fl:\n        g_bar *= ti_bar\n    h_bar = T_bar // g_bar\n    g = Poly(g_bar, domain=ZZ)\n    h = Poly(h_bar, domain=ZZ)\n    f = (g * h - T) // p\n    f_bar = Poly(f, modulus=p)\n    Z_bar = f_bar\n    for b in [g_bar, h_bar]:\n        Z_bar = Z_bar.gcd(b)\n    U_bar = T_bar // Z_bar\n    m = Z_bar.degree()\n    return (U_bar, m)",
            "def _apply_Dedekind_criterion(T, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Apply the \"Dedekind criterion\" to test whether the order needs to be\\n    enlarged relative to a given prime *p*.\\n    '\n    x = T.gen\n    T_bar = Poly(T, modulus=p)\n    (lc, fl) = T_bar.factor_list()\n    assert lc == 1\n    g_bar = Poly(1, x, modulus=p)\n    for (ti_bar, _) in fl:\n        g_bar *= ti_bar\n    h_bar = T_bar // g_bar\n    g = Poly(g_bar, domain=ZZ)\n    h = Poly(h_bar, domain=ZZ)\n    f = (g * h - T) // p\n    f_bar = Poly(f, modulus=p)\n    Z_bar = f_bar\n    for b in [g_bar, h_bar]:\n        Z_bar = Z_bar.gcd(b)\n    U_bar = T_bar // Z_bar\n    m = Z_bar.degree()\n    return (U_bar, m)",
            "def _apply_Dedekind_criterion(T, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Apply the \"Dedekind criterion\" to test whether the order needs to be\\n    enlarged relative to a given prime *p*.\\n    '\n    x = T.gen\n    T_bar = Poly(T, modulus=p)\n    (lc, fl) = T_bar.factor_list()\n    assert lc == 1\n    g_bar = Poly(1, x, modulus=p)\n    for (ti_bar, _) in fl:\n        g_bar *= ti_bar\n    h_bar = T_bar // g_bar\n    g = Poly(g_bar, domain=ZZ)\n    h = Poly(h_bar, domain=ZZ)\n    f = (g * h - T) // p\n    f_bar = Poly(f, modulus=p)\n    Z_bar = f_bar\n    for b in [g_bar, h_bar]:\n        Z_bar = Z_bar.gcd(b)\n    U_bar = T_bar // Z_bar\n    m = Z_bar.degree()\n    return (U_bar, m)",
            "def _apply_Dedekind_criterion(T, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Apply the \"Dedekind criterion\" to test whether the order needs to be\\n    enlarged relative to a given prime *p*.\\n    '\n    x = T.gen\n    T_bar = Poly(T, modulus=p)\n    (lc, fl) = T_bar.factor_list()\n    assert lc == 1\n    g_bar = Poly(1, x, modulus=p)\n    for (ti_bar, _) in fl:\n        g_bar *= ti_bar\n    h_bar = T_bar // g_bar\n    g = Poly(g_bar, domain=ZZ)\n    h = Poly(h_bar, domain=ZZ)\n    f = (g * h - T) // p\n    f_bar = Poly(f, modulus=p)\n    Z_bar = f_bar\n    for b in [g_bar, h_bar]:\n        Z_bar = Z_bar.gcd(b)\n    U_bar = T_bar // Z_bar\n    m = Z_bar.degree()\n    return (U_bar, m)",
            "def _apply_Dedekind_criterion(T, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Apply the \"Dedekind criterion\" to test whether the order needs to be\\n    enlarged relative to a given prime *p*.\\n    '\n    x = T.gen\n    T_bar = Poly(T, modulus=p)\n    (lc, fl) = T_bar.factor_list()\n    assert lc == 1\n    g_bar = Poly(1, x, modulus=p)\n    for (ti_bar, _) in fl:\n        g_bar *= ti_bar\n    h_bar = T_bar // g_bar\n    g = Poly(g_bar, domain=ZZ)\n    h = Poly(h_bar, domain=ZZ)\n    f = (g * h - T) // p\n    f_bar = Poly(f, modulus=p)\n    Z_bar = f_bar\n    for b in [g_bar, h_bar]:\n        Z_bar = Z_bar.gcd(b)\n    U_bar = T_bar // Z_bar\n    m = Z_bar.degree()\n    return (U_bar, m)"
        ]
    },
    {
        "func_name": "nilradical_mod_p",
        "original": "def nilradical_mod_p(H, p, q=None):\n    \"\"\"\n    Compute the nilradical mod *p* for a given order *H*, and prime *p*.\n\n    Explanation\n    ===========\n\n    This is the ideal $I$ in $H/pH$ consisting of all elements some positive\n    power of which is zero in this quotient ring, i.e. is a multiple of *p*.\n\n    Parameters\n    ==========\n\n    H : :py:class:`~.Submodule`\n        The given order.\n    p : int\n        The rational prime.\n    q : int, optional\n        If known, the smallest power of *p* that is $>=$ the dimension of *H*.\n        If not provided, we compute it here.\n\n    Returns\n    =======\n\n    :py:class:`~.Module` representing the nilradical mod *p* in *H*.\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory*.\n    (See Lemma 6.1.6.)\n\n    \"\"\"\n    n = H.n\n    if q is None:\n        q = p\n        while q < n:\n            q *= p\n    phi = ModuleEndomorphism(H, lambda x: x ** q)\n    return phi.kernel(modulus=p)",
        "mutated": [
            "def nilradical_mod_p(H, p, q=None):\n    if False:\n        i = 10\n    '\\n    Compute the nilradical mod *p* for a given order *H*, and prime *p*.\\n\\n    Explanation\\n    ===========\\n\\n    This is the ideal $I$ in $H/pH$ consisting of all elements some positive\\n    power of which is zero in this quotient ring, i.e. is a multiple of *p*.\\n\\n    Parameters\\n    ==========\\n\\n    H : :py:class:`~.Submodule`\\n        The given order.\\n    p : int\\n        The rational prime.\\n    q : int, optional\\n        If known, the smallest power of *p* that is $>=$ the dimension of *H*.\\n        If not provided, we compute it here.\\n\\n    Returns\\n    =======\\n\\n    :py:class:`~.Module` representing the nilradical mod *p* in *H*.\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory*.\\n    (See Lemma 6.1.6.)\\n\\n    '\n    n = H.n\n    if q is None:\n        q = p\n        while q < n:\n            q *= p\n    phi = ModuleEndomorphism(H, lambda x: x ** q)\n    return phi.kernel(modulus=p)",
            "def nilradical_mod_p(H, p, q=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the nilradical mod *p* for a given order *H*, and prime *p*.\\n\\n    Explanation\\n    ===========\\n\\n    This is the ideal $I$ in $H/pH$ consisting of all elements some positive\\n    power of which is zero in this quotient ring, i.e. is a multiple of *p*.\\n\\n    Parameters\\n    ==========\\n\\n    H : :py:class:`~.Submodule`\\n        The given order.\\n    p : int\\n        The rational prime.\\n    q : int, optional\\n        If known, the smallest power of *p* that is $>=$ the dimension of *H*.\\n        If not provided, we compute it here.\\n\\n    Returns\\n    =======\\n\\n    :py:class:`~.Module` representing the nilradical mod *p* in *H*.\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory*.\\n    (See Lemma 6.1.6.)\\n\\n    '\n    n = H.n\n    if q is None:\n        q = p\n        while q < n:\n            q *= p\n    phi = ModuleEndomorphism(H, lambda x: x ** q)\n    return phi.kernel(modulus=p)",
            "def nilradical_mod_p(H, p, q=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the nilradical mod *p* for a given order *H*, and prime *p*.\\n\\n    Explanation\\n    ===========\\n\\n    This is the ideal $I$ in $H/pH$ consisting of all elements some positive\\n    power of which is zero in this quotient ring, i.e. is a multiple of *p*.\\n\\n    Parameters\\n    ==========\\n\\n    H : :py:class:`~.Submodule`\\n        The given order.\\n    p : int\\n        The rational prime.\\n    q : int, optional\\n        If known, the smallest power of *p* that is $>=$ the dimension of *H*.\\n        If not provided, we compute it here.\\n\\n    Returns\\n    =======\\n\\n    :py:class:`~.Module` representing the nilradical mod *p* in *H*.\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory*.\\n    (See Lemma 6.1.6.)\\n\\n    '\n    n = H.n\n    if q is None:\n        q = p\n        while q < n:\n            q *= p\n    phi = ModuleEndomorphism(H, lambda x: x ** q)\n    return phi.kernel(modulus=p)",
            "def nilradical_mod_p(H, p, q=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the nilradical mod *p* for a given order *H*, and prime *p*.\\n\\n    Explanation\\n    ===========\\n\\n    This is the ideal $I$ in $H/pH$ consisting of all elements some positive\\n    power of which is zero in this quotient ring, i.e. is a multiple of *p*.\\n\\n    Parameters\\n    ==========\\n\\n    H : :py:class:`~.Submodule`\\n        The given order.\\n    p : int\\n        The rational prime.\\n    q : int, optional\\n        If known, the smallest power of *p* that is $>=$ the dimension of *H*.\\n        If not provided, we compute it here.\\n\\n    Returns\\n    =======\\n\\n    :py:class:`~.Module` representing the nilradical mod *p* in *H*.\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory*.\\n    (See Lemma 6.1.6.)\\n\\n    '\n    n = H.n\n    if q is None:\n        q = p\n        while q < n:\n            q *= p\n    phi = ModuleEndomorphism(H, lambda x: x ** q)\n    return phi.kernel(modulus=p)",
            "def nilradical_mod_p(H, p, q=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the nilradical mod *p* for a given order *H*, and prime *p*.\\n\\n    Explanation\\n    ===========\\n\\n    This is the ideal $I$ in $H/pH$ consisting of all elements some positive\\n    power of which is zero in this quotient ring, i.e. is a multiple of *p*.\\n\\n    Parameters\\n    ==========\\n\\n    H : :py:class:`~.Submodule`\\n        The given order.\\n    p : int\\n        The rational prime.\\n    q : int, optional\\n        If known, the smallest power of *p* that is $>=$ the dimension of *H*.\\n        If not provided, we compute it here.\\n\\n    Returns\\n    =======\\n\\n    :py:class:`~.Module` representing the nilradical mod *p* in *H*.\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory*.\\n    (See Lemma 6.1.6.)\\n\\n    '\n    n = H.n\n    if q is None:\n        q = p\n        while q < n:\n            q *= p\n    phi = ModuleEndomorphism(H, lambda x: x ** q)\n    return phi.kernel(modulus=p)"
        ]
    },
    {
        "func_name": "_second_enlargement",
        "original": "def _second_enlargement(H, p, q):\n    \"\"\"\n    Perform the second enlargement in the Round Two algorithm.\n    \"\"\"\n    Ip = nilradical_mod_p(H, p, q=q)\n    B = H.parent.submodule_from_matrix(H.matrix * Ip.matrix, denom=H.denom)\n    C = B + p * H\n    E = C.endomorphism_ring()\n    phi = ModuleHomomorphism(H, E, lambda x: E.inner_endomorphism(x))\n    gamma = phi.kernel(modulus=p)\n    G = H.parent.submodule_from_matrix(H.matrix * gamma.matrix, denom=H.denom * p)\n    H1 = G + H\n    return (H1, Ip)",
        "mutated": [
            "def _second_enlargement(H, p, q):\n    if False:\n        i = 10\n    '\\n    Perform the second enlargement in the Round Two algorithm.\\n    '\n    Ip = nilradical_mod_p(H, p, q=q)\n    B = H.parent.submodule_from_matrix(H.matrix * Ip.matrix, denom=H.denom)\n    C = B + p * H\n    E = C.endomorphism_ring()\n    phi = ModuleHomomorphism(H, E, lambda x: E.inner_endomorphism(x))\n    gamma = phi.kernel(modulus=p)\n    G = H.parent.submodule_from_matrix(H.matrix * gamma.matrix, denom=H.denom * p)\n    H1 = G + H\n    return (H1, Ip)",
            "def _second_enlargement(H, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Perform the second enlargement in the Round Two algorithm.\\n    '\n    Ip = nilradical_mod_p(H, p, q=q)\n    B = H.parent.submodule_from_matrix(H.matrix * Ip.matrix, denom=H.denom)\n    C = B + p * H\n    E = C.endomorphism_ring()\n    phi = ModuleHomomorphism(H, E, lambda x: E.inner_endomorphism(x))\n    gamma = phi.kernel(modulus=p)\n    G = H.parent.submodule_from_matrix(H.matrix * gamma.matrix, denom=H.denom * p)\n    H1 = G + H\n    return (H1, Ip)",
            "def _second_enlargement(H, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Perform the second enlargement in the Round Two algorithm.\\n    '\n    Ip = nilradical_mod_p(H, p, q=q)\n    B = H.parent.submodule_from_matrix(H.matrix * Ip.matrix, denom=H.denom)\n    C = B + p * H\n    E = C.endomorphism_ring()\n    phi = ModuleHomomorphism(H, E, lambda x: E.inner_endomorphism(x))\n    gamma = phi.kernel(modulus=p)\n    G = H.parent.submodule_from_matrix(H.matrix * gamma.matrix, denom=H.denom * p)\n    H1 = G + H\n    return (H1, Ip)",
            "def _second_enlargement(H, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Perform the second enlargement in the Round Two algorithm.\\n    '\n    Ip = nilradical_mod_p(H, p, q=q)\n    B = H.parent.submodule_from_matrix(H.matrix * Ip.matrix, denom=H.denom)\n    C = B + p * H\n    E = C.endomorphism_ring()\n    phi = ModuleHomomorphism(H, E, lambda x: E.inner_endomorphism(x))\n    gamma = phi.kernel(modulus=p)\n    G = H.parent.submodule_from_matrix(H.matrix * gamma.matrix, denom=H.denom * p)\n    H1 = G + H\n    return (H1, Ip)",
            "def _second_enlargement(H, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Perform the second enlargement in the Round Two algorithm.\\n    '\n    Ip = nilradical_mod_p(H, p, q=q)\n    B = H.parent.submodule_from_matrix(H.matrix * Ip.matrix, denom=H.denom)\n    C = B + p * H\n    E = C.endomorphism_ring()\n    phi = ModuleHomomorphism(H, E, lambda x: E.inner_endomorphism(x))\n    gamma = phi.kernel(modulus=p)\n    G = H.parent.submodule_from_matrix(H.matrix * gamma.matrix, denom=H.denom * p)\n    H1 = G + H\n    return (H1, Ip)"
        ]
    },
    {
        "func_name": "round_two",
        "original": "@public\ndef round_two(T, radicals=None):\n    \"\"\"\n    Zassenhaus's \"Round 2\" algorithm.\n\n    Explanation\n    ===========\n\n    Carry out Zassenhaus's \"Round 2\" algorithm on an irreducible polynomial\n    *T* over :ref:`ZZ` or :ref:`QQ`. This computes an integral basis and the\n    discriminant for the field $K = \\\\mathbb{Q}[x]/(T(x))$.\n\n    Alternatively, you may pass an :py:class:`~.AlgebraicField` instance, in\n    place of the polynomial *T*, in which case the algorithm is applied to the\n    minimal polynomial for the field's primitive element.\n\n    Ordinarily this function need not be called directly, as one can instead\n    access the :py:meth:`~.AlgebraicField.maximal_order`,\n    :py:meth:`~.AlgebraicField.integral_basis`, and\n    :py:meth:`~.AlgebraicField.discriminant` methods of an\n    :py:class:`~.AlgebraicField`.\n\n    Examples\n    ========\n\n    Working through an AlgebraicField:\n\n    >>> from sympy import Poly, QQ\n    >>> from sympy.abc import x\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\n    >>> K = QQ.alg_field_from_poly(T, \"theta\")\n    >>> print(K.maximal_order())\n    Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2\n    >>> print(K.discriminant())\n    -503\n    >>> print(K.integral_basis(fmt='sympy'))\n    [1, theta, theta/2 + theta**2/2]\n\n    Calling directly:\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x\n    >>> from sympy.polys.numberfields.basis import round_two\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\n    >>> print(round_two(T))\n    (Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2, -503)\n\n    The nilradicals mod $p$ that are sometimes computed during the Round Two\n    algorithm may be useful in further calculations. Pass a dictionary under\n    `radicals` to receive these:\n\n    >>> T = Poly(x**3 + 3*x**2 + 5)\n    >>> rad = {}\n    >>> ZK, dK = round_two(T, radicals=rad)\n    >>> print(rad)\n    {3: Submodule[[-1, 1, 0], [-1, 0, 1]]}\n\n    Parameters\n    ==========\n\n    T : :py:class:`~.Poly`, :py:class:`~.AlgebraicField`\n        Either (1) the irreducible polynomial over :ref:`ZZ` or :ref:`QQ`\n        defining the number field, or (2) an :py:class:`~.AlgebraicField`\n        representing the number field itself.\n\n    radicals : dict, optional\n        This is a way for any $p$-radicals (if computed) to be returned by\n        reference. If desired, pass an empty dictionary. If the algorithm\n        reaches the point where it computes the nilradical mod $p$ of the ring\n        of integers $Z_K$, then an $\\\\mathbb{F}_p$-basis for this ideal will be\n        stored in this dictionary under the key ``p``. This can be useful for\n        other algorithms, such as prime decomposition.\n\n    Returns\n    =======\n\n    Pair ``(ZK, dK)``, where:\n\n        ``ZK`` is a :py:class:`~sympy.polys.numberfields.modules.Submodule`\n        representing the maximal order.\n\n        ``dK`` is the discriminant of the field $K = \\\\mathbb{Q}[x]/(T(x))$.\n\n    See Also\n    ========\n\n    .AlgebraicField.maximal_order\n    .AlgebraicField.integral_basis\n    .AlgebraicField.discriminant\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n\n    \"\"\"\n    K = None\n    if isinstance(T, AlgebraicField):\n        (K, T) = (T, T.ext.minpoly_of_element())\n    if not T.is_univariate or not T.is_irreducible or T.domain not in [ZZ, QQ]:\n        raise ValueError('Round 2 requires an irreducible univariate polynomial over ZZ or QQ.')\n    (T, _) = T.make_monic_over_integers_by_scaling_roots()\n    n = T.degree()\n    D = T.discriminant()\n    D_modulus = ZZ.from_sympy(abs(D))\n    (_, F) = extract_fundamental_discriminant(D)\n    Ztheta = PowerBasis(K or T)\n    H = Ztheta.whole_submodule()\n    nilrad = None\n    while F:\n        (p, e) = F.popitem()\n        (U_bar, m) = _apply_Dedekind_criterion(T, p)\n        if m == 0:\n            continue\n        U = Ztheta.element_from_poly(Poly(U_bar, domain=ZZ))\n        H = H.add(U // p * H, hnf_modulus=D_modulus)\n        if e <= m:\n            continue\n        q = p\n        while q < n:\n            q *= p\n        (H1, nilrad) = _second_enlargement(H, p, q)\n        while H1 != H:\n            H = H1\n            (H1, nilrad) = _second_enlargement(H, p, q)\n    if nilrad is not None and isinstance(radicals, dict):\n        radicals[p] = nilrad\n    ZK = H\n    ZK._starts_with_unity = True\n    ZK._is_sq_maxrank_HNF = True\n    dK = D * ZK.matrix.det() ** 2 // ZK.denom ** (2 * n)\n    return (ZK, dK)",
        "mutated": [
            "@public\ndef round_two(T, radicals=None):\n    if False:\n        i = 10\n    '\\n    Zassenhaus\\'s \"Round 2\" algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Carry out Zassenhaus\\'s \"Round 2\" algorithm on an irreducible polynomial\\n    *T* over :ref:`ZZ` or :ref:`QQ`. This computes an integral basis and the\\n    discriminant for the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    Alternatively, you may pass an :py:class:`~.AlgebraicField` instance, in\\n    place of the polynomial *T*, in which case the algorithm is applied to the\\n    minimal polynomial for the field\\'s primitive element.\\n\\n    Ordinarily this function need not be called directly, as one can instead\\n    access the :py:meth:`~.AlgebraicField.maximal_order`,\\n    :py:meth:`~.AlgebraicField.integral_basis`, and\\n    :py:meth:`~.AlgebraicField.discriminant` methods of an\\n    :py:class:`~.AlgebraicField`.\\n\\n    Examples\\n    ========\\n\\n    Working through an AlgebraicField:\\n\\n    >>> from sympy import Poly, QQ\\n    >>> from sympy.abc import x\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> K = QQ.alg_field_from_poly(T, \"theta\")\\n    >>> print(K.maximal_order())\\n    Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2\\n    >>> print(K.discriminant())\\n    -503\\n    >>> print(K.integral_basis(fmt=\\'sympy\\'))\\n    [1, theta, theta/2 + theta**2/2]\\n\\n    Calling directly:\\n\\n    >>> from sympy import Poly\\n    >>> from sympy.abc import x\\n    >>> from sympy.polys.numberfields.basis import round_two\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> print(round_two(T))\\n    (Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2, -503)\\n\\n    The nilradicals mod $p$ that are sometimes computed during the Round Two\\n    algorithm may be useful in further calculations. Pass a dictionary under\\n    `radicals` to receive these:\\n\\n    >>> T = Poly(x**3 + 3*x**2 + 5)\\n    >>> rad = {}\\n    >>> ZK, dK = round_two(T, radicals=rad)\\n    >>> print(rad)\\n    {3: Submodule[[-1, 1, 0], [-1, 0, 1]]}\\n\\n    Parameters\\n    ==========\\n\\n    T : :py:class:`~.Poly`, :py:class:`~.AlgebraicField`\\n        Either (1) the irreducible polynomial over :ref:`ZZ` or :ref:`QQ`\\n        defining the number field, or (2) an :py:class:`~.AlgebraicField`\\n        representing the number field itself.\\n\\n    radicals : dict, optional\\n        This is a way for any $p$-radicals (if computed) to be returned by\\n        reference. If desired, pass an empty dictionary. If the algorithm\\n        reaches the point where it computes the nilradical mod $p$ of the ring\\n        of integers $Z_K$, then an $\\\\mathbb{F}_p$-basis for this ideal will be\\n        stored in this dictionary under the key ``p``. This can be useful for\\n        other algorithms, such as prime decomposition.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(ZK, dK)``, where:\\n\\n        ``ZK`` is a :py:class:`~sympy.polys.numberfields.modules.Submodule`\\n        representing the maximal order.\\n\\n        ``dK`` is the discriminant of the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    See Also\\n    ========\\n\\n    .AlgebraicField.maximal_order\\n    .AlgebraicField.integral_basis\\n    .AlgebraicField.discriminant\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\\n\\n    '\n    K = None\n    if isinstance(T, AlgebraicField):\n        (K, T) = (T, T.ext.minpoly_of_element())\n    if not T.is_univariate or not T.is_irreducible or T.domain not in [ZZ, QQ]:\n        raise ValueError('Round 2 requires an irreducible univariate polynomial over ZZ or QQ.')\n    (T, _) = T.make_monic_over_integers_by_scaling_roots()\n    n = T.degree()\n    D = T.discriminant()\n    D_modulus = ZZ.from_sympy(abs(D))\n    (_, F) = extract_fundamental_discriminant(D)\n    Ztheta = PowerBasis(K or T)\n    H = Ztheta.whole_submodule()\n    nilrad = None\n    while F:\n        (p, e) = F.popitem()\n        (U_bar, m) = _apply_Dedekind_criterion(T, p)\n        if m == 0:\n            continue\n        U = Ztheta.element_from_poly(Poly(U_bar, domain=ZZ))\n        H = H.add(U // p * H, hnf_modulus=D_modulus)\n        if e <= m:\n            continue\n        q = p\n        while q < n:\n            q *= p\n        (H1, nilrad) = _second_enlargement(H, p, q)\n        while H1 != H:\n            H = H1\n            (H1, nilrad) = _second_enlargement(H, p, q)\n    if nilrad is not None and isinstance(radicals, dict):\n        radicals[p] = nilrad\n    ZK = H\n    ZK._starts_with_unity = True\n    ZK._is_sq_maxrank_HNF = True\n    dK = D * ZK.matrix.det() ** 2 // ZK.denom ** (2 * n)\n    return (ZK, dK)",
            "@public\ndef round_two(T, radicals=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Zassenhaus\\'s \"Round 2\" algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Carry out Zassenhaus\\'s \"Round 2\" algorithm on an irreducible polynomial\\n    *T* over :ref:`ZZ` or :ref:`QQ`. This computes an integral basis and the\\n    discriminant for the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    Alternatively, you may pass an :py:class:`~.AlgebraicField` instance, in\\n    place of the polynomial *T*, in which case the algorithm is applied to the\\n    minimal polynomial for the field\\'s primitive element.\\n\\n    Ordinarily this function need not be called directly, as one can instead\\n    access the :py:meth:`~.AlgebraicField.maximal_order`,\\n    :py:meth:`~.AlgebraicField.integral_basis`, and\\n    :py:meth:`~.AlgebraicField.discriminant` methods of an\\n    :py:class:`~.AlgebraicField`.\\n\\n    Examples\\n    ========\\n\\n    Working through an AlgebraicField:\\n\\n    >>> from sympy import Poly, QQ\\n    >>> from sympy.abc import x\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> K = QQ.alg_field_from_poly(T, \"theta\")\\n    >>> print(K.maximal_order())\\n    Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2\\n    >>> print(K.discriminant())\\n    -503\\n    >>> print(K.integral_basis(fmt=\\'sympy\\'))\\n    [1, theta, theta/2 + theta**2/2]\\n\\n    Calling directly:\\n\\n    >>> from sympy import Poly\\n    >>> from sympy.abc import x\\n    >>> from sympy.polys.numberfields.basis import round_two\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> print(round_two(T))\\n    (Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2, -503)\\n\\n    The nilradicals mod $p$ that are sometimes computed during the Round Two\\n    algorithm may be useful in further calculations. Pass a dictionary under\\n    `radicals` to receive these:\\n\\n    >>> T = Poly(x**3 + 3*x**2 + 5)\\n    >>> rad = {}\\n    >>> ZK, dK = round_two(T, radicals=rad)\\n    >>> print(rad)\\n    {3: Submodule[[-1, 1, 0], [-1, 0, 1]]}\\n\\n    Parameters\\n    ==========\\n\\n    T : :py:class:`~.Poly`, :py:class:`~.AlgebraicField`\\n        Either (1) the irreducible polynomial over :ref:`ZZ` or :ref:`QQ`\\n        defining the number field, or (2) an :py:class:`~.AlgebraicField`\\n        representing the number field itself.\\n\\n    radicals : dict, optional\\n        This is a way for any $p$-radicals (if computed) to be returned by\\n        reference. If desired, pass an empty dictionary. If the algorithm\\n        reaches the point where it computes the nilradical mod $p$ of the ring\\n        of integers $Z_K$, then an $\\\\mathbb{F}_p$-basis for this ideal will be\\n        stored in this dictionary under the key ``p``. This can be useful for\\n        other algorithms, such as prime decomposition.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(ZK, dK)``, where:\\n\\n        ``ZK`` is a :py:class:`~sympy.polys.numberfields.modules.Submodule`\\n        representing the maximal order.\\n\\n        ``dK`` is the discriminant of the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    See Also\\n    ========\\n\\n    .AlgebraicField.maximal_order\\n    .AlgebraicField.integral_basis\\n    .AlgebraicField.discriminant\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\\n\\n    '\n    K = None\n    if isinstance(T, AlgebraicField):\n        (K, T) = (T, T.ext.minpoly_of_element())\n    if not T.is_univariate or not T.is_irreducible or T.domain not in [ZZ, QQ]:\n        raise ValueError('Round 2 requires an irreducible univariate polynomial over ZZ or QQ.')\n    (T, _) = T.make_monic_over_integers_by_scaling_roots()\n    n = T.degree()\n    D = T.discriminant()\n    D_modulus = ZZ.from_sympy(abs(D))\n    (_, F) = extract_fundamental_discriminant(D)\n    Ztheta = PowerBasis(K or T)\n    H = Ztheta.whole_submodule()\n    nilrad = None\n    while F:\n        (p, e) = F.popitem()\n        (U_bar, m) = _apply_Dedekind_criterion(T, p)\n        if m == 0:\n            continue\n        U = Ztheta.element_from_poly(Poly(U_bar, domain=ZZ))\n        H = H.add(U // p * H, hnf_modulus=D_modulus)\n        if e <= m:\n            continue\n        q = p\n        while q < n:\n            q *= p\n        (H1, nilrad) = _second_enlargement(H, p, q)\n        while H1 != H:\n            H = H1\n            (H1, nilrad) = _second_enlargement(H, p, q)\n    if nilrad is not None and isinstance(radicals, dict):\n        radicals[p] = nilrad\n    ZK = H\n    ZK._starts_with_unity = True\n    ZK._is_sq_maxrank_HNF = True\n    dK = D * ZK.matrix.det() ** 2 // ZK.denom ** (2 * n)\n    return (ZK, dK)",
            "@public\ndef round_two(T, radicals=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Zassenhaus\\'s \"Round 2\" algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Carry out Zassenhaus\\'s \"Round 2\" algorithm on an irreducible polynomial\\n    *T* over :ref:`ZZ` or :ref:`QQ`. This computes an integral basis and the\\n    discriminant for the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    Alternatively, you may pass an :py:class:`~.AlgebraicField` instance, in\\n    place of the polynomial *T*, in which case the algorithm is applied to the\\n    minimal polynomial for the field\\'s primitive element.\\n\\n    Ordinarily this function need not be called directly, as one can instead\\n    access the :py:meth:`~.AlgebraicField.maximal_order`,\\n    :py:meth:`~.AlgebraicField.integral_basis`, and\\n    :py:meth:`~.AlgebraicField.discriminant` methods of an\\n    :py:class:`~.AlgebraicField`.\\n\\n    Examples\\n    ========\\n\\n    Working through an AlgebraicField:\\n\\n    >>> from sympy import Poly, QQ\\n    >>> from sympy.abc import x\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> K = QQ.alg_field_from_poly(T, \"theta\")\\n    >>> print(K.maximal_order())\\n    Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2\\n    >>> print(K.discriminant())\\n    -503\\n    >>> print(K.integral_basis(fmt=\\'sympy\\'))\\n    [1, theta, theta/2 + theta**2/2]\\n\\n    Calling directly:\\n\\n    >>> from sympy import Poly\\n    >>> from sympy.abc import x\\n    >>> from sympy.polys.numberfields.basis import round_two\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> print(round_two(T))\\n    (Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2, -503)\\n\\n    The nilradicals mod $p$ that are sometimes computed during the Round Two\\n    algorithm may be useful in further calculations. Pass a dictionary under\\n    `radicals` to receive these:\\n\\n    >>> T = Poly(x**3 + 3*x**2 + 5)\\n    >>> rad = {}\\n    >>> ZK, dK = round_two(T, radicals=rad)\\n    >>> print(rad)\\n    {3: Submodule[[-1, 1, 0], [-1, 0, 1]]}\\n\\n    Parameters\\n    ==========\\n\\n    T : :py:class:`~.Poly`, :py:class:`~.AlgebraicField`\\n        Either (1) the irreducible polynomial over :ref:`ZZ` or :ref:`QQ`\\n        defining the number field, or (2) an :py:class:`~.AlgebraicField`\\n        representing the number field itself.\\n\\n    radicals : dict, optional\\n        This is a way for any $p$-radicals (if computed) to be returned by\\n        reference. If desired, pass an empty dictionary. If the algorithm\\n        reaches the point where it computes the nilradical mod $p$ of the ring\\n        of integers $Z_K$, then an $\\\\mathbb{F}_p$-basis for this ideal will be\\n        stored in this dictionary under the key ``p``. This can be useful for\\n        other algorithms, such as prime decomposition.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(ZK, dK)``, where:\\n\\n        ``ZK`` is a :py:class:`~sympy.polys.numberfields.modules.Submodule`\\n        representing the maximal order.\\n\\n        ``dK`` is the discriminant of the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    See Also\\n    ========\\n\\n    .AlgebraicField.maximal_order\\n    .AlgebraicField.integral_basis\\n    .AlgebraicField.discriminant\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\\n\\n    '\n    K = None\n    if isinstance(T, AlgebraicField):\n        (K, T) = (T, T.ext.minpoly_of_element())\n    if not T.is_univariate or not T.is_irreducible or T.domain not in [ZZ, QQ]:\n        raise ValueError('Round 2 requires an irreducible univariate polynomial over ZZ or QQ.')\n    (T, _) = T.make_monic_over_integers_by_scaling_roots()\n    n = T.degree()\n    D = T.discriminant()\n    D_modulus = ZZ.from_sympy(abs(D))\n    (_, F) = extract_fundamental_discriminant(D)\n    Ztheta = PowerBasis(K or T)\n    H = Ztheta.whole_submodule()\n    nilrad = None\n    while F:\n        (p, e) = F.popitem()\n        (U_bar, m) = _apply_Dedekind_criterion(T, p)\n        if m == 0:\n            continue\n        U = Ztheta.element_from_poly(Poly(U_bar, domain=ZZ))\n        H = H.add(U // p * H, hnf_modulus=D_modulus)\n        if e <= m:\n            continue\n        q = p\n        while q < n:\n            q *= p\n        (H1, nilrad) = _second_enlargement(H, p, q)\n        while H1 != H:\n            H = H1\n            (H1, nilrad) = _second_enlargement(H, p, q)\n    if nilrad is not None and isinstance(radicals, dict):\n        radicals[p] = nilrad\n    ZK = H\n    ZK._starts_with_unity = True\n    ZK._is_sq_maxrank_HNF = True\n    dK = D * ZK.matrix.det() ** 2 // ZK.denom ** (2 * n)\n    return (ZK, dK)",
            "@public\ndef round_two(T, radicals=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Zassenhaus\\'s \"Round 2\" algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Carry out Zassenhaus\\'s \"Round 2\" algorithm on an irreducible polynomial\\n    *T* over :ref:`ZZ` or :ref:`QQ`. This computes an integral basis and the\\n    discriminant for the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    Alternatively, you may pass an :py:class:`~.AlgebraicField` instance, in\\n    place of the polynomial *T*, in which case the algorithm is applied to the\\n    minimal polynomial for the field\\'s primitive element.\\n\\n    Ordinarily this function need not be called directly, as one can instead\\n    access the :py:meth:`~.AlgebraicField.maximal_order`,\\n    :py:meth:`~.AlgebraicField.integral_basis`, and\\n    :py:meth:`~.AlgebraicField.discriminant` methods of an\\n    :py:class:`~.AlgebraicField`.\\n\\n    Examples\\n    ========\\n\\n    Working through an AlgebraicField:\\n\\n    >>> from sympy import Poly, QQ\\n    >>> from sympy.abc import x\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> K = QQ.alg_field_from_poly(T, \"theta\")\\n    >>> print(K.maximal_order())\\n    Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2\\n    >>> print(K.discriminant())\\n    -503\\n    >>> print(K.integral_basis(fmt=\\'sympy\\'))\\n    [1, theta, theta/2 + theta**2/2]\\n\\n    Calling directly:\\n\\n    >>> from sympy import Poly\\n    >>> from sympy.abc import x\\n    >>> from sympy.polys.numberfields.basis import round_two\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> print(round_two(T))\\n    (Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2, -503)\\n\\n    The nilradicals mod $p$ that are sometimes computed during the Round Two\\n    algorithm may be useful in further calculations. Pass a dictionary under\\n    `radicals` to receive these:\\n\\n    >>> T = Poly(x**3 + 3*x**2 + 5)\\n    >>> rad = {}\\n    >>> ZK, dK = round_two(T, radicals=rad)\\n    >>> print(rad)\\n    {3: Submodule[[-1, 1, 0], [-1, 0, 1]]}\\n\\n    Parameters\\n    ==========\\n\\n    T : :py:class:`~.Poly`, :py:class:`~.AlgebraicField`\\n        Either (1) the irreducible polynomial over :ref:`ZZ` or :ref:`QQ`\\n        defining the number field, or (2) an :py:class:`~.AlgebraicField`\\n        representing the number field itself.\\n\\n    radicals : dict, optional\\n        This is a way for any $p$-radicals (if computed) to be returned by\\n        reference. If desired, pass an empty dictionary. If the algorithm\\n        reaches the point where it computes the nilradical mod $p$ of the ring\\n        of integers $Z_K$, then an $\\\\mathbb{F}_p$-basis for this ideal will be\\n        stored in this dictionary under the key ``p``. This can be useful for\\n        other algorithms, such as prime decomposition.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(ZK, dK)``, where:\\n\\n        ``ZK`` is a :py:class:`~sympy.polys.numberfields.modules.Submodule`\\n        representing the maximal order.\\n\\n        ``dK`` is the discriminant of the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    See Also\\n    ========\\n\\n    .AlgebraicField.maximal_order\\n    .AlgebraicField.integral_basis\\n    .AlgebraicField.discriminant\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\\n\\n    '\n    K = None\n    if isinstance(T, AlgebraicField):\n        (K, T) = (T, T.ext.minpoly_of_element())\n    if not T.is_univariate or not T.is_irreducible or T.domain not in [ZZ, QQ]:\n        raise ValueError('Round 2 requires an irreducible univariate polynomial over ZZ or QQ.')\n    (T, _) = T.make_monic_over_integers_by_scaling_roots()\n    n = T.degree()\n    D = T.discriminant()\n    D_modulus = ZZ.from_sympy(abs(D))\n    (_, F) = extract_fundamental_discriminant(D)\n    Ztheta = PowerBasis(K or T)\n    H = Ztheta.whole_submodule()\n    nilrad = None\n    while F:\n        (p, e) = F.popitem()\n        (U_bar, m) = _apply_Dedekind_criterion(T, p)\n        if m == 0:\n            continue\n        U = Ztheta.element_from_poly(Poly(U_bar, domain=ZZ))\n        H = H.add(U // p * H, hnf_modulus=D_modulus)\n        if e <= m:\n            continue\n        q = p\n        while q < n:\n            q *= p\n        (H1, nilrad) = _second_enlargement(H, p, q)\n        while H1 != H:\n            H = H1\n            (H1, nilrad) = _second_enlargement(H, p, q)\n    if nilrad is not None and isinstance(radicals, dict):\n        radicals[p] = nilrad\n    ZK = H\n    ZK._starts_with_unity = True\n    ZK._is_sq_maxrank_HNF = True\n    dK = D * ZK.matrix.det() ** 2 // ZK.denom ** (2 * n)\n    return (ZK, dK)",
            "@public\ndef round_two(T, radicals=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Zassenhaus\\'s \"Round 2\" algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Carry out Zassenhaus\\'s \"Round 2\" algorithm on an irreducible polynomial\\n    *T* over :ref:`ZZ` or :ref:`QQ`. This computes an integral basis and the\\n    discriminant for the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    Alternatively, you may pass an :py:class:`~.AlgebraicField` instance, in\\n    place of the polynomial *T*, in which case the algorithm is applied to the\\n    minimal polynomial for the field\\'s primitive element.\\n\\n    Ordinarily this function need not be called directly, as one can instead\\n    access the :py:meth:`~.AlgebraicField.maximal_order`,\\n    :py:meth:`~.AlgebraicField.integral_basis`, and\\n    :py:meth:`~.AlgebraicField.discriminant` methods of an\\n    :py:class:`~.AlgebraicField`.\\n\\n    Examples\\n    ========\\n\\n    Working through an AlgebraicField:\\n\\n    >>> from sympy import Poly, QQ\\n    >>> from sympy.abc import x\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> K = QQ.alg_field_from_poly(T, \"theta\")\\n    >>> print(K.maximal_order())\\n    Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2\\n    >>> print(K.discriminant())\\n    -503\\n    >>> print(K.integral_basis(fmt=\\'sympy\\'))\\n    [1, theta, theta/2 + theta**2/2]\\n\\n    Calling directly:\\n\\n    >>> from sympy import Poly\\n    >>> from sympy.abc import x\\n    >>> from sympy.polys.numberfields.basis import round_two\\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\\n    >>> print(round_two(T))\\n    (Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2, -503)\\n\\n    The nilradicals mod $p$ that are sometimes computed during the Round Two\\n    algorithm may be useful in further calculations. Pass a dictionary under\\n    `radicals` to receive these:\\n\\n    >>> T = Poly(x**3 + 3*x**2 + 5)\\n    >>> rad = {}\\n    >>> ZK, dK = round_two(T, radicals=rad)\\n    >>> print(rad)\\n    {3: Submodule[[-1, 1, 0], [-1, 0, 1]]}\\n\\n    Parameters\\n    ==========\\n\\n    T : :py:class:`~.Poly`, :py:class:`~.AlgebraicField`\\n        Either (1) the irreducible polynomial over :ref:`ZZ` or :ref:`QQ`\\n        defining the number field, or (2) an :py:class:`~.AlgebraicField`\\n        representing the number field itself.\\n\\n    radicals : dict, optional\\n        This is a way for any $p$-radicals (if computed) to be returned by\\n        reference. If desired, pass an empty dictionary. If the algorithm\\n        reaches the point where it computes the nilradical mod $p$ of the ring\\n        of integers $Z_K$, then an $\\\\mathbb{F}_p$-basis for this ideal will be\\n        stored in this dictionary under the key ``p``. This can be useful for\\n        other algorithms, such as prime decomposition.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(ZK, dK)``, where:\\n\\n        ``ZK`` is a :py:class:`~sympy.polys.numberfields.modules.Submodule`\\n        representing the maximal order.\\n\\n        ``dK`` is the discriminant of the field $K = \\\\mathbb{Q}[x]/(T(x))$.\\n\\n    See Also\\n    ========\\n\\n    .AlgebraicField.maximal_order\\n    .AlgebraicField.integral_basis\\n    .AlgebraicField.discriminant\\n\\n    References\\n    ==========\\n\\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\\n\\n    '\n    K = None\n    if isinstance(T, AlgebraicField):\n        (K, T) = (T, T.ext.minpoly_of_element())\n    if not T.is_univariate or not T.is_irreducible or T.domain not in [ZZ, QQ]:\n        raise ValueError('Round 2 requires an irreducible univariate polynomial over ZZ or QQ.')\n    (T, _) = T.make_monic_over_integers_by_scaling_roots()\n    n = T.degree()\n    D = T.discriminant()\n    D_modulus = ZZ.from_sympy(abs(D))\n    (_, F) = extract_fundamental_discriminant(D)\n    Ztheta = PowerBasis(K or T)\n    H = Ztheta.whole_submodule()\n    nilrad = None\n    while F:\n        (p, e) = F.popitem()\n        (U_bar, m) = _apply_Dedekind_criterion(T, p)\n        if m == 0:\n            continue\n        U = Ztheta.element_from_poly(Poly(U_bar, domain=ZZ))\n        H = H.add(U // p * H, hnf_modulus=D_modulus)\n        if e <= m:\n            continue\n        q = p\n        while q < n:\n            q *= p\n        (H1, nilrad) = _second_enlargement(H, p, q)\n        while H1 != H:\n            H = H1\n            (H1, nilrad) = _second_enlargement(H, p, q)\n    if nilrad is not None and isinstance(radicals, dict):\n        radicals[p] = nilrad\n    ZK = H\n    ZK._starts_with_unity = True\n    ZK._is_sq_maxrank_HNF = True\n    dK = D * ZK.matrix.det() ** 2 // ZK.denom ** (2 * n)\n    return (ZK, dK)"
        ]
    }
]