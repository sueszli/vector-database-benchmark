[
    {
        "func_name": "norm",
        "original": "def norm(p1, p2):\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5",
        "mutated": [
            "def norm(p1, p2):\n    if False:\n        i = 10\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5",
            "def norm(p1, p2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5",
            "def norm(p1, p2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5",
            "def norm(p1, p2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5",
            "def norm(p1, p2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5"
        ]
    },
    {
        "func_name": "geometry_median",
        "original": "def geometry_median(positions, median):\n    (numerator, denominator) = ([0.0, 0.0], 0.0)\n    for p in positions:\n        l = norm(median, p)\n        if not l:\n            continue\n        numerator[0] += p[0] / l\n        numerator[1] += p[1] / l\n        denominator += 1 / l\n    if denominator == 0.0:\n        return (True, None)\n    return (False, [numerator[0] / denominator, numerator[1] / denominator])",
        "mutated": [
            "def geometry_median(positions, median):\n    if False:\n        i = 10\n    (numerator, denominator) = ([0.0, 0.0], 0.0)\n    for p in positions:\n        l = norm(median, p)\n        if not l:\n            continue\n        numerator[0] += p[0] / l\n        numerator[1] += p[1] / l\n        denominator += 1 / l\n    if denominator == 0.0:\n        return (True, None)\n    return (False, [numerator[0] / denominator, numerator[1] / denominator])",
            "def geometry_median(positions, median):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (numerator, denominator) = ([0.0, 0.0], 0.0)\n    for p in positions:\n        l = norm(median, p)\n        if not l:\n            continue\n        numerator[0] += p[0] / l\n        numerator[1] += p[1] / l\n        denominator += 1 / l\n    if denominator == 0.0:\n        return (True, None)\n    return (False, [numerator[0] / denominator, numerator[1] / denominator])",
            "def geometry_median(positions, median):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (numerator, denominator) = ([0.0, 0.0], 0.0)\n    for p in positions:\n        l = norm(median, p)\n        if not l:\n            continue\n        numerator[0] += p[0] / l\n        numerator[1] += p[1] / l\n        denominator += 1 / l\n    if denominator == 0.0:\n        return (True, None)\n    return (False, [numerator[0] / denominator, numerator[1] / denominator])",
            "def geometry_median(positions, median):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (numerator, denominator) = ([0.0, 0.0], 0.0)\n    for p in positions:\n        l = norm(median, p)\n        if not l:\n            continue\n        numerator[0] += p[0] / l\n        numerator[1] += p[1] / l\n        denominator += 1 / l\n    if denominator == 0.0:\n        return (True, None)\n    return (False, [numerator[0] / denominator, numerator[1] / denominator])",
            "def geometry_median(positions, median):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (numerator, denominator) = ([0.0, 0.0], 0.0)\n    for p in positions:\n        l = norm(median, p)\n        if not l:\n            continue\n        numerator[0] += p[0] / l\n        numerator[1] += p[1] / l\n        denominator += 1 / l\n    if denominator == 0.0:\n        return (True, None)\n    return (False, [numerator[0] / denominator, numerator[1] / denominator])"
        ]
    },
    {
        "func_name": "getMinDistSum",
        "original": "def getMinDistSum(self, positions):\n    \"\"\"\n        :type positions: List[List[int]]\n        :rtype: float\n        \"\"\"\n    EPS = 1e-06\n\n    def norm(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def geometry_median(positions, median):\n        (numerator, denominator) = ([0.0, 0.0], 0.0)\n        for p in positions:\n            l = norm(median, p)\n            if not l:\n                continue\n            numerator[0] += p[0] / l\n            numerator[1] += p[1] / l\n            denominator += 1 / l\n        if denominator == 0.0:\n            return (True, None)\n        return (False, [numerator[0] / denominator, numerator[1] / denominator])\n    median = [float(sum((p[0] for p in positions))) / len(positions), float(sum((p[1] for p in positions))) / len(positions)]\n    prev_median = [float('-inf'), float('-inf')]\n    while norm(median, prev_median) * len(positions) > EPS:\n        (stopped, new_median) = geometry_median(positions, median)\n        if stopped:\n            break\n        (median, prev_median) = (new_median, median)\n    return sum((norm(median, p) for p in positions))",
        "mutated": [
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    EPS = 1e-06\n\n    def norm(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def geometry_median(positions, median):\n        (numerator, denominator) = ([0.0, 0.0], 0.0)\n        for p in positions:\n            l = norm(median, p)\n            if not l:\n                continue\n            numerator[0] += p[0] / l\n            numerator[1] += p[1] / l\n            denominator += 1 / l\n        if denominator == 0.0:\n            return (True, None)\n        return (False, [numerator[0] / denominator, numerator[1] / denominator])\n    median = [float(sum((p[0] for p in positions))) / len(positions), float(sum((p[1] for p in positions))) / len(positions)]\n    prev_median = [float('-inf'), float('-inf')]\n    while norm(median, prev_median) * len(positions) > EPS:\n        (stopped, new_median) = geometry_median(positions, median)\n        if stopped:\n            break\n        (median, prev_median) = (new_median, median)\n    return sum((norm(median, p) for p in positions))",
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    EPS = 1e-06\n\n    def norm(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def geometry_median(positions, median):\n        (numerator, denominator) = ([0.0, 0.0], 0.0)\n        for p in positions:\n            l = norm(median, p)\n            if not l:\n                continue\n            numerator[0] += p[0] / l\n            numerator[1] += p[1] / l\n            denominator += 1 / l\n        if denominator == 0.0:\n            return (True, None)\n        return (False, [numerator[0] / denominator, numerator[1] / denominator])\n    median = [float(sum((p[0] for p in positions))) / len(positions), float(sum((p[1] for p in positions))) / len(positions)]\n    prev_median = [float('-inf'), float('-inf')]\n    while norm(median, prev_median) * len(positions) > EPS:\n        (stopped, new_median) = geometry_median(positions, median)\n        if stopped:\n            break\n        (median, prev_median) = (new_median, median)\n    return sum((norm(median, p) for p in positions))",
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    EPS = 1e-06\n\n    def norm(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def geometry_median(positions, median):\n        (numerator, denominator) = ([0.0, 0.0], 0.0)\n        for p in positions:\n            l = norm(median, p)\n            if not l:\n                continue\n            numerator[0] += p[0] / l\n            numerator[1] += p[1] / l\n            denominator += 1 / l\n        if denominator == 0.0:\n            return (True, None)\n        return (False, [numerator[0] / denominator, numerator[1] / denominator])\n    median = [float(sum((p[0] for p in positions))) / len(positions), float(sum((p[1] for p in positions))) / len(positions)]\n    prev_median = [float('-inf'), float('-inf')]\n    while norm(median, prev_median) * len(positions) > EPS:\n        (stopped, new_median) = geometry_median(positions, median)\n        if stopped:\n            break\n        (median, prev_median) = (new_median, median)\n    return sum((norm(median, p) for p in positions))",
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    EPS = 1e-06\n\n    def norm(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def geometry_median(positions, median):\n        (numerator, denominator) = ([0.0, 0.0], 0.0)\n        for p in positions:\n            l = norm(median, p)\n            if not l:\n                continue\n            numerator[0] += p[0] / l\n            numerator[1] += p[1] / l\n            denominator += 1 / l\n        if denominator == 0.0:\n            return (True, None)\n        return (False, [numerator[0] / denominator, numerator[1] / denominator])\n    median = [float(sum((p[0] for p in positions))) / len(positions), float(sum((p[1] for p in positions))) / len(positions)]\n    prev_median = [float('-inf'), float('-inf')]\n    while norm(median, prev_median) * len(positions) > EPS:\n        (stopped, new_median) = geometry_median(positions, median)\n        if stopped:\n            break\n        (median, prev_median) = (new_median, median)\n    return sum((norm(median, p) for p in positions))",
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    EPS = 1e-06\n\n    def norm(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def geometry_median(positions, median):\n        (numerator, denominator) = ([0.0, 0.0], 0.0)\n        for p in positions:\n            l = norm(median, p)\n            if not l:\n                continue\n            numerator[0] += p[0] / l\n            numerator[1] += p[1] / l\n            denominator += 1 / l\n        if denominator == 0.0:\n            return (True, None)\n        return (False, [numerator[0] / denominator, numerator[1] / denominator])\n    median = [float(sum((p[0] for p in positions))) / len(positions), float(sum((p[1] for p in positions))) / len(positions)]\n    prev_median = [float('-inf'), float('-inf')]\n    while norm(median, prev_median) * len(positions) > EPS:\n        (stopped, new_median) = geometry_median(positions, median)\n        if stopped:\n            break\n        (median, prev_median) = (new_median, median)\n    return sum((norm(median, p) for p in positions))"
        ]
    },
    {
        "func_name": "dist",
        "original": "def dist(positions, p):\n    return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))",
        "mutated": [
            "def dist(positions, p):\n    if False:\n        i = 10\n    return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))",
            "def dist(positions, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))",
            "def dist(positions, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))",
            "def dist(positions, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))",
            "def dist(positions, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))"
        ]
    },
    {
        "func_name": "getMinDistSum",
        "original": "def getMinDistSum(self, positions):\n    \"\"\"\n        :type positions: List[List[int]]\n        :rtype: float\n        \"\"\"\n    DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    EPS = 1e-06\n\n    def dist(positions, p):\n        return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))\n    median = [0.0, 0.0]\n    median[0] = float(sum((x for (x, _) in positions))) / len(positions)\n    median[1] = float(sum((y for (_, y) in positions))) / len(positions)\n    result = dist(positions, median)\n    delta = float(max(max(positions, key=lambda x: x[0])[0], max(positions, key=lambda x: x[1])[1])) - float(min(min(positions, key=lambda x: x[0])[0], min(positions, key=lambda x: x[1])[1]))\n    while delta > EPS:\n        for (dx, dy) in DIRECTIONS:\n            new_median = [median[0] + delta * dx, median[1] + delta * dy]\n            nd = dist(positions, new_median)\n            if nd < result:\n                result = nd\n                median = new_median\n                break\n        else:\n            delta /= 2.0\n    return result",
        "mutated": [
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    EPS = 1e-06\n\n    def dist(positions, p):\n        return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))\n    median = [0.0, 0.0]\n    median[0] = float(sum((x for (x, _) in positions))) / len(positions)\n    median[1] = float(sum((y for (_, y) in positions))) / len(positions)\n    result = dist(positions, median)\n    delta = float(max(max(positions, key=lambda x: x[0])[0], max(positions, key=lambda x: x[1])[1])) - float(min(min(positions, key=lambda x: x[0])[0], min(positions, key=lambda x: x[1])[1]))\n    while delta > EPS:\n        for (dx, dy) in DIRECTIONS:\n            new_median = [median[0] + delta * dx, median[1] + delta * dy]\n            nd = dist(positions, new_median)\n            if nd < result:\n                result = nd\n                median = new_median\n                break\n        else:\n            delta /= 2.0\n    return result",
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    EPS = 1e-06\n\n    def dist(positions, p):\n        return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))\n    median = [0.0, 0.0]\n    median[0] = float(sum((x for (x, _) in positions))) / len(positions)\n    median[1] = float(sum((y for (_, y) in positions))) / len(positions)\n    result = dist(positions, median)\n    delta = float(max(max(positions, key=lambda x: x[0])[0], max(positions, key=lambda x: x[1])[1])) - float(min(min(positions, key=lambda x: x[0])[0], min(positions, key=lambda x: x[1])[1]))\n    while delta > EPS:\n        for (dx, dy) in DIRECTIONS:\n            new_median = [median[0] + delta * dx, median[1] + delta * dy]\n            nd = dist(positions, new_median)\n            if nd < result:\n                result = nd\n                median = new_median\n                break\n        else:\n            delta /= 2.0\n    return result",
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    EPS = 1e-06\n\n    def dist(positions, p):\n        return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))\n    median = [0.0, 0.0]\n    median[0] = float(sum((x for (x, _) in positions))) / len(positions)\n    median[1] = float(sum((y for (_, y) in positions))) / len(positions)\n    result = dist(positions, median)\n    delta = float(max(max(positions, key=lambda x: x[0])[0], max(positions, key=lambda x: x[1])[1])) - float(min(min(positions, key=lambda x: x[0])[0], min(positions, key=lambda x: x[1])[1]))\n    while delta > EPS:\n        for (dx, dy) in DIRECTIONS:\n            new_median = [median[0] + delta * dx, median[1] + delta * dy]\n            nd = dist(positions, new_median)\n            if nd < result:\n                result = nd\n                median = new_median\n                break\n        else:\n            delta /= 2.0\n    return result",
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    EPS = 1e-06\n\n    def dist(positions, p):\n        return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))\n    median = [0.0, 0.0]\n    median[0] = float(sum((x for (x, _) in positions))) / len(positions)\n    median[1] = float(sum((y for (_, y) in positions))) / len(positions)\n    result = dist(positions, median)\n    delta = float(max(max(positions, key=lambda x: x[0])[0], max(positions, key=lambda x: x[1])[1])) - float(min(min(positions, key=lambda x: x[0])[0], min(positions, key=lambda x: x[1])[1]))\n    while delta > EPS:\n        for (dx, dy) in DIRECTIONS:\n            new_median = [median[0] + delta * dx, median[1] + delta * dy]\n            nd = dist(positions, new_median)\n            if nd < result:\n                result = nd\n                median = new_median\n                break\n        else:\n            delta /= 2.0\n    return result",
            "def getMinDistSum(self, positions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        '\n    DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    EPS = 1e-06\n\n    def dist(positions, p):\n        return sum((((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for (x, y) in positions))\n    median = [0.0, 0.0]\n    median[0] = float(sum((x for (x, _) in positions))) / len(positions)\n    median[1] = float(sum((y for (_, y) in positions))) / len(positions)\n    result = dist(positions, median)\n    delta = float(max(max(positions, key=lambda x: x[0])[0], max(positions, key=lambda x: x[1])[1])) - float(min(min(positions, key=lambda x: x[0])[0], min(positions, key=lambda x: x[1])[1]))\n    while delta > EPS:\n        for (dx, dy) in DIRECTIONS:\n            new_median = [median[0] + delta * dx, median[1] + delta * dy]\n            nd = dist(positions, new_median)\n            if nd < result:\n                result = nd\n                median = new_median\n                break\n        else:\n            delta /= 2.0\n    return result"
        ]
    }
]