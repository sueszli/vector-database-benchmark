[
    {
        "func_name": "_all_gather_into_tensor_in_dygraph",
        "original": "def _all_gather_into_tensor_in_dygraph(out_tensor, in_tensor, group, sync_op, use_calc_stream):\n    group = _get_global_group() if group is None else group\n    if use_calc_stream:\n        return group.process_group.all_gather_into_tensor_on_calc_stream(out_tensor, in_tensor)\n    task = group.process_group.all_gather_into_tensor(out_tensor, in_tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
        "mutated": [
            "def _all_gather_into_tensor_in_dygraph(out_tensor, in_tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n    group = _get_global_group() if group is None else group\n    if use_calc_stream:\n        return group.process_group.all_gather_into_tensor_on_calc_stream(out_tensor, in_tensor)\n    task = group.process_group.all_gather_into_tensor(out_tensor, in_tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
            "def _all_gather_into_tensor_in_dygraph(out_tensor, in_tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    group = _get_global_group() if group is None else group\n    if use_calc_stream:\n        return group.process_group.all_gather_into_tensor_on_calc_stream(out_tensor, in_tensor)\n    task = group.process_group.all_gather_into_tensor(out_tensor, in_tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
            "def _all_gather_into_tensor_in_dygraph(out_tensor, in_tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    group = _get_global_group() if group is None else group\n    if use_calc_stream:\n        return group.process_group.all_gather_into_tensor_on_calc_stream(out_tensor, in_tensor)\n    task = group.process_group.all_gather_into_tensor(out_tensor, in_tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
            "def _all_gather_into_tensor_in_dygraph(out_tensor, in_tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    group = _get_global_group() if group is None else group\n    if use_calc_stream:\n        return group.process_group.all_gather_into_tensor_on_calc_stream(out_tensor, in_tensor)\n    task = group.process_group.all_gather_into_tensor(out_tensor, in_tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
            "def _all_gather_into_tensor_in_dygraph(out_tensor, in_tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    group = _get_global_group() if group is None else group\n    if use_calc_stream:\n        return group.process_group.all_gather_into_tensor_on_calc_stream(out_tensor, in_tensor)\n    task = group.process_group.all_gather_into_tensor(out_tensor, in_tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task"
        ]
    },
    {
        "func_name": "_all_gather_in_dygraph",
        "original": "def _all_gather_in_dygraph(tensor_list, tensor, group, sync_op, use_calc_stream):\n    group = _get_global_group() if group is None else group\n    if len(tensor_list) == 0:\n        tensor_list += [paddle.empty_like(tensor) for _ in range(group.nranks)]\n    if use_calc_stream:\n        return group.process_group.all_gather_on_calc_stream(tensor_list, tensor)\n    task = group.process_group.all_gather(tensor_list, tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
        "mutated": [
            "def _all_gather_in_dygraph(tensor_list, tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n    group = _get_global_group() if group is None else group\n    if len(tensor_list) == 0:\n        tensor_list += [paddle.empty_like(tensor) for _ in range(group.nranks)]\n    if use_calc_stream:\n        return group.process_group.all_gather_on_calc_stream(tensor_list, tensor)\n    task = group.process_group.all_gather(tensor_list, tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
            "def _all_gather_in_dygraph(tensor_list, tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    group = _get_global_group() if group is None else group\n    if len(tensor_list) == 0:\n        tensor_list += [paddle.empty_like(tensor) for _ in range(group.nranks)]\n    if use_calc_stream:\n        return group.process_group.all_gather_on_calc_stream(tensor_list, tensor)\n    task = group.process_group.all_gather(tensor_list, tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
            "def _all_gather_in_dygraph(tensor_list, tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    group = _get_global_group() if group is None else group\n    if len(tensor_list) == 0:\n        tensor_list += [paddle.empty_like(tensor) for _ in range(group.nranks)]\n    if use_calc_stream:\n        return group.process_group.all_gather_on_calc_stream(tensor_list, tensor)\n    task = group.process_group.all_gather(tensor_list, tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
            "def _all_gather_in_dygraph(tensor_list, tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    group = _get_global_group() if group is None else group\n    if len(tensor_list) == 0:\n        tensor_list += [paddle.empty_like(tensor) for _ in range(group.nranks)]\n    if use_calc_stream:\n        return group.process_group.all_gather_on_calc_stream(tensor_list, tensor)\n    task = group.process_group.all_gather(tensor_list, tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task",
            "def _all_gather_in_dygraph(tensor_list, tensor, group, sync_op, use_calc_stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    group = _get_global_group() if group is None else group\n    if len(tensor_list) == 0:\n        tensor_list += [paddle.empty_like(tensor) for _ in range(group.nranks)]\n    if use_calc_stream:\n        return group.process_group.all_gather_on_calc_stream(tensor_list, tensor)\n    task = group.process_group.all_gather(tensor_list, tensor, sync_op)\n    if sync_op:\n        task.wait()\n    return task"
        ]
    },
    {
        "func_name": "_all_gather_in_static_mode",
        "original": "def _all_gather_in_static_mode(tensor_list, tensor, group, sync_op):\n    op_type = 'c_allgather'\n    helper = framework.LayerHelper(op_type, **locals())\n    out = helper.create_variable_for_type_inference(dtype=tensor.dtype)\n    for elem in tensor_list:\n        data_feeder.check_variable_and_dtype(elem, 'tensor_list', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    data_feeder.check_variable_and_dtype(tensor, 'tensor', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    ring_id = 0 if group is None else group.id\n    nranks = dist.get_world_size()\n    helper.append_op(type=op_type, inputs={'X': [tensor]}, outputs={'Out': [out]}, attrs={'ring_id': ring_id, 'use_calc_stream': sync_op, 'nranks': nranks})\n    tensor_list.clear()\n    if len(tensor.shape) == 0:\n        tensor_list.extend(paddle.unstack(out, 0))\n    else:\n        tensor_list.extend(paddle.split(out, nranks, 0))",
        "mutated": [
            "def _all_gather_in_static_mode(tensor_list, tensor, group, sync_op):\n    if False:\n        i = 10\n    op_type = 'c_allgather'\n    helper = framework.LayerHelper(op_type, **locals())\n    out = helper.create_variable_for_type_inference(dtype=tensor.dtype)\n    for elem in tensor_list:\n        data_feeder.check_variable_and_dtype(elem, 'tensor_list', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    data_feeder.check_variable_and_dtype(tensor, 'tensor', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    ring_id = 0 if group is None else group.id\n    nranks = dist.get_world_size()\n    helper.append_op(type=op_type, inputs={'X': [tensor]}, outputs={'Out': [out]}, attrs={'ring_id': ring_id, 'use_calc_stream': sync_op, 'nranks': nranks})\n    tensor_list.clear()\n    if len(tensor.shape) == 0:\n        tensor_list.extend(paddle.unstack(out, 0))\n    else:\n        tensor_list.extend(paddle.split(out, nranks, 0))",
            "def _all_gather_in_static_mode(tensor_list, tensor, group, sync_op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    op_type = 'c_allgather'\n    helper = framework.LayerHelper(op_type, **locals())\n    out = helper.create_variable_for_type_inference(dtype=tensor.dtype)\n    for elem in tensor_list:\n        data_feeder.check_variable_and_dtype(elem, 'tensor_list', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    data_feeder.check_variable_and_dtype(tensor, 'tensor', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    ring_id = 0 if group is None else group.id\n    nranks = dist.get_world_size()\n    helper.append_op(type=op_type, inputs={'X': [tensor]}, outputs={'Out': [out]}, attrs={'ring_id': ring_id, 'use_calc_stream': sync_op, 'nranks': nranks})\n    tensor_list.clear()\n    if len(tensor.shape) == 0:\n        tensor_list.extend(paddle.unstack(out, 0))\n    else:\n        tensor_list.extend(paddle.split(out, nranks, 0))",
            "def _all_gather_in_static_mode(tensor_list, tensor, group, sync_op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    op_type = 'c_allgather'\n    helper = framework.LayerHelper(op_type, **locals())\n    out = helper.create_variable_for_type_inference(dtype=tensor.dtype)\n    for elem in tensor_list:\n        data_feeder.check_variable_and_dtype(elem, 'tensor_list', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    data_feeder.check_variable_and_dtype(tensor, 'tensor', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    ring_id = 0 if group is None else group.id\n    nranks = dist.get_world_size()\n    helper.append_op(type=op_type, inputs={'X': [tensor]}, outputs={'Out': [out]}, attrs={'ring_id': ring_id, 'use_calc_stream': sync_op, 'nranks': nranks})\n    tensor_list.clear()\n    if len(tensor.shape) == 0:\n        tensor_list.extend(paddle.unstack(out, 0))\n    else:\n        tensor_list.extend(paddle.split(out, nranks, 0))",
            "def _all_gather_in_static_mode(tensor_list, tensor, group, sync_op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    op_type = 'c_allgather'\n    helper = framework.LayerHelper(op_type, **locals())\n    out = helper.create_variable_for_type_inference(dtype=tensor.dtype)\n    for elem in tensor_list:\n        data_feeder.check_variable_and_dtype(elem, 'tensor_list', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    data_feeder.check_variable_and_dtype(tensor, 'tensor', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    ring_id = 0 if group is None else group.id\n    nranks = dist.get_world_size()\n    helper.append_op(type=op_type, inputs={'X': [tensor]}, outputs={'Out': [out]}, attrs={'ring_id': ring_id, 'use_calc_stream': sync_op, 'nranks': nranks})\n    tensor_list.clear()\n    if len(tensor.shape) == 0:\n        tensor_list.extend(paddle.unstack(out, 0))\n    else:\n        tensor_list.extend(paddle.split(out, nranks, 0))",
            "def _all_gather_in_static_mode(tensor_list, tensor, group, sync_op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    op_type = 'c_allgather'\n    helper = framework.LayerHelper(op_type, **locals())\n    out = helper.create_variable_for_type_inference(dtype=tensor.dtype)\n    for elem in tensor_list:\n        data_feeder.check_variable_and_dtype(elem, 'tensor_list', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    data_feeder.check_variable_and_dtype(tensor, 'tensor', ['float16', 'float32', 'float64', 'int32', 'int64', 'bool', 'int8', 'uint8'], 'all_gather')\n    ring_id = 0 if group is None else group.id\n    nranks = dist.get_world_size()\n    helper.append_op(type=op_type, inputs={'X': [tensor]}, outputs={'Out': [out]}, attrs={'ring_id': ring_id, 'use_calc_stream': sync_op, 'nranks': nranks})\n    tensor_list.clear()\n    if len(tensor.shape) == 0:\n        tensor_list.extend(paddle.unstack(out, 0))\n    else:\n        tensor_list.extend(paddle.split(out, nranks, 0))"
        ]
    },
    {
        "func_name": "all_gather",
        "original": "def all_gather(tensor_or_tensor_list, tensor, group=None, sync_op=True, use_calc_stream=False):\n    \"\"\"\n\n    Gather tensors across devices to a correctly-sized tensor or a tensor list.\n\n    Args:\n        tensor_or_tensor_list (Union[Tensor, List[Tensor]]): The output. If it is a tensor, it should be correctly-sized. If it is a list, it\n            should be empty or contain correctly-sized tensors.\n        tensor (Tensor): The input tensor on each rank. The result will overwrite this tenor after communication. Support\n            float16, float32, float64, int32, int64, int8, uint8 or bool as the input data type.\n        group (Group, optional): Communicate in which group. If none is given, use the global group as default.\n        sync_op (bool, optional): Indicate whether the communication is sync or not. If none is given, use true as default.\n        use_calc_stream (bool, optional): Indicate whether the communication is done on calculation stream. If none is given, use false as default. This\n            option is designed for high performance demand, be careful to turn it on except you are clearly know its meaning.\n\n    Returns:\n        Return a task object.\n\n    Warning:\n        This API only supports the dygraph mode now.\n\n    Examples:\n        .. code-block:: python\n\n            >>> # doctest: +REQUIRES(env: DISTRIBUTED)\n            >>> import paddle\n            >>> import paddle.distributed as dist\n\n            >>> dist.init_parallel_env()\n            >>> local_rank = dist.get_rank()\n            >>> tensor_list = []\n            >>> if local_rank == 0:\n            ...     data = paddle.to_tensor([[4, 5, 6], [4, 5, 6]])\n            >>> else:\n            ...     data = paddle.to_tensor([[1, 2, 3], [1, 2, 3]])\n            >>> task = dist.stream.all_gather(tensor_list, data, sync_op=False)\n            >>> task.wait()\n            >>> print(tensor_list)\n            [[[4, 5, 6], [4, 5, 6]], [[1, 2, 3], [1, 2, 3]]] (2 GPUs)\n    \"\"\"\n    if group is not None and (not group.is_member()):\n        raise RuntimeError('The group should not be None and all ranks which invoke this operation should be the member of this group.')\n    if not sync_op and use_calc_stream:\n        raise RuntimeError('use_calc_stream can only be true in sync op behavior.')\n    if framework.in_dynamic_mode():\n        if paddle.is_tensor(tensor_or_tensor_list):\n            return _all_gather_into_tensor_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n        else:\n            return _all_gather_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n    else:\n        assert group is None, 'Group can not be used in static graph mode for now.'\n        if paddle.is_tensor(tensor_or_tensor_list):\n            raise RuntimeError('Only support passing a tensor list to `all_gather` in static graph mode now.')\n        else:\n            return _all_gather_in_static_mode(tensor_or_tensor_list, tensor, group, sync_op)",
        "mutated": [
            "def all_gather(tensor_or_tensor_list, tensor, group=None, sync_op=True, use_calc_stream=False):\n    if False:\n        i = 10\n    '\\n\\n    Gather tensors across devices to a correctly-sized tensor or a tensor list.\\n\\n    Args:\\n        tensor_or_tensor_list (Union[Tensor, List[Tensor]]): The output. If it is a tensor, it should be correctly-sized. If it is a list, it\\n            should be empty or contain correctly-sized tensors.\\n        tensor (Tensor): The input tensor on each rank. The result will overwrite this tenor after communication. Support\\n            float16, float32, float64, int32, int64, int8, uint8 or bool as the input data type.\\n        group (Group, optional): Communicate in which group. If none is given, use the global group as default.\\n        sync_op (bool, optional): Indicate whether the communication is sync or not. If none is given, use true as default.\\n        use_calc_stream (bool, optional): Indicate whether the communication is done on calculation stream. If none is given, use false as default. This\\n            option is designed for high performance demand, be careful to turn it on except you are clearly know its meaning.\\n\\n    Returns:\\n        Return a task object.\\n\\n    Warning:\\n        This API only supports the dygraph mode now.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env: DISTRIBUTED)\\n            >>> import paddle\\n            >>> import paddle.distributed as dist\\n\\n            >>> dist.init_parallel_env()\\n            >>> local_rank = dist.get_rank()\\n            >>> tensor_list = []\\n            >>> if local_rank == 0:\\n            ...     data = paddle.to_tensor([[4, 5, 6], [4, 5, 6]])\\n            >>> else:\\n            ...     data = paddle.to_tensor([[1, 2, 3], [1, 2, 3]])\\n            >>> task = dist.stream.all_gather(tensor_list, data, sync_op=False)\\n            >>> task.wait()\\n            >>> print(tensor_list)\\n            [[[4, 5, 6], [4, 5, 6]], [[1, 2, 3], [1, 2, 3]]] (2 GPUs)\\n    '\n    if group is not None and (not group.is_member()):\n        raise RuntimeError('The group should not be None and all ranks which invoke this operation should be the member of this group.')\n    if not sync_op and use_calc_stream:\n        raise RuntimeError('use_calc_stream can only be true in sync op behavior.')\n    if framework.in_dynamic_mode():\n        if paddle.is_tensor(tensor_or_tensor_list):\n            return _all_gather_into_tensor_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n        else:\n            return _all_gather_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n    else:\n        assert group is None, 'Group can not be used in static graph mode for now.'\n        if paddle.is_tensor(tensor_or_tensor_list):\n            raise RuntimeError('Only support passing a tensor list to `all_gather` in static graph mode now.')\n        else:\n            return _all_gather_in_static_mode(tensor_or_tensor_list, tensor, group, sync_op)",
            "def all_gather(tensor_or_tensor_list, tensor, group=None, sync_op=True, use_calc_stream=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n    Gather tensors across devices to a correctly-sized tensor or a tensor list.\\n\\n    Args:\\n        tensor_or_tensor_list (Union[Tensor, List[Tensor]]): The output. If it is a tensor, it should be correctly-sized. If it is a list, it\\n            should be empty or contain correctly-sized tensors.\\n        tensor (Tensor): The input tensor on each rank. The result will overwrite this tenor after communication. Support\\n            float16, float32, float64, int32, int64, int8, uint8 or bool as the input data type.\\n        group (Group, optional): Communicate in which group. If none is given, use the global group as default.\\n        sync_op (bool, optional): Indicate whether the communication is sync or not. If none is given, use true as default.\\n        use_calc_stream (bool, optional): Indicate whether the communication is done on calculation stream. If none is given, use false as default. This\\n            option is designed for high performance demand, be careful to turn it on except you are clearly know its meaning.\\n\\n    Returns:\\n        Return a task object.\\n\\n    Warning:\\n        This API only supports the dygraph mode now.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env: DISTRIBUTED)\\n            >>> import paddle\\n            >>> import paddle.distributed as dist\\n\\n            >>> dist.init_parallel_env()\\n            >>> local_rank = dist.get_rank()\\n            >>> tensor_list = []\\n            >>> if local_rank == 0:\\n            ...     data = paddle.to_tensor([[4, 5, 6], [4, 5, 6]])\\n            >>> else:\\n            ...     data = paddle.to_tensor([[1, 2, 3], [1, 2, 3]])\\n            >>> task = dist.stream.all_gather(tensor_list, data, sync_op=False)\\n            >>> task.wait()\\n            >>> print(tensor_list)\\n            [[[4, 5, 6], [4, 5, 6]], [[1, 2, 3], [1, 2, 3]]] (2 GPUs)\\n    '\n    if group is not None and (not group.is_member()):\n        raise RuntimeError('The group should not be None and all ranks which invoke this operation should be the member of this group.')\n    if not sync_op and use_calc_stream:\n        raise RuntimeError('use_calc_stream can only be true in sync op behavior.')\n    if framework.in_dynamic_mode():\n        if paddle.is_tensor(tensor_or_tensor_list):\n            return _all_gather_into_tensor_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n        else:\n            return _all_gather_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n    else:\n        assert group is None, 'Group can not be used in static graph mode for now.'\n        if paddle.is_tensor(tensor_or_tensor_list):\n            raise RuntimeError('Only support passing a tensor list to `all_gather` in static graph mode now.')\n        else:\n            return _all_gather_in_static_mode(tensor_or_tensor_list, tensor, group, sync_op)",
            "def all_gather(tensor_or_tensor_list, tensor, group=None, sync_op=True, use_calc_stream=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n    Gather tensors across devices to a correctly-sized tensor or a tensor list.\\n\\n    Args:\\n        tensor_or_tensor_list (Union[Tensor, List[Tensor]]): The output. If it is a tensor, it should be correctly-sized. If it is a list, it\\n            should be empty or contain correctly-sized tensors.\\n        tensor (Tensor): The input tensor on each rank. The result will overwrite this tenor after communication. Support\\n            float16, float32, float64, int32, int64, int8, uint8 or bool as the input data type.\\n        group (Group, optional): Communicate in which group. If none is given, use the global group as default.\\n        sync_op (bool, optional): Indicate whether the communication is sync or not. If none is given, use true as default.\\n        use_calc_stream (bool, optional): Indicate whether the communication is done on calculation stream. If none is given, use false as default. This\\n            option is designed for high performance demand, be careful to turn it on except you are clearly know its meaning.\\n\\n    Returns:\\n        Return a task object.\\n\\n    Warning:\\n        This API only supports the dygraph mode now.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env: DISTRIBUTED)\\n            >>> import paddle\\n            >>> import paddle.distributed as dist\\n\\n            >>> dist.init_parallel_env()\\n            >>> local_rank = dist.get_rank()\\n            >>> tensor_list = []\\n            >>> if local_rank == 0:\\n            ...     data = paddle.to_tensor([[4, 5, 6], [4, 5, 6]])\\n            >>> else:\\n            ...     data = paddle.to_tensor([[1, 2, 3], [1, 2, 3]])\\n            >>> task = dist.stream.all_gather(tensor_list, data, sync_op=False)\\n            >>> task.wait()\\n            >>> print(tensor_list)\\n            [[[4, 5, 6], [4, 5, 6]], [[1, 2, 3], [1, 2, 3]]] (2 GPUs)\\n    '\n    if group is not None and (not group.is_member()):\n        raise RuntimeError('The group should not be None and all ranks which invoke this operation should be the member of this group.')\n    if not sync_op and use_calc_stream:\n        raise RuntimeError('use_calc_stream can only be true in sync op behavior.')\n    if framework.in_dynamic_mode():\n        if paddle.is_tensor(tensor_or_tensor_list):\n            return _all_gather_into_tensor_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n        else:\n            return _all_gather_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n    else:\n        assert group is None, 'Group can not be used in static graph mode for now.'\n        if paddle.is_tensor(tensor_or_tensor_list):\n            raise RuntimeError('Only support passing a tensor list to `all_gather` in static graph mode now.')\n        else:\n            return _all_gather_in_static_mode(tensor_or_tensor_list, tensor, group, sync_op)",
            "def all_gather(tensor_or_tensor_list, tensor, group=None, sync_op=True, use_calc_stream=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n    Gather tensors across devices to a correctly-sized tensor or a tensor list.\\n\\n    Args:\\n        tensor_or_tensor_list (Union[Tensor, List[Tensor]]): The output. If it is a tensor, it should be correctly-sized. If it is a list, it\\n            should be empty or contain correctly-sized tensors.\\n        tensor (Tensor): The input tensor on each rank. The result will overwrite this tenor after communication. Support\\n            float16, float32, float64, int32, int64, int8, uint8 or bool as the input data type.\\n        group (Group, optional): Communicate in which group. If none is given, use the global group as default.\\n        sync_op (bool, optional): Indicate whether the communication is sync or not. If none is given, use true as default.\\n        use_calc_stream (bool, optional): Indicate whether the communication is done on calculation stream. If none is given, use false as default. This\\n            option is designed for high performance demand, be careful to turn it on except you are clearly know its meaning.\\n\\n    Returns:\\n        Return a task object.\\n\\n    Warning:\\n        This API only supports the dygraph mode now.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env: DISTRIBUTED)\\n            >>> import paddle\\n            >>> import paddle.distributed as dist\\n\\n            >>> dist.init_parallel_env()\\n            >>> local_rank = dist.get_rank()\\n            >>> tensor_list = []\\n            >>> if local_rank == 0:\\n            ...     data = paddle.to_tensor([[4, 5, 6], [4, 5, 6]])\\n            >>> else:\\n            ...     data = paddle.to_tensor([[1, 2, 3], [1, 2, 3]])\\n            >>> task = dist.stream.all_gather(tensor_list, data, sync_op=False)\\n            >>> task.wait()\\n            >>> print(tensor_list)\\n            [[[4, 5, 6], [4, 5, 6]], [[1, 2, 3], [1, 2, 3]]] (2 GPUs)\\n    '\n    if group is not None and (not group.is_member()):\n        raise RuntimeError('The group should not be None and all ranks which invoke this operation should be the member of this group.')\n    if not sync_op and use_calc_stream:\n        raise RuntimeError('use_calc_stream can only be true in sync op behavior.')\n    if framework.in_dynamic_mode():\n        if paddle.is_tensor(tensor_or_tensor_list):\n            return _all_gather_into_tensor_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n        else:\n            return _all_gather_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n    else:\n        assert group is None, 'Group can not be used in static graph mode for now.'\n        if paddle.is_tensor(tensor_or_tensor_list):\n            raise RuntimeError('Only support passing a tensor list to `all_gather` in static graph mode now.')\n        else:\n            return _all_gather_in_static_mode(tensor_or_tensor_list, tensor, group, sync_op)",
            "def all_gather(tensor_or_tensor_list, tensor, group=None, sync_op=True, use_calc_stream=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n    Gather tensors across devices to a correctly-sized tensor or a tensor list.\\n\\n    Args:\\n        tensor_or_tensor_list (Union[Tensor, List[Tensor]]): The output. If it is a tensor, it should be correctly-sized. If it is a list, it\\n            should be empty or contain correctly-sized tensors.\\n        tensor (Tensor): The input tensor on each rank. The result will overwrite this tenor after communication. Support\\n            float16, float32, float64, int32, int64, int8, uint8 or bool as the input data type.\\n        group (Group, optional): Communicate in which group. If none is given, use the global group as default.\\n        sync_op (bool, optional): Indicate whether the communication is sync or not. If none is given, use true as default.\\n        use_calc_stream (bool, optional): Indicate whether the communication is done on calculation stream. If none is given, use false as default. This\\n            option is designed for high performance demand, be careful to turn it on except you are clearly know its meaning.\\n\\n    Returns:\\n        Return a task object.\\n\\n    Warning:\\n        This API only supports the dygraph mode now.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env: DISTRIBUTED)\\n            >>> import paddle\\n            >>> import paddle.distributed as dist\\n\\n            >>> dist.init_parallel_env()\\n            >>> local_rank = dist.get_rank()\\n            >>> tensor_list = []\\n            >>> if local_rank == 0:\\n            ...     data = paddle.to_tensor([[4, 5, 6], [4, 5, 6]])\\n            >>> else:\\n            ...     data = paddle.to_tensor([[1, 2, 3], [1, 2, 3]])\\n            >>> task = dist.stream.all_gather(tensor_list, data, sync_op=False)\\n            >>> task.wait()\\n            >>> print(tensor_list)\\n            [[[4, 5, 6], [4, 5, 6]], [[1, 2, 3], [1, 2, 3]]] (2 GPUs)\\n    '\n    if group is not None and (not group.is_member()):\n        raise RuntimeError('The group should not be None and all ranks which invoke this operation should be the member of this group.')\n    if not sync_op and use_calc_stream:\n        raise RuntimeError('use_calc_stream can only be true in sync op behavior.')\n    if framework.in_dynamic_mode():\n        if paddle.is_tensor(tensor_or_tensor_list):\n            return _all_gather_into_tensor_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n        else:\n            return _all_gather_in_dygraph(tensor_or_tensor_list, tensor, group, sync_op, use_calc_stream)\n    else:\n        assert group is None, 'Group can not be used in static graph mode for now.'\n        if paddle.is_tensor(tensor_or_tensor_list):\n            raise RuntimeError('Only support passing a tensor list to `all_gather` in static graph mode now.')\n        else:\n            return _all_gather_in_static_mode(tensor_or_tensor_list, tensor, group, sync_op)"
        ]
    }
]