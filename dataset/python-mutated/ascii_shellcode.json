[
    {
        "func_name": "__init__",
        "original": "def __init__(self, slop=20, max_subs=4):\n    \"\"\" Init\n\n        Args:\n            slop (int, optional): The amount esp will be increased by in the\n                allocation phase (In addition to the length of the packed\n                shellcode) as well as defines the size of the NOP sled (you can\n                increase/ decrease the size of the NOP sled by adding/removing\n                b'P'-s to/ from the end of the packed shellcode).\n                Defaults to 20.\n            max_subs (int, optional): The maximum amount of subtractions\n                allowed to be taken. This may be increased if you have a\n                relatively  restrictive ``avoid`` set. The more subtractions\n                there are, the bigger the packed shellcode will be.\n                Defaults to 4.\n        \"\"\"\n    if six.PY2:\n        super(AsciiShellcodeEncoder, self).__init__()\n    elif six.PY3:\n        super().__init__()\n    self.slop = slop\n    self.max_subs = max_subs",
        "mutated": [
            "def __init__(self, slop=20, max_subs=4):\n    if False:\n        i = 10\n    \" Init\\n\\n        Args:\\n            slop (int, optional): The amount esp will be increased by in the\\n                allocation phase (In addition to the length of the packed\\n                shellcode) as well as defines the size of the NOP sled (you can\\n                increase/ decrease the size of the NOP sled by adding/removing\\n                b'P'-s to/ from the end of the packed shellcode).\\n                Defaults to 20.\\n            max_subs (int, optional): The maximum amount of subtractions\\n                allowed to be taken. This may be increased if you have a\\n                relatively  restrictive ``avoid`` set. The more subtractions\\n                there are, the bigger the packed shellcode will be.\\n                Defaults to 4.\\n        \"\n    if six.PY2:\n        super(AsciiShellcodeEncoder, self).__init__()\n    elif six.PY3:\n        super().__init__()\n    self.slop = slop\n    self.max_subs = max_subs",
            "def __init__(self, slop=20, max_subs=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \" Init\\n\\n        Args:\\n            slop (int, optional): The amount esp will be increased by in the\\n                allocation phase (In addition to the length of the packed\\n                shellcode) as well as defines the size of the NOP sled (you can\\n                increase/ decrease the size of the NOP sled by adding/removing\\n                b'P'-s to/ from the end of the packed shellcode).\\n                Defaults to 20.\\n            max_subs (int, optional): The maximum amount of subtractions\\n                allowed to be taken. This may be increased if you have a\\n                relatively  restrictive ``avoid`` set. The more subtractions\\n                there are, the bigger the packed shellcode will be.\\n                Defaults to 4.\\n        \"\n    if six.PY2:\n        super(AsciiShellcodeEncoder, self).__init__()\n    elif six.PY3:\n        super().__init__()\n    self.slop = slop\n    self.max_subs = max_subs",
            "def __init__(self, slop=20, max_subs=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \" Init\\n\\n        Args:\\n            slop (int, optional): The amount esp will be increased by in the\\n                allocation phase (In addition to the length of the packed\\n                shellcode) as well as defines the size of the NOP sled (you can\\n                increase/ decrease the size of the NOP sled by adding/removing\\n                b'P'-s to/ from the end of the packed shellcode).\\n                Defaults to 20.\\n            max_subs (int, optional): The maximum amount of subtractions\\n                allowed to be taken. This may be increased if you have a\\n                relatively  restrictive ``avoid`` set. The more subtractions\\n                there are, the bigger the packed shellcode will be.\\n                Defaults to 4.\\n        \"\n    if six.PY2:\n        super(AsciiShellcodeEncoder, self).__init__()\n    elif six.PY3:\n        super().__init__()\n    self.slop = slop\n    self.max_subs = max_subs",
            "def __init__(self, slop=20, max_subs=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \" Init\\n\\n        Args:\\n            slop (int, optional): The amount esp will be increased by in the\\n                allocation phase (In addition to the length of the packed\\n                shellcode) as well as defines the size of the NOP sled (you can\\n                increase/ decrease the size of the NOP sled by adding/removing\\n                b'P'-s to/ from the end of the packed shellcode).\\n                Defaults to 20.\\n            max_subs (int, optional): The maximum amount of subtractions\\n                allowed to be taken. This may be increased if you have a\\n                relatively  restrictive ``avoid`` set. The more subtractions\\n                there are, the bigger the packed shellcode will be.\\n                Defaults to 4.\\n        \"\n    if six.PY2:\n        super(AsciiShellcodeEncoder, self).__init__()\n    elif six.PY3:\n        super().__init__()\n    self.slop = slop\n    self.max_subs = max_subs",
            "def __init__(self, slop=20, max_subs=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \" Init\\n\\n        Args:\\n            slop (int, optional): The amount esp will be increased by in the\\n                allocation phase (In addition to the length of the packed\\n                shellcode) as well as defines the size of the NOP sled (you can\\n                increase/ decrease the size of the NOP sled by adding/removing\\n                b'P'-s to/ from the end of the packed shellcode).\\n                Defaults to 20.\\n            max_subs (int, optional): The maximum amount of subtractions\\n                allowed to be taken. This may be increased if you have a\\n                relatively  restrictive ``avoid`` set. The more subtractions\\n                there are, the bigger the packed shellcode will be.\\n                Defaults to 4.\\n        \"\n    if six.PY2:\n        super(AsciiShellcodeEncoder, self).__init__()\n    elif six.PY3:\n        super().__init__()\n    self.slop = slop\n    self.max_subs = max_subs"
        ]
    },
    {
        "func_name": "__call__",
        "original": "@LocalContext\ndef __call__(self, raw_bytes, avoid=None, pcreg=None):\n    \"\"\" Pack shellcode into only ascii characters that unpacks itself and\n        executes (on the stack)\n\n        Args:\n            raw_bytes (bytes): The shellcode to be packed\n            avoid (set, optional): Characters to avoid. Defaults to allow\n                printable ascii (0x21-0x7e).\n            pcreg (NoneType, optional): Ignored\n\n        Raises:\n            RuntimeError: A required character is in ``avoid`` (required\n                characters are characters which assemble into assembly\n                instructions and are used to unpack the shellcode onto the\n                stack, more details in the paper linked above ``\\\\ - % T X P``).\n            RuntimeError: Not supported architecture\n            ArithmeticError: The allowed character set does not contain\n                two characters that when they are bitwise-anded with eachother\n                their result is 0\n            ArithmeticError: Could not find a correct subtraction sequence\n                to get to the the desired target value with the given ``avoid``\n                parameter\n\n        Returns:\n            bytes: The packed shellcode\n\n        Examples:\n\n            >>> context.update(arch='i386', os='linux')\n            >>> sc = b\"\\\\x83\\\\xc4\\\\x181\\\\xc01\\\\xdb\\\\xb0\\\\x06\\\\xcd\\\\x80Sh/ttyh/dev\\\\x89\\\\xe31\\\\xc9f\\\\xb9\\\\x12'\\\\xb0\\\\x05\\\\xcd\\\\x80j\\\\x17X1\\\\xdb\\\\xcd\\\\x80j.XS\\\\xcd\\\\x801\\\\xc0Ph//shh/bin\\\\x89\\\\xe3PS\\\\x89\\\\xe1\\\\x99\\\\xb0\\\\x0b\\\\xcd\\\\x80\"\n            >>> encoders.i386.ascii_shellcode.encode(sc)\n            b'TX-!!!!-\"_``-~~~~P\\\\\\\\%!!!!%@@@@-!6!!-V~!!-~~<-P-!mha-a~~~P-!!L`-a^~~-~~~~P-!!if-9`~~P-!!!!-aOaf-~~~~P-!&!<-!~`~--~~~P-!!!!-!!H^-+A~~P-U!![-~A1~P-,<V!-~~~!-~~~GP-!2!8-j~O~P-!]!!-!~!r-y~w~P-c!!!-~<(+P-N!_W-~1~~P-!!]!-Mn~!-~~~<P-!<!!-r~!P-~~x~P-fe!$-~~S~-~~~~P-!!\\\\'$-%z~~P-A!!!-~!#!-~*~=P-!7!!-T~!!-~~E^PPPPPPPPPPPPPPPPPPPPP'\n            >>> avoid = {'\\\\x00', '\\\\x83', '\\\\x04', '\\\\x87', '\\\\x08', '\\\\x8b', '\\\\x0c', '\\\\x8f', '\\\\x10', '\\\\x93', '\\\\x14', '\\\\x97', '\\\\x18', '\\\\x9b', '\\\\x1c', '\\\\x9f', ' ', '\\\\xa3', '\\\\xa7', '\\\\xab', '\\\\xaf', '\\\\xb3', '\\\\xb7', '\\\\xbb', '\\\\xbf', '\\\\xc3', '\\\\xc7', '\\\\xcb', '\\\\xcf', '\\\\xd3', '\\\\xd7', '\\\\xdb', '\\\\xdf', '\\\\xe3', '\\\\xe7', '\\\\xeb', '\\\\xef', '\\\\xf3', '\\\\xf7', '\\\\xfb', '\\\\xff', '\\\\x80', '\\\\x03', '\\\\x84', '\\\\x07', '\\\\x88', '\\\\x0b', '\\\\x8c', '\\\\x0f', '\\\\x90', '\\\\x13', '\\\\x94', '\\\\x17', '\\\\x98', '\\\\x1b', '\\\\x9c', '\\\\x1f', '\\\\xa0', '\\\\xa4', '\\\\xa8', '\\\\xac', '\\\\xb0', '\\\\xb4', '\\\\xb8', '\\\\xbc', '\\\\xc0', '\\\\xc4', '\\\\xc8', '\\\\xcc', '\\\\xd0', '\\\\xd4', '\\\\xd8', '\\\\xdc', '\\\\xe0', '\\\\xe4', '\\\\xe8', '\\\\xec', '\\\\xf0', '\\\\xf4', '\\\\xf8', '\\\\xfc', '\\\\x7f', '\\\\x81', '\\\\x02', '\\\\x85', '\\\\x06', '\\\\x89', '\\\\n', '\\\\x8d', '\\\\x0e', '\\\\x91', '\\\\x12', '\\\\x95', '\\\\x16', '\\\\x99', '\\\\x1a', '\\\\x9d', '\\\\x1e', '\\\\xa1', '\\\\xa5', '\\\\xa9', '\\\\xad', '\\\\xb1', '\\\\xb5', '\\\\xb9', '\\\\xbd', '\\\\xc1', '\\\\xc5', '\\\\xc9', '\\\\xcd', '\\\\xd1', '\\\\xd5', '\\\\xd9', '\\\\xdd', '\\\\xe1', '\\\\xe5', '\\\\xe9', '\\\\xed', '\\\\xf1', '\\\\xf5', '\\\\xf9', '\\\\xfd', '\\\\x01', '\\\\x82', '\\\\x05', '\\\\x86', '\\\\t', '\\\\x8a', '\\\\r', '\\\\x8e', '\\\\x11', '\\\\x92', '\\\\x15', '\\\\x96', '\\\\x19', '\\\\x9a', '\\\\x1d', '\\\\x9e', '\\\\xa2', '\\\\xa6', '\\\\xaa', '\\\\xae', '\\\\xb2', '\\\\xb6', '\\\\xba', '\\\\xbe', '\\\\xc2', '\\\\xc6', '\\\\xca', '\\\\xce', '\\\\xd2', '\\\\xd6', '\\\\xda', '\\\\xde', '\\\\xe2', '\\\\xe6', '\\\\xea', '\\\\xee', '\\\\xf2', '\\\\xf6', '\\\\xfa', '\\\\xfe'}\n            >>> sc = shellcraft.echo(\"Hello world\") + shellcraft.exit()\n            >>> ascii = encoders.i386.ascii_shellcode.encode(asm(sc), avoid)\n            >>> ascii += asm('jmp esp') # just for testing, the unpacker should also run on the stack\n            >>> ELF.from_bytes(ascii).process().recvall()\n            b'Hello world'\n        \"\"\"\n    if not avoid:\n        vocab = bytearray(b'!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n    else:\n        required_chars = set('\\\\-%TXP')\n        allowed = set(all_chars)\n        if avoid.intersection(required_chars):\n            raise RuntimeError('These characters ({}) are required because they assemble\\n                    into instructions used to unpack the shellcode'.format(str(required_chars, 'ascii')))\n        allowed.difference_update(avoid)\n        vocab = bytearray(map(ord, allowed))\n    if context.arch != 'i386' or context.bits != 32:\n        raise RuntimeError('Only 32-bit i386 is currently supported')\n    int_size = context.bytes\n    shellcode = bytearray(b'\\x90' * int_size + raw_bytes)\n    subtractions = self._get_subtractions(shellcode, vocab)\n    allocator = self._get_allocator(len(subtractions) + self.slop, vocab)\n    nop_sled = b'P' * self.slop\n    return bytes(allocator + subtractions + nop_sled)",
        "mutated": [
            "@LocalContext\ndef __call__(self, raw_bytes, avoid=None, pcreg=None):\n    if False:\n        i = 10\n    ' Pack shellcode into only ascii characters that unpacks itself and\\n        executes (on the stack)\\n\\n        Args:\\n            raw_bytes (bytes): The shellcode to be packed\\n            avoid (set, optional): Characters to avoid. Defaults to allow\\n                printable ascii (0x21-0x7e).\\n            pcreg (NoneType, optional): Ignored\\n\\n        Raises:\\n            RuntimeError: A required character is in ``avoid`` (required\\n                characters are characters which assemble into assembly\\n                instructions and are used to unpack the shellcode onto the\\n                stack, more details in the paper linked above ``\\\\ - % T X P``).\\n            RuntimeError: Not supported architecture\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-anded with eachother\\n                their result is 0\\n            ArithmeticError: Could not find a correct subtraction sequence\\n                to get to the the desired target value with the given ``avoid``\\n                parameter\\n\\n        Returns:\\n            bytes: The packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = b\"\\\\x83\\\\xc4\\\\x181\\\\xc01\\\\xdb\\\\xb0\\\\x06\\\\xcd\\\\x80Sh/ttyh/dev\\\\x89\\\\xe31\\\\xc9f\\\\xb9\\\\x12\\'\\\\xb0\\\\x05\\\\xcd\\\\x80j\\\\x17X1\\\\xdb\\\\xcd\\\\x80j.XS\\\\xcd\\\\x801\\\\xc0Ph//shh/bin\\\\x89\\\\xe3PS\\\\x89\\\\xe1\\\\x99\\\\xb0\\\\x0b\\\\xcd\\\\x80\"\\n            >>> encoders.i386.ascii_shellcode.encode(sc)\\n            b\\'TX-!!!!-\"_``-~~~~P\\\\\\\\%!!!!%@@@@-!6!!-V~!!-~~<-P-!mha-a~~~P-!!L`-a^~~-~~~~P-!!if-9`~~P-!!!!-aOaf-~~~~P-!&!<-!~`~--~~~P-!!!!-!!H^-+A~~P-U!![-~A1~P-,<V!-~~~!-~~~GP-!2!8-j~O~P-!]!!-!~!r-y~w~P-c!!!-~<(+P-N!_W-~1~~P-!!]!-Mn~!-~~~<P-!<!!-r~!P-~~x~P-fe!$-~~S~-~~~~P-!!\\\\\\'$-%z~~P-A!!!-~!#!-~*~=P-!7!!-T~!!-~~E^PPPPPPPPPPPPPPPPPPPPP\\'\\n            >>> avoid = {\\'\\\\x00\\', \\'\\\\x83\\', \\'\\\\x04\\', \\'\\\\x87\\', \\'\\\\x08\\', \\'\\\\x8b\\', \\'\\\\x0c\\', \\'\\\\x8f\\', \\'\\\\x10\\', \\'\\\\x93\\', \\'\\\\x14\\', \\'\\\\x97\\', \\'\\\\x18\\', \\'\\\\x9b\\', \\'\\\\x1c\\', \\'\\\\x9f\\', \\' \\', \\'\\\\xa3\\', \\'\\\\xa7\\', \\'\\\\xab\\', \\'\\\\xaf\\', \\'\\\\xb3\\', \\'\\\\xb7\\', \\'\\\\xbb\\', \\'\\\\xbf\\', \\'\\\\xc3\\', \\'\\\\xc7\\', \\'\\\\xcb\\', \\'\\\\xcf\\', \\'\\\\xd3\\', \\'\\\\xd7\\', \\'\\\\xdb\\', \\'\\\\xdf\\', \\'\\\\xe3\\', \\'\\\\xe7\\', \\'\\\\xeb\\', \\'\\\\xef\\', \\'\\\\xf3\\', \\'\\\\xf7\\', \\'\\\\xfb\\', \\'\\\\xff\\', \\'\\\\x80\\', \\'\\\\x03\\', \\'\\\\x84\\', \\'\\\\x07\\', \\'\\\\x88\\', \\'\\\\x0b\\', \\'\\\\x8c\\', \\'\\\\x0f\\', \\'\\\\x90\\', \\'\\\\x13\\', \\'\\\\x94\\', \\'\\\\x17\\', \\'\\\\x98\\', \\'\\\\x1b\\', \\'\\\\x9c\\', \\'\\\\x1f\\', \\'\\\\xa0\\', \\'\\\\xa4\\', \\'\\\\xa8\\', \\'\\\\xac\\', \\'\\\\xb0\\', \\'\\\\xb4\\', \\'\\\\xb8\\', \\'\\\\xbc\\', \\'\\\\xc0\\', \\'\\\\xc4\\', \\'\\\\xc8\\', \\'\\\\xcc\\', \\'\\\\xd0\\', \\'\\\\xd4\\', \\'\\\\xd8\\', \\'\\\\xdc\\', \\'\\\\xe0\\', \\'\\\\xe4\\', \\'\\\\xe8\\', \\'\\\\xec\\', \\'\\\\xf0\\', \\'\\\\xf4\\', \\'\\\\xf8\\', \\'\\\\xfc\\', \\'\\\\x7f\\', \\'\\\\x81\\', \\'\\\\x02\\', \\'\\\\x85\\', \\'\\\\x06\\', \\'\\\\x89\\', \\'\\\\n\\', \\'\\\\x8d\\', \\'\\\\x0e\\', \\'\\\\x91\\', \\'\\\\x12\\', \\'\\\\x95\\', \\'\\\\x16\\', \\'\\\\x99\\', \\'\\\\x1a\\', \\'\\\\x9d\\', \\'\\\\x1e\\', \\'\\\\xa1\\', \\'\\\\xa5\\', \\'\\\\xa9\\', \\'\\\\xad\\', \\'\\\\xb1\\', \\'\\\\xb5\\', \\'\\\\xb9\\', \\'\\\\xbd\\', \\'\\\\xc1\\', \\'\\\\xc5\\', \\'\\\\xc9\\', \\'\\\\xcd\\', \\'\\\\xd1\\', \\'\\\\xd5\\', \\'\\\\xd9\\', \\'\\\\xdd\\', \\'\\\\xe1\\', \\'\\\\xe5\\', \\'\\\\xe9\\', \\'\\\\xed\\', \\'\\\\xf1\\', \\'\\\\xf5\\', \\'\\\\xf9\\', \\'\\\\xfd\\', \\'\\\\x01\\', \\'\\\\x82\\', \\'\\\\x05\\', \\'\\\\x86\\', \\'\\\\t\\', \\'\\\\x8a\\', \\'\\\\r\\', \\'\\\\x8e\\', \\'\\\\x11\\', \\'\\\\x92\\', \\'\\\\x15\\', \\'\\\\x96\\', \\'\\\\x19\\', \\'\\\\x9a\\', \\'\\\\x1d\\', \\'\\\\x9e\\', \\'\\\\xa2\\', \\'\\\\xa6\\', \\'\\\\xaa\\', \\'\\\\xae\\', \\'\\\\xb2\\', \\'\\\\xb6\\', \\'\\\\xba\\', \\'\\\\xbe\\', \\'\\\\xc2\\', \\'\\\\xc6\\', \\'\\\\xca\\', \\'\\\\xce\\', \\'\\\\xd2\\', \\'\\\\xd6\\', \\'\\\\xda\\', \\'\\\\xde\\', \\'\\\\xe2\\', \\'\\\\xe6\\', \\'\\\\xea\\', \\'\\\\xee\\', \\'\\\\xf2\\', \\'\\\\xf6\\', \\'\\\\xfa\\', \\'\\\\xfe\\'}\\n            >>> sc = shellcraft.echo(\"Hello world\") + shellcraft.exit()\\n            >>> ascii = encoders.i386.ascii_shellcode.encode(asm(sc), avoid)\\n            >>> ascii += asm(\\'jmp esp\\') # just for testing, the unpacker should also run on the stack\\n            >>> ELF.from_bytes(ascii).process().recvall()\\n            b\\'Hello world\\'\\n        '\n    if not avoid:\n        vocab = bytearray(b'!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n    else:\n        required_chars = set('\\\\-%TXP')\n        allowed = set(all_chars)\n        if avoid.intersection(required_chars):\n            raise RuntimeError('These characters ({}) are required because they assemble\\n                    into instructions used to unpack the shellcode'.format(str(required_chars, 'ascii')))\n        allowed.difference_update(avoid)\n        vocab = bytearray(map(ord, allowed))\n    if context.arch != 'i386' or context.bits != 32:\n        raise RuntimeError('Only 32-bit i386 is currently supported')\n    int_size = context.bytes\n    shellcode = bytearray(b'\\x90' * int_size + raw_bytes)\n    subtractions = self._get_subtractions(shellcode, vocab)\n    allocator = self._get_allocator(len(subtractions) + self.slop, vocab)\n    nop_sled = b'P' * self.slop\n    return bytes(allocator + subtractions + nop_sled)",
            "@LocalContext\ndef __call__(self, raw_bytes, avoid=None, pcreg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Pack shellcode into only ascii characters that unpacks itself and\\n        executes (on the stack)\\n\\n        Args:\\n            raw_bytes (bytes): The shellcode to be packed\\n            avoid (set, optional): Characters to avoid. Defaults to allow\\n                printable ascii (0x21-0x7e).\\n            pcreg (NoneType, optional): Ignored\\n\\n        Raises:\\n            RuntimeError: A required character is in ``avoid`` (required\\n                characters are characters which assemble into assembly\\n                instructions and are used to unpack the shellcode onto the\\n                stack, more details in the paper linked above ``\\\\ - % T X P``).\\n            RuntimeError: Not supported architecture\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-anded with eachother\\n                their result is 0\\n            ArithmeticError: Could not find a correct subtraction sequence\\n                to get to the the desired target value with the given ``avoid``\\n                parameter\\n\\n        Returns:\\n            bytes: The packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = b\"\\\\x83\\\\xc4\\\\x181\\\\xc01\\\\xdb\\\\xb0\\\\x06\\\\xcd\\\\x80Sh/ttyh/dev\\\\x89\\\\xe31\\\\xc9f\\\\xb9\\\\x12\\'\\\\xb0\\\\x05\\\\xcd\\\\x80j\\\\x17X1\\\\xdb\\\\xcd\\\\x80j.XS\\\\xcd\\\\x801\\\\xc0Ph//shh/bin\\\\x89\\\\xe3PS\\\\x89\\\\xe1\\\\x99\\\\xb0\\\\x0b\\\\xcd\\\\x80\"\\n            >>> encoders.i386.ascii_shellcode.encode(sc)\\n            b\\'TX-!!!!-\"_``-~~~~P\\\\\\\\%!!!!%@@@@-!6!!-V~!!-~~<-P-!mha-a~~~P-!!L`-a^~~-~~~~P-!!if-9`~~P-!!!!-aOaf-~~~~P-!&!<-!~`~--~~~P-!!!!-!!H^-+A~~P-U!![-~A1~P-,<V!-~~~!-~~~GP-!2!8-j~O~P-!]!!-!~!r-y~w~P-c!!!-~<(+P-N!_W-~1~~P-!!]!-Mn~!-~~~<P-!<!!-r~!P-~~x~P-fe!$-~~S~-~~~~P-!!\\\\\\'$-%z~~P-A!!!-~!#!-~*~=P-!7!!-T~!!-~~E^PPPPPPPPPPPPPPPPPPPPP\\'\\n            >>> avoid = {\\'\\\\x00\\', \\'\\\\x83\\', \\'\\\\x04\\', \\'\\\\x87\\', \\'\\\\x08\\', \\'\\\\x8b\\', \\'\\\\x0c\\', \\'\\\\x8f\\', \\'\\\\x10\\', \\'\\\\x93\\', \\'\\\\x14\\', \\'\\\\x97\\', \\'\\\\x18\\', \\'\\\\x9b\\', \\'\\\\x1c\\', \\'\\\\x9f\\', \\' \\', \\'\\\\xa3\\', \\'\\\\xa7\\', \\'\\\\xab\\', \\'\\\\xaf\\', \\'\\\\xb3\\', \\'\\\\xb7\\', \\'\\\\xbb\\', \\'\\\\xbf\\', \\'\\\\xc3\\', \\'\\\\xc7\\', \\'\\\\xcb\\', \\'\\\\xcf\\', \\'\\\\xd3\\', \\'\\\\xd7\\', \\'\\\\xdb\\', \\'\\\\xdf\\', \\'\\\\xe3\\', \\'\\\\xe7\\', \\'\\\\xeb\\', \\'\\\\xef\\', \\'\\\\xf3\\', \\'\\\\xf7\\', \\'\\\\xfb\\', \\'\\\\xff\\', \\'\\\\x80\\', \\'\\\\x03\\', \\'\\\\x84\\', \\'\\\\x07\\', \\'\\\\x88\\', \\'\\\\x0b\\', \\'\\\\x8c\\', \\'\\\\x0f\\', \\'\\\\x90\\', \\'\\\\x13\\', \\'\\\\x94\\', \\'\\\\x17\\', \\'\\\\x98\\', \\'\\\\x1b\\', \\'\\\\x9c\\', \\'\\\\x1f\\', \\'\\\\xa0\\', \\'\\\\xa4\\', \\'\\\\xa8\\', \\'\\\\xac\\', \\'\\\\xb0\\', \\'\\\\xb4\\', \\'\\\\xb8\\', \\'\\\\xbc\\', \\'\\\\xc0\\', \\'\\\\xc4\\', \\'\\\\xc8\\', \\'\\\\xcc\\', \\'\\\\xd0\\', \\'\\\\xd4\\', \\'\\\\xd8\\', \\'\\\\xdc\\', \\'\\\\xe0\\', \\'\\\\xe4\\', \\'\\\\xe8\\', \\'\\\\xec\\', \\'\\\\xf0\\', \\'\\\\xf4\\', \\'\\\\xf8\\', \\'\\\\xfc\\', \\'\\\\x7f\\', \\'\\\\x81\\', \\'\\\\x02\\', \\'\\\\x85\\', \\'\\\\x06\\', \\'\\\\x89\\', \\'\\\\n\\', \\'\\\\x8d\\', \\'\\\\x0e\\', \\'\\\\x91\\', \\'\\\\x12\\', \\'\\\\x95\\', \\'\\\\x16\\', \\'\\\\x99\\', \\'\\\\x1a\\', \\'\\\\x9d\\', \\'\\\\x1e\\', \\'\\\\xa1\\', \\'\\\\xa5\\', \\'\\\\xa9\\', \\'\\\\xad\\', \\'\\\\xb1\\', \\'\\\\xb5\\', \\'\\\\xb9\\', \\'\\\\xbd\\', \\'\\\\xc1\\', \\'\\\\xc5\\', \\'\\\\xc9\\', \\'\\\\xcd\\', \\'\\\\xd1\\', \\'\\\\xd5\\', \\'\\\\xd9\\', \\'\\\\xdd\\', \\'\\\\xe1\\', \\'\\\\xe5\\', \\'\\\\xe9\\', \\'\\\\xed\\', \\'\\\\xf1\\', \\'\\\\xf5\\', \\'\\\\xf9\\', \\'\\\\xfd\\', \\'\\\\x01\\', \\'\\\\x82\\', \\'\\\\x05\\', \\'\\\\x86\\', \\'\\\\t\\', \\'\\\\x8a\\', \\'\\\\r\\', \\'\\\\x8e\\', \\'\\\\x11\\', \\'\\\\x92\\', \\'\\\\x15\\', \\'\\\\x96\\', \\'\\\\x19\\', \\'\\\\x9a\\', \\'\\\\x1d\\', \\'\\\\x9e\\', \\'\\\\xa2\\', \\'\\\\xa6\\', \\'\\\\xaa\\', \\'\\\\xae\\', \\'\\\\xb2\\', \\'\\\\xb6\\', \\'\\\\xba\\', \\'\\\\xbe\\', \\'\\\\xc2\\', \\'\\\\xc6\\', \\'\\\\xca\\', \\'\\\\xce\\', \\'\\\\xd2\\', \\'\\\\xd6\\', \\'\\\\xda\\', \\'\\\\xde\\', \\'\\\\xe2\\', \\'\\\\xe6\\', \\'\\\\xea\\', \\'\\\\xee\\', \\'\\\\xf2\\', \\'\\\\xf6\\', \\'\\\\xfa\\', \\'\\\\xfe\\'}\\n            >>> sc = shellcraft.echo(\"Hello world\") + shellcraft.exit()\\n            >>> ascii = encoders.i386.ascii_shellcode.encode(asm(sc), avoid)\\n            >>> ascii += asm(\\'jmp esp\\') # just for testing, the unpacker should also run on the stack\\n            >>> ELF.from_bytes(ascii).process().recvall()\\n            b\\'Hello world\\'\\n        '\n    if not avoid:\n        vocab = bytearray(b'!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n    else:\n        required_chars = set('\\\\-%TXP')\n        allowed = set(all_chars)\n        if avoid.intersection(required_chars):\n            raise RuntimeError('These characters ({}) are required because they assemble\\n                    into instructions used to unpack the shellcode'.format(str(required_chars, 'ascii')))\n        allowed.difference_update(avoid)\n        vocab = bytearray(map(ord, allowed))\n    if context.arch != 'i386' or context.bits != 32:\n        raise RuntimeError('Only 32-bit i386 is currently supported')\n    int_size = context.bytes\n    shellcode = bytearray(b'\\x90' * int_size + raw_bytes)\n    subtractions = self._get_subtractions(shellcode, vocab)\n    allocator = self._get_allocator(len(subtractions) + self.slop, vocab)\n    nop_sled = b'P' * self.slop\n    return bytes(allocator + subtractions + nop_sled)",
            "@LocalContext\ndef __call__(self, raw_bytes, avoid=None, pcreg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Pack shellcode into only ascii characters that unpacks itself and\\n        executes (on the stack)\\n\\n        Args:\\n            raw_bytes (bytes): The shellcode to be packed\\n            avoid (set, optional): Characters to avoid. Defaults to allow\\n                printable ascii (0x21-0x7e).\\n            pcreg (NoneType, optional): Ignored\\n\\n        Raises:\\n            RuntimeError: A required character is in ``avoid`` (required\\n                characters are characters which assemble into assembly\\n                instructions and are used to unpack the shellcode onto the\\n                stack, more details in the paper linked above ``\\\\ - % T X P``).\\n            RuntimeError: Not supported architecture\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-anded with eachother\\n                their result is 0\\n            ArithmeticError: Could not find a correct subtraction sequence\\n                to get to the the desired target value with the given ``avoid``\\n                parameter\\n\\n        Returns:\\n            bytes: The packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = b\"\\\\x83\\\\xc4\\\\x181\\\\xc01\\\\xdb\\\\xb0\\\\x06\\\\xcd\\\\x80Sh/ttyh/dev\\\\x89\\\\xe31\\\\xc9f\\\\xb9\\\\x12\\'\\\\xb0\\\\x05\\\\xcd\\\\x80j\\\\x17X1\\\\xdb\\\\xcd\\\\x80j.XS\\\\xcd\\\\x801\\\\xc0Ph//shh/bin\\\\x89\\\\xe3PS\\\\x89\\\\xe1\\\\x99\\\\xb0\\\\x0b\\\\xcd\\\\x80\"\\n            >>> encoders.i386.ascii_shellcode.encode(sc)\\n            b\\'TX-!!!!-\"_``-~~~~P\\\\\\\\%!!!!%@@@@-!6!!-V~!!-~~<-P-!mha-a~~~P-!!L`-a^~~-~~~~P-!!if-9`~~P-!!!!-aOaf-~~~~P-!&!<-!~`~--~~~P-!!!!-!!H^-+A~~P-U!![-~A1~P-,<V!-~~~!-~~~GP-!2!8-j~O~P-!]!!-!~!r-y~w~P-c!!!-~<(+P-N!_W-~1~~P-!!]!-Mn~!-~~~<P-!<!!-r~!P-~~x~P-fe!$-~~S~-~~~~P-!!\\\\\\'$-%z~~P-A!!!-~!#!-~*~=P-!7!!-T~!!-~~E^PPPPPPPPPPPPPPPPPPPPP\\'\\n            >>> avoid = {\\'\\\\x00\\', \\'\\\\x83\\', \\'\\\\x04\\', \\'\\\\x87\\', \\'\\\\x08\\', \\'\\\\x8b\\', \\'\\\\x0c\\', \\'\\\\x8f\\', \\'\\\\x10\\', \\'\\\\x93\\', \\'\\\\x14\\', \\'\\\\x97\\', \\'\\\\x18\\', \\'\\\\x9b\\', \\'\\\\x1c\\', \\'\\\\x9f\\', \\' \\', \\'\\\\xa3\\', \\'\\\\xa7\\', \\'\\\\xab\\', \\'\\\\xaf\\', \\'\\\\xb3\\', \\'\\\\xb7\\', \\'\\\\xbb\\', \\'\\\\xbf\\', \\'\\\\xc3\\', \\'\\\\xc7\\', \\'\\\\xcb\\', \\'\\\\xcf\\', \\'\\\\xd3\\', \\'\\\\xd7\\', \\'\\\\xdb\\', \\'\\\\xdf\\', \\'\\\\xe3\\', \\'\\\\xe7\\', \\'\\\\xeb\\', \\'\\\\xef\\', \\'\\\\xf3\\', \\'\\\\xf7\\', \\'\\\\xfb\\', \\'\\\\xff\\', \\'\\\\x80\\', \\'\\\\x03\\', \\'\\\\x84\\', \\'\\\\x07\\', \\'\\\\x88\\', \\'\\\\x0b\\', \\'\\\\x8c\\', \\'\\\\x0f\\', \\'\\\\x90\\', \\'\\\\x13\\', \\'\\\\x94\\', \\'\\\\x17\\', \\'\\\\x98\\', \\'\\\\x1b\\', \\'\\\\x9c\\', \\'\\\\x1f\\', \\'\\\\xa0\\', \\'\\\\xa4\\', \\'\\\\xa8\\', \\'\\\\xac\\', \\'\\\\xb0\\', \\'\\\\xb4\\', \\'\\\\xb8\\', \\'\\\\xbc\\', \\'\\\\xc0\\', \\'\\\\xc4\\', \\'\\\\xc8\\', \\'\\\\xcc\\', \\'\\\\xd0\\', \\'\\\\xd4\\', \\'\\\\xd8\\', \\'\\\\xdc\\', \\'\\\\xe0\\', \\'\\\\xe4\\', \\'\\\\xe8\\', \\'\\\\xec\\', \\'\\\\xf0\\', \\'\\\\xf4\\', \\'\\\\xf8\\', \\'\\\\xfc\\', \\'\\\\x7f\\', \\'\\\\x81\\', \\'\\\\x02\\', \\'\\\\x85\\', \\'\\\\x06\\', \\'\\\\x89\\', \\'\\\\n\\', \\'\\\\x8d\\', \\'\\\\x0e\\', \\'\\\\x91\\', \\'\\\\x12\\', \\'\\\\x95\\', \\'\\\\x16\\', \\'\\\\x99\\', \\'\\\\x1a\\', \\'\\\\x9d\\', \\'\\\\x1e\\', \\'\\\\xa1\\', \\'\\\\xa5\\', \\'\\\\xa9\\', \\'\\\\xad\\', \\'\\\\xb1\\', \\'\\\\xb5\\', \\'\\\\xb9\\', \\'\\\\xbd\\', \\'\\\\xc1\\', \\'\\\\xc5\\', \\'\\\\xc9\\', \\'\\\\xcd\\', \\'\\\\xd1\\', \\'\\\\xd5\\', \\'\\\\xd9\\', \\'\\\\xdd\\', \\'\\\\xe1\\', \\'\\\\xe5\\', \\'\\\\xe9\\', \\'\\\\xed\\', \\'\\\\xf1\\', \\'\\\\xf5\\', \\'\\\\xf9\\', \\'\\\\xfd\\', \\'\\\\x01\\', \\'\\\\x82\\', \\'\\\\x05\\', \\'\\\\x86\\', \\'\\\\t\\', \\'\\\\x8a\\', \\'\\\\r\\', \\'\\\\x8e\\', \\'\\\\x11\\', \\'\\\\x92\\', \\'\\\\x15\\', \\'\\\\x96\\', \\'\\\\x19\\', \\'\\\\x9a\\', \\'\\\\x1d\\', \\'\\\\x9e\\', \\'\\\\xa2\\', \\'\\\\xa6\\', \\'\\\\xaa\\', \\'\\\\xae\\', \\'\\\\xb2\\', \\'\\\\xb6\\', \\'\\\\xba\\', \\'\\\\xbe\\', \\'\\\\xc2\\', \\'\\\\xc6\\', \\'\\\\xca\\', \\'\\\\xce\\', \\'\\\\xd2\\', \\'\\\\xd6\\', \\'\\\\xda\\', \\'\\\\xde\\', \\'\\\\xe2\\', \\'\\\\xe6\\', \\'\\\\xea\\', \\'\\\\xee\\', \\'\\\\xf2\\', \\'\\\\xf6\\', \\'\\\\xfa\\', \\'\\\\xfe\\'}\\n            >>> sc = shellcraft.echo(\"Hello world\") + shellcraft.exit()\\n            >>> ascii = encoders.i386.ascii_shellcode.encode(asm(sc), avoid)\\n            >>> ascii += asm(\\'jmp esp\\') # just for testing, the unpacker should also run on the stack\\n            >>> ELF.from_bytes(ascii).process().recvall()\\n            b\\'Hello world\\'\\n        '\n    if not avoid:\n        vocab = bytearray(b'!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n    else:\n        required_chars = set('\\\\-%TXP')\n        allowed = set(all_chars)\n        if avoid.intersection(required_chars):\n            raise RuntimeError('These characters ({}) are required because they assemble\\n                    into instructions used to unpack the shellcode'.format(str(required_chars, 'ascii')))\n        allowed.difference_update(avoid)\n        vocab = bytearray(map(ord, allowed))\n    if context.arch != 'i386' or context.bits != 32:\n        raise RuntimeError('Only 32-bit i386 is currently supported')\n    int_size = context.bytes\n    shellcode = bytearray(b'\\x90' * int_size + raw_bytes)\n    subtractions = self._get_subtractions(shellcode, vocab)\n    allocator = self._get_allocator(len(subtractions) + self.slop, vocab)\n    nop_sled = b'P' * self.slop\n    return bytes(allocator + subtractions + nop_sled)",
            "@LocalContext\ndef __call__(self, raw_bytes, avoid=None, pcreg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Pack shellcode into only ascii characters that unpacks itself and\\n        executes (on the stack)\\n\\n        Args:\\n            raw_bytes (bytes): The shellcode to be packed\\n            avoid (set, optional): Characters to avoid. Defaults to allow\\n                printable ascii (0x21-0x7e).\\n            pcreg (NoneType, optional): Ignored\\n\\n        Raises:\\n            RuntimeError: A required character is in ``avoid`` (required\\n                characters are characters which assemble into assembly\\n                instructions and are used to unpack the shellcode onto the\\n                stack, more details in the paper linked above ``\\\\ - % T X P``).\\n            RuntimeError: Not supported architecture\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-anded with eachother\\n                their result is 0\\n            ArithmeticError: Could not find a correct subtraction sequence\\n                to get to the the desired target value with the given ``avoid``\\n                parameter\\n\\n        Returns:\\n            bytes: The packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = b\"\\\\x83\\\\xc4\\\\x181\\\\xc01\\\\xdb\\\\xb0\\\\x06\\\\xcd\\\\x80Sh/ttyh/dev\\\\x89\\\\xe31\\\\xc9f\\\\xb9\\\\x12\\'\\\\xb0\\\\x05\\\\xcd\\\\x80j\\\\x17X1\\\\xdb\\\\xcd\\\\x80j.XS\\\\xcd\\\\x801\\\\xc0Ph//shh/bin\\\\x89\\\\xe3PS\\\\x89\\\\xe1\\\\x99\\\\xb0\\\\x0b\\\\xcd\\\\x80\"\\n            >>> encoders.i386.ascii_shellcode.encode(sc)\\n            b\\'TX-!!!!-\"_``-~~~~P\\\\\\\\%!!!!%@@@@-!6!!-V~!!-~~<-P-!mha-a~~~P-!!L`-a^~~-~~~~P-!!if-9`~~P-!!!!-aOaf-~~~~P-!&!<-!~`~--~~~P-!!!!-!!H^-+A~~P-U!![-~A1~P-,<V!-~~~!-~~~GP-!2!8-j~O~P-!]!!-!~!r-y~w~P-c!!!-~<(+P-N!_W-~1~~P-!!]!-Mn~!-~~~<P-!<!!-r~!P-~~x~P-fe!$-~~S~-~~~~P-!!\\\\\\'$-%z~~P-A!!!-~!#!-~*~=P-!7!!-T~!!-~~E^PPPPPPPPPPPPPPPPPPPPP\\'\\n            >>> avoid = {\\'\\\\x00\\', \\'\\\\x83\\', \\'\\\\x04\\', \\'\\\\x87\\', \\'\\\\x08\\', \\'\\\\x8b\\', \\'\\\\x0c\\', \\'\\\\x8f\\', \\'\\\\x10\\', \\'\\\\x93\\', \\'\\\\x14\\', \\'\\\\x97\\', \\'\\\\x18\\', \\'\\\\x9b\\', \\'\\\\x1c\\', \\'\\\\x9f\\', \\' \\', \\'\\\\xa3\\', \\'\\\\xa7\\', \\'\\\\xab\\', \\'\\\\xaf\\', \\'\\\\xb3\\', \\'\\\\xb7\\', \\'\\\\xbb\\', \\'\\\\xbf\\', \\'\\\\xc3\\', \\'\\\\xc7\\', \\'\\\\xcb\\', \\'\\\\xcf\\', \\'\\\\xd3\\', \\'\\\\xd7\\', \\'\\\\xdb\\', \\'\\\\xdf\\', \\'\\\\xe3\\', \\'\\\\xe7\\', \\'\\\\xeb\\', \\'\\\\xef\\', \\'\\\\xf3\\', \\'\\\\xf7\\', \\'\\\\xfb\\', \\'\\\\xff\\', \\'\\\\x80\\', \\'\\\\x03\\', \\'\\\\x84\\', \\'\\\\x07\\', \\'\\\\x88\\', \\'\\\\x0b\\', \\'\\\\x8c\\', \\'\\\\x0f\\', \\'\\\\x90\\', \\'\\\\x13\\', \\'\\\\x94\\', \\'\\\\x17\\', \\'\\\\x98\\', \\'\\\\x1b\\', \\'\\\\x9c\\', \\'\\\\x1f\\', \\'\\\\xa0\\', \\'\\\\xa4\\', \\'\\\\xa8\\', \\'\\\\xac\\', \\'\\\\xb0\\', \\'\\\\xb4\\', \\'\\\\xb8\\', \\'\\\\xbc\\', \\'\\\\xc0\\', \\'\\\\xc4\\', \\'\\\\xc8\\', \\'\\\\xcc\\', \\'\\\\xd0\\', \\'\\\\xd4\\', \\'\\\\xd8\\', \\'\\\\xdc\\', \\'\\\\xe0\\', \\'\\\\xe4\\', \\'\\\\xe8\\', \\'\\\\xec\\', \\'\\\\xf0\\', \\'\\\\xf4\\', \\'\\\\xf8\\', \\'\\\\xfc\\', \\'\\\\x7f\\', \\'\\\\x81\\', \\'\\\\x02\\', \\'\\\\x85\\', \\'\\\\x06\\', \\'\\\\x89\\', \\'\\\\n\\', \\'\\\\x8d\\', \\'\\\\x0e\\', \\'\\\\x91\\', \\'\\\\x12\\', \\'\\\\x95\\', \\'\\\\x16\\', \\'\\\\x99\\', \\'\\\\x1a\\', \\'\\\\x9d\\', \\'\\\\x1e\\', \\'\\\\xa1\\', \\'\\\\xa5\\', \\'\\\\xa9\\', \\'\\\\xad\\', \\'\\\\xb1\\', \\'\\\\xb5\\', \\'\\\\xb9\\', \\'\\\\xbd\\', \\'\\\\xc1\\', \\'\\\\xc5\\', \\'\\\\xc9\\', \\'\\\\xcd\\', \\'\\\\xd1\\', \\'\\\\xd5\\', \\'\\\\xd9\\', \\'\\\\xdd\\', \\'\\\\xe1\\', \\'\\\\xe5\\', \\'\\\\xe9\\', \\'\\\\xed\\', \\'\\\\xf1\\', \\'\\\\xf5\\', \\'\\\\xf9\\', \\'\\\\xfd\\', \\'\\\\x01\\', \\'\\\\x82\\', \\'\\\\x05\\', \\'\\\\x86\\', \\'\\\\t\\', \\'\\\\x8a\\', \\'\\\\r\\', \\'\\\\x8e\\', \\'\\\\x11\\', \\'\\\\x92\\', \\'\\\\x15\\', \\'\\\\x96\\', \\'\\\\x19\\', \\'\\\\x9a\\', \\'\\\\x1d\\', \\'\\\\x9e\\', \\'\\\\xa2\\', \\'\\\\xa6\\', \\'\\\\xaa\\', \\'\\\\xae\\', \\'\\\\xb2\\', \\'\\\\xb6\\', \\'\\\\xba\\', \\'\\\\xbe\\', \\'\\\\xc2\\', \\'\\\\xc6\\', \\'\\\\xca\\', \\'\\\\xce\\', \\'\\\\xd2\\', \\'\\\\xd6\\', \\'\\\\xda\\', \\'\\\\xde\\', \\'\\\\xe2\\', \\'\\\\xe6\\', \\'\\\\xea\\', \\'\\\\xee\\', \\'\\\\xf2\\', \\'\\\\xf6\\', \\'\\\\xfa\\', \\'\\\\xfe\\'}\\n            >>> sc = shellcraft.echo(\"Hello world\") + shellcraft.exit()\\n            >>> ascii = encoders.i386.ascii_shellcode.encode(asm(sc), avoid)\\n            >>> ascii += asm(\\'jmp esp\\') # just for testing, the unpacker should also run on the stack\\n            >>> ELF.from_bytes(ascii).process().recvall()\\n            b\\'Hello world\\'\\n        '\n    if not avoid:\n        vocab = bytearray(b'!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n    else:\n        required_chars = set('\\\\-%TXP')\n        allowed = set(all_chars)\n        if avoid.intersection(required_chars):\n            raise RuntimeError('These characters ({}) are required because they assemble\\n                    into instructions used to unpack the shellcode'.format(str(required_chars, 'ascii')))\n        allowed.difference_update(avoid)\n        vocab = bytearray(map(ord, allowed))\n    if context.arch != 'i386' or context.bits != 32:\n        raise RuntimeError('Only 32-bit i386 is currently supported')\n    int_size = context.bytes\n    shellcode = bytearray(b'\\x90' * int_size + raw_bytes)\n    subtractions = self._get_subtractions(shellcode, vocab)\n    allocator = self._get_allocator(len(subtractions) + self.slop, vocab)\n    nop_sled = b'P' * self.slop\n    return bytes(allocator + subtractions + nop_sled)",
            "@LocalContext\ndef __call__(self, raw_bytes, avoid=None, pcreg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Pack shellcode into only ascii characters that unpacks itself and\\n        executes (on the stack)\\n\\n        Args:\\n            raw_bytes (bytes): The shellcode to be packed\\n            avoid (set, optional): Characters to avoid. Defaults to allow\\n                printable ascii (0x21-0x7e).\\n            pcreg (NoneType, optional): Ignored\\n\\n        Raises:\\n            RuntimeError: A required character is in ``avoid`` (required\\n                characters are characters which assemble into assembly\\n                instructions and are used to unpack the shellcode onto the\\n                stack, more details in the paper linked above ``\\\\ - % T X P``).\\n            RuntimeError: Not supported architecture\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-anded with eachother\\n                their result is 0\\n            ArithmeticError: Could not find a correct subtraction sequence\\n                to get to the the desired target value with the given ``avoid``\\n                parameter\\n\\n        Returns:\\n            bytes: The packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = b\"\\\\x83\\\\xc4\\\\x181\\\\xc01\\\\xdb\\\\xb0\\\\x06\\\\xcd\\\\x80Sh/ttyh/dev\\\\x89\\\\xe31\\\\xc9f\\\\xb9\\\\x12\\'\\\\xb0\\\\x05\\\\xcd\\\\x80j\\\\x17X1\\\\xdb\\\\xcd\\\\x80j.XS\\\\xcd\\\\x801\\\\xc0Ph//shh/bin\\\\x89\\\\xe3PS\\\\x89\\\\xe1\\\\x99\\\\xb0\\\\x0b\\\\xcd\\\\x80\"\\n            >>> encoders.i386.ascii_shellcode.encode(sc)\\n            b\\'TX-!!!!-\"_``-~~~~P\\\\\\\\%!!!!%@@@@-!6!!-V~!!-~~<-P-!mha-a~~~P-!!L`-a^~~-~~~~P-!!if-9`~~P-!!!!-aOaf-~~~~P-!&!<-!~`~--~~~P-!!!!-!!H^-+A~~P-U!![-~A1~P-,<V!-~~~!-~~~GP-!2!8-j~O~P-!]!!-!~!r-y~w~P-c!!!-~<(+P-N!_W-~1~~P-!!]!-Mn~!-~~~<P-!<!!-r~!P-~~x~P-fe!$-~~S~-~~~~P-!!\\\\\\'$-%z~~P-A!!!-~!#!-~*~=P-!7!!-T~!!-~~E^PPPPPPPPPPPPPPPPPPPPP\\'\\n            >>> avoid = {\\'\\\\x00\\', \\'\\\\x83\\', \\'\\\\x04\\', \\'\\\\x87\\', \\'\\\\x08\\', \\'\\\\x8b\\', \\'\\\\x0c\\', \\'\\\\x8f\\', \\'\\\\x10\\', \\'\\\\x93\\', \\'\\\\x14\\', \\'\\\\x97\\', \\'\\\\x18\\', \\'\\\\x9b\\', \\'\\\\x1c\\', \\'\\\\x9f\\', \\' \\', \\'\\\\xa3\\', \\'\\\\xa7\\', \\'\\\\xab\\', \\'\\\\xaf\\', \\'\\\\xb3\\', \\'\\\\xb7\\', \\'\\\\xbb\\', \\'\\\\xbf\\', \\'\\\\xc3\\', \\'\\\\xc7\\', \\'\\\\xcb\\', \\'\\\\xcf\\', \\'\\\\xd3\\', \\'\\\\xd7\\', \\'\\\\xdb\\', \\'\\\\xdf\\', \\'\\\\xe3\\', \\'\\\\xe7\\', \\'\\\\xeb\\', \\'\\\\xef\\', \\'\\\\xf3\\', \\'\\\\xf7\\', \\'\\\\xfb\\', \\'\\\\xff\\', \\'\\\\x80\\', \\'\\\\x03\\', \\'\\\\x84\\', \\'\\\\x07\\', \\'\\\\x88\\', \\'\\\\x0b\\', \\'\\\\x8c\\', \\'\\\\x0f\\', \\'\\\\x90\\', \\'\\\\x13\\', \\'\\\\x94\\', \\'\\\\x17\\', \\'\\\\x98\\', \\'\\\\x1b\\', \\'\\\\x9c\\', \\'\\\\x1f\\', \\'\\\\xa0\\', \\'\\\\xa4\\', \\'\\\\xa8\\', \\'\\\\xac\\', \\'\\\\xb0\\', \\'\\\\xb4\\', \\'\\\\xb8\\', \\'\\\\xbc\\', \\'\\\\xc0\\', \\'\\\\xc4\\', \\'\\\\xc8\\', \\'\\\\xcc\\', \\'\\\\xd0\\', \\'\\\\xd4\\', \\'\\\\xd8\\', \\'\\\\xdc\\', \\'\\\\xe0\\', \\'\\\\xe4\\', \\'\\\\xe8\\', \\'\\\\xec\\', \\'\\\\xf0\\', \\'\\\\xf4\\', \\'\\\\xf8\\', \\'\\\\xfc\\', \\'\\\\x7f\\', \\'\\\\x81\\', \\'\\\\x02\\', \\'\\\\x85\\', \\'\\\\x06\\', \\'\\\\x89\\', \\'\\\\n\\', \\'\\\\x8d\\', \\'\\\\x0e\\', \\'\\\\x91\\', \\'\\\\x12\\', \\'\\\\x95\\', \\'\\\\x16\\', \\'\\\\x99\\', \\'\\\\x1a\\', \\'\\\\x9d\\', \\'\\\\x1e\\', \\'\\\\xa1\\', \\'\\\\xa5\\', \\'\\\\xa9\\', \\'\\\\xad\\', \\'\\\\xb1\\', \\'\\\\xb5\\', \\'\\\\xb9\\', \\'\\\\xbd\\', \\'\\\\xc1\\', \\'\\\\xc5\\', \\'\\\\xc9\\', \\'\\\\xcd\\', \\'\\\\xd1\\', \\'\\\\xd5\\', \\'\\\\xd9\\', \\'\\\\xdd\\', \\'\\\\xe1\\', \\'\\\\xe5\\', \\'\\\\xe9\\', \\'\\\\xed\\', \\'\\\\xf1\\', \\'\\\\xf5\\', \\'\\\\xf9\\', \\'\\\\xfd\\', \\'\\\\x01\\', \\'\\\\x82\\', \\'\\\\x05\\', \\'\\\\x86\\', \\'\\\\t\\', \\'\\\\x8a\\', \\'\\\\r\\', \\'\\\\x8e\\', \\'\\\\x11\\', \\'\\\\x92\\', \\'\\\\x15\\', \\'\\\\x96\\', \\'\\\\x19\\', \\'\\\\x9a\\', \\'\\\\x1d\\', \\'\\\\x9e\\', \\'\\\\xa2\\', \\'\\\\xa6\\', \\'\\\\xaa\\', \\'\\\\xae\\', \\'\\\\xb2\\', \\'\\\\xb6\\', \\'\\\\xba\\', \\'\\\\xbe\\', \\'\\\\xc2\\', \\'\\\\xc6\\', \\'\\\\xca\\', \\'\\\\xce\\', \\'\\\\xd2\\', \\'\\\\xd6\\', \\'\\\\xda\\', \\'\\\\xde\\', \\'\\\\xe2\\', \\'\\\\xe6\\', \\'\\\\xea\\', \\'\\\\xee\\', \\'\\\\xf2\\', \\'\\\\xf6\\', \\'\\\\xfa\\', \\'\\\\xfe\\'}\\n            >>> sc = shellcraft.echo(\"Hello world\") + shellcraft.exit()\\n            >>> ascii = encoders.i386.ascii_shellcode.encode(asm(sc), avoid)\\n            >>> ascii += asm(\\'jmp esp\\') # just for testing, the unpacker should also run on the stack\\n            >>> ELF.from_bytes(ascii).process().recvall()\\n            b\\'Hello world\\'\\n        '\n    if not avoid:\n        vocab = bytearray(b'!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n    else:\n        required_chars = set('\\\\-%TXP')\n        allowed = set(all_chars)\n        if avoid.intersection(required_chars):\n            raise RuntimeError('These characters ({}) are required because they assemble\\n                    into instructions used to unpack the shellcode'.format(str(required_chars, 'ascii')))\n        allowed.difference_update(avoid)\n        vocab = bytearray(map(ord, allowed))\n    if context.arch != 'i386' or context.bits != 32:\n        raise RuntimeError('Only 32-bit i386 is currently supported')\n    int_size = context.bytes\n    shellcode = bytearray(b'\\x90' * int_size + raw_bytes)\n    subtractions = self._get_subtractions(shellcode, vocab)\n    allocator = self._get_allocator(len(subtractions) + self.slop, vocab)\n    nop_sled = b'P' * self.slop\n    return bytes(allocator + subtractions + nop_sled)"
        ]
    },
    {
        "func_name": "_get_allocator",
        "original": "@LocalContext\ndef _get_allocator(self, size, vocab):\n    \"\"\" Allocate enough space on the stack for the shellcode\n\n        int_size is taken from the context\n\n        Args:\n            size (int): The allocation size\n            vocab (bytearray): Allowed characters\n\n        Returns:\n            bytearray: The allocator shellcode\n\n        Examples:\n\n            >>> context.update(arch='i386', os='linux')\n            >>> vocab = bytearray(b'!\"#$%&\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n            >>> encoders.i386.ascii_shellcode.encode._get_allocator(300, vocab)\n            bytearray(b'TX-!!!!-!_``-t~~~P\\\\\\\\%!!!!%@@@@')\n        \"\"\"\n    size += 30\n    int_size = context.bytes\n    result = bytearray(b'TX')\n    target = bytearray(pack(size))\n    for subtraction in self._calc_subtractions(bytearray(int_size), target, vocab):\n        result += b'-' + subtraction\n    result += b'P\\\\'\n    (pos, neg) = self._find_negatives(vocab)\n    result += flat((b'%', pos, b'%', neg))\n    return result",
        "mutated": [
            "@LocalContext\ndef _get_allocator(self, size, vocab):\n    if False:\n        i = 10\n    ' Allocate enough space on the stack for the shellcode\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            size (int): The allocation size\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: The allocator shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_allocator(300, vocab)\\n            bytearray(b\\'TX-!!!!-!_``-t~~~P\\\\\\\\%!!!!%@@@@\\')\\n        '\n    size += 30\n    int_size = context.bytes\n    result = bytearray(b'TX')\n    target = bytearray(pack(size))\n    for subtraction in self._calc_subtractions(bytearray(int_size), target, vocab):\n        result += b'-' + subtraction\n    result += b'P\\\\'\n    (pos, neg) = self._find_negatives(vocab)\n    result += flat((b'%', pos, b'%', neg))\n    return result",
            "@LocalContext\ndef _get_allocator(self, size, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Allocate enough space on the stack for the shellcode\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            size (int): The allocation size\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: The allocator shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_allocator(300, vocab)\\n            bytearray(b\\'TX-!!!!-!_``-t~~~P\\\\\\\\%!!!!%@@@@\\')\\n        '\n    size += 30\n    int_size = context.bytes\n    result = bytearray(b'TX')\n    target = bytearray(pack(size))\n    for subtraction in self._calc_subtractions(bytearray(int_size), target, vocab):\n        result += b'-' + subtraction\n    result += b'P\\\\'\n    (pos, neg) = self._find_negatives(vocab)\n    result += flat((b'%', pos, b'%', neg))\n    return result",
            "@LocalContext\ndef _get_allocator(self, size, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Allocate enough space on the stack for the shellcode\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            size (int): The allocation size\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: The allocator shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_allocator(300, vocab)\\n            bytearray(b\\'TX-!!!!-!_``-t~~~P\\\\\\\\%!!!!%@@@@\\')\\n        '\n    size += 30\n    int_size = context.bytes\n    result = bytearray(b'TX')\n    target = bytearray(pack(size))\n    for subtraction in self._calc_subtractions(bytearray(int_size), target, vocab):\n        result += b'-' + subtraction\n    result += b'P\\\\'\n    (pos, neg) = self._find_negatives(vocab)\n    result += flat((b'%', pos, b'%', neg))\n    return result",
            "@LocalContext\ndef _get_allocator(self, size, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Allocate enough space on the stack for the shellcode\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            size (int): The allocation size\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: The allocator shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_allocator(300, vocab)\\n            bytearray(b\\'TX-!!!!-!_``-t~~~P\\\\\\\\%!!!!%@@@@\\')\\n        '\n    size += 30\n    int_size = context.bytes\n    result = bytearray(b'TX')\n    target = bytearray(pack(size))\n    for subtraction in self._calc_subtractions(bytearray(int_size), target, vocab):\n        result += b'-' + subtraction\n    result += b'P\\\\'\n    (pos, neg) = self._find_negatives(vocab)\n    result += flat((b'%', pos, b'%', neg))\n    return result",
            "@LocalContext\ndef _get_allocator(self, size, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Allocate enough space on the stack for the shellcode\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            size (int): The allocation size\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: The allocator shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_allocator(300, vocab)\\n            bytearray(b\\'TX-!!!!-!_``-t~~~P\\\\\\\\%!!!!%@@@@\\')\\n        '\n    size += 30\n    int_size = context.bytes\n    result = bytearray(b'TX')\n    target = bytearray(pack(size))\n    for subtraction in self._calc_subtractions(bytearray(int_size), target, vocab):\n        result += b'-' + subtraction\n    result += b'P\\\\'\n    (pos, neg) = self._find_negatives(vocab)\n    result += flat((b'%', pos, b'%', neg))\n    return result"
        ]
    },
    {
        "func_name": "_find_negatives",
        "original": "@LocalContext\ndef _find_negatives(self, vocab):\n    \"\"\" Find two bitwise negatives in the vocab so that when they are\n        and-ed the result is 0.\n\n        int_size is taken from the context\n\n        Args:\n            vocab (bytearray): Allowed characters\n\n        Returns:\n            Tuple[int, int]: value A, value B\n\n        Raises:\n            ArithmeticError: The allowed character set does not contain\n                two characters that when they are bitwise-and-ed with eachother\n                the result is 0\n\n        Examples:\n\n            >>> context.update(arch='i386', os='linux')\n            >>> vocab = bytearray(b'!\"#$%&\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n            >>> a, b = encoders.i386.ascii_shellcode.encode._find_negatives(vocab)\n            >>> a & b\n            0\n        \"\"\"\n    int_size = context.bytes\n    for products in product(vocab, vocab):\n        if products[0] & products[1] == 0:\n            return tuple((unpack(p8(x) * int_size) for x in bytearray(products)))\n    else:\n        raise ArithmeticError('Could not find two bitwise negatives in the provided vocab')",
        "mutated": [
            "@LocalContext\ndef _find_negatives(self, vocab):\n    if False:\n        i = 10\n    ' Find two bitwise negatives in the vocab so that when they are\\n        and-ed the result is 0.\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            Tuple[int, int]: value A, value B\\n\\n        Raises:\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-and-ed with eachother\\n                the result is 0\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> a, b = encoders.i386.ascii_shellcode.encode._find_negatives(vocab)\\n            >>> a & b\\n            0\\n        '\n    int_size = context.bytes\n    for products in product(vocab, vocab):\n        if products[0] & products[1] == 0:\n            return tuple((unpack(p8(x) * int_size) for x in bytearray(products)))\n    else:\n        raise ArithmeticError('Could not find two bitwise negatives in the provided vocab')",
            "@LocalContext\ndef _find_negatives(self, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Find two bitwise negatives in the vocab so that when they are\\n        and-ed the result is 0.\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            Tuple[int, int]: value A, value B\\n\\n        Raises:\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-and-ed with eachother\\n                the result is 0\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> a, b = encoders.i386.ascii_shellcode.encode._find_negatives(vocab)\\n            >>> a & b\\n            0\\n        '\n    int_size = context.bytes\n    for products in product(vocab, vocab):\n        if products[0] & products[1] == 0:\n            return tuple((unpack(p8(x) * int_size) for x in bytearray(products)))\n    else:\n        raise ArithmeticError('Could not find two bitwise negatives in the provided vocab')",
            "@LocalContext\ndef _find_negatives(self, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Find two bitwise negatives in the vocab so that when they are\\n        and-ed the result is 0.\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            Tuple[int, int]: value A, value B\\n\\n        Raises:\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-and-ed with eachother\\n                the result is 0\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> a, b = encoders.i386.ascii_shellcode.encode._find_negatives(vocab)\\n            >>> a & b\\n            0\\n        '\n    int_size = context.bytes\n    for products in product(vocab, vocab):\n        if products[0] & products[1] == 0:\n            return tuple((unpack(p8(x) * int_size) for x in bytearray(products)))\n    else:\n        raise ArithmeticError('Could not find two bitwise negatives in the provided vocab')",
            "@LocalContext\ndef _find_negatives(self, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Find two bitwise negatives in the vocab so that when they are\\n        and-ed the result is 0.\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            Tuple[int, int]: value A, value B\\n\\n        Raises:\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-and-ed with eachother\\n                the result is 0\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> a, b = encoders.i386.ascii_shellcode.encode._find_negatives(vocab)\\n            >>> a & b\\n            0\\n        '\n    int_size = context.bytes\n    for products in product(vocab, vocab):\n        if products[0] & products[1] == 0:\n            return tuple((unpack(p8(x) * int_size) for x in bytearray(products)))\n    else:\n        raise ArithmeticError('Could not find two bitwise negatives in the provided vocab')",
            "@LocalContext\ndef _find_negatives(self, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Find two bitwise negatives in the vocab so that when they are\\n        and-ed the result is 0.\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            Tuple[int, int]: value A, value B\\n\\n        Raises:\\n            ArithmeticError: The allowed character set does not contain\\n                two characters that when they are bitwise-and-ed with eachother\\n                the result is 0\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> a, b = encoders.i386.ascii_shellcode.encode._find_negatives(vocab)\\n            >>> a & b\\n            0\\n        '\n    int_size = context.bytes\n    for products in product(vocab, vocab):\n        if products[0] & products[1] == 0:\n            return tuple((unpack(p8(x) * int_size) for x in bytearray(products)))\n    else:\n        raise ArithmeticError('Could not find two bitwise negatives in the provided vocab')"
        ]
    },
    {
        "func_name": "_get_subtractions",
        "original": "@LocalContext\ndef _get_subtractions(self, shellcode, vocab):\n    \"\"\" Covert the sellcode to sub eax and posh eax instructions\n\n        int_size is taken from the context\n\n        Args:\n            shellcode (bytearray): The shellcode to pack\n            vocab (bytearray): Allowed characters\n\n        Returns:\n            bytearray: packed shellcode\n\n        Examples:\n\n            >>> context.update(arch='i386', os='linux')\n            >>> sc = bytearray(b'ABCDEFGHIGKLMNOPQRSTUVXYZ')\n            >>> vocab = bytearray(b'!\"#$%&\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n            >>> encoders.i386.ascii_shellcode.encode._get_subtractions(sc, vocab)\n            bytearray(b'-(!!!-~NNNP-!=;:-f~~~-~~~~P-!!!!-edee-~~~~P-!!!!-eddd-~~~~P-!!!!-egdd-~~~~P-!!!!-eadd-~~~~P-!!!!-eddd-~~~~P')\n        \"\"\"\n    int_size = context.bytes\n    result = bytearray()\n    last = bytearray(int_size)\n    sc = tuple(group(int_size, shellcode, 144))[::-1]\n    for x in sc:\n        for subtraction in self._calc_subtractions(last, x, vocab):\n            result += b'-' + subtraction\n        last = x\n        result += b'P'\n    return result",
        "mutated": [
            "@LocalContext\ndef _get_subtractions(self, shellcode, vocab):\n    if False:\n        i = 10\n    ' Covert the sellcode to sub eax and posh eax instructions\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            shellcode (bytearray): The shellcode to pack\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = bytearray(b\\'ABCDEFGHIGKLMNOPQRSTUVXYZ\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_subtractions(sc, vocab)\\n            bytearray(b\\'-(!!!-~NNNP-!=;:-f~~~-~~~~P-!!!!-edee-~~~~P-!!!!-eddd-~~~~P-!!!!-egdd-~~~~P-!!!!-eadd-~~~~P-!!!!-eddd-~~~~P\\')\\n        '\n    int_size = context.bytes\n    result = bytearray()\n    last = bytearray(int_size)\n    sc = tuple(group(int_size, shellcode, 144))[::-1]\n    for x in sc:\n        for subtraction in self._calc_subtractions(last, x, vocab):\n            result += b'-' + subtraction\n        last = x\n        result += b'P'\n    return result",
            "@LocalContext\ndef _get_subtractions(self, shellcode, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Covert the sellcode to sub eax and posh eax instructions\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            shellcode (bytearray): The shellcode to pack\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = bytearray(b\\'ABCDEFGHIGKLMNOPQRSTUVXYZ\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_subtractions(sc, vocab)\\n            bytearray(b\\'-(!!!-~NNNP-!=;:-f~~~-~~~~P-!!!!-edee-~~~~P-!!!!-eddd-~~~~P-!!!!-egdd-~~~~P-!!!!-eadd-~~~~P-!!!!-eddd-~~~~P\\')\\n        '\n    int_size = context.bytes\n    result = bytearray()\n    last = bytearray(int_size)\n    sc = tuple(group(int_size, shellcode, 144))[::-1]\n    for x in sc:\n        for subtraction in self._calc_subtractions(last, x, vocab):\n            result += b'-' + subtraction\n        last = x\n        result += b'P'\n    return result",
            "@LocalContext\ndef _get_subtractions(self, shellcode, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Covert the sellcode to sub eax and posh eax instructions\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            shellcode (bytearray): The shellcode to pack\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = bytearray(b\\'ABCDEFGHIGKLMNOPQRSTUVXYZ\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_subtractions(sc, vocab)\\n            bytearray(b\\'-(!!!-~NNNP-!=;:-f~~~-~~~~P-!!!!-edee-~~~~P-!!!!-eddd-~~~~P-!!!!-egdd-~~~~P-!!!!-eadd-~~~~P-!!!!-eddd-~~~~P\\')\\n        '\n    int_size = context.bytes\n    result = bytearray()\n    last = bytearray(int_size)\n    sc = tuple(group(int_size, shellcode, 144))[::-1]\n    for x in sc:\n        for subtraction in self._calc_subtractions(last, x, vocab):\n            result += b'-' + subtraction\n        last = x\n        result += b'P'\n    return result",
            "@LocalContext\ndef _get_subtractions(self, shellcode, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Covert the sellcode to sub eax and posh eax instructions\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            shellcode (bytearray): The shellcode to pack\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = bytearray(b\\'ABCDEFGHIGKLMNOPQRSTUVXYZ\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_subtractions(sc, vocab)\\n            bytearray(b\\'-(!!!-~NNNP-!=;:-f~~~-~~~~P-!!!!-edee-~~~~P-!!!!-eddd-~~~~P-!!!!-egdd-~~~~P-!!!!-eadd-~~~~P-!!!!-eddd-~~~~P\\')\\n        '\n    int_size = context.bytes\n    result = bytearray()\n    last = bytearray(int_size)\n    sc = tuple(group(int_size, shellcode, 144))[::-1]\n    for x in sc:\n        for subtraction in self._calc_subtractions(last, x, vocab):\n            result += b'-' + subtraction\n        last = x\n        result += b'P'\n    return result",
            "@LocalContext\ndef _get_subtractions(self, shellcode, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Covert the sellcode to sub eax and posh eax instructions\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            shellcode (bytearray): The shellcode to pack\\n            vocab (bytearray): Allowed characters\\n\\n        Returns:\\n            bytearray: packed shellcode\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> sc = bytearray(b\\'ABCDEFGHIGKLMNOPQRSTUVXYZ\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> encoders.i386.ascii_shellcode.encode._get_subtractions(sc, vocab)\\n            bytearray(b\\'-(!!!-~NNNP-!=;:-f~~~-~~~~P-!!!!-edee-~~~~P-!!!!-eddd-~~~~P-!!!!-egdd-~~~~P-!!!!-eadd-~~~~P-!!!!-eddd-~~~~P\\')\\n        '\n    int_size = context.bytes\n    result = bytearray()\n    last = bytearray(int_size)\n    sc = tuple(group(int_size, shellcode, 144))[::-1]\n    for x in sc:\n        for subtraction in self._calc_subtractions(last, x, vocab):\n            result += b'-' + subtraction\n        last = x\n        result += b'P'\n    return result"
        ]
    },
    {
        "func_name": "_calc_subtractions",
        "original": "@LocalContext\ndef _calc_subtractions(self, last, target, vocab):\n    \"\"\" Given `target` and `last`, return a list of integers that when\n         subtracted from `last` will equal `target` while only constructing\n         integers from bytes in `vocab`\n\n        int_size is taken from the context\n\n        Args:\n            last (bytearray): Original value\n            target (bytearray): Desired value\n            vocab (bytearray): Allowed characters\n\n        Raises:\n            ArithmeticError: If a sequence of subtractions could not be found\n\n        Returns:\n            List[bytearray]: List of numbers that would need to be subtracted\n            from `last` to get to `target`\n\n        Examples:\n\n            >>> context.update(arch='i386', os='linux')\n            >>> vocab = bytearray(b'!\"#$%&\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~')\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b'\\\\x10'*4), bytearray(b'\\\\x11'*4), vocab))\n            [bytearray(b'!!!!'), bytearray(b'`___'), bytearray(b'~~~~')]\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b'\\\\x11\\\\x12\\\\x13\\\\x14'), bytearray(b'\\\\x15\\\\x16\\\\x17\\\\x18'), vocab))\n            [bytearray(b'~}}}'), bytearray(b'~~~~')]\n        \"\"\"\n    int_size = context.bytes\n    subtractions = [bytearray(int_size)]\n    for sub in range(self.max_subs):\n        carry = success_count = 0\n        for byte in range(int_size):\n            for products in product(*[x <= sub and vocab or (0,) for x in range(self.max_subs)]):\n                attempt = target[byte] + carry + sum(products)\n                if last[byte] == attempt & 255:\n                    carry = (attempt & 65280) >> 8\n                    for (p, i) in zip(products, range(sub + 1)):\n                        subtractions[i][byte] = p\n                    success_count += 1\n                    break\n        if success_count == int_size:\n            return subtractions\n        else:\n            subtractions.append(bytearray(int_size))\n    else:\n        raise ArithmeticError(str.format('Could not find the correct subtraction sequence\\n                to get the the desired target ({}) from ({})', target[byte], last[byte]))",
        "mutated": [
            "@LocalContext\ndef _calc_subtractions(self, last, target, vocab):\n    if False:\n        i = 10\n    ' Given `target` and `last`, return a list of integers that when\\n         subtracted from `last` will equal `target` while only constructing\\n         integers from bytes in `vocab`\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            last (bytearray): Original value\\n            target (bytearray): Desired value\\n            vocab (bytearray): Allowed characters\\n\\n        Raises:\\n            ArithmeticError: If a sequence of subtractions could not be found\\n\\n        Returns:\\n            List[bytearray]: List of numbers that would need to be subtracted\\n            from `last` to get to `target`\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x10\\'*4), bytearray(b\\'\\\\x11\\'*4), vocab))\\n            [bytearray(b\\'!!!!\\'), bytearray(b\\'`___\\'), bytearray(b\\'~~~~\\')]\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x11\\\\x12\\\\x13\\\\x14\\'), bytearray(b\\'\\\\x15\\\\x16\\\\x17\\\\x18\\'), vocab))\\n            [bytearray(b\\'~}}}\\'), bytearray(b\\'~~~~\\')]\\n        '\n    int_size = context.bytes\n    subtractions = [bytearray(int_size)]\n    for sub in range(self.max_subs):\n        carry = success_count = 0\n        for byte in range(int_size):\n            for products in product(*[x <= sub and vocab or (0,) for x in range(self.max_subs)]):\n                attempt = target[byte] + carry + sum(products)\n                if last[byte] == attempt & 255:\n                    carry = (attempt & 65280) >> 8\n                    for (p, i) in zip(products, range(sub + 1)):\n                        subtractions[i][byte] = p\n                    success_count += 1\n                    break\n        if success_count == int_size:\n            return subtractions\n        else:\n            subtractions.append(bytearray(int_size))\n    else:\n        raise ArithmeticError(str.format('Could not find the correct subtraction sequence\\n                to get the the desired target ({}) from ({})', target[byte], last[byte]))",
            "@LocalContext\ndef _calc_subtractions(self, last, target, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Given `target` and `last`, return a list of integers that when\\n         subtracted from `last` will equal `target` while only constructing\\n         integers from bytes in `vocab`\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            last (bytearray): Original value\\n            target (bytearray): Desired value\\n            vocab (bytearray): Allowed characters\\n\\n        Raises:\\n            ArithmeticError: If a sequence of subtractions could not be found\\n\\n        Returns:\\n            List[bytearray]: List of numbers that would need to be subtracted\\n            from `last` to get to `target`\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x10\\'*4), bytearray(b\\'\\\\x11\\'*4), vocab))\\n            [bytearray(b\\'!!!!\\'), bytearray(b\\'`___\\'), bytearray(b\\'~~~~\\')]\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x11\\\\x12\\\\x13\\\\x14\\'), bytearray(b\\'\\\\x15\\\\x16\\\\x17\\\\x18\\'), vocab))\\n            [bytearray(b\\'~}}}\\'), bytearray(b\\'~~~~\\')]\\n        '\n    int_size = context.bytes\n    subtractions = [bytearray(int_size)]\n    for sub in range(self.max_subs):\n        carry = success_count = 0\n        for byte in range(int_size):\n            for products in product(*[x <= sub and vocab or (0,) for x in range(self.max_subs)]):\n                attempt = target[byte] + carry + sum(products)\n                if last[byte] == attempt & 255:\n                    carry = (attempt & 65280) >> 8\n                    for (p, i) in zip(products, range(sub + 1)):\n                        subtractions[i][byte] = p\n                    success_count += 1\n                    break\n        if success_count == int_size:\n            return subtractions\n        else:\n            subtractions.append(bytearray(int_size))\n    else:\n        raise ArithmeticError(str.format('Could not find the correct subtraction sequence\\n                to get the the desired target ({}) from ({})', target[byte], last[byte]))",
            "@LocalContext\ndef _calc_subtractions(self, last, target, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Given `target` and `last`, return a list of integers that when\\n         subtracted from `last` will equal `target` while only constructing\\n         integers from bytes in `vocab`\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            last (bytearray): Original value\\n            target (bytearray): Desired value\\n            vocab (bytearray): Allowed characters\\n\\n        Raises:\\n            ArithmeticError: If a sequence of subtractions could not be found\\n\\n        Returns:\\n            List[bytearray]: List of numbers that would need to be subtracted\\n            from `last` to get to `target`\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x10\\'*4), bytearray(b\\'\\\\x11\\'*4), vocab))\\n            [bytearray(b\\'!!!!\\'), bytearray(b\\'`___\\'), bytearray(b\\'~~~~\\')]\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x11\\\\x12\\\\x13\\\\x14\\'), bytearray(b\\'\\\\x15\\\\x16\\\\x17\\\\x18\\'), vocab))\\n            [bytearray(b\\'~}}}\\'), bytearray(b\\'~~~~\\')]\\n        '\n    int_size = context.bytes\n    subtractions = [bytearray(int_size)]\n    for sub in range(self.max_subs):\n        carry = success_count = 0\n        for byte in range(int_size):\n            for products in product(*[x <= sub and vocab or (0,) for x in range(self.max_subs)]):\n                attempt = target[byte] + carry + sum(products)\n                if last[byte] == attempt & 255:\n                    carry = (attempt & 65280) >> 8\n                    for (p, i) in zip(products, range(sub + 1)):\n                        subtractions[i][byte] = p\n                    success_count += 1\n                    break\n        if success_count == int_size:\n            return subtractions\n        else:\n            subtractions.append(bytearray(int_size))\n    else:\n        raise ArithmeticError(str.format('Could not find the correct subtraction sequence\\n                to get the the desired target ({}) from ({})', target[byte], last[byte]))",
            "@LocalContext\ndef _calc_subtractions(self, last, target, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Given `target` and `last`, return a list of integers that when\\n         subtracted from `last` will equal `target` while only constructing\\n         integers from bytes in `vocab`\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            last (bytearray): Original value\\n            target (bytearray): Desired value\\n            vocab (bytearray): Allowed characters\\n\\n        Raises:\\n            ArithmeticError: If a sequence of subtractions could not be found\\n\\n        Returns:\\n            List[bytearray]: List of numbers that would need to be subtracted\\n            from `last` to get to `target`\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x10\\'*4), bytearray(b\\'\\\\x11\\'*4), vocab))\\n            [bytearray(b\\'!!!!\\'), bytearray(b\\'`___\\'), bytearray(b\\'~~~~\\')]\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x11\\\\x12\\\\x13\\\\x14\\'), bytearray(b\\'\\\\x15\\\\x16\\\\x17\\\\x18\\'), vocab))\\n            [bytearray(b\\'~}}}\\'), bytearray(b\\'~~~~\\')]\\n        '\n    int_size = context.bytes\n    subtractions = [bytearray(int_size)]\n    for sub in range(self.max_subs):\n        carry = success_count = 0\n        for byte in range(int_size):\n            for products in product(*[x <= sub and vocab or (0,) for x in range(self.max_subs)]):\n                attempt = target[byte] + carry + sum(products)\n                if last[byte] == attempt & 255:\n                    carry = (attempt & 65280) >> 8\n                    for (p, i) in zip(products, range(sub + 1)):\n                        subtractions[i][byte] = p\n                    success_count += 1\n                    break\n        if success_count == int_size:\n            return subtractions\n        else:\n            subtractions.append(bytearray(int_size))\n    else:\n        raise ArithmeticError(str.format('Could not find the correct subtraction sequence\\n                to get the the desired target ({}) from ({})', target[byte], last[byte]))",
            "@LocalContext\ndef _calc_subtractions(self, last, target, vocab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Given `target` and `last`, return a list of integers that when\\n         subtracted from `last` will equal `target` while only constructing\\n         integers from bytes in `vocab`\\n\\n        int_size is taken from the context\\n\\n        Args:\\n            last (bytearray): Original value\\n            target (bytearray): Desired value\\n            vocab (bytearray): Allowed characters\\n\\n        Raises:\\n            ArithmeticError: If a sequence of subtractions could not be found\\n\\n        Returns:\\n            List[bytearray]: List of numbers that would need to be subtracted\\n            from `last` to get to `target`\\n\\n        Examples:\\n\\n            >>> context.update(arch=\\'i386\\', os=\\'linux\\')\\n            >>> vocab = bytearray(b\\'!\"#$%&\\\\\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\')\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x10\\'*4), bytearray(b\\'\\\\x11\\'*4), vocab))\\n            [bytearray(b\\'!!!!\\'), bytearray(b\\'`___\\'), bytearray(b\\'~~~~\\')]\\n            >>> print(encoders.i386.ascii_shellcode.encode._calc_subtractions(bytearray(b\\'\\\\x11\\\\x12\\\\x13\\\\x14\\'), bytearray(b\\'\\\\x15\\\\x16\\\\x17\\\\x18\\'), vocab))\\n            [bytearray(b\\'~}}}\\'), bytearray(b\\'~~~~\\')]\\n        '\n    int_size = context.bytes\n    subtractions = [bytearray(int_size)]\n    for sub in range(self.max_subs):\n        carry = success_count = 0\n        for byte in range(int_size):\n            for products in product(*[x <= sub and vocab or (0,) for x in range(self.max_subs)]):\n                attempt = target[byte] + carry + sum(products)\n                if last[byte] == attempt & 255:\n                    carry = (attempt & 65280) >> 8\n                    for (p, i) in zip(products, range(sub + 1)):\n                        subtractions[i][byte] = p\n                    success_count += 1\n                    break\n        if success_count == int_size:\n            return subtractions\n        else:\n            subtractions.append(bytearray(int_size))\n    else:\n        raise ArithmeticError(str.format('Could not find the correct subtraction sequence\\n                to get the the desired target ({}) from ({})', target[byte], last[byte]))"
        ]
    }
]