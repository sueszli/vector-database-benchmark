[
    {
        "func_name": "test_centerpoint_fpn",
        "original": "def test_centerpoint_fpn():\n    second_cfg = dict(type='SECOND', in_channels=64, out_channels=[64, 128, 256], layer_nums=[3, 5, 5], layer_strides=[2, 2, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), conv_cfg=dict(type='Conv2d', bias=False))\n    second = build_backbone(second_cfg)\n    centerpoint_fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], out_channels=[128, 128, 128], upsample_strides=[0.5, 1, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), upsample_cfg=dict(type='deconv', bias=False), use_conv_for_no_stride=True)\n    fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], upsample_strides=[1, 2, 4], out_channels=[128, 128, 128])\n    second_fpn = build_neck(fpn_cfg)\n    centerpoint_second_fpn = build_neck(centerpoint_fpn_cfg)\n    input = torch.rand([4, 64, 512, 512])\n    sec_output = second(input)\n    centerpoint_output = centerpoint_second_fpn(sec_output)\n    second_output = second_fpn(sec_output)\n    assert centerpoint_output[0].shape == torch.Size([4, 384, 128, 128])\n    assert second_output[0].shape == torch.Size([4, 384, 256, 256])",
        "mutated": [
            "def test_centerpoint_fpn():\n    if False:\n        i = 10\n    second_cfg = dict(type='SECOND', in_channels=64, out_channels=[64, 128, 256], layer_nums=[3, 5, 5], layer_strides=[2, 2, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), conv_cfg=dict(type='Conv2d', bias=False))\n    second = build_backbone(second_cfg)\n    centerpoint_fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], out_channels=[128, 128, 128], upsample_strides=[0.5, 1, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), upsample_cfg=dict(type='deconv', bias=False), use_conv_for_no_stride=True)\n    fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], upsample_strides=[1, 2, 4], out_channels=[128, 128, 128])\n    second_fpn = build_neck(fpn_cfg)\n    centerpoint_second_fpn = build_neck(centerpoint_fpn_cfg)\n    input = torch.rand([4, 64, 512, 512])\n    sec_output = second(input)\n    centerpoint_output = centerpoint_second_fpn(sec_output)\n    second_output = second_fpn(sec_output)\n    assert centerpoint_output[0].shape == torch.Size([4, 384, 128, 128])\n    assert second_output[0].shape == torch.Size([4, 384, 256, 256])",
            "def test_centerpoint_fpn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    second_cfg = dict(type='SECOND', in_channels=64, out_channels=[64, 128, 256], layer_nums=[3, 5, 5], layer_strides=[2, 2, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), conv_cfg=dict(type='Conv2d', bias=False))\n    second = build_backbone(second_cfg)\n    centerpoint_fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], out_channels=[128, 128, 128], upsample_strides=[0.5, 1, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), upsample_cfg=dict(type='deconv', bias=False), use_conv_for_no_stride=True)\n    fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], upsample_strides=[1, 2, 4], out_channels=[128, 128, 128])\n    second_fpn = build_neck(fpn_cfg)\n    centerpoint_second_fpn = build_neck(centerpoint_fpn_cfg)\n    input = torch.rand([4, 64, 512, 512])\n    sec_output = second(input)\n    centerpoint_output = centerpoint_second_fpn(sec_output)\n    second_output = second_fpn(sec_output)\n    assert centerpoint_output[0].shape == torch.Size([4, 384, 128, 128])\n    assert second_output[0].shape == torch.Size([4, 384, 256, 256])",
            "def test_centerpoint_fpn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    second_cfg = dict(type='SECOND', in_channels=64, out_channels=[64, 128, 256], layer_nums=[3, 5, 5], layer_strides=[2, 2, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), conv_cfg=dict(type='Conv2d', bias=False))\n    second = build_backbone(second_cfg)\n    centerpoint_fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], out_channels=[128, 128, 128], upsample_strides=[0.5, 1, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), upsample_cfg=dict(type='deconv', bias=False), use_conv_for_no_stride=True)\n    fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], upsample_strides=[1, 2, 4], out_channels=[128, 128, 128])\n    second_fpn = build_neck(fpn_cfg)\n    centerpoint_second_fpn = build_neck(centerpoint_fpn_cfg)\n    input = torch.rand([4, 64, 512, 512])\n    sec_output = second(input)\n    centerpoint_output = centerpoint_second_fpn(sec_output)\n    second_output = second_fpn(sec_output)\n    assert centerpoint_output[0].shape == torch.Size([4, 384, 128, 128])\n    assert second_output[0].shape == torch.Size([4, 384, 256, 256])",
            "def test_centerpoint_fpn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    second_cfg = dict(type='SECOND', in_channels=64, out_channels=[64, 128, 256], layer_nums=[3, 5, 5], layer_strides=[2, 2, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), conv_cfg=dict(type='Conv2d', bias=False))\n    second = build_backbone(second_cfg)\n    centerpoint_fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], out_channels=[128, 128, 128], upsample_strides=[0.5, 1, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), upsample_cfg=dict(type='deconv', bias=False), use_conv_for_no_stride=True)\n    fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], upsample_strides=[1, 2, 4], out_channels=[128, 128, 128])\n    second_fpn = build_neck(fpn_cfg)\n    centerpoint_second_fpn = build_neck(centerpoint_fpn_cfg)\n    input = torch.rand([4, 64, 512, 512])\n    sec_output = second(input)\n    centerpoint_output = centerpoint_second_fpn(sec_output)\n    second_output = second_fpn(sec_output)\n    assert centerpoint_output[0].shape == torch.Size([4, 384, 128, 128])\n    assert second_output[0].shape == torch.Size([4, 384, 256, 256])",
            "def test_centerpoint_fpn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    second_cfg = dict(type='SECOND', in_channels=64, out_channels=[64, 128, 256], layer_nums=[3, 5, 5], layer_strides=[2, 2, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), conv_cfg=dict(type='Conv2d', bias=False))\n    second = build_backbone(second_cfg)\n    centerpoint_fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], out_channels=[128, 128, 128], upsample_strides=[0.5, 1, 2], norm_cfg=dict(type='BN', eps=0.001, momentum=0.01), upsample_cfg=dict(type='deconv', bias=False), use_conv_for_no_stride=True)\n    fpn_cfg = dict(type='SECONDFPN', in_channels=[64, 128, 256], upsample_strides=[1, 2, 4], out_channels=[128, 128, 128])\n    second_fpn = build_neck(fpn_cfg)\n    centerpoint_second_fpn = build_neck(centerpoint_fpn_cfg)\n    input = torch.rand([4, 64, 512, 512])\n    sec_output = second(input)\n    centerpoint_output = centerpoint_second_fpn(sec_output)\n    second_output = second_fpn(sec_output)\n    assert centerpoint_output[0].shape == torch.Size([4, 384, 128, 128])\n    assert second_output[0].shape == torch.Size([4, 384, 256, 256])"
        ]
    },
    {
        "func_name": "test_outdoor_imvoxel_neck",
        "original": "def test_outdoor_imvoxel_neck():\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='OutdoorImVoxelNeck', in_channels=64, out_channels=256)\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 216, 248, 12], device='cuda')\n    outputs = neck(inputs)\n    assert outputs[0].shape == (1, 256, 248, 216)",
        "mutated": [
            "def test_outdoor_imvoxel_neck():\n    if False:\n        i = 10\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='OutdoorImVoxelNeck', in_channels=64, out_channels=256)\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 216, 248, 12], device='cuda')\n    outputs = neck(inputs)\n    assert outputs[0].shape == (1, 256, 248, 216)",
            "def test_outdoor_imvoxel_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='OutdoorImVoxelNeck', in_channels=64, out_channels=256)\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 216, 248, 12], device='cuda')\n    outputs = neck(inputs)\n    assert outputs[0].shape == (1, 256, 248, 216)",
            "def test_outdoor_imvoxel_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='OutdoorImVoxelNeck', in_channels=64, out_channels=256)\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 216, 248, 12], device='cuda')\n    outputs = neck(inputs)\n    assert outputs[0].shape == (1, 256, 248, 216)",
            "def test_outdoor_imvoxel_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='OutdoorImVoxelNeck', in_channels=64, out_channels=256)\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 216, 248, 12], device='cuda')\n    outputs = neck(inputs)\n    assert outputs[0].shape == (1, 256, 248, 216)",
            "def test_outdoor_imvoxel_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='OutdoorImVoxelNeck', in_channels=64, out_channels=256)\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 216, 248, 12], device='cuda')\n    outputs = neck(inputs)\n    assert outputs[0].shape == (1, 256, 248, 216)"
        ]
    },
    {
        "func_name": "test_indoor_imvoxel_neck",
        "original": "def test_indoor_imvoxel_neck():\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='IndoorImVoxelNeck', in_channels=64, out_channels=256, n_blocks=[1, 1, 1])\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 40, 40, 16], device='cuda')\n    outputs = neck(inputs)\n    assert len(outputs) == 3\n    assert outputs[0].shape == (1, 256, 40, 40, 16)\n    assert outputs[1].shape == (1, 256, 20, 20, 8)\n    assert outputs[2].shape == (1, 256, 10, 10, 4)",
        "mutated": [
            "def test_indoor_imvoxel_neck():\n    if False:\n        i = 10\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='IndoorImVoxelNeck', in_channels=64, out_channels=256, n_blocks=[1, 1, 1])\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 40, 40, 16], device='cuda')\n    outputs = neck(inputs)\n    assert len(outputs) == 3\n    assert outputs[0].shape == (1, 256, 40, 40, 16)\n    assert outputs[1].shape == (1, 256, 20, 20, 8)\n    assert outputs[2].shape == (1, 256, 10, 10, 4)",
            "def test_indoor_imvoxel_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='IndoorImVoxelNeck', in_channels=64, out_channels=256, n_blocks=[1, 1, 1])\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 40, 40, 16], device='cuda')\n    outputs = neck(inputs)\n    assert len(outputs) == 3\n    assert outputs[0].shape == (1, 256, 40, 40, 16)\n    assert outputs[1].shape == (1, 256, 20, 20, 8)\n    assert outputs[2].shape == (1, 256, 10, 10, 4)",
            "def test_indoor_imvoxel_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='IndoorImVoxelNeck', in_channels=64, out_channels=256, n_blocks=[1, 1, 1])\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 40, 40, 16], device='cuda')\n    outputs = neck(inputs)\n    assert len(outputs) == 3\n    assert outputs[0].shape == (1, 256, 40, 40, 16)\n    assert outputs[1].shape == (1, 256, 20, 20, 8)\n    assert outputs[2].shape == (1, 256, 10, 10, 4)",
            "def test_indoor_imvoxel_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='IndoorImVoxelNeck', in_channels=64, out_channels=256, n_blocks=[1, 1, 1])\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 40, 40, 16], device='cuda')\n    outputs = neck(inputs)\n    assert len(outputs) == 3\n    assert outputs[0].shape == (1, 256, 40, 40, 16)\n    assert outputs[1].shape == (1, 256, 20, 20, 8)\n    assert outputs[2].shape == (1, 256, 10, 10, 4)",
            "def test_indoor_imvoxel_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not torch.cuda.is_available():\n        pytest.skip('test requires GPU and torch+cuda')\n    neck_cfg = dict(type='IndoorImVoxelNeck', in_channels=64, out_channels=256, n_blocks=[1, 1, 1])\n    neck = build_neck(neck_cfg).cuda()\n    inputs = torch.rand([1, 64, 40, 40, 16], device='cuda')\n    outputs = neck(inputs)\n    assert len(outputs) == 3\n    assert outputs[0].shape == (1, 256, 40, 40, 16)\n    assert outputs[1].shape == (1, 256, 20, 20, 8)\n    assert outputs[2].shape == (1, 256, 10, 10, 4)"
        ]
    },
    {
        "func_name": "test_fp_neck",
        "original": "def test_fp_neck():\n    if not torch.cuda.is_available():\n        pytest.skip()\n    xyzs = [16384, 4096, 1024, 256, 64]\n    feat_channels = [1, 96, 256, 512, 1024]\n    channel_num = 5\n    sa_xyz = [torch.rand(3, xyzs[i], 3) for i in range(channel_num)]\n    sa_features = [torch.rand(3, feat_channels[i], xyzs[i]) for i in range(channel_num)]\n    neck_cfg = dict(type='PointNetFPNeck', fp_channels=((1536, 512, 512), (768, 512, 512), (608, 256, 256), (257, 128, 128)))\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        sa_xyz = [x.cuda() for x in sa_xyz]\n        sa_features = [x.cuda() for x in sa_features]\n        neck.cuda()\n    feats_sa = {'sa_xyz': sa_xyz, 'sa_features': sa_features}\n    outputs = neck(feats_sa)\n    assert outputs['fp_xyz'].cpu().numpy().shape == (3, 16384, 3)\n    assert outputs['fp_features'].detach().cpu().numpy().shape == (3, 128, 16384)",
        "mutated": [
            "def test_fp_neck():\n    if False:\n        i = 10\n    if not torch.cuda.is_available():\n        pytest.skip()\n    xyzs = [16384, 4096, 1024, 256, 64]\n    feat_channels = [1, 96, 256, 512, 1024]\n    channel_num = 5\n    sa_xyz = [torch.rand(3, xyzs[i], 3) for i in range(channel_num)]\n    sa_features = [torch.rand(3, feat_channels[i], xyzs[i]) for i in range(channel_num)]\n    neck_cfg = dict(type='PointNetFPNeck', fp_channels=((1536, 512, 512), (768, 512, 512), (608, 256, 256), (257, 128, 128)))\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        sa_xyz = [x.cuda() for x in sa_xyz]\n        sa_features = [x.cuda() for x in sa_features]\n        neck.cuda()\n    feats_sa = {'sa_xyz': sa_xyz, 'sa_features': sa_features}\n    outputs = neck(feats_sa)\n    assert outputs['fp_xyz'].cpu().numpy().shape == (3, 16384, 3)\n    assert outputs['fp_features'].detach().cpu().numpy().shape == (3, 128, 16384)",
            "def test_fp_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not torch.cuda.is_available():\n        pytest.skip()\n    xyzs = [16384, 4096, 1024, 256, 64]\n    feat_channels = [1, 96, 256, 512, 1024]\n    channel_num = 5\n    sa_xyz = [torch.rand(3, xyzs[i], 3) for i in range(channel_num)]\n    sa_features = [torch.rand(3, feat_channels[i], xyzs[i]) for i in range(channel_num)]\n    neck_cfg = dict(type='PointNetFPNeck', fp_channels=((1536, 512, 512), (768, 512, 512), (608, 256, 256), (257, 128, 128)))\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        sa_xyz = [x.cuda() for x in sa_xyz]\n        sa_features = [x.cuda() for x in sa_features]\n        neck.cuda()\n    feats_sa = {'sa_xyz': sa_xyz, 'sa_features': sa_features}\n    outputs = neck(feats_sa)\n    assert outputs['fp_xyz'].cpu().numpy().shape == (3, 16384, 3)\n    assert outputs['fp_features'].detach().cpu().numpy().shape == (3, 128, 16384)",
            "def test_fp_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not torch.cuda.is_available():\n        pytest.skip()\n    xyzs = [16384, 4096, 1024, 256, 64]\n    feat_channels = [1, 96, 256, 512, 1024]\n    channel_num = 5\n    sa_xyz = [torch.rand(3, xyzs[i], 3) for i in range(channel_num)]\n    sa_features = [torch.rand(3, feat_channels[i], xyzs[i]) for i in range(channel_num)]\n    neck_cfg = dict(type='PointNetFPNeck', fp_channels=((1536, 512, 512), (768, 512, 512), (608, 256, 256), (257, 128, 128)))\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        sa_xyz = [x.cuda() for x in sa_xyz]\n        sa_features = [x.cuda() for x in sa_features]\n        neck.cuda()\n    feats_sa = {'sa_xyz': sa_xyz, 'sa_features': sa_features}\n    outputs = neck(feats_sa)\n    assert outputs['fp_xyz'].cpu().numpy().shape == (3, 16384, 3)\n    assert outputs['fp_features'].detach().cpu().numpy().shape == (3, 128, 16384)",
            "def test_fp_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not torch.cuda.is_available():\n        pytest.skip()\n    xyzs = [16384, 4096, 1024, 256, 64]\n    feat_channels = [1, 96, 256, 512, 1024]\n    channel_num = 5\n    sa_xyz = [torch.rand(3, xyzs[i], 3) for i in range(channel_num)]\n    sa_features = [torch.rand(3, feat_channels[i], xyzs[i]) for i in range(channel_num)]\n    neck_cfg = dict(type='PointNetFPNeck', fp_channels=((1536, 512, 512), (768, 512, 512), (608, 256, 256), (257, 128, 128)))\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        sa_xyz = [x.cuda() for x in sa_xyz]\n        sa_features = [x.cuda() for x in sa_features]\n        neck.cuda()\n    feats_sa = {'sa_xyz': sa_xyz, 'sa_features': sa_features}\n    outputs = neck(feats_sa)\n    assert outputs['fp_xyz'].cpu().numpy().shape == (3, 16384, 3)\n    assert outputs['fp_features'].detach().cpu().numpy().shape == (3, 128, 16384)",
            "def test_fp_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not torch.cuda.is_available():\n        pytest.skip()\n    xyzs = [16384, 4096, 1024, 256, 64]\n    feat_channels = [1, 96, 256, 512, 1024]\n    channel_num = 5\n    sa_xyz = [torch.rand(3, xyzs[i], 3) for i in range(channel_num)]\n    sa_features = [torch.rand(3, feat_channels[i], xyzs[i]) for i in range(channel_num)]\n    neck_cfg = dict(type='PointNetFPNeck', fp_channels=((1536, 512, 512), (768, 512, 512), (608, 256, 256), (257, 128, 128)))\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        sa_xyz = [x.cuda() for x in sa_xyz]\n        sa_features = [x.cuda() for x in sa_features]\n        neck.cuda()\n    feats_sa = {'sa_xyz': sa_xyz, 'sa_features': sa_features}\n    outputs = neck(feats_sa)\n    assert outputs['fp_xyz'].cpu().numpy().shape == (3, 16384, 3)\n    assert outputs['fp_features'].detach().cpu().numpy().shape == (3, 128, 16384)"
        ]
    },
    {
        "func_name": "test_dla_neck",
        "original": "def test_dla_neck():\n    s = 32\n    in_channels = [16, 32, 64, 128, 256, 512]\n    feat_sizes = [s // 2 ** i for i in range(6)]\n    if torch.cuda.is_available():\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32))\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        neck.cuda()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]).cuda() for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)\n    else:\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32), use_dcn=False)\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]) for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)",
        "mutated": [
            "def test_dla_neck():\n    if False:\n        i = 10\n    s = 32\n    in_channels = [16, 32, 64, 128, 256, 512]\n    feat_sizes = [s // 2 ** i for i in range(6)]\n    if torch.cuda.is_available():\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32))\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        neck.cuda()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]).cuda() for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)\n    else:\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32), use_dcn=False)\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]) for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)",
            "def test_dla_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = 32\n    in_channels = [16, 32, 64, 128, 256, 512]\n    feat_sizes = [s // 2 ** i for i in range(6)]\n    if torch.cuda.is_available():\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32))\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        neck.cuda()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]).cuda() for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)\n    else:\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32), use_dcn=False)\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]) for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)",
            "def test_dla_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = 32\n    in_channels = [16, 32, 64, 128, 256, 512]\n    feat_sizes = [s // 2 ** i for i in range(6)]\n    if torch.cuda.is_available():\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32))\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        neck.cuda()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]).cuda() for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)\n    else:\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32), use_dcn=False)\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]) for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)",
            "def test_dla_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = 32\n    in_channels = [16, 32, 64, 128, 256, 512]\n    feat_sizes = [s // 2 ** i for i in range(6)]\n    if torch.cuda.is_available():\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32))\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        neck.cuda()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]).cuda() for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)\n    else:\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32), use_dcn=False)\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]) for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)",
            "def test_dla_neck():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = 32\n    in_channels = [16, 32, 64, 128, 256, 512]\n    feat_sizes = [s // 2 ** i for i in range(6)]\n    if torch.cuda.is_available():\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32))\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        neck.cuda()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]).cuda() for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)\n    else:\n        neck_cfg = dict(type='DLANeck', in_channels=[16, 32, 64, 128, 256, 512], start_level=2, end_level=5, norm_cfg=dict(type='GN', num_groups=32), use_dcn=False)\n        neck = build_neck(neck_cfg)\n        neck.init_weights()\n        feats = [torch.rand(4, in_channels[i], feat_sizes[i], feat_sizes[i]) for i in range(len(in_channels))]\n        outputs = neck(feats)\n        assert outputs[0].shape == (4, 64, 8, 8)"
        ]
    },
    {
        "func_name": "test_lss_view_transformer",
        "original": "def test_lss_view_transformer():\n    feats_image_view = torch.rand(1, 2, 512, 44, 16)\n    rots = torch.tensor([[[1.0, 0.0067, 0.0017], [-0.0019, 0.0194, 0.9998], [0.0067, -0.9998, 0.0194]], [[0.548, -0.0104, 0.8364], [-0.836, 0.025, 0.5481], [-0.0266, -0.9996, 0.005]]]).unsqueeze(0)\n    trans = torch.tensor([[-0.0097, 0.4028, -0.3244], [0.4984, 0.3233, -0.3376]]).unsqueeze(0)\n    intrins = torch.tensor([[[1266.4, 0.0, 816.27], [0.0, 1266.4, 491.51], [0.0, 0.0, 1.0]]]).expand(1, 2, 3, 3)\n    post_rots = torch.tensor([[[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]], [[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]]]).unsqueeze(0)\n    post_trans = torch.tensor([[-32.0, -176.0, 0.0], [-32.0, -176.0, 0.0]]).unsqueeze(0)\n    inputs = (feats_image_view, rots, trans, intrins, post_rots, post_trans)\n    grid_config = {'x': [-51.2, 51.2, 0.8], 'y': [-51.2, 51.2, 0.8], 'z': [-10.0, 10.0, 20.0], 'depth': [1.0, 60.0, 1.0]}\n    neck_cfg = dict(type='LSSViewTransformer', grid_config=grid_config, input_size=(256, 704), downsample=16, in_channels=512, out_channels=64, accelerate=False)\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        inputs = tuple([item.cuda() for item in inputs])\n        neck = neck.cuda()\n    feats_bev = neck(inputs)\n    neck.accelerate = True\n    neck.max_voxel_points = 300\n    feats_bev_acc = neck(inputs)\n    assert feats_bev.shape == (1, 64, 128, 128)\n    assert feats_bev_acc.shape == (1, 64, 128, 128)\n    assert torch.sum((feats_bev - feats_bev_acc).abs() < 0.0001).float() / (64 * 128 * 128) > 0.99",
        "mutated": [
            "def test_lss_view_transformer():\n    if False:\n        i = 10\n    feats_image_view = torch.rand(1, 2, 512, 44, 16)\n    rots = torch.tensor([[[1.0, 0.0067, 0.0017], [-0.0019, 0.0194, 0.9998], [0.0067, -0.9998, 0.0194]], [[0.548, -0.0104, 0.8364], [-0.836, 0.025, 0.5481], [-0.0266, -0.9996, 0.005]]]).unsqueeze(0)\n    trans = torch.tensor([[-0.0097, 0.4028, -0.3244], [0.4984, 0.3233, -0.3376]]).unsqueeze(0)\n    intrins = torch.tensor([[[1266.4, 0.0, 816.27], [0.0, 1266.4, 491.51], [0.0, 0.0, 1.0]]]).expand(1, 2, 3, 3)\n    post_rots = torch.tensor([[[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]], [[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]]]).unsqueeze(0)\n    post_trans = torch.tensor([[-32.0, -176.0, 0.0], [-32.0, -176.0, 0.0]]).unsqueeze(0)\n    inputs = (feats_image_view, rots, trans, intrins, post_rots, post_trans)\n    grid_config = {'x': [-51.2, 51.2, 0.8], 'y': [-51.2, 51.2, 0.8], 'z': [-10.0, 10.0, 20.0], 'depth': [1.0, 60.0, 1.0]}\n    neck_cfg = dict(type='LSSViewTransformer', grid_config=grid_config, input_size=(256, 704), downsample=16, in_channels=512, out_channels=64, accelerate=False)\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        inputs = tuple([item.cuda() for item in inputs])\n        neck = neck.cuda()\n    feats_bev = neck(inputs)\n    neck.accelerate = True\n    neck.max_voxel_points = 300\n    feats_bev_acc = neck(inputs)\n    assert feats_bev.shape == (1, 64, 128, 128)\n    assert feats_bev_acc.shape == (1, 64, 128, 128)\n    assert torch.sum((feats_bev - feats_bev_acc).abs() < 0.0001).float() / (64 * 128 * 128) > 0.99",
            "def test_lss_view_transformer():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    feats_image_view = torch.rand(1, 2, 512, 44, 16)\n    rots = torch.tensor([[[1.0, 0.0067, 0.0017], [-0.0019, 0.0194, 0.9998], [0.0067, -0.9998, 0.0194]], [[0.548, -0.0104, 0.8364], [-0.836, 0.025, 0.5481], [-0.0266, -0.9996, 0.005]]]).unsqueeze(0)\n    trans = torch.tensor([[-0.0097, 0.4028, -0.3244], [0.4984, 0.3233, -0.3376]]).unsqueeze(0)\n    intrins = torch.tensor([[[1266.4, 0.0, 816.27], [0.0, 1266.4, 491.51], [0.0, 0.0, 1.0]]]).expand(1, 2, 3, 3)\n    post_rots = torch.tensor([[[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]], [[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]]]).unsqueeze(0)\n    post_trans = torch.tensor([[-32.0, -176.0, 0.0], [-32.0, -176.0, 0.0]]).unsqueeze(0)\n    inputs = (feats_image_view, rots, trans, intrins, post_rots, post_trans)\n    grid_config = {'x': [-51.2, 51.2, 0.8], 'y': [-51.2, 51.2, 0.8], 'z': [-10.0, 10.0, 20.0], 'depth': [1.0, 60.0, 1.0]}\n    neck_cfg = dict(type='LSSViewTransformer', grid_config=grid_config, input_size=(256, 704), downsample=16, in_channels=512, out_channels=64, accelerate=False)\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        inputs = tuple([item.cuda() for item in inputs])\n        neck = neck.cuda()\n    feats_bev = neck(inputs)\n    neck.accelerate = True\n    neck.max_voxel_points = 300\n    feats_bev_acc = neck(inputs)\n    assert feats_bev.shape == (1, 64, 128, 128)\n    assert feats_bev_acc.shape == (1, 64, 128, 128)\n    assert torch.sum((feats_bev - feats_bev_acc).abs() < 0.0001).float() / (64 * 128 * 128) > 0.99",
            "def test_lss_view_transformer():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    feats_image_view = torch.rand(1, 2, 512, 44, 16)\n    rots = torch.tensor([[[1.0, 0.0067, 0.0017], [-0.0019, 0.0194, 0.9998], [0.0067, -0.9998, 0.0194]], [[0.548, -0.0104, 0.8364], [-0.836, 0.025, 0.5481], [-0.0266, -0.9996, 0.005]]]).unsqueeze(0)\n    trans = torch.tensor([[-0.0097, 0.4028, -0.3244], [0.4984, 0.3233, -0.3376]]).unsqueeze(0)\n    intrins = torch.tensor([[[1266.4, 0.0, 816.27], [0.0, 1266.4, 491.51], [0.0, 0.0, 1.0]]]).expand(1, 2, 3, 3)\n    post_rots = torch.tensor([[[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]], [[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]]]).unsqueeze(0)\n    post_trans = torch.tensor([[-32.0, -176.0, 0.0], [-32.0, -176.0, 0.0]]).unsqueeze(0)\n    inputs = (feats_image_view, rots, trans, intrins, post_rots, post_trans)\n    grid_config = {'x': [-51.2, 51.2, 0.8], 'y': [-51.2, 51.2, 0.8], 'z': [-10.0, 10.0, 20.0], 'depth': [1.0, 60.0, 1.0]}\n    neck_cfg = dict(type='LSSViewTransformer', grid_config=grid_config, input_size=(256, 704), downsample=16, in_channels=512, out_channels=64, accelerate=False)\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        inputs = tuple([item.cuda() for item in inputs])\n        neck = neck.cuda()\n    feats_bev = neck(inputs)\n    neck.accelerate = True\n    neck.max_voxel_points = 300\n    feats_bev_acc = neck(inputs)\n    assert feats_bev.shape == (1, 64, 128, 128)\n    assert feats_bev_acc.shape == (1, 64, 128, 128)\n    assert torch.sum((feats_bev - feats_bev_acc).abs() < 0.0001).float() / (64 * 128 * 128) > 0.99",
            "def test_lss_view_transformer():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    feats_image_view = torch.rand(1, 2, 512, 44, 16)\n    rots = torch.tensor([[[1.0, 0.0067, 0.0017], [-0.0019, 0.0194, 0.9998], [0.0067, -0.9998, 0.0194]], [[0.548, -0.0104, 0.8364], [-0.836, 0.025, 0.5481], [-0.0266, -0.9996, 0.005]]]).unsqueeze(0)\n    trans = torch.tensor([[-0.0097, 0.4028, -0.3244], [0.4984, 0.3233, -0.3376]]).unsqueeze(0)\n    intrins = torch.tensor([[[1266.4, 0.0, 816.27], [0.0, 1266.4, 491.51], [0.0, 0.0, 1.0]]]).expand(1, 2, 3, 3)\n    post_rots = torch.tensor([[[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]], [[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]]]).unsqueeze(0)\n    post_trans = torch.tensor([[-32.0, -176.0, 0.0], [-32.0, -176.0, 0.0]]).unsqueeze(0)\n    inputs = (feats_image_view, rots, trans, intrins, post_rots, post_trans)\n    grid_config = {'x': [-51.2, 51.2, 0.8], 'y': [-51.2, 51.2, 0.8], 'z': [-10.0, 10.0, 20.0], 'depth': [1.0, 60.0, 1.0]}\n    neck_cfg = dict(type='LSSViewTransformer', grid_config=grid_config, input_size=(256, 704), downsample=16, in_channels=512, out_channels=64, accelerate=False)\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        inputs = tuple([item.cuda() for item in inputs])\n        neck = neck.cuda()\n    feats_bev = neck(inputs)\n    neck.accelerate = True\n    neck.max_voxel_points = 300\n    feats_bev_acc = neck(inputs)\n    assert feats_bev.shape == (1, 64, 128, 128)\n    assert feats_bev_acc.shape == (1, 64, 128, 128)\n    assert torch.sum((feats_bev - feats_bev_acc).abs() < 0.0001).float() / (64 * 128 * 128) > 0.99",
            "def test_lss_view_transformer():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    feats_image_view = torch.rand(1, 2, 512, 44, 16)\n    rots = torch.tensor([[[1.0, 0.0067, 0.0017], [-0.0019, 0.0194, 0.9998], [0.0067, -0.9998, 0.0194]], [[0.548, -0.0104, 0.8364], [-0.836, 0.025, 0.5481], [-0.0266, -0.9996, 0.005]]]).unsqueeze(0)\n    trans = torch.tensor([[-0.0097, 0.4028, -0.3244], [0.4984, 0.3233, -0.3376]]).unsqueeze(0)\n    intrins = torch.tensor([[[1266.4, 0.0, 816.27], [0.0, 1266.4, 491.51], [0.0, 0.0, 1.0]]]).expand(1, 2, 3, 3)\n    post_rots = torch.tensor([[[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]], [[0.48, 0.0, 0.0], [0.0, 0.48, 0.0], [0.0, 0.0, 1.0]]]).unsqueeze(0)\n    post_trans = torch.tensor([[-32.0, -176.0, 0.0], [-32.0, -176.0, 0.0]]).unsqueeze(0)\n    inputs = (feats_image_view, rots, trans, intrins, post_rots, post_trans)\n    grid_config = {'x': [-51.2, 51.2, 0.8], 'y': [-51.2, 51.2, 0.8], 'z': [-10.0, 10.0, 20.0], 'depth': [1.0, 60.0, 1.0]}\n    neck_cfg = dict(type='LSSViewTransformer', grid_config=grid_config, input_size=(256, 704), downsample=16, in_channels=512, out_channels=64, accelerate=False)\n    neck = build_neck(neck_cfg)\n    neck.init_weights()\n    if torch.cuda.is_available():\n        inputs = tuple([item.cuda() for item in inputs])\n        neck = neck.cuda()\n    feats_bev = neck(inputs)\n    neck.accelerate = True\n    neck.max_voxel_points = 300\n    feats_bev_acc = neck(inputs)\n    assert feats_bev.shape == (1, 64, 128, 128)\n    assert feats_bev_acc.shape == (1, 64, 128, 128)\n    assert torch.sum((feats_bev - feats_bev_acc).abs() < 0.0001).float() / (64 * 128 * 128) > 0.99"
        ]
    }
]