[
    {
        "func_name": "test_basic_newton_finder",
        "original": "def test_basic_newton_finder(self):\n    \"\"\"Tests the Newton root finder recovers the volatility on a few cases.\"\"\"\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
        "mutated": [
            "def test_basic_newton_finder(self):\n    if False:\n        i = 10\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_basic_newton_finder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_basic_newton_finder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_basic_newton_finder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_basic_newton_finder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)"
        ]
    },
    {
        "func_name": "test_basic_radiocic_newton_combination_finder",
        "original": "def test_basic_radiocic_newton_combination_finder(self):\n    \"\"\"Tests the Newton root finder recovers the volatility on a few cases.\"\"\"\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
        "mutated": [
            "def test_basic_radiocic_newton_combination_finder(self):\n    if False:\n        i = 10\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_basic_radiocic_newton_combination_finder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_basic_radiocic_newton_combination_finder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_basic_radiocic_newton_combination_finder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_basic_radiocic_newton_combination_finder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.38292492, 0.19061012, 0.38292492, 0.09530506, 0.27632639, 0.52049988])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)"
        ]
    },
    {
        "func_name": "test_bachelier_positive_underlying",
        "original": "def test_bachelier_positive_underlying(self):\n    \"\"\"Tests the Newton root finder recovers the volatility on Bachelier Model.\n\n    This are the cases with positive underlying and strike.\n    \"\"\"\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.0833155, 0.3989423, 0.1977966, 0.2820948, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
        "mutated": [
            "def test_bachelier_positive_underlying(self):\n    if False:\n        i = 10\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    This are the cases with positive underlying and strike.\\n    '\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.0833155, 0.3989423, 0.1977966, 0.2820948, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_positive_underlying(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    This are the cases with positive underlying and strike.\\n    '\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.0833155, 0.3989423, 0.1977966, 0.2820948, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_positive_underlying(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    This are the cases with positive underlying and strike.\\n    '\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.0833155, 0.3989423, 0.1977966, 0.2820948, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_positive_underlying(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    This are the cases with positive underlying and strike.\\n    '\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.0833155, 0.3989423, 0.1977966, 0.2820948, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_positive_underlying(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    This are the cases with positive underlying and strike.\\n    '\n    forwards = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.0, 2.0, 1.0, 0.5, 1.0, 1.0])\n    expiries = np.array([1.0, 1.0, 1.0, 1.0, 0.5, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 0.5, 2.0, 0.5, 1.5, 1.5])\n    is_call_options = np.array([True, True, False, False, True, True])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.0833155, 0.3989423, 0.1977966, 0.2820948, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)"
        ]
    },
    {
        "func_name": "test_bachelier_negative_underlying",
        "original": "def test_bachelier_negative_underlying(self):\n    \"\"\"Tests the Newton root finder recovers the volatility on Bachelier Model.\n\n    These are the cases with negative underlying and strike.\n    \"\"\"\n    forwards = np.array([-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -0.5])\n    expiries = np.array([1.0, 1.0, 1.0, 2.0, 0.5, 1.0, 1.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, True, True, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.0084907, 0.0833155, 0.3989423, 0.5641896, 0.2820948, 0.3989423, 0.6977965])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
        "mutated": [
            "def test_bachelier_negative_underlying(self):\n    if False:\n        i = 10\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases with negative underlying and strike.\\n    '\n    forwards = np.array([-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -0.5])\n    expiries = np.array([1.0, 1.0, 1.0, 2.0, 0.5, 1.0, 1.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, True, True, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.0084907, 0.0833155, 0.3989423, 0.5641896, 0.2820948, 0.3989423, 0.6977965])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_negative_underlying(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases with negative underlying and strike.\\n    '\n    forwards = np.array([-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -0.5])\n    expiries = np.array([1.0, 1.0, 1.0, 2.0, 0.5, 1.0, 1.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, True, True, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.0084907, 0.0833155, 0.3989423, 0.5641896, 0.2820948, 0.3989423, 0.6977965])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_negative_underlying(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases with negative underlying and strike.\\n    '\n    forwards = np.array([-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -0.5])\n    expiries = np.array([1.0, 1.0, 1.0, 2.0, 0.5, 1.0, 1.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, True, True, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.0084907, 0.0833155, 0.3989423, 0.5641896, 0.2820948, 0.3989423, 0.6977965])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_negative_underlying(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases with negative underlying and strike.\\n    '\n    forwards = np.array([-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -0.5])\n    expiries = np.array([1.0, 1.0, 1.0, 2.0, 0.5, 1.0, 1.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, True, True, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.0084907, 0.0833155, 0.3989423, 0.5641896, 0.2820948, 0.3989423, 0.6977965])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_negative_underlying(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases with negative underlying and strike.\\n    '\n    forwards = np.array([-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, -1.0, -1.0, -1.0, -0.5])\n    expiries = np.array([1.0, 1.0, 1.0, 2.0, 0.5, 1.0, 1.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, True, True, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.0084907, 0.0833155, 0.3989423, 0.5641896, 0.2820948, 0.3989423, 0.6977965])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)"
        ]
    },
    {
        "func_name": "test_bachelier_at_the_money",
        "original": "def test_bachelier_at_the_money(self):\n    \"\"\"Tests the Newton root finder recovers the volatility on Bachelier Model.\n\n    These are the cases for at the money (forward = strike).\n    \"\"\"\n    forwards = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    expiries = np.array([1.0, 1.0, 2.0, 1.0, 1.0, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 1.0, 1.0, 2.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, False, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.3989423, 0.5641896, 0.3989423, 0.3989423, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    print('converged', converged)\n    print('failed', failed)\n    print('implied_vols', implied_vols)\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
        "mutated": [
            "def test_bachelier_at_the_money(self):\n    if False:\n        i = 10\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases for at the money (forward = strike).\\n    '\n    forwards = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    expiries = np.array([1.0, 1.0, 2.0, 1.0, 1.0, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 1.0, 1.0, 2.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, False, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.3989423, 0.5641896, 0.3989423, 0.3989423, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    print('converged', converged)\n    print('failed', failed)\n    print('implied_vols', implied_vols)\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_at_the_money(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases for at the money (forward = strike).\\n    '\n    forwards = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    expiries = np.array([1.0, 1.0, 2.0, 1.0, 1.0, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 1.0, 1.0, 2.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, False, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.3989423, 0.5641896, 0.3989423, 0.3989423, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    print('converged', converged)\n    print('failed', failed)\n    print('implied_vols', implied_vols)\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_at_the_money(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases for at the money (forward = strike).\\n    '\n    forwards = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    expiries = np.array([1.0, 1.0, 2.0, 1.0, 1.0, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 1.0, 1.0, 2.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, False, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.3989423, 0.5641896, 0.3989423, 0.3989423, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    print('converged', converged)\n    print('failed', failed)\n    print('implied_vols', implied_vols)\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_at_the_money(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases for at the money (forward = strike).\\n    '\n    forwards = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    expiries = np.array([1.0, 1.0, 2.0, 1.0, 1.0, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 1.0, 1.0, 2.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, False, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.3989423, 0.5641896, 0.3989423, 0.3989423, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    print('converged', converged)\n    print('failed', failed)\n    print('implied_vols', implied_vols)\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)",
            "def test_bachelier_at_the_money(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the Newton root finder recovers the volatility on Bachelier Model.\\n\\n    These are the cases for at the money (forward = strike).\\n    '\n    forwards = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    strikes = np.array([1.0, 0.0, -1.0, 1.0, 0.0, -1.0])\n    expiries = np.array([1.0, 1.0, 2.0, 1.0, 1.0, 2.0])\n    discounts = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    init_vols = np.array([2.0, 1.0, 1.0, 2.0, 1.0, 1.0])\n    is_call_options = np.array([True, True, True, False, False, False])\n    volatilities = np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\n    prices = np.array([0.3989423, 0.3989423, 0.5641896, 0.3989423, 0.3989423, 0.5641896])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, initial_volatilities=init_vols, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100))\n    print('converged', converged)\n    print('failed', failed)\n    print('implied_vols', implied_vols)\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-06)"
        ]
    },
    {
        "func_name": "test_implied_vol_validate_raises",
        "original": "@parameterized.named_parameters(('call_lower', 0.0, 1.0, 1.0, 1.0, 1.0), ('call_upper', 1.0, 1.0, 1.0, 1.0, 1.0), ('put_lower', 1.0, 1.0, 1.0, 1.0, -1.0), ('put_upper', 0.0, 1.0, 1.0, 1.0, -1.0))\ndef test_implied_vol_validate_raises(self, price, forward, strike, expiry, option_sign):\n    \"\"\"Tests validation errors raised where BS model assumptions violated.\"\"\"\n    prices = np.array([price])\n    forwards = np.array([forward])\n    strikes = np.array([strike])\n    expiries = np.array([expiry])\n    is_call_options = np.array([option_sign > 0])\n    discounts = np.array([1.0])\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, validate_args=True, is_call_options=is_call_options))",
        "mutated": [
            "@parameterized.named_parameters(('call_lower', 0.0, 1.0, 1.0, 1.0, 1.0), ('call_upper', 1.0, 1.0, 1.0, 1.0, 1.0), ('put_lower', 1.0, 1.0, 1.0, 1.0, -1.0), ('put_upper', 0.0, 1.0, 1.0, 1.0, -1.0))\ndef test_implied_vol_validate_raises(self, price, forward, strike, expiry, option_sign):\n    if False:\n        i = 10\n    'Tests validation errors raised where BS model assumptions violated.'\n    prices = np.array([price])\n    forwards = np.array([forward])\n    strikes = np.array([strike])\n    expiries = np.array([expiry])\n    is_call_options = np.array([option_sign > 0])\n    discounts = np.array([1.0])\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, validate_args=True, is_call_options=is_call_options))",
            "@parameterized.named_parameters(('call_lower', 0.0, 1.0, 1.0, 1.0, 1.0), ('call_upper', 1.0, 1.0, 1.0, 1.0, 1.0), ('put_lower', 1.0, 1.0, 1.0, 1.0, -1.0), ('put_upper', 0.0, 1.0, 1.0, 1.0, -1.0))\ndef test_implied_vol_validate_raises(self, price, forward, strike, expiry, option_sign):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests validation errors raised where BS model assumptions violated.'\n    prices = np.array([price])\n    forwards = np.array([forward])\n    strikes = np.array([strike])\n    expiries = np.array([expiry])\n    is_call_options = np.array([option_sign > 0])\n    discounts = np.array([1.0])\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, validate_args=True, is_call_options=is_call_options))",
            "@parameterized.named_parameters(('call_lower', 0.0, 1.0, 1.0, 1.0, 1.0), ('call_upper', 1.0, 1.0, 1.0, 1.0, 1.0), ('put_lower', 1.0, 1.0, 1.0, 1.0, -1.0), ('put_upper', 0.0, 1.0, 1.0, 1.0, -1.0))\ndef test_implied_vol_validate_raises(self, price, forward, strike, expiry, option_sign):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests validation errors raised where BS model assumptions violated.'\n    prices = np.array([price])\n    forwards = np.array([forward])\n    strikes = np.array([strike])\n    expiries = np.array([expiry])\n    is_call_options = np.array([option_sign > 0])\n    discounts = np.array([1.0])\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, validate_args=True, is_call_options=is_call_options))",
            "@parameterized.named_parameters(('call_lower', 0.0, 1.0, 1.0, 1.0, 1.0), ('call_upper', 1.0, 1.0, 1.0, 1.0, 1.0), ('put_lower', 1.0, 1.0, 1.0, 1.0, -1.0), ('put_upper', 0.0, 1.0, 1.0, 1.0, -1.0))\ndef test_implied_vol_validate_raises(self, price, forward, strike, expiry, option_sign):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests validation errors raised where BS model assumptions violated.'\n    prices = np.array([price])\n    forwards = np.array([forward])\n    strikes = np.array([strike])\n    expiries = np.array([expiry])\n    is_call_options = np.array([option_sign > 0])\n    discounts = np.array([1.0])\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, validate_args=True, is_call_options=is_call_options))",
            "@parameterized.named_parameters(('call_lower', 0.0, 1.0, 1.0, 1.0, 1.0), ('call_upper', 1.0, 1.0, 1.0, 1.0, 1.0), ('put_lower', 1.0, 1.0, 1.0, 1.0, -1.0), ('put_upper', 0.0, 1.0, 1.0, 1.0, -1.0))\ndef test_implied_vol_validate_raises(self, price, forward, strike, expiry, option_sign):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests validation errors raised where BS model assumptions violated.'\n    prices = np.array([price])\n    forwards = np.array([forward])\n    strikes = np.array([strike])\n    expiries = np.array([expiry])\n    is_call_options = np.array([option_sign > 0])\n    discounts = np.array([1.0])\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, validate_args=True, is_call_options=is_call_options))"
        ]
    },
    {
        "func_name": "test_implied_vol_extensive",
        "original": "def test_implied_vol_extensive(self):\n    np.random.seed(135)\n    num_examples = 1000\n    expiries = np.linspace(0.8, 1.2, num_examples)\n    rates = np.linspace(0.03, 0.08, num_examples)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.ones(num_examples)\n    forwards = spots / discount_factors\n    strikes = np.linspace(0.8, 1.2, num_examples)\n    volatilities = np.ones_like(forwards)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
        "mutated": [
            "def test_implied_vol_extensive(self):\n    if False:\n        i = 10\n    np.random.seed(135)\n    num_examples = 1000\n    expiries = np.linspace(0.8, 1.2, num_examples)\n    rates = np.linspace(0.03, 0.08, num_examples)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.ones(num_examples)\n    forwards = spots / discount_factors\n    strikes = np.linspace(0.8, 1.2, num_examples)\n    volatilities = np.ones_like(forwards)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_implied_vol_extensive(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(135)\n    num_examples = 1000\n    expiries = np.linspace(0.8, 1.2, num_examples)\n    rates = np.linspace(0.03, 0.08, num_examples)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.ones(num_examples)\n    forwards = spots / discount_factors\n    strikes = np.linspace(0.8, 1.2, num_examples)\n    volatilities = np.ones_like(forwards)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_implied_vol_extensive(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(135)\n    num_examples = 1000\n    expiries = np.linspace(0.8, 1.2, num_examples)\n    rates = np.linspace(0.03, 0.08, num_examples)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.ones(num_examples)\n    forwards = spots / discount_factors\n    strikes = np.linspace(0.8, 1.2, num_examples)\n    volatilities = np.ones_like(forwards)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_implied_vol_extensive(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(135)\n    num_examples = 1000\n    expiries = np.linspace(0.8, 1.2, num_examples)\n    rates = np.linspace(0.03, 0.08, num_examples)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.ones(num_examples)\n    forwards = spots / discount_factors\n    strikes = np.linspace(0.8, 1.2, num_examples)\n    volatilities = np.ones_like(forwards)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_implied_vol_extensive(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(135)\n    num_examples = 1000\n    expiries = np.linspace(0.8, 1.2, num_examples)\n    rates = np.linspace(0.03, 0.08, num_examples)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.ones(num_examples)\n    forwards = spots / discount_factors\n    strikes = np.linspace(0.8, 1.2, num_examples)\n    volatilities = np.ones_like(forwards)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)"
        ]
    },
    {
        "func_name": "test_discount_factor_correctness",
        "original": "def test_discount_factor_correctness(self):\n    dtype = np.float64\n    expiries = np.array([1.0], dtype=dtype)\n    rates = np.array([0.05], dtype=dtype)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.array([1.0], dtype=dtype)\n    strikes = np.array([0.9], dtype=dtype)\n    volatilities = np.array([0.13], dtype=dtype)\n    is_call_options = True\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
        "mutated": [
            "def test_discount_factor_correctness(self):\n    if False:\n        i = 10\n    dtype = np.float64\n    expiries = np.array([1.0], dtype=dtype)\n    rates = np.array([0.05], dtype=dtype)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.array([1.0], dtype=dtype)\n    strikes = np.array([0.9], dtype=dtype)\n    volatilities = np.array([0.13], dtype=dtype)\n    is_call_options = True\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_discount_factor_correctness(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dtype = np.float64\n    expiries = np.array([1.0], dtype=dtype)\n    rates = np.array([0.05], dtype=dtype)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.array([1.0], dtype=dtype)\n    strikes = np.array([0.9], dtype=dtype)\n    volatilities = np.array([0.13], dtype=dtype)\n    is_call_options = True\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_discount_factor_correctness(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dtype = np.float64\n    expiries = np.array([1.0], dtype=dtype)\n    rates = np.array([0.05], dtype=dtype)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.array([1.0], dtype=dtype)\n    strikes = np.array([0.9], dtype=dtype)\n    volatilities = np.array([0.13], dtype=dtype)\n    is_call_options = True\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_discount_factor_correctness(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dtype = np.float64\n    expiries = np.array([1.0], dtype=dtype)\n    rates = np.array([0.05], dtype=dtype)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.array([1.0], dtype=dtype)\n    strikes = np.array([0.9], dtype=dtype)\n    volatilities = np.array([0.13], dtype=dtype)\n    is_call_options = True\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_discount_factor_correctness(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dtype = np.float64\n    expiries = np.array([1.0], dtype=dtype)\n    rates = np.array([0.05], dtype=dtype)\n    discount_factors = np.exp(-rates * expiries)\n    spots = np.array([1.0], dtype=dtype)\n    strikes = np.array([0.9], dtype=dtype)\n    volatilities = np.array([0.13], dtype=dtype)\n    is_call_options = True\n    prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, is_call_options=is_call_options, discount_factors=discount_factors, dtype=tf.float64))\n    implied_vols = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options, dtype=tf.float64, max_iterations=1000, tolerance=1e-08))[0]\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)"
        ]
    },
    {
        "func_name": "test_bachelier_tricky",
        "original": "def test_bachelier_tricky(self):\n    \"\"\"Tests the Newton root finder recovers the volatility on a few cases.\"\"\"\n    forwards = np.array([0.00982430235191995])\n    strikes = np.array([0.00982430235191995])\n    expiries = np.array([0.5])\n    discounts = np.array([1.0])\n    is_call_options = np.array([True])\n    volatilities = np.array([0.01])\n    prices = np.array([0.002820947917738782])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100, dtype=np.float64))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
        "mutated": [
            "def test_bachelier_tricky(self):\n    if False:\n        i = 10\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([0.00982430235191995])\n    strikes = np.array([0.00982430235191995])\n    expiries = np.array([0.5])\n    discounts = np.array([1.0])\n    is_call_options = np.array([True])\n    volatilities = np.array([0.01])\n    prices = np.array([0.002820947917738782])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100, dtype=np.float64))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_bachelier_tricky(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([0.00982430235191995])\n    strikes = np.array([0.00982430235191995])\n    expiries = np.array([0.5])\n    discounts = np.array([1.0])\n    is_call_options = np.array([True])\n    volatilities = np.array([0.01])\n    prices = np.array([0.002820947917738782])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100, dtype=np.float64))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_bachelier_tricky(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([0.00982430235191995])\n    strikes = np.array([0.00982430235191995])\n    expiries = np.array([0.5])\n    discounts = np.array([1.0])\n    is_call_options = np.array([True])\n    volatilities = np.array([0.01])\n    prices = np.array([0.002820947917738782])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100, dtype=np.float64))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_bachelier_tricky(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([0.00982430235191995])\n    strikes = np.array([0.00982430235191995])\n    expiries = np.array([0.5])\n    discounts = np.array([1.0])\n    is_call_options = np.array([True])\n    volatilities = np.array([0.01])\n    prices = np.array([0.002820947917738782])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100, dtype=np.float64))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)",
            "def test_bachelier_tricky(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the Newton root finder recovers the volatility on a few cases.'\n    forwards = np.array([0.00982430235191995])\n    strikes = np.array([0.00982430235191995])\n    expiries = np.array([0.5])\n    discounts = np.array([1.0])\n    is_call_options = np.array([True])\n    volatilities = np.array([0.01])\n    prices = np.array([0.002820947917738782])\n    (implied_vols, converged, failed) = self.evaluate(tff.black_scholes.implied_vol_newton(prices=prices, strikes=strikes, expiries=expiries, forwards=forwards, discount_factors=discounts, is_call_options=is_call_options, underlying_distribution=ImpliedVolUnderlyingDistribution.NORMAL, max_iterations=100, dtype=np.float64))\n    self.assertTrue(np.all(converged))\n    self.assertFalse(np.any(failed))\n    self.assertArrayNear(volatilities, implied_vols, 1e-07)"
        ]
    }
]