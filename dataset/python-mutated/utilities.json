[
    {
        "func_name": "regressor_index",
        "original": "def regressor_index(m, name):\n    \"\"\"Given the name of a regressor, return its (column) index in the `beta` matrix.\n\n    Parameters\n    ----------\n    m: Prophet model object, after fitting.\n    name: Name of the regressor, as passed into the `add_regressor` function.\n\n    Returns\n    -------\n    The column index of the regressor in the `beta` matrix.\n    \"\"\"\n    return np.extract(m.train_component_cols[name] == 1, m.train_component_cols.index)[0]",
        "mutated": [
            "def regressor_index(m, name):\n    if False:\n        i = 10\n    'Given the name of a regressor, return its (column) index in the `beta` matrix.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n    name: Name of the regressor, as passed into the `add_regressor` function.\\n\\n    Returns\\n    -------\\n    The column index of the regressor in the `beta` matrix.\\n    '\n    return np.extract(m.train_component_cols[name] == 1, m.train_component_cols.index)[0]",
            "def regressor_index(m, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Given the name of a regressor, return its (column) index in the `beta` matrix.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n    name: Name of the regressor, as passed into the `add_regressor` function.\\n\\n    Returns\\n    -------\\n    The column index of the regressor in the `beta` matrix.\\n    '\n    return np.extract(m.train_component_cols[name] == 1, m.train_component_cols.index)[0]",
            "def regressor_index(m, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Given the name of a regressor, return its (column) index in the `beta` matrix.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n    name: Name of the regressor, as passed into the `add_regressor` function.\\n\\n    Returns\\n    -------\\n    The column index of the regressor in the `beta` matrix.\\n    '\n    return np.extract(m.train_component_cols[name] == 1, m.train_component_cols.index)[0]",
            "def regressor_index(m, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Given the name of a regressor, return its (column) index in the `beta` matrix.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n    name: Name of the regressor, as passed into the `add_regressor` function.\\n\\n    Returns\\n    -------\\n    The column index of the regressor in the `beta` matrix.\\n    '\n    return np.extract(m.train_component_cols[name] == 1, m.train_component_cols.index)[0]",
            "def regressor_index(m, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Given the name of a regressor, return its (column) index in the `beta` matrix.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n    name: Name of the regressor, as passed into the `add_regressor` function.\\n\\n    Returns\\n    -------\\n    The column index of the regressor in the `beta` matrix.\\n    '\n    return np.extract(m.train_component_cols[name] == 1, m.train_component_cols.index)[0]"
        ]
    },
    {
        "func_name": "regressor_coefficients",
        "original": "def regressor_coefficients(m):\n    \"\"\"Summarise the coefficients of the extra regressors used in the model.\n\n    For additive regressors, the coefficient represents the incremental impact\n    on `y` of a unit increase in the regressor. For multiplicative regressors,\n    the incremental impact is equal to `trend(t)` multiplied by the coefficient.\n\n    Coefficients are measured on the original scale of the training data.\n\n    Parameters\n    ----------\n    m: Prophet model object, after fitting.\n\n    Returns\n    -------\n    pd.DataFrame containing:\n    - `regressor`: Name of the regressor\n    - `regressor_mode`: Whether the regressor has an additive or multiplicative\n        effect on `y`.\n    - `center`: The mean of the regressor if it was standardized. Otherwise 0.\n    - `coef_lower`: Lower bound for the coefficient, estimated from the MCMC samples.\n        Only different to `coef` if `mcmc_samples > 0`.\n    - `coef`: Expected value of the coefficient.\n    - `coef_upper`: Upper bound for the coefficient, estimated from MCMC samples.\n        Only to different to `coef` if `mcmc_samples > 0`.\n    \"\"\"\n    assert len(m.extra_regressors) > 0, 'No extra regressors found.'\n    coefs = []\n    for (regressor, params) in m.extra_regressors.items():\n        beta = m.params['beta'][:, regressor_index(m, regressor)]\n        if params['mode'] == 'additive':\n            coef = beta * m.y_scale / params['std']\n        else:\n            coef = beta / params['std']\n        percentiles = [(1 - m.interval_width) / 2, 1 - (1 - m.interval_width) / 2]\n        coef_bounds = np.quantile(coef, q=percentiles)\n        record = {'regressor': regressor, 'regressor_mode': params['mode'], 'center': params['mu'], 'coef_lower': coef_bounds[0], 'coef': np.mean(coef), 'coef_upper': coef_bounds[1]}\n        coefs.append(record)\n    return pd.DataFrame(coefs)",
        "mutated": [
            "def regressor_coefficients(m):\n    if False:\n        i = 10\n    'Summarise the coefficients of the extra regressors used in the model.\\n\\n    For additive regressors, the coefficient represents the incremental impact\\n    on `y` of a unit increase in the regressor. For multiplicative regressors,\\n    the incremental impact is equal to `trend(t)` multiplied by the coefficient.\\n\\n    Coefficients are measured on the original scale of the training data.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n\\n    Returns\\n    -------\\n    pd.DataFrame containing:\\n    - `regressor`: Name of the regressor\\n    - `regressor_mode`: Whether the regressor has an additive or multiplicative\\n        effect on `y`.\\n    - `center`: The mean of the regressor if it was standardized. Otherwise 0.\\n    - `coef_lower`: Lower bound for the coefficient, estimated from the MCMC samples.\\n        Only different to `coef` if `mcmc_samples > 0`.\\n    - `coef`: Expected value of the coefficient.\\n    - `coef_upper`: Upper bound for the coefficient, estimated from MCMC samples.\\n        Only to different to `coef` if `mcmc_samples > 0`.\\n    '\n    assert len(m.extra_regressors) > 0, 'No extra regressors found.'\n    coefs = []\n    for (regressor, params) in m.extra_regressors.items():\n        beta = m.params['beta'][:, regressor_index(m, regressor)]\n        if params['mode'] == 'additive':\n            coef = beta * m.y_scale / params['std']\n        else:\n            coef = beta / params['std']\n        percentiles = [(1 - m.interval_width) / 2, 1 - (1 - m.interval_width) / 2]\n        coef_bounds = np.quantile(coef, q=percentiles)\n        record = {'regressor': regressor, 'regressor_mode': params['mode'], 'center': params['mu'], 'coef_lower': coef_bounds[0], 'coef': np.mean(coef), 'coef_upper': coef_bounds[1]}\n        coefs.append(record)\n    return pd.DataFrame(coefs)",
            "def regressor_coefficients(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Summarise the coefficients of the extra regressors used in the model.\\n\\n    For additive regressors, the coefficient represents the incremental impact\\n    on `y` of a unit increase in the regressor. For multiplicative regressors,\\n    the incremental impact is equal to `trend(t)` multiplied by the coefficient.\\n\\n    Coefficients are measured on the original scale of the training data.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n\\n    Returns\\n    -------\\n    pd.DataFrame containing:\\n    - `regressor`: Name of the regressor\\n    - `regressor_mode`: Whether the regressor has an additive or multiplicative\\n        effect on `y`.\\n    - `center`: The mean of the regressor if it was standardized. Otherwise 0.\\n    - `coef_lower`: Lower bound for the coefficient, estimated from the MCMC samples.\\n        Only different to `coef` if `mcmc_samples > 0`.\\n    - `coef`: Expected value of the coefficient.\\n    - `coef_upper`: Upper bound for the coefficient, estimated from MCMC samples.\\n        Only to different to `coef` if `mcmc_samples > 0`.\\n    '\n    assert len(m.extra_regressors) > 0, 'No extra regressors found.'\n    coefs = []\n    for (regressor, params) in m.extra_regressors.items():\n        beta = m.params['beta'][:, regressor_index(m, regressor)]\n        if params['mode'] == 'additive':\n            coef = beta * m.y_scale / params['std']\n        else:\n            coef = beta / params['std']\n        percentiles = [(1 - m.interval_width) / 2, 1 - (1 - m.interval_width) / 2]\n        coef_bounds = np.quantile(coef, q=percentiles)\n        record = {'regressor': regressor, 'regressor_mode': params['mode'], 'center': params['mu'], 'coef_lower': coef_bounds[0], 'coef': np.mean(coef), 'coef_upper': coef_bounds[1]}\n        coefs.append(record)\n    return pd.DataFrame(coefs)",
            "def regressor_coefficients(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Summarise the coefficients of the extra regressors used in the model.\\n\\n    For additive regressors, the coefficient represents the incremental impact\\n    on `y` of a unit increase in the regressor. For multiplicative regressors,\\n    the incremental impact is equal to `trend(t)` multiplied by the coefficient.\\n\\n    Coefficients are measured on the original scale of the training data.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n\\n    Returns\\n    -------\\n    pd.DataFrame containing:\\n    - `regressor`: Name of the regressor\\n    - `regressor_mode`: Whether the regressor has an additive or multiplicative\\n        effect on `y`.\\n    - `center`: The mean of the regressor if it was standardized. Otherwise 0.\\n    - `coef_lower`: Lower bound for the coefficient, estimated from the MCMC samples.\\n        Only different to `coef` if `mcmc_samples > 0`.\\n    - `coef`: Expected value of the coefficient.\\n    - `coef_upper`: Upper bound for the coefficient, estimated from MCMC samples.\\n        Only to different to `coef` if `mcmc_samples > 0`.\\n    '\n    assert len(m.extra_regressors) > 0, 'No extra regressors found.'\n    coefs = []\n    for (regressor, params) in m.extra_regressors.items():\n        beta = m.params['beta'][:, regressor_index(m, regressor)]\n        if params['mode'] == 'additive':\n            coef = beta * m.y_scale / params['std']\n        else:\n            coef = beta / params['std']\n        percentiles = [(1 - m.interval_width) / 2, 1 - (1 - m.interval_width) / 2]\n        coef_bounds = np.quantile(coef, q=percentiles)\n        record = {'regressor': regressor, 'regressor_mode': params['mode'], 'center': params['mu'], 'coef_lower': coef_bounds[0], 'coef': np.mean(coef), 'coef_upper': coef_bounds[1]}\n        coefs.append(record)\n    return pd.DataFrame(coefs)",
            "def regressor_coefficients(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Summarise the coefficients of the extra regressors used in the model.\\n\\n    For additive regressors, the coefficient represents the incremental impact\\n    on `y` of a unit increase in the regressor. For multiplicative regressors,\\n    the incremental impact is equal to `trend(t)` multiplied by the coefficient.\\n\\n    Coefficients are measured on the original scale of the training data.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n\\n    Returns\\n    -------\\n    pd.DataFrame containing:\\n    - `regressor`: Name of the regressor\\n    - `regressor_mode`: Whether the regressor has an additive or multiplicative\\n        effect on `y`.\\n    - `center`: The mean of the regressor if it was standardized. Otherwise 0.\\n    - `coef_lower`: Lower bound for the coefficient, estimated from the MCMC samples.\\n        Only different to `coef` if `mcmc_samples > 0`.\\n    - `coef`: Expected value of the coefficient.\\n    - `coef_upper`: Upper bound for the coefficient, estimated from MCMC samples.\\n        Only to different to `coef` if `mcmc_samples > 0`.\\n    '\n    assert len(m.extra_regressors) > 0, 'No extra regressors found.'\n    coefs = []\n    for (regressor, params) in m.extra_regressors.items():\n        beta = m.params['beta'][:, regressor_index(m, regressor)]\n        if params['mode'] == 'additive':\n            coef = beta * m.y_scale / params['std']\n        else:\n            coef = beta / params['std']\n        percentiles = [(1 - m.interval_width) / 2, 1 - (1 - m.interval_width) / 2]\n        coef_bounds = np.quantile(coef, q=percentiles)\n        record = {'regressor': regressor, 'regressor_mode': params['mode'], 'center': params['mu'], 'coef_lower': coef_bounds[0], 'coef': np.mean(coef), 'coef_upper': coef_bounds[1]}\n        coefs.append(record)\n    return pd.DataFrame(coefs)",
            "def regressor_coefficients(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Summarise the coefficients of the extra regressors used in the model.\\n\\n    For additive regressors, the coefficient represents the incremental impact\\n    on `y` of a unit increase in the regressor. For multiplicative regressors,\\n    the incremental impact is equal to `trend(t)` multiplied by the coefficient.\\n\\n    Coefficients are measured on the original scale of the training data.\\n\\n    Parameters\\n    ----------\\n    m: Prophet model object, after fitting.\\n\\n    Returns\\n    -------\\n    pd.DataFrame containing:\\n    - `regressor`: Name of the regressor\\n    - `regressor_mode`: Whether the regressor has an additive or multiplicative\\n        effect on `y`.\\n    - `center`: The mean of the regressor if it was standardized. Otherwise 0.\\n    - `coef_lower`: Lower bound for the coefficient, estimated from the MCMC samples.\\n        Only different to `coef` if `mcmc_samples > 0`.\\n    - `coef`: Expected value of the coefficient.\\n    - `coef_upper`: Upper bound for the coefficient, estimated from MCMC samples.\\n        Only to different to `coef` if `mcmc_samples > 0`.\\n    '\n    assert len(m.extra_regressors) > 0, 'No extra regressors found.'\n    coefs = []\n    for (regressor, params) in m.extra_regressors.items():\n        beta = m.params['beta'][:, regressor_index(m, regressor)]\n        if params['mode'] == 'additive':\n            coef = beta * m.y_scale / params['std']\n        else:\n            coef = beta / params['std']\n        percentiles = [(1 - m.interval_width) / 2, 1 - (1 - m.interval_width) / 2]\n        coef_bounds = np.quantile(coef, q=percentiles)\n        record = {'regressor': regressor, 'regressor_mode': params['mode'], 'center': params['mu'], 'coef_lower': coef_bounds[0], 'coef': np.mean(coef), 'coef_upper': coef_bounds[1]}\n        coefs.append(record)\n    return pd.DataFrame(coefs)"
        ]
    },
    {
        "func_name": "warm_start_params",
        "original": "def warm_start_params(m):\n    \"\"\"\n    Retrieve parameters from a trained model in the format used to initialize a new Stan model.\n    Note that the new Stan model must have these same settings:\n        n_changepoints, seasonality features, mcmc sampling\n    for the retrieved parameters to be valid for the new model.\n\n    Parameters\n    ----------\n    m: A trained model of the Prophet class.\n\n    Returns\n    -------\n    A Dictionary containing retrieved parameters of m.\n    \"\"\"\n    res = {}\n    for pname in ['k', 'm', 'sigma_obs']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0][0]\n        else:\n            res[pname] = np.mean(m.params[pname])\n    for pname in ['delta', 'beta']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0]\n        else:\n            res[pname] = np.mean(m.params[pname], axis=0)\n    return res",
        "mutated": [
            "def warm_start_params(m):\n    if False:\n        i = 10\n    '\\n    Retrieve parameters from a trained model in the format used to initialize a new Stan model.\\n    Note that the new Stan model must have these same settings:\\n        n_changepoints, seasonality features, mcmc sampling\\n    for the retrieved parameters to be valid for the new model.\\n\\n    Parameters\\n    ----------\\n    m: A trained model of the Prophet class.\\n\\n    Returns\\n    -------\\n    A Dictionary containing retrieved parameters of m.\\n    '\n    res = {}\n    for pname in ['k', 'm', 'sigma_obs']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0][0]\n        else:\n            res[pname] = np.mean(m.params[pname])\n    for pname in ['delta', 'beta']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0]\n        else:\n            res[pname] = np.mean(m.params[pname], axis=0)\n    return res",
            "def warm_start_params(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Retrieve parameters from a trained model in the format used to initialize a new Stan model.\\n    Note that the new Stan model must have these same settings:\\n        n_changepoints, seasonality features, mcmc sampling\\n    for the retrieved parameters to be valid for the new model.\\n\\n    Parameters\\n    ----------\\n    m: A trained model of the Prophet class.\\n\\n    Returns\\n    -------\\n    A Dictionary containing retrieved parameters of m.\\n    '\n    res = {}\n    for pname in ['k', 'm', 'sigma_obs']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0][0]\n        else:\n            res[pname] = np.mean(m.params[pname])\n    for pname in ['delta', 'beta']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0]\n        else:\n            res[pname] = np.mean(m.params[pname], axis=0)\n    return res",
            "def warm_start_params(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Retrieve parameters from a trained model in the format used to initialize a new Stan model.\\n    Note that the new Stan model must have these same settings:\\n        n_changepoints, seasonality features, mcmc sampling\\n    for the retrieved parameters to be valid for the new model.\\n\\n    Parameters\\n    ----------\\n    m: A trained model of the Prophet class.\\n\\n    Returns\\n    -------\\n    A Dictionary containing retrieved parameters of m.\\n    '\n    res = {}\n    for pname in ['k', 'm', 'sigma_obs']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0][0]\n        else:\n            res[pname] = np.mean(m.params[pname])\n    for pname in ['delta', 'beta']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0]\n        else:\n            res[pname] = np.mean(m.params[pname], axis=0)\n    return res",
            "def warm_start_params(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Retrieve parameters from a trained model in the format used to initialize a new Stan model.\\n    Note that the new Stan model must have these same settings:\\n        n_changepoints, seasonality features, mcmc sampling\\n    for the retrieved parameters to be valid for the new model.\\n\\n    Parameters\\n    ----------\\n    m: A trained model of the Prophet class.\\n\\n    Returns\\n    -------\\n    A Dictionary containing retrieved parameters of m.\\n    '\n    res = {}\n    for pname in ['k', 'm', 'sigma_obs']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0][0]\n        else:\n            res[pname] = np.mean(m.params[pname])\n    for pname in ['delta', 'beta']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0]\n        else:\n            res[pname] = np.mean(m.params[pname], axis=0)\n    return res",
            "def warm_start_params(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Retrieve parameters from a trained model in the format used to initialize a new Stan model.\\n    Note that the new Stan model must have these same settings:\\n        n_changepoints, seasonality features, mcmc sampling\\n    for the retrieved parameters to be valid for the new model.\\n\\n    Parameters\\n    ----------\\n    m: A trained model of the Prophet class.\\n\\n    Returns\\n    -------\\n    A Dictionary containing retrieved parameters of m.\\n    '\n    res = {}\n    for pname in ['k', 'm', 'sigma_obs']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0][0]\n        else:\n            res[pname] = np.mean(m.params[pname])\n    for pname in ['delta', 'beta']:\n        if m.mcmc_samples == 0:\n            res[pname] = m.params[pname][0]\n        else:\n            res[pname] = np.mean(m.params[pname], axis=0)\n    return res"
        ]
    }
]