"""
training_Methods for creating and using a logistic regression model.
"""
from __future__ import print_function as _
from __future__ import division as _
from __future__ import absolute_import as _
import turicreate.toolkits._supervised_learning as _sl
from turicreate.toolkits._supervised_learning import Classifier as _Classifier
from turicreate.toolkits._internal_utils import _toolkit_repr_print, _toolkit_get_topk_bottomk, _raise_error_if_not_sframe, _check_categorical_option_type, _raise_error_evaluation_metric_is_valid, _summarize_coefficients
_DEFAULT_SOLVER_OPTIONS = {'convergence_threshold': 0.01, 'step_size': 1.0, 'lbfgs_memory_level': 11, 'max_iterations': 10}

def create(dataset, target, features=None, l2_penalty=0.01, l1_penalty=0.0, solver='auto', feature_rescaling=True, convergence_threshold=_DEFAULT_SOLVER_OPTIONS['convergence_threshold'], step_size=_DEFAULT_SOLVER_OPTIONS['step_size'], lbfgs_memory_level=_DEFAULT_SOLVER_OPTIONS['lbfgs_memory_level'], max_iterations=_DEFAULT_SOLVER_OPTIONS['max_iterations'], class_weights=None, validation_set='auto', verbose=True, seed=None):
    if False:
        while True:
            i = 10
    "\n    Create a :class:`~turicreate.logistic_classifier.LogisticClassifier` (using\n    logistic regression as a classifier) to predict the class of a discrete\n    target variable (binary or multiclass) based on a model of class probability\n    as a logistic function of a linear combination of the features.  In addition\n    to standard numeric and categorical types, features can also be extracted\n    automatically from list or dictionary-type SFrame columns.\n\n    This model can be regularized with an l1 penalty, an l2 penalty, or both. By\n    default this model has an l2 regularization weight of 0.01.\n\n    Parameters\n    ----------\n    dataset : SFrame\n        Dataset for training the model.\n\n    target : string or int\n        Name of the column containing the target variable. The values in this\n        column must be of string or integer type. String target variables are\n        automatically mapped to integers in the order in which they are provided.\n        For example, a target variable with 'cat' and 'dog' as possible\n        values is mapped to 0 and 1 respectively with 0 being the base class\n        and 1 being the reference class. Use `model.classes` to retrieve\n        the order in which the classes are mapped.\n\n    features : list[string], optional\n        Names of the columns containing features. 'None' (the default) indicates\n        that all columns except the target variable should be used as features.\n\n        The features are columns in the input SFrame that can be of the\n        following types:\n\n        - *Numeric*: values of numeric type integer or float.\n\n        - *Categorical*: values of type string.\n\n        - *Array*: list of numeric (integer or float) values. Each list element\n          is treated as a separate feature in the model.\n\n        - *Dictionary*: key-value pairs with numeric (integer or float) values\n          Each key of a dictionary is treated as a separate feature and the\n          value in the dictionary corresponds to the value of the feature.\n          Dictionaries are ideal for representing sparse data.\n\n        Columns of type *list* are not supported. Convert such feature\n        columns to type array if all entries in the list are of numeric\n        types. If the lists contain data of mixed types, separate\n        them out into different columns.\n\n    l2_penalty : float, optional\n        Weight on l2 regularization of the model. The larger this weight, the\n        more the model coefficients shrink toward 0. This introduces bias into\n        the model but decreases variance, potentially leading to better\n        predictions. The default value is 0.01; setting this parameter to 0\n        corresponds to unregularized logistic regression. See the ridge\n        regression reference for more detail.\n\n    l1_penalty : float, optional\n        Weight on l1 regularization of the model. Like the l2 penalty, the\n        higher the l1 penalty, the more the estimated coefficients shrink toward\n        0. The l1 penalty, however, completely zeros out sufficiently small\n        coefficients, automatically indicating features that are not useful\n        for the model. The default weight of 0 prevents any features from\n        being discarded. See the LASSO regression reference for more detail.\n\n    solver : string, optional\n        Name of the solver to be used to solve the regression. See the\n        references for more detail on each solver. Available solvers are:\n\n        - *auto (default)*: automatically chooses the best solver for the data\n          and model parameters.\n        - *newton*: Newton-Raphson\n        - *lbfgs*: limited memory BFGS\n        - *fista*: accelerated gradient descent\n\n        For this model, the Newton-Raphson method is equivalent to the\n        iteratively re-weighted least squares algorithm. If the l1_penalty is\n        greater than 0, use the 'fista' solver.\n\n        The model is trained using a carefully engineered collection of methods\n        that are automatically picked based on the input data. The ``newton``\n        method  works best for datasets with plenty of examples and few features\n        (long datasets). Limited memory BFGS (``lbfgs``) is a robust solver for\n        wide datasets (i.e datasets with many coefficients).  ``fista`` is the\n        default solver for l1-regularized linear regression. The solvers are all\n        automatically tuned and the default options should function well. See\n        the solver options guide for setting additional parameters for each of\n        the solvers.\n\n        See the user guide for additional details on how the solver is chosen.\n        (see `here\n        <https://apple.github.io/turicreate/docs/userguide/supervised-learning/linear-regression.html>`_)\n\n\n\n    feature_rescaling : boolean, optional\n\n        Feature rescaling is an important pre-processing step that ensures that\n        all features are on the same scale. An l2-norm rescaling is performed\n        to make sure that all features are of the same norm. Categorical\n        features are also rescaled by rescaling the dummy variables that are\n        used to represent them. The coefficients are returned in original scale\n        of the problem. This process is particularly useful when features\n        vary widely in their ranges.\n\n\n    convergence_threshold : float, optional\n\n        Convergence is tested using variation in the training objective. The\n        variation in the training objective is calculated using the difference\n        between the objective values between two steps. Consider reducing this\n        below the default value (0.01) for a more accurately trained model.\n        Beware of overfitting (i.e a model that works well only on the training\n        data) if this parameter is set to a very low value.\n\n    lbfgs_memory_level : float, optional\n\n        The L-BFGS algorithm keeps track of gradient information from the\n        previous ``lbfgs_memory_level`` iterations. The storage requirement for\n        each of these gradients is the ``num_coefficients`` in the problem.\n        Increasing the ``lbfgs_memory_level ``can help improve the quality of\n        the model trained. Setting this to more than ``max_iterations`` has the\n        same effect as setting it to ``max_iterations``.\n\n    max_iterations : int, optional\n\n        The maximum number of allowed passes through the data. More passes over\n        the data can result in a more accurately trained model. Consider\n        increasing this (the default value is 10) if the training accuracy is\n        low and the *Grad-Norm* in the display is large.\n\n    step_size : float, optional\n\n        The starting step size to use for the ``fista`` solver. The default is\n        set to 1.0, this is an aggressive setting. If the first iteration takes\n        a considerable amount of time, reducing this parameter may speed up\n        model training.\n\n    class_weights : {dict, `auto`}, optional\n\n        Weights the examples in the training data according to the given class\n        weights. If set to `None`, all classes are supposed to have weight one. The\n        `auto` mode set the class weight to be inversely proportional to number of\n        examples in the training data with the given class.\n\n    validation_set : SFrame, optional\n\n        A dataset for monitoring the model's generalization performance.\n        For each row of the progress table, the chosen metrics are computed\n        for both the provided training dataset and the validation_set. The\n        format of this SFrame must be the same as the training set.\n        By default this argument is set to 'auto' and a validation set is\n        automatically sampled and used for progress printing. If\n        validation_set is set to None, then no additional metrics\n        are computed. The default value is 'auto'.\n\n    verbose : bool, optional\n        If True, print progress updates.\n\n    seed : int, optional\n        Seed for random number generation. Set this value to ensure that the\n        same model is created every time.\n\n    Returns\n    -------\n    out : LogisticClassifier\n        A trained model of type\n        :class:`~turicreate.logistic_classifier.LogisticClassifier`.\n\n    See Also\n    --------\n    LogisticClassifier, turicreate.boosted_trees_classifier.BoostedTreesClassifier,\n    turicreate.svm_classifier.SVMClassifier, turicreate.classifier.create\n\n    Notes\n    -----\n    - Categorical variables are encoded by creating dummy variables. For a\n      variable with :math:`K` categories, the encoding creates :math:`K-1` dummy\n      variables, while the first category encountered in the data is used as the\n      baseline.\n\n    - For prediction and evaluation of logistic regression models with sparse\n      dictionary inputs, new keys/columns that were not seen during training\n      are silently ignored.\n\n    - During model creation, 'None' values in the data will result in an error\n      being thrown.\n\n    - A constant term is automatically added for the model intercept. This term\n      is not regularized.\n\n    - Standard errors on coefficients are only availiable when `solver=newton`\n      or when the default `auto` solver option choses the newton method and if\n      the number of examples in the training data is more than the number of\n      coefficients. If standard errors cannot be estimated, a column of `None`\n      values are returned.\n\n\n    References\n    ----------\n    - `Wikipedia - logistic regression\n      <http://en.wikipedia.org/wiki/Logistic_regression>`_\n\n    - Hoerl, A.E. and Kennard, R.W. (1970) `Ridge regression: Biased Estimation\n      for Nonorthogonal Problems\n      <http://amstat.tandfonline.com/doi/abs/10.1080/00401706.1970.10488634>`_.\n      Technometrics 12(1) pp.55-67\n\n    - Tibshirani, R. (1996) `Regression Shrinkage and Selection via the Lasso <h\n      ttp://www.jstor.org/discover/10.2307/2346178?uid=3739256&uid=2&uid=4&sid=2\n      1104169934983>`_. Journal of the Royal Statistical Society. Series B\n      (Methodological) 58(1) pp.267-288.\n\n    - Zhu, C., et al. (1997) `Algorithm 778: L-BFGS-B: Fortran subroutines for\n      large-scale bound-constrained optimization\n      <https://dl.acm.org/citation.cfm?id=279236>`_. ACM Transactions on\n      Mathematical Software 23(4) pp.550-560.\n\n    - Beck, A. and Teboulle, M. (2009) `A Fast Iterative Shrinkage-Thresholding\n      Algorithm for Linear Inverse Problems\n      <http://epubs.siam.org/doi/abs/10.1137/080716542>`_. SIAM Journal on\n      Imaging Sciences 2(1) pp.183-202.\n\n\n    Examples\n    --------\n\n    Given an :class:`~turicreate.SFrame` ``sf``, a list of feature columns\n    [``feature_1`` ... ``feature_K``], and a target column ``target`` with 0 and\n    1 values, create a\n    :class:`~turicreate.logistic_classifier.LogisticClassifier` as follows:\n\n    >>> data =  turicreate.SFrame('https://static.turi.com/datasets/regression/houses.csv')\n    >>> data['is_expensive'] = data['price'] > 30000\n    >>> model = turicreate.logistic_classifier.create(data, 'is_expensive')\n\n    By default all columns of ``data`` except the target are used as features, but\n    specific feature columns can be specified manually.\n\n    >>> model = turicreate.logistic_classifier.create(data, 'is_expensive', ['bedroom', 'size'])\n\n\n    .. sourcecode:: python\n\n      # L2 regularizer\n      >>> model_ridge = turicreate.logistic_classifier.create(data, 'is_expensive', l2_penalty=0.1)\n\n      # L1 regularizer\n      >>> model_lasso = turicreate.logistic_classifier.create(data, 'is_expensive', l2_penalty=0.,\n                                                                   l1_penalty=1.0)\n\n      # Both L1 and L2 regularizer\n      >>> model_enet  = turicreate.logistic_classifier.create(data, 'is_expensive', l2_penalty=0.5, l1_penalty=0.5)\n\n    "
    model_name = 'classifier_logistic_regression'
    solver = solver.lower()
    model = _sl.create(dataset, target, model_name, features=features, validation_set=validation_set, verbose=verbose, l2_penalty=l2_penalty, l1_penalty=l1_penalty, feature_rescaling=feature_rescaling, convergence_threshold=convergence_threshold, step_size=step_size, solver=solver, lbfgs_memory_level=lbfgs_memory_level, max_iterations=max_iterations, class_weights=class_weights, seed=seed)
    return LogisticClassifier(model.__proxy__)

class LogisticClassifier(_Classifier):
    """
    Logistic regression models a discrete target variable as a function of
    several feature variables.

    The :class:`~turicreate.logistic_classifier.logisticClassifier` uses
    a discrete target variable :math:`y` instead of a scalar. For each
    observation, the probability that :math:`y=1` (instead of 0) is modeled as
    the logistic function of a linear combination of the feature values.

    Given a set of features :math:`x_i`, and a label :math:`y_i \\in \\{0,1\\}`,
    logistic regression interprets the probability that the label is in one class
    as a logistic function of a linear combination of the features.

        .. math::
          f_i(\\theta) =  p(y_i = 1 | x) = \\frac{1}{1 + \\exp(-\\theta^T x)}

    An intercept term is added by appending a column of 1's to the features.
    Regularization is often required to prevent over fitting by penalizing
    models with extreme parameter values. The logistic regression module
    supports l1 and l2 regularization, which are added to the loss function.

    The composite objective being optimized for is the following;

        .. math::
           \\min_{\\theta} \\sum_{i = 1}^{n} f_i(\\theta) + \\lambda_1 ||\\theta||_1 + \\lambda_2 ||\\theta||^{2}_{2}

    where :math:`\\lambda_1` is the ``l1_penalty`` and :math:`\\lambda_2` is the
    ``l2_penalty``.

    For multi-class models, we perform multinomial logistic regression, which
    is an extension of the binary logistic regression model discussed above.

    This model cannot be constructed directly.  Instead, use
    :func:`turicreate.logistic_classifier.create` to create an instance of this
    model. A detailed list of parameter options and code samples are available
    in the documentation for the create function.

    Examples
    --------
    .. sourcecode:: python

        # Load the data (From an S3 bucket)
        >>> data =  turicreate.SFrame('https://static.turi.com/datasets/regression/houses.csv')

        # Make sure the target is discrete
        >>> data['is_expensive'] = data['price'] > 30000

        # Make a logistic regression model
        >>> model = turicreate.logistic_classifier.create(data, target='is_expensive', features=['bath', 'bedroom', 'size'])

        # Extract the coefficients
        >>> coefficients = model.coefficients

        # Make predictions (as margins, probability, or class)
        >>> predictions = model.predict(data)
        >>> predictions = model.predict(data, output_type='probability')
        >>> predictions = model.predict(data, output_type='margin')

        # Evaluate the model
        >>> results = model.evaluate(data)

    See Also
    --------
    create


    """

    def __init__(self, model_proxy):
        if False:
            return 10
        self.__proxy__ = model_proxy
        self.__name__ = self.__class__._native_name()

    @classmethod
    def _native_name(cls):
        if False:
            for i in range(10):
                print('nop')
        return 'classifier_logistic_regression'

    def __str__(self):
        if False:
            i = 10
            return i + 15
        '\n        Return a string description of the model to the ``print`` method.\n\n        Returns\n        -------\n        out : string\n            A description of the model.\n        '
        return self.__repr__()

    def _get_summary_struct(self):
        if False:
            i = 10
            return i + 15
        "\n        Returns a structured description of the model, including (where relevant)\n        the schema of the training data, description of the training data,\n        training statistics, and model hyperparameters.\n\n        Returns\n        -------\n        sections : list (of list of tuples)\n            A list of summary sections.\n              Each section is a list.\n                Each item in a section list is a tuple of the form:\n                  ('<label>','<field>')\n        section_titles: list\n            A list of section titles.\n              The order matches that of the 'sections' object.\n        "
        model_fields = [('Number of coefficients', 'num_coefficients'), ('Number of examples', 'num_examples'), ('Number of classes', 'num_classes'), ('Number of feature columns', 'num_features'), ('Number of unpacked features', 'num_unpacked_features')]
        hyperparam_fields = [('L1 penalty', 'l1_penalty'), ('L2 penalty', 'l2_penalty')]
        solver_fields = [('Solver', 'solver'), ('Solver iterations', 'training_iterations'), ('Solver status', 'training_solver_status'), ('Training time (sec)', 'training_time')]
        training_fields = [('Log-likelihood', 'training_loss')]
        coefs = self.coefficients
        (top_coefs, bottom_coefs) = _toolkit_get_topk_bottomk(coefs, k=5)
        (coefs_list, titles_list) = _summarize_coefficients(top_coefs, bottom_coefs)
        return ([model_fields, hyperparam_fields, solver_fields, training_fields] + coefs_list, ['Schema', 'Hyperparameters', 'Training Summary', 'Settings'] + titles_list)

    def __repr__(self):
        if False:
            return 10
        '\n        Print a string description of the model, when the model name is entered\n        in the terminal.\n        '
        (sections, section_titles) = self._get_summary_struct()
        return _toolkit_repr_print(self, sections, section_titles, width=30)

    def export_coreml(self, filename):
        if False:
            while True:
                i = 10
        '\n        Export the model in Core ML format.\n\n        Parameters\n        ----------\n        filename: str\n          A valid filename where the model can be saved.\n\n        Examples\n        --------\n        >>> model.export_coreml("MyModel.mlmodel")\n        '
        from turicreate.extensions import _logistic_classifier_export_as_model_asset
        from turicreate.toolkits import _coreml_utils
        display_name = 'logistic classifier'
        short_description = _coreml_utils._mlmodel_short_description(display_name)
        context = {'class': self.__class__.__name__, 'short_description': short_description}
        context['user_defined'] = _coreml_utils._get_model_metadata(self.__class__.__name__, None)
        _logistic_classifier_export_as_model_asset(self.__proxy__, filename, context)

    def _get(self, field):
        if False:
            i = 10
            return i + 15
        '\n        Return the value of a given field. The list of all queryable fields is\n        detailed below, and can be obtained programmatically with the\n        :func:`~turicreate.logistic_classifier.LogisticClassifier._list_fields`\n        method.\n\n        +------------------------+-------------------------------------------------------------+\n        |      Field             | Description                                                 |\n        +========================+=============================================================+\n        | coefficients           | Regression coefficients                                     |\n        +------------------------+-------------------------------------------------------------+\n        | convergence_threshold  | Desired solver accuracy                                     |\n        +------------------------+-------------------------------------------------------------+\n        | feature_rescaling      | Bool indicating l2-rescaling of features                    |\n        +------------------------+-------------------------------------------------------------+\n        | features               | Feature column names                                        |\n        +------------------------+-------------------------------------------------------------+\n        | l1_penalty             | l1 regularization weight                                    |\n        +------------------------+-------------------------------------------------------------+\n        | l2_penalty             | l2 regularization weight                                    |\n        +------------------------+-------------------------------------------------------------+\n        | lbfgs_memory_level     | LBFGS memory level                                          |\n        +------------------------+-------------------------------------------------------------+\n        | max_iterations         | Maximum number of solver iterations                         |\n        +------------------------+-------------------------------------------------------------+\n        | num_coefficients       | Number of coefficients in the model                         |\n        +------------------------+-------------------------------------------------------------+\n        | num_examples           | Number of examples used for training                        |\n        +------------------------+-------------------------------------------------------------+\n        | num_features           | Number of dataset columns used for training                 |\n        +------------------------+-------------------------------------------------------------+\n        | num_unpacked_features  | Number of features (including expanded list/dict features)  |\n        +------------------------+-------------------------------------------------------------+\n        | solver                 | Type of solver                                              |\n        +------------------------+-------------------------------------------------------------+\n        | step_size              | Initial step size for the solver                            |\n        +------------------------+-------------------------------------------------------------+\n        | target                 | Target column name                                          |\n        +------------------------+-------------------------------------------------------------+\n        | training_iterations    | Number of solver iterations                                 |\n        +------------------------+-------------------------------------------------------------+\n        | training_loss          | Maximized Log-likelihood                                    |\n        +------------------------+-------------------------------------------------------------+\n        | training_solver_status | Solver status after training                                |\n        +------------------------+-------------------------------------------------------------+\n        | training_time          | Training time (excludes preprocessing)                      |\n        +------------------------+-------------------------------------------------------------+\n        | unpacked_features      | Feature names (including expanded list/dict features)       |\n        +------------------------+-------------------------------------------------------------+\n\n        Parameters\n        ----------\n        field : string\n            Name of the field to be retrieved.\n\n        Returns\n        -------\n        out\n            Value of the requested fields.\n        '
        return super(_Classifier, self)._get(field)

    def predict(self, dataset, output_type='class', missing_value_action='auto'):
        if False:
            print('Hello World!')
        "\n        Return predictions for ``dataset``, using the trained logistic\n        regression model. Predictions can be generated as class labels,\n        probabilities that the target value is True, or margins (i.e. the\n        distance of the observations from the hyperplane separating the\n        classes). `probability_vector` returns a vector of probabilities by\n        each class.\n\n        For each new example in ``dataset``, the margin---also known as the\n        linear predictor---is the inner product of the example and the model\n        coefficients. The probability is obtained by passing the margin through\n        the logistic function. Predicted classes are obtained by thresholding\n        the predicted probabilities at 0.5. If you would like to threshold\n        predictions at a different probability level, you can use the\n        Turi Create evaluation toolkit.\n\n        Parameters\n        ----------\n        dataset : SFrame\n            Dataset of new observations. Must include columns with the same\n            names as the features used for model training, but does not require\n            a target column. Additional columns are ignored.\n\n        output_type : {'probability', 'margin', 'class', 'probability_vector'}, optional\n            Form of the predictions which are one of:\n\n            - 'probability': Prediction probability associated with the True\n              class (not applicable for multi-class classification)\n            - 'probability_vector': Prediction probability associated with each\n              class as a vector. The probability of the first class (sorted\n              alphanumerically by name of the class in the training set) is in\n              position 0 of the vector, the second in position 1 and so on.\n            - 'class': Class prediction. For multi-class classification, this\n              returns the class with maximum probability.\n\n        missing_value_action : str, optional\n            Action to perform when missing values are encountered. Can be\n            one of:\n\n            - 'auto': Default to 'impute'\n            - 'impute': Proceed with evaluation by filling in the missing\n              values with the mean of the training data. Missing\n              values are also imputed if an entire column of data is\n              missing during evaluation.\n            - 'error': Do not proceed with evaluation and terminate with\n              an error message.\n\n        Returns\n        -------\n        out : SArray\n            An SArray with model predictions.\n\n        See Also\n        ----------\n        create, evaluate, classify\n\n        Examples\n        ----------\n        >>> data =  turicreate.SFrame('https://static.turi.com/datasets/regression/houses.csv')\n\n        >>> data['is_expensive'] = data['price'] > 30000\n        >>> model = turicreate.logistic_classifier.create(data,\n                                             target='is_expensive',\n                                             features=['bath', 'bedroom', 'size'])\n\n        >>> probability_predictions = model.predict(data, output_type='probability')\n        >>> margin_predictions = model.predict(data, output_type='margin')\n        >>> class_predictions = model.predict(data, output_type='class')\n\n        "
        return super(_Classifier, self).predict(dataset, output_type=output_type, missing_value_action=missing_value_action)

    def classify(self, dataset, missing_value_action='auto'):
        if False:
            i = 10
            return i + 15
        "\n        Return a classification, for each example in the ``dataset``, using the\n        trained logistic regression model. The output SFrame contains predictions\n        as both class labels (0 or 1) as well as probabilities that the predicted\n        value is the associated label.\n\n        Parameters\n        ----------\n        dataset : SFrame\n            Dataset of new observations. Must include columns with the same\n            names as the features used for model training, but does not require\n            a target column. Additional columns are ignored.\n\n        missing_value_action : str, optional\n            Action to perform when missing values are encountered. This can be\n            one of:\n\n            - 'auto': Default to 'impute'\n            - 'impute': Proceed with evaluation by filling in the missing\n              values with the mean of the training data. Missing\n              values are also imputed if an entire column of data is\n              missing during evaluation.\n            - 'error': Do not proceed with evaluation and terminate with\n              an error message.\n\n        Returns\n        -------\n        out : SFrame\n            An SFrame with model predictions i.e class labels and probabilities.\n\n        See Also\n        ----------\n        create, evaluate, predict\n\n        Examples\n        ----------\n        >>> data =  turicreate.SFrame('https://static.turi.com/datasets/regression/houses.csv')\n\n        >>> data['is_expensive'] = data['price'] > 30000\n        >>> model = turicreate.logistic_classifier.create(data,\n                                             target='is_expensive',\n                                             features=['bath', 'bedroom', 'size'])\n\n        >>> classes = model.classify(data)\n\n        "
        return super(LogisticClassifier, self).classify(dataset, missing_value_action=missing_value_action)

    def predict_topk(self, dataset, output_type='probability', k=3, missing_value_action='auto'):
        if False:
            for i in range(10):
                print('nop')
        "\n        Return top-k predictions for the ``dataset``, using the trained model.\n        Predictions are returned as an SFrame with three columns: `id`,\n        `class`, and `probability`, `margin`,  or `rank`, depending on the ``output_type``\n        parameter. Input dataset size must be the same as for training of the model.\n\n        Parameters\n        ----------\n        dataset : SFrame\n            A dataset that has the same columns that were used during training.\n            If the target column exists in ``dataset`` it will be ignored\n            while making predictions.\n\n        output_type : {'probability', 'rank', 'margin'}, optional\n            Choose the return type of the prediction:\n\n            - `probability`: Probability associated with each label in the prediction.\n            - `rank`       : Rank associated with each label in the prediction.\n            - `margin`     : Margin associated with each label in the prediction.\n\n        k : int, optional\n            Number of classes to return for each input example.\n\n        missing_value_action : str, optional\n            Action to perform when missing values are encountered. Can be\n            one of:\n\n            - 'auto': Default to 'impute'\n            - 'impute': Proceed with evaluation by filling in the missing\n              values with the mean of the training data. Missing\n              values are also imputed if an entire column of data is\n              missing during evaluation.\n            - 'error': Do not proceed with evaluation and terminate with\n              an error message.\n\n        Returns\n        -------\n        out : SFrame\n            An SFrame with model predictions.\n\n        See Also\n        --------\n        predict, classify, evaluate\n\n        Examples\n        --------\n        >>> pred = m.predict_topk(validation_data, k=3)\n        >>> pred\n        +--------+-------+-------------------+\n        | id     | class |   probability     |\n        +--------+-------+-------------------+\n        |   0    |   4   |   0.995623886585  |\n        |   0    |   9   |  0.0038311756216  |\n        |   0    |   7   | 0.000301006948575 |\n        |   1    |   1   |   0.928708016872  |\n        |   1    |   3   |  0.0440889261663  |\n        |   1    |   2   |  0.0176190119237  |\n        |   2    |   3   |   0.996967732906  |\n        |   2    |   2   |  0.00151345680933 |\n        |   2    |   7   | 0.000637513934635 |\n        |   3    |   1   |   0.998070061207  |\n        |  ...   |  ...  |        ...        |\n        +--------+-------+-------------------+\n        [35688 rows x 3 columns]\n        "
        _check_categorical_option_type('output_type', output_type, ['rank', 'margin', 'probability'])
        _check_categorical_option_type('missing_value_action', missing_value_action, ['auto', 'impute', 'error'])
        if missing_value_action == 'auto':
            missing_value_action = 'impute'
        if isinstance(dataset, list):
            return self.__proxy__.fast_predict_topk(dataset, missing_value_action, output_type, k)
        if isinstance(dataset, dict):
            return self.__proxy__.fast_predict_topk([dataset], missing_value_action, output_type, k)
        _raise_error_if_not_sframe(dataset, 'dataset')
        if missing_value_action == 'auto':
            missing_value_action = _sl.select_default_missing_value_policy(self, 'predict')
        return self.__proxy__.predict_topk(dataset, missing_value_action, output_type, k)

    def evaluate(self, dataset, metric='auto', missing_value_action='auto', with_predictions=False):
        if False:
            print('Hello World!')
        "\n        Evaluate the model by making predictions of target values and comparing\n        these to actual values.\n\n        Parameters\n        ----------\n        dataset : SFrame\n            Dataset of new observations. Must include columns with the same\n            names as the target and features used for model training. Additional\n            columns are ignored.\n\n        metric : str, optional\n            Name of the evaluation metric.  Possible values are:\n\n            - 'auto'             : Returns all available metrics.\n            - 'accuracy'         : Classification accuracy (micro average).\n            - 'auc'              : Area under the ROC curve (macro average)\n            - 'precision'        : Precision score (macro average)\n            - 'recall'           : Recall score (macro average)\n            - 'f1_score'         : F1 score (macro average)\n            - 'log_loss'         : Log loss\n            - 'confusion_matrix' : An SFrame with counts of possible prediction/true label combinations.\n            - 'roc_curve'        : An SFrame containing information needed for an ROC curve\n\n            For more flexibility in calculating evaluation metrics, use the\n            :class:`~turicreate.evaluation` module.\n\n        missing_value_action : str, optional\n            Action to perform when missing values are encountered. This can be\n            one of:\n\n            - 'auto': Default to 'impute'\n            - 'impute': Proceed with evaluation by filling in the missing\n              values with the mean of the training data. Missing\n              values are also imputed if an entire column of data is\n              missing during evaluation.\n            - 'error': Do not proceed with evaluation and terminate with\n              an error message.\n\n        Returns\n        -------\n        out : dict\n            Dictionary of evaluation results where the key is the name of the\n            evaluation metric (e.g. `accuracy`) and the value is the evaluation\n            score.\n\n        See Also\n        ----------\n        create, predict, classify\n\n        Examples\n        ----------\n        .. sourcecode:: python\n\n          >>> data =  turicreate.SFrame('https://static.turi.com/datasets/regression/houses.csv')\n          >>> data['is_expensive'] = data['price'] > 30000\n          >>> model = turicreate.logistic_classifier.create(data,\n          ...                             target='is_expensive',\n          ...                             features=['bath', 'bedroom', 'size'])\n          >>> results = model.evaluate(data)\n          >>> print results['accuracy']\n        "
        _raise_error_evaluation_metric_is_valid(metric, ['auto', 'accuracy', 'confusion_matrix', 'roc_curve', 'auc', 'log_loss', 'precision', 'recall', 'f1_score'])
        return super(_Classifier, self).evaluate(dataset, missing_value_action=missing_value_action, metric=metric, with_predictions=with_predictions)