[
    {
        "func_name": "project_pts_on_img",
        "original": "def project_pts_on_img(points, raw_img, lidar2img_rt, max_distance=70, thickness=-1):\n    \"\"\"Project the 3D points cloud on 2D image.\n\n    Args:\n        points (numpy.array): 3D points cloud (x, y, z) to visualize.\n        raw_img (numpy.array): The numpy array of image.\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\n            according to the camera intrinsic parameters.\n        max_distance (float, optional): the max distance of the points cloud.\n            Default: 70.\n        thickness (int, optional): The thickness of 2D points. Default: -1.\n    \"\"\"\n    img = raw_img.copy()\n    num_points = points.shape[0]\n    pts_4d = np.concatenate([points[:, :3], np.ones((num_points, 1))], axis=-1)\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=99999)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    fov_inds = (pts_2d[:, 0] < img.shape[1]) & (pts_2d[:, 0] >= 0) & (pts_2d[:, 1] < img.shape[0]) & (pts_2d[:, 1] >= 0)\n    imgfov_pts_2d = pts_2d[fov_inds, :3]\n    cmap = plt.cm.get_cmap('hsv', 256)\n    cmap = np.array([cmap(i) for i in range(256)])[:, :3] * 255\n    for i in range(imgfov_pts_2d.shape[0]):\n        depth = imgfov_pts_2d[i, 2]\n        color = cmap[np.clip(int(max_distance * 10 / depth), 0, 255), :]\n        cv2.circle(img, center=(int(np.round(imgfov_pts_2d[i, 0])), int(np.round(imgfov_pts_2d[i, 1]))), radius=1, color=tuple(color), thickness=thickness)\n    cv2.imshow('project_pts_img', img.astype(np.uint8))\n    cv2.waitKey(100)",
        "mutated": [
            "def project_pts_on_img(points, raw_img, lidar2img_rt, max_distance=70, thickness=-1):\n    if False:\n        i = 10\n    'Project the 3D points cloud on 2D image.\\n\\n    Args:\\n        points (numpy.array): 3D points cloud (x, y, z) to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        max_distance (float, optional): the max distance of the points cloud.\\n            Default: 70.\\n        thickness (int, optional): The thickness of 2D points. Default: -1.\\n    '\n    img = raw_img.copy()\n    num_points = points.shape[0]\n    pts_4d = np.concatenate([points[:, :3], np.ones((num_points, 1))], axis=-1)\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=99999)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    fov_inds = (pts_2d[:, 0] < img.shape[1]) & (pts_2d[:, 0] >= 0) & (pts_2d[:, 1] < img.shape[0]) & (pts_2d[:, 1] >= 0)\n    imgfov_pts_2d = pts_2d[fov_inds, :3]\n    cmap = plt.cm.get_cmap('hsv', 256)\n    cmap = np.array([cmap(i) for i in range(256)])[:, :3] * 255\n    for i in range(imgfov_pts_2d.shape[0]):\n        depth = imgfov_pts_2d[i, 2]\n        color = cmap[np.clip(int(max_distance * 10 / depth), 0, 255), :]\n        cv2.circle(img, center=(int(np.round(imgfov_pts_2d[i, 0])), int(np.round(imgfov_pts_2d[i, 1]))), radius=1, color=tuple(color), thickness=thickness)\n    cv2.imshow('project_pts_img', img.astype(np.uint8))\n    cv2.waitKey(100)",
            "def project_pts_on_img(points, raw_img, lidar2img_rt, max_distance=70, thickness=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Project the 3D points cloud on 2D image.\\n\\n    Args:\\n        points (numpy.array): 3D points cloud (x, y, z) to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        max_distance (float, optional): the max distance of the points cloud.\\n            Default: 70.\\n        thickness (int, optional): The thickness of 2D points. Default: -1.\\n    '\n    img = raw_img.copy()\n    num_points = points.shape[0]\n    pts_4d = np.concatenate([points[:, :3], np.ones((num_points, 1))], axis=-1)\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=99999)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    fov_inds = (pts_2d[:, 0] < img.shape[1]) & (pts_2d[:, 0] >= 0) & (pts_2d[:, 1] < img.shape[0]) & (pts_2d[:, 1] >= 0)\n    imgfov_pts_2d = pts_2d[fov_inds, :3]\n    cmap = plt.cm.get_cmap('hsv', 256)\n    cmap = np.array([cmap(i) for i in range(256)])[:, :3] * 255\n    for i in range(imgfov_pts_2d.shape[0]):\n        depth = imgfov_pts_2d[i, 2]\n        color = cmap[np.clip(int(max_distance * 10 / depth), 0, 255), :]\n        cv2.circle(img, center=(int(np.round(imgfov_pts_2d[i, 0])), int(np.round(imgfov_pts_2d[i, 1]))), radius=1, color=tuple(color), thickness=thickness)\n    cv2.imshow('project_pts_img', img.astype(np.uint8))\n    cv2.waitKey(100)",
            "def project_pts_on_img(points, raw_img, lidar2img_rt, max_distance=70, thickness=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Project the 3D points cloud on 2D image.\\n\\n    Args:\\n        points (numpy.array): 3D points cloud (x, y, z) to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        max_distance (float, optional): the max distance of the points cloud.\\n            Default: 70.\\n        thickness (int, optional): The thickness of 2D points. Default: -1.\\n    '\n    img = raw_img.copy()\n    num_points = points.shape[0]\n    pts_4d = np.concatenate([points[:, :3], np.ones((num_points, 1))], axis=-1)\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=99999)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    fov_inds = (pts_2d[:, 0] < img.shape[1]) & (pts_2d[:, 0] >= 0) & (pts_2d[:, 1] < img.shape[0]) & (pts_2d[:, 1] >= 0)\n    imgfov_pts_2d = pts_2d[fov_inds, :3]\n    cmap = plt.cm.get_cmap('hsv', 256)\n    cmap = np.array([cmap(i) for i in range(256)])[:, :3] * 255\n    for i in range(imgfov_pts_2d.shape[0]):\n        depth = imgfov_pts_2d[i, 2]\n        color = cmap[np.clip(int(max_distance * 10 / depth), 0, 255), :]\n        cv2.circle(img, center=(int(np.round(imgfov_pts_2d[i, 0])), int(np.round(imgfov_pts_2d[i, 1]))), radius=1, color=tuple(color), thickness=thickness)\n    cv2.imshow('project_pts_img', img.astype(np.uint8))\n    cv2.waitKey(100)",
            "def project_pts_on_img(points, raw_img, lidar2img_rt, max_distance=70, thickness=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Project the 3D points cloud on 2D image.\\n\\n    Args:\\n        points (numpy.array): 3D points cloud (x, y, z) to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        max_distance (float, optional): the max distance of the points cloud.\\n            Default: 70.\\n        thickness (int, optional): The thickness of 2D points. Default: -1.\\n    '\n    img = raw_img.copy()\n    num_points = points.shape[0]\n    pts_4d = np.concatenate([points[:, :3], np.ones((num_points, 1))], axis=-1)\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=99999)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    fov_inds = (pts_2d[:, 0] < img.shape[1]) & (pts_2d[:, 0] >= 0) & (pts_2d[:, 1] < img.shape[0]) & (pts_2d[:, 1] >= 0)\n    imgfov_pts_2d = pts_2d[fov_inds, :3]\n    cmap = plt.cm.get_cmap('hsv', 256)\n    cmap = np.array([cmap(i) for i in range(256)])[:, :3] * 255\n    for i in range(imgfov_pts_2d.shape[0]):\n        depth = imgfov_pts_2d[i, 2]\n        color = cmap[np.clip(int(max_distance * 10 / depth), 0, 255), :]\n        cv2.circle(img, center=(int(np.round(imgfov_pts_2d[i, 0])), int(np.round(imgfov_pts_2d[i, 1]))), radius=1, color=tuple(color), thickness=thickness)\n    cv2.imshow('project_pts_img', img.astype(np.uint8))\n    cv2.waitKey(100)",
            "def project_pts_on_img(points, raw_img, lidar2img_rt, max_distance=70, thickness=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Project the 3D points cloud on 2D image.\\n\\n    Args:\\n        points (numpy.array): 3D points cloud (x, y, z) to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        max_distance (float, optional): the max distance of the points cloud.\\n            Default: 70.\\n        thickness (int, optional): The thickness of 2D points. Default: -1.\\n    '\n    img = raw_img.copy()\n    num_points = points.shape[0]\n    pts_4d = np.concatenate([points[:, :3], np.ones((num_points, 1))], axis=-1)\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=99999)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    fov_inds = (pts_2d[:, 0] < img.shape[1]) & (pts_2d[:, 0] >= 0) & (pts_2d[:, 1] < img.shape[0]) & (pts_2d[:, 1] >= 0)\n    imgfov_pts_2d = pts_2d[fov_inds, :3]\n    cmap = plt.cm.get_cmap('hsv', 256)\n    cmap = np.array([cmap(i) for i in range(256)])[:, :3] * 255\n    for i in range(imgfov_pts_2d.shape[0]):\n        depth = imgfov_pts_2d[i, 2]\n        color = cmap[np.clip(int(max_distance * 10 / depth), 0, 255), :]\n        cv2.circle(img, center=(int(np.round(imgfov_pts_2d[i, 0])), int(np.round(imgfov_pts_2d[i, 1]))), radius=1, color=tuple(color), thickness=thickness)\n    cv2.imshow('project_pts_img', img.astype(np.uint8))\n    cv2.waitKey(100)"
        ]
    },
    {
        "func_name": "plot_rect3d_on_img",
        "original": "def plot_rect3d_on_img(img, num_rects, rect_corners, color=(0, 255, 0), thickness=1):\n    \"\"\"Plot the boundary lines of 3D rectangular on 2D images.\n\n    Args:\n        img (numpy.array): The numpy array of image.\n        num_rects (int): Number of 3D rectangulars.\n        rect_corners (numpy.array): Coordinates of the corners of 3D\n            rectangulars. Should be in the shape of [num_rect, 8, 2].\n        color (tuple[int], optional): The color to draw bboxes.\n            Default: (0, 255, 0).\n        thickness (int, optional): The thickness of bboxes. Default: 1.\n    \"\"\"\n    line_indices = ((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (3, 2), (3, 7), (4, 5), (4, 7), (2, 6), (5, 6), (6, 7))\n    for i in range(num_rects):\n        corners = rect_corners[i].astype(np.int)\n        for (start, end) in line_indices:\n            cv2.line(img, (corners[start, 0], corners[start, 1]), (corners[end, 0], corners[end, 1]), color, thickness, cv2.LINE_AA)\n    return img.astype(np.uint8)",
        "mutated": [
            "def plot_rect3d_on_img(img, num_rects, rect_corners, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n    'Plot the boundary lines of 3D rectangular on 2D images.\\n\\n    Args:\\n        img (numpy.array): The numpy array of image.\\n        num_rects (int): Number of 3D rectangulars.\\n        rect_corners (numpy.array): Coordinates of the corners of 3D\\n            rectangulars. Should be in the shape of [num_rect, 8, 2].\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    line_indices = ((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (3, 2), (3, 7), (4, 5), (4, 7), (2, 6), (5, 6), (6, 7))\n    for i in range(num_rects):\n        corners = rect_corners[i].astype(np.int)\n        for (start, end) in line_indices:\n            cv2.line(img, (corners[start, 0], corners[start, 1]), (corners[end, 0], corners[end, 1]), color, thickness, cv2.LINE_AA)\n    return img.astype(np.uint8)",
            "def plot_rect3d_on_img(img, num_rects, rect_corners, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the boundary lines of 3D rectangular on 2D images.\\n\\n    Args:\\n        img (numpy.array): The numpy array of image.\\n        num_rects (int): Number of 3D rectangulars.\\n        rect_corners (numpy.array): Coordinates of the corners of 3D\\n            rectangulars. Should be in the shape of [num_rect, 8, 2].\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    line_indices = ((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (3, 2), (3, 7), (4, 5), (4, 7), (2, 6), (5, 6), (6, 7))\n    for i in range(num_rects):\n        corners = rect_corners[i].astype(np.int)\n        for (start, end) in line_indices:\n            cv2.line(img, (corners[start, 0], corners[start, 1]), (corners[end, 0], corners[end, 1]), color, thickness, cv2.LINE_AA)\n    return img.astype(np.uint8)",
            "def plot_rect3d_on_img(img, num_rects, rect_corners, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the boundary lines of 3D rectangular on 2D images.\\n\\n    Args:\\n        img (numpy.array): The numpy array of image.\\n        num_rects (int): Number of 3D rectangulars.\\n        rect_corners (numpy.array): Coordinates of the corners of 3D\\n            rectangulars. Should be in the shape of [num_rect, 8, 2].\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    line_indices = ((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (3, 2), (3, 7), (4, 5), (4, 7), (2, 6), (5, 6), (6, 7))\n    for i in range(num_rects):\n        corners = rect_corners[i].astype(np.int)\n        for (start, end) in line_indices:\n            cv2.line(img, (corners[start, 0], corners[start, 1]), (corners[end, 0], corners[end, 1]), color, thickness, cv2.LINE_AA)\n    return img.astype(np.uint8)",
            "def plot_rect3d_on_img(img, num_rects, rect_corners, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the boundary lines of 3D rectangular on 2D images.\\n\\n    Args:\\n        img (numpy.array): The numpy array of image.\\n        num_rects (int): Number of 3D rectangulars.\\n        rect_corners (numpy.array): Coordinates of the corners of 3D\\n            rectangulars. Should be in the shape of [num_rect, 8, 2].\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    line_indices = ((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (3, 2), (3, 7), (4, 5), (4, 7), (2, 6), (5, 6), (6, 7))\n    for i in range(num_rects):\n        corners = rect_corners[i].astype(np.int)\n        for (start, end) in line_indices:\n            cv2.line(img, (corners[start, 0], corners[start, 1]), (corners[end, 0], corners[end, 1]), color, thickness, cv2.LINE_AA)\n    return img.astype(np.uint8)",
            "def plot_rect3d_on_img(img, num_rects, rect_corners, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the boundary lines of 3D rectangular on 2D images.\\n\\n    Args:\\n        img (numpy.array): The numpy array of image.\\n        num_rects (int): Number of 3D rectangulars.\\n        rect_corners (numpy.array): Coordinates of the corners of 3D\\n            rectangulars. Should be in the shape of [num_rect, 8, 2].\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    line_indices = ((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (3, 2), (3, 7), (4, 5), (4, 7), (2, 6), (5, 6), (6, 7))\n    for i in range(num_rects):\n        corners = rect_corners[i].astype(np.int)\n        for (start, end) in line_indices:\n            cv2.line(img, (corners[start, 0], corners[start, 1]), (corners[end, 0], corners[end, 1]), color, thickness, cv2.LINE_AA)\n    return img.astype(np.uint8)"
        ]
    },
    {
        "func_name": "draw_lidar_bbox3d_on_img",
        "original": "def draw_lidar_bbox3d_on_img(bboxes3d, raw_img, lidar2img_rt, img_metas, color=(0, 255, 0), thickness=1):\n    \"\"\"Project the 3D bbox on 2D plane and draw on input image.\n\n    Args:\n        bboxes3d (:obj:`LiDARInstance3DBoxes`):\n            3d bbox in lidar coordinate system to visualize.\n        raw_img (numpy.array): The numpy array of image.\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\n            according to the camera intrinsic parameters.\n        img_metas (dict): Useless here.\n        color (tuple[int], optional): The color to draw bboxes.\n            Default: (0, 255, 0).\n        thickness (int, optional): The thickness of bboxes. Default: 1.\n    \"\"\"\n    img = raw_img.copy()\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    pts_4d = np.concatenate([corners_3d.reshape(-1, 3), np.ones((num_bbox * 8, 1))], axis=-1)\n    lidar2img_rt = copy.deepcopy(lidar2img_rt).reshape(4, 4)\n    if isinstance(lidar2img_rt, torch.Tensor):\n        lidar2img_rt = lidar2img_rt.cpu().numpy()\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=100000.0)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    imgfov_pts_2d = pts_2d[..., :2].reshape(num_bbox, 8, 2)\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
        "mutated": [
            "def draw_lidar_bbox3d_on_img(bboxes3d, raw_img, lidar2img_rt, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`LiDARInstance3DBoxes`):\\n            3d bbox in lidar coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    img = raw_img.copy()\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    pts_4d = np.concatenate([corners_3d.reshape(-1, 3), np.ones((num_bbox * 8, 1))], axis=-1)\n    lidar2img_rt = copy.deepcopy(lidar2img_rt).reshape(4, 4)\n    if isinstance(lidar2img_rt, torch.Tensor):\n        lidar2img_rt = lidar2img_rt.cpu().numpy()\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=100000.0)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    imgfov_pts_2d = pts_2d[..., :2].reshape(num_bbox, 8, 2)\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_lidar_bbox3d_on_img(bboxes3d, raw_img, lidar2img_rt, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`LiDARInstance3DBoxes`):\\n            3d bbox in lidar coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    img = raw_img.copy()\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    pts_4d = np.concatenate([corners_3d.reshape(-1, 3), np.ones((num_bbox * 8, 1))], axis=-1)\n    lidar2img_rt = copy.deepcopy(lidar2img_rt).reshape(4, 4)\n    if isinstance(lidar2img_rt, torch.Tensor):\n        lidar2img_rt = lidar2img_rt.cpu().numpy()\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=100000.0)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    imgfov_pts_2d = pts_2d[..., :2].reshape(num_bbox, 8, 2)\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_lidar_bbox3d_on_img(bboxes3d, raw_img, lidar2img_rt, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`LiDARInstance3DBoxes`):\\n            3d bbox in lidar coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    img = raw_img.copy()\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    pts_4d = np.concatenate([corners_3d.reshape(-1, 3), np.ones((num_bbox * 8, 1))], axis=-1)\n    lidar2img_rt = copy.deepcopy(lidar2img_rt).reshape(4, 4)\n    if isinstance(lidar2img_rt, torch.Tensor):\n        lidar2img_rt = lidar2img_rt.cpu().numpy()\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=100000.0)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    imgfov_pts_2d = pts_2d[..., :2].reshape(num_bbox, 8, 2)\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_lidar_bbox3d_on_img(bboxes3d, raw_img, lidar2img_rt, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`LiDARInstance3DBoxes`):\\n            3d bbox in lidar coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    img = raw_img.copy()\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    pts_4d = np.concatenate([corners_3d.reshape(-1, 3), np.ones((num_bbox * 8, 1))], axis=-1)\n    lidar2img_rt = copy.deepcopy(lidar2img_rt).reshape(4, 4)\n    if isinstance(lidar2img_rt, torch.Tensor):\n        lidar2img_rt = lidar2img_rt.cpu().numpy()\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=100000.0)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    imgfov_pts_2d = pts_2d[..., :2].reshape(num_bbox, 8, 2)\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_lidar_bbox3d_on_img(bboxes3d, raw_img, lidar2img_rt, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`LiDARInstance3DBoxes`):\\n            3d bbox in lidar coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        lidar2img_rt (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    img = raw_img.copy()\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    pts_4d = np.concatenate([corners_3d.reshape(-1, 3), np.ones((num_bbox * 8, 1))], axis=-1)\n    lidar2img_rt = copy.deepcopy(lidar2img_rt).reshape(4, 4)\n    if isinstance(lidar2img_rt, torch.Tensor):\n        lidar2img_rt = lidar2img_rt.cpu().numpy()\n    pts_2d = pts_4d @ lidar2img_rt.T\n    pts_2d[:, 2] = np.clip(pts_2d[:, 2], a_min=1e-05, a_max=100000.0)\n    pts_2d[:, 0] /= pts_2d[:, 2]\n    pts_2d[:, 1] /= pts_2d[:, 2]\n    imgfov_pts_2d = pts_2d[..., :2].reshape(num_bbox, 8, 2)\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)"
        ]
    },
    {
        "func_name": "draw_depth_bbox3d_on_img",
        "original": "def draw_depth_bbox3d_on_img(bboxes3d, raw_img, calibs, img_metas, color=(0, 255, 0), thickness=1):\n    \"\"\"Project the 3D bbox on 2D plane and draw on input image.\n\n    Args:\n        bboxes3d (:obj:`DepthInstance3DBoxes`, shape=[M, 7]):\n            3d bbox in depth coordinate system to visualize.\n        raw_img (numpy.array): The numpy array of image.\n        calibs (dict): Camera calibration information, Rt and K.\n        img_metas (dict): Used in coordinates transformation.\n        color (tuple[int], optional): The color to draw bboxes.\n            Default: (0, 255, 0).\n        thickness (int, optional): The thickness of bboxes. Default: 1.\n    \"\"\"\n    from mmdet3d.core.bbox import points_cam2img\n    from mmdet3d.models import apply_3d_transformation\n    img = raw_img.copy()\n    img_metas = copy.deepcopy(img_metas)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    xyz_depth = apply_3d_transformation(points_3d, 'DEPTH', img_metas, reverse=True)\n    uv_origin = points_cam2img(xyz_depth, xyz_depth.new_tensor(img_metas['depth2img']))\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
        "mutated": [
            "def draw_depth_bbox3d_on_img(bboxes3d, raw_img, calibs, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`DepthInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in depth coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        calibs (dict): Camera calibration information, Rt and K.\\n        img_metas (dict): Used in coordinates transformation.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    from mmdet3d.models import apply_3d_transformation\n    img = raw_img.copy()\n    img_metas = copy.deepcopy(img_metas)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    xyz_depth = apply_3d_transformation(points_3d, 'DEPTH', img_metas, reverse=True)\n    uv_origin = points_cam2img(xyz_depth, xyz_depth.new_tensor(img_metas['depth2img']))\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_depth_bbox3d_on_img(bboxes3d, raw_img, calibs, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`DepthInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in depth coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        calibs (dict): Camera calibration information, Rt and K.\\n        img_metas (dict): Used in coordinates transformation.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    from mmdet3d.models import apply_3d_transformation\n    img = raw_img.copy()\n    img_metas = copy.deepcopy(img_metas)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    xyz_depth = apply_3d_transformation(points_3d, 'DEPTH', img_metas, reverse=True)\n    uv_origin = points_cam2img(xyz_depth, xyz_depth.new_tensor(img_metas['depth2img']))\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_depth_bbox3d_on_img(bboxes3d, raw_img, calibs, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`DepthInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in depth coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        calibs (dict): Camera calibration information, Rt and K.\\n        img_metas (dict): Used in coordinates transformation.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    from mmdet3d.models import apply_3d_transformation\n    img = raw_img.copy()\n    img_metas = copy.deepcopy(img_metas)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    xyz_depth = apply_3d_transformation(points_3d, 'DEPTH', img_metas, reverse=True)\n    uv_origin = points_cam2img(xyz_depth, xyz_depth.new_tensor(img_metas['depth2img']))\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_depth_bbox3d_on_img(bboxes3d, raw_img, calibs, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`DepthInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in depth coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        calibs (dict): Camera calibration information, Rt and K.\\n        img_metas (dict): Used in coordinates transformation.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    from mmdet3d.models import apply_3d_transformation\n    img = raw_img.copy()\n    img_metas = copy.deepcopy(img_metas)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    xyz_depth = apply_3d_transformation(points_3d, 'DEPTH', img_metas, reverse=True)\n    uv_origin = points_cam2img(xyz_depth, xyz_depth.new_tensor(img_metas['depth2img']))\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_depth_bbox3d_on_img(bboxes3d, raw_img, calibs, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`DepthInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in depth coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        calibs (dict): Camera calibration information, Rt and K.\\n        img_metas (dict): Used in coordinates transformation.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    from mmdet3d.models import apply_3d_transformation\n    img = raw_img.copy()\n    img_metas = copy.deepcopy(img_metas)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    xyz_depth = apply_3d_transformation(points_3d, 'DEPTH', img_metas, reverse=True)\n    uv_origin = points_cam2img(xyz_depth, xyz_depth.new_tensor(img_metas['depth2img']))\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)"
        ]
    },
    {
        "func_name": "draw_camera_bbox3d_on_img",
        "original": "def draw_camera_bbox3d_on_img(bboxes3d, raw_img, cam2img, img_metas, color=(0, 255, 0), thickness=1):\n    \"\"\"Project the 3D bbox on 2D plane and draw on input image.\n\n    Args:\n        bboxes3d (:obj:`CameraInstance3DBoxes`, shape=[M, 7]):\n            3d bbox in camera coordinate system to visualize.\n        raw_img (numpy.array): The numpy array of image.\n        cam2img (dict): Camera intrinsic matrix,\n            denoted as `K` in depth bbox coordinate system.\n        img_metas (dict): Useless here.\n        color (tuple[int], optional): The color to draw bboxes.\n            Default: (0, 255, 0).\n        thickness (int, optional): The thickness of bboxes. Default: 1.\n    \"\"\"\n    from mmdet3d.core.bbox import points_cam2img\n    img = raw_img.copy()\n    cam2img = copy.deepcopy(cam2img)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    if not isinstance(cam2img, torch.Tensor):\n        cam2img = torch.from_numpy(np.array(cam2img))\n    assert cam2img.shape == torch.Size([3, 3]) or cam2img.shape == torch.Size([4, 4])\n    cam2img = cam2img.float().cpu()\n    uv_origin = points_cam2img(points_3d, cam2img)\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
        "mutated": [
            "def draw_camera_bbox3d_on_img(bboxes3d, raw_img, cam2img, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`CameraInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in camera coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        cam2img (dict): Camera intrinsic matrix,\\n            denoted as `K` in depth bbox coordinate system.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    img = raw_img.copy()\n    cam2img = copy.deepcopy(cam2img)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    if not isinstance(cam2img, torch.Tensor):\n        cam2img = torch.from_numpy(np.array(cam2img))\n    assert cam2img.shape == torch.Size([3, 3]) or cam2img.shape == torch.Size([4, 4])\n    cam2img = cam2img.float().cpu()\n    uv_origin = points_cam2img(points_3d, cam2img)\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_camera_bbox3d_on_img(bboxes3d, raw_img, cam2img, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`CameraInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in camera coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        cam2img (dict): Camera intrinsic matrix,\\n            denoted as `K` in depth bbox coordinate system.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    img = raw_img.copy()\n    cam2img = copy.deepcopy(cam2img)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    if not isinstance(cam2img, torch.Tensor):\n        cam2img = torch.from_numpy(np.array(cam2img))\n    assert cam2img.shape == torch.Size([3, 3]) or cam2img.shape == torch.Size([4, 4])\n    cam2img = cam2img.float().cpu()\n    uv_origin = points_cam2img(points_3d, cam2img)\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_camera_bbox3d_on_img(bboxes3d, raw_img, cam2img, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`CameraInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in camera coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        cam2img (dict): Camera intrinsic matrix,\\n            denoted as `K` in depth bbox coordinate system.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    img = raw_img.copy()\n    cam2img = copy.deepcopy(cam2img)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    if not isinstance(cam2img, torch.Tensor):\n        cam2img = torch.from_numpy(np.array(cam2img))\n    assert cam2img.shape == torch.Size([3, 3]) or cam2img.shape == torch.Size([4, 4])\n    cam2img = cam2img.float().cpu()\n    uv_origin = points_cam2img(points_3d, cam2img)\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_camera_bbox3d_on_img(bboxes3d, raw_img, cam2img, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`CameraInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in camera coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        cam2img (dict): Camera intrinsic matrix,\\n            denoted as `K` in depth bbox coordinate system.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    img = raw_img.copy()\n    cam2img = copy.deepcopy(cam2img)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    if not isinstance(cam2img, torch.Tensor):\n        cam2img = torch.from_numpy(np.array(cam2img))\n    assert cam2img.shape == torch.Size([3, 3]) or cam2img.shape == torch.Size([4, 4])\n    cam2img = cam2img.float().cpu()\n    uv_origin = points_cam2img(points_3d, cam2img)\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)",
            "def draw_camera_bbox3d_on_img(bboxes3d, raw_img, cam2img, img_metas, color=(0, 255, 0), thickness=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Project the 3D bbox on 2D plane and draw on input image.\\n\\n    Args:\\n        bboxes3d (:obj:`CameraInstance3DBoxes`, shape=[M, 7]):\\n            3d bbox in camera coordinate system to visualize.\\n        raw_img (numpy.array): The numpy array of image.\\n        cam2img (dict): Camera intrinsic matrix,\\n            denoted as `K` in depth bbox coordinate system.\\n        img_metas (dict): Useless here.\\n        color (tuple[int], optional): The color to draw bboxes.\\n            Default: (0, 255, 0).\\n        thickness (int, optional): The thickness of bboxes. Default: 1.\\n    '\n    from mmdet3d.core.bbox import points_cam2img\n    img = raw_img.copy()\n    cam2img = copy.deepcopy(cam2img)\n    corners_3d = bboxes3d.corners\n    num_bbox = corners_3d.shape[0]\n    points_3d = corners_3d.reshape(-1, 3)\n    if not isinstance(cam2img, torch.Tensor):\n        cam2img = torch.from_numpy(np.array(cam2img))\n    assert cam2img.shape == torch.Size([3, 3]) or cam2img.shape == torch.Size([4, 4])\n    cam2img = cam2img.float().cpu()\n    uv_origin = points_cam2img(points_3d, cam2img)\n    uv_origin = (uv_origin - 1).round()\n    imgfov_pts_2d = uv_origin[..., :2].reshape(num_bbox, 8, 2).numpy()\n    return plot_rect3d_on_img(img, num_bbox, imgfov_pts_2d, color, thickness)"
        ]
    }
]