[
    {
        "func_name": "_fprop_slice_np",
        "original": "def _fprop_slice_np(h, stride, H, roi_offset):\n    \"\"\"\n    slicing in this 1 dimension\n    h: is the index on the pooled map (output index)\n    stride:\n    H: the max of the input map\n    roi_offset: how far hstart is from 0\n    \"\"\"\n    hstart = int(np.floor(float(h) * stride))\n    hend = int(np.ceil(float(h + 1) * stride))\n    hstart = min(max(hstart + roi_offset, 0), H)\n    hend = min(max(hend + roi_offset, 0), H)\n    return (slice(hstart, hend), hend - hstart)",
        "mutated": [
            "def _fprop_slice_np(h, stride, H, roi_offset):\n    if False:\n        i = 10\n    '\\n    slicing in this 1 dimension\\n    h: is the index on the pooled map (output index)\\n    stride:\\n    H: the max of the input map\\n    roi_offset: how far hstart is from 0\\n    '\n    hstart = int(np.floor(float(h) * stride))\n    hend = int(np.ceil(float(h + 1) * stride))\n    hstart = min(max(hstart + roi_offset, 0), H)\n    hend = min(max(hend + roi_offset, 0), H)\n    return (slice(hstart, hend), hend - hstart)",
            "def _fprop_slice_np(h, stride, H, roi_offset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    slicing in this 1 dimension\\n    h: is the index on the pooled map (output index)\\n    stride:\\n    H: the max of the input map\\n    roi_offset: how far hstart is from 0\\n    '\n    hstart = int(np.floor(float(h) * stride))\n    hend = int(np.ceil(float(h + 1) * stride))\n    hstart = min(max(hstart + roi_offset, 0), H)\n    hend = min(max(hend + roi_offset, 0), H)\n    return (slice(hstart, hend), hend - hstart)",
            "def _fprop_slice_np(h, stride, H, roi_offset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    slicing in this 1 dimension\\n    h: is the index on the pooled map (output index)\\n    stride:\\n    H: the max of the input map\\n    roi_offset: how far hstart is from 0\\n    '\n    hstart = int(np.floor(float(h) * stride))\n    hend = int(np.ceil(float(h + 1) * stride))\n    hstart = min(max(hstart + roi_offset, 0), H)\n    hend = min(max(hend + roi_offset, 0), H)\n    return (slice(hstart, hend), hend - hstart)",
            "def _fprop_slice_np(h, stride, H, roi_offset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    slicing in this 1 dimension\\n    h: is the index on the pooled map (output index)\\n    stride:\\n    H: the max of the input map\\n    roi_offset: how far hstart is from 0\\n    '\n    hstart = int(np.floor(float(h) * stride))\n    hend = int(np.ceil(float(h + 1) * stride))\n    hstart = min(max(hstart + roi_offset, 0), H)\n    hend = min(max(hend + roi_offset, 0), H)\n    return (slice(hstart, hend), hend - hstart)",
            "def _fprop_slice_np(h, stride, H, roi_offset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    slicing in this 1 dimension\\n    h: is the index on the pooled map (output index)\\n    stride:\\n    H: the max of the input map\\n    roi_offset: how far hstart is from 0\\n    '\n    hstart = int(np.floor(float(h) * stride))\n    hend = int(np.ceil(float(h + 1) * stride))\n    hstart = min(max(hstart + roi_offset, 0), H)\n    hend = min(max(hend + roi_offset, 0), H)\n    return (slice(hstart, hend), hend - hstart)"
        ]
    },
    {
        "func_name": "pytest_generate_tests",
        "original": "def pytest_generate_tests(metafunc):\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        bsz_rng = [2]\n        roi_num_rng = [2]\n        img_fm_c_rng = [2]\n        img_fm_h_rng = [62]\n        img_fm_w_rng = [62]\n        roi_size_rng = [6]\n        fargs = itt.product(roi_num_rng, img_fm_c_rng, img_fm_h_rng, img_fm_w_rng, roi_size_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
        "mutated": [
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        bsz_rng = [2]\n        roi_num_rng = [2]\n        img_fm_c_rng = [2]\n        img_fm_h_rng = [62]\n        img_fm_w_rng = [62]\n        roi_size_rng = [6]\n        fargs = itt.product(roi_num_rng, img_fm_c_rng, img_fm_h_rng, img_fm_w_rng, roi_size_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        bsz_rng = [2]\n        roi_num_rng = [2]\n        img_fm_c_rng = [2]\n        img_fm_h_rng = [62]\n        img_fm_w_rng = [62]\n        roi_size_rng = [6]\n        fargs = itt.product(roi_num_rng, img_fm_c_rng, img_fm_h_rng, img_fm_w_rng, roi_size_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        bsz_rng = [2]\n        roi_num_rng = [2]\n        img_fm_c_rng = [2]\n        img_fm_h_rng = [62]\n        img_fm_w_rng = [62]\n        roi_size_rng = [6]\n        fargs = itt.product(roi_num_rng, img_fm_c_rng, img_fm_h_rng, img_fm_w_rng, roi_size_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        bsz_rng = [2]\n        roi_num_rng = [2]\n        img_fm_c_rng = [2]\n        img_fm_h_rng = [62]\n        img_fm_w_rng = [62]\n        roi_size_rng = [6]\n        fargs = itt.product(roi_num_rng, img_fm_c_rng, img_fm_h_rng, img_fm_w_rng, roi_size_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        bsz_rng = [2]\n        roi_num_rng = [2]\n        img_fm_c_rng = [2]\n        img_fm_h_rng = [62]\n        img_fm_w_rng = [62]\n        roi_size_rng = [6]\n        fargs = itt.product(roi_num_rng, img_fm_c_rng, img_fm_h_rng, img_fm_w_rng, roi_size_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)"
        ]
    },
    {
        "func_name": "bprop_roipooling_ref",
        "original": "def bprop_roipooling_ref(fm, rois, error, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    \"\"\"\n    Function to perform a bprop of ROIPooling. It uses a different way from the\n    that in CPU backend\n    \"\"\"\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    error_in = error.reshape(fm_channel, H, W, rois_per_batch)\n    delta = np.zeros(feature_maps.shape).reshape(fm_channel, fm_height, fm_width, bsz)\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / float(H)\n        stride_w = float(roi_width) / float(W)\n        for h_out in range(H):\n            (sliceh, lenh) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, lenw) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    max_idx = np.argmax(array_I, axis=1)\n                    delta_view = delta[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    delta_view[list(range(fm_channel)), max_idx] += error_in[:, h_out, w_out, b_id]\n                    delta[:, sliceh, slicew, int(idx)] = delta_view.reshape(fm_channel, lenh, lenw)\n    return delta",
        "mutated": [
            "def bprop_roipooling_ref(fm, rois, error, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n    '\\n    Function to perform a bprop of ROIPooling. It uses a different way from the\\n    that in CPU backend\\n    '\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    error_in = error.reshape(fm_channel, H, W, rois_per_batch)\n    delta = np.zeros(feature_maps.shape).reshape(fm_channel, fm_height, fm_width, bsz)\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / float(H)\n        stride_w = float(roi_width) / float(W)\n        for h_out in range(H):\n            (sliceh, lenh) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, lenw) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    max_idx = np.argmax(array_I, axis=1)\n                    delta_view = delta[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    delta_view[list(range(fm_channel)), max_idx] += error_in[:, h_out, w_out, b_id]\n                    delta[:, sliceh, slicew, int(idx)] = delta_view.reshape(fm_channel, lenh, lenw)\n    return delta",
            "def bprop_roipooling_ref(fm, rois, error, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Function to perform a bprop of ROIPooling. It uses a different way from the\\n    that in CPU backend\\n    '\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    error_in = error.reshape(fm_channel, H, W, rois_per_batch)\n    delta = np.zeros(feature_maps.shape).reshape(fm_channel, fm_height, fm_width, bsz)\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / float(H)\n        stride_w = float(roi_width) / float(W)\n        for h_out in range(H):\n            (sliceh, lenh) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, lenw) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    max_idx = np.argmax(array_I, axis=1)\n                    delta_view = delta[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    delta_view[list(range(fm_channel)), max_idx] += error_in[:, h_out, w_out, b_id]\n                    delta[:, sliceh, slicew, int(idx)] = delta_view.reshape(fm_channel, lenh, lenw)\n    return delta",
            "def bprop_roipooling_ref(fm, rois, error, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Function to perform a bprop of ROIPooling. It uses a different way from the\\n    that in CPU backend\\n    '\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    error_in = error.reshape(fm_channel, H, W, rois_per_batch)\n    delta = np.zeros(feature_maps.shape).reshape(fm_channel, fm_height, fm_width, bsz)\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / float(H)\n        stride_w = float(roi_width) / float(W)\n        for h_out in range(H):\n            (sliceh, lenh) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, lenw) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    max_idx = np.argmax(array_I, axis=1)\n                    delta_view = delta[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    delta_view[list(range(fm_channel)), max_idx] += error_in[:, h_out, w_out, b_id]\n                    delta[:, sliceh, slicew, int(idx)] = delta_view.reshape(fm_channel, lenh, lenw)\n    return delta",
            "def bprop_roipooling_ref(fm, rois, error, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Function to perform a bprop of ROIPooling. It uses a different way from the\\n    that in CPU backend\\n    '\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    error_in = error.reshape(fm_channel, H, W, rois_per_batch)\n    delta = np.zeros(feature_maps.shape).reshape(fm_channel, fm_height, fm_width, bsz)\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / float(H)\n        stride_w = float(roi_width) / float(W)\n        for h_out in range(H):\n            (sliceh, lenh) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, lenw) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    max_idx = np.argmax(array_I, axis=1)\n                    delta_view = delta[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    delta_view[list(range(fm_channel)), max_idx] += error_in[:, h_out, w_out, b_id]\n                    delta[:, sliceh, slicew, int(idx)] = delta_view.reshape(fm_channel, lenh, lenw)\n    return delta",
            "def bprop_roipooling_ref(fm, rois, error, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Function to perform a bprop of ROIPooling. It uses a different way from the\\n    that in CPU backend\\n    '\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    error_in = error.reshape(fm_channel, H, W, rois_per_batch)\n    delta = np.zeros(feature_maps.shape).reshape(fm_channel, fm_height, fm_width, bsz)\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / float(H)\n        stride_w = float(roi_width) / float(W)\n        for h_out in range(H):\n            (sliceh, lenh) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, lenw) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    max_idx = np.argmax(array_I, axis=1)\n                    delta_view = delta[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    delta_view[list(range(fm_channel)), max_idx] += error_in[:, h_out, w_out, b_id]\n                    delta[:, sliceh, slicew, int(idx)] = delta_view.reshape(fm_channel, lenh, lenw)\n    return delta"
        ]
    },
    {
        "func_name": "fprop_roipooling_ref",
        "original": "def fprop_roipooling_ref(fm, rois, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    outputs = np.zeros((fm_channel, H, W, rois_per_batch))\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / H\n        stride_w = float(roi_width) / W\n        for h_out in range(H):\n            (sliceh, _) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, _) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    outputs[:, h_out, w_out, b_id] = np.max(array_I, axis=1)\n    return outputs.reshape(-1, rois_per_batch)",
        "mutated": [
            "def fprop_roipooling_ref(fm, rois, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    outputs = np.zeros((fm_channel, H, W, rois_per_batch))\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / H\n        stride_w = float(roi_width) / W\n        for h_out in range(H):\n            (sliceh, _) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, _) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    outputs[:, h_out, w_out, b_id] = np.max(array_I, axis=1)\n    return outputs.reshape(-1, rois_per_batch)",
            "def fprop_roipooling_ref(fm, rois, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    outputs = np.zeros((fm_channel, H, W, rois_per_batch))\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / H\n        stride_w = float(roi_width) / W\n        for h_out in range(H):\n            (sliceh, _) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, _) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    outputs[:, h_out, w_out, b_id] = np.max(array_I, axis=1)\n    return outputs.reshape(-1, rois_per_batch)",
            "def fprop_roipooling_ref(fm, rois, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    outputs = np.zeros((fm_channel, H, W, rois_per_batch))\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / H\n        stride_w = float(roi_width) / W\n        for h_out in range(H):\n            (sliceh, _) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, _) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    outputs[:, h_out, w_out, b_id] = np.max(array_I, axis=1)\n    return outputs.reshape(-1, rois_per_batch)",
            "def fprop_roipooling_ref(fm, rois, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    outputs = np.zeros((fm_channel, H, W, rois_per_batch))\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / H\n        stride_w = float(roi_width) / W\n        for h_out in range(H):\n            (sliceh, _) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, _) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    outputs[:, h_out, w_out, b_id] = np.max(array_I, axis=1)\n    return outputs.reshape(-1, rois_per_batch)",
            "def fprop_roipooling_ref(fm, rois, fm_channel, fm_height, fm_width, bsz, rois_per_image, H, W):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    feature_maps = fm.reshape(fm_channel, fm_height, fm_width, bsz)\n    rois_per_batch = rois_per_image * bsz\n    outputs = np.zeros((fm_channel, H, W, rois_per_batch))\n    for b_id in range(rois_per_batch):\n        [idx, xmin, ymin, xmax, ymax] = rois[b_id]\n        xmin = int(round(xmin * spatial_scale))\n        xmax = int(round(xmax * spatial_scale))\n        ymin = int(round(ymin * spatial_scale))\n        ymax = int(round(ymax * spatial_scale))\n        roi_width = max(xmax - xmin + 1, 1)\n        roi_height = max(ymax - ymin + 1, 1)\n        stride_h = float(roi_height) / H\n        stride_w = float(roi_width) / W\n        for h_out in range(H):\n            (sliceh, _) = _fprop_slice_np(h_out, stride_h, fm_height, ymin)\n            if sliceh.stop <= sliceh.start:\n                continue\n            for w_out in range(W):\n                (slicew, _) = _fprop_slice_np(w_out, stride_w, fm_width, xmin)\n                if slicew.stop <= slicew.start:\n                    continue\n                else:\n                    array_I = feature_maps[:, sliceh, slicew, int(idx)].reshape(fm_channel, -1)\n                    outputs[:, h_out, w_out, b_id] = np.max(array_I, axis=1)\n    return outputs.reshape(-1, rois_per_batch)"
        ]
    },
    {
        "func_name": "test_roipooling_fprop_random",
        "original": "def test_roipooling_fprop_random(backend_default, fargs):\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    feature_maps = np.random.random((img_fm_c, img_fm_h, img_fm_w, bsz)).reshape(-1, bsz)\n    rois_per_batch = rois_per_image * bsz\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.random.random((rois_per_batch,)) * 10 / spatial_scale\n    rois[:, 1] = np.random.random((rois_per_batch,)) * 25 / spatial_scale\n    rois[:, 2] = (np.random.random((rois_per_batch,)) * 27 + (img_fm_w - 27)) / spatial_scale\n    rois[:, 3] = (np.random.random((rois_per_batch,)) * 12 + (img_fm_h - 12)) / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape)\n    argmax_dev = be.zeros(output_shape, np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    outputs_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
        "mutated": [
            "def test_roipooling_fprop_random(backend_default, fargs):\n    if False:\n        i = 10\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    feature_maps = np.random.random((img_fm_c, img_fm_h, img_fm_w, bsz)).reshape(-1, bsz)\n    rois_per_batch = rois_per_image * bsz\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.random.random((rois_per_batch,)) * 10 / spatial_scale\n    rois[:, 1] = np.random.random((rois_per_batch,)) * 25 / spatial_scale\n    rois[:, 2] = (np.random.random((rois_per_batch,)) * 27 + (img_fm_w - 27)) / spatial_scale\n    rois[:, 3] = (np.random.random((rois_per_batch,)) * 12 + (img_fm_h - 12)) / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape)\n    argmax_dev = be.zeros(output_shape, np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    outputs_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
            "def test_roipooling_fprop_random(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    feature_maps = np.random.random((img_fm_c, img_fm_h, img_fm_w, bsz)).reshape(-1, bsz)\n    rois_per_batch = rois_per_image * bsz\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.random.random((rois_per_batch,)) * 10 / spatial_scale\n    rois[:, 1] = np.random.random((rois_per_batch,)) * 25 / spatial_scale\n    rois[:, 2] = (np.random.random((rois_per_batch,)) * 27 + (img_fm_w - 27)) / spatial_scale\n    rois[:, 3] = (np.random.random((rois_per_batch,)) * 12 + (img_fm_h - 12)) / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape)\n    argmax_dev = be.zeros(output_shape, np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    outputs_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
            "def test_roipooling_fprop_random(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    feature_maps = np.random.random((img_fm_c, img_fm_h, img_fm_w, bsz)).reshape(-1, bsz)\n    rois_per_batch = rois_per_image * bsz\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.random.random((rois_per_batch,)) * 10 / spatial_scale\n    rois[:, 1] = np.random.random((rois_per_batch,)) * 25 / spatial_scale\n    rois[:, 2] = (np.random.random((rois_per_batch,)) * 27 + (img_fm_w - 27)) / spatial_scale\n    rois[:, 3] = (np.random.random((rois_per_batch,)) * 12 + (img_fm_h - 12)) / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape)\n    argmax_dev = be.zeros(output_shape, np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    outputs_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
            "def test_roipooling_fprop_random(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    feature_maps = np.random.random((img_fm_c, img_fm_h, img_fm_w, bsz)).reshape(-1, bsz)\n    rois_per_batch = rois_per_image * bsz\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.random.random((rois_per_batch,)) * 10 / spatial_scale\n    rois[:, 1] = np.random.random((rois_per_batch,)) * 25 / spatial_scale\n    rois[:, 2] = (np.random.random((rois_per_batch,)) * 27 + (img_fm_w - 27)) / spatial_scale\n    rois[:, 3] = (np.random.random((rois_per_batch,)) * 12 + (img_fm_h - 12)) / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape)\n    argmax_dev = be.zeros(output_shape, np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    outputs_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
            "def test_roipooling_fprop_random(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    feature_maps = np.random.random((img_fm_c, img_fm_h, img_fm_w, bsz)).reshape(-1, bsz)\n    rois_per_batch = rois_per_image * bsz\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.random.random((rois_per_batch,)) * 10 / spatial_scale\n    rois[:, 1] = np.random.random((rois_per_batch,)) * 25 / spatial_scale\n    rois[:, 2] = (np.random.random((rois_per_batch,)) * 27 + (img_fm_w - 27)) / spatial_scale\n    rois[:, 3] = (np.random.random((rois_per_batch,)) * 12 + (img_fm_h - 12)) / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape)\n    argmax_dev = be.zeros(output_shape, np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    outputs_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)"
        ]
    },
    {
        "func_name": "test_roipooling_fprop_ref",
        "original": "def test_roipooling_fprop_ref(backend_default, rois=None, inputs=None, outputs_ref=None):\n    if rois is None and inputs is None and (outputs_ref is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = outputs_ref.shape\n    outputs_ref_in = outputs_ref.reshape(rois_per_batch, -1).T\n    rois_per_image = rois_per_batch // bsz\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    assert allclose_with_out(outputs_ref_in, outputs_np, atol=1e-06, rtol=0)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_backend = outputs_dev.get().reshape(-1, rois_per_batch)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    assert allclose_with_out(outputs_ref_in, outputs_backend, atol=1e-06, rtol=0)",
        "mutated": [
            "def test_roipooling_fprop_ref(backend_default, rois=None, inputs=None, outputs_ref=None):\n    if False:\n        i = 10\n    if rois is None and inputs is None and (outputs_ref is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = outputs_ref.shape\n    outputs_ref_in = outputs_ref.reshape(rois_per_batch, -1).T\n    rois_per_image = rois_per_batch // bsz\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    assert allclose_with_out(outputs_ref_in, outputs_np, atol=1e-06, rtol=0)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_backend = outputs_dev.get().reshape(-1, rois_per_batch)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    assert allclose_with_out(outputs_ref_in, outputs_backend, atol=1e-06, rtol=0)",
            "def test_roipooling_fprop_ref(backend_default, rois=None, inputs=None, outputs_ref=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if rois is None and inputs is None and (outputs_ref is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = outputs_ref.shape\n    outputs_ref_in = outputs_ref.reshape(rois_per_batch, -1).T\n    rois_per_image = rois_per_batch // bsz\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    assert allclose_with_out(outputs_ref_in, outputs_np, atol=1e-06, rtol=0)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_backend = outputs_dev.get().reshape(-1, rois_per_batch)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    assert allclose_with_out(outputs_ref_in, outputs_backend, atol=1e-06, rtol=0)",
            "def test_roipooling_fprop_ref(backend_default, rois=None, inputs=None, outputs_ref=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if rois is None and inputs is None and (outputs_ref is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = outputs_ref.shape\n    outputs_ref_in = outputs_ref.reshape(rois_per_batch, -1).T\n    rois_per_image = rois_per_batch // bsz\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    assert allclose_with_out(outputs_ref_in, outputs_np, atol=1e-06, rtol=0)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_backend = outputs_dev.get().reshape(-1, rois_per_batch)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    assert allclose_with_out(outputs_ref_in, outputs_backend, atol=1e-06, rtol=0)",
            "def test_roipooling_fprop_ref(backend_default, rois=None, inputs=None, outputs_ref=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if rois is None and inputs is None and (outputs_ref is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = outputs_ref.shape\n    outputs_ref_in = outputs_ref.reshape(rois_per_batch, -1).T\n    rois_per_image = rois_per_batch // bsz\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    assert allclose_with_out(outputs_ref_in, outputs_np, atol=1e-06, rtol=0)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_backend = outputs_dev.get().reshape(-1, rois_per_batch)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    assert allclose_with_out(outputs_ref_in, outputs_backend, atol=1e-06, rtol=0)",
            "def test_roipooling_fprop_ref(backend_default, rois=None, inputs=None, outputs_ref=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if rois is None and inputs is None and (outputs_ref is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = outputs_ref.shape\n    outputs_ref_in = outputs_ref.reshape(rois_per_batch, -1).T\n    rois_per_image = rois_per_batch // bsz\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    outputs_np = fprop_roipooling_ref(feature_maps, rois, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    assert allclose_with_out(outputs_ref_in, outputs_np, atol=1e-06, rtol=0)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    start_time = timeit()\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_backend = outputs_dev.get().reshape(-1, rois_per_batch)\n    neon_logger.display('Nervana backend roipooling fprop (sec): {}'.format(timeit() - start_time))\n    assert allclose_with_out(outputs_ref_in, outputs_backend, atol=1e-06, rtol=0)"
        ]
    },
    {
        "func_name": "test_roipooling_bprop_random",
        "original": "def test_roipooling_bprop_random(backend_default, fargs):\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    rois_per_batch = rois_per_image * bsz\n    feature_map_size = img_fm_c * img_fm_h * img_fm_w * bsz\n    feature_maps = np.array(list(range(feature_map_size))).reshape((img_fm_c, img_fm_h, img_fm_w, bsz))\n    input_errors = np.zeros((img_fm_c, roi_size, roi_size, rois_per_batch))\n    range_num = roi_size * roi_size\n    input_errors[0, :, :, rois_per_batch - 1] = np.array(list(range(range_num))).reshape(input_errors[0, :, :, rois_per_batch - 1].shape)\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.ones((rois_per_batch,))\n    rois[:, 1] = np.ones((rois_per_batch,))\n    rois[:, 2] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois[:, 3] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = bprop_roipooling_ref(feature_maps, rois, input_errors, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors)\n    output_error_dev = be.zeros(feature_maps.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling bprop (sec): {}'.format(timeit() - start_time))\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, 0].sum() == 0\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, -1].sum() != 0\n    assert output_error_dev.get().sum() == input_errors.sum()\n    outputs_be = output_error_dev.get()\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
        "mutated": [
            "def test_roipooling_bprop_random(backend_default, fargs):\n    if False:\n        i = 10\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    rois_per_batch = rois_per_image * bsz\n    feature_map_size = img_fm_c * img_fm_h * img_fm_w * bsz\n    feature_maps = np.array(list(range(feature_map_size))).reshape((img_fm_c, img_fm_h, img_fm_w, bsz))\n    input_errors = np.zeros((img_fm_c, roi_size, roi_size, rois_per_batch))\n    range_num = roi_size * roi_size\n    input_errors[0, :, :, rois_per_batch - 1] = np.array(list(range(range_num))).reshape(input_errors[0, :, :, rois_per_batch - 1].shape)\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.ones((rois_per_batch,))\n    rois[:, 1] = np.ones((rois_per_batch,))\n    rois[:, 2] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois[:, 3] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = bprop_roipooling_ref(feature_maps, rois, input_errors, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors)\n    output_error_dev = be.zeros(feature_maps.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling bprop (sec): {}'.format(timeit() - start_time))\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, 0].sum() == 0\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, -1].sum() != 0\n    assert output_error_dev.get().sum() == input_errors.sum()\n    outputs_be = output_error_dev.get()\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
            "def test_roipooling_bprop_random(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    rois_per_batch = rois_per_image * bsz\n    feature_map_size = img_fm_c * img_fm_h * img_fm_w * bsz\n    feature_maps = np.array(list(range(feature_map_size))).reshape((img_fm_c, img_fm_h, img_fm_w, bsz))\n    input_errors = np.zeros((img_fm_c, roi_size, roi_size, rois_per_batch))\n    range_num = roi_size * roi_size\n    input_errors[0, :, :, rois_per_batch - 1] = np.array(list(range(range_num))).reshape(input_errors[0, :, :, rois_per_batch - 1].shape)\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.ones((rois_per_batch,))\n    rois[:, 1] = np.ones((rois_per_batch,))\n    rois[:, 2] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois[:, 3] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = bprop_roipooling_ref(feature_maps, rois, input_errors, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors)\n    output_error_dev = be.zeros(feature_maps.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling bprop (sec): {}'.format(timeit() - start_time))\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, 0].sum() == 0\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, -1].sum() != 0\n    assert output_error_dev.get().sum() == input_errors.sum()\n    outputs_be = output_error_dev.get()\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
            "def test_roipooling_bprop_random(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    rois_per_batch = rois_per_image * bsz\n    feature_map_size = img_fm_c * img_fm_h * img_fm_w * bsz\n    feature_maps = np.array(list(range(feature_map_size))).reshape((img_fm_c, img_fm_h, img_fm_w, bsz))\n    input_errors = np.zeros((img_fm_c, roi_size, roi_size, rois_per_batch))\n    range_num = roi_size * roi_size\n    input_errors[0, :, :, rois_per_batch - 1] = np.array(list(range(range_num))).reshape(input_errors[0, :, :, rois_per_batch - 1].shape)\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.ones((rois_per_batch,))\n    rois[:, 1] = np.ones((rois_per_batch,))\n    rois[:, 2] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois[:, 3] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = bprop_roipooling_ref(feature_maps, rois, input_errors, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors)\n    output_error_dev = be.zeros(feature_maps.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling bprop (sec): {}'.format(timeit() - start_time))\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, 0].sum() == 0\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, -1].sum() != 0\n    assert output_error_dev.get().sum() == input_errors.sum()\n    outputs_be = output_error_dev.get()\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
            "def test_roipooling_bprop_random(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    rois_per_batch = rois_per_image * bsz\n    feature_map_size = img_fm_c * img_fm_h * img_fm_w * bsz\n    feature_maps = np.array(list(range(feature_map_size))).reshape((img_fm_c, img_fm_h, img_fm_w, bsz))\n    input_errors = np.zeros((img_fm_c, roi_size, roi_size, rois_per_batch))\n    range_num = roi_size * roi_size\n    input_errors[0, :, :, rois_per_batch - 1] = np.array(list(range(range_num))).reshape(input_errors[0, :, :, rois_per_batch - 1].shape)\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.ones((rois_per_batch,))\n    rois[:, 1] = np.ones((rois_per_batch,))\n    rois[:, 2] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois[:, 3] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = bprop_roipooling_ref(feature_maps, rois, input_errors, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors)\n    output_error_dev = be.zeros(feature_maps.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling bprop (sec): {}'.format(timeit() - start_time))\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, 0].sum() == 0\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, -1].sum() != 0\n    assert output_error_dev.get().sum() == input_errors.sum()\n    outputs_be = output_error_dev.get()\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)",
            "def test_roipooling_bprop_random(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (rois_per_image, img_fm_c, img_fm_h, img_fm_w, roi_size, bsz) = fargs\n    rois_per_batch = rois_per_image * bsz\n    feature_map_size = img_fm_c * img_fm_h * img_fm_w * bsz\n    feature_maps = np.array(list(range(feature_map_size))).reshape((img_fm_c, img_fm_h, img_fm_w, bsz))\n    input_errors = np.zeros((img_fm_c, roi_size, roi_size, rois_per_batch))\n    range_num = roi_size * roi_size\n    input_errors[0, :, :, rois_per_batch - 1] = np.array(list(range(range_num))).reshape(input_errors[0, :, :, rois_per_batch - 1].shape)\n    rois_idx = np.vstack([i * np.ones((rois_per_image, 1)) for i in range(bsz)])\n    rois = np.random.random((rois_per_batch, 4)) * min(img_fm_h, img_fm_w)\n    rois = np.zeros((rois_per_batch, 4))\n    rois[:, 0] = np.ones((rois_per_batch,))\n    rois[:, 1] = np.ones((rois_per_batch,))\n    rois[:, 2] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois[:, 3] = np.ones((rois_per_batch,)) * img_fm_w / spatial_scale\n    rois = np.hstack((rois_idx, rois))\n    outputs_np = bprop_roipooling_ref(feature_maps, rois, input_errors, img_fm_c, img_fm_h, img_fm_w, bsz, rois_per_image, roi_size, roi_size)\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors)\n    output_error_dev = be.zeros(feature_maps.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('Nervana backend roipooling bprop (sec): {}'.format(timeit() - start_time))\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, 0].sum() == 0\n    assert output_error_dev.get().reshape(img_fm_c, img_fm_h, img_fm_w, bsz)[:, :, :, -1].sum() != 0\n    assert output_error_dev.get().sum() == input_errors.sum()\n    outputs_be = output_error_dev.get()\n    assert allclose_with_out(outputs_np, outputs_be, atol=1e-06, rtol=0)"
        ]
    },
    {
        "func_name": "test_roipooling_bprop_ref",
        "original": "def test_roipooling_bprop_ref(backend_default, rois=None, inputs=None, outputs_fprop_ref=None, input_errors=None):\n    if rois is None and inputs is None and (outputs_fprop_ref is None) and (input_errors is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = input_errors.shape\n    outputs_fprop_ref_in = outputs_fprop_ref.reshape(rois_per_batch, -1).T\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    input_errors_in = input_errors.reshape(rois_per_batch, -1).T.astype(np.float, order='C')\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors_in)\n    output_error_dev = be.zeros(outputs_fprop_ref_in.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_fprop_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_fprop_be, atol=1e-06, rtol=0)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('NervanaGPU roipooling bprop (sec): {}'.format(timeit() - start_time))\n    outputs_backend = output_error_dev.get()\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_backend, atol=1e-06, rtol=0)",
        "mutated": [
            "def test_roipooling_bprop_ref(backend_default, rois=None, inputs=None, outputs_fprop_ref=None, input_errors=None):\n    if False:\n        i = 10\n    if rois is None and inputs is None and (outputs_fprop_ref is None) and (input_errors is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = input_errors.shape\n    outputs_fprop_ref_in = outputs_fprop_ref.reshape(rois_per_batch, -1).T\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    input_errors_in = input_errors.reshape(rois_per_batch, -1).T.astype(np.float, order='C')\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors_in)\n    output_error_dev = be.zeros(outputs_fprop_ref_in.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_fprop_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_fprop_be, atol=1e-06, rtol=0)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('NervanaGPU roipooling bprop (sec): {}'.format(timeit() - start_time))\n    outputs_backend = output_error_dev.get()\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_backend, atol=1e-06, rtol=0)",
            "def test_roipooling_bprop_ref(backend_default, rois=None, inputs=None, outputs_fprop_ref=None, input_errors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if rois is None and inputs is None and (outputs_fprop_ref is None) and (input_errors is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = input_errors.shape\n    outputs_fprop_ref_in = outputs_fprop_ref.reshape(rois_per_batch, -1).T\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    input_errors_in = input_errors.reshape(rois_per_batch, -1).T.astype(np.float, order='C')\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors_in)\n    output_error_dev = be.zeros(outputs_fprop_ref_in.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_fprop_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_fprop_be, atol=1e-06, rtol=0)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('NervanaGPU roipooling bprop (sec): {}'.format(timeit() - start_time))\n    outputs_backend = output_error_dev.get()\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_backend, atol=1e-06, rtol=0)",
            "def test_roipooling_bprop_ref(backend_default, rois=None, inputs=None, outputs_fprop_ref=None, input_errors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if rois is None and inputs is None and (outputs_fprop_ref is None) and (input_errors is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = input_errors.shape\n    outputs_fprop_ref_in = outputs_fprop_ref.reshape(rois_per_batch, -1).T\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    input_errors_in = input_errors.reshape(rois_per_batch, -1).T.astype(np.float, order='C')\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors_in)\n    output_error_dev = be.zeros(outputs_fprop_ref_in.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_fprop_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_fprop_be, atol=1e-06, rtol=0)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('NervanaGPU roipooling bprop (sec): {}'.format(timeit() - start_time))\n    outputs_backend = output_error_dev.get()\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_backend, atol=1e-06, rtol=0)",
            "def test_roipooling_bprop_ref(backend_default, rois=None, inputs=None, outputs_fprop_ref=None, input_errors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if rois is None and inputs is None and (outputs_fprop_ref is None) and (input_errors is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = input_errors.shape\n    outputs_fprop_ref_in = outputs_fprop_ref.reshape(rois_per_batch, -1).T\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    input_errors_in = input_errors.reshape(rois_per_batch, -1).T.astype(np.float, order='C')\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors_in)\n    output_error_dev = be.zeros(outputs_fprop_ref_in.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_fprop_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_fprop_be, atol=1e-06, rtol=0)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('NervanaGPU roipooling bprop (sec): {}'.format(timeit() - start_time))\n    outputs_backend = output_error_dev.get()\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_backend, atol=1e-06, rtol=0)",
            "def test_roipooling_bprop_ref(backend_default, rois=None, inputs=None, outputs_fprop_ref=None, input_errors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if rois is None and inputs is None and (outputs_fprop_ref is None) and (input_errors is None):\n        return\n    (bsz, img_fm_c, img_fm_h, img_fm_w) = inputs.shape\n    (rois_per_batch, _, roi_size, _) = input_errors.shape\n    outputs_fprop_ref_in = outputs_fprop_ref.reshape(rois_per_batch, -1).T\n    feature_maps = inputs.reshape(bsz, -1).T.astype(np.float, order='C')\n    input_errors_in = input_errors.reshape(rois_per_batch, -1).T.astype(np.float, order='C')\n    NervanaObject.be.bsz = bsz\n    be = NervanaObject.be\n    input_dev = be.array(feature_maps)\n    rois_dev = be.array(rois)\n    output_shape = (img_fm_c, roi_size, roi_size, rois_per_batch)\n    outputs_dev = be.zeros(output_shape, dtype=np.float32)\n    argmax_dev = be.zeros(output_shape, dtype=np.int32)\n    input_error_dev = be.array(input_errors_in)\n    output_error_dev = be.zeros(outputs_fprop_ref_in.shape)\n    be.roipooling_fprop(input_dev, rois_dev, outputs_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    outputs_fprop_be = outputs_dev.get().reshape(-1, rois_per_batch)\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_fprop_be, atol=1e-06, rtol=0)\n    start_time = timeit()\n    be.roipooling_bprop(input_error_dev, rois_dev, output_error_dev, argmax_dev, rois_per_batch, img_fm_c, img_fm_h, img_fm_w, roi_size, roi_size, spatial_scale)\n    neon_logger.display('NervanaGPU roipooling bprop (sec): {}'.format(timeit() - start_time))\n    outputs_backend = output_error_dev.get()\n    assert allclose_with_out(outputs_fprop_ref_in, outputs_backend, atol=1e-06, rtol=0)"
        ]
    }
]