[
    {
        "func_name": "GenerateTrainingBlocks",
        "original": "def GenerateTrainingBlocks(data_folder, gt_folder, dataset_path='./dataset', M=256, N=256):\n    print(data_folder)\n    print('Generating training blocks!!!')\n    train_path = dataset_path + '/' + data_folder + '_Trainblocks'\n    if not os.path.exists(train_path):\n        os.makedirs(train_path)\n    train_filenames = train_path + '/train_block_names.txt'\n    f = open(train_filenames, 'w')\n    data_path = dataset_path + '/' + data_folder\n    gt_path = dataset_path + '/' + gt_folder\n    print(data_path)\n    filenames = getListOfFiles(data_path)\n    cnt = 0\n    print(filenames)\n    for name in tqdm(filenames):\n        print(name)\n        gt_filename = gt_path + '/' + name\n        in_filename = data_path + '/' + name\n        print(gt_filename)\n        print(in_filename)\n        gt_image_initial = cv2.imread(gt_filename)\n        in_image_initial = cv2.imread(in_filename)\n        print(gt_image_initial.shape, in_image_initial.shape)\n        for scale in [0.7, 1.0, 1.4]:\n            gt_image = ImageResize(gt_image_initial, scale)\n            in_image = ImageResize(in_image_initial, scale)\n            (h, w, c) = in_image.shape\n            gt_img = GetOverlappingBlocks(gt_image, Part=8)\n            in_img = GetOverlappingBlocks(in_image, Part=8)\n            for i in range(len(gt_img)):\n                train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                cv2.imwrite(train_img_path, in_img[i])\n                cv2.imwrite(gt_img_path, gt_img[i])\n                t_name = 'block_' + str(cnt) + '.png'\n                f.write(t_name)\n                f.write('\\n')\n                cnt += 1\n            Random_Block_Number_PerImage = int(len(gt_img) / 5)\n            for i in range(Random_Block_Number_PerImage):\n                if in_image.shape[0] - M > 1 and in_image.shape[1] - N > 1:\n                    y = random.randint(1, in_image.shape[0] - M)\n                    x = random.randint(1, in_image.shape[1] - N)\n                    in_part_img = in_image[y:y + M, x:x + N, :].copy()\n                    gt_part_img = gt_image[y:y + M, x:x + N, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n                else:\n                    break\n                    in_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    gt_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    in_part_img[:, :, :] = 255\n                    gt_part_img[:, :, :] = 255\n                    if in_image.shape[0] - M <= 1 and in_image.shape[1] - N > 1:\n                        y = 0\n                        x = random.randint(1, in_image.shape[1] - N)\n                        in_part_img[:h, :, :] = in_image[:, x:x + N, :].copy()\n                        gt_part_img[:h, :, :] = gt_image[:, x:x + N, :].copy()\n                    if in_image.shape[0] - M > 1 and in_image.shape[1] - N <= 1:\n                        x = 0\n                        y = random.randint(1, in_image.shape[0] - M)\n                        in_part_img[:, :w, :] = in_image[y:y + M, :, :].copy()\n                        gt_part_img[:, :w, :] = gt_image[y:y + M, :, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n    f.close()\n    print('Total number of training blocks generated: ', cnt)\n    return (train_path, train_filenames)",
        "mutated": [
            "def GenerateTrainingBlocks(data_folder, gt_folder, dataset_path='./dataset', M=256, N=256):\n    if False:\n        i = 10\n    print(data_folder)\n    print('Generating training blocks!!!')\n    train_path = dataset_path + '/' + data_folder + '_Trainblocks'\n    if not os.path.exists(train_path):\n        os.makedirs(train_path)\n    train_filenames = train_path + '/train_block_names.txt'\n    f = open(train_filenames, 'w')\n    data_path = dataset_path + '/' + data_folder\n    gt_path = dataset_path + '/' + gt_folder\n    print(data_path)\n    filenames = getListOfFiles(data_path)\n    cnt = 0\n    print(filenames)\n    for name in tqdm(filenames):\n        print(name)\n        gt_filename = gt_path + '/' + name\n        in_filename = data_path + '/' + name\n        print(gt_filename)\n        print(in_filename)\n        gt_image_initial = cv2.imread(gt_filename)\n        in_image_initial = cv2.imread(in_filename)\n        print(gt_image_initial.shape, in_image_initial.shape)\n        for scale in [0.7, 1.0, 1.4]:\n            gt_image = ImageResize(gt_image_initial, scale)\n            in_image = ImageResize(in_image_initial, scale)\n            (h, w, c) = in_image.shape\n            gt_img = GetOverlappingBlocks(gt_image, Part=8)\n            in_img = GetOverlappingBlocks(in_image, Part=8)\n            for i in range(len(gt_img)):\n                train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                cv2.imwrite(train_img_path, in_img[i])\n                cv2.imwrite(gt_img_path, gt_img[i])\n                t_name = 'block_' + str(cnt) + '.png'\n                f.write(t_name)\n                f.write('\\n')\n                cnt += 1\n            Random_Block_Number_PerImage = int(len(gt_img) / 5)\n            for i in range(Random_Block_Number_PerImage):\n                if in_image.shape[0] - M > 1 and in_image.shape[1] - N > 1:\n                    y = random.randint(1, in_image.shape[0] - M)\n                    x = random.randint(1, in_image.shape[1] - N)\n                    in_part_img = in_image[y:y + M, x:x + N, :].copy()\n                    gt_part_img = gt_image[y:y + M, x:x + N, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n                else:\n                    break\n                    in_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    gt_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    in_part_img[:, :, :] = 255\n                    gt_part_img[:, :, :] = 255\n                    if in_image.shape[0] - M <= 1 and in_image.shape[1] - N > 1:\n                        y = 0\n                        x = random.randint(1, in_image.shape[1] - N)\n                        in_part_img[:h, :, :] = in_image[:, x:x + N, :].copy()\n                        gt_part_img[:h, :, :] = gt_image[:, x:x + N, :].copy()\n                    if in_image.shape[0] - M > 1 and in_image.shape[1] - N <= 1:\n                        x = 0\n                        y = random.randint(1, in_image.shape[0] - M)\n                        in_part_img[:, :w, :] = in_image[y:y + M, :, :].copy()\n                        gt_part_img[:, :w, :] = gt_image[y:y + M, :, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n    f.close()\n    print('Total number of training blocks generated: ', cnt)\n    return (train_path, train_filenames)",
            "def GenerateTrainingBlocks(data_folder, gt_folder, dataset_path='./dataset', M=256, N=256):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print(data_folder)\n    print('Generating training blocks!!!')\n    train_path = dataset_path + '/' + data_folder + '_Trainblocks'\n    if not os.path.exists(train_path):\n        os.makedirs(train_path)\n    train_filenames = train_path + '/train_block_names.txt'\n    f = open(train_filenames, 'w')\n    data_path = dataset_path + '/' + data_folder\n    gt_path = dataset_path + '/' + gt_folder\n    print(data_path)\n    filenames = getListOfFiles(data_path)\n    cnt = 0\n    print(filenames)\n    for name in tqdm(filenames):\n        print(name)\n        gt_filename = gt_path + '/' + name\n        in_filename = data_path + '/' + name\n        print(gt_filename)\n        print(in_filename)\n        gt_image_initial = cv2.imread(gt_filename)\n        in_image_initial = cv2.imread(in_filename)\n        print(gt_image_initial.shape, in_image_initial.shape)\n        for scale in [0.7, 1.0, 1.4]:\n            gt_image = ImageResize(gt_image_initial, scale)\n            in_image = ImageResize(in_image_initial, scale)\n            (h, w, c) = in_image.shape\n            gt_img = GetOverlappingBlocks(gt_image, Part=8)\n            in_img = GetOverlappingBlocks(in_image, Part=8)\n            for i in range(len(gt_img)):\n                train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                cv2.imwrite(train_img_path, in_img[i])\n                cv2.imwrite(gt_img_path, gt_img[i])\n                t_name = 'block_' + str(cnt) + '.png'\n                f.write(t_name)\n                f.write('\\n')\n                cnt += 1\n            Random_Block_Number_PerImage = int(len(gt_img) / 5)\n            for i in range(Random_Block_Number_PerImage):\n                if in_image.shape[0] - M > 1 and in_image.shape[1] - N > 1:\n                    y = random.randint(1, in_image.shape[0] - M)\n                    x = random.randint(1, in_image.shape[1] - N)\n                    in_part_img = in_image[y:y + M, x:x + N, :].copy()\n                    gt_part_img = gt_image[y:y + M, x:x + N, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n                else:\n                    break\n                    in_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    gt_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    in_part_img[:, :, :] = 255\n                    gt_part_img[:, :, :] = 255\n                    if in_image.shape[0] - M <= 1 and in_image.shape[1] - N > 1:\n                        y = 0\n                        x = random.randint(1, in_image.shape[1] - N)\n                        in_part_img[:h, :, :] = in_image[:, x:x + N, :].copy()\n                        gt_part_img[:h, :, :] = gt_image[:, x:x + N, :].copy()\n                    if in_image.shape[0] - M > 1 and in_image.shape[1] - N <= 1:\n                        x = 0\n                        y = random.randint(1, in_image.shape[0] - M)\n                        in_part_img[:, :w, :] = in_image[y:y + M, :, :].copy()\n                        gt_part_img[:, :w, :] = gt_image[y:y + M, :, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n    f.close()\n    print('Total number of training blocks generated: ', cnt)\n    return (train_path, train_filenames)",
            "def GenerateTrainingBlocks(data_folder, gt_folder, dataset_path='./dataset', M=256, N=256):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print(data_folder)\n    print('Generating training blocks!!!')\n    train_path = dataset_path + '/' + data_folder + '_Trainblocks'\n    if not os.path.exists(train_path):\n        os.makedirs(train_path)\n    train_filenames = train_path + '/train_block_names.txt'\n    f = open(train_filenames, 'w')\n    data_path = dataset_path + '/' + data_folder\n    gt_path = dataset_path + '/' + gt_folder\n    print(data_path)\n    filenames = getListOfFiles(data_path)\n    cnt = 0\n    print(filenames)\n    for name in tqdm(filenames):\n        print(name)\n        gt_filename = gt_path + '/' + name\n        in_filename = data_path + '/' + name\n        print(gt_filename)\n        print(in_filename)\n        gt_image_initial = cv2.imread(gt_filename)\n        in_image_initial = cv2.imread(in_filename)\n        print(gt_image_initial.shape, in_image_initial.shape)\n        for scale in [0.7, 1.0, 1.4]:\n            gt_image = ImageResize(gt_image_initial, scale)\n            in_image = ImageResize(in_image_initial, scale)\n            (h, w, c) = in_image.shape\n            gt_img = GetOverlappingBlocks(gt_image, Part=8)\n            in_img = GetOverlappingBlocks(in_image, Part=8)\n            for i in range(len(gt_img)):\n                train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                cv2.imwrite(train_img_path, in_img[i])\n                cv2.imwrite(gt_img_path, gt_img[i])\n                t_name = 'block_' + str(cnt) + '.png'\n                f.write(t_name)\n                f.write('\\n')\n                cnt += 1\n            Random_Block_Number_PerImage = int(len(gt_img) / 5)\n            for i in range(Random_Block_Number_PerImage):\n                if in_image.shape[0] - M > 1 and in_image.shape[1] - N > 1:\n                    y = random.randint(1, in_image.shape[0] - M)\n                    x = random.randint(1, in_image.shape[1] - N)\n                    in_part_img = in_image[y:y + M, x:x + N, :].copy()\n                    gt_part_img = gt_image[y:y + M, x:x + N, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n                else:\n                    break\n                    in_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    gt_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    in_part_img[:, :, :] = 255\n                    gt_part_img[:, :, :] = 255\n                    if in_image.shape[0] - M <= 1 and in_image.shape[1] - N > 1:\n                        y = 0\n                        x = random.randint(1, in_image.shape[1] - N)\n                        in_part_img[:h, :, :] = in_image[:, x:x + N, :].copy()\n                        gt_part_img[:h, :, :] = gt_image[:, x:x + N, :].copy()\n                    if in_image.shape[0] - M > 1 and in_image.shape[1] - N <= 1:\n                        x = 0\n                        y = random.randint(1, in_image.shape[0] - M)\n                        in_part_img[:, :w, :] = in_image[y:y + M, :, :].copy()\n                        gt_part_img[:, :w, :] = gt_image[y:y + M, :, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n    f.close()\n    print('Total number of training blocks generated: ', cnt)\n    return (train_path, train_filenames)",
            "def GenerateTrainingBlocks(data_folder, gt_folder, dataset_path='./dataset', M=256, N=256):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print(data_folder)\n    print('Generating training blocks!!!')\n    train_path = dataset_path + '/' + data_folder + '_Trainblocks'\n    if not os.path.exists(train_path):\n        os.makedirs(train_path)\n    train_filenames = train_path + '/train_block_names.txt'\n    f = open(train_filenames, 'w')\n    data_path = dataset_path + '/' + data_folder\n    gt_path = dataset_path + '/' + gt_folder\n    print(data_path)\n    filenames = getListOfFiles(data_path)\n    cnt = 0\n    print(filenames)\n    for name in tqdm(filenames):\n        print(name)\n        gt_filename = gt_path + '/' + name\n        in_filename = data_path + '/' + name\n        print(gt_filename)\n        print(in_filename)\n        gt_image_initial = cv2.imread(gt_filename)\n        in_image_initial = cv2.imread(in_filename)\n        print(gt_image_initial.shape, in_image_initial.shape)\n        for scale in [0.7, 1.0, 1.4]:\n            gt_image = ImageResize(gt_image_initial, scale)\n            in_image = ImageResize(in_image_initial, scale)\n            (h, w, c) = in_image.shape\n            gt_img = GetOverlappingBlocks(gt_image, Part=8)\n            in_img = GetOverlappingBlocks(in_image, Part=8)\n            for i in range(len(gt_img)):\n                train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                cv2.imwrite(train_img_path, in_img[i])\n                cv2.imwrite(gt_img_path, gt_img[i])\n                t_name = 'block_' + str(cnt) + '.png'\n                f.write(t_name)\n                f.write('\\n')\n                cnt += 1\n            Random_Block_Number_PerImage = int(len(gt_img) / 5)\n            for i in range(Random_Block_Number_PerImage):\n                if in_image.shape[0] - M > 1 and in_image.shape[1] - N > 1:\n                    y = random.randint(1, in_image.shape[0] - M)\n                    x = random.randint(1, in_image.shape[1] - N)\n                    in_part_img = in_image[y:y + M, x:x + N, :].copy()\n                    gt_part_img = gt_image[y:y + M, x:x + N, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n                else:\n                    break\n                    in_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    gt_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    in_part_img[:, :, :] = 255\n                    gt_part_img[:, :, :] = 255\n                    if in_image.shape[0] - M <= 1 and in_image.shape[1] - N > 1:\n                        y = 0\n                        x = random.randint(1, in_image.shape[1] - N)\n                        in_part_img[:h, :, :] = in_image[:, x:x + N, :].copy()\n                        gt_part_img[:h, :, :] = gt_image[:, x:x + N, :].copy()\n                    if in_image.shape[0] - M > 1 and in_image.shape[1] - N <= 1:\n                        x = 0\n                        y = random.randint(1, in_image.shape[0] - M)\n                        in_part_img[:, :w, :] = in_image[y:y + M, :, :].copy()\n                        gt_part_img[:, :w, :] = gt_image[y:y + M, :, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n    f.close()\n    print('Total number of training blocks generated: ', cnt)\n    return (train_path, train_filenames)",
            "def GenerateTrainingBlocks(data_folder, gt_folder, dataset_path='./dataset', M=256, N=256):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print(data_folder)\n    print('Generating training blocks!!!')\n    train_path = dataset_path + '/' + data_folder + '_Trainblocks'\n    if not os.path.exists(train_path):\n        os.makedirs(train_path)\n    train_filenames = train_path + '/train_block_names.txt'\n    f = open(train_filenames, 'w')\n    data_path = dataset_path + '/' + data_folder\n    gt_path = dataset_path + '/' + gt_folder\n    print(data_path)\n    filenames = getListOfFiles(data_path)\n    cnt = 0\n    print(filenames)\n    for name in tqdm(filenames):\n        print(name)\n        gt_filename = gt_path + '/' + name\n        in_filename = data_path + '/' + name\n        print(gt_filename)\n        print(in_filename)\n        gt_image_initial = cv2.imread(gt_filename)\n        in_image_initial = cv2.imread(in_filename)\n        print(gt_image_initial.shape, in_image_initial.shape)\n        for scale in [0.7, 1.0, 1.4]:\n            gt_image = ImageResize(gt_image_initial, scale)\n            in_image = ImageResize(in_image_initial, scale)\n            (h, w, c) = in_image.shape\n            gt_img = GetOverlappingBlocks(gt_image, Part=8)\n            in_img = GetOverlappingBlocks(in_image, Part=8)\n            for i in range(len(gt_img)):\n                train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                cv2.imwrite(train_img_path, in_img[i])\n                cv2.imwrite(gt_img_path, gt_img[i])\n                t_name = 'block_' + str(cnt) + '.png'\n                f.write(t_name)\n                f.write('\\n')\n                cnt += 1\n            Random_Block_Number_PerImage = int(len(gt_img) / 5)\n            for i in range(Random_Block_Number_PerImage):\n                if in_image.shape[0] - M > 1 and in_image.shape[1] - N > 1:\n                    y = random.randint(1, in_image.shape[0] - M)\n                    x = random.randint(1, in_image.shape[1] - N)\n                    in_part_img = in_image[y:y + M, x:x + N, :].copy()\n                    gt_part_img = gt_image[y:y + M, x:x + N, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n                else:\n                    break\n                    in_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    gt_part_img = np.zeros((M, N, 3), dtype=np.uint8)\n                    in_part_img[:, :, :] = 255\n                    gt_part_img[:, :, :] = 255\n                    if in_image.shape[0] - M <= 1 and in_image.shape[1] - N > 1:\n                        y = 0\n                        x = random.randint(1, in_image.shape[1] - N)\n                        in_part_img[:h, :, :] = in_image[:, x:x + N, :].copy()\n                        gt_part_img[:h, :, :] = gt_image[:, x:x + N, :].copy()\n                    if in_image.shape[0] - M > 1 and in_image.shape[1] - N <= 1:\n                        x = 0\n                        y = random.randint(1, in_image.shape[0] - M)\n                        in_part_img[:, :w, :] = in_image[y:y + M, :, :].copy()\n                        gt_part_img[:, :w, :] = gt_image[y:y + M, :, :].copy()\n                    train_img_path = train_path + '/block_' + str(cnt) + '.png'\n                    gt_img_path = train_path + '/gtblock_' + str(cnt) + '.png'\n                    in_part_img = cv2.cvtColor(in_part_img, cv2.COLOR_BGR2RGB)\n                    augmented_image = transform(image=in_part_img)['image']\n                    augmented_image = cv2.cvtColor(augmented_image, cv2.COLOR_RGB2BGR)\n                    cv2.imwrite(train_img_path, augmented_image)\n                    cv2.imwrite(gt_img_path, gt_part_img)\n                    t_name = 'block_' + str(cnt) + '.png'\n                    f.write(t_name)\n                    f.write('\\n')\n                    cnt += 1\n    f.close()\n    print('Total number of training blocks generated: ', cnt)\n    return (train_path, train_filenames)"
        ]
    }
]