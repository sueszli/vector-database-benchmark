[
    {
        "func_name": "read_aggregation",
        "original": "def read_aggregation(filename):\n    assert os.path.isfile(filename)\n    object_id_to_segs = {}\n    label_to_segs = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_objects = len(data['segGroups'])\n        for i in range(num_objects):\n            object_id = data['segGroups'][i]['objectId'] + 1\n            label = data['segGroups'][i]['label']\n            segs = data['segGroups'][i]['segments']\n            object_id_to_segs[object_id] = segs\n            if label in label_to_segs:\n                label_to_segs[label].extend(segs)\n            else:\n                label_to_segs[label] = segs\n    return (object_id_to_segs, label_to_segs)",
        "mutated": [
            "def read_aggregation(filename):\n    if False:\n        i = 10\n    assert os.path.isfile(filename)\n    object_id_to_segs = {}\n    label_to_segs = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_objects = len(data['segGroups'])\n        for i in range(num_objects):\n            object_id = data['segGroups'][i]['objectId'] + 1\n            label = data['segGroups'][i]['label']\n            segs = data['segGroups'][i]['segments']\n            object_id_to_segs[object_id] = segs\n            if label in label_to_segs:\n                label_to_segs[label].extend(segs)\n            else:\n                label_to_segs[label] = segs\n    return (object_id_to_segs, label_to_segs)",
            "def read_aggregation(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert os.path.isfile(filename)\n    object_id_to_segs = {}\n    label_to_segs = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_objects = len(data['segGroups'])\n        for i in range(num_objects):\n            object_id = data['segGroups'][i]['objectId'] + 1\n            label = data['segGroups'][i]['label']\n            segs = data['segGroups'][i]['segments']\n            object_id_to_segs[object_id] = segs\n            if label in label_to_segs:\n                label_to_segs[label].extend(segs)\n            else:\n                label_to_segs[label] = segs\n    return (object_id_to_segs, label_to_segs)",
            "def read_aggregation(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert os.path.isfile(filename)\n    object_id_to_segs = {}\n    label_to_segs = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_objects = len(data['segGroups'])\n        for i in range(num_objects):\n            object_id = data['segGroups'][i]['objectId'] + 1\n            label = data['segGroups'][i]['label']\n            segs = data['segGroups'][i]['segments']\n            object_id_to_segs[object_id] = segs\n            if label in label_to_segs:\n                label_to_segs[label].extend(segs)\n            else:\n                label_to_segs[label] = segs\n    return (object_id_to_segs, label_to_segs)",
            "def read_aggregation(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert os.path.isfile(filename)\n    object_id_to_segs = {}\n    label_to_segs = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_objects = len(data['segGroups'])\n        for i in range(num_objects):\n            object_id = data['segGroups'][i]['objectId'] + 1\n            label = data['segGroups'][i]['label']\n            segs = data['segGroups'][i]['segments']\n            object_id_to_segs[object_id] = segs\n            if label in label_to_segs:\n                label_to_segs[label].extend(segs)\n            else:\n                label_to_segs[label] = segs\n    return (object_id_to_segs, label_to_segs)",
            "def read_aggregation(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert os.path.isfile(filename)\n    object_id_to_segs = {}\n    label_to_segs = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_objects = len(data['segGroups'])\n        for i in range(num_objects):\n            object_id = data['segGroups'][i]['objectId'] + 1\n            label = data['segGroups'][i]['label']\n            segs = data['segGroups'][i]['segments']\n            object_id_to_segs[object_id] = segs\n            if label in label_to_segs:\n                label_to_segs[label].extend(segs)\n            else:\n                label_to_segs[label] = segs\n    return (object_id_to_segs, label_to_segs)"
        ]
    },
    {
        "func_name": "read_segmentation",
        "original": "def read_segmentation(filename):\n    assert os.path.isfile(filename)\n    seg_to_verts = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_verts = len(data['segIndices'])\n        for i in range(num_verts):\n            seg_id = data['segIndices'][i]\n            if seg_id in seg_to_verts:\n                seg_to_verts[seg_id].append(i)\n            else:\n                seg_to_verts[seg_id] = [i]\n    return (seg_to_verts, num_verts)",
        "mutated": [
            "def read_segmentation(filename):\n    if False:\n        i = 10\n    assert os.path.isfile(filename)\n    seg_to_verts = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_verts = len(data['segIndices'])\n        for i in range(num_verts):\n            seg_id = data['segIndices'][i]\n            if seg_id in seg_to_verts:\n                seg_to_verts[seg_id].append(i)\n            else:\n                seg_to_verts[seg_id] = [i]\n    return (seg_to_verts, num_verts)",
            "def read_segmentation(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert os.path.isfile(filename)\n    seg_to_verts = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_verts = len(data['segIndices'])\n        for i in range(num_verts):\n            seg_id = data['segIndices'][i]\n            if seg_id in seg_to_verts:\n                seg_to_verts[seg_id].append(i)\n            else:\n                seg_to_verts[seg_id] = [i]\n    return (seg_to_verts, num_verts)",
            "def read_segmentation(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert os.path.isfile(filename)\n    seg_to_verts = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_verts = len(data['segIndices'])\n        for i in range(num_verts):\n            seg_id = data['segIndices'][i]\n            if seg_id in seg_to_verts:\n                seg_to_verts[seg_id].append(i)\n            else:\n                seg_to_verts[seg_id] = [i]\n    return (seg_to_verts, num_verts)",
            "def read_segmentation(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert os.path.isfile(filename)\n    seg_to_verts = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_verts = len(data['segIndices'])\n        for i in range(num_verts):\n            seg_id = data['segIndices'][i]\n            if seg_id in seg_to_verts:\n                seg_to_verts[seg_id].append(i)\n            else:\n                seg_to_verts[seg_id] = [i]\n    return (seg_to_verts, num_verts)",
            "def read_segmentation(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert os.path.isfile(filename)\n    seg_to_verts = {}\n    with open(filename) as f:\n        data = json.load(f)\n        num_verts = len(data['segIndices'])\n        for i in range(num_verts):\n            seg_id = data['segIndices'][i]\n            if seg_id in seg_to_verts:\n                seg_to_verts[seg_id].append(i)\n            else:\n                seg_to_verts[seg_id] = [i]\n    return (seg_to_verts, num_verts)"
        ]
    },
    {
        "func_name": "extract_bbox",
        "original": "def extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids):\n    num_instances = len(np.unique(list(object_id_to_segs.keys())))\n    instance_bboxes = np.zeros((num_instances, 7))\n    for obj_id in object_id_to_segs:\n        label_id = object_id_to_label_id[obj_id]\n        obj_pc = mesh_vertices[instance_ids == obj_id, 0:3]\n        if len(obj_pc) == 0:\n            continue\n        xyz_min = np.min(obj_pc, axis=0)\n        xyz_max = np.max(obj_pc, axis=0)\n        bbox = np.concatenate([(xyz_min + xyz_max) / 2.0, xyz_max - xyz_min, np.array([label_id])])\n        instance_bboxes[obj_id - 1, :] = bbox\n    return instance_bboxes",
        "mutated": [
            "def extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids):\n    if False:\n        i = 10\n    num_instances = len(np.unique(list(object_id_to_segs.keys())))\n    instance_bboxes = np.zeros((num_instances, 7))\n    for obj_id in object_id_to_segs:\n        label_id = object_id_to_label_id[obj_id]\n        obj_pc = mesh_vertices[instance_ids == obj_id, 0:3]\n        if len(obj_pc) == 0:\n            continue\n        xyz_min = np.min(obj_pc, axis=0)\n        xyz_max = np.max(obj_pc, axis=0)\n        bbox = np.concatenate([(xyz_min + xyz_max) / 2.0, xyz_max - xyz_min, np.array([label_id])])\n        instance_bboxes[obj_id - 1, :] = bbox\n    return instance_bboxes",
            "def extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num_instances = len(np.unique(list(object_id_to_segs.keys())))\n    instance_bboxes = np.zeros((num_instances, 7))\n    for obj_id in object_id_to_segs:\n        label_id = object_id_to_label_id[obj_id]\n        obj_pc = mesh_vertices[instance_ids == obj_id, 0:3]\n        if len(obj_pc) == 0:\n            continue\n        xyz_min = np.min(obj_pc, axis=0)\n        xyz_max = np.max(obj_pc, axis=0)\n        bbox = np.concatenate([(xyz_min + xyz_max) / 2.0, xyz_max - xyz_min, np.array([label_id])])\n        instance_bboxes[obj_id - 1, :] = bbox\n    return instance_bboxes",
            "def extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num_instances = len(np.unique(list(object_id_to_segs.keys())))\n    instance_bboxes = np.zeros((num_instances, 7))\n    for obj_id in object_id_to_segs:\n        label_id = object_id_to_label_id[obj_id]\n        obj_pc = mesh_vertices[instance_ids == obj_id, 0:3]\n        if len(obj_pc) == 0:\n            continue\n        xyz_min = np.min(obj_pc, axis=0)\n        xyz_max = np.max(obj_pc, axis=0)\n        bbox = np.concatenate([(xyz_min + xyz_max) / 2.0, xyz_max - xyz_min, np.array([label_id])])\n        instance_bboxes[obj_id - 1, :] = bbox\n    return instance_bboxes",
            "def extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num_instances = len(np.unique(list(object_id_to_segs.keys())))\n    instance_bboxes = np.zeros((num_instances, 7))\n    for obj_id in object_id_to_segs:\n        label_id = object_id_to_label_id[obj_id]\n        obj_pc = mesh_vertices[instance_ids == obj_id, 0:3]\n        if len(obj_pc) == 0:\n            continue\n        xyz_min = np.min(obj_pc, axis=0)\n        xyz_max = np.max(obj_pc, axis=0)\n        bbox = np.concatenate([(xyz_min + xyz_max) / 2.0, xyz_max - xyz_min, np.array([label_id])])\n        instance_bboxes[obj_id - 1, :] = bbox\n    return instance_bboxes",
            "def extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num_instances = len(np.unique(list(object_id_to_segs.keys())))\n    instance_bboxes = np.zeros((num_instances, 7))\n    for obj_id in object_id_to_segs:\n        label_id = object_id_to_label_id[obj_id]\n        obj_pc = mesh_vertices[instance_ids == obj_id, 0:3]\n        if len(obj_pc) == 0:\n            continue\n        xyz_min = np.min(obj_pc, axis=0)\n        xyz_max = np.max(obj_pc, axis=0)\n        bbox = np.concatenate([(xyz_min + xyz_max) / 2.0, xyz_max - xyz_min, np.array([label_id])])\n        instance_bboxes[obj_id - 1, :] = bbox\n    return instance_bboxes"
        ]
    },
    {
        "func_name": "export",
        "original": "def export(mesh_file, agg_file, seg_file, meta_file, label_map_file, output_file=None, test_mode=False):\n    \"\"\"Export original files to vert, ins_label, sem_label and bbox file.\n\n    Args:\n        mesh_file (str): Path of the mesh_file.\n        agg_file (str): Path of the agg_file.\n        seg_file (str): Path of the seg_file.\n        meta_file (str): Path of the meta_file.\n        label_map_file (str): Path of the label_map_file.\n        output_file (str): Path of the output folder.\n            Default: None.\n        test_mode (bool): Whether is generating test data without labels.\n            Default: False.\n\n    It returns a tuple, which contains the the following things:\n        np.ndarray: Vertices of points data.\n        np.ndarray: Indexes of label.\n        np.ndarray: Indexes of instance.\n        np.ndarray: Instance bboxes.\n        dict: Map from object_id to label_id.\n    \"\"\"\n    label_map = scannet_utils.read_label_mapping(label_map_file, label_from='raw_category', label_to='nyu40id')\n    mesh_vertices = scannet_utils.read_mesh_vertices_rgb(mesh_file)\n    lines = open(meta_file).readlines()\n    axis_align_matrix = np.eye(4)\n    for line in lines:\n        if 'axisAlignment' in line:\n            axis_align_matrix = [float(x) for x in line.rstrip().strip('axisAlignment = ').split(' ')]\n            break\n    axis_align_matrix = np.array(axis_align_matrix).reshape((4, 4))\n    pts = np.ones((mesh_vertices.shape[0], 4))\n    pts[:, 0:3] = mesh_vertices[:, 0:3]\n    pts = np.dot(pts, axis_align_matrix.transpose())\n    aligned_mesh_vertices = np.concatenate([pts[:, 0:3], mesh_vertices[:, 3:]], axis=1)\n    if not test_mode:\n        (object_id_to_segs, label_to_segs) = read_aggregation(agg_file)\n        (seg_to_verts, num_verts) = read_segmentation(seg_file)\n        label_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        object_id_to_label_id = {}\n        for (label, segs) in label_to_segs.items():\n            label_id = label_map[label]\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                label_ids[verts] = label_id\n        instance_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        for (object_id, segs) in object_id_to_segs.items():\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                instance_ids[verts] = object_id\n                if object_id not in object_id_to_label_id:\n                    object_id_to_label_id[object_id] = label_ids[verts][0]\n        unaligned_bboxes = extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n        aligned_bboxes = extract_bbox(aligned_mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n    else:\n        label_ids = None\n        instance_ids = None\n        unaligned_bboxes = None\n        aligned_bboxes = None\n        object_id_to_label_id = None\n    if output_file is not None:\n        np.save(output_file + '_vert.npy', mesh_vertices)\n        if not test_mode:\n            np.save(output_file + '_sem_label.npy', label_ids)\n            np.save(output_file + '_ins_label.npy', instance_ids)\n            np.save(output_file + '_unaligned_bbox.npy', unaligned_bboxes)\n            np.save(output_file + '_aligned_bbox.npy', aligned_bboxes)\n            np.save(output_file + '_axis_align_matrix.npy', axis_align_matrix)\n    return (mesh_vertices, label_ids, instance_ids, unaligned_bboxes, aligned_bboxes, object_id_to_label_id, axis_align_matrix)",
        "mutated": [
            "def export(mesh_file, agg_file, seg_file, meta_file, label_map_file, output_file=None, test_mode=False):\n    if False:\n        i = 10\n    'Export original files to vert, ins_label, sem_label and bbox file.\\n\\n    Args:\\n        mesh_file (str): Path of the mesh_file.\\n        agg_file (str): Path of the agg_file.\\n        seg_file (str): Path of the seg_file.\\n        meta_file (str): Path of the meta_file.\\n        label_map_file (str): Path of the label_map_file.\\n        output_file (str): Path of the output folder.\\n            Default: None.\\n        test_mode (bool): Whether is generating test data without labels.\\n            Default: False.\\n\\n    It returns a tuple, which contains the the following things:\\n        np.ndarray: Vertices of points data.\\n        np.ndarray: Indexes of label.\\n        np.ndarray: Indexes of instance.\\n        np.ndarray: Instance bboxes.\\n        dict: Map from object_id to label_id.\\n    '\n    label_map = scannet_utils.read_label_mapping(label_map_file, label_from='raw_category', label_to='nyu40id')\n    mesh_vertices = scannet_utils.read_mesh_vertices_rgb(mesh_file)\n    lines = open(meta_file).readlines()\n    axis_align_matrix = np.eye(4)\n    for line in lines:\n        if 'axisAlignment' in line:\n            axis_align_matrix = [float(x) for x in line.rstrip().strip('axisAlignment = ').split(' ')]\n            break\n    axis_align_matrix = np.array(axis_align_matrix).reshape((4, 4))\n    pts = np.ones((mesh_vertices.shape[0], 4))\n    pts[:, 0:3] = mesh_vertices[:, 0:3]\n    pts = np.dot(pts, axis_align_matrix.transpose())\n    aligned_mesh_vertices = np.concatenate([pts[:, 0:3], mesh_vertices[:, 3:]], axis=1)\n    if not test_mode:\n        (object_id_to_segs, label_to_segs) = read_aggregation(agg_file)\n        (seg_to_verts, num_verts) = read_segmentation(seg_file)\n        label_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        object_id_to_label_id = {}\n        for (label, segs) in label_to_segs.items():\n            label_id = label_map[label]\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                label_ids[verts] = label_id\n        instance_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        for (object_id, segs) in object_id_to_segs.items():\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                instance_ids[verts] = object_id\n                if object_id not in object_id_to_label_id:\n                    object_id_to_label_id[object_id] = label_ids[verts][0]\n        unaligned_bboxes = extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n        aligned_bboxes = extract_bbox(aligned_mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n    else:\n        label_ids = None\n        instance_ids = None\n        unaligned_bboxes = None\n        aligned_bboxes = None\n        object_id_to_label_id = None\n    if output_file is not None:\n        np.save(output_file + '_vert.npy', mesh_vertices)\n        if not test_mode:\n            np.save(output_file + '_sem_label.npy', label_ids)\n            np.save(output_file + '_ins_label.npy', instance_ids)\n            np.save(output_file + '_unaligned_bbox.npy', unaligned_bboxes)\n            np.save(output_file + '_aligned_bbox.npy', aligned_bboxes)\n            np.save(output_file + '_axis_align_matrix.npy', axis_align_matrix)\n    return (mesh_vertices, label_ids, instance_ids, unaligned_bboxes, aligned_bboxes, object_id_to_label_id, axis_align_matrix)",
            "def export(mesh_file, agg_file, seg_file, meta_file, label_map_file, output_file=None, test_mode=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Export original files to vert, ins_label, sem_label and bbox file.\\n\\n    Args:\\n        mesh_file (str): Path of the mesh_file.\\n        agg_file (str): Path of the agg_file.\\n        seg_file (str): Path of the seg_file.\\n        meta_file (str): Path of the meta_file.\\n        label_map_file (str): Path of the label_map_file.\\n        output_file (str): Path of the output folder.\\n            Default: None.\\n        test_mode (bool): Whether is generating test data without labels.\\n            Default: False.\\n\\n    It returns a tuple, which contains the the following things:\\n        np.ndarray: Vertices of points data.\\n        np.ndarray: Indexes of label.\\n        np.ndarray: Indexes of instance.\\n        np.ndarray: Instance bboxes.\\n        dict: Map from object_id to label_id.\\n    '\n    label_map = scannet_utils.read_label_mapping(label_map_file, label_from='raw_category', label_to='nyu40id')\n    mesh_vertices = scannet_utils.read_mesh_vertices_rgb(mesh_file)\n    lines = open(meta_file).readlines()\n    axis_align_matrix = np.eye(4)\n    for line in lines:\n        if 'axisAlignment' in line:\n            axis_align_matrix = [float(x) for x in line.rstrip().strip('axisAlignment = ').split(' ')]\n            break\n    axis_align_matrix = np.array(axis_align_matrix).reshape((4, 4))\n    pts = np.ones((mesh_vertices.shape[0], 4))\n    pts[:, 0:3] = mesh_vertices[:, 0:3]\n    pts = np.dot(pts, axis_align_matrix.transpose())\n    aligned_mesh_vertices = np.concatenate([pts[:, 0:3], mesh_vertices[:, 3:]], axis=1)\n    if not test_mode:\n        (object_id_to_segs, label_to_segs) = read_aggregation(agg_file)\n        (seg_to_verts, num_verts) = read_segmentation(seg_file)\n        label_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        object_id_to_label_id = {}\n        for (label, segs) in label_to_segs.items():\n            label_id = label_map[label]\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                label_ids[verts] = label_id\n        instance_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        for (object_id, segs) in object_id_to_segs.items():\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                instance_ids[verts] = object_id\n                if object_id not in object_id_to_label_id:\n                    object_id_to_label_id[object_id] = label_ids[verts][0]\n        unaligned_bboxes = extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n        aligned_bboxes = extract_bbox(aligned_mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n    else:\n        label_ids = None\n        instance_ids = None\n        unaligned_bboxes = None\n        aligned_bboxes = None\n        object_id_to_label_id = None\n    if output_file is not None:\n        np.save(output_file + '_vert.npy', mesh_vertices)\n        if not test_mode:\n            np.save(output_file + '_sem_label.npy', label_ids)\n            np.save(output_file + '_ins_label.npy', instance_ids)\n            np.save(output_file + '_unaligned_bbox.npy', unaligned_bboxes)\n            np.save(output_file + '_aligned_bbox.npy', aligned_bboxes)\n            np.save(output_file + '_axis_align_matrix.npy', axis_align_matrix)\n    return (mesh_vertices, label_ids, instance_ids, unaligned_bboxes, aligned_bboxes, object_id_to_label_id, axis_align_matrix)",
            "def export(mesh_file, agg_file, seg_file, meta_file, label_map_file, output_file=None, test_mode=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Export original files to vert, ins_label, sem_label and bbox file.\\n\\n    Args:\\n        mesh_file (str): Path of the mesh_file.\\n        agg_file (str): Path of the agg_file.\\n        seg_file (str): Path of the seg_file.\\n        meta_file (str): Path of the meta_file.\\n        label_map_file (str): Path of the label_map_file.\\n        output_file (str): Path of the output folder.\\n            Default: None.\\n        test_mode (bool): Whether is generating test data without labels.\\n            Default: False.\\n\\n    It returns a tuple, which contains the the following things:\\n        np.ndarray: Vertices of points data.\\n        np.ndarray: Indexes of label.\\n        np.ndarray: Indexes of instance.\\n        np.ndarray: Instance bboxes.\\n        dict: Map from object_id to label_id.\\n    '\n    label_map = scannet_utils.read_label_mapping(label_map_file, label_from='raw_category', label_to='nyu40id')\n    mesh_vertices = scannet_utils.read_mesh_vertices_rgb(mesh_file)\n    lines = open(meta_file).readlines()\n    axis_align_matrix = np.eye(4)\n    for line in lines:\n        if 'axisAlignment' in line:\n            axis_align_matrix = [float(x) for x in line.rstrip().strip('axisAlignment = ').split(' ')]\n            break\n    axis_align_matrix = np.array(axis_align_matrix).reshape((4, 4))\n    pts = np.ones((mesh_vertices.shape[0], 4))\n    pts[:, 0:3] = mesh_vertices[:, 0:3]\n    pts = np.dot(pts, axis_align_matrix.transpose())\n    aligned_mesh_vertices = np.concatenate([pts[:, 0:3], mesh_vertices[:, 3:]], axis=1)\n    if not test_mode:\n        (object_id_to_segs, label_to_segs) = read_aggregation(agg_file)\n        (seg_to_verts, num_verts) = read_segmentation(seg_file)\n        label_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        object_id_to_label_id = {}\n        for (label, segs) in label_to_segs.items():\n            label_id = label_map[label]\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                label_ids[verts] = label_id\n        instance_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        for (object_id, segs) in object_id_to_segs.items():\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                instance_ids[verts] = object_id\n                if object_id not in object_id_to_label_id:\n                    object_id_to_label_id[object_id] = label_ids[verts][0]\n        unaligned_bboxes = extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n        aligned_bboxes = extract_bbox(aligned_mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n    else:\n        label_ids = None\n        instance_ids = None\n        unaligned_bboxes = None\n        aligned_bboxes = None\n        object_id_to_label_id = None\n    if output_file is not None:\n        np.save(output_file + '_vert.npy', mesh_vertices)\n        if not test_mode:\n            np.save(output_file + '_sem_label.npy', label_ids)\n            np.save(output_file + '_ins_label.npy', instance_ids)\n            np.save(output_file + '_unaligned_bbox.npy', unaligned_bboxes)\n            np.save(output_file + '_aligned_bbox.npy', aligned_bboxes)\n            np.save(output_file + '_axis_align_matrix.npy', axis_align_matrix)\n    return (mesh_vertices, label_ids, instance_ids, unaligned_bboxes, aligned_bboxes, object_id_to_label_id, axis_align_matrix)",
            "def export(mesh_file, agg_file, seg_file, meta_file, label_map_file, output_file=None, test_mode=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Export original files to vert, ins_label, sem_label and bbox file.\\n\\n    Args:\\n        mesh_file (str): Path of the mesh_file.\\n        agg_file (str): Path of the agg_file.\\n        seg_file (str): Path of the seg_file.\\n        meta_file (str): Path of the meta_file.\\n        label_map_file (str): Path of the label_map_file.\\n        output_file (str): Path of the output folder.\\n            Default: None.\\n        test_mode (bool): Whether is generating test data without labels.\\n            Default: False.\\n\\n    It returns a tuple, which contains the the following things:\\n        np.ndarray: Vertices of points data.\\n        np.ndarray: Indexes of label.\\n        np.ndarray: Indexes of instance.\\n        np.ndarray: Instance bboxes.\\n        dict: Map from object_id to label_id.\\n    '\n    label_map = scannet_utils.read_label_mapping(label_map_file, label_from='raw_category', label_to='nyu40id')\n    mesh_vertices = scannet_utils.read_mesh_vertices_rgb(mesh_file)\n    lines = open(meta_file).readlines()\n    axis_align_matrix = np.eye(4)\n    for line in lines:\n        if 'axisAlignment' in line:\n            axis_align_matrix = [float(x) for x in line.rstrip().strip('axisAlignment = ').split(' ')]\n            break\n    axis_align_matrix = np.array(axis_align_matrix).reshape((4, 4))\n    pts = np.ones((mesh_vertices.shape[0], 4))\n    pts[:, 0:3] = mesh_vertices[:, 0:3]\n    pts = np.dot(pts, axis_align_matrix.transpose())\n    aligned_mesh_vertices = np.concatenate([pts[:, 0:3], mesh_vertices[:, 3:]], axis=1)\n    if not test_mode:\n        (object_id_to_segs, label_to_segs) = read_aggregation(agg_file)\n        (seg_to_verts, num_verts) = read_segmentation(seg_file)\n        label_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        object_id_to_label_id = {}\n        for (label, segs) in label_to_segs.items():\n            label_id = label_map[label]\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                label_ids[verts] = label_id\n        instance_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        for (object_id, segs) in object_id_to_segs.items():\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                instance_ids[verts] = object_id\n                if object_id not in object_id_to_label_id:\n                    object_id_to_label_id[object_id] = label_ids[verts][0]\n        unaligned_bboxes = extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n        aligned_bboxes = extract_bbox(aligned_mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n    else:\n        label_ids = None\n        instance_ids = None\n        unaligned_bboxes = None\n        aligned_bboxes = None\n        object_id_to_label_id = None\n    if output_file is not None:\n        np.save(output_file + '_vert.npy', mesh_vertices)\n        if not test_mode:\n            np.save(output_file + '_sem_label.npy', label_ids)\n            np.save(output_file + '_ins_label.npy', instance_ids)\n            np.save(output_file + '_unaligned_bbox.npy', unaligned_bboxes)\n            np.save(output_file + '_aligned_bbox.npy', aligned_bboxes)\n            np.save(output_file + '_axis_align_matrix.npy', axis_align_matrix)\n    return (mesh_vertices, label_ids, instance_ids, unaligned_bboxes, aligned_bboxes, object_id_to_label_id, axis_align_matrix)",
            "def export(mesh_file, agg_file, seg_file, meta_file, label_map_file, output_file=None, test_mode=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Export original files to vert, ins_label, sem_label and bbox file.\\n\\n    Args:\\n        mesh_file (str): Path of the mesh_file.\\n        agg_file (str): Path of the agg_file.\\n        seg_file (str): Path of the seg_file.\\n        meta_file (str): Path of the meta_file.\\n        label_map_file (str): Path of the label_map_file.\\n        output_file (str): Path of the output folder.\\n            Default: None.\\n        test_mode (bool): Whether is generating test data without labels.\\n            Default: False.\\n\\n    It returns a tuple, which contains the the following things:\\n        np.ndarray: Vertices of points data.\\n        np.ndarray: Indexes of label.\\n        np.ndarray: Indexes of instance.\\n        np.ndarray: Instance bboxes.\\n        dict: Map from object_id to label_id.\\n    '\n    label_map = scannet_utils.read_label_mapping(label_map_file, label_from='raw_category', label_to='nyu40id')\n    mesh_vertices = scannet_utils.read_mesh_vertices_rgb(mesh_file)\n    lines = open(meta_file).readlines()\n    axis_align_matrix = np.eye(4)\n    for line in lines:\n        if 'axisAlignment' in line:\n            axis_align_matrix = [float(x) for x in line.rstrip().strip('axisAlignment = ').split(' ')]\n            break\n    axis_align_matrix = np.array(axis_align_matrix).reshape((4, 4))\n    pts = np.ones((mesh_vertices.shape[0], 4))\n    pts[:, 0:3] = mesh_vertices[:, 0:3]\n    pts = np.dot(pts, axis_align_matrix.transpose())\n    aligned_mesh_vertices = np.concatenate([pts[:, 0:3], mesh_vertices[:, 3:]], axis=1)\n    if not test_mode:\n        (object_id_to_segs, label_to_segs) = read_aggregation(agg_file)\n        (seg_to_verts, num_verts) = read_segmentation(seg_file)\n        label_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        object_id_to_label_id = {}\n        for (label, segs) in label_to_segs.items():\n            label_id = label_map[label]\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                label_ids[verts] = label_id\n        instance_ids = np.zeros(shape=num_verts, dtype=np.uint32)\n        for (object_id, segs) in object_id_to_segs.items():\n            for seg in segs:\n                verts = seg_to_verts[seg]\n                instance_ids[verts] = object_id\n                if object_id not in object_id_to_label_id:\n                    object_id_to_label_id[object_id] = label_ids[verts][0]\n        unaligned_bboxes = extract_bbox(mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n        aligned_bboxes = extract_bbox(aligned_mesh_vertices, object_id_to_segs, object_id_to_label_id, instance_ids)\n    else:\n        label_ids = None\n        instance_ids = None\n        unaligned_bboxes = None\n        aligned_bboxes = None\n        object_id_to_label_id = None\n    if output_file is not None:\n        np.save(output_file + '_vert.npy', mesh_vertices)\n        if not test_mode:\n            np.save(output_file + '_sem_label.npy', label_ids)\n            np.save(output_file + '_ins_label.npy', instance_ids)\n            np.save(output_file + '_unaligned_bbox.npy', unaligned_bboxes)\n            np.save(output_file + '_aligned_bbox.npy', aligned_bboxes)\n            np.save(output_file + '_axis_align_matrix.npy', axis_align_matrix)\n    return (mesh_vertices, label_ids, instance_ids, unaligned_bboxes, aligned_bboxes, object_id_to_label_id, axis_align_matrix)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--scan_path', required=True, help='path to scannet scene (e.g., data/ScanNet/v2/scene0000_00')\n    parser.add_argument('--output_file', required=True, help='output file')\n    parser.add_argument('--label_map_file', required=True, help='path to scannetv2-labels.combined.tsv')\n    opt = parser.parse_args()\n    scan_name = os.path.split(opt.scan_path)[-1]\n    mesh_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.ply')\n    agg_file = os.path.join(opt.scan_path, scan_name + '.aggregation.json')\n    seg_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.0.010000.segs.json')\n    meta_file = os.path.join(opt.scan_path, scan_name + '.txt')\n    export(mesh_file, agg_file, seg_file, meta_file, opt.label_map_file, opt.output_file)",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--scan_path', required=True, help='path to scannet scene (e.g., data/ScanNet/v2/scene0000_00')\n    parser.add_argument('--output_file', required=True, help='output file')\n    parser.add_argument('--label_map_file', required=True, help='path to scannetv2-labels.combined.tsv')\n    opt = parser.parse_args()\n    scan_name = os.path.split(opt.scan_path)[-1]\n    mesh_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.ply')\n    agg_file = os.path.join(opt.scan_path, scan_name + '.aggregation.json')\n    seg_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.0.010000.segs.json')\n    meta_file = os.path.join(opt.scan_path, scan_name + '.txt')\n    export(mesh_file, agg_file, seg_file, meta_file, opt.label_map_file, opt.output_file)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--scan_path', required=True, help='path to scannet scene (e.g., data/ScanNet/v2/scene0000_00')\n    parser.add_argument('--output_file', required=True, help='output file')\n    parser.add_argument('--label_map_file', required=True, help='path to scannetv2-labels.combined.tsv')\n    opt = parser.parse_args()\n    scan_name = os.path.split(opt.scan_path)[-1]\n    mesh_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.ply')\n    agg_file = os.path.join(opt.scan_path, scan_name + '.aggregation.json')\n    seg_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.0.010000.segs.json')\n    meta_file = os.path.join(opt.scan_path, scan_name + '.txt')\n    export(mesh_file, agg_file, seg_file, meta_file, opt.label_map_file, opt.output_file)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--scan_path', required=True, help='path to scannet scene (e.g., data/ScanNet/v2/scene0000_00')\n    parser.add_argument('--output_file', required=True, help='output file')\n    parser.add_argument('--label_map_file', required=True, help='path to scannetv2-labels.combined.tsv')\n    opt = parser.parse_args()\n    scan_name = os.path.split(opt.scan_path)[-1]\n    mesh_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.ply')\n    agg_file = os.path.join(opt.scan_path, scan_name + '.aggregation.json')\n    seg_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.0.010000.segs.json')\n    meta_file = os.path.join(opt.scan_path, scan_name + '.txt')\n    export(mesh_file, agg_file, seg_file, meta_file, opt.label_map_file, opt.output_file)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--scan_path', required=True, help='path to scannet scene (e.g., data/ScanNet/v2/scene0000_00')\n    parser.add_argument('--output_file', required=True, help='output file')\n    parser.add_argument('--label_map_file', required=True, help='path to scannetv2-labels.combined.tsv')\n    opt = parser.parse_args()\n    scan_name = os.path.split(opt.scan_path)[-1]\n    mesh_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.ply')\n    agg_file = os.path.join(opt.scan_path, scan_name + '.aggregation.json')\n    seg_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.0.010000.segs.json')\n    meta_file = os.path.join(opt.scan_path, scan_name + '.txt')\n    export(mesh_file, agg_file, seg_file, meta_file, opt.label_map_file, opt.output_file)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--scan_path', required=True, help='path to scannet scene (e.g., data/ScanNet/v2/scene0000_00')\n    parser.add_argument('--output_file', required=True, help='output file')\n    parser.add_argument('--label_map_file', required=True, help='path to scannetv2-labels.combined.tsv')\n    opt = parser.parse_args()\n    scan_name = os.path.split(opt.scan_path)[-1]\n    mesh_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.ply')\n    agg_file = os.path.join(opt.scan_path, scan_name + '.aggregation.json')\n    seg_file = os.path.join(opt.scan_path, scan_name + '_vh_clean_2.0.010000.segs.json')\n    meta_file = os.path.join(opt.scan_path, scan_name + '.txt')\n    export(mesh_file, agg_file, seg_file, meta_file, opt.label_map_file, opt.output_file)"
        ]
    }
]