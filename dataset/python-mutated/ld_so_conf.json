[
    {
        "func_name": "parse_ld_so_conf",
        "original": "def parse_ld_so_conf(conf_file='/etc/ld.so.conf'):\n    \"\"\"Parse glibc style ld.so.conf file, which specifies default search paths for the\n    dynamic linker. This can in principle also be used for musl libc.\n\n    Arguments:\n        conf_file (str or bytes): Path to config file\n\n    Returns:\n        list: List of absolute search paths\n    \"\"\"\n    is_bytes = isinstance(conf_file, bytes)\n    if not is_bytes:\n        conf_file = conf_file.encode('utf-8')\n    cwd = os.getcwd()\n    try:\n        paths = _process_ld_so_conf_queue([conf_file])\n    finally:\n        os.chdir(cwd)\n    return list(paths) if is_bytes else [p.decode('utf-8') for p in paths]",
        "mutated": [
            "def parse_ld_so_conf(conf_file='/etc/ld.so.conf'):\n    if False:\n        i = 10\n    'Parse glibc style ld.so.conf file, which specifies default search paths for the\\n    dynamic linker. This can in principle also be used for musl libc.\\n\\n    Arguments:\\n        conf_file (str or bytes): Path to config file\\n\\n    Returns:\\n        list: List of absolute search paths\\n    '\n    is_bytes = isinstance(conf_file, bytes)\n    if not is_bytes:\n        conf_file = conf_file.encode('utf-8')\n    cwd = os.getcwd()\n    try:\n        paths = _process_ld_so_conf_queue([conf_file])\n    finally:\n        os.chdir(cwd)\n    return list(paths) if is_bytes else [p.decode('utf-8') for p in paths]",
            "def parse_ld_so_conf(conf_file='/etc/ld.so.conf'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Parse glibc style ld.so.conf file, which specifies default search paths for the\\n    dynamic linker. This can in principle also be used for musl libc.\\n\\n    Arguments:\\n        conf_file (str or bytes): Path to config file\\n\\n    Returns:\\n        list: List of absolute search paths\\n    '\n    is_bytes = isinstance(conf_file, bytes)\n    if not is_bytes:\n        conf_file = conf_file.encode('utf-8')\n    cwd = os.getcwd()\n    try:\n        paths = _process_ld_so_conf_queue([conf_file])\n    finally:\n        os.chdir(cwd)\n    return list(paths) if is_bytes else [p.decode('utf-8') for p in paths]",
            "def parse_ld_so_conf(conf_file='/etc/ld.so.conf'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Parse glibc style ld.so.conf file, which specifies default search paths for the\\n    dynamic linker. This can in principle also be used for musl libc.\\n\\n    Arguments:\\n        conf_file (str or bytes): Path to config file\\n\\n    Returns:\\n        list: List of absolute search paths\\n    '\n    is_bytes = isinstance(conf_file, bytes)\n    if not is_bytes:\n        conf_file = conf_file.encode('utf-8')\n    cwd = os.getcwd()\n    try:\n        paths = _process_ld_so_conf_queue([conf_file])\n    finally:\n        os.chdir(cwd)\n    return list(paths) if is_bytes else [p.decode('utf-8') for p in paths]",
            "def parse_ld_so_conf(conf_file='/etc/ld.so.conf'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Parse glibc style ld.so.conf file, which specifies default search paths for the\\n    dynamic linker. This can in principle also be used for musl libc.\\n\\n    Arguments:\\n        conf_file (str or bytes): Path to config file\\n\\n    Returns:\\n        list: List of absolute search paths\\n    '\n    is_bytes = isinstance(conf_file, bytes)\n    if not is_bytes:\n        conf_file = conf_file.encode('utf-8')\n    cwd = os.getcwd()\n    try:\n        paths = _process_ld_so_conf_queue([conf_file])\n    finally:\n        os.chdir(cwd)\n    return list(paths) if is_bytes else [p.decode('utf-8') for p in paths]",
            "def parse_ld_so_conf(conf_file='/etc/ld.so.conf'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Parse glibc style ld.so.conf file, which specifies default search paths for the\\n    dynamic linker. This can in principle also be used for musl libc.\\n\\n    Arguments:\\n        conf_file (str or bytes): Path to config file\\n\\n    Returns:\\n        list: List of absolute search paths\\n    '\n    is_bytes = isinstance(conf_file, bytes)\n    if not is_bytes:\n        conf_file = conf_file.encode('utf-8')\n    cwd = os.getcwd()\n    try:\n        paths = _process_ld_so_conf_queue([conf_file])\n    finally:\n        os.chdir(cwd)\n    return list(paths) if is_bytes else [p.decode('utf-8') for p in paths]"
        ]
    },
    {
        "func_name": "_process_ld_so_conf_queue",
        "original": "def _process_ld_so_conf_queue(queue):\n    include_regex = re.compile(b'include\\\\s')\n    paths = []\n    while queue:\n        p = queue.pop(0)\n        try:\n            with open(p, 'rb') as f:\n                lines = f.readlines()\n        except (IOError, OSError):\n            continue\n        for line in lines:\n            comment = line.find(b'#')\n            if comment != -1:\n                line = line[:comment]\n            line = line.strip()\n            if not line:\n                continue\n            is_include = include_regex.match(line) is not None\n            if not is_include:\n                if os.path.isabs(line):\n                    paths.append(line)\n                continue\n            include_path = line[8:].strip()\n            if not include_path:\n                continue\n            cwd = os.path.dirname(p)\n            os.chdir(cwd)\n            queue.extend((os.path.join(cwd, p) for p in glob.glob(include_path)))\n    return dedupe(paths)",
        "mutated": [
            "def _process_ld_so_conf_queue(queue):\n    if False:\n        i = 10\n    include_regex = re.compile(b'include\\\\s')\n    paths = []\n    while queue:\n        p = queue.pop(0)\n        try:\n            with open(p, 'rb') as f:\n                lines = f.readlines()\n        except (IOError, OSError):\n            continue\n        for line in lines:\n            comment = line.find(b'#')\n            if comment != -1:\n                line = line[:comment]\n            line = line.strip()\n            if not line:\n                continue\n            is_include = include_regex.match(line) is not None\n            if not is_include:\n                if os.path.isabs(line):\n                    paths.append(line)\n                continue\n            include_path = line[8:].strip()\n            if not include_path:\n                continue\n            cwd = os.path.dirname(p)\n            os.chdir(cwd)\n            queue.extend((os.path.join(cwd, p) for p in glob.glob(include_path)))\n    return dedupe(paths)",
            "def _process_ld_so_conf_queue(queue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    include_regex = re.compile(b'include\\\\s')\n    paths = []\n    while queue:\n        p = queue.pop(0)\n        try:\n            with open(p, 'rb') as f:\n                lines = f.readlines()\n        except (IOError, OSError):\n            continue\n        for line in lines:\n            comment = line.find(b'#')\n            if comment != -1:\n                line = line[:comment]\n            line = line.strip()\n            if not line:\n                continue\n            is_include = include_regex.match(line) is not None\n            if not is_include:\n                if os.path.isabs(line):\n                    paths.append(line)\n                continue\n            include_path = line[8:].strip()\n            if not include_path:\n                continue\n            cwd = os.path.dirname(p)\n            os.chdir(cwd)\n            queue.extend((os.path.join(cwd, p) for p in glob.glob(include_path)))\n    return dedupe(paths)",
            "def _process_ld_so_conf_queue(queue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    include_regex = re.compile(b'include\\\\s')\n    paths = []\n    while queue:\n        p = queue.pop(0)\n        try:\n            with open(p, 'rb') as f:\n                lines = f.readlines()\n        except (IOError, OSError):\n            continue\n        for line in lines:\n            comment = line.find(b'#')\n            if comment != -1:\n                line = line[:comment]\n            line = line.strip()\n            if not line:\n                continue\n            is_include = include_regex.match(line) is not None\n            if not is_include:\n                if os.path.isabs(line):\n                    paths.append(line)\n                continue\n            include_path = line[8:].strip()\n            if not include_path:\n                continue\n            cwd = os.path.dirname(p)\n            os.chdir(cwd)\n            queue.extend((os.path.join(cwd, p) for p in glob.glob(include_path)))\n    return dedupe(paths)",
            "def _process_ld_so_conf_queue(queue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    include_regex = re.compile(b'include\\\\s')\n    paths = []\n    while queue:\n        p = queue.pop(0)\n        try:\n            with open(p, 'rb') as f:\n                lines = f.readlines()\n        except (IOError, OSError):\n            continue\n        for line in lines:\n            comment = line.find(b'#')\n            if comment != -1:\n                line = line[:comment]\n            line = line.strip()\n            if not line:\n                continue\n            is_include = include_regex.match(line) is not None\n            if not is_include:\n                if os.path.isabs(line):\n                    paths.append(line)\n                continue\n            include_path = line[8:].strip()\n            if not include_path:\n                continue\n            cwd = os.path.dirname(p)\n            os.chdir(cwd)\n            queue.extend((os.path.join(cwd, p) for p in glob.glob(include_path)))\n    return dedupe(paths)",
            "def _process_ld_so_conf_queue(queue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    include_regex = re.compile(b'include\\\\s')\n    paths = []\n    while queue:\n        p = queue.pop(0)\n        try:\n            with open(p, 'rb') as f:\n                lines = f.readlines()\n        except (IOError, OSError):\n            continue\n        for line in lines:\n            comment = line.find(b'#')\n            if comment != -1:\n                line = line[:comment]\n            line = line.strip()\n            if not line:\n                continue\n            is_include = include_regex.match(line) is not None\n            if not is_include:\n                if os.path.isabs(line):\n                    paths.append(line)\n                continue\n            include_path = line[8:].strip()\n            if not include_path:\n                continue\n            cwd = os.path.dirname(p)\n            os.chdir(cwd)\n            queue.extend((os.path.join(cwd, p) for p in glob.glob(include_path)))\n    return dedupe(paths)"
        ]
    },
    {
        "func_name": "get_conf_file_from_dynamic_linker",
        "original": "def get_conf_file_from_dynamic_linker(dynamic_linker_name):\n    if 'ld-musl-' not in dynamic_linker_name:\n        return 'ld.so.conf'\n    idx = dynamic_linker_name.find('.')\n    if idx != -1:\n        return dynamic_linker_name[:idx] + '.path'",
        "mutated": [
            "def get_conf_file_from_dynamic_linker(dynamic_linker_name):\n    if False:\n        i = 10\n    if 'ld-musl-' not in dynamic_linker_name:\n        return 'ld.so.conf'\n    idx = dynamic_linker_name.find('.')\n    if idx != -1:\n        return dynamic_linker_name[:idx] + '.path'",
            "def get_conf_file_from_dynamic_linker(dynamic_linker_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'ld-musl-' not in dynamic_linker_name:\n        return 'ld.so.conf'\n    idx = dynamic_linker_name.find('.')\n    if idx != -1:\n        return dynamic_linker_name[:idx] + '.path'",
            "def get_conf_file_from_dynamic_linker(dynamic_linker_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'ld-musl-' not in dynamic_linker_name:\n        return 'ld.so.conf'\n    idx = dynamic_linker_name.find('.')\n    if idx != -1:\n        return dynamic_linker_name[:idx] + '.path'",
            "def get_conf_file_from_dynamic_linker(dynamic_linker_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'ld-musl-' not in dynamic_linker_name:\n        return 'ld.so.conf'\n    idx = dynamic_linker_name.find('.')\n    if idx != -1:\n        return dynamic_linker_name[:idx] + '.path'",
            "def get_conf_file_from_dynamic_linker(dynamic_linker_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'ld-musl-' not in dynamic_linker_name:\n        return 'ld.so.conf'\n    idx = dynamic_linker_name.find('.')\n    if idx != -1:\n        return dynamic_linker_name[:idx] + '.path'"
        ]
    },
    {
        "func_name": "host_dynamic_linker_search_paths",
        "original": "def host_dynamic_linker_search_paths():\n    \"\"\"Retrieve the current host runtime search paths for shared libraries;\n    for GNU and musl Linux we try to retrieve the dynamic linker from the\n    current Python interpreter and then find the corresponding config file\n    (e.g. ld.so.conf or ld-musl-<arch>.path). Similar can be done for\n    BSD and others, but this is not implemented yet. The default paths\n    are always returned. We don't check if the listed directories exist.\"\"\"\n    default_paths = ['/usr/lib', '/usr/lib64', '/lib', '/lib64']\n    if not sys.platform.startswith('linux'):\n        return default_paths\n    conf_file = '/etc/ld.so.conf'\n    try:\n        with open(sys.executable, 'rb') as f:\n            elf = elf_utils.parse_elf(f, dynamic_section=False, interpreter=True)\n        if elf.has_pt_interp:\n            dynamic_linker = elf.pt_interp_str.decode('utf-8')\n            dynamic_linker_name = os.path.basename(dynamic_linker)\n            conf_name = get_conf_file_from_dynamic_linker(dynamic_linker_name)\n            possible_prefix = os.path.dirname(os.path.dirname(dynamic_linker))\n            possible_conf = os.path.join(possible_prefix, 'etc', conf_name)\n            if os.path.exists(possible_conf):\n                conf_file = possible_conf\n    except (IOError, OSError, elf_utils.ElfParsingError):\n        pass\n    return list(dedupe(parse_ld_so_conf(conf_file) + default_paths))",
        "mutated": [
            "def host_dynamic_linker_search_paths():\n    if False:\n        i = 10\n    \"Retrieve the current host runtime search paths for shared libraries;\\n    for GNU and musl Linux we try to retrieve the dynamic linker from the\\n    current Python interpreter and then find the corresponding config file\\n    (e.g. ld.so.conf or ld-musl-<arch>.path). Similar can be done for\\n    BSD and others, but this is not implemented yet. The default paths\\n    are always returned. We don't check if the listed directories exist.\"\n    default_paths = ['/usr/lib', '/usr/lib64', '/lib', '/lib64']\n    if not sys.platform.startswith('linux'):\n        return default_paths\n    conf_file = '/etc/ld.so.conf'\n    try:\n        with open(sys.executable, 'rb') as f:\n            elf = elf_utils.parse_elf(f, dynamic_section=False, interpreter=True)\n        if elf.has_pt_interp:\n            dynamic_linker = elf.pt_interp_str.decode('utf-8')\n            dynamic_linker_name = os.path.basename(dynamic_linker)\n            conf_name = get_conf_file_from_dynamic_linker(dynamic_linker_name)\n            possible_prefix = os.path.dirname(os.path.dirname(dynamic_linker))\n            possible_conf = os.path.join(possible_prefix, 'etc', conf_name)\n            if os.path.exists(possible_conf):\n                conf_file = possible_conf\n    except (IOError, OSError, elf_utils.ElfParsingError):\n        pass\n    return list(dedupe(parse_ld_so_conf(conf_file) + default_paths))",
            "def host_dynamic_linker_search_paths():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Retrieve the current host runtime search paths for shared libraries;\\n    for GNU and musl Linux we try to retrieve the dynamic linker from the\\n    current Python interpreter and then find the corresponding config file\\n    (e.g. ld.so.conf or ld-musl-<arch>.path). Similar can be done for\\n    BSD and others, but this is not implemented yet. The default paths\\n    are always returned. We don't check if the listed directories exist.\"\n    default_paths = ['/usr/lib', '/usr/lib64', '/lib', '/lib64']\n    if not sys.platform.startswith('linux'):\n        return default_paths\n    conf_file = '/etc/ld.so.conf'\n    try:\n        with open(sys.executable, 'rb') as f:\n            elf = elf_utils.parse_elf(f, dynamic_section=False, interpreter=True)\n        if elf.has_pt_interp:\n            dynamic_linker = elf.pt_interp_str.decode('utf-8')\n            dynamic_linker_name = os.path.basename(dynamic_linker)\n            conf_name = get_conf_file_from_dynamic_linker(dynamic_linker_name)\n            possible_prefix = os.path.dirname(os.path.dirname(dynamic_linker))\n            possible_conf = os.path.join(possible_prefix, 'etc', conf_name)\n            if os.path.exists(possible_conf):\n                conf_file = possible_conf\n    except (IOError, OSError, elf_utils.ElfParsingError):\n        pass\n    return list(dedupe(parse_ld_so_conf(conf_file) + default_paths))",
            "def host_dynamic_linker_search_paths():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Retrieve the current host runtime search paths for shared libraries;\\n    for GNU and musl Linux we try to retrieve the dynamic linker from the\\n    current Python interpreter and then find the corresponding config file\\n    (e.g. ld.so.conf or ld-musl-<arch>.path). Similar can be done for\\n    BSD and others, but this is not implemented yet. The default paths\\n    are always returned. We don't check if the listed directories exist.\"\n    default_paths = ['/usr/lib', '/usr/lib64', '/lib', '/lib64']\n    if not sys.platform.startswith('linux'):\n        return default_paths\n    conf_file = '/etc/ld.so.conf'\n    try:\n        with open(sys.executable, 'rb') as f:\n            elf = elf_utils.parse_elf(f, dynamic_section=False, interpreter=True)\n        if elf.has_pt_interp:\n            dynamic_linker = elf.pt_interp_str.decode('utf-8')\n            dynamic_linker_name = os.path.basename(dynamic_linker)\n            conf_name = get_conf_file_from_dynamic_linker(dynamic_linker_name)\n            possible_prefix = os.path.dirname(os.path.dirname(dynamic_linker))\n            possible_conf = os.path.join(possible_prefix, 'etc', conf_name)\n            if os.path.exists(possible_conf):\n                conf_file = possible_conf\n    except (IOError, OSError, elf_utils.ElfParsingError):\n        pass\n    return list(dedupe(parse_ld_so_conf(conf_file) + default_paths))",
            "def host_dynamic_linker_search_paths():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Retrieve the current host runtime search paths for shared libraries;\\n    for GNU and musl Linux we try to retrieve the dynamic linker from the\\n    current Python interpreter and then find the corresponding config file\\n    (e.g. ld.so.conf or ld-musl-<arch>.path). Similar can be done for\\n    BSD and others, but this is not implemented yet. The default paths\\n    are always returned. We don't check if the listed directories exist.\"\n    default_paths = ['/usr/lib', '/usr/lib64', '/lib', '/lib64']\n    if not sys.platform.startswith('linux'):\n        return default_paths\n    conf_file = '/etc/ld.so.conf'\n    try:\n        with open(sys.executable, 'rb') as f:\n            elf = elf_utils.parse_elf(f, dynamic_section=False, interpreter=True)\n        if elf.has_pt_interp:\n            dynamic_linker = elf.pt_interp_str.decode('utf-8')\n            dynamic_linker_name = os.path.basename(dynamic_linker)\n            conf_name = get_conf_file_from_dynamic_linker(dynamic_linker_name)\n            possible_prefix = os.path.dirname(os.path.dirname(dynamic_linker))\n            possible_conf = os.path.join(possible_prefix, 'etc', conf_name)\n            if os.path.exists(possible_conf):\n                conf_file = possible_conf\n    except (IOError, OSError, elf_utils.ElfParsingError):\n        pass\n    return list(dedupe(parse_ld_so_conf(conf_file) + default_paths))",
            "def host_dynamic_linker_search_paths():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Retrieve the current host runtime search paths for shared libraries;\\n    for GNU and musl Linux we try to retrieve the dynamic linker from the\\n    current Python interpreter and then find the corresponding config file\\n    (e.g. ld.so.conf or ld-musl-<arch>.path). Similar can be done for\\n    BSD and others, but this is not implemented yet. The default paths\\n    are always returned. We don't check if the listed directories exist.\"\n    default_paths = ['/usr/lib', '/usr/lib64', '/lib', '/lib64']\n    if not sys.platform.startswith('linux'):\n        return default_paths\n    conf_file = '/etc/ld.so.conf'\n    try:\n        with open(sys.executable, 'rb') as f:\n            elf = elf_utils.parse_elf(f, dynamic_section=False, interpreter=True)\n        if elf.has_pt_interp:\n            dynamic_linker = elf.pt_interp_str.decode('utf-8')\n            dynamic_linker_name = os.path.basename(dynamic_linker)\n            conf_name = get_conf_file_from_dynamic_linker(dynamic_linker_name)\n            possible_prefix = os.path.dirname(os.path.dirname(dynamic_linker))\n            possible_conf = os.path.join(possible_prefix, 'etc', conf_name)\n            if os.path.exists(possible_conf):\n                conf_file = possible_conf\n    except (IOError, OSError, elf_utils.ElfParsingError):\n        pass\n    return list(dedupe(parse_ld_so_conf(conf_file) + default_paths))"
        ]
    }
]