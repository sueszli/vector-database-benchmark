[
    {
        "func_name": "test_predict_dates",
        "original": "def test_predict_dates():\n    index = pd.date_range(start='1950-01-01', periods=11, freq='D')\n    np.random.seed(324328)\n    endog = pd.Series(np.random.normal(size=10), index=index[:-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 1, 0), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - 1)\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[1:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 2, 0), seasonal_order=(0, 1, 0, 4), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - (4 + 2))\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[4 + 2:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])",
        "mutated": [
            "def test_predict_dates():\n    if False:\n        i = 10\n    index = pd.date_range(start='1950-01-01', periods=11, freq='D')\n    np.random.seed(324328)\n    endog = pd.Series(np.random.normal(size=10), index=index[:-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 1, 0), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - 1)\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[1:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 2, 0), seasonal_order=(0, 1, 0, 4), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - (4 + 2))\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[4 + 2:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])",
            "def test_predict_dates():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index = pd.date_range(start='1950-01-01', periods=11, freq='D')\n    np.random.seed(324328)\n    endog = pd.Series(np.random.normal(size=10), index=index[:-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 1, 0), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - 1)\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[1:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 2, 0), seasonal_order=(0, 1, 0, 4), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - (4 + 2))\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[4 + 2:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])",
            "def test_predict_dates():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index = pd.date_range(start='1950-01-01', periods=11, freq='D')\n    np.random.seed(324328)\n    endog = pd.Series(np.random.normal(size=10), index=index[:-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 1, 0), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - 1)\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[1:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 2, 0), seasonal_order=(0, 1, 0, 4), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - (4 + 2))\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[4 + 2:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])",
            "def test_predict_dates():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index = pd.date_range(start='1950-01-01', periods=11, freq='D')\n    np.random.seed(324328)\n    endog = pd.Series(np.random.normal(size=10), index=index[:-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 1, 0), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - 1)\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[1:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 2, 0), seasonal_order=(0, 1, 0, 4), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - (4 + 2))\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[4 + 2:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])",
            "def test_predict_dates():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index = pd.date_range(start='1950-01-01', periods=11, freq='D')\n    np.random.seed(324328)\n    endog = pd.Series(np.random.normal(size=10), index=index[:-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 1, 0), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - 1)\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[1:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])\n    mod = sarimax.SARIMAX(endog, order=(1, 2, 0), seasonal_order=(0, 1, 0, 4), simple_differencing=True)\n    res = mod.filter(mod.start_params)\n    pred = res.predict()\n    assert_equal(mod.nobs, endog.shape[0] - (4 + 2))\n    assert_equal(len(pred), mod.nobs)\n    assert_equal(pred.index.values, index[4 + 2:-1].values)\n    fcast = res.forecast()\n    assert_equal(fcast.index[0], index[-1])"
        ]
    },
    {
        "func_name": "test_memory_no_predicted",
        "original": "def test_memory_no_predicted():\n    endog = [0.5, 1.2, 0.4, 0.6]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res1 = mod.filter([0.5, 1.0])\n    mod.ssm.memory_no_predicted = True\n    res2 = mod.filter([0.5, 1.0])\n    assert_equal(res1.predicted_state.shape, (1, 5))\n    assert_(res2.predicted_state is None)\n    assert_equal(res1.predicted_state_cov.shape, (1, 1, 5))\n    assert_(res2.predicted_state_cov is None)\n    assert_raises(ValueError, res2.predict, dynamic=True)\n    assert_raises(ValueError, res2.get_prediction, dynamic=True)\n    assert_allclose(res1.forecast(10), res2.forecast(10))\n    fcast1 = res1.get_forecast(10)\n    fcast2 = res1.get_forecast(10)\n    assert_allclose(fcast1.summary_frame(), fcast2.summary_frame())",
        "mutated": [
            "def test_memory_no_predicted():\n    if False:\n        i = 10\n    endog = [0.5, 1.2, 0.4, 0.6]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res1 = mod.filter([0.5, 1.0])\n    mod.ssm.memory_no_predicted = True\n    res2 = mod.filter([0.5, 1.0])\n    assert_equal(res1.predicted_state.shape, (1, 5))\n    assert_(res2.predicted_state is None)\n    assert_equal(res1.predicted_state_cov.shape, (1, 1, 5))\n    assert_(res2.predicted_state_cov is None)\n    assert_raises(ValueError, res2.predict, dynamic=True)\n    assert_raises(ValueError, res2.get_prediction, dynamic=True)\n    assert_allclose(res1.forecast(10), res2.forecast(10))\n    fcast1 = res1.get_forecast(10)\n    fcast2 = res1.get_forecast(10)\n    assert_allclose(fcast1.summary_frame(), fcast2.summary_frame())",
            "def test_memory_no_predicted():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = [0.5, 1.2, 0.4, 0.6]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res1 = mod.filter([0.5, 1.0])\n    mod.ssm.memory_no_predicted = True\n    res2 = mod.filter([0.5, 1.0])\n    assert_equal(res1.predicted_state.shape, (1, 5))\n    assert_(res2.predicted_state is None)\n    assert_equal(res1.predicted_state_cov.shape, (1, 1, 5))\n    assert_(res2.predicted_state_cov is None)\n    assert_raises(ValueError, res2.predict, dynamic=True)\n    assert_raises(ValueError, res2.get_prediction, dynamic=True)\n    assert_allclose(res1.forecast(10), res2.forecast(10))\n    fcast1 = res1.get_forecast(10)\n    fcast2 = res1.get_forecast(10)\n    assert_allclose(fcast1.summary_frame(), fcast2.summary_frame())",
            "def test_memory_no_predicted():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = [0.5, 1.2, 0.4, 0.6]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res1 = mod.filter([0.5, 1.0])\n    mod.ssm.memory_no_predicted = True\n    res2 = mod.filter([0.5, 1.0])\n    assert_equal(res1.predicted_state.shape, (1, 5))\n    assert_(res2.predicted_state is None)\n    assert_equal(res1.predicted_state_cov.shape, (1, 1, 5))\n    assert_(res2.predicted_state_cov is None)\n    assert_raises(ValueError, res2.predict, dynamic=True)\n    assert_raises(ValueError, res2.get_prediction, dynamic=True)\n    assert_allclose(res1.forecast(10), res2.forecast(10))\n    fcast1 = res1.get_forecast(10)\n    fcast2 = res1.get_forecast(10)\n    assert_allclose(fcast1.summary_frame(), fcast2.summary_frame())",
            "def test_memory_no_predicted():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = [0.5, 1.2, 0.4, 0.6]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res1 = mod.filter([0.5, 1.0])\n    mod.ssm.memory_no_predicted = True\n    res2 = mod.filter([0.5, 1.0])\n    assert_equal(res1.predicted_state.shape, (1, 5))\n    assert_(res2.predicted_state is None)\n    assert_equal(res1.predicted_state_cov.shape, (1, 1, 5))\n    assert_(res2.predicted_state_cov is None)\n    assert_raises(ValueError, res2.predict, dynamic=True)\n    assert_raises(ValueError, res2.get_prediction, dynamic=True)\n    assert_allclose(res1.forecast(10), res2.forecast(10))\n    fcast1 = res1.get_forecast(10)\n    fcast2 = res1.get_forecast(10)\n    assert_allclose(fcast1.summary_frame(), fcast2.summary_frame())",
            "def test_memory_no_predicted():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = [0.5, 1.2, 0.4, 0.6]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0))\n    res1 = mod.filter([0.5, 1.0])\n    mod.ssm.memory_no_predicted = True\n    res2 = mod.filter([0.5, 1.0])\n    assert_equal(res1.predicted_state.shape, (1, 5))\n    assert_(res2.predicted_state is None)\n    assert_equal(res1.predicted_state_cov.shape, (1, 1, 5))\n    assert_(res2.predicted_state_cov is None)\n    assert_raises(ValueError, res2.predict, dynamic=True)\n    assert_raises(ValueError, res2.get_prediction, dynamic=True)\n    assert_allclose(res1.forecast(10), res2.forecast(10))\n    fcast1 = res1.get_forecast(10)\n    fcast2 = res1.get_forecast(10)\n    assert_allclose(fcast1.summary_frame(), fcast2.summary_frame())"
        ]
    },
    {
        "func_name": "test_concatenated_predict_sarimax",
        "original": "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_sarimax(use_exog, trend):\n    endog = np.arange(100).reshape(100, 1) * 1.0\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[10:30] = 2.0\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.2]\n    var_params = [1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += ar_params\n    if use_exog:\n        params += exog_params\n    params += var_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = sarimax.SARIMAX(y1, order=(1, 1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = sarimax.SARIMAX(endog[:50], order=(1, 1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
        "mutated": [
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_sarimax(use_exog, trend):\n    if False:\n        i = 10\n    endog = np.arange(100).reshape(100, 1) * 1.0\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[10:30] = 2.0\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.2]\n    var_params = [1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += ar_params\n    if use_exog:\n        params += exog_params\n    params += var_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = sarimax.SARIMAX(y1, order=(1, 1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = sarimax.SARIMAX(endog[:50], order=(1, 1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_sarimax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.arange(100).reshape(100, 1) * 1.0\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[10:30] = 2.0\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.2]\n    var_params = [1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += ar_params\n    if use_exog:\n        params += exog_params\n    params += var_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = sarimax.SARIMAX(y1, order=(1, 1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = sarimax.SARIMAX(endog[:50], order=(1, 1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_sarimax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.arange(100).reshape(100, 1) * 1.0\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[10:30] = 2.0\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.2]\n    var_params = [1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += ar_params\n    if use_exog:\n        params += exog_params\n    params += var_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = sarimax.SARIMAX(y1, order=(1, 1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = sarimax.SARIMAX(endog[:50], order=(1, 1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_sarimax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.arange(100).reshape(100, 1) * 1.0\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[10:30] = 2.0\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.2]\n    var_params = [1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += ar_params\n    if use_exog:\n        params += exog_params\n    params += var_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = sarimax.SARIMAX(y1, order=(1, 1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = sarimax.SARIMAX(endog[:50], order=(1, 1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_sarimax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.arange(100).reshape(100, 1) * 1.0\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[10:30] = 2.0\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.2]\n    var_params = [1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += ar_params\n    if use_exog:\n        params += exog_params\n    params += var_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = sarimax.SARIMAX(y1, order=(1, 1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = sarimax.SARIMAX(endog[:50], order=(1, 1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))"
        ]
    },
    {
        "func_name": "test_concatenated_predict_varmax",
        "original": "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_varmax(use_exog, trend):\n    endog = np.arange(200).reshape(100, 2) * 1.0\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = varmax.VARMAX(y1, order=(1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
        "mutated": [
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_varmax(use_exog, trend):\n    if False:\n        i = 10\n    endog = np.arange(200).reshape(100, 2) * 1.0\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = varmax.VARMAX(y1, order=(1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.arange(200).reshape(100, 2) * 1.0\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = varmax.VARMAX(y1, order=(1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.arange(200).reshape(100, 2) * 1.0\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = varmax.VARMAX(y1, order=(1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.arange(200).reshape(100, 2) * 1.0\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = varmax.VARMAX(y1, order=(1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_concatenated_predict_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.arange(200).reshape(100, 2) * 1.0\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    y1 = endog.copy()\n    y1[-50:] = np.nan\n    mod1 = varmax.VARMAX(y1, order=(1, 0), trend=trend, exog=exog)\n    res1 = mod1.smooth(params)\n    p1 = res1.get_prediction()\n    pr1 = p1.prediction_results\n    x2 = exog[:50] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x2)\n    res2 = mod2.smooth(params)\n    x2f = exog[50:] if use_exog else None\n    p2 = res2.get_prediction(start=0, end=99, exog=x2f)\n    pr2 = p2.prediction_results\n    attrs = pr1.representation_attributes + pr1.filter_attributes + pr1.smoother_attributes\n    for key in attrs:\n        assert_allclose(getattr(pr2, key), getattr(pr1, key))"
        ]
    },
    {
        "func_name": "test_predicted_filtered_smoothed_with_nans",
        "original": "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_with_nans(use_exog, trend):\n    endog = np.zeros(200).reshape(100, 2) * np.nan\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    if use_exog is False and trend == 'n':\n        assert_allclose(p_signal.predicted_mean[:50], res.fittedvalues)\n        assert_allclose(p_signal.var_pred_mean[:50].T, res.forecasts_error_cov)\n    else:\n        assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'], res.fittedvalues)\n        assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov']).T, res.forecasts_error_cov)",
        "mutated": [
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_with_nans(use_exog, trend):\n    if False:\n        i = 10\n    endog = np.zeros(200).reshape(100, 2) * np.nan\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    if use_exog is False and trend == 'n':\n        assert_allclose(p_signal.predicted_mean[:50], res.fittedvalues)\n        assert_allclose(p_signal.var_pred_mean[:50].T, res.forecasts_error_cov)\n    else:\n        assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'], res.fittedvalues)\n        assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov']).T, res.forecasts_error_cov)",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_with_nans(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros(200).reshape(100, 2) * np.nan\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    if use_exog is False and trend == 'n':\n        assert_allclose(p_signal.predicted_mean[:50], res.fittedvalues)\n        assert_allclose(p_signal.var_pred_mean[:50].T, res.forecasts_error_cov)\n    else:\n        assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'], res.fittedvalues)\n        assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov']).T, res.forecasts_error_cov)",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_with_nans(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros(200).reshape(100, 2) * np.nan\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    if use_exog is False and trend == 'n':\n        assert_allclose(p_signal.predicted_mean[:50], res.fittedvalues)\n        assert_allclose(p_signal.var_pred_mean[:50].T, res.forecasts_error_cov)\n    else:\n        assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'], res.fittedvalues)\n        assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov']).T, res.forecasts_error_cov)",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_with_nans(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros(200).reshape(100, 2) * np.nan\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    if use_exog is False and trend == 'n':\n        assert_allclose(p_signal.predicted_mean[:50], res.fittedvalues)\n        assert_allclose(p_signal.var_pred_mean[:50].T, res.forecasts_error_cov)\n    else:\n        assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'], res.fittedvalues)\n        assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov']).T, res.forecasts_error_cov)",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_with_nans(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros(200).reshape(100, 2) * np.nan\n    exog = np.ones(100) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    if use_exog is False and trend == 'n':\n        assert_allclose(p_signal.predicted_mean[:50], res.fittedvalues)\n        assert_allclose(p_signal.var_pred_mean[:50].T, res.forecasts_error_cov)\n    else:\n        assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'], res.fittedvalues)\n        assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov']).T, res.forecasts_error_cov)"
        ]
    },
    {
        "func_name": "test_predicted_filtered_smoothed_with_nans_TVSS",
        "original": "def test_predicted_filtered_smoothed_with_nans_TVSS(reset_randomstate):\n    mod = TVSS(np.zeros((50, 2)) * np.nan)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'].T, res.fittedvalues)\n    assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov'].T).T, res.forecasts_error_cov)",
        "mutated": [
            "def test_predicted_filtered_smoothed_with_nans_TVSS(reset_randomstate):\n    if False:\n        i = 10\n    mod = TVSS(np.zeros((50, 2)) * np.nan)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'].T, res.fittedvalues)\n    assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov'].T).T, res.forecasts_error_cov)",
            "def test_predicted_filtered_smoothed_with_nans_TVSS(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mod = TVSS(np.zeros((50, 2)) * np.nan)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'].T, res.fittedvalues)\n    assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov'].T).T, res.forecasts_error_cov)",
            "def test_predicted_filtered_smoothed_with_nans_TVSS(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mod = TVSS(np.zeros((50, 2)) * np.nan)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'].T, res.fittedvalues)\n    assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov'].T).T, res.forecasts_error_cov)",
            "def test_predicted_filtered_smoothed_with_nans_TVSS(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mod = TVSS(np.zeros((50, 2)) * np.nan)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'].T, res.fittedvalues)\n    assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov'].T).T, res.forecasts_error_cov)",
            "def test_predicted_filtered_smoothed_with_nans_TVSS(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mod = TVSS(np.zeros((50, 2)) * np.nan)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    assert_allclose(s_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(s_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(f_pred.predicted_mean, p_pred.predicted_mean)\n    assert_allclose(f_pred.var_pred_mean, p_pred.var_pred_mean)\n    assert_allclose(p_pred.predicted_mean[:50], res.fittedvalues)\n    assert_allclose(p_pred.var_pred_mean[:50].T, res.forecasts_error_cov)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    assert_allclose(s_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(s_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(f_signal.predicted_mean, p_signal.predicted_mean)\n    assert_allclose(f_signal.var_pred_mean, p_signal.var_pred_mean)\n    assert_allclose(p_signal.predicted_mean[:50] + mod['obs_intercept'].T, res.fittedvalues)\n    assert_allclose((p_signal.var_pred_mean[:50] + mod['obs_cov'].T).T, res.forecasts_error_cov)"
        ]
    },
    {
        "func_name": "test_predicted_filtered_smoothed_varmax",
        "original": "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_varmax(use_exog, trend):\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    mod['obs_intercept'] = [5, -2.0]\n    mod['obs_cov'] = np.array([[1.2, 0.3], [0.3, 3.4]])\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    fcast = res.get_forecast(11, exog=x_fcast)\n    d = mod['obs_intercept'][:, None]\n    Z = mod['design']\n    H = mod['obs_cov'][:, :, None]\n    desired_s_signal = Z @ res.smoothed_state\n    desired_f_signal = Z @ res.filtered_state\n    desired_p_signal = Z @ res.predicted_state[..., :-1]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal).T)\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal).T)\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal).T)\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    desired_s_signal_cov = Z[None, :, :] @ res.smoothed_state_cov.T @ Z.T[None, :, :]\n    desired_f_signal_cov = Z[None, :, :] @ res.filtered_state_cov.T @ Z.T[None, :, :]\n    desired_p_signal_cov = Z[None, :, :] @ res.predicted_state_cov[..., :-1].T @ Z.T[None, :, :]\n    assert_allclose(s_pred.var_pred_mean[:50], (desired_s_signal_cov.T + H).T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[:50], (desired_f_signal_cov.T + H).T)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[:50], (desired_p_signal_cov.T + H).T)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    fcast_signal = fcast.predicted_mean - d.T\n    fcast_signal_cov = (fcast.var_pred_mean.T - H).T\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal.T)\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal.T)\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal.T)\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(s_signal.var_pred_mean[:50], desired_s_signal_cov)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[:50], desired_f_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[:50], desired_p_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
        "mutated": [
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_varmax(use_exog, trend):\n    if False:\n        i = 10\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    mod['obs_intercept'] = [5, -2.0]\n    mod['obs_cov'] = np.array([[1.2, 0.3], [0.3, 3.4]])\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    fcast = res.get_forecast(11, exog=x_fcast)\n    d = mod['obs_intercept'][:, None]\n    Z = mod['design']\n    H = mod['obs_cov'][:, :, None]\n    desired_s_signal = Z @ res.smoothed_state\n    desired_f_signal = Z @ res.filtered_state\n    desired_p_signal = Z @ res.predicted_state[..., :-1]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal).T)\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal).T)\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal).T)\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    desired_s_signal_cov = Z[None, :, :] @ res.smoothed_state_cov.T @ Z.T[None, :, :]\n    desired_f_signal_cov = Z[None, :, :] @ res.filtered_state_cov.T @ Z.T[None, :, :]\n    desired_p_signal_cov = Z[None, :, :] @ res.predicted_state_cov[..., :-1].T @ Z.T[None, :, :]\n    assert_allclose(s_pred.var_pred_mean[:50], (desired_s_signal_cov.T + H).T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[:50], (desired_f_signal_cov.T + H).T)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[:50], (desired_p_signal_cov.T + H).T)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    fcast_signal = fcast.predicted_mean - d.T\n    fcast_signal_cov = (fcast.var_pred_mean.T - H).T\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal.T)\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal.T)\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal.T)\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(s_signal.var_pred_mean[:50], desired_s_signal_cov)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[:50], desired_f_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[:50], desired_p_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    mod['obs_intercept'] = [5, -2.0]\n    mod['obs_cov'] = np.array([[1.2, 0.3], [0.3, 3.4]])\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    fcast = res.get_forecast(11, exog=x_fcast)\n    d = mod['obs_intercept'][:, None]\n    Z = mod['design']\n    H = mod['obs_cov'][:, :, None]\n    desired_s_signal = Z @ res.smoothed_state\n    desired_f_signal = Z @ res.filtered_state\n    desired_p_signal = Z @ res.predicted_state[..., :-1]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal).T)\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal).T)\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal).T)\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    desired_s_signal_cov = Z[None, :, :] @ res.smoothed_state_cov.T @ Z.T[None, :, :]\n    desired_f_signal_cov = Z[None, :, :] @ res.filtered_state_cov.T @ Z.T[None, :, :]\n    desired_p_signal_cov = Z[None, :, :] @ res.predicted_state_cov[..., :-1].T @ Z.T[None, :, :]\n    assert_allclose(s_pred.var_pred_mean[:50], (desired_s_signal_cov.T + H).T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[:50], (desired_f_signal_cov.T + H).T)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[:50], (desired_p_signal_cov.T + H).T)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    fcast_signal = fcast.predicted_mean - d.T\n    fcast_signal_cov = (fcast.var_pred_mean.T - H).T\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal.T)\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal.T)\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal.T)\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(s_signal.var_pred_mean[:50], desired_s_signal_cov)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[:50], desired_f_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[:50], desired_p_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    mod['obs_intercept'] = [5, -2.0]\n    mod['obs_cov'] = np.array([[1.2, 0.3], [0.3, 3.4]])\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    fcast = res.get_forecast(11, exog=x_fcast)\n    d = mod['obs_intercept'][:, None]\n    Z = mod['design']\n    H = mod['obs_cov'][:, :, None]\n    desired_s_signal = Z @ res.smoothed_state\n    desired_f_signal = Z @ res.filtered_state\n    desired_p_signal = Z @ res.predicted_state[..., :-1]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal).T)\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal).T)\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal).T)\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    desired_s_signal_cov = Z[None, :, :] @ res.smoothed_state_cov.T @ Z.T[None, :, :]\n    desired_f_signal_cov = Z[None, :, :] @ res.filtered_state_cov.T @ Z.T[None, :, :]\n    desired_p_signal_cov = Z[None, :, :] @ res.predicted_state_cov[..., :-1].T @ Z.T[None, :, :]\n    assert_allclose(s_pred.var_pred_mean[:50], (desired_s_signal_cov.T + H).T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[:50], (desired_f_signal_cov.T + H).T)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[:50], (desired_p_signal_cov.T + H).T)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    fcast_signal = fcast.predicted_mean - d.T\n    fcast_signal_cov = (fcast.var_pred_mean.T - H).T\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal.T)\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal.T)\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal.T)\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(s_signal.var_pred_mean[:50], desired_s_signal_cov)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[:50], desired_f_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[:50], desired_p_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    mod['obs_intercept'] = [5, -2.0]\n    mod['obs_cov'] = np.array([[1.2, 0.3], [0.3, 3.4]])\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    fcast = res.get_forecast(11, exog=x_fcast)\n    d = mod['obs_intercept'][:, None]\n    Z = mod['design']\n    H = mod['obs_cov'][:, :, None]\n    desired_s_signal = Z @ res.smoothed_state\n    desired_f_signal = Z @ res.filtered_state\n    desired_p_signal = Z @ res.predicted_state[..., :-1]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal).T)\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal).T)\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal).T)\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    desired_s_signal_cov = Z[None, :, :] @ res.smoothed_state_cov.T @ Z.T[None, :, :]\n    desired_f_signal_cov = Z[None, :, :] @ res.filtered_state_cov.T @ Z.T[None, :, :]\n    desired_p_signal_cov = Z[None, :, :] @ res.predicted_state_cov[..., :-1].T @ Z.T[None, :, :]\n    assert_allclose(s_pred.var_pred_mean[:50], (desired_s_signal_cov.T + H).T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[:50], (desired_f_signal_cov.T + H).T)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[:50], (desired_p_signal_cov.T + H).T)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    fcast_signal = fcast.predicted_mean - d.T\n    fcast_signal_cov = (fcast.var_pred_mean.T - H).T\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal.T)\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal.T)\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal.T)\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(s_signal.var_pred_mean[:50], desired_s_signal_cov)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[:50], desired_f_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[:50], desired_p_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
            "@pytest.mark.parametrize('use_exog', [True, False])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_smoothed_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit = exog[:50] if use_exog else None\n    mod = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit)\n    mod['obs_intercept'] = [5, -2.0]\n    mod['obs_cov'] = np.array([[1.2, 0.3], [0.3, 3.4]])\n    res = mod.smooth(params)\n    x_fcast = exog[50:61] if use_exog else None\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', exog=x_fcast)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', exog=x_fcast)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', exog=x_fcast)\n    fcast = res.get_forecast(11, exog=x_fcast)\n    d = mod['obs_intercept'][:, None]\n    Z = mod['design']\n    H = mod['obs_cov'][:, :, None]\n    desired_s_signal = Z @ res.smoothed_state\n    desired_f_signal = Z @ res.filtered_state\n    desired_p_signal = Z @ res.predicted_state[..., :-1]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal).T)\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal).T)\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal).T)\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    desired_s_signal_cov = Z[None, :, :] @ res.smoothed_state_cov.T @ Z.T[None, :, :]\n    desired_f_signal_cov = Z[None, :, :] @ res.filtered_state_cov.T @ Z.T[None, :, :]\n    desired_p_signal_cov = Z[None, :, :] @ res.predicted_state_cov[..., :-1].T @ Z.T[None, :, :]\n    assert_allclose(s_pred.var_pred_mean[:50], (desired_s_signal_cov.T + H).T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[:50], (desired_f_signal_cov.T + H).T)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[:50], (desired_p_signal_cov.T + H).T)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, exog=x_fcast)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, exog=x_fcast)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, exog=x_fcast)\n    fcast_signal = fcast.predicted_mean - d.T\n    fcast_signal_cov = (fcast.var_pred_mean.T - H).T\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal.T)\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal.T)\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal.T)\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(s_signal.var_pred_mean[:50], desired_s_signal_cov)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[:50], desired_f_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[:50], desired_p_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)"
        ]
    },
    {
        "func_name": "test_predicted_filtered_smoothed_TVSS",
        "original": "def test_predicted_filtered_smoothed_TVSS(reset_randomstate):\n    mod = TVSS(np.zeros((50, 2)))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    d = mod['obs_intercept'].transpose(1, 0)[:, :, None]\n    Z = mod['design'].transpose(2, 0, 1)\n    H = mod['obs_cov'].transpose(2, 0, 1)\n    fcast = res.get_forecast(11, **kwargs)\n    fcast_signal = fcast.predicted_mean - mod_oos['obs_intercept'].T\n    fcast_signal_cov = fcast.var_pred_mean - mod_oos['obs_cov'].T\n    desired_s_signal = Z @ res.smoothed_state.T[:, :, None]\n    desired_f_signal = Z @ res.filtered_state.T[:, :, None]\n    desired_p_signal = Z @ res.predicted_state.T[:-1, :, None]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal)[..., 0])\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal)[..., 0])\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal)[..., 0])\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal[..., 0])\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal[..., 0])\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal[..., 0])\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    for t in range(mod.nobs):\n        assert_allclose(s_pred.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(f_pred.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(p_pred.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(s_signal.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T)\n        assert_allclose(f_signal.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T)\n        assert_allclose(p_signal.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
        "mutated": [
            "def test_predicted_filtered_smoothed_TVSS(reset_randomstate):\n    if False:\n        i = 10\n    mod = TVSS(np.zeros((50, 2)))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    d = mod['obs_intercept'].transpose(1, 0)[:, :, None]\n    Z = mod['design'].transpose(2, 0, 1)\n    H = mod['obs_cov'].transpose(2, 0, 1)\n    fcast = res.get_forecast(11, **kwargs)\n    fcast_signal = fcast.predicted_mean - mod_oos['obs_intercept'].T\n    fcast_signal_cov = fcast.var_pred_mean - mod_oos['obs_cov'].T\n    desired_s_signal = Z @ res.smoothed_state.T[:, :, None]\n    desired_f_signal = Z @ res.filtered_state.T[:, :, None]\n    desired_p_signal = Z @ res.predicted_state.T[:-1, :, None]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal)[..., 0])\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal)[..., 0])\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal)[..., 0])\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal[..., 0])\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal[..., 0])\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal[..., 0])\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    for t in range(mod.nobs):\n        assert_allclose(s_pred.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(f_pred.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(p_pred.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(s_signal.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T)\n        assert_allclose(f_signal.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T)\n        assert_allclose(p_signal.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
            "def test_predicted_filtered_smoothed_TVSS(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mod = TVSS(np.zeros((50, 2)))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    d = mod['obs_intercept'].transpose(1, 0)[:, :, None]\n    Z = mod['design'].transpose(2, 0, 1)\n    H = mod['obs_cov'].transpose(2, 0, 1)\n    fcast = res.get_forecast(11, **kwargs)\n    fcast_signal = fcast.predicted_mean - mod_oos['obs_intercept'].T\n    fcast_signal_cov = fcast.var_pred_mean - mod_oos['obs_cov'].T\n    desired_s_signal = Z @ res.smoothed_state.T[:, :, None]\n    desired_f_signal = Z @ res.filtered_state.T[:, :, None]\n    desired_p_signal = Z @ res.predicted_state.T[:-1, :, None]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal)[..., 0])\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal)[..., 0])\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal)[..., 0])\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal[..., 0])\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal[..., 0])\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal[..., 0])\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    for t in range(mod.nobs):\n        assert_allclose(s_pred.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(f_pred.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(p_pred.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(s_signal.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T)\n        assert_allclose(f_signal.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T)\n        assert_allclose(p_signal.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
            "def test_predicted_filtered_smoothed_TVSS(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mod = TVSS(np.zeros((50, 2)))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    d = mod['obs_intercept'].transpose(1, 0)[:, :, None]\n    Z = mod['design'].transpose(2, 0, 1)\n    H = mod['obs_cov'].transpose(2, 0, 1)\n    fcast = res.get_forecast(11, **kwargs)\n    fcast_signal = fcast.predicted_mean - mod_oos['obs_intercept'].T\n    fcast_signal_cov = fcast.var_pred_mean - mod_oos['obs_cov'].T\n    desired_s_signal = Z @ res.smoothed_state.T[:, :, None]\n    desired_f_signal = Z @ res.filtered_state.T[:, :, None]\n    desired_p_signal = Z @ res.predicted_state.T[:-1, :, None]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal)[..., 0])\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal)[..., 0])\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal)[..., 0])\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal[..., 0])\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal[..., 0])\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal[..., 0])\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    for t in range(mod.nobs):\n        assert_allclose(s_pred.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(f_pred.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(p_pred.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(s_signal.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T)\n        assert_allclose(f_signal.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T)\n        assert_allclose(p_signal.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
            "def test_predicted_filtered_smoothed_TVSS(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mod = TVSS(np.zeros((50, 2)))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    d = mod['obs_intercept'].transpose(1, 0)[:, :, None]\n    Z = mod['design'].transpose(2, 0, 1)\n    H = mod['obs_cov'].transpose(2, 0, 1)\n    fcast = res.get_forecast(11, **kwargs)\n    fcast_signal = fcast.predicted_mean - mod_oos['obs_intercept'].T\n    fcast_signal_cov = fcast.var_pred_mean - mod_oos['obs_cov'].T\n    desired_s_signal = Z @ res.smoothed_state.T[:, :, None]\n    desired_f_signal = Z @ res.filtered_state.T[:, :, None]\n    desired_p_signal = Z @ res.predicted_state.T[:-1, :, None]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal)[..., 0])\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal)[..., 0])\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal)[..., 0])\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal[..., 0])\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal[..., 0])\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal[..., 0])\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    for t in range(mod.nobs):\n        assert_allclose(s_pred.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(f_pred.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(p_pred.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(s_signal.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T)\n        assert_allclose(f_signal.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T)\n        assert_allclose(p_signal.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)",
            "def test_predicted_filtered_smoothed_TVSS(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mod = TVSS(np.zeros((50, 2)))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    res = mod.smooth([])\n    mod_oos = TVSS(np.zeros((11, 2)) * np.nan)\n    kwargs = {key: mod_oos[key] for key in ['obs_intercept', 'design', 'obs_cov', 'transition', 'selection', 'state_cov']}\n    p_pred = res.get_prediction(start=0, end=60, information_set='predicted', **kwargs)\n    f_pred = res.get_prediction(start=0, end=60, information_set='filtered', **kwargs)\n    s_pred = res.get_prediction(start=0, end=60, information_set='smoothed', **kwargs)\n    p_signal = res.get_prediction(start=0, end=60, information_set='predicted', signal_only=True, **kwargs)\n    f_signal = res.get_prediction(start=0, end=60, information_set='filtered', signal_only=True, **kwargs)\n    s_signal = res.get_prediction(start=0, end=60, information_set='smoothed', signal_only=True, **kwargs)\n    d = mod['obs_intercept'].transpose(1, 0)[:, :, None]\n    Z = mod['design'].transpose(2, 0, 1)\n    H = mod['obs_cov'].transpose(2, 0, 1)\n    fcast = res.get_forecast(11, **kwargs)\n    fcast_signal = fcast.predicted_mean - mod_oos['obs_intercept'].T\n    fcast_signal_cov = fcast.var_pred_mean - mod_oos['obs_cov'].T\n    desired_s_signal = Z @ res.smoothed_state.T[:, :, None]\n    desired_f_signal = Z @ res.filtered_state.T[:, :, None]\n    desired_p_signal = Z @ res.predicted_state.T[:-1, :, None]\n    assert_allclose(s_pred.predicted_mean[:50], (d + desired_s_signal)[..., 0])\n    assert_allclose(s_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(f_pred.predicted_mean[:50], (d + desired_f_signal)[..., 0])\n    assert_allclose(f_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(p_pred.predicted_mean[:50], (d + desired_p_signal)[..., 0])\n    assert_allclose(p_pred.predicted_mean[50:], fcast.predicted_mean)\n    assert_allclose(s_signal.predicted_mean[:50], desired_s_signal[..., 0])\n    assert_allclose(s_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(f_signal.predicted_mean[:50], desired_f_signal[..., 0])\n    assert_allclose(f_signal.predicted_mean[50:], fcast_signal)\n    assert_allclose(p_signal.predicted_mean[:50], desired_p_signal[..., 0])\n    assert_allclose(p_signal.predicted_mean[50:], fcast_signal)\n    for t in range(mod.nobs):\n        assert_allclose(s_pred.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(f_pred.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(p_pred.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T + H[t])\n        assert_allclose(s_signal.var_pred_mean[t], Z[t] @ res.smoothed_state_cov[..., t] @ Z[t].T)\n        assert_allclose(f_signal.var_pred_mean[t], Z[t] @ res.filtered_state_cov[..., t] @ Z[t].T)\n        assert_allclose(p_signal.var_pred_mean[t], Z[t] @ res.predicted_state_cov[..., t] @ Z[t].T)\n    assert_allclose(s_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(f_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(p_pred.var_pred_mean[50:], fcast.var_pred_mean)\n    assert_allclose(s_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(f_signal.var_pred_mean[50:], fcast_signal_cov)\n    assert_allclose(p_signal.var_pred_mean[50:], fcast_signal_cov)"
        ]
    },
    {
        "func_name": "test_predicted_filtered_dynamic_varmax",
        "original": "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_dynamic_varmax(use_exog, trend):\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit1 = exog[:50] if use_exog else None\n    x_fcast1 = exog[50:61] if use_exog else None\n    mod1 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit1)\n    res1 = mod1.filter(params)\n    x_fit2 = exog[:20] if use_exog else None\n    x_fcast2 = exog[20:61] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:20], order=(1, 0), trend=trend, exog=x_fit2)\n    res2 = mod2.filter(params)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)",
        "mutated": [
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_dynamic_varmax(use_exog, trend):\n    if False:\n        i = 10\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit1 = exog[:50] if use_exog else None\n    x_fcast1 = exog[50:61] if use_exog else None\n    mod1 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit1)\n    res1 = mod1.filter(params)\n    x_fit2 = exog[:20] if use_exog else None\n    x_fcast2 = exog[20:61] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:20], order=(1, 0), trend=trend, exog=x_fit2)\n    res2 = mod2.filter(params)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_dynamic_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit1 = exog[:50] if use_exog else None\n    x_fcast1 = exog[50:61] if use_exog else None\n    mod1 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit1)\n    res1 = mod1.filter(params)\n    x_fit2 = exog[:20] if use_exog else None\n    x_fcast2 = exog[20:61] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:20], order=(1, 0), trend=trend, exog=x_fit2)\n    res2 = mod2.filter(params)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_dynamic_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit1 = exog[:50] if use_exog else None\n    x_fcast1 = exog[50:61] if use_exog else None\n    mod1 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit1)\n    res1 = mod1.filter(params)\n    x_fit2 = exog[:20] if use_exog else None\n    x_fcast2 = exog[20:61] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:20], order=(1, 0), trend=trend, exog=x_fit2)\n    res2 = mod2.filter(params)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_dynamic_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit1 = exog[:50] if use_exog else None\n    x_fcast1 = exog[50:61] if use_exog else None\n    mod1 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit1)\n    res1 = mod1.filter(params)\n    x_fit2 = exog[:20] if use_exog else None\n    x_fcast2 = exog[20:61] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:20], order=(1, 0), trend=trend, exog=x_fit2)\n    res2 = mod2.filter(params)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_predicted_filtered_dynamic_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.log(dta[['realgdp', 'cpi']])\n    if trend in ['n', 'c']:\n        endog = endog.diff().iloc[1:] * 100\n    if trend == 'n':\n        endog -= endog.mean()\n    exog = np.ones(100) if use_exog else None\n    if use_exog:\n        exog[20:40] = 2.0\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    x_fit1 = exog[:50] if use_exog else None\n    x_fcast1 = exog[50:61] if use_exog else None\n    mod1 = varmax.VARMAX(endog[:50], order=(1, 0), trend=trend, exog=x_fit1)\n    res1 = mod1.filter(params)\n    x_fit2 = exog[:20] if use_exog else None\n    x_fcast2 = exog[20:61] if use_exog else None\n    mod2 = varmax.VARMAX(endog[:20], order=(1, 0), trend=trend, exog=x_fit2)\n    res2 = mod2.filter(params)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True)\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True)\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=0, dynamic=20, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=0, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=2, dynamic=18, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=2, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)\n    p1 = res1.get_prediction(start=20, dynamic=True, end=60, exog=x_fcast1, signal_only=True, information_set='filtered')\n    p2 = res2.get_prediction(start=20, end=60, exog=x_fcast2, signal_only=True, information_set='filtered')\n    assert_allclose(p1.predicted_mean, p2.predicted_mean)\n    assert_allclose(p1.var_pred_mean, p2.var_pred_mean)"
        ]
    }
]