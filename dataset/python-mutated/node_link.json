[
    {
        "func_name": "_to_tuple",
        "original": "def _to_tuple(x):\n    \"\"\"Converts lists to tuples, including nested lists.\n\n    All other non-list inputs are passed through unmodified. This function is\n    intended to be used to convert potentially nested lists from json files\n    into valid nodes.\n\n    Examples\n    --------\n    >>> _to_tuple([1, 2, [3, 4]])\n    (1, 2, (3, 4))\n    \"\"\"\n    if not isinstance(x, tuple | list):\n        return x\n    return tuple(map(_to_tuple, x))",
        "mutated": [
            "def _to_tuple(x):\n    if False:\n        i = 10\n    'Converts lists to tuples, including nested lists.\\n\\n    All other non-list inputs are passed through unmodified. This function is\\n    intended to be used to convert potentially nested lists from json files\\n    into valid nodes.\\n\\n    Examples\\n    --------\\n    >>> _to_tuple([1, 2, [3, 4]])\\n    (1, 2, (3, 4))\\n    '\n    if not isinstance(x, tuple | list):\n        return x\n    return tuple(map(_to_tuple, x))",
            "def _to_tuple(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Converts lists to tuples, including nested lists.\\n\\n    All other non-list inputs are passed through unmodified. This function is\\n    intended to be used to convert potentially nested lists from json files\\n    into valid nodes.\\n\\n    Examples\\n    --------\\n    >>> _to_tuple([1, 2, [3, 4]])\\n    (1, 2, (3, 4))\\n    '\n    if not isinstance(x, tuple | list):\n        return x\n    return tuple(map(_to_tuple, x))",
            "def _to_tuple(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Converts lists to tuples, including nested lists.\\n\\n    All other non-list inputs are passed through unmodified. This function is\\n    intended to be used to convert potentially nested lists from json files\\n    into valid nodes.\\n\\n    Examples\\n    --------\\n    >>> _to_tuple([1, 2, [3, 4]])\\n    (1, 2, (3, 4))\\n    '\n    if not isinstance(x, tuple | list):\n        return x\n    return tuple(map(_to_tuple, x))",
            "def _to_tuple(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Converts lists to tuples, including nested lists.\\n\\n    All other non-list inputs are passed through unmodified. This function is\\n    intended to be used to convert potentially nested lists from json files\\n    into valid nodes.\\n\\n    Examples\\n    --------\\n    >>> _to_tuple([1, 2, [3, 4]])\\n    (1, 2, (3, 4))\\n    '\n    if not isinstance(x, tuple | list):\n        return x\n    return tuple(map(_to_tuple, x))",
            "def _to_tuple(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Converts lists to tuples, including nested lists.\\n\\n    All other non-list inputs are passed through unmodified. This function is\\n    intended to be used to convert potentially nested lists from json files\\n    into valid nodes.\\n\\n    Examples\\n    --------\\n    >>> _to_tuple([1, 2, [3, 4]])\\n    (1, 2, (3, 4))\\n    '\n    if not isinstance(x, tuple | list):\n        return x\n    return tuple(map(_to_tuple, x))"
        ]
    },
    {
        "func_name": "node_link_data",
        "original": "def node_link_data(G, *, source='source', target='target', name='id', key='key', link='links'):\n    \"\"\"Returns data in node-link format that is suitable for JSON serialization\n    and use in JavaScript documents.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n    source : string\n        A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\n    target : string\n        A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\n    name : string\n        A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\n    key : string\n        A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\n    link : string\n        A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\n\n    Returns\n    -------\n    data : dict\n       A dictionary with node-link formatted data.\n\n    Raises\n    ------\n    NetworkXError\n        If the values of 'source', 'target' and 'key' are not unique.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(\"A\", \"B\")])\n    >>> data1 = nx.node_link_data(G)\n    >>> data1\n    {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\n\n    To serialize with JSON\n\n    >>> import json\n    >>> s1 = json.dumps(data1)\n    >>> s1\n    '{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\n\n    A graph can also be serialized by passing `node_link_data` as an encoder function. The two methods are equivalent.\n\n    >>> s1 = json.dumps(G, default=nx.node_link_data)\n    >>> s1\n    '{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\n\n    The attribute names for storing NetworkX-internal graph data can\n    be specified as keyword options.\n\n    >>> H = nx.gn_graph(2)\n    >>> data2 = nx.node_link_data(H, link=\"edges\", source=\"from\", target=\"to\")\n    >>> data2\n    {'directed': True, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 0}, {'id': 1}], 'edges': [{'from': 1, 'to': 0}]}\n\n    Notes\n    -----\n    Graph, node, and link attributes are stored in this format.  Note that\n    attribute keys will be converted to strings in order to comply with JSON.\n\n    Attribute 'key' is only used for multigraphs.\n\n    To use `node_link_data` in conjunction with `node_link_graph`,\n    the keyword names for the attributes must match.\n\n\n    See Also\n    --------\n    node_link_graph, adjacency_data, tree_data\n    \"\"\"\n    multigraph = G.is_multigraph()\n    key = None if not multigraph else key\n    if len({source, target, key}) < 3:\n        raise nx.NetworkXError('Attribute names are not unique.')\n    data = {'directed': G.is_directed(), 'multigraph': multigraph, 'graph': G.graph, 'nodes': [{**G.nodes[n], name: n} for n in G]}\n    if multigraph:\n        data[link] = [{**d, source: u, target: v, key: k} for (u, v, k, d) in G.edges(keys=True, data=True)]\n    else:\n        data[link] = [{**d, source: u, target: v} for (u, v, d) in G.edges(data=True)]\n    return data",
        "mutated": [
            "def node_link_data(G, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n    'Returns data in node-link format that is suitable for JSON serialization\\n    and use in JavaScript documents.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n    source : string\\n        A string that provides the \\'source\\' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the \\'target\\' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the \\'name\\' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the \\'key\\' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the \\'link\\' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    data : dict\\n       A dictionary with node-link formatted data.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the values of \\'source\\', \\'target\\' and \\'key\\' are not unique.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(\"A\", \"B\")])\\n    >>> data1 = nx.node_link_data(G)\\n    >>> data1\\n    {\\'directed\\': False, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': \\'A\\'}, {\\'id\\': \\'B\\'}], \\'links\\': [{\\'source\\': \\'A\\', \\'target\\': \\'B\\'}]}\\n\\n    To serialize with JSON\\n\\n    >>> import json\\n    >>> s1 = json.dumps(data1)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    A graph can also be serialized by passing `node_link_data` as an encoder function. The two methods are equivalent.\\n\\n    >>> s1 = json.dumps(G, default=nx.node_link_data)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    The attribute names for storing NetworkX-internal graph data can\\n    be specified as keyword options.\\n\\n    >>> H = nx.gn_graph(2)\\n    >>> data2 = nx.node_link_data(H, link=\"edges\", source=\"from\", target=\"to\")\\n    >>> data2\\n    {\\'directed\\': True, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': 0}, {\\'id\\': 1}], \\'edges\\': [{\\'from\\': 1, \\'to\\': 0}]}\\n\\n    Notes\\n    -----\\n    Graph, node, and link attributes are stored in this format.  Note that\\n    attribute keys will be converted to strings in order to comply with JSON.\\n\\n    Attribute \\'key\\' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n\\n    See Also\\n    --------\\n    node_link_graph, adjacency_data, tree_data\\n    '\n    multigraph = G.is_multigraph()\n    key = None if not multigraph else key\n    if len({source, target, key}) < 3:\n        raise nx.NetworkXError('Attribute names are not unique.')\n    data = {'directed': G.is_directed(), 'multigraph': multigraph, 'graph': G.graph, 'nodes': [{**G.nodes[n], name: n} for n in G]}\n    if multigraph:\n        data[link] = [{**d, source: u, target: v, key: k} for (u, v, k, d) in G.edges(keys=True, data=True)]\n    else:\n        data[link] = [{**d, source: u, target: v} for (u, v, d) in G.edges(data=True)]\n    return data",
            "def node_link_data(G, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns data in node-link format that is suitable for JSON serialization\\n    and use in JavaScript documents.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n    source : string\\n        A string that provides the \\'source\\' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the \\'target\\' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the \\'name\\' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the \\'key\\' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the \\'link\\' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    data : dict\\n       A dictionary with node-link formatted data.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the values of \\'source\\', \\'target\\' and \\'key\\' are not unique.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(\"A\", \"B\")])\\n    >>> data1 = nx.node_link_data(G)\\n    >>> data1\\n    {\\'directed\\': False, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': \\'A\\'}, {\\'id\\': \\'B\\'}], \\'links\\': [{\\'source\\': \\'A\\', \\'target\\': \\'B\\'}]}\\n\\n    To serialize with JSON\\n\\n    >>> import json\\n    >>> s1 = json.dumps(data1)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    A graph can also be serialized by passing `node_link_data` as an encoder function. The two methods are equivalent.\\n\\n    >>> s1 = json.dumps(G, default=nx.node_link_data)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    The attribute names for storing NetworkX-internal graph data can\\n    be specified as keyword options.\\n\\n    >>> H = nx.gn_graph(2)\\n    >>> data2 = nx.node_link_data(H, link=\"edges\", source=\"from\", target=\"to\")\\n    >>> data2\\n    {\\'directed\\': True, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': 0}, {\\'id\\': 1}], \\'edges\\': [{\\'from\\': 1, \\'to\\': 0}]}\\n\\n    Notes\\n    -----\\n    Graph, node, and link attributes are stored in this format.  Note that\\n    attribute keys will be converted to strings in order to comply with JSON.\\n\\n    Attribute \\'key\\' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n\\n    See Also\\n    --------\\n    node_link_graph, adjacency_data, tree_data\\n    '\n    multigraph = G.is_multigraph()\n    key = None if not multigraph else key\n    if len({source, target, key}) < 3:\n        raise nx.NetworkXError('Attribute names are not unique.')\n    data = {'directed': G.is_directed(), 'multigraph': multigraph, 'graph': G.graph, 'nodes': [{**G.nodes[n], name: n} for n in G]}\n    if multigraph:\n        data[link] = [{**d, source: u, target: v, key: k} for (u, v, k, d) in G.edges(keys=True, data=True)]\n    else:\n        data[link] = [{**d, source: u, target: v} for (u, v, d) in G.edges(data=True)]\n    return data",
            "def node_link_data(G, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns data in node-link format that is suitable for JSON serialization\\n    and use in JavaScript documents.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n    source : string\\n        A string that provides the \\'source\\' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the \\'target\\' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the \\'name\\' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the \\'key\\' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the \\'link\\' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    data : dict\\n       A dictionary with node-link formatted data.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the values of \\'source\\', \\'target\\' and \\'key\\' are not unique.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(\"A\", \"B\")])\\n    >>> data1 = nx.node_link_data(G)\\n    >>> data1\\n    {\\'directed\\': False, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': \\'A\\'}, {\\'id\\': \\'B\\'}], \\'links\\': [{\\'source\\': \\'A\\', \\'target\\': \\'B\\'}]}\\n\\n    To serialize with JSON\\n\\n    >>> import json\\n    >>> s1 = json.dumps(data1)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    A graph can also be serialized by passing `node_link_data` as an encoder function. The two methods are equivalent.\\n\\n    >>> s1 = json.dumps(G, default=nx.node_link_data)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    The attribute names for storing NetworkX-internal graph data can\\n    be specified as keyword options.\\n\\n    >>> H = nx.gn_graph(2)\\n    >>> data2 = nx.node_link_data(H, link=\"edges\", source=\"from\", target=\"to\")\\n    >>> data2\\n    {\\'directed\\': True, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': 0}, {\\'id\\': 1}], \\'edges\\': [{\\'from\\': 1, \\'to\\': 0}]}\\n\\n    Notes\\n    -----\\n    Graph, node, and link attributes are stored in this format.  Note that\\n    attribute keys will be converted to strings in order to comply with JSON.\\n\\n    Attribute \\'key\\' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n\\n    See Also\\n    --------\\n    node_link_graph, adjacency_data, tree_data\\n    '\n    multigraph = G.is_multigraph()\n    key = None if not multigraph else key\n    if len({source, target, key}) < 3:\n        raise nx.NetworkXError('Attribute names are not unique.')\n    data = {'directed': G.is_directed(), 'multigraph': multigraph, 'graph': G.graph, 'nodes': [{**G.nodes[n], name: n} for n in G]}\n    if multigraph:\n        data[link] = [{**d, source: u, target: v, key: k} for (u, v, k, d) in G.edges(keys=True, data=True)]\n    else:\n        data[link] = [{**d, source: u, target: v} for (u, v, d) in G.edges(data=True)]\n    return data",
            "def node_link_data(G, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns data in node-link format that is suitable for JSON serialization\\n    and use in JavaScript documents.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n    source : string\\n        A string that provides the \\'source\\' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the \\'target\\' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the \\'name\\' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the \\'key\\' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the \\'link\\' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    data : dict\\n       A dictionary with node-link formatted data.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the values of \\'source\\', \\'target\\' and \\'key\\' are not unique.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(\"A\", \"B\")])\\n    >>> data1 = nx.node_link_data(G)\\n    >>> data1\\n    {\\'directed\\': False, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': \\'A\\'}, {\\'id\\': \\'B\\'}], \\'links\\': [{\\'source\\': \\'A\\', \\'target\\': \\'B\\'}]}\\n\\n    To serialize with JSON\\n\\n    >>> import json\\n    >>> s1 = json.dumps(data1)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    A graph can also be serialized by passing `node_link_data` as an encoder function. The two methods are equivalent.\\n\\n    >>> s1 = json.dumps(G, default=nx.node_link_data)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    The attribute names for storing NetworkX-internal graph data can\\n    be specified as keyword options.\\n\\n    >>> H = nx.gn_graph(2)\\n    >>> data2 = nx.node_link_data(H, link=\"edges\", source=\"from\", target=\"to\")\\n    >>> data2\\n    {\\'directed\\': True, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': 0}, {\\'id\\': 1}], \\'edges\\': [{\\'from\\': 1, \\'to\\': 0}]}\\n\\n    Notes\\n    -----\\n    Graph, node, and link attributes are stored in this format.  Note that\\n    attribute keys will be converted to strings in order to comply with JSON.\\n\\n    Attribute \\'key\\' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n\\n    See Also\\n    --------\\n    node_link_graph, adjacency_data, tree_data\\n    '\n    multigraph = G.is_multigraph()\n    key = None if not multigraph else key\n    if len({source, target, key}) < 3:\n        raise nx.NetworkXError('Attribute names are not unique.')\n    data = {'directed': G.is_directed(), 'multigraph': multigraph, 'graph': G.graph, 'nodes': [{**G.nodes[n], name: n} for n in G]}\n    if multigraph:\n        data[link] = [{**d, source: u, target: v, key: k} for (u, v, k, d) in G.edges(keys=True, data=True)]\n    else:\n        data[link] = [{**d, source: u, target: v} for (u, v, d) in G.edges(data=True)]\n    return data",
            "def node_link_data(G, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns data in node-link format that is suitable for JSON serialization\\n    and use in JavaScript documents.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n    source : string\\n        A string that provides the \\'source\\' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the \\'target\\' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the \\'name\\' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the \\'key\\' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the \\'link\\' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    data : dict\\n       A dictionary with node-link formatted data.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the values of \\'source\\', \\'target\\' and \\'key\\' are not unique.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(\"A\", \"B\")])\\n    >>> data1 = nx.node_link_data(G)\\n    >>> data1\\n    {\\'directed\\': False, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': \\'A\\'}, {\\'id\\': \\'B\\'}], \\'links\\': [{\\'source\\': \\'A\\', \\'target\\': \\'B\\'}]}\\n\\n    To serialize with JSON\\n\\n    >>> import json\\n    >>> s1 = json.dumps(data1)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    A graph can also be serialized by passing `node_link_data` as an encoder function. The two methods are equivalent.\\n\\n    >>> s1 = json.dumps(G, default=nx.node_link_data)\\n    >>> s1\\n    \\'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}\\'\\n\\n    The attribute names for storing NetworkX-internal graph data can\\n    be specified as keyword options.\\n\\n    >>> H = nx.gn_graph(2)\\n    >>> data2 = nx.node_link_data(H, link=\"edges\", source=\"from\", target=\"to\")\\n    >>> data2\\n    {\\'directed\\': True, \\'multigraph\\': False, \\'graph\\': {}, \\'nodes\\': [{\\'id\\': 0}, {\\'id\\': 1}], \\'edges\\': [{\\'from\\': 1, \\'to\\': 0}]}\\n\\n    Notes\\n    -----\\n    Graph, node, and link attributes are stored in this format.  Note that\\n    attribute keys will be converted to strings in order to comply with JSON.\\n\\n    Attribute \\'key\\' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n\\n    See Also\\n    --------\\n    node_link_graph, adjacency_data, tree_data\\n    '\n    multigraph = G.is_multigraph()\n    key = None if not multigraph else key\n    if len({source, target, key}) < 3:\n        raise nx.NetworkXError('Attribute names are not unique.')\n    data = {'directed': G.is_directed(), 'multigraph': multigraph, 'graph': G.graph, 'nodes': [{**G.nodes[n], name: n} for n in G]}\n    if multigraph:\n        data[link] = [{**d, source: u, target: v, key: k} for (u, v, k, d) in G.edges(keys=True, data=True)]\n    else:\n        data[link] = [{**d, source: u, target: v} for (u, v, d) in G.edges(data=True)]\n    return data"
        ]
    },
    {
        "func_name": "node_link_graph",
        "original": "@nx._dispatch(graphs=None)\ndef node_link_graph(data, directed=False, multigraph=True, *, source='source', target='target', name='id', key='key', link='links'):\n    \"\"\"Returns graph from node-link data format.\n    Useful for de-serialization from JSON.\n\n    Parameters\n    ----------\n    data : dict\n        node-link formatted graph data\n\n    directed : bool\n        If True, and direction not specified in data, return a directed graph.\n\n    multigraph : bool\n        If True, and multigraph not specified in data, return a multigraph.\n\n    source : string\n        A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\n    target : string\n        A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\n    name : string\n        A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\n    key : string\n        A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\n    link : string\n        A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\n\n    Returns\n    -------\n    G : NetworkX graph\n        A NetworkX graph object\n\n    Examples\n    --------\n\n    Create data in node-link format by converting a graph.\n\n    >>> G = nx.Graph([('A', 'B')])\n    >>> data = nx.node_link_data(G)\n    >>> data\n    {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\n\n    Revert data in node-link format to a graph.\n\n    >>> H = nx.node_link_graph(data)\n    >>> print(H.edges)\n    [('A', 'B')]\n\n    To serialize and deserialize a graph with JSON,\n\n    >>> import json\n    >>> d = json.dumps(node_link_data(G))\n    >>> H = node_link_graph(json.loads(d))\n    >>> print(G.edges, H.edges)\n    [('A', 'B')] [('A', 'B')]\n\n\n    Notes\n    -----\n    Attribute 'key' is only used for multigraphs.\n\n    To use `node_link_data` in conjunction with `node_link_graph`,\n    the keyword names for the attributes must match.\n\n    See Also\n    --------\n    node_link_data, adjacency_data, tree_data\n    \"\"\"\n    multigraph = data.get('multigraph', multigraph)\n    directed = data.get('directed', directed)\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    key = None if not multigraph else key\n    graph.graph = data.get('graph', {})\n    c = count()\n    for d in data['nodes']:\n        node = _to_tuple(d.get(name, next(c)))\n        nodedata = {str(k): v for (k, v) in d.items() if k != name}\n        graph.add_node(node, **nodedata)\n    for d in data[link]:\n        src = tuple(d[source]) if isinstance(d[source], list) else d[source]\n        tgt = tuple(d[target]) if isinstance(d[target], list) else d[target]\n        if not multigraph:\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target}\n            graph.add_edge(src, tgt, **edgedata)\n        else:\n            ky = d.get(key, None)\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target and (k != key)}\n            graph.add_edge(src, tgt, ky, **edgedata)\n    return graph",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef node_link_graph(data, directed=False, multigraph=True, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n    \"Returns graph from node-link data format.\\n    Useful for de-serialization from JSON.\\n\\n    Parameters\\n    ----------\\n    data : dict\\n        node-link formatted graph data\\n\\n    directed : bool\\n        If True, and direction not specified in data, return a directed graph.\\n\\n    multigraph : bool\\n        If True, and multigraph not specified in data, return a multigraph.\\n\\n    source : string\\n        A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    G : NetworkX graph\\n        A NetworkX graph object\\n\\n    Examples\\n    --------\\n\\n    Create data in node-link format by converting a graph.\\n\\n    >>> G = nx.Graph([('A', 'B')])\\n    >>> data = nx.node_link_data(G)\\n    >>> data\\n    {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\\n\\n    Revert data in node-link format to a graph.\\n\\n    >>> H = nx.node_link_graph(data)\\n    >>> print(H.edges)\\n    [('A', 'B')]\\n\\n    To serialize and deserialize a graph with JSON,\\n\\n    >>> import json\\n    >>> d = json.dumps(node_link_data(G))\\n    >>> H = node_link_graph(json.loads(d))\\n    >>> print(G.edges, H.edges)\\n    [('A', 'B')] [('A', 'B')]\\n\\n\\n    Notes\\n    -----\\n    Attribute 'key' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n    See Also\\n    --------\\n    node_link_data, adjacency_data, tree_data\\n    \"\n    multigraph = data.get('multigraph', multigraph)\n    directed = data.get('directed', directed)\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    key = None if not multigraph else key\n    graph.graph = data.get('graph', {})\n    c = count()\n    for d in data['nodes']:\n        node = _to_tuple(d.get(name, next(c)))\n        nodedata = {str(k): v for (k, v) in d.items() if k != name}\n        graph.add_node(node, **nodedata)\n    for d in data[link]:\n        src = tuple(d[source]) if isinstance(d[source], list) else d[source]\n        tgt = tuple(d[target]) if isinstance(d[target], list) else d[target]\n        if not multigraph:\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target}\n            graph.add_edge(src, tgt, **edgedata)\n        else:\n            ky = d.get(key, None)\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target and (k != key)}\n            graph.add_edge(src, tgt, ky, **edgedata)\n    return graph",
            "@nx._dispatch(graphs=None)\ndef node_link_graph(data, directed=False, multigraph=True, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Returns graph from node-link data format.\\n    Useful for de-serialization from JSON.\\n\\n    Parameters\\n    ----------\\n    data : dict\\n        node-link formatted graph data\\n\\n    directed : bool\\n        If True, and direction not specified in data, return a directed graph.\\n\\n    multigraph : bool\\n        If True, and multigraph not specified in data, return a multigraph.\\n\\n    source : string\\n        A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    G : NetworkX graph\\n        A NetworkX graph object\\n\\n    Examples\\n    --------\\n\\n    Create data in node-link format by converting a graph.\\n\\n    >>> G = nx.Graph([('A', 'B')])\\n    >>> data = nx.node_link_data(G)\\n    >>> data\\n    {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\\n\\n    Revert data in node-link format to a graph.\\n\\n    >>> H = nx.node_link_graph(data)\\n    >>> print(H.edges)\\n    [('A', 'B')]\\n\\n    To serialize and deserialize a graph with JSON,\\n\\n    >>> import json\\n    >>> d = json.dumps(node_link_data(G))\\n    >>> H = node_link_graph(json.loads(d))\\n    >>> print(G.edges, H.edges)\\n    [('A', 'B')] [('A', 'B')]\\n\\n\\n    Notes\\n    -----\\n    Attribute 'key' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n    See Also\\n    --------\\n    node_link_data, adjacency_data, tree_data\\n    \"\n    multigraph = data.get('multigraph', multigraph)\n    directed = data.get('directed', directed)\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    key = None if not multigraph else key\n    graph.graph = data.get('graph', {})\n    c = count()\n    for d in data['nodes']:\n        node = _to_tuple(d.get(name, next(c)))\n        nodedata = {str(k): v for (k, v) in d.items() if k != name}\n        graph.add_node(node, **nodedata)\n    for d in data[link]:\n        src = tuple(d[source]) if isinstance(d[source], list) else d[source]\n        tgt = tuple(d[target]) if isinstance(d[target], list) else d[target]\n        if not multigraph:\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target}\n            graph.add_edge(src, tgt, **edgedata)\n        else:\n            ky = d.get(key, None)\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target and (k != key)}\n            graph.add_edge(src, tgt, ky, **edgedata)\n    return graph",
            "@nx._dispatch(graphs=None)\ndef node_link_graph(data, directed=False, multigraph=True, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Returns graph from node-link data format.\\n    Useful for de-serialization from JSON.\\n\\n    Parameters\\n    ----------\\n    data : dict\\n        node-link formatted graph data\\n\\n    directed : bool\\n        If True, and direction not specified in data, return a directed graph.\\n\\n    multigraph : bool\\n        If True, and multigraph not specified in data, return a multigraph.\\n\\n    source : string\\n        A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    G : NetworkX graph\\n        A NetworkX graph object\\n\\n    Examples\\n    --------\\n\\n    Create data in node-link format by converting a graph.\\n\\n    >>> G = nx.Graph([('A', 'B')])\\n    >>> data = nx.node_link_data(G)\\n    >>> data\\n    {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\\n\\n    Revert data in node-link format to a graph.\\n\\n    >>> H = nx.node_link_graph(data)\\n    >>> print(H.edges)\\n    [('A', 'B')]\\n\\n    To serialize and deserialize a graph with JSON,\\n\\n    >>> import json\\n    >>> d = json.dumps(node_link_data(G))\\n    >>> H = node_link_graph(json.loads(d))\\n    >>> print(G.edges, H.edges)\\n    [('A', 'B')] [('A', 'B')]\\n\\n\\n    Notes\\n    -----\\n    Attribute 'key' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n    See Also\\n    --------\\n    node_link_data, adjacency_data, tree_data\\n    \"\n    multigraph = data.get('multigraph', multigraph)\n    directed = data.get('directed', directed)\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    key = None if not multigraph else key\n    graph.graph = data.get('graph', {})\n    c = count()\n    for d in data['nodes']:\n        node = _to_tuple(d.get(name, next(c)))\n        nodedata = {str(k): v for (k, v) in d.items() if k != name}\n        graph.add_node(node, **nodedata)\n    for d in data[link]:\n        src = tuple(d[source]) if isinstance(d[source], list) else d[source]\n        tgt = tuple(d[target]) if isinstance(d[target], list) else d[target]\n        if not multigraph:\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target}\n            graph.add_edge(src, tgt, **edgedata)\n        else:\n            ky = d.get(key, None)\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target and (k != key)}\n            graph.add_edge(src, tgt, ky, **edgedata)\n    return graph",
            "@nx._dispatch(graphs=None)\ndef node_link_graph(data, directed=False, multigraph=True, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Returns graph from node-link data format.\\n    Useful for de-serialization from JSON.\\n\\n    Parameters\\n    ----------\\n    data : dict\\n        node-link formatted graph data\\n\\n    directed : bool\\n        If True, and direction not specified in data, return a directed graph.\\n\\n    multigraph : bool\\n        If True, and multigraph not specified in data, return a multigraph.\\n\\n    source : string\\n        A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    G : NetworkX graph\\n        A NetworkX graph object\\n\\n    Examples\\n    --------\\n\\n    Create data in node-link format by converting a graph.\\n\\n    >>> G = nx.Graph([('A', 'B')])\\n    >>> data = nx.node_link_data(G)\\n    >>> data\\n    {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\\n\\n    Revert data in node-link format to a graph.\\n\\n    >>> H = nx.node_link_graph(data)\\n    >>> print(H.edges)\\n    [('A', 'B')]\\n\\n    To serialize and deserialize a graph with JSON,\\n\\n    >>> import json\\n    >>> d = json.dumps(node_link_data(G))\\n    >>> H = node_link_graph(json.loads(d))\\n    >>> print(G.edges, H.edges)\\n    [('A', 'B')] [('A', 'B')]\\n\\n\\n    Notes\\n    -----\\n    Attribute 'key' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n    See Also\\n    --------\\n    node_link_data, adjacency_data, tree_data\\n    \"\n    multigraph = data.get('multigraph', multigraph)\n    directed = data.get('directed', directed)\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    key = None if not multigraph else key\n    graph.graph = data.get('graph', {})\n    c = count()\n    for d in data['nodes']:\n        node = _to_tuple(d.get(name, next(c)))\n        nodedata = {str(k): v for (k, v) in d.items() if k != name}\n        graph.add_node(node, **nodedata)\n    for d in data[link]:\n        src = tuple(d[source]) if isinstance(d[source], list) else d[source]\n        tgt = tuple(d[target]) if isinstance(d[target], list) else d[target]\n        if not multigraph:\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target}\n            graph.add_edge(src, tgt, **edgedata)\n        else:\n            ky = d.get(key, None)\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target and (k != key)}\n            graph.add_edge(src, tgt, ky, **edgedata)\n    return graph",
            "@nx._dispatch(graphs=None)\ndef node_link_graph(data, directed=False, multigraph=True, *, source='source', target='target', name='id', key='key', link='links'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Returns graph from node-link data format.\\n    Useful for de-serialization from JSON.\\n\\n    Parameters\\n    ----------\\n    data : dict\\n        node-link formatted graph data\\n\\n    directed : bool\\n        If True, and direction not specified in data, return a directed graph.\\n\\n    multigraph : bool\\n        If True, and multigraph not specified in data, return a multigraph.\\n\\n    source : string\\n        A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\\n    target : string\\n        A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\\n    name : string\\n        A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\\n    key : string\\n        A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\\n    link : string\\n        A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\\n\\n    Returns\\n    -------\\n    G : NetworkX graph\\n        A NetworkX graph object\\n\\n    Examples\\n    --------\\n\\n    Create data in node-link format by converting a graph.\\n\\n    >>> G = nx.Graph([('A', 'B')])\\n    >>> data = nx.node_link_data(G)\\n    >>> data\\n    {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\\n\\n    Revert data in node-link format to a graph.\\n\\n    >>> H = nx.node_link_graph(data)\\n    >>> print(H.edges)\\n    [('A', 'B')]\\n\\n    To serialize and deserialize a graph with JSON,\\n\\n    >>> import json\\n    >>> d = json.dumps(node_link_data(G))\\n    >>> H = node_link_graph(json.loads(d))\\n    >>> print(G.edges, H.edges)\\n    [('A', 'B')] [('A', 'B')]\\n\\n\\n    Notes\\n    -----\\n    Attribute 'key' is only used for multigraphs.\\n\\n    To use `node_link_data` in conjunction with `node_link_graph`,\\n    the keyword names for the attributes must match.\\n\\n    See Also\\n    --------\\n    node_link_data, adjacency_data, tree_data\\n    \"\n    multigraph = data.get('multigraph', multigraph)\n    directed = data.get('directed', directed)\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    key = None if not multigraph else key\n    graph.graph = data.get('graph', {})\n    c = count()\n    for d in data['nodes']:\n        node = _to_tuple(d.get(name, next(c)))\n        nodedata = {str(k): v for (k, v) in d.items() if k != name}\n        graph.add_node(node, **nodedata)\n    for d in data[link]:\n        src = tuple(d[source]) if isinstance(d[source], list) else d[source]\n        tgt = tuple(d[target]) if isinstance(d[target], list) else d[target]\n        if not multigraph:\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target}\n            graph.add_edge(src, tgt, **edgedata)\n        else:\n            ky = d.get(key, None)\n            edgedata = {str(k): v for (k, v) in d.items() if k != source and k != target and (k != key)}\n            graph.add_edge(src, tgt, ky, **edgedata)\n    return graph"
        ]
    }
]