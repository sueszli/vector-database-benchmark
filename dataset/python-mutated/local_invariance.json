[
    {
        "func_name": "two_qubit_local_invariants",
        "original": "def two_qubit_local_invariants(U: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the local invariants for a two-qubit unitary.\n\n    Args:\n        U (ndarray): Input two-qubit unitary.\n\n    Returns:\n        ndarray: NumPy array of local invariants [g0, g1, g2].\n\n    Raises:\n        ValueError: Input not a 2q unitary.\n\n    Notes:\n        Y. Makhlin, Quant. Info. Proc. 1, 243-252 (2002).\n        Zhang et al., Phys Rev A. 67, 042313 (2003).\n    \"\"\"\n    U = np.asarray(U)\n    if U.shape != (4, 4):\n        raise ValueError('Unitary must correspond to a two-qubit gate.')\n    Um = MAGIC.conj().T.dot(U.dot(MAGIC))\n    det_um = np.linalg.det(Um)\n    M = Um.T.dot(Um)\n    m_tr2 = M.trace()\n    m_tr2 *= m_tr2\n    G1 = m_tr2 / (16 * det_um)\n    G2 = (m_tr2 - np.trace(M.dot(M))) / (4 * det_um)\n    return np.round([G1.real, G1.imag, G2.real], 12) + 0.0",
        "mutated": [
            "def two_qubit_local_invariants(U: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n    'Computes the local invariants for a two-qubit unitary.\\n\\n    Args:\\n        U (ndarray): Input two-qubit unitary.\\n\\n    Returns:\\n        ndarray: NumPy array of local invariants [g0, g1, g2].\\n\\n    Raises:\\n        ValueError: Input not a 2q unitary.\\n\\n    Notes:\\n        Y. Makhlin, Quant. Info. Proc. 1, 243-252 (2002).\\n        Zhang et al., Phys Rev A. 67, 042313 (2003).\\n    '\n    U = np.asarray(U)\n    if U.shape != (4, 4):\n        raise ValueError('Unitary must correspond to a two-qubit gate.')\n    Um = MAGIC.conj().T.dot(U.dot(MAGIC))\n    det_um = np.linalg.det(Um)\n    M = Um.T.dot(Um)\n    m_tr2 = M.trace()\n    m_tr2 *= m_tr2\n    G1 = m_tr2 / (16 * det_um)\n    G2 = (m_tr2 - np.trace(M.dot(M))) / (4 * det_um)\n    return np.round([G1.real, G1.imag, G2.real], 12) + 0.0",
            "def two_qubit_local_invariants(U: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes the local invariants for a two-qubit unitary.\\n\\n    Args:\\n        U (ndarray): Input two-qubit unitary.\\n\\n    Returns:\\n        ndarray: NumPy array of local invariants [g0, g1, g2].\\n\\n    Raises:\\n        ValueError: Input not a 2q unitary.\\n\\n    Notes:\\n        Y. Makhlin, Quant. Info. Proc. 1, 243-252 (2002).\\n        Zhang et al., Phys Rev A. 67, 042313 (2003).\\n    '\n    U = np.asarray(U)\n    if U.shape != (4, 4):\n        raise ValueError('Unitary must correspond to a two-qubit gate.')\n    Um = MAGIC.conj().T.dot(U.dot(MAGIC))\n    det_um = np.linalg.det(Um)\n    M = Um.T.dot(Um)\n    m_tr2 = M.trace()\n    m_tr2 *= m_tr2\n    G1 = m_tr2 / (16 * det_um)\n    G2 = (m_tr2 - np.trace(M.dot(M))) / (4 * det_um)\n    return np.round([G1.real, G1.imag, G2.real], 12) + 0.0",
            "def two_qubit_local_invariants(U: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes the local invariants for a two-qubit unitary.\\n\\n    Args:\\n        U (ndarray): Input two-qubit unitary.\\n\\n    Returns:\\n        ndarray: NumPy array of local invariants [g0, g1, g2].\\n\\n    Raises:\\n        ValueError: Input not a 2q unitary.\\n\\n    Notes:\\n        Y. Makhlin, Quant. Info. Proc. 1, 243-252 (2002).\\n        Zhang et al., Phys Rev A. 67, 042313 (2003).\\n    '\n    U = np.asarray(U)\n    if U.shape != (4, 4):\n        raise ValueError('Unitary must correspond to a two-qubit gate.')\n    Um = MAGIC.conj().T.dot(U.dot(MAGIC))\n    det_um = np.linalg.det(Um)\n    M = Um.T.dot(Um)\n    m_tr2 = M.trace()\n    m_tr2 *= m_tr2\n    G1 = m_tr2 / (16 * det_um)\n    G2 = (m_tr2 - np.trace(M.dot(M))) / (4 * det_um)\n    return np.round([G1.real, G1.imag, G2.real], 12) + 0.0",
            "def two_qubit_local_invariants(U: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes the local invariants for a two-qubit unitary.\\n\\n    Args:\\n        U (ndarray): Input two-qubit unitary.\\n\\n    Returns:\\n        ndarray: NumPy array of local invariants [g0, g1, g2].\\n\\n    Raises:\\n        ValueError: Input not a 2q unitary.\\n\\n    Notes:\\n        Y. Makhlin, Quant. Info. Proc. 1, 243-252 (2002).\\n        Zhang et al., Phys Rev A. 67, 042313 (2003).\\n    '\n    U = np.asarray(U)\n    if U.shape != (4, 4):\n        raise ValueError('Unitary must correspond to a two-qubit gate.')\n    Um = MAGIC.conj().T.dot(U.dot(MAGIC))\n    det_um = np.linalg.det(Um)\n    M = Um.T.dot(Um)\n    m_tr2 = M.trace()\n    m_tr2 *= m_tr2\n    G1 = m_tr2 / (16 * det_um)\n    G2 = (m_tr2 - np.trace(M.dot(M))) / (4 * det_um)\n    return np.round([G1.real, G1.imag, G2.real], 12) + 0.0",
            "def two_qubit_local_invariants(U: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes the local invariants for a two-qubit unitary.\\n\\n    Args:\\n        U (ndarray): Input two-qubit unitary.\\n\\n    Returns:\\n        ndarray: NumPy array of local invariants [g0, g1, g2].\\n\\n    Raises:\\n        ValueError: Input not a 2q unitary.\\n\\n    Notes:\\n        Y. Makhlin, Quant. Info. Proc. 1, 243-252 (2002).\\n        Zhang et al., Phys Rev A. 67, 042313 (2003).\\n    '\n    U = np.asarray(U)\n    if U.shape != (4, 4):\n        raise ValueError('Unitary must correspond to a two-qubit gate.')\n    Um = MAGIC.conj().T.dot(U.dot(MAGIC))\n    det_um = np.linalg.det(Um)\n    M = Um.T.dot(Um)\n    m_tr2 = M.trace()\n    m_tr2 *= m_tr2\n    G1 = m_tr2 / (16 * det_um)\n    G2 = (m_tr2 - np.trace(M.dot(M))) / (4 * det_um)\n    return np.round([G1.real, G1.imag, G2.real], 12) + 0.0"
        ]
    },
    {
        "func_name": "local_equivalence",
        "original": "def local_equivalence(weyl: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the equivalent local invariants from the\n    Weyl coordinates.\n\n    Args:\n        weyl (ndarray): Weyl coordinates.\n\n    Returns:\n        ndarray: Local equivalent coordinates [g0, g1, g3].\n\n    Notes:\n        This uses Eq. 30 from Zhang et al, PRA 67, 042313 (2003),\n        but we multiply weyl coordinates by 2 since we are\n        working in the reduced chamber.\n    \"\"\"\n    g0_equiv = np.prod(np.cos(2 * weyl) ** 2) - np.prod(np.sin(2 * weyl) ** 2)\n    g1_equiv = np.prod(np.sin(4 * weyl)) / 4\n    g2_equiv = 4 * np.prod(np.cos(2 * weyl) ** 2) - 4 * np.prod(np.sin(2 * weyl) ** 2) - np.prod(np.cos(4 * weyl))\n    return np.round([g0_equiv, g1_equiv, g2_equiv], 12) + 0.0",
        "mutated": [
            "def local_equivalence(weyl: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n    'Computes the equivalent local invariants from the\\n    Weyl coordinates.\\n\\n    Args:\\n        weyl (ndarray): Weyl coordinates.\\n\\n    Returns:\\n        ndarray: Local equivalent coordinates [g0, g1, g3].\\n\\n    Notes:\\n        This uses Eq. 30 from Zhang et al, PRA 67, 042313 (2003),\\n        but we multiply weyl coordinates by 2 since we are\\n        working in the reduced chamber.\\n    '\n    g0_equiv = np.prod(np.cos(2 * weyl) ** 2) - np.prod(np.sin(2 * weyl) ** 2)\n    g1_equiv = np.prod(np.sin(4 * weyl)) / 4\n    g2_equiv = 4 * np.prod(np.cos(2 * weyl) ** 2) - 4 * np.prod(np.sin(2 * weyl) ** 2) - np.prod(np.cos(4 * weyl))\n    return np.round([g0_equiv, g1_equiv, g2_equiv], 12) + 0.0",
            "def local_equivalence(weyl: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes the equivalent local invariants from the\\n    Weyl coordinates.\\n\\n    Args:\\n        weyl (ndarray): Weyl coordinates.\\n\\n    Returns:\\n        ndarray: Local equivalent coordinates [g0, g1, g3].\\n\\n    Notes:\\n        This uses Eq. 30 from Zhang et al, PRA 67, 042313 (2003),\\n        but we multiply weyl coordinates by 2 since we are\\n        working in the reduced chamber.\\n    '\n    g0_equiv = np.prod(np.cos(2 * weyl) ** 2) - np.prod(np.sin(2 * weyl) ** 2)\n    g1_equiv = np.prod(np.sin(4 * weyl)) / 4\n    g2_equiv = 4 * np.prod(np.cos(2 * weyl) ** 2) - 4 * np.prod(np.sin(2 * weyl) ** 2) - np.prod(np.cos(4 * weyl))\n    return np.round([g0_equiv, g1_equiv, g2_equiv], 12) + 0.0",
            "def local_equivalence(weyl: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes the equivalent local invariants from the\\n    Weyl coordinates.\\n\\n    Args:\\n        weyl (ndarray): Weyl coordinates.\\n\\n    Returns:\\n        ndarray: Local equivalent coordinates [g0, g1, g3].\\n\\n    Notes:\\n        This uses Eq. 30 from Zhang et al, PRA 67, 042313 (2003),\\n        but we multiply weyl coordinates by 2 since we are\\n        working in the reduced chamber.\\n    '\n    g0_equiv = np.prod(np.cos(2 * weyl) ** 2) - np.prod(np.sin(2 * weyl) ** 2)\n    g1_equiv = np.prod(np.sin(4 * weyl)) / 4\n    g2_equiv = 4 * np.prod(np.cos(2 * weyl) ** 2) - 4 * np.prod(np.sin(2 * weyl) ** 2) - np.prod(np.cos(4 * weyl))\n    return np.round([g0_equiv, g1_equiv, g2_equiv], 12) + 0.0",
            "def local_equivalence(weyl: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes the equivalent local invariants from the\\n    Weyl coordinates.\\n\\n    Args:\\n        weyl (ndarray): Weyl coordinates.\\n\\n    Returns:\\n        ndarray: Local equivalent coordinates [g0, g1, g3].\\n\\n    Notes:\\n        This uses Eq. 30 from Zhang et al, PRA 67, 042313 (2003),\\n        but we multiply weyl coordinates by 2 since we are\\n        working in the reduced chamber.\\n    '\n    g0_equiv = np.prod(np.cos(2 * weyl) ** 2) - np.prod(np.sin(2 * weyl) ** 2)\n    g1_equiv = np.prod(np.sin(4 * weyl)) / 4\n    g2_equiv = 4 * np.prod(np.cos(2 * weyl) ** 2) - 4 * np.prod(np.sin(2 * weyl) ** 2) - np.prod(np.cos(4 * weyl))\n    return np.round([g0_equiv, g1_equiv, g2_equiv], 12) + 0.0",
            "def local_equivalence(weyl: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes the equivalent local invariants from the\\n    Weyl coordinates.\\n\\n    Args:\\n        weyl (ndarray): Weyl coordinates.\\n\\n    Returns:\\n        ndarray: Local equivalent coordinates [g0, g1, g3].\\n\\n    Notes:\\n        This uses Eq. 30 from Zhang et al, PRA 67, 042313 (2003),\\n        but we multiply weyl coordinates by 2 since we are\\n        working in the reduced chamber.\\n    '\n    g0_equiv = np.prod(np.cos(2 * weyl) ** 2) - np.prod(np.sin(2 * weyl) ** 2)\n    g1_equiv = np.prod(np.sin(4 * weyl)) / 4\n    g2_equiv = 4 * np.prod(np.cos(2 * weyl) ** 2) - 4 * np.prod(np.sin(2 * weyl) ** 2) - np.prod(np.cos(4 * weyl))\n    return np.round([g0_equiv, g1_equiv, g2_equiv], 12) + 0.0"
        ]
    }
]