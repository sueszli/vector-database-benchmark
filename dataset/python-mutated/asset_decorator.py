from typing import Any, Callable, Dict, FrozenSet, Mapping, Optional, Sequence, Set, Tuple
from dagster import AssetCheckSpec, AssetDep, AssetKey, AssetOut, AssetsDefinition, BackfillPolicy, DagsterInvalidDefinitionError, Nothing, PartitionsDefinition, multi_asset
from dagster._utils.warnings import disable_dagster_warnings, experimental_warning
from .asset_utils import DAGSTER_DBT_TRANSLATOR_METADATA_KEY, MANIFEST_METADATA_KEY, default_asset_check_fn, default_code_version_fn, get_deps, has_self_dependency
from .dagster_dbt_translator import DagsterDbtTranslator, DbtManifestWrapper, validate_translator
from .dbt_manifest import DbtManifestParam, validate_manifest
from .utils import ASSET_RESOURCE_TYPES, get_dbt_resource_props_by_dbt_unique_id_from_manifest, output_name_fn, select_unique_ids_from_manifest

def dbt_assets(*, manifest: DbtManifestParam, select: str='fqn:*', exclude: Optional[str]=None, name: Optional[str]=None, io_manager_key: Optional[str]=None, partitions_def: Optional[PartitionsDefinition]=None, dagster_dbt_translator: DagsterDbtTranslator=DagsterDbtTranslator(), backfill_policy: Optional[BackfillPolicy]=None, op_tags: Optional[Mapping[str, Any]]=None) -> Callable[..., AssetsDefinition]:
    if False:
        i = 10
        return i + 15
    'Create a definition for how to compute a set of dbt resources, described by a manifest.json.\n    When invoking dbt commands using :py:class:`~dagster_dbt.DbtCliResource`\'s\n    :py:meth:`~dagster_dbt.DbtCliResource.cli` method, Dagster events are emitted by calling\n    ``yield from`` on the event stream returned by :py:meth:`~dagster_dbt.DbtCliInvocation.stream`.\n\n    Args:\n        manifest (Union[Mapping[str, Any], str, Path]): The contents of a manifest.json file\n            or the path to a manifest.json file. A manifest.json contains a representation of a\n            dbt project (models, tests, macros, etc). We use this representation to create\n            corresponding Dagster assets.\n        select (str): A dbt selection string for the models in a project that you want\n            to include. Defaults to ``fqn:*``.\n        exclude (Optional[str]): A dbt selection string for the models in a project that you want\n            to exclude. Defaults to "".\n        name (Optional[str]): The name of the op.\n        io_manager_key (Optional[str]): The IO manager key that will be set on each of the returned\n            assets. When other ops are downstream of the loaded assets, the IOManager specified\n            here determines how the inputs to those ops are loaded. Defaults to "io_manager".\n        partitions_def (Optional[PartitionsDefinition]): Defines the set of partition keys that\n            compose the dbt assets.\n        dagster_dbt_translator (Optional[DagsterDbtTranslator]): Allows customizing how to map\n            dbt models, seeds, etc. to asset keys and asset metadata.\n        backfill_policy (Optional[BackfillPolicy]): If a partitions_def is defined, this determines\n            how to execute backfills that target multiple partitions.\n        op_tags (Optional[Dict[str, Any]]): A dictionary of tags for the op that computes the assets.\n            Frameworks may expect and require certain metadata to be attached to a op. Values that\n            are not strings will be json encoded and must meet the criteria that\n            `json.loads(json.dumps(value)) == value`.\n\n    Examples:\n        Running ``dbt build`` for a dbt project:\n\n        .. code-block:: python\n\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext\n            from dagster_dbt import DbtCliResource, dbt_assets\n\n\n            @dbt_assets(manifest=Path("target", "manifest.json"))\n            def my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):\n                yield from dbt.cli(["build"], context=context).stream()\n\n        Running dbt commands with flags:\n\n        .. code-block:: python\n\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext\n            from dagster_dbt import DbtCliResource, dbt_assets\n\n\n            @dbt_assets(manifest=Path("target", "manifest.json"))\n            def my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):\n                yield from dbt.cli(["build", "--full-refresh"], context=context).stream()\n\n        Running dbt commands with ``--vars``:\n\n        .. code-block:: python\n\n            import json\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext\n            from dagster_dbt import DbtCliResource, dbt_assets\n\n\n            @dbt_assets(manifest=Path("target", "manifest.json"))\n            def my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):\n                dbt_vars = {"key": "value"}\n\n                yield from dbt.cli(["build", "--vars", json.dumps(dbt_vars)], context=context).stream()\n\n        Retrieving dbt artifacts after running a dbt command:\n\n        .. code-block:: python\n\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext\n            from dagster_dbt import DbtCliResource, dbt_assets\n\n\n            @dbt_assets(manifest=Path("target", "manifest.json"))\n            def my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):\n                dbt_build_invocation = dbt.cli(["build"], context=context)\n\n                yield from dbt_build_invocation.stream()\n\n                run_results_json = dbt_build_invocation.get_artifact("run_results.json")\n\n        Running multiple dbt commands for a dbt project:\n\n        .. code-block:: python\n\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext\n            from dagster_dbt import DbtCliResource, dbt_assets\n\n\n            @dbt_assets(manifest=Path("target", "manifest.json"))\n            def my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):\n                yield from dbt.cli(["run"], context=context).stream()\n                yield from dbt.cli(["test"], context=context).stream()\n\n        Customizing the Dagster asset metadata inferred from a dbt project using :py:class:`~dagster_dbt.DagsterDbtTranslator`:\n\n        .. code-block:: python\n\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext\n            from dagster_dbt import DagsterDbtTranslator, DbtCliResource, dbt_assets\n\n\n            class CustomDagsterDbtTranslator(DagsterDbtTranslator):\n                ...\n\n\n            @dbt_assets(\n                manifest=Path("target", "manifest.json"),\n                dagster_dbt_translator=CustomDagsterDbtTranslator(),\n            )\n            def my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):\n                yield from dbt.cli(["build"], context=context).stream()\n\n        Invoking another Dagster :py:class:`~dagster.ResourceDefinition` alongside dbt:\n\n        .. code-block:: python\n\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext\n            from dagster_dbt import DagsterDbtTranslator, DbtCliResource, dbt_assets\n            from dagster_slack import SlackResource\n\n\n            @dbt_assets(manifest=Path("target", "manifest.json"))\n            def my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource, slack: SlackResource):\n                yield from dbt.cli(["build"], context=context).stream()\n\n                slack_client = slack.get_client()\n                slack_client.chat_postMessage(channel="#my-channel", text="dbt build succeeded!")\n\n        Defining and accessing Dagster :py:class:`~dagster.Config` alongside dbt:\n\n        .. code-block:: python\n\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext, Config\n            from dagster_dbt import DagsterDbtTranslator, DbtCliResource, dbt_assets\n\n\n            class MyDbtConfig(Config):\n                full_refresh: bool\n\n\n            @dbt_assets(manifest=Path("target", "manifest.json"))\n            def my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource, config: MyDbtConfig):\n                dbt_build_args = ["build"]\n                if config.full_refresh:\n                    dbt_build_args += ["--full-refresh"]\n\n                yield from dbt.cli(dbt_build_args, context=context).stream()\n\n        Defining Dagster :py:class:`~dagster.PartitionDefinition` alongside dbt:\n\n\n        .. code-block:: python\n\n            import json\n            from pathlib import Path\n\n            from dagster import AssetExecutionContext, DailyPartitionDefinition\n            from dagster_dbt import DbtCliResource, dbt_assets\n\n\n            @dbt_assets(\n                manifest=Path("target", "manifest.json"),\n                partitions_def=DailyPartitionsDefinition(start_date="2023-01-01")\n            )\n            def partitionshop_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):\n                time_window = context.asset_partitions_time_window_for_output(\n                    list(context.selected_output_names)[0]\n                )\n\n                dbt_vars = {\n                    "min_date": time_window.start.isoformat(),\n                    "max_date": time_window.end.isoformat()\n                }\n                dbt_build_args = ["build", "--vars", json.dumps(dbt_vars)]\n\n                yield from dbt.cli(dbt_build_args, context=context).stream()\n\n    '
    dagster_dbt_translator = validate_translator(dagster_dbt_translator)
    manifest = validate_manifest(manifest)
    unique_ids = select_unique_ids_from_manifest(select=select, exclude=exclude or '', manifest_json=manifest)
    node_info_by_dbt_unique_id = get_dbt_resource_props_by_dbt_unique_id_from_manifest(manifest)
    dbt_unique_id_deps = get_deps(dbt_nodes=node_info_by_dbt_unique_id, selected_unique_ids=unique_ids, asset_resource_types=ASSET_RESOURCE_TYPES)
    (deps, outs, internal_asset_deps, check_specs) = get_dbt_multi_asset_args(dbt_nodes=node_info_by_dbt_unique_id, dbt_unique_id_deps=dbt_unique_id_deps, io_manager_key=io_manager_key, manifest=manifest, dagster_dbt_translator=dagster_dbt_translator)
    if op_tags and 'dagster-dbt/select' in op_tags:
        raise DagsterInvalidDefinitionError("To specify a dbt selection, use the 'select' argument, not 'dagster-dbt/select' with op_tags")
    if op_tags and 'dagster-dbt/exclude' in op_tags:
        raise DagsterInvalidDefinitionError("To specify a dbt exclusion, use the 'exclude' argument, not 'dagster-dbt/exclude' with op_tags")
    resolved_op_tags = {**({'dagster-dbt/select': select} if select else {}), **({'dagster-dbt/exclude': exclude} if exclude else {}), **(op_tags if op_tags else {})}

    def inner(fn) -> AssetsDefinition:
        if False:
            i = 10
            return i + 15
        asset_definition = multi_asset(outs=outs, name=name, internal_asset_deps=internal_asset_deps, deps=deps, compute_kind='dbt', partitions_def=partitions_def, can_subset=True, op_tags=resolved_op_tags, check_specs=check_specs, backfill_policy=backfill_policy)(fn)
        return asset_definition
    return inner

def get_dbt_multi_asset_args(dbt_nodes: Mapping[str, Any], dbt_unique_id_deps: Mapping[str, FrozenSet[str]], io_manager_key: Optional[str], manifest: Mapping[str, Any], dagster_dbt_translator: DagsterDbtTranslator) -> Tuple[Sequence[AssetDep], Dict[str, AssetOut], Dict[str, Set[AssetKey]], Sequence[AssetCheckSpec]]:
    if False:
        while True:
            i = 10
    deps: Set[AssetDep] = set()
    outs: Dict[str, AssetOut] = {}
    internal_asset_deps: Dict[str, Set[AssetKey]] = {}
    check_specs: Sequence[AssetCheckSpec] = []
    for (unique_id, parent_unique_ids) in dbt_unique_id_deps.items():
        dbt_resource_props = dbt_nodes[unique_id]
        output_name = output_name_fn(dbt_resource_props)
        asset_key = dagster_dbt_translator.get_asset_key(dbt_resource_props)
        outs[output_name] = AssetOut(key=asset_key, dagster_type=Nothing, io_manager_key=io_manager_key, description=dagster_dbt_translator.get_description(dbt_resource_props), is_required=False, metadata={**dagster_dbt_translator.get_metadata(dbt_resource_props), MANIFEST_METADATA_KEY: DbtManifestWrapper(manifest=manifest), DAGSTER_DBT_TRANSLATOR_METADATA_KEY: dagster_dbt_translator}, group_name=dagster_dbt_translator.get_group_name(dbt_resource_props), code_version=default_code_version_fn(dbt_resource_props), freshness_policy=dagster_dbt_translator.get_freshness_policy(dbt_resource_props), auto_materialize_policy=dagster_dbt_translator.get_auto_materialize_policy(dbt_resource_props))
        test_unique_ids = [child_unique_id for child_unique_id in manifest['child_map'][unique_id] if child_unique_id.startswith('test')]
        for test_unique_id in test_unique_ids:
            test_resource_props = manifest['nodes'][test_unique_id]
            check_spec = default_asset_check_fn(asset_key, unique_id, dagster_dbt_translator.settings, test_resource_props)
            if check_spec:
                check_specs.append(check_spec)
        with disable_dagster_warnings():
            output_internal_deps = internal_asset_deps.setdefault(output_name, set())
            for parent_unique_id in parent_unique_ids:
                dbt_parent_resource_props = dbt_nodes[parent_unique_id]
                parent_asset_key = dagster_dbt_translator.get_asset_key(dbt_parent_resource_props)
                parent_partition_mapping = dagster_dbt_translator.get_partition_mapping(dbt_resource_props, dbt_parent_resource_props=dbt_parent_resource_props)
                if parent_partition_mapping:
                    experimental_warning('DagsterDbtTranslator.get_partition_mapping')
                output_internal_deps.add(parent_asset_key)
                if parent_unique_id not in dbt_unique_id_deps:
                    deps.add(AssetDep(asset=parent_asset_key, partition_mapping=parent_partition_mapping))
            self_partition_mapping = dagster_dbt_translator.get_partition_mapping(dbt_resource_props, dbt_parent_resource_props=dbt_resource_props)
            if self_partition_mapping and has_self_dependency(dbt_resource_props):
                experimental_warning('+meta.dagster.has_self_dependency')
                deps.add(AssetDep(asset=asset_key, partition_mapping=self_partition_mapping))
                output_internal_deps.add(asset_key)
    return (list(deps), outs, internal_asset_deps, check_specs)