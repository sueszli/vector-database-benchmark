"""
    flyteidl/service/admin.proto

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: version not set
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""
import pprint
import re
import six
from flyteadmin.models.admin_annotations import AdminAnnotations
from flyteadmin.models.admin_auth_role import AdminAuthRole
from flyteadmin.models.admin_cluster_assignment import AdminClusterAssignment
from flyteadmin.models.admin_envs import AdminEnvs
from flyteadmin.models.admin_execution_metadata import AdminExecutionMetadata
from flyteadmin.models.admin_labels import AdminLabels
from flyteadmin.models.admin_notification_list import AdminNotificationList
from flyteadmin.models.admin_raw_output_data_config import AdminRawOutputDataConfig
from flyteadmin.models.core_identifier import CoreIdentifier
from flyteadmin.models.core_literal_map import CoreLiteralMap
from flyteadmin.models.core_quality_of_service import CoreQualityOfService
from flyteadmin.models.core_security_context import CoreSecurityContext

class AdminExecutionSpec(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    '\n    Attributes:\n      swagger_types (dict): The key is attribute name\n                            and the value is attribute type.\n      attribute_map (dict): The key is attribute name\n                            and the value is json key in definition.\n    '
    swagger_types = {'launch_plan': 'CoreIdentifier', 'inputs': 'CoreLiteralMap', 'metadata': 'AdminExecutionMetadata', 'notifications': 'AdminNotificationList', 'disable_all': 'bool', 'labels': 'AdminLabels', 'annotations': 'AdminAnnotations', 'security_context': 'CoreSecurityContext', 'auth_role': 'AdminAuthRole', 'quality_of_service': 'CoreQualityOfService', 'max_parallelism': 'int', 'raw_output_data_config': 'AdminRawOutputDataConfig', 'cluster_assignment': 'AdminClusterAssignment', 'interruptible': 'bool', 'overwrite_cache': 'bool', 'envs': 'AdminEnvs', 'tags': 'list[str]'}
    attribute_map = {'launch_plan': 'launch_plan', 'inputs': 'inputs', 'metadata': 'metadata', 'notifications': 'notifications', 'disable_all': 'disable_all', 'labels': 'labels', 'annotations': 'annotations', 'security_context': 'security_context', 'auth_role': 'auth_role', 'quality_of_service': 'quality_of_service', 'max_parallelism': 'max_parallelism', 'raw_output_data_config': 'raw_output_data_config', 'cluster_assignment': 'cluster_assignment', 'interruptible': 'interruptible', 'overwrite_cache': 'overwrite_cache', 'envs': 'envs', 'tags': 'tags'}

    def __init__(self, launch_plan=None, inputs=None, metadata=None, notifications=None, disable_all=None, labels=None, annotations=None, security_context=None, auth_role=None, quality_of_service=None, max_parallelism=None, raw_output_data_config=None, cluster_assignment=None, interruptible=None, overwrite_cache=None, envs=None, tags=None):
        if False:
            print('Hello World!')
        'AdminExecutionSpec - a model defined in Swagger'
        self._launch_plan = None
        self._inputs = None
        self._metadata = None
        self._notifications = None
        self._disable_all = None
        self._labels = None
        self._annotations = None
        self._security_context = None
        self._auth_role = None
        self._quality_of_service = None
        self._max_parallelism = None
        self._raw_output_data_config = None
        self._cluster_assignment = None
        self._interruptible = None
        self._overwrite_cache = None
        self._envs = None
        self._tags = None
        self.discriminator = None
        if launch_plan is not None:
            self.launch_plan = launch_plan
        if inputs is not None:
            self.inputs = inputs
        if metadata is not None:
            self.metadata = metadata
        if notifications is not None:
            self.notifications = notifications
        if disable_all is not None:
            self.disable_all = disable_all
        if labels is not None:
            self.labels = labels
        if annotations is not None:
            self.annotations = annotations
        if security_context is not None:
            self.security_context = security_context
        if auth_role is not None:
            self.auth_role = auth_role
        if quality_of_service is not None:
            self.quality_of_service = quality_of_service
        if max_parallelism is not None:
            self.max_parallelism = max_parallelism
        if raw_output_data_config is not None:
            self.raw_output_data_config = raw_output_data_config
        if cluster_assignment is not None:
            self.cluster_assignment = cluster_assignment
        if interruptible is not None:
            self.interruptible = interruptible
        if overwrite_cache is not None:
            self.overwrite_cache = overwrite_cache
        if envs is not None:
            self.envs = envs
        if tags is not None:
            self.tags = tags

    @property
    def launch_plan(self):
        if False:
            while True:
                i = 10
        'Gets the launch_plan of this AdminExecutionSpec.  # noqa: E501\n\n\n        :return: The launch_plan of this AdminExecutionSpec.  # noqa: E501\n        :rtype: CoreIdentifier\n        '
        return self._launch_plan

    @launch_plan.setter
    def launch_plan(self, launch_plan):
        if False:
            print('Hello World!')
        'Sets the launch_plan of this AdminExecutionSpec.\n\n\n        :param launch_plan: The launch_plan of this AdminExecutionSpec.  # noqa: E501\n        :type: CoreIdentifier\n        '
        self._launch_plan = launch_plan

    @property
    def inputs(self):
        if False:
            return 10
        'Gets the inputs of this AdminExecutionSpec.  # noqa: E501\n\n\n        :return: The inputs of this AdminExecutionSpec.  # noqa: E501\n        :rtype: CoreLiteralMap\n        '
        return self._inputs

    @inputs.setter
    def inputs(self, inputs):
        if False:
            print('Hello World!')
        'Sets the inputs of this AdminExecutionSpec.\n\n\n        :param inputs: The inputs of this AdminExecutionSpec.  # noqa: E501\n        :type: CoreLiteralMap\n        '
        self._inputs = inputs

    @property
    def metadata(self):
        if False:
            print('Hello World!')
        'Gets the metadata of this AdminExecutionSpec.  # noqa: E501\n\n\n        :return: The metadata of this AdminExecutionSpec.  # noqa: E501\n        :rtype: AdminExecutionMetadata\n        '
        return self._metadata

    @metadata.setter
    def metadata(self, metadata):
        if False:
            i = 10
            return i + 15
        'Sets the metadata of this AdminExecutionSpec.\n\n\n        :param metadata: The metadata of this AdminExecutionSpec.  # noqa: E501\n        :type: AdminExecutionMetadata\n        '
        self._metadata = metadata

    @property
    def notifications(self):
        if False:
            for i in range(10):
                print('nop')
        'Gets the notifications of this AdminExecutionSpec.  # noqa: E501\n\n        List of notifications based on Execution status transitions When this list is not empty it is used rather than any notifications defined in the referenced launch plan. When this list is empty, the notifications defined for the launch plan will be applied.  # noqa: E501\n\n        :return: The notifications of this AdminExecutionSpec.  # noqa: E501\n        :rtype: AdminNotificationList\n        '
        return self._notifications

    @notifications.setter
    def notifications(self, notifications):
        if False:
            for i in range(10):
                print('nop')
        'Sets the notifications of this AdminExecutionSpec.\n\n        List of notifications based on Execution status transitions When this list is not empty it is used rather than any notifications defined in the referenced launch plan. When this list is empty, the notifications defined for the launch plan will be applied.  # noqa: E501\n\n        :param notifications: The notifications of this AdminExecutionSpec.  # noqa: E501\n        :type: AdminNotificationList\n        '
        self._notifications = notifications

    @property
    def disable_all(self):
        if False:
            print('Hello World!')
        'Gets the disable_all of this AdminExecutionSpec.  # noqa: E501\n\n        This should be set to true if all notifications are intended to be disabled for this execution.  # noqa: E501\n\n        :return: The disable_all of this AdminExecutionSpec.  # noqa: E501\n        :rtype: bool\n        '
        return self._disable_all

    @disable_all.setter
    def disable_all(self, disable_all):
        if False:
            return 10
        'Sets the disable_all of this AdminExecutionSpec.\n\n        This should be set to true if all notifications are intended to be disabled for this execution.  # noqa: E501\n\n        :param disable_all: The disable_all of this AdminExecutionSpec.  # noqa: E501\n        :type: bool\n        '
        self._disable_all = disable_all

    @property
    def labels(self):
        if False:
            print('Hello World!')
        'Gets the labels of this AdminExecutionSpec.  # noqa: E501\n\n        Labels to apply to the execution resource.  # noqa: E501\n\n        :return: The labels of this AdminExecutionSpec.  # noqa: E501\n        :rtype: AdminLabels\n        '
        return self._labels

    @labels.setter
    def labels(self, labels):
        if False:
            while True:
                i = 10
        'Sets the labels of this AdminExecutionSpec.\n\n        Labels to apply to the execution resource.  # noqa: E501\n\n        :param labels: The labels of this AdminExecutionSpec.  # noqa: E501\n        :type: AdminLabels\n        '
        self._labels = labels

    @property
    def annotations(self):
        if False:
            return 10
        'Gets the annotations of this AdminExecutionSpec.  # noqa: E501\n\n        Annotations to apply to the execution resource.  # noqa: E501\n\n        :return: The annotations of this AdminExecutionSpec.  # noqa: E501\n        :rtype: AdminAnnotations\n        '
        return self._annotations

    @annotations.setter
    def annotations(self, annotations):
        if False:
            for i in range(10):
                print('nop')
        'Sets the annotations of this AdminExecutionSpec.\n\n        Annotations to apply to the execution resource.  # noqa: E501\n\n        :param annotations: The annotations of this AdminExecutionSpec.  # noqa: E501\n        :type: AdminAnnotations\n        '
        self._annotations = annotations

    @property
    def security_context(self):
        if False:
            i = 10
            return i + 15
        'Gets the security_context of this AdminExecutionSpec.  # noqa: E501\n\n        Optional: security context override to apply this execution.  # noqa: E501\n\n        :return: The security_context of this AdminExecutionSpec.  # noqa: E501\n        :rtype: CoreSecurityContext\n        '
        return self._security_context

    @security_context.setter
    def security_context(self, security_context):
        if False:
            i = 10
            return i + 15
        'Sets the security_context of this AdminExecutionSpec.\n\n        Optional: security context override to apply this execution.  # noqa: E501\n\n        :param security_context: The security_context of this AdminExecutionSpec.  # noqa: E501\n        :type: CoreSecurityContext\n        '
        self._security_context = security_context

    @property
    def auth_role(self):
        if False:
            while True:
                i = 10
        'Gets the auth_role of this AdminExecutionSpec.  # noqa: E501\n\n        Optional: auth override to apply this execution.  # noqa: E501\n\n        :return: The auth_role of this AdminExecutionSpec.  # noqa: E501\n        :rtype: AdminAuthRole\n        '
        return self._auth_role

    @auth_role.setter
    def auth_role(self, auth_role):
        if False:
            while True:
                i = 10
        'Sets the auth_role of this AdminExecutionSpec.\n\n        Optional: auth override to apply this execution.  # noqa: E501\n\n        :param auth_role: The auth_role of this AdminExecutionSpec.  # noqa: E501\n        :type: AdminAuthRole\n        '
        self._auth_role = auth_role

    @property
    def quality_of_service(self):
        if False:
            print('Hello World!')
        'Gets the quality_of_service of this AdminExecutionSpec.  # noqa: E501\n\n        Indicates the runtime priority of the execution.  # noqa: E501\n\n        :return: The quality_of_service of this AdminExecutionSpec.  # noqa: E501\n        :rtype: CoreQualityOfService\n        '
        return self._quality_of_service

    @quality_of_service.setter
    def quality_of_service(self, quality_of_service):
        if False:
            while True:
                i = 10
        'Sets the quality_of_service of this AdminExecutionSpec.\n\n        Indicates the runtime priority of the execution.  # noqa: E501\n\n        :param quality_of_service: The quality_of_service of this AdminExecutionSpec.  # noqa: E501\n        :type: CoreQualityOfService\n        '
        self._quality_of_service = quality_of_service

    @property
    def max_parallelism(self):
        if False:
            for i in range(10):
                print('nop')
        'Gets the max_parallelism of this AdminExecutionSpec.  # noqa: E501\n\n        Controls the maximum number of task nodes that can be run in parallel for the entire workflow. This is useful to achieve fairness. Note: MapTasks are regarded as one unit, and parallelism/concurrency of MapTasks is independent from this.  # noqa: E501\n\n        :return: The max_parallelism of this AdminExecutionSpec.  # noqa: E501\n        :rtype: int\n        '
        return self._max_parallelism

    @max_parallelism.setter
    def max_parallelism(self, max_parallelism):
        if False:
            for i in range(10):
                print('nop')
        'Sets the max_parallelism of this AdminExecutionSpec.\n\n        Controls the maximum number of task nodes that can be run in parallel for the entire workflow. This is useful to achieve fairness. Note: MapTasks are regarded as one unit, and parallelism/concurrency of MapTasks is independent from this.  # noqa: E501\n\n        :param max_parallelism: The max_parallelism of this AdminExecutionSpec.  # noqa: E501\n        :type: int\n        '
        self._max_parallelism = max_parallelism

    @property
    def raw_output_data_config(self):
        if False:
            return 10
        'Gets the raw_output_data_config of this AdminExecutionSpec.  # noqa: E501\n\n\n        :return: The raw_output_data_config of this AdminExecutionSpec.  # noqa: E501\n        :rtype: AdminRawOutputDataConfig\n        '
        return self._raw_output_data_config

    @raw_output_data_config.setter
    def raw_output_data_config(self, raw_output_data_config):
        if False:
            print('Hello World!')
        'Sets the raw_output_data_config of this AdminExecutionSpec.\n\n\n        :param raw_output_data_config: The raw_output_data_config of this AdminExecutionSpec.  # noqa: E501\n        :type: AdminRawOutputDataConfig\n        '
        self._raw_output_data_config = raw_output_data_config

    @property
    def cluster_assignment(self):
        if False:
            for i in range(10):
                print('nop')
        'Gets the cluster_assignment of this AdminExecutionSpec.  # noqa: E501\n\n        Controls how to select an available cluster on which this execution should run.  # noqa: E501\n\n        :return: The cluster_assignment of this AdminExecutionSpec.  # noqa: E501\n        :rtype: AdminClusterAssignment\n        '
        return self._cluster_assignment

    @cluster_assignment.setter
    def cluster_assignment(self, cluster_assignment):
        if False:
            return 10
        'Sets the cluster_assignment of this AdminExecutionSpec.\n\n        Controls how to select an available cluster on which this execution should run.  # noqa: E501\n\n        :param cluster_assignment: The cluster_assignment of this AdminExecutionSpec.  # noqa: E501\n        :type: AdminClusterAssignment\n        '
        self._cluster_assignment = cluster_assignment

    @property
    def interruptible(self):
        if False:
            print('Hello World!')
        "Gets the interruptible of this AdminExecutionSpec.  # noqa: E501\n\n        Allows for the interruptible flag of a workflow to be overwritten for a single execution. Omitting this field uses the workflow's value as a default. As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper around the bool field.  # noqa: E501\n\n        :return: The interruptible of this AdminExecutionSpec.  # noqa: E501\n        :rtype: bool\n        "
        return self._interruptible

    @interruptible.setter
    def interruptible(self, interruptible):
        if False:
            i = 10
            return i + 15
        "Sets the interruptible of this AdminExecutionSpec.\n\n        Allows for the interruptible flag of a workflow to be overwritten for a single execution. Omitting this field uses the workflow's value as a default. As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper around the bool field.  # noqa: E501\n\n        :param interruptible: The interruptible of this AdminExecutionSpec.  # noqa: E501\n        :type: bool\n        "
        self._interruptible = interruptible

    @property
    def overwrite_cache(self):
        if False:
            print('Hello World!')
        'Gets the overwrite_cache of this AdminExecutionSpec.  # noqa: E501\n\n        Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.  # noqa: E501\n\n        :return: The overwrite_cache of this AdminExecutionSpec.  # noqa: E501\n        :rtype: bool\n        '
        return self._overwrite_cache

    @overwrite_cache.setter
    def overwrite_cache(self, overwrite_cache):
        if False:
            i = 10
            return i + 15
        'Sets the overwrite_cache of this AdminExecutionSpec.\n\n        Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.  # noqa: E501\n\n        :param overwrite_cache: The overwrite_cache of this AdminExecutionSpec.  # noqa: E501\n        :type: bool\n        '
        self._overwrite_cache = overwrite_cache

    @property
    def envs(self):
        if False:
            while True:
                i = 10
        'Gets the envs of this AdminExecutionSpec.  # noqa: E501\n\n        Environment variables to be set for the execution.  # noqa: E501\n\n        :return: The envs of this AdminExecutionSpec.  # noqa: E501\n        :rtype: AdminEnvs\n        '
        return self._envs

    @envs.setter
    def envs(self, envs):
        if False:
            while True:
                i = 10
        'Sets the envs of this AdminExecutionSpec.\n\n        Environment variables to be set for the execution.  # noqa: E501\n\n        :param envs: The envs of this AdminExecutionSpec.  # noqa: E501\n        :type: AdminEnvs\n        '
        self._envs = envs

    @property
    def tags(self):
        if False:
            for i in range(10):
                print('nop')
        'Gets the tags of this AdminExecutionSpec.  # noqa: E501\n\n        Tags to be set for the execution.  # noqa: E501\n\n        :return: The tags of this AdminExecutionSpec.  # noqa: E501\n        :rtype: list[str]\n        '
        return self._tags

    @tags.setter
    def tags(self, tags):
        if False:
            for i in range(10):
                print('nop')
        'Sets the tags of this AdminExecutionSpec.\n\n        Tags to be set for the execution.  # noqa: E501\n\n        :param tags: The tags of this AdminExecutionSpec.  # noqa: E501\n        :type: list[str]\n        '
        self._tags = tags

    def to_dict(self):
        if False:
            while True:
                i = 10
        'Returns the model properties as a dict'
        result = {}
        for (attr, _) in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(lambda x: x.to_dict() if hasattr(x, 'to_dict') else x, value))
            elif hasattr(value, 'to_dict'):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(lambda item: (item[0], item[1].to_dict()) if hasattr(item[1], 'to_dict') else item, value.items()))
            else:
                result[attr] = value
        if issubclass(AdminExecutionSpec, dict):
            for (key, value) in self.items():
                result[key] = value
        return result

    def to_str(self):
        if False:
            print('Hello World!')
        'Returns the string representation of the model'
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        if False:
            print('Hello World!')
        'For `print` and `pprint`'
        return self.to_str()

    def __eq__(self, other):
        if False:
            i = 10
            return i + 15
        'Returns true if both objects are equal'
        if not isinstance(other, AdminExecutionSpec):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        if False:
            print('Hello World!')
        'Returns true if both objects are not equal'
        return not self == other