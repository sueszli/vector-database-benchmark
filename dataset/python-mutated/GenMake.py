from __future__ import absolute_import
import Common.LongFilePathOs as os
import sys
import string
import re
import os.path as path
from Common.LongFilePathSupport import OpenLongFilePath as open
from Common.MultipleWorkspace import MultipleWorkspace as mws
from Common.BuildToolError import *
from Common.Misc import *
from Common.StringUtils import *
from .BuildEngine import *
import Common.GlobalData as GlobalData
from collections import OrderedDict
from Common.DataType import TAB_COMPILER_MSFT
gIncludePattern = re.compile('^[ \\t]*[#%]?[ \\t]*include(?:[ \\t]*(?:\\\\(?:\\r\\n|\\r|\\n))*[ \\t]*)*(?:\\(?[\\"<]?[ \\t]*)([-\\w.\\\\/() \\t]+)(?:[ \\t]*[\\">]?\\)?)', re.MULTILINE | re.UNICODE | re.IGNORECASE)
gMacroPattern = re.compile('([_A-Z][_A-Z0-9]*)[ \t]*\\((.+)\\)', re.UNICODE)
gIsFileMap = {}
gProtocolDefinition = 'Protocol/%(HeaderKey)s/%(HeaderKey)s.h'
gGuidDefinition = 'Guid/%(HeaderKey)s/%(HeaderKey)s.h'
gArchProtocolDefinition = 'ArchProtocol/%(HeaderKey)s/%(HeaderKey)s.h'
gPpiDefinition = 'Ppi/%(HeaderKey)s/%(HeaderKey)s.h'
gIncludeMacroConversion = {'EFI_PROTOCOL_DEFINITION': gProtocolDefinition, 'EFI_GUID_DEFINITION': gGuidDefinition, 'EFI_ARCH_PROTOCOL_DEFINITION': gArchProtocolDefinition, 'EFI_PROTOCOL_PRODUCER': gProtocolDefinition, 'EFI_PROTOCOL_CONSUMER': gProtocolDefinition, 'EFI_PROTOCOL_DEPENDENCY': gProtocolDefinition, 'EFI_ARCH_PROTOCOL_PRODUCER': gArchProtocolDefinition, 'EFI_ARCH_PROTOCOL_CONSUMER': gArchProtocolDefinition, 'EFI_ARCH_PROTOCOL_DEPENDENCY': gArchProtocolDefinition, 'EFI_PPI_DEFINITION': gPpiDefinition, 'EFI_PPI_PRODUCER': gPpiDefinition, 'EFI_PPI_CONSUMER': gPpiDefinition, 'EFI_PPI_DEPENDENCY': gPpiDefinition}
NMAKE_FILETYPE = 'nmake'
GMAKE_FILETYPE = 'gmake'
WIN32_PLATFORM = 'win32'
POSIX_PLATFORM = 'posix'

class BuildFile(object):
    _TEMPLATE_ = TemplateString('')
    _DEFAULT_FILE_NAME_ = 'Makefile'
    _FILE_NAME_ = {NMAKE_FILETYPE: 'Makefile', GMAKE_FILETYPE: 'GNUmakefile'}

    def getMakefileName(self):
        if False:
            i = 10
            return i + 15
        if not self._FileType:
            return self._DEFAULT_FILE_NAME_
        else:
            return self._FILE_NAME_[self._FileType]
    _MAKEFILE_HEADER = '#\n# DO NOT EDIT\n# This file is auto-generated by build utility\n#\n# Module Name:\n#\n#   %s\n#\n# Abstract:\n#\n#   Auto-generated makefile for building modules, libraries or platform\n#\n    '
    _FILE_HEADER_ = {NMAKE_FILETYPE: _MAKEFILE_HEADER % _FILE_NAME_[NMAKE_FILETYPE], GMAKE_FILETYPE: _MAKEFILE_HEADER % _FILE_NAME_[GMAKE_FILETYPE]}
    _SHELL_CMD_ = {WIN32_PLATFORM: {'CP': 'copy /y', 'MV': 'move /y', 'RM': 'del /f /q', 'MD': 'mkdir', 'RD': 'rmdir /s /q'}, POSIX_PLATFORM: {'CP': 'cp -p -f', 'MV': 'mv -f', 'RM': 'rm -f', 'MD': 'mkdir -p', 'RD': 'rm -r -f'}}
    _SEP_ = {WIN32_PLATFORM: '\\', POSIX_PLATFORM: '/'}
    _MD_TEMPLATE_ = {WIN32_PLATFORM: 'if not exist %(dir)s $(MD) %(dir)s', POSIX_PLATFORM: '$(MD) %(dir)s'}
    _RD_TEMPLATE_ = {WIN32_PLATFORM: 'if exist %(dir)s $(RD) %(dir)s', POSIX_PLATFORM: '$(RD) %(dir)s'}
    _CP_TEMPLATE_ = {WIN32_PLATFORM: 'if exist %(Src)s $(CP) %(Src)s %(Dst)s', POSIX_PLATFORM: 'test -f %(Src)s && $(CP) %(Src)s %(Dst)s'}
    _CD_TEMPLATE_ = {WIN32_PLATFORM: 'if exist %(dir)s cd %(dir)s', POSIX_PLATFORM: 'test -e %(dir)s && cd %(dir)s'}
    _MAKE_TEMPLATE_ = {WIN32_PLATFORM: 'if exist %(file)s "$(MAKE)" $(MAKE_FLAGS) -f %(file)s', POSIX_PLATFORM: 'test -e %(file)s && "$(MAKE)" $(MAKE_FLAGS) -f %(file)s'}
    _INCLUDE_CMD_ = {NMAKE_FILETYPE: '!INCLUDE', GMAKE_FILETYPE: 'include'}
    _INC_FLAG_ = {TAB_COMPILER_MSFT: '/I', 'GCC': '-I', 'INTEL': '-I', 'NASM': '-I'}

    def __init__(self, AutoGenObject):
        if False:
            for i in range(10):
                print('nop')
        self._AutoGenObject = AutoGenObject
        MakePath = AutoGenObject.BuildOption.get('MAKE', {}).get('PATH')
        if not MakePath:
            MakePath = AutoGenObject.ToolDefinition.get('MAKE', {}).get('PATH')
        if 'nmake' in MakePath:
            self._FileType = NMAKE_FILETYPE
        else:
            self._FileType = GMAKE_FILETYPE
        if sys.platform == 'win32':
            self._Platform = WIN32_PLATFORM
        else:
            self._Platform = POSIX_PLATFORM

    def Generate(self):
        if False:
            return 10
        FileContent = self._TEMPLATE_.Replace(self._TemplateDict)
        FileName = self.getMakefileName()
        if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt')):
            with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt'), 'w+') as fd:
                fd.write('')
        if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency')):
            with open(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency'), 'w+') as fd:
                fd.write('')
        if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target')):
            with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target'), 'w+') as fd:
                fd.write('')
        return SaveFileOnChange(os.path.join(self._AutoGenObject.MakeFileDir, FileName), FileContent, False)

    def GetCreateDirectoryCommand(self, DirList):
        if False:
            for i in range(10):
                print('nop')
        return [self._MD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]

    def GetRemoveDirectoryCommand(self, DirList):
        if False:
            i = 10
            return i + 15
        return [self._RD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]

    def PlaceMacro(self, Path, MacroDefinitions=None):
        if False:
            print('Hello World!')
        if Path.startswith('$('):
            return Path
        else:
            if MacroDefinitions is None:
                MacroDefinitions = {}
            PathLength = len(Path)
            for MacroName in MacroDefinitions:
                MacroValue = MacroDefinitions[MacroName]
                MacroValueLength = len(MacroValue)
                if MacroValueLength == 0:
                    continue
                if MacroValueLength <= PathLength and Path.startswith(MacroValue):
                    Path = '$(%s)%s' % (MacroName, Path[MacroValueLength:])
                    break
            return Path

class ModuleMakefile(BuildFile):
    _TEMPLATE_ = TemplateString('${makefile_header}\n\n#\n# Platform Macro Definition\n#\nPLATFORM_NAME = ${platform_name}\nPLATFORM_GUID = ${platform_guid}\nPLATFORM_VERSION = ${platform_version}\nPLATFORM_RELATIVE_DIR = ${platform_relative_directory}\nPLATFORM_DIR = ${platform_dir}\nPLATFORM_OUTPUT_DIR = ${platform_output_directory}\n\n#\n# Module Macro Definition\n#\nMODULE_NAME = ${module_name}\nMODULE_GUID = ${module_guid}\nMODULE_NAME_GUID = ${module_name_guid}\nMODULE_VERSION = ${module_version}\nMODULE_TYPE = ${module_type}\nMODULE_FILE = ${module_file}\nMODULE_FILE_BASE_NAME = ${module_file_base_name}\nBASE_NAME = $(MODULE_NAME)\nMODULE_RELATIVE_DIR = ${module_relative_directory}\nPACKAGE_RELATIVE_DIR = ${package_relative_directory}\nMODULE_DIR = ${module_dir}\nFFS_OUTPUT_DIR = ${ffs_output_directory}\n\nMODULE_ENTRY_POINT = ${module_entry_point}\nARCH_ENTRY_POINT = ${arch_entry_point}\nIMAGE_ENTRY_POINT = ${image_entry_point}\n\n${BEGIN}${module_extra_defines}\n${END}\n#\n# Build Configuration Macro Definition\n#\nARCH = ${architecture}\nTOOLCHAIN = ${toolchain_tag}\nTOOLCHAIN_TAG = ${toolchain_tag}\nTARGET = ${build_target}\n\n#\n# Build Directory Macro Definition\n#\n# PLATFORM_BUILD_DIR = ${platform_build_directory}\nBUILD_DIR = ${platform_build_directory}\nBIN_DIR = $(BUILD_DIR)${separator}${architecture}\nLIB_DIR = $(BIN_DIR)\nMODULE_BUILD_DIR = ${module_build_directory}\nOUTPUT_DIR = ${module_output_directory}\nDEBUG_DIR = ${module_debug_directory}\nDEST_DIR_OUTPUT = $(OUTPUT_DIR)\nDEST_DIR_DEBUG = $(DEBUG_DIR)\n\n#\n# Shell Command Macro\n#\n${BEGIN}${shell_command_code} = ${shell_command}\n${END}\n\n#\n# Tools definitions specific to this module\n#\n${BEGIN}${module_tool_definitions}\n${END}\nMAKE_FILE = ${makefile_path}\n\n#\n# Build Macro\n#\n${BEGIN}${file_macro}\n${END}\n\n#\n# Overridable Target Macro Definitions\n#\nFORCE_REBUILD = force_build\nINIT_TARGET = init\nPCH_TARGET =\nBC_TARGET = ${BEGIN}${backward_compatible_target} ${END}\nCODA_TARGET = ${BEGIN}${remaining_build_target} \\\n              ${END}\n\n#\n# Default target, which will build dependent libraries in addition to source files\n#\n\nall: mbuild\n\n\n#\n# Target used when called from platform makefile, which will bypass the build of dependent libraries\n#\n\npbuild: $(INIT_TARGET) $(BC_TARGET) $(PCH_TARGET) $(CODA_TARGET)\n\n#\n# ModuleTarget\n#\n\nmbuild: $(INIT_TARGET) $(BC_TARGET) gen_libs $(PCH_TARGET) $(CODA_TARGET)\n\n#\n# Build Target used in multi-thread build mode, which will bypass the init and gen_libs targets\n#\n\ntbuild: $(BC_TARGET) $(PCH_TARGET) $(CODA_TARGET)\n\n#\n# Phony target which is used to force executing commands for a target\n#\nforce_build:\n\t-@\n\n#\n# Target to update the FD\n#\n\nfds: mbuild gen_fds\n\n#\n# Initialization target: print build information and create necessary directories\n#\ninit: info dirs\n\ninfo:\n\t-@echo Building ... $(MODULE_DIR)${separator}$(MODULE_FILE) [$(ARCH)]\n\ndirs:\n${BEGIN}\t-@${create_directory_command}\n${END}\n\nstrdefs:\n\t-@$(CP) $(DEBUG_DIR)${separator}AutoGen.h $(DEBUG_DIR)${separator}$(MODULE_NAME)StrDefs.h\n\n#\n# GenLibsTarget\n#\ngen_libs:\n\t${BEGIN}@"$(MAKE)" $(MAKE_FLAGS) -f ${dependent_library_build_directory}${separator}${makefile_name}\n\t${END}@cd $(MODULE_BUILD_DIR)\n\n#\n# Build Flash Device Image\n#\ngen_fds:\n\t@"$(MAKE)" $(MAKE_FLAGS) -f $(BUILD_DIR)${separator}${makefile_name} fds\n\t@cd $(MODULE_BUILD_DIR)\n\n${INCLUDETAG}\n\n#\n# Individual Object Build Targets\n#\n${BEGIN}${file_build_target}\n${END}\n\n#\n# clean all intermediate files\n#\nclean:\n\t${BEGIN}${clean_command}\n\t${END}\t$(RM) AutoGenTimeStamp\n\n#\n# clean all generated files\n#\ncleanall:\n${BEGIN}\t${cleanall_command}\n${END}\t$(RM) *.pdb *.idb > NUL 2>&1\n\t$(RM) $(BIN_DIR)${separator}$(MODULE_NAME).efi\n\t$(RM) AutoGenTimeStamp\n\n#\n# clean all dependent libraries built\n#\ncleanlib:\n\t${BEGIN}-@${library_build_command} cleanall\n\t${END}@cd $(MODULE_BUILD_DIR)\n\n')
    _FILE_MACRO_TEMPLATE = TemplateString('${macro_name} = ${BEGIN} \\\n    ${source_file}${END}\n')
    _BUILD_TARGET_TEMPLATE = TemplateString('${BEGIN}${target} : ${deps}\n${END}\t${cmd}\n')

    def __init__(self, ModuleAutoGen):
        if False:
            for i in range(10):
                print('nop')
        BuildFile.__init__(self, ModuleAutoGen)
        self.PlatformInfo = self._AutoGenObject.PlatformInfo
        self.ResultFileList = []
        self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']
        self.FileBuildTargetList = []
        self.BuildTargetList = []
        self.PendingBuildTargetList = []
        self.CommonFileDependency = []
        self.FileListMacros = {}
        self.ListFileMacros = {}
        self.ObjTargetDict = OrderedDict()
        self.FileCache = {}
        self.LibraryBuildCommandList = []
        self.LibraryFileList = []
        self.LibraryMakefileList = []
        self.LibraryBuildDirectoryList = []
        self.SystemLibraryList = []
        self.Macros = OrderedDict()
        self.Macros['OUTPUT_DIR'] = self._AutoGenObject.Macros['OUTPUT_DIR']
        self.Macros['DEBUG_DIR'] = self._AutoGenObject.Macros['DEBUG_DIR']
        self.Macros['MODULE_BUILD_DIR'] = self._AutoGenObject.Macros['MODULE_BUILD_DIR']
        self.Macros['BIN_DIR'] = self._AutoGenObject.Macros['BIN_DIR']
        self.Macros['BUILD_DIR'] = self._AutoGenObject.Macros['BUILD_DIR']
        self.Macros['WORKSPACE'] = self._AutoGenObject.Macros['WORKSPACE']
        self.Macros['FFS_OUTPUT_DIR'] = self._AutoGenObject.Macros['FFS_OUTPUT_DIR']
        self.GenFfsList = ModuleAutoGen.GenFfsList
        self.MacroList = ['FFS_OUTPUT_DIR', 'MODULE_GUID', 'OUTPUT_DIR']
        self.FfsOutputFileList = []
        self.DependencyHeaderFileSet = set()

    @property
    def _TemplateDict(self):
        if False:
            for i in range(10):
                print('nop')
        MyAgo = self._AutoGenObject
        Separator = self._SEP_[self._Platform]
        if len(MyAgo.SourceFileList) == 0 and len(MyAgo.BinaryFileList) == 0:
            EdkLogger.error('build', AUTOGEN_ERROR, 'No files to be built in module [%s, %s, %s]' % (MyAgo.BuildTarget, MyAgo.ToolChain, MyAgo.Arch), ExtraData='[%s]' % str(MyAgo))
        self.ProcessDependentLibrary()
        if len(MyAgo.Module.ModuleEntryPointList) > 0:
            ModuleEntryPoint = MyAgo.Module.ModuleEntryPointList[0]
        else:
            ModuleEntryPoint = '_ModuleEntryPoint'
        ArchEntryPoint = ModuleEntryPoint
        if MyAgo.Arch == 'EBC':
            ImageEntryPoint = 'EfiStart'
        else:
            ImageEntryPoint = '_ModuleEntryPoint'
        for (k, v) in MyAgo.Module.Defines.items():
            if k not in MyAgo.Macros:
                MyAgo.Macros[k] = v
        if 'MODULE_ENTRY_POINT' not in MyAgo.Macros:
            MyAgo.Macros['MODULE_ENTRY_POINT'] = ModuleEntryPoint
        if 'ARCH_ENTRY_POINT' not in MyAgo.Macros:
            MyAgo.Macros['ARCH_ENTRY_POINT'] = ArchEntryPoint
        if 'IMAGE_ENTRY_POINT' not in MyAgo.Macros:
            MyAgo.Macros['IMAGE_ENTRY_POINT'] = ImageEntryPoint
        PCI_COMPRESS_Flag = False
        for (k, v) in MyAgo.Module.Defines.items():
            if 'PCI_COMPRESS' == k and 'TRUE' == v:
                PCI_COMPRESS_Flag = True
        ToolsDef = []
        IncPrefix = self._INC_FLAG_[MyAgo.ToolChainFamily]
        for Tool in sorted(list(MyAgo.BuildOption)):
            Appended = False
            for Attr in sorted(list(MyAgo.BuildOption[Tool])):
                Value = MyAgo.BuildOption[Tool][Attr]
                if Attr == 'FAMILY':
                    continue
                elif Attr == 'PATH':
                    ToolsDef.append('%s = %s' % (Tool, Value))
                    Appended = True
                else:
                    if Tool == 'MAKE':
                        continue
                    if Attr == 'FLAGS':
                        Value = RemoveDupOption(Value, IncPrefix, MyAgo.IncludePathList)
                        if Tool == 'OPTROM' and PCI_COMPRESS_Flag:
                            ValueList = Value.split()
                            if ValueList:
                                for (i, v) in enumerate(ValueList):
                                    if '-e' == v:
                                        ValueList[i] = '-ec'
                                Value = ' '.join(ValueList)
                    ToolsDef.append('%s_%s = %s' % (Tool, Attr, Value))
                    Appended = True
            if Appended:
                ToolsDef.append('')
        RespDict = self.CommandExceedLimit()
        RespFileList = os.path.join(MyAgo.OutputDir, 'respfilelist.txt')
        if RespDict:
            RespFileListContent = ''
            for Resp in RespDict:
                RespFile = os.path.join(MyAgo.OutputDir, str(Resp).lower() + '.txt')
                StrList = RespDict[Resp].split(' ')
                UnexpandMacro = []
                NewStr = []
                for Str in StrList:
                    if '$' in Str or '-MMD' in Str or '-MF' in Str:
                        UnexpandMacro.append(Str)
                    else:
                        NewStr.append(Str)
                UnexpandMacroStr = ' '.join(UnexpandMacro)
                NewRespStr = ' '.join(NewStr)
                SaveFileOnChange(RespFile, NewRespStr, False)
                ToolsDef.append('%s = %s' % (Resp, UnexpandMacroStr + ' @' + RespFile))
                RespFileListContent += '@' + RespFile + TAB_LINE_BREAK
                RespFileListContent += NewRespStr + TAB_LINE_BREAK
            SaveFileOnChange(RespFileList, RespFileListContent, False)
        elif os.path.exists(RespFileList):
            os.remove(RespFileList)
        self.ResultFileList = [str(T.Target) for T in MyAgo.CodaTargetList]
        if len(self.ResultFileList) == 0 and len(MyAgo.SourceFileList) != 0:
            EdkLogger.error('build', AUTOGEN_ERROR, 'Nothing to build', ExtraData='[%s]' % str(MyAgo))
        self.ProcessBuildTargetList(MyAgo.OutputDir, ToolsDef)
        self.ParserGenerateFfsCmd()
        FileMacroList = []
        for FileListMacro in self.FileListMacros:
            FileMacro = self._FILE_MACRO_TEMPLATE.Replace({'macro_name': FileListMacro, 'source_file': self.FileListMacros[FileListMacro]})
            FileMacroList.append(FileMacro)
        FileMacro = ''
        IncludePathList = []
        for P in MyAgo.IncludePathList:
            IncludePathList.append(IncPrefix + self.PlaceMacro(P, self.Macros))
            if FileBuildRule.INC_LIST_MACRO in self.ListFileMacros:
                self.ListFileMacros[FileBuildRule.INC_LIST_MACRO].append(IncPrefix + P)
        FileMacro += self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'INC', 'source_file': IncludePathList})
        FileMacroList.append(FileMacro)
        IncludePathList = []
        asmsource = [item for item in MyAgo.SourceFileList if item.File.upper().endswith(('.NASM', '.ASM', '.NASMB', 'S'))]
        if asmsource:
            for P in MyAgo.IncludePathList:
                IncludePath = self._INC_FLAG_['NASM'] + self.PlaceMacro(P, self.Macros)
                if IncludePath.endswith(os.sep):
                    IncludePath = IncludePath.rstrip(os.sep)
                if P == MyAgo.IncludePathList[-1] and self._Platform == WIN32_PLATFORM and (self._FileType == NMAKE_FILETYPE):
                    IncludePath = ''.join([IncludePath, '^', os.sep])
                else:
                    IncludePath = os.path.join(IncludePath, '')
                IncludePathList.append(IncludePath)
            FileMacroList.append(self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'NASM_INC', 'source_file': IncludePathList}))
        for ListFileMacro in self.ListFileMacros:
            ListFileName = os.path.join(MyAgo.OutputDir, '%s.lst' % ListFileMacro.lower()[:len(ListFileMacro) - 5])
            FileMacroList.append('%s = %s' % (ListFileMacro, ListFileName))
            SaveFileOnChange(ListFileName, '\n'.join(self.ListFileMacros[ListFileMacro]), False)
        for Type in self.ObjTargetDict:
            NewLine = ' '.join(list(self.ObjTargetDict[Type]))
            FileMacroList.append('OBJLIST_%s = %s' % (list(self.ObjTargetDict.keys()).index(Type), NewLine))
        BcTargetList = []
        MakefileName = self.getMakefileName()
        LibraryMakeCommandList = []
        for D in self.LibraryBuildDirectoryList:
            Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join(D, MakefileName)}
            LibraryMakeCommandList.append(Command)
        package_rel_dir = MyAgo.SourceDir
        current_dir = self.Macros['WORKSPACE']
        found = False
        while not found and os.sep in package_rel_dir:
            index = package_rel_dir.index(os.sep)
            current_dir = mws.join(current_dir, package_rel_dir[:index])
            if os.path.exists(current_dir):
                for fl in os.listdir(current_dir):
                    if fl.endswith('.dec'):
                        found = True
                        break
            package_rel_dir = package_rel_dir[index + 1:]
        MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'makefile_name': MakefileName, 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'ffs_output_directory': MyAgo.Macros['FFS_OUTPUT_DIR'], 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile.Name, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(self.Macros['WORKSPACE'], MyAgo.SourceDir), 'package_relative_directory': package_rel_dir, 'module_extra_defines': ['%s = %s' % (k, v) for (k, v) in MyAgo.Module.Defines.items()], 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'module_entry_point': ModuleEntryPoint, 'image_entry_point': ImageEntryPoint, 'arch_entry_point': ArchEntryPoint, 'remaining_build_target': self.ResultFileList, 'common_dependency_file': self.CommonFileDependency, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'clean_command': self.GetRemoveDirectoryCommand(['$(OUTPUT_DIR)']), 'cleanall_command': self.GetRemoveDirectoryCommand(['$(DEBUG_DIR)', '$(OUTPUT_DIR)']), 'dependent_library_build_directory': self.LibraryBuildDirectoryList, 'library_build_command': LibraryMakeCommandList, 'file_macro': FileMacroList, 'file_build_target': self.BuildTargetList, 'backward_compatible_target': BcTargetList, 'INCLUDETAG': '\n'.join([self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'dependency'), self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'deps_target')])}
        return MakefileTemplateDict

    def ParserGenerateFfsCmd(self):
        if False:
            while True:
                i = 10
        OutputFile = ''
        DepsFileList = []
        for Cmd in self.GenFfsList:
            if Cmd[2]:
                for CopyCmd in Cmd[2]:
                    (Src, Dst) = CopyCmd
                    Src = self.ReplaceMacro(Src)
                    Dst = self.ReplaceMacro(Dst)
                    if Dst not in self.ResultFileList:
                        self.ResultFileList.append(Dst)
                    if '%s :' % Dst not in self.BuildTargetList:
                        self.BuildTargetList.append('%s : %s' % (Dst, Src))
                        self.BuildTargetList.append('\t' + self._CP_TEMPLATE_[self._Platform] % {'Src': Src, 'Dst': Dst})
            FfsCmdList = Cmd[0]
            for (index, Str) in enumerate(FfsCmdList):
                if '-o' == Str:
                    OutputFile = FfsCmdList[index + 1]
                if '-i' == Str or '-oi' == Str:
                    if DepsFileList == []:
                        DepsFileList = [FfsCmdList[index + 1]]
                    else:
                        DepsFileList.append(FfsCmdList[index + 1])
            DepsFileString = ' '.join(DepsFileList).strip()
            if DepsFileString == '':
                continue
            OutputFile = self.ReplaceMacro(OutputFile)
            self.ResultFileList.append(OutputFile)
            DepsFileString = self.ReplaceMacro(DepsFileString)
            self.BuildTargetList.append('%s : %s' % (OutputFile, DepsFileString))
            CmdString = ' '.join(FfsCmdList).strip()
            CmdString = self.ReplaceMacro(CmdString)
            self.BuildTargetList.append('\t%s' % CmdString)
            self.ParseSecCmd(DepsFileList, Cmd[1])
            for (SecOutputFile, SecDepsFile, SecCmd) in self.FfsOutputFileList:
                self.BuildTargetList.append('%s : %s' % (self.ReplaceMacro(SecOutputFile), self.ReplaceMacro(SecDepsFile)))
                self.BuildTargetList.append('\t%s' % self.ReplaceMacro(SecCmd))
            self.FfsOutputFileList = []

    def ParseSecCmd(self, OutputFileList, CmdTuple):
        if False:
            print('Hello World!')
        for OutputFile in OutputFileList:
            for SecCmdStr in CmdTuple:
                SecDepsFileList = []
                SecCmdList = SecCmdStr.split()
                CmdName = SecCmdList[0]
                for (index, CmdItem) in enumerate(SecCmdList):
                    if '-o' == CmdItem and OutputFile == SecCmdList[index + 1]:
                        index = index + 1
                        while index + 1 < len(SecCmdList):
                            if not SecCmdList[index + 1].startswith('-'):
                                SecDepsFileList.append(SecCmdList[index + 1])
                            index = index + 1
                        if CmdName == 'Trim':
                            SecDepsFileList.append(os.path.join('$(DEBUG_DIR)', os.path.basename(OutputFile).replace('offset', 'efi')))
                        if OutputFile.endswith('.ui') or OutputFile.endswith('.ver'):
                            SecDepsFileList.append(os.path.join('$(MODULE_DIR)', '$(MODULE_FILE)'))
                        self.FfsOutputFileList.append((OutputFile, ' '.join(SecDepsFileList), SecCmdStr))
                        if len(SecDepsFileList) > 0:
                            self.ParseSecCmd(SecDepsFileList, CmdTuple)
                        break
                    else:
                        continue

    def ReplaceMacro(self, str):
        if False:
            while True:
                i = 10
        for Macro in self.MacroList:
            if self._AutoGenObject.Macros[Macro] and os.path.normcase(self._AutoGenObject.Macros[Macro]) in os.path.normcase(str):
                replace_dir = str[os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])):os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])) + len(self._AutoGenObject.Macros[Macro])]
                str = str.replace(replace_dir, '$(' + Macro + ')')
        return str

    def CommandExceedLimit(self):
        if False:
            i = 10
            return i + 15
        FlagDict = {'CC': {'Macro': '$(CC_FLAGS)', 'Value': False}, 'PP': {'Macro': '$(PP_FLAGS)', 'Value': False}, 'APP': {'Macro': '$(APP_FLAGS)', 'Value': False}, 'ASLPP': {'Macro': '$(ASLPP_FLAGS)', 'Value': False}, 'VFRPP': {'Macro': '$(VFRPP_FLAGS)', 'Value': False}, 'ASM': {'Macro': '$(ASM_FLAGS)', 'Value': False}, 'ASLCC': {'Macro': '$(ASLCC_FLAGS)', 'Value': False}}
        RespDict = {}
        FileTypeList = []
        IncPrefix = self._INC_FLAG_[self._AutoGenObject.ToolChainFamily]
        for File in self._AutoGenObject.SourceFileList:
            for type in self._AutoGenObject.FileTypes:
                if File in self._AutoGenObject.FileTypes[type]:
                    if type not in FileTypeList:
                        FileTypeList.append(type)
        if FileTypeList:
            for type in FileTypeList:
                BuildTargets = self._AutoGenObject.BuildRules[type].BuildTargets
                for Target in BuildTargets:
                    CommandList = BuildTargets[Target].Commands
                    for SingleCommand in CommandList:
                        Tool = ''
                        SingleCommandLength = len(SingleCommand)
                        SingleCommandList = SingleCommand.split()
                        if len(SingleCommandList) > 0:
                            for Flag in FlagDict:
                                if '$(' + Flag + ')' in SingleCommandList[0]:
                                    Tool = Flag
                                    break
                        if Tool:
                            if 'PATH' not in self._AutoGenObject.BuildOption[Tool]:
                                EdkLogger.error('build', AUTOGEN_ERROR, "%s_PATH doesn't exist in %s ToolChain and %s Arch." % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))
                            SingleCommandLength += len(self._AutoGenObject.BuildOption[Tool]['PATH'])
                            for item in SingleCommandList[1:]:
                                if FlagDict[Tool]['Macro'] in item:
                                    if 'FLAGS' not in self._AutoGenObject.BuildOption[Tool]:
                                        EdkLogger.error('build', AUTOGEN_ERROR, "%s_FLAGS doesn't exist in %s ToolChain and %s Arch." % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))
                                    Str = self._AutoGenObject.BuildOption[Tool]['FLAGS']
                                    for Option in self._AutoGenObject.BuildOption:
                                        for Attr in self._AutoGenObject.BuildOption[Option]:
                                            if Str.find(Option + '_' + Attr) != -1:
                                                Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])
                                    while Str.find('$(') != -1:
                                        for macro in self._AutoGenObject.Macros:
                                            MacroName = '$(' + macro + ')'
                                            if Str.find(MacroName) != -1:
                                                Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])
                                                break
                                        else:
                                            break
                                    SingleCommandLength += len(Str)
                                elif '$(INC)' in item:
                                    SingleCommandLength += self._AutoGenObject.IncludePathLength + len(IncPrefix) * len(self._AutoGenObject.IncludePathList)
                                elif item.find('$(') != -1:
                                    Str = item
                                    for Option in self._AutoGenObject.BuildOption:
                                        for Attr in self._AutoGenObject.BuildOption[Option]:
                                            if Str.find(Option + '_' + Attr) != -1:
                                                Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])
                                    while Str.find('$(') != -1:
                                        for macro in self._AutoGenObject.Macros:
                                            MacroName = '$(' + macro + ')'
                                            if Str.find(MacroName) != -1:
                                                Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])
                                                break
                                        else:
                                            break
                                    SingleCommandLength += len(Str)
                            if SingleCommandLength > GlobalData.gCommandMaxLength:
                                FlagDict[Tool]['Value'] = True
                for Flag in FlagDict:
                    if FlagDict[Flag]['Value']:
                        Key = Flag + '_RESP'
                        RespMacro = FlagDict[Flag]['Macro'].replace('FLAGS', 'RESP')
                        Value = self._AutoGenObject.BuildOption[Flag]['FLAGS']
                        for inc in self._AutoGenObject.IncludePathList:
                            Value += ' ' + IncPrefix + inc
                        for Option in self._AutoGenObject.BuildOption:
                            for Attr in self._AutoGenObject.BuildOption[Option]:
                                if Value.find(Option + '_' + Attr) != -1:
                                    Value = Value.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])
                        while Value.find('$(') != -1:
                            for macro in self._AutoGenObject.Macros:
                                MacroName = '$(' + macro + ')'
                                if Value.find(MacroName) != -1:
                                    Value = Value.replace(MacroName, self._AutoGenObject.Macros[macro])
                                    break
                            else:
                                break
                        if self._AutoGenObject.ToolChainFamily == 'GCC':
                            RespDict[Key] = Value.replace('\\', '/')
                        else:
                            RespDict[Key] = Value
                        for Target in BuildTargets:
                            for (i, SingleCommand) in enumerate(BuildTargets[Target].Commands):
                                if FlagDict[Flag]['Macro'] in SingleCommand:
                                    BuildTargets[Target].Commands[i] = SingleCommand.replace('$(INC)', '').replace(FlagDict[Flag]['Macro'], RespMacro)
        return RespDict

    def ProcessBuildTargetList(self, RespFile, ToolsDef):
        if False:
            return 10
        ForceIncludedFile = []
        for File in self._AutoGenObject.AutoGenFileList:
            if File.Ext == '.h':
                ForceIncludedFile.append(File)
        SourceFileList = []
        OutPutFileList = []
        for Target in self._AutoGenObject.IntroTargetList:
            SourceFileList.extend(Target.Inputs)
            OutPutFileList.extend(Target.Outputs)
        if OutPutFileList:
            for Item in OutPutFileList:
                if Item in SourceFileList:
                    SourceFileList.remove(Item)
        FileDependencyDict = {item: ForceIncludedFile for item in SourceFileList}
        for Dependency in FileDependencyDict.values():
            self.DependencyHeaderFileSet.update(set(Dependency))
        parentMetaFileIncludes = set()
        for aInclude in self._AutoGenObject.PackageIncludePathList:
            aIncludeName = str(aInclude)
            parentMetaFileIncludes.add(aIncludeName.lower())
        headerFilesInMetaFileSet = set()
        for aFile in self._AutoGenObject.SourceFileList:
            aFileName = str(aFile)
            if not aFileName.endswith('.h'):
                continue
            headerFilesInMetaFileSet.add(aFileName.lower())
        localAutoGenFileSet = set()
        for aFile in self._AutoGenObject.AutoGenFileList:
            localAutoGenFileSet.add(str(aFile).lower())
        headerFileDependencySet = set()
        localSourceDir = str(self._AutoGenObject.SourceDir).lower()
        for Dependency in FileDependencyDict.values():
            for aFile in Dependency:
                aFileName = str(aFile).lower()
                if not aFileName.endswith('.h'):
                    continue
                if aFileName in localAutoGenFileSet:
                    continue
                if localSourceDir not in aFileName:
                    continue
                pathNeeded = True
                for aIncludePath in parentMetaFileIncludes:
                    if aIncludePath in aFileName:
                        pathNeeded = False
                        break
                if not pathNeeded:
                    continue
                headerFileDependencySet.add(aFileName)
        for aFile in headerFileDependencySet:
            if aFile in headerFilesInMetaFileSet:
                continue
            if GlobalData.gUseHashCache:
                GlobalData.gModuleBuildTracking[self._AutoGenObject] = 'FAIL_METAFILE'
            EdkLogger.warn('build', 'Module MetaFile [Sources] is missing local header!', ExtraData='Local Header: ' + aFile + ' not found in ' + self._AutoGenObject.MetaFile.Path)
        for (File, Dependency) in FileDependencyDict.items():
            if not Dependency:
                continue
            self._AutoGenObject.AutoGenDepSet |= set(Dependency)
        CmdSumDict = {}
        CmdTargetDict = {}
        CmdCppDict = {}
        DependencyDict = FileDependencyDict.copy()
        if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and TAB_C_CODE_FILE in self._AutoGenObject.Targets:
            for T in self._AutoGenObject.Targets[TAB_C_CODE_FILE]:
                NewFile = self.PlaceMacro(str(T), self.Macros)
                if not self.ObjTargetDict.get(T.Target.SubDir):
                    self.ObjTargetDict[T.Target.SubDir] = set()
                self.ObjTargetDict[T.Target.SubDir].add(NewFile)
        for Type in self._AutoGenObject.Targets:
            resp_file_number = 0
            for T in self._AutoGenObject.Targets[Type]:
                if T.GenFileListMacro and T.FileListMacro not in self.FileListMacros:
                    self.FileListMacros[T.FileListMacro] = []
                if T.GenListFile and T.ListFileMacro not in self.ListFileMacros:
                    self.ListFileMacros[T.ListFileMacro] = []
                if T.GenIncListFile and T.IncListFileMacro not in self.ListFileMacros:
                    self.ListFileMacros[T.IncListFileMacro] = []
                Deps = []
                CCodeDeps = []
                for Dep in T.Dependencies:
                    Deps.append(self.PlaceMacro(str(Dep), self.Macros))
                    if Dep != '$(MAKE_FILE)':
                        CCodeDeps.append(self.PlaceMacro(str(Dep), self.Macros))
                if len(T.Inputs) == 1 and T.Inputs[0] in FileDependencyDict:
                    for F in FileDependencyDict[T.Inputs[0]]:
                        Deps.append(self.PlaceMacro(str(F), self.Macros))
                for F in T.Inputs:
                    NewFile = self.PlaceMacro(str(F), self.Macros)
                    if T.GenListFile:
                        self.ListFileMacros[T.ListFileMacro].append(str(F).replace('\\', '/'))
                        self.FileListMacros[T.FileListMacro].append(NewFile)
                    elif T.GenFileListMacro:
                        self.FileListMacros[T.FileListMacro].append(NewFile)
                    else:
                        Deps.append(NewFile)
                for key in self.FileListMacros:
                    self.FileListMacros[key].sort()
                if T.GenFileListMacro:
                    Deps.append('$(%s)' % T.FileListMacro)
                    if Type in [TAB_OBJECT_FILE, TAB_STATIC_LIBRARY]:
                        Deps.append('$(%s)' % T.ListFileMacro)
                if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and Type == TAB_C_CODE_FILE:
                    (T, CmdTarget, CmdTargetDict, CmdCppDict) = self.ParserCCodeFile(T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number)
                    resp_file_number += 1
                    TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\n\t'.join(T.Commands), 'deps': CCodeDeps}
                    CmdLine = self._BUILD_TARGET_TEMPLATE.Replace(TargetDict).rstrip().replace('\t$(OBJLIST', '$(OBJLIST')
                    if T.Commands:
                        CmdLine = '%s%s' % (CmdLine, TAB_LINE_BREAK)
                    if CCodeDeps or CmdLine:
                        self.BuildTargetList.append(CmdLine)
                else:
                    TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\n\t'.join(T.Commands), 'deps': Deps}
                    self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(TargetDict))
                    for i in T.Outputs[1:]:
                        AnnexeTargetDict = {'target': self.PlaceMacro(i.Path, self.Macros), 'cmd': '', 'deps': self.PlaceMacro(T.Target.Path, self.Macros)}
                        self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(AnnexeTargetDict))

    def ParserCCodeFile(self, T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number):
        if False:
            return 10
        SaveFilePath = os.path.join(RespFile, 'cc_resp_%s.txt' % resp_file_number)
        if not CmdSumDict:
            for item in self._AutoGenObject.Targets[Type]:
                CmdSumDict[item.Target.SubDir] = item.Target.BaseName
                for CppPath in item.Inputs:
                    Path = self.PlaceMacro(CppPath.Path, self.Macros)
                    if CmdCppDict.get(item.Target.SubDir):
                        CmdCppDict[item.Target.SubDir].append(Path)
                    else:
                        CmdCppDict[item.Target.SubDir] = ['$(MAKE_FILE)', Path]
                    if CppPath.Path in DependencyDict:
                        for Temp in DependencyDict[CppPath.Path]:
                            try:
                                Path = self.PlaceMacro(Temp.Path, self.Macros)
                            except:
                                continue
                            if Path not in self.CommonFileDependency + CmdCppDict[item.Target.SubDir]:
                                CmdCppDict[item.Target.SubDir].append(Path)
        if T.Commands:
            CommandList = T.Commands[:]
            for Item in CommandList[:]:
                SingleCommandList = Item.split()
                if len(SingleCommandList) > 0 and self.CheckCCCmd(SingleCommandList):
                    for Temp in SingleCommandList:
                        if Temp.startswith('/Fo'):
                            CmdSign = '%s%s' % (Temp.rsplit(TAB_SLASH, 1)[0], TAB_SLASH)
                            break
                    else:
                        continue
                    if CmdSign not in list(CmdTargetDict.keys()):
                        cmd = Item.replace(Temp, CmdSign)
                        if SingleCommandList[-1] in cmd:
                            CmdTargetDict[CmdSign] = [cmd.replace(SingleCommandList[-1], '').rstrip(), SingleCommandList[-1]]
                    else:
                        CmdTargetDict[CmdSign].append(SingleCommandList[-1])
                    Index = CommandList.index(Item)
                    CommandList.pop(Index)
                    BaseName = SingleCommandList[-1].rsplit('.', 1)[0]
                    if BaseName.endswith('%s%s' % (TAB_SLASH, CmdSumDict[CmdSign[3:].rsplit(TAB_SLASH, 1)[0]])):
                        Cpplist = CmdCppDict[T.Target.SubDir]
                        Cpplist.insert(0, '$(OBJLIST_%d): ' % list(self.ObjTargetDict.keys()).index(T.Target.SubDir))
                        source_files = CmdTargetDict[CmdSign][1:]
                        source_files.insert(0, ' ')
                        if len(source_files) > 2:
                            SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)
                            T.Commands[Index] = '%s\n\t%s $(cc_resp_%s)' % (' \\\n\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)
                            ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))
                        elif len(source_files) <= 2 and len(' '.join(CmdTargetDict[CmdSign][:2])) > GlobalData.gCommandMaxLength:
                            SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)
                            T.Commands[Index] = '%s\n\t%s $(cc_resp_%s)' % (' \\\n\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)
                            ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))
                        else:
                            T.Commands[Index] = '%s\n\t%s' % (' \\\n\t'.join(Cpplist), ' '.join(CmdTargetDict[CmdSign]))
                    else:
                        T.Commands.pop(Index)
        return (T, CmdSumDict, CmdTargetDict, CmdCppDict)

    def CheckCCCmd(self, CommandList):
        if False:
            while True:
                i = 10
        for cmd in CommandList:
            if '$(CC)' in cmd:
                return True
        return False

    def ProcessDependentLibrary(self):
        if False:
            i = 10
            return i + 15
        for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:
            if not LibraryAutoGen.IsBinaryModule:
                self.LibraryBuildDirectoryList.append(self.PlaceMacro(LibraryAutoGen.BuildDir, self.Macros))

    def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):
        if False:
            i = 10
            return i + 15
        Dependency = {}
        for F in FileList:
            Dependency[F] = GetDependencyList(self._AutoGenObject, self.FileCache, F, ForceInculeList, SearchPathList)
        return Dependency

class CustomMakefile(BuildFile):
    _TEMPLATE_ = TemplateString('${makefile_header}\n\n#\n# Platform Macro Definition\n#\nPLATFORM_NAME = ${platform_name}\nPLATFORM_GUID = ${platform_guid}\nPLATFORM_VERSION = ${platform_version}\nPLATFORM_RELATIVE_DIR = ${platform_relative_directory}\nPLATFORM_DIR = ${platform_dir}\nPLATFORM_OUTPUT_DIR = ${platform_output_directory}\n\n#\n# Module Macro Definition\n#\nMODULE_NAME = ${module_name}\nMODULE_GUID = ${module_guid}\nMODULE_NAME_GUID = ${module_name_guid}\nMODULE_VERSION = ${module_version}\nMODULE_TYPE = ${module_type}\nMODULE_FILE = ${module_file}\nMODULE_FILE_BASE_NAME = ${module_file_base_name}\nBASE_NAME = $(MODULE_NAME)\nMODULE_RELATIVE_DIR = ${module_relative_directory}\nMODULE_DIR = ${module_dir}\n\n#\n# Build Configuration Macro Definition\n#\nARCH = ${architecture}\nTOOLCHAIN = ${toolchain_tag}\nTOOLCHAIN_TAG = ${toolchain_tag}\nTARGET = ${build_target}\n\n#\n# Build Directory Macro Definition\n#\n# PLATFORM_BUILD_DIR = ${platform_build_directory}\nBUILD_DIR = ${platform_build_directory}\nBIN_DIR = $(BUILD_DIR)${separator}${architecture}\nLIB_DIR = $(BIN_DIR)\nMODULE_BUILD_DIR = ${module_build_directory}\nOUTPUT_DIR = ${module_output_directory}\nDEBUG_DIR = ${module_debug_directory}\nDEST_DIR_OUTPUT = $(OUTPUT_DIR)\nDEST_DIR_DEBUG = $(DEBUG_DIR)\n\n#\n# Tools definitions specific to this module\n#\n${BEGIN}${module_tool_definitions}\n${END}\nMAKE_FILE = ${makefile_path}\n\n#\n# Shell Command Macro\n#\n${BEGIN}${shell_command_code} = ${shell_command}\n${END}\n\n${custom_makefile_content}\n\n#\n# Target used when called from platform makefile, which will bypass the build of dependent libraries\n#\n\npbuild: init all\n\n\n#\n# ModuleTarget\n#\n\nmbuild: init all\n\n#\n# Build Target used in multi-thread build mode, which no init target is needed\n#\n\ntbuild: all\n\n#\n# Initialization target: print build information and create necessary directories\n#\ninit:\n\t-@echo Building ... $(MODULE_DIR)${separator}$(MODULE_FILE) [$(ARCH)]\n${BEGIN}\t-@${create_directory_command}\n${END}\n')

    def __init__(self, ModuleAutoGen):
        if False:
            return 10
        BuildFile.__init__(self, ModuleAutoGen)
        self.PlatformInfo = self._AutoGenObject.PlatformInfo
        self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']
        self.DependencyHeaderFileSet = set()

    @property
    def _TemplateDict(self):
        if False:
            i = 10
            return i + 15
        Separator = self._SEP_[self._Platform]
        MyAgo = self._AutoGenObject
        if self._FileType not in MyAgo.CustomMakefile:
            EdkLogger.error('build', OPTION_NOT_SUPPORTED, 'No custom makefile for %s' % self._FileType, ExtraData='[%s]' % str(MyAgo))
        MakefilePath = mws.join(MyAgo.WorkspaceDir, MyAgo.CustomMakefile[self._FileType])
        try:
            CustomMakefile = open(MakefilePath, 'r').read()
        except:
            EdkLogger.error('build', FILE_OPEN_FAILURE, File=str(MyAgo), ExtraData=MyAgo.CustomMakefile[self._FileType])
        ToolsDef = []
        for Tool in MyAgo.BuildOption:
            if Tool == 'MAKE':
                continue
            for Attr in MyAgo.BuildOption[Tool]:
                if Attr == 'FAMILY':
                    continue
                elif Attr == 'PATH':
                    ToolsDef.append('%s = %s' % (Tool, MyAgo.BuildOption[Tool][Attr]))
                else:
                    ToolsDef.append('%s_%s = %s' % (Tool, Attr, MyAgo.BuildOption[Tool][Attr]))
            ToolsDef.append('')
        MakefileName = self.getMakefileName()
        MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(MyAgo.WorkspaceDir, MyAgo.SourceDir), 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'custom_makefile_content': CustomMakefile}
        return MakefileTemplateDict

class PlatformMakefile(BuildFile):
    _TEMPLATE_ = TemplateString('${makefile_header}\n\n#\n# Platform Macro Definition\n#\nPLATFORM_NAME = ${platform_name}\nPLATFORM_GUID = ${platform_guid}\nPLATFORM_VERSION = ${platform_version}\nPLATFORM_FILE = ${platform_file}\nPLATFORM_DIR = ${platform_dir}\nPLATFORM_OUTPUT_DIR = ${platform_output_directory}\n\n#\n# Build Configuration Macro Definition\n#\nTOOLCHAIN = ${toolchain_tag}\nTOOLCHAIN_TAG = ${toolchain_tag}\nTARGET = ${build_target}\n\n#\n# Build Directory Macro Definition\n#\nBUILD_DIR = ${platform_build_directory}\nFV_DIR = ${platform_build_directory}${separator}FV\n\n#\n# Shell Command Macro\n#\n${BEGIN}${shell_command_code} = ${shell_command}\n${END}\n\nMAKE = ${make_path}\nMAKE_FILE = ${makefile_path}\n\n#\n# Default target\n#\nall: init build_libraries build_modules\n\n#\n# Initialization target: print build information and create necessary directories\n#\ninit:\n\t-@echo Building ... $(PLATFORM_FILE) [${build_architecture_list}]\n\t${BEGIN}-@${create_directory_command}\n\t${END}\n#\n# library build target\n#\nlibraries: init build_libraries\n\n#\n# module build target\n#\nmodules: init build_libraries build_modules\n\n#\n# Build all libraries:\n#\nbuild_libraries:\n${BEGIN}\t@"$(MAKE)" $(MAKE_FLAGS) -f ${library_makefile_list} pbuild\n${END}\t@cd $(BUILD_DIR)\n\n#\n# Build all modules:\n#\nbuild_modules:\n${BEGIN}\t@"$(MAKE)" $(MAKE_FLAGS) -f ${module_makefile_list} pbuild\n${END}\t@cd $(BUILD_DIR)\n\n#\n# Clean intermediate files\n#\nclean:\n\t${BEGIN}-@${library_build_command} clean\n\t${END}${BEGIN}-@${module_build_command} clean\n\t${END}@cd $(BUILD_DIR)\n\n#\n# Clean all generated files except to makefile\n#\ncleanall:\n${BEGIN}\t${cleanall_command}\n${END}\n\n#\n# Clean all library files\n#\ncleanlib:\n\t${BEGIN}-@${library_build_command} cleanall\n\t${END}@cd $(BUILD_DIR)\n\n')

    def __init__(self, PlatformAutoGen):
        if False:
            while True:
                i = 10
        BuildFile.__init__(self, PlatformAutoGen)
        self.ModuleBuildCommandList = []
        self.ModuleMakefileList = []
        self.IntermediateDirectoryList = []
        self.ModuleBuildDirectoryList = []
        self.LibraryBuildDirectoryList = []
        self.LibraryMakeCommandList = []
        self.DependencyHeaderFileSet = set()

    @property
    def _TemplateDict(self):
        if False:
            i = 10
            return i + 15
        Separator = self._SEP_[self._Platform]
        MyAgo = self._AutoGenObject
        if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:
            EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))
        self.IntermediateDirectoryList = ['$(BUILD_DIR)']
        self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()
        self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()
        MakefileName = self.getMakefileName()
        LibraryMakefileList = []
        LibraryMakeCommandList = []
        for D in self.LibraryBuildDirectoryList:
            D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})
            Makefile = os.path.join(D, MakefileName)
            Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}
            LibraryMakefileList.append(Makefile)
            LibraryMakeCommandList.append(Command)
        self.LibraryMakeCommandList = LibraryMakeCommandList
        ModuleMakefileList = []
        ModuleMakeCommandList = []
        for D in self.ModuleBuildDirectoryList:
            D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})
            Makefile = os.path.join(D, MakefileName)
            Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}
            ModuleMakefileList.append(Makefile)
            ModuleMakeCommandList.append(Command)
        MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'makefile_name': MakefileName, 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_file': MyAgo.MetaFile, 'platform_relative_directory': MyAgo.SourceDir, 'platform_output_directory': MyAgo.OutputDir, 'platform_build_directory': MyAgo.BuildDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'build_architecture_list': MyAgo.Arch, 'architecture': MyAgo.Arch, 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'library_makefile_list': LibraryMakefileList, 'module_makefile_list': ModuleMakefileList, 'library_build_command': LibraryMakeCommandList, 'module_build_command': ModuleMakeCommandList}
        return MakefileTemplateDict

    def GetModuleBuildDirectoryList(self):
        if False:
            while True:
                i = 10
        DirList = []
        for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:
            if not ModuleAutoGen.IsBinaryModule:
                DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))
        return DirList

    def GetLibraryBuildDirectoryList(self):
        if False:
            i = 10
            return i + 15
        DirList = []
        for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:
            if not LibraryAutoGen.IsBinaryModule:
                DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))
        return DirList

class TopLevelMakefile(BuildFile):
    _TEMPLATE_ = TemplateString('${BEGIN}\tGenFds -f ${fdf_file} --conf=${conf_directory} -o ${platform_build_directory} -t ${toolchain_tag} -b ${build_target} -p ${active_platform} -a ${build_architecture_list} ${extra_options}${END}${BEGIN} -r ${fd} ${END}${BEGIN} -i ${fv} ${END}${BEGIN} -C ${cap} ${END}${BEGIN} -D ${macro} ${END}')

    def __init__(self, Workspace):
        if False:
            print('Hello World!')
        BuildFile.__init__(self, Workspace)
        self.IntermediateDirectoryList = []
        self.DependencyHeaderFileSet = set()

    @property
    def _TemplateDict(self):
        if False:
            print('Hello World!')
        Separator = self._SEP_[self._Platform]
        MyAgo = self._AutoGenObject
        if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:
            EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))
        for Arch in MyAgo.ArchList:
            self.IntermediateDirectoryList.append(Separator.join(['$(BUILD_DIR)', Arch]))
        self.IntermediateDirectoryList.append('$(FV_DIR)')
        MacroList = []
        if MyAgo.FdfFile is not None and MyAgo.FdfFile != '':
            FdfFileList = [MyAgo.FdfFile]
            MacroDict = {}
            MacroDict.update(GlobalData.gGlobalDefines)
            MacroDict.update(GlobalData.gCommandLineDefines)
            for MacroName in MacroDict:
                if MacroDict[MacroName] != '':
                    MacroList.append('"%s=%s"' % (MacroName, MacroDict[MacroName].replace('\\', '\\\\')))
                else:
                    MacroList.append('"%s"' % MacroName)
        else:
            FdfFileList = []
        ExtraOption = ''
        LogLevel = EdkLogger.GetLevel()
        if LogLevel == EdkLogger.VERBOSE:
            ExtraOption += ' -v'
        elif LogLevel <= EdkLogger.DEBUG_9:
            ExtraOption += ' -d %d' % (LogLevel - 1)
        elif LogLevel == EdkLogger.QUIET:
            ExtraOption += ' -q'
        if GlobalData.gCaseInsensitive:
            ExtraOption += ' -c'
        if not GlobalData.gEnableGenfdsMultiThread:
            ExtraOption += ' --no-genfds-multi-thread'
        if GlobalData.gIgnoreSource:
            ExtraOption += ' --ignore-sources'
        for pcd in GlobalData.BuildOptionPcd:
            if pcd[2]:
                pcdname = '.'.join(pcd[0:3])
            else:
                pcdname = '.'.join(pcd[0:2])
            if pcd[3].startswith('{'):
                ExtraOption += ' --pcd ' + pcdname + '=' + 'H' + '"' + pcd[3] + '"'
            else:
                ExtraOption += ' --pcd ' + pcdname + '=' + pcd[3]
        MakefileName = self.getMakefileName()
        SubBuildCommandList = []
        for A in MyAgo.ArchList:
            Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join('$(BUILD_DIR)', A, MakefileName)}
            SubBuildCommandList.append(Command)
        MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_build_directory': MyAgo.BuildDir, 'conf_directory': GlobalData.gConfDirectory, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'arch': list(MyAgo.ArchList), 'build_architecture_list': ','.join(MyAgo.ArchList), 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'sub_build_command': SubBuildCommandList, 'fdf_file': FdfFileList, 'active_platform': str(MyAgo), 'fd': MyAgo.FdTargetList, 'fv': MyAgo.FvTargetList, 'cap': MyAgo.CapTargetList, 'extra_options': ExtraOption, 'macro': MacroList}
        return MakefileTemplateDict

    def GetModuleBuildDirectoryList(self):
        if False:
            while True:
                i = 10
        DirList = []
        for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:
            if not ModuleAutoGen.IsBinaryModule:
                DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))
        return DirList

    def GetLibraryBuildDirectoryList(self):
        if False:
            return 10
        DirList = []
        for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:
            if not LibraryAutoGen.IsBinaryModule:
                DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))
        return DirList

def GetDependencyList(AutoGenObject, FileCache, File, ForceList, SearchPathList):
    if False:
        print('Hello World!')
    EdkLogger.debug(EdkLogger.DEBUG_1, 'Try to get dependency files for %s' % File)
    FileStack = [File] + ForceList
    DependencySet = set()
    if AutoGenObject.Arch not in gDependencyDatabase:
        gDependencyDatabase[AutoGenObject.Arch] = {}
    DepDb = gDependencyDatabase[AutoGenObject.Arch]
    while len(FileStack) > 0:
        F = FileStack.pop()
        FullPathDependList = []
        if F in FileCache:
            for CacheFile in FileCache[F]:
                FullPathDependList.append(CacheFile)
                if CacheFile not in DependencySet:
                    FileStack.append(CacheFile)
            DependencySet.update(FullPathDependList)
            continue
        CurrentFileDependencyList = []
        if F in DepDb:
            CurrentFileDependencyList = DepDb[F]
        else:
            try:
                Fd = open(F.Path, 'rb')
                FileContent = Fd.read()
                Fd.close()
            except BaseException as X:
                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F.Path + '\n\t' + str(X))
            if len(FileContent) == 0:
                continue
            try:
                if FileContent[0] == 255 or FileContent[0] == 254:
                    FileContent = FileContent.decode('utf-16')
                else:
                    FileContent = FileContent.decode()
            except:
                continue
            IncludedFileList = gIncludePattern.findall(FileContent)
            for Inc in IncludedFileList:
                Inc = Inc.strip()
                HeaderList = gMacroPattern.findall(Inc)
                if len(HeaderList) == 1 and len(HeaderList[0]) == 2:
                    HeaderType = HeaderList[0][0]
                    HeaderKey = HeaderList[0][1]
                    if HeaderType in gIncludeMacroConversion:
                        Inc = gIncludeMacroConversion[HeaderType] % {'HeaderKey': HeaderKey}
                    else:
                        FileCache[File] = []
                        return []
                Inc = os.path.normpath(Inc)
                CurrentFileDependencyList.append(Inc)
            DepDb[F] = CurrentFileDependencyList
        CurrentFilePath = F.Dir
        PathList = [CurrentFilePath] + SearchPathList
        for Inc in CurrentFileDependencyList:
            for SearchPath in PathList:
                FilePath = os.path.join(SearchPath, Inc)
                if FilePath in gIsFileMap:
                    if not gIsFileMap[FilePath]:
                        continue
                elif not os.path.isfile(FilePath):
                    gIsFileMap[FilePath] = False
                    continue
                else:
                    gIsFileMap[FilePath] = True
                FilePath = PathClass(FilePath)
                FullPathDependList.append(FilePath)
                if FilePath not in DependencySet:
                    FileStack.append(FilePath)
                break
            else:
                EdkLogger.debug(EdkLogger.DEBUG_9, '%s included by %s was not found in any given path:\n\t%s' % (Inc, F, '\n\t'.join(SearchPathList)))
        FileCache[F] = FullPathDependList
        DependencySet.update(FullPathDependList)
    DependencySet.update(ForceList)
    if File in DependencySet:
        DependencySet.remove(File)
    DependencyList = list(DependencySet)
    return DependencyList
if __name__ == '__main__':
    pass