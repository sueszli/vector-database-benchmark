[
    {
        "func_name": "update_bom_item",
        "original": "def update_bom_item(apps, schema_editor):\n    \"\"\"Update all existing BomItem instances, and cache the 'validated' field.\n\n    The 'validated' field denotes whether this individual BomItem has been validated,\n    which previously was calculated on the fly (which was very expensive).\n    \"\"\"\n    BomItem = apps.get_model('part', 'bomitem')\n    InvenTreeSetting = apps.get_model('common', 'inventreesetting')\n    n = BomItem.objects.count()\n    if n > 0:\n        for item in BomItem.objects.all():\n            'For each item, we need to re-calculate the \"checksum\", based on the *old* routine.\\n            Note that as we cannot access the ORM models, we have to do this \"by hand\"\\n            '\n            try:\n                setting = InvenTreeSetting.objects.get(key='PART_NAME_FORMAT')\n                full_name_pattern = str(setting.value)\n            except Exception:\n                full_name_pattern = \"{{ part.IPN if part.IPN }}{{ ' | ' if part.IPN }}{{ part.name }}{{ ' | ' if part.revision }}{{ part.revision if part.revision }}\"\n            template = Template(full_name_pattern)\n            full_name = template.render({'part': item.sub_part})\n            old_hash = hashlib.md5(str(item.pk).encode())\n            old_hash.update(str(item.sub_part.pk).encode())\n            old_hash.update(str(full_name).encode())\n            old_hash.update(str(item.quantity).encode())\n            old_hash.update(str(item.note).encode())\n            old_hash.update(str(item.reference).encode())\n            old_hash.update(str(item.optional).encode())\n            old_hash.update(str(item.inherited).encode())\n            if item.consumable:\n                old_hash.update(str(item.consumable).encode())\n            if item.allow_variants:\n                old_hash.update(str(item.allow_variants).encode())\n            checksum = str(old_hash.digest())\n            item.validated = item.checksum == checksum\n            'Next, we need to update the item with a \"new\" hash, with the following differences:\\n            - Uses the PK of the \\'part\\', not the BomItem itself,\\n            - Does not use the \\'full_name\\' of the linked \\'sub_part\\'\\n            - Does not use the \\'note\\' field\\n            '\n            if item.validated:\n                new_hash = hashlib.md5(''.encode())\n                components = [item.part.pk, item.sub_part.pk, normalize(item.quantity), item.reference, item.optional, item.inherited, item.consumable, item.allow_variants]\n                for component in components:\n                    new_hash.update(str(component).encode())\n                item.checksum = str(new_hash.digest())\n            item.save()\n        logger.info(f\"Updated 'validated' flag for {n} BomItem objects\")",
        "mutated": [
            "def update_bom_item(apps, schema_editor):\n    if False:\n        i = 10\n    \"Update all existing BomItem instances, and cache the 'validated' field.\\n\\n    The 'validated' field denotes whether this individual BomItem has been validated,\\n    which previously was calculated on the fly (which was very expensive).\\n    \"\n    BomItem = apps.get_model('part', 'bomitem')\n    InvenTreeSetting = apps.get_model('common', 'inventreesetting')\n    n = BomItem.objects.count()\n    if n > 0:\n        for item in BomItem.objects.all():\n            'For each item, we need to re-calculate the \"checksum\", based on the *old* routine.\\n            Note that as we cannot access the ORM models, we have to do this \"by hand\"\\n            '\n            try:\n                setting = InvenTreeSetting.objects.get(key='PART_NAME_FORMAT')\n                full_name_pattern = str(setting.value)\n            except Exception:\n                full_name_pattern = \"{{ part.IPN if part.IPN }}{{ ' | ' if part.IPN }}{{ part.name }}{{ ' | ' if part.revision }}{{ part.revision if part.revision }}\"\n            template = Template(full_name_pattern)\n            full_name = template.render({'part': item.sub_part})\n            old_hash = hashlib.md5(str(item.pk).encode())\n            old_hash.update(str(item.sub_part.pk).encode())\n            old_hash.update(str(full_name).encode())\n            old_hash.update(str(item.quantity).encode())\n            old_hash.update(str(item.note).encode())\n            old_hash.update(str(item.reference).encode())\n            old_hash.update(str(item.optional).encode())\n            old_hash.update(str(item.inherited).encode())\n            if item.consumable:\n                old_hash.update(str(item.consumable).encode())\n            if item.allow_variants:\n                old_hash.update(str(item.allow_variants).encode())\n            checksum = str(old_hash.digest())\n            item.validated = item.checksum == checksum\n            'Next, we need to update the item with a \"new\" hash, with the following differences:\\n            - Uses the PK of the \\'part\\', not the BomItem itself,\\n            - Does not use the \\'full_name\\' of the linked \\'sub_part\\'\\n            - Does not use the \\'note\\' field\\n            '\n            if item.validated:\n                new_hash = hashlib.md5(''.encode())\n                components = [item.part.pk, item.sub_part.pk, normalize(item.quantity), item.reference, item.optional, item.inherited, item.consumable, item.allow_variants]\n                for component in components:\n                    new_hash.update(str(component).encode())\n                item.checksum = str(new_hash.digest())\n            item.save()\n        logger.info(f\"Updated 'validated' flag for {n} BomItem objects\")",
            "def update_bom_item(apps, schema_editor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Update all existing BomItem instances, and cache the 'validated' field.\\n\\n    The 'validated' field denotes whether this individual BomItem has been validated,\\n    which previously was calculated on the fly (which was very expensive).\\n    \"\n    BomItem = apps.get_model('part', 'bomitem')\n    InvenTreeSetting = apps.get_model('common', 'inventreesetting')\n    n = BomItem.objects.count()\n    if n > 0:\n        for item in BomItem.objects.all():\n            'For each item, we need to re-calculate the \"checksum\", based on the *old* routine.\\n            Note that as we cannot access the ORM models, we have to do this \"by hand\"\\n            '\n            try:\n                setting = InvenTreeSetting.objects.get(key='PART_NAME_FORMAT')\n                full_name_pattern = str(setting.value)\n            except Exception:\n                full_name_pattern = \"{{ part.IPN if part.IPN }}{{ ' | ' if part.IPN }}{{ part.name }}{{ ' | ' if part.revision }}{{ part.revision if part.revision }}\"\n            template = Template(full_name_pattern)\n            full_name = template.render({'part': item.sub_part})\n            old_hash = hashlib.md5(str(item.pk).encode())\n            old_hash.update(str(item.sub_part.pk).encode())\n            old_hash.update(str(full_name).encode())\n            old_hash.update(str(item.quantity).encode())\n            old_hash.update(str(item.note).encode())\n            old_hash.update(str(item.reference).encode())\n            old_hash.update(str(item.optional).encode())\n            old_hash.update(str(item.inherited).encode())\n            if item.consumable:\n                old_hash.update(str(item.consumable).encode())\n            if item.allow_variants:\n                old_hash.update(str(item.allow_variants).encode())\n            checksum = str(old_hash.digest())\n            item.validated = item.checksum == checksum\n            'Next, we need to update the item with a \"new\" hash, with the following differences:\\n            - Uses the PK of the \\'part\\', not the BomItem itself,\\n            - Does not use the \\'full_name\\' of the linked \\'sub_part\\'\\n            - Does not use the \\'note\\' field\\n            '\n            if item.validated:\n                new_hash = hashlib.md5(''.encode())\n                components = [item.part.pk, item.sub_part.pk, normalize(item.quantity), item.reference, item.optional, item.inherited, item.consumable, item.allow_variants]\n                for component in components:\n                    new_hash.update(str(component).encode())\n                item.checksum = str(new_hash.digest())\n            item.save()\n        logger.info(f\"Updated 'validated' flag for {n} BomItem objects\")",
            "def update_bom_item(apps, schema_editor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Update all existing BomItem instances, and cache the 'validated' field.\\n\\n    The 'validated' field denotes whether this individual BomItem has been validated,\\n    which previously was calculated on the fly (which was very expensive).\\n    \"\n    BomItem = apps.get_model('part', 'bomitem')\n    InvenTreeSetting = apps.get_model('common', 'inventreesetting')\n    n = BomItem.objects.count()\n    if n > 0:\n        for item in BomItem.objects.all():\n            'For each item, we need to re-calculate the \"checksum\", based on the *old* routine.\\n            Note that as we cannot access the ORM models, we have to do this \"by hand\"\\n            '\n            try:\n                setting = InvenTreeSetting.objects.get(key='PART_NAME_FORMAT')\n                full_name_pattern = str(setting.value)\n            except Exception:\n                full_name_pattern = \"{{ part.IPN if part.IPN }}{{ ' | ' if part.IPN }}{{ part.name }}{{ ' | ' if part.revision }}{{ part.revision if part.revision }}\"\n            template = Template(full_name_pattern)\n            full_name = template.render({'part': item.sub_part})\n            old_hash = hashlib.md5(str(item.pk).encode())\n            old_hash.update(str(item.sub_part.pk).encode())\n            old_hash.update(str(full_name).encode())\n            old_hash.update(str(item.quantity).encode())\n            old_hash.update(str(item.note).encode())\n            old_hash.update(str(item.reference).encode())\n            old_hash.update(str(item.optional).encode())\n            old_hash.update(str(item.inherited).encode())\n            if item.consumable:\n                old_hash.update(str(item.consumable).encode())\n            if item.allow_variants:\n                old_hash.update(str(item.allow_variants).encode())\n            checksum = str(old_hash.digest())\n            item.validated = item.checksum == checksum\n            'Next, we need to update the item with a \"new\" hash, with the following differences:\\n            - Uses the PK of the \\'part\\', not the BomItem itself,\\n            - Does not use the \\'full_name\\' of the linked \\'sub_part\\'\\n            - Does not use the \\'note\\' field\\n            '\n            if item.validated:\n                new_hash = hashlib.md5(''.encode())\n                components = [item.part.pk, item.sub_part.pk, normalize(item.quantity), item.reference, item.optional, item.inherited, item.consumable, item.allow_variants]\n                for component in components:\n                    new_hash.update(str(component).encode())\n                item.checksum = str(new_hash.digest())\n            item.save()\n        logger.info(f\"Updated 'validated' flag for {n} BomItem objects\")",
            "def update_bom_item(apps, schema_editor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Update all existing BomItem instances, and cache the 'validated' field.\\n\\n    The 'validated' field denotes whether this individual BomItem has been validated,\\n    which previously was calculated on the fly (which was very expensive).\\n    \"\n    BomItem = apps.get_model('part', 'bomitem')\n    InvenTreeSetting = apps.get_model('common', 'inventreesetting')\n    n = BomItem.objects.count()\n    if n > 0:\n        for item in BomItem.objects.all():\n            'For each item, we need to re-calculate the \"checksum\", based on the *old* routine.\\n            Note that as we cannot access the ORM models, we have to do this \"by hand\"\\n            '\n            try:\n                setting = InvenTreeSetting.objects.get(key='PART_NAME_FORMAT')\n                full_name_pattern = str(setting.value)\n            except Exception:\n                full_name_pattern = \"{{ part.IPN if part.IPN }}{{ ' | ' if part.IPN }}{{ part.name }}{{ ' | ' if part.revision }}{{ part.revision if part.revision }}\"\n            template = Template(full_name_pattern)\n            full_name = template.render({'part': item.sub_part})\n            old_hash = hashlib.md5(str(item.pk).encode())\n            old_hash.update(str(item.sub_part.pk).encode())\n            old_hash.update(str(full_name).encode())\n            old_hash.update(str(item.quantity).encode())\n            old_hash.update(str(item.note).encode())\n            old_hash.update(str(item.reference).encode())\n            old_hash.update(str(item.optional).encode())\n            old_hash.update(str(item.inherited).encode())\n            if item.consumable:\n                old_hash.update(str(item.consumable).encode())\n            if item.allow_variants:\n                old_hash.update(str(item.allow_variants).encode())\n            checksum = str(old_hash.digest())\n            item.validated = item.checksum == checksum\n            'Next, we need to update the item with a \"new\" hash, with the following differences:\\n            - Uses the PK of the \\'part\\', not the BomItem itself,\\n            - Does not use the \\'full_name\\' of the linked \\'sub_part\\'\\n            - Does not use the \\'note\\' field\\n            '\n            if item.validated:\n                new_hash = hashlib.md5(''.encode())\n                components = [item.part.pk, item.sub_part.pk, normalize(item.quantity), item.reference, item.optional, item.inherited, item.consumable, item.allow_variants]\n                for component in components:\n                    new_hash.update(str(component).encode())\n                item.checksum = str(new_hash.digest())\n            item.save()\n        logger.info(f\"Updated 'validated' flag for {n} BomItem objects\")",
            "def update_bom_item(apps, schema_editor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Update all existing BomItem instances, and cache the 'validated' field.\\n\\n    The 'validated' field denotes whether this individual BomItem has been validated,\\n    which previously was calculated on the fly (which was very expensive).\\n    \"\n    BomItem = apps.get_model('part', 'bomitem')\n    InvenTreeSetting = apps.get_model('common', 'inventreesetting')\n    n = BomItem.objects.count()\n    if n > 0:\n        for item in BomItem.objects.all():\n            'For each item, we need to re-calculate the \"checksum\", based on the *old* routine.\\n            Note that as we cannot access the ORM models, we have to do this \"by hand\"\\n            '\n            try:\n                setting = InvenTreeSetting.objects.get(key='PART_NAME_FORMAT')\n                full_name_pattern = str(setting.value)\n            except Exception:\n                full_name_pattern = \"{{ part.IPN if part.IPN }}{{ ' | ' if part.IPN }}{{ part.name }}{{ ' | ' if part.revision }}{{ part.revision if part.revision }}\"\n            template = Template(full_name_pattern)\n            full_name = template.render({'part': item.sub_part})\n            old_hash = hashlib.md5(str(item.pk).encode())\n            old_hash.update(str(item.sub_part.pk).encode())\n            old_hash.update(str(full_name).encode())\n            old_hash.update(str(item.quantity).encode())\n            old_hash.update(str(item.note).encode())\n            old_hash.update(str(item.reference).encode())\n            old_hash.update(str(item.optional).encode())\n            old_hash.update(str(item.inherited).encode())\n            if item.consumable:\n                old_hash.update(str(item.consumable).encode())\n            if item.allow_variants:\n                old_hash.update(str(item.allow_variants).encode())\n            checksum = str(old_hash.digest())\n            item.validated = item.checksum == checksum\n            'Next, we need to update the item with a \"new\" hash, with the following differences:\\n            - Uses the PK of the \\'part\\', not the BomItem itself,\\n            - Does not use the \\'full_name\\' of the linked \\'sub_part\\'\\n            - Does not use the \\'note\\' field\\n            '\n            if item.validated:\n                new_hash = hashlib.md5(''.encode())\n                components = [item.part.pk, item.sub_part.pk, normalize(item.quantity), item.reference, item.optional, item.inherited, item.consumable, item.allow_variants]\n                for component in components:\n                    new_hash.update(str(component).encode())\n                item.checksum = str(new_hash.digest())\n            item.save()\n        logger.info(f\"Updated 'validated' flag for {n} BomItem objects\")"
        ]
    }
]