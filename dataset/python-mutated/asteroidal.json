[
    {
        "func_name": "find_asteroidal_triple",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef find_asteroidal_triple(G):\n    \"\"\"Find an asteroidal triple in the given graph.\n\n    An asteroidal triple is a triple of non-adjacent vertices such that\n    there exists a path between any two of them which avoids the closed\n    neighborhood of the third. It checks all independent triples of vertices\n    and whether they are an asteroidal triple or not. This is done with the\n    help of a data structure called a component structure.\n    A component structure encodes information about which vertices belongs to\n    the same connected component when the closed neighborhood of a given vertex\n    is removed from the graph. The algorithm used to check is the trivial\n    one, outlined in [1]_, which has a runtime of\n    :math:`O(|V||\\\\overline{E} + |V||E|)`, where the second term is the\n    creation of the component structure.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        The graph to check whether is AT-free or not\n\n    Returns\n    -------\n    list or None\n        An asteroidal triple is returned as a list of nodes. If no asteroidal\n        triple exists, i.e. the graph is AT-free, then None is returned.\n        The returned value depends on the certificate parameter. The default\n        option is a bool which is True if the graph is AT-free, i.e. the\n        given graph contains no asteroidal triples, and False otherwise, i.e.\n        if the graph contains at least one asteroidal triple.\n\n    Notes\n    -----\n    The component structure and the algorithm is described in [1]_. The current\n    implementation implements the trivial algorithm for simple graphs.\n\n    References\n    ----------\n    .. [1] Ekkehard K\u00f6hler,\n       \"Recognizing Graphs without asteroidal triples\",\n       Journal of Discrete Algorithms 2, pages 439-452, 2004.\n       https://www.sciencedirect.com/science/article/pii/S157086670400019X\n    \"\"\"\n    V = set(G.nodes)\n    if len(V) < 6:\n        return None\n    component_structure = create_component_structure(G)\n    E_complement = set(nx.complement(G).edges)\n    for e in E_complement:\n        u = e[0]\n        v = e[1]\n        u_neighborhood = set(G[u]).union([u])\n        v_neighborhood = set(G[v]).union([v])\n        union_of_neighborhoods = u_neighborhood.union(v_neighborhood)\n        for w in V - union_of_neighborhoods:\n            if component_structure[u][v] == component_structure[u][w] and component_structure[v][u] == component_structure[v][w] and (component_structure[w][u] == component_structure[w][v]):\n                return [u, v, w]\n    return None",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef find_asteroidal_triple(G):\n    if False:\n        i = 10\n    'Find an asteroidal triple in the given graph.\\n\\n    An asteroidal triple is a triple of non-adjacent vertices such that\\n    there exists a path between any two of them which avoids the closed\\n    neighborhood of the third. It checks all independent triples of vertices\\n    and whether they are an asteroidal triple or not. This is done with the\\n    help of a data structure called a component structure.\\n    A component structure encodes information about which vertices belongs to\\n    the same connected component when the closed neighborhood of a given vertex\\n    is removed from the graph. The algorithm used to check is the trivial\\n    one, outlined in [1]_, which has a runtime of\\n    :math:`O(|V||\\\\overline{E} + |V||E|)`, where the second term is the\\n    creation of the component structure.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not\\n\\n    Returns\\n    -------\\n    list or None\\n        An asteroidal triple is returned as a list of nodes. If no asteroidal\\n        triple exists, i.e. the graph is AT-free, then None is returned.\\n        The returned value depends on the certificate parameter. The default\\n        option is a bool which is True if the graph is AT-free, i.e. the\\n        given graph contains no asteroidal triples, and False otherwise, i.e.\\n        if the graph contains at least one asteroidal triple.\\n\\n    Notes\\n    -----\\n    The component structure and the algorithm is described in [1]_. The current\\n    implementation implements the trivial algorithm for simple graphs.\\n\\n    References\\n    ----------\\n    .. [1] Ekkehard K\u00f6hler,\\n       \"Recognizing Graphs without asteroidal triples\",\\n       Journal of Discrete Algorithms 2, pages 439-452, 2004.\\n       https://www.sciencedirect.com/science/article/pii/S157086670400019X\\n    '\n    V = set(G.nodes)\n    if len(V) < 6:\n        return None\n    component_structure = create_component_structure(G)\n    E_complement = set(nx.complement(G).edges)\n    for e in E_complement:\n        u = e[0]\n        v = e[1]\n        u_neighborhood = set(G[u]).union([u])\n        v_neighborhood = set(G[v]).union([v])\n        union_of_neighborhoods = u_neighborhood.union(v_neighborhood)\n        for w in V - union_of_neighborhoods:\n            if component_structure[u][v] == component_structure[u][w] and component_structure[v][u] == component_structure[v][w] and (component_structure[w][u] == component_structure[w][v]):\n                return [u, v, w]\n    return None",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef find_asteroidal_triple(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find an asteroidal triple in the given graph.\\n\\n    An asteroidal triple is a triple of non-adjacent vertices such that\\n    there exists a path between any two of them which avoids the closed\\n    neighborhood of the third. It checks all independent triples of vertices\\n    and whether they are an asteroidal triple or not. This is done with the\\n    help of a data structure called a component structure.\\n    A component structure encodes information about which vertices belongs to\\n    the same connected component when the closed neighborhood of a given vertex\\n    is removed from the graph. The algorithm used to check is the trivial\\n    one, outlined in [1]_, which has a runtime of\\n    :math:`O(|V||\\\\overline{E} + |V||E|)`, where the second term is the\\n    creation of the component structure.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not\\n\\n    Returns\\n    -------\\n    list or None\\n        An asteroidal triple is returned as a list of nodes. If no asteroidal\\n        triple exists, i.e. the graph is AT-free, then None is returned.\\n        The returned value depends on the certificate parameter. The default\\n        option is a bool which is True if the graph is AT-free, i.e. the\\n        given graph contains no asteroidal triples, and False otherwise, i.e.\\n        if the graph contains at least one asteroidal triple.\\n\\n    Notes\\n    -----\\n    The component structure and the algorithm is described in [1]_. The current\\n    implementation implements the trivial algorithm for simple graphs.\\n\\n    References\\n    ----------\\n    .. [1] Ekkehard K\u00f6hler,\\n       \"Recognizing Graphs without asteroidal triples\",\\n       Journal of Discrete Algorithms 2, pages 439-452, 2004.\\n       https://www.sciencedirect.com/science/article/pii/S157086670400019X\\n    '\n    V = set(G.nodes)\n    if len(V) < 6:\n        return None\n    component_structure = create_component_structure(G)\n    E_complement = set(nx.complement(G).edges)\n    for e in E_complement:\n        u = e[0]\n        v = e[1]\n        u_neighborhood = set(G[u]).union([u])\n        v_neighborhood = set(G[v]).union([v])\n        union_of_neighborhoods = u_neighborhood.union(v_neighborhood)\n        for w in V - union_of_neighborhoods:\n            if component_structure[u][v] == component_structure[u][w] and component_structure[v][u] == component_structure[v][w] and (component_structure[w][u] == component_structure[w][v]):\n                return [u, v, w]\n    return None",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef find_asteroidal_triple(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find an asteroidal triple in the given graph.\\n\\n    An asteroidal triple is a triple of non-adjacent vertices such that\\n    there exists a path between any two of them which avoids the closed\\n    neighborhood of the third. It checks all independent triples of vertices\\n    and whether they are an asteroidal triple or not. This is done with the\\n    help of a data structure called a component structure.\\n    A component structure encodes information about which vertices belongs to\\n    the same connected component when the closed neighborhood of a given vertex\\n    is removed from the graph. The algorithm used to check is the trivial\\n    one, outlined in [1]_, which has a runtime of\\n    :math:`O(|V||\\\\overline{E} + |V||E|)`, where the second term is the\\n    creation of the component structure.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not\\n\\n    Returns\\n    -------\\n    list or None\\n        An asteroidal triple is returned as a list of nodes. If no asteroidal\\n        triple exists, i.e. the graph is AT-free, then None is returned.\\n        The returned value depends on the certificate parameter. The default\\n        option is a bool which is True if the graph is AT-free, i.e. the\\n        given graph contains no asteroidal triples, and False otherwise, i.e.\\n        if the graph contains at least one asteroidal triple.\\n\\n    Notes\\n    -----\\n    The component structure and the algorithm is described in [1]_. The current\\n    implementation implements the trivial algorithm for simple graphs.\\n\\n    References\\n    ----------\\n    .. [1] Ekkehard K\u00f6hler,\\n       \"Recognizing Graphs without asteroidal triples\",\\n       Journal of Discrete Algorithms 2, pages 439-452, 2004.\\n       https://www.sciencedirect.com/science/article/pii/S157086670400019X\\n    '\n    V = set(G.nodes)\n    if len(V) < 6:\n        return None\n    component_structure = create_component_structure(G)\n    E_complement = set(nx.complement(G).edges)\n    for e in E_complement:\n        u = e[0]\n        v = e[1]\n        u_neighborhood = set(G[u]).union([u])\n        v_neighborhood = set(G[v]).union([v])\n        union_of_neighborhoods = u_neighborhood.union(v_neighborhood)\n        for w in V - union_of_neighborhoods:\n            if component_structure[u][v] == component_structure[u][w] and component_structure[v][u] == component_structure[v][w] and (component_structure[w][u] == component_structure[w][v]):\n                return [u, v, w]\n    return None",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef find_asteroidal_triple(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find an asteroidal triple in the given graph.\\n\\n    An asteroidal triple is a triple of non-adjacent vertices such that\\n    there exists a path between any two of them which avoids the closed\\n    neighborhood of the third. It checks all independent triples of vertices\\n    and whether they are an asteroidal triple or not. This is done with the\\n    help of a data structure called a component structure.\\n    A component structure encodes information about which vertices belongs to\\n    the same connected component when the closed neighborhood of a given vertex\\n    is removed from the graph. The algorithm used to check is the trivial\\n    one, outlined in [1]_, which has a runtime of\\n    :math:`O(|V||\\\\overline{E} + |V||E|)`, where the second term is the\\n    creation of the component structure.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not\\n\\n    Returns\\n    -------\\n    list or None\\n        An asteroidal triple is returned as a list of nodes. If no asteroidal\\n        triple exists, i.e. the graph is AT-free, then None is returned.\\n        The returned value depends on the certificate parameter. The default\\n        option is a bool which is True if the graph is AT-free, i.e. the\\n        given graph contains no asteroidal triples, and False otherwise, i.e.\\n        if the graph contains at least one asteroidal triple.\\n\\n    Notes\\n    -----\\n    The component structure and the algorithm is described in [1]_. The current\\n    implementation implements the trivial algorithm for simple graphs.\\n\\n    References\\n    ----------\\n    .. [1] Ekkehard K\u00f6hler,\\n       \"Recognizing Graphs without asteroidal triples\",\\n       Journal of Discrete Algorithms 2, pages 439-452, 2004.\\n       https://www.sciencedirect.com/science/article/pii/S157086670400019X\\n    '\n    V = set(G.nodes)\n    if len(V) < 6:\n        return None\n    component_structure = create_component_structure(G)\n    E_complement = set(nx.complement(G).edges)\n    for e in E_complement:\n        u = e[0]\n        v = e[1]\n        u_neighborhood = set(G[u]).union([u])\n        v_neighborhood = set(G[v]).union([v])\n        union_of_neighborhoods = u_neighborhood.union(v_neighborhood)\n        for w in V - union_of_neighborhoods:\n            if component_structure[u][v] == component_structure[u][w] and component_structure[v][u] == component_structure[v][w] and (component_structure[w][u] == component_structure[w][v]):\n                return [u, v, w]\n    return None",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef find_asteroidal_triple(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find an asteroidal triple in the given graph.\\n\\n    An asteroidal triple is a triple of non-adjacent vertices such that\\n    there exists a path between any two of them which avoids the closed\\n    neighborhood of the third. It checks all independent triples of vertices\\n    and whether they are an asteroidal triple or not. This is done with the\\n    help of a data structure called a component structure.\\n    A component structure encodes information about which vertices belongs to\\n    the same connected component when the closed neighborhood of a given vertex\\n    is removed from the graph. The algorithm used to check is the trivial\\n    one, outlined in [1]_, which has a runtime of\\n    :math:`O(|V||\\\\overline{E} + |V||E|)`, where the second term is the\\n    creation of the component structure.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not\\n\\n    Returns\\n    -------\\n    list or None\\n        An asteroidal triple is returned as a list of nodes. If no asteroidal\\n        triple exists, i.e. the graph is AT-free, then None is returned.\\n        The returned value depends on the certificate parameter. The default\\n        option is a bool which is True if the graph is AT-free, i.e. the\\n        given graph contains no asteroidal triples, and False otherwise, i.e.\\n        if the graph contains at least one asteroidal triple.\\n\\n    Notes\\n    -----\\n    The component structure and the algorithm is described in [1]_. The current\\n    implementation implements the trivial algorithm for simple graphs.\\n\\n    References\\n    ----------\\n    .. [1] Ekkehard K\u00f6hler,\\n       \"Recognizing Graphs without asteroidal triples\",\\n       Journal of Discrete Algorithms 2, pages 439-452, 2004.\\n       https://www.sciencedirect.com/science/article/pii/S157086670400019X\\n    '\n    V = set(G.nodes)\n    if len(V) < 6:\n        return None\n    component_structure = create_component_structure(G)\n    E_complement = set(nx.complement(G).edges)\n    for e in E_complement:\n        u = e[0]\n        v = e[1]\n        u_neighborhood = set(G[u]).union([u])\n        v_neighborhood = set(G[v]).union([v])\n        union_of_neighborhoods = u_neighborhood.union(v_neighborhood)\n        for w in V - union_of_neighborhoods:\n            if component_structure[u][v] == component_structure[u][w] and component_structure[v][u] == component_structure[v][w] and (component_structure[w][u] == component_structure[w][v]):\n                return [u, v, w]\n    return None"
        ]
    },
    {
        "func_name": "is_at_free",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef is_at_free(G):\n    \"\"\"Check if a graph is AT-free.\n\n    The method uses the `find_asteroidal_triple` method to recognize\n    an AT-free graph. If no asteroidal triple is found the graph is\n    AT-free and True is returned. If at least one asteroidal triple is\n    found the graph is not AT-free and False is returned.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        The graph to check whether is AT-free or not.\n\n    Returns\n    -------\n    bool\n        True if G is AT-free and False otherwise.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\n    >>> nx.is_at_free(G)\n    True\n\n    >>> G = nx.cycle_graph(6)\n    >>> nx.is_at_free(G)\n    False\n    \"\"\"\n    return find_asteroidal_triple(G) is None",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef is_at_free(G):\n    if False:\n        i = 10\n    'Check if a graph is AT-free.\\n\\n    The method uses the `find_asteroidal_triple` method to recognize\\n    an AT-free graph. If no asteroidal triple is found the graph is\\n    AT-free and True is returned. If at least one asteroidal triple is\\n    found the graph is not AT-free and False is returned.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not.\\n\\n    Returns\\n    -------\\n    bool\\n        True if G is AT-free and False otherwise.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\\n    >>> nx.is_at_free(G)\\n    True\\n\\n    >>> G = nx.cycle_graph(6)\\n    >>> nx.is_at_free(G)\\n    False\\n    '\n    return find_asteroidal_triple(G) is None",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef is_at_free(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check if a graph is AT-free.\\n\\n    The method uses the `find_asteroidal_triple` method to recognize\\n    an AT-free graph. If no asteroidal triple is found the graph is\\n    AT-free and True is returned. If at least one asteroidal triple is\\n    found the graph is not AT-free and False is returned.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not.\\n\\n    Returns\\n    -------\\n    bool\\n        True if G is AT-free and False otherwise.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\\n    >>> nx.is_at_free(G)\\n    True\\n\\n    >>> G = nx.cycle_graph(6)\\n    >>> nx.is_at_free(G)\\n    False\\n    '\n    return find_asteroidal_triple(G) is None",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef is_at_free(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check if a graph is AT-free.\\n\\n    The method uses the `find_asteroidal_triple` method to recognize\\n    an AT-free graph. If no asteroidal triple is found the graph is\\n    AT-free and True is returned. If at least one asteroidal triple is\\n    found the graph is not AT-free and False is returned.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not.\\n\\n    Returns\\n    -------\\n    bool\\n        True if G is AT-free and False otherwise.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\\n    >>> nx.is_at_free(G)\\n    True\\n\\n    >>> G = nx.cycle_graph(6)\\n    >>> nx.is_at_free(G)\\n    False\\n    '\n    return find_asteroidal_triple(G) is None",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef is_at_free(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check if a graph is AT-free.\\n\\n    The method uses the `find_asteroidal_triple` method to recognize\\n    an AT-free graph. If no asteroidal triple is found the graph is\\n    AT-free and True is returned. If at least one asteroidal triple is\\n    found the graph is not AT-free and False is returned.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not.\\n\\n    Returns\\n    -------\\n    bool\\n        True if G is AT-free and False otherwise.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\\n    >>> nx.is_at_free(G)\\n    True\\n\\n    >>> G = nx.cycle_graph(6)\\n    >>> nx.is_at_free(G)\\n    False\\n    '\n    return find_asteroidal_triple(G) is None",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef is_at_free(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check if a graph is AT-free.\\n\\n    The method uses the `find_asteroidal_triple` method to recognize\\n    an AT-free graph. If no asteroidal triple is found the graph is\\n    AT-free and True is returned. If at least one asteroidal triple is\\n    found the graph is not AT-free and False is returned.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        The graph to check whether is AT-free or not.\\n\\n    Returns\\n    -------\\n    bool\\n        True if G is AT-free and False otherwise.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\\n    >>> nx.is_at_free(G)\\n    True\\n\\n    >>> G = nx.cycle_graph(6)\\n    >>> nx.is_at_free(G)\\n    False\\n    '\n    return find_asteroidal_triple(G) is None"
        ]
    },
    {
        "func_name": "create_component_structure",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef create_component_structure(G):\n    \"\"\"Create component structure for G.\n\n    A *component structure* is an `nxn` array, denoted `c`, where `n` is\n    the number of vertices,  where each row and column corresponds to a vertex.\n\n    .. math::\n        c_{uv} = \\\\begin{cases} 0, if v \\\\in N[u] \\\\\\\\\n            k, if v \\\\in component k of G \\\\setminus N[u] \\\\end{cases}\n\n    Where `k` is an arbitrary label for each component. The structure is used\n    to simplify the detection of asteroidal triples.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        Undirected, simple graph.\n\n    Returns\n    -------\n    component_structure : dictionary\n        A dictionary of dictionaries, keyed by pairs of vertices.\n\n    \"\"\"\n    V = set(G.nodes)\n    component_structure = {}\n    for v in V:\n        label = 0\n        closed_neighborhood = set(G[v]).union({v})\n        row_dict = {}\n        for u in closed_neighborhood:\n            row_dict[u] = 0\n        G_reduced = G.subgraph(set(G.nodes) - closed_neighborhood)\n        for cc in nx.connected_components(G_reduced):\n            label += 1\n            for u in cc:\n                row_dict[u] = label\n        component_structure[v] = row_dict\n    return component_structure",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef create_component_structure(G):\n    if False:\n        i = 10\n    'Create component structure for G.\\n\\n    A *component structure* is an `nxn` array, denoted `c`, where `n` is\\n    the number of vertices,  where each row and column corresponds to a vertex.\\n\\n    .. math::\\n        c_{uv} = \\\\begin{cases} 0, if v \\\\in N[u] \\\\\\\\\\n            k, if v \\\\in component k of G \\\\setminus N[u] \\\\end{cases}\\n\\n    Where `k` is an arbitrary label for each component. The structure is used\\n    to simplify the detection of asteroidal triples.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        Undirected, simple graph.\\n\\n    Returns\\n    -------\\n    component_structure : dictionary\\n        A dictionary of dictionaries, keyed by pairs of vertices.\\n\\n    '\n    V = set(G.nodes)\n    component_structure = {}\n    for v in V:\n        label = 0\n        closed_neighborhood = set(G[v]).union({v})\n        row_dict = {}\n        for u in closed_neighborhood:\n            row_dict[u] = 0\n        G_reduced = G.subgraph(set(G.nodes) - closed_neighborhood)\n        for cc in nx.connected_components(G_reduced):\n            label += 1\n            for u in cc:\n                row_dict[u] = label\n        component_structure[v] = row_dict\n    return component_structure",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef create_component_structure(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create component structure for G.\\n\\n    A *component structure* is an `nxn` array, denoted `c`, where `n` is\\n    the number of vertices,  where each row and column corresponds to a vertex.\\n\\n    .. math::\\n        c_{uv} = \\\\begin{cases} 0, if v \\\\in N[u] \\\\\\\\\\n            k, if v \\\\in component k of G \\\\setminus N[u] \\\\end{cases}\\n\\n    Where `k` is an arbitrary label for each component. The structure is used\\n    to simplify the detection of asteroidal triples.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        Undirected, simple graph.\\n\\n    Returns\\n    -------\\n    component_structure : dictionary\\n        A dictionary of dictionaries, keyed by pairs of vertices.\\n\\n    '\n    V = set(G.nodes)\n    component_structure = {}\n    for v in V:\n        label = 0\n        closed_neighborhood = set(G[v]).union({v})\n        row_dict = {}\n        for u in closed_neighborhood:\n            row_dict[u] = 0\n        G_reduced = G.subgraph(set(G.nodes) - closed_neighborhood)\n        for cc in nx.connected_components(G_reduced):\n            label += 1\n            for u in cc:\n                row_dict[u] = label\n        component_structure[v] = row_dict\n    return component_structure",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef create_component_structure(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create component structure for G.\\n\\n    A *component structure* is an `nxn` array, denoted `c`, where `n` is\\n    the number of vertices,  where each row and column corresponds to a vertex.\\n\\n    .. math::\\n        c_{uv} = \\\\begin{cases} 0, if v \\\\in N[u] \\\\\\\\\\n            k, if v \\\\in component k of G \\\\setminus N[u] \\\\end{cases}\\n\\n    Where `k` is an arbitrary label for each component. The structure is used\\n    to simplify the detection of asteroidal triples.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        Undirected, simple graph.\\n\\n    Returns\\n    -------\\n    component_structure : dictionary\\n        A dictionary of dictionaries, keyed by pairs of vertices.\\n\\n    '\n    V = set(G.nodes)\n    component_structure = {}\n    for v in V:\n        label = 0\n        closed_neighborhood = set(G[v]).union({v})\n        row_dict = {}\n        for u in closed_neighborhood:\n            row_dict[u] = 0\n        G_reduced = G.subgraph(set(G.nodes) - closed_neighborhood)\n        for cc in nx.connected_components(G_reduced):\n            label += 1\n            for u in cc:\n                row_dict[u] = label\n        component_structure[v] = row_dict\n    return component_structure",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef create_component_structure(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create component structure for G.\\n\\n    A *component structure* is an `nxn` array, denoted `c`, where `n` is\\n    the number of vertices,  where each row and column corresponds to a vertex.\\n\\n    .. math::\\n        c_{uv} = \\\\begin{cases} 0, if v \\\\in N[u] \\\\\\\\\\n            k, if v \\\\in component k of G \\\\setminus N[u] \\\\end{cases}\\n\\n    Where `k` is an arbitrary label for each component. The structure is used\\n    to simplify the detection of asteroidal triples.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        Undirected, simple graph.\\n\\n    Returns\\n    -------\\n    component_structure : dictionary\\n        A dictionary of dictionaries, keyed by pairs of vertices.\\n\\n    '\n    V = set(G.nodes)\n    component_structure = {}\n    for v in V:\n        label = 0\n        closed_neighborhood = set(G[v]).union({v})\n        row_dict = {}\n        for u in closed_neighborhood:\n            row_dict[u] = 0\n        G_reduced = G.subgraph(set(G.nodes) - closed_neighborhood)\n        for cc in nx.connected_components(G_reduced):\n            label += 1\n            for u in cc:\n                row_dict[u] = label\n        component_structure[v] = row_dict\n    return component_structure",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef create_component_structure(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create component structure for G.\\n\\n    A *component structure* is an `nxn` array, denoted `c`, where `n` is\\n    the number of vertices,  where each row and column corresponds to a vertex.\\n\\n    .. math::\\n        c_{uv} = \\\\begin{cases} 0, if v \\\\in N[u] \\\\\\\\\\n            k, if v \\\\in component k of G \\\\setminus N[u] \\\\end{cases}\\n\\n    Where `k` is an arbitrary label for each component. The structure is used\\n    to simplify the detection of asteroidal triples.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        Undirected, simple graph.\\n\\n    Returns\\n    -------\\n    component_structure : dictionary\\n        A dictionary of dictionaries, keyed by pairs of vertices.\\n\\n    '\n    V = set(G.nodes)\n    component_structure = {}\n    for v in V:\n        label = 0\n        closed_neighborhood = set(G[v]).union({v})\n        row_dict = {}\n        for u in closed_neighborhood:\n            row_dict[u] = 0\n        G_reduced = G.subgraph(set(G.nodes) - closed_neighborhood)\n        for cc in nx.connected_components(G_reduced):\n            label += 1\n            for u in cc:\n                row_dict[u] = label\n        component_structure[v] = row_dict\n    return component_structure"
        ]
    }
]