[
    {
        "func_name": "_opt_common_mu",
        "original": "def _opt_common_mu(self, mu):\n    \"\"\"\n        Optimizes the likelihood under the null hypothesis that all groups have\n        mean mu.\n\n        Parameters\n        ----------\n        mu : float\n            The common mean.\n\n        Returns\n        -------\n        llr : float\n            -2 times the llr ratio, which is the test statistic.\n        \"\"\"\n    nobs = self.nobs\n    endog = self.endog\n    num_groups = self.num_groups\n    endog_asarray = np.zeros((nobs, num_groups))\n    obs_num = 0\n    for arr_num in range(len(endog)):\n        new_obs_num = obs_num + len(endog[arr_num])\n        endog_asarray[obs_num:new_obs_num, arr_num] = endog[arr_num] - mu\n        obs_num = new_obs_num\n    est_vect = endog_asarray\n    wts = np.ones(est_vect.shape[0]) * (1.0 / est_vect.shape[0])\n    eta_star = self._modif_newton(np.zeros(num_groups), est_vect, wts)\n    denom = 1.0 + np.dot(eta_star, est_vect.T)\n    self.new_weights = 1.0 / nobs * 1.0 / denom\n    llr = np.sum(np.log(nobs * self.new_weights))\n    return -2 * llr",
        "mutated": [
            "def _opt_common_mu(self, mu):\n    if False:\n        i = 10\n    '\\n        Optimizes the likelihood under the null hypothesis that all groups have\\n        mean mu.\\n\\n        Parameters\\n        ----------\\n        mu : float\\n            The common mean.\\n\\n        Returns\\n        -------\\n        llr : float\\n            -2 times the llr ratio, which is the test statistic.\\n        '\n    nobs = self.nobs\n    endog = self.endog\n    num_groups = self.num_groups\n    endog_asarray = np.zeros((nobs, num_groups))\n    obs_num = 0\n    for arr_num in range(len(endog)):\n        new_obs_num = obs_num + len(endog[arr_num])\n        endog_asarray[obs_num:new_obs_num, arr_num] = endog[arr_num] - mu\n        obs_num = new_obs_num\n    est_vect = endog_asarray\n    wts = np.ones(est_vect.shape[0]) * (1.0 / est_vect.shape[0])\n    eta_star = self._modif_newton(np.zeros(num_groups), est_vect, wts)\n    denom = 1.0 + np.dot(eta_star, est_vect.T)\n    self.new_weights = 1.0 / nobs * 1.0 / denom\n    llr = np.sum(np.log(nobs * self.new_weights))\n    return -2 * llr",
            "def _opt_common_mu(self, mu):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Optimizes the likelihood under the null hypothesis that all groups have\\n        mean mu.\\n\\n        Parameters\\n        ----------\\n        mu : float\\n            The common mean.\\n\\n        Returns\\n        -------\\n        llr : float\\n            -2 times the llr ratio, which is the test statistic.\\n        '\n    nobs = self.nobs\n    endog = self.endog\n    num_groups = self.num_groups\n    endog_asarray = np.zeros((nobs, num_groups))\n    obs_num = 0\n    for arr_num in range(len(endog)):\n        new_obs_num = obs_num + len(endog[arr_num])\n        endog_asarray[obs_num:new_obs_num, arr_num] = endog[arr_num] - mu\n        obs_num = new_obs_num\n    est_vect = endog_asarray\n    wts = np.ones(est_vect.shape[0]) * (1.0 / est_vect.shape[0])\n    eta_star = self._modif_newton(np.zeros(num_groups), est_vect, wts)\n    denom = 1.0 + np.dot(eta_star, est_vect.T)\n    self.new_weights = 1.0 / nobs * 1.0 / denom\n    llr = np.sum(np.log(nobs * self.new_weights))\n    return -2 * llr",
            "def _opt_common_mu(self, mu):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Optimizes the likelihood under the null hypothesis that all groups have\\n        mean mu.\\n\\n        Parameters\\n        ----------\\n        mu : float\\n            The common mean.\\n\\n        Returns\\n        -------\\n        llr : float\\n            -2 times the llr ratio, which is the test statistic.\\n        '\n    nobs = self.nobs\n    endog = self.endog\n    num_groups = self.num_groups\n    endog_asarray = np.zeros((nobs, num_groups))\n    obs_num = 0\n    for arr_num in range(len(endog)):\n        new_obs_num = obs_num + len(endog[arr_num])\n        endog_asarray[obs_num:new_obs_num, arr_num] = endog[arr_num] - mu\n        obs_num = new_obs_num\n    est_vect = endog_asarray\n    wts = np.ones(est_vect.shape[0]) * (1.0 / est_vect.shape[0])\n    eta_star = self._modif_newton(np.zeros(num_groups), est_vect, wts)\n    denom = 1.0 + np.dot(eta_star, est_vect.T)\n    self.new_weights = 1.0 / nobs * 1.0 / denom\n    llr = np.sum(np.log(nobs * self.new_weights))\n    return -2 * llr",
            "def _opt_common_mu(self, mu):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Optimizes the likelihood under the null hypothesis that all groups have\\n        mean mu.\\n\\n        Parameters\\n        ----------\\n        mu : float\\n            The common mean.\\n\\n        Returns\\n        -------\\n        llr : float\\n            -2 times the llr ratio, which is the test statistic.\\n        '\n    nobs = self.nobs\n    endog = self.endog\n    num_groups = self.num_groups\n    endog_asarray = np.zeros((nobs, num_groups))\n    obs_num = 0\n    for arr_num in range(len(endog)):\n        new_obs_num = obs_num + len(endog[arr_num])\n        endog_asarray[obs_num:new_obs_num, arr_num] = endog[arr_num] - mu\n        obs_num = new_obs_num\n    est_vect = endog_asarray\n    wts = np.ones(est_vect.shape[0]) * (1.0 / est_vect.shape[0])\n    eta_star = self._modif_newton(np.zeros(num_groups), est_vect, wts)\n    denom = 1.0 + np.dot(eta_star, est_vect.T)\n    self.new_weights = 1.0 / nobs * 1.0 / denom\n    llr = np.sum(np.log(nobs * self.new_weights))\n    return -2 * llr",
            "def _opt_common_mu(self, mu):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Optimizes the likelihood under the null hypothesis that all groups have\\n        mean mu.\\n\\n        Parameters\\n        ----------\\n        mu : float\\n            The common mean.\\n\\n        Returns\\n        -------\\n        llr : float\\n            -2 times the llr ratio, which is the test statistic.\\n        '\n    nobs = self.nobs\n    endog = self.endog\n    num_groups = self.num_groups\n    endog_asarray = np.zeros((nobs, num_groups))\n    obs_num = 0\n    for arr_num in range(len(endog)):\n        new_obs_num = obs_num + len(endog[arr_num])\n        endog_asarray[obs_num:new_obs_num, arr_num] = endog[arr_num] - mu\n        obs_num = new_obs_num\n    est_vect = endog_asarray\n    wts = np.ones(est_vect.shape[0]) * (1.0 / est_vect.shape[0])\n    eta_star = self._modif_newton(np.zeros(num_groups), est_vect, wts)\n    denom = 1.0 + np.dot(eta_star, est_vect.T)\n    self.new_weights = 1.0 / nobs * 1.0 / denom\n    llr = np.sum(np.log(nobs * self.new_weights))\n    return -2 * llr"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog):\n    self.endog = endog\n    self.num_groups = len(self.endog)\n    self.nobs = 0\n    for i in self.endog:\n        self.nobs = self.nobs + len(i)",
        "mutated": [
            "def __init__(self, endog):\n    if False:\n        i = 10\n    self.endog = endog\n    self.num_groups = len(self.endog)\n    self.nobs = 0\n    for i in self.endog:\n        self.nobs = self.nobs + len(i)",
            "def __init__(self, endog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.endog = endog\n    self.num_groups = len(self.endog)\n    self.nobs = 0\n    for i in self.endog:\n        self.nobs = self.nobs + len(i)",
            "def __init__(self, endog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.endog = endog\n    self.num_groups = len(self.endog)\n    self.nobs = 0\n    for i in self.endog:\n        self.nobs = self.nobs + len(i)",
            "def __init__(self, endog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.endog = endog\n    self.num_groups = len(self.endog)\n    self.nobs = 0\n    for i in self.endog:\n        self.nobs = self.nobs + len(i)",
            "def __init__(self, endog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.endog = endog\n    self.num_groups = len(self.endog)\n    self.nobs = 0\n    for i in self.endog:\n        self.nobs = self.nobs + len(i)"
        ]
    },
    {
        "func_name": "compute_ANOVA",
        "original": "def compute_ANOVA(self, mu=None, mu_start=0, return_weights=0):\n    \"\"\"\n        Returns -2 log likelihood, the pvalue and the maximum likelihood\n        estimate for a common mean.\n\n        Parameters\n        ----------\n\n        mu : float\n            If a mu is specified, ANOVA is conducted with mu as the\n            common mean.  Otherwise, the common mean is the maximum\n            empirical likelihood estimate of the common mean.\n            Default is None.\n\n        mu_start : float\n            Starting value for commean mean if specific mu is not specified.\n            Default = 0.\n\n        return_weights : bool\n            if TRUE, returns the weights on observations that maximize the\n            likelihood.  Default is FALSE.\n\n        Returns\n        -------\n\n        res: tuple\n            The log-likelihood, p-value and estimate for the common mean.\n        \"\"\"\n    if mu is not None:\n        llr = self._opt_common_mu(mu)\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu, self.new_weights)\n        else:\n            return (llr, pval, mu)\n    else:\n        res = optimize.fmin_powell(self._opt_common_mu, mu_start, full_output=1, disp=False)\n        llr = res[1]\n        mu_common = float(np.squeeze(res[0]))\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu_common, self.new_weights)\n        else:\n            return (llr, pval, mu_common)",
        "mutated": [
            "def compute_ANOVA(self, mu=None, mu_start=0, return_weights=0):\n    if False:\n        i = 10\n    '\\n        Returns -2 log likelihood, the pvalue and the maximum likelihood\\n        estimate for a common mean.\\n\\n        Parameters\\n        ----------\\n\\n        mu : float\\n            If a mu is specified, ANOVA is conducted with mu as the\\n            common mean.  Otherwise, the common mean is the maximum\\n            empirical likelihood estimate of the common mean.\\n            Default is None.\\n\\n        mu_start : float\\n            Starting value for commean mean if specific mu is not specified.\\n            Default = 0.\\n\\n        return_weights : bool\\n            if TRUE, returns the weights on observations that maximize the\\n            likelihood.  Default is FALSE.\\n\\n        Returns\\n        -------\\n\\n        res: tuple\\n            The log-likelihood, p-value and estimate for the common mean.\\n        '\n    if mu is not None:\n        llr = self._opt_common_mu(mu)\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu, self.new_weights)\n        else:\n            return (llr, pval, mu)\n    else:\n        res = optimize.fmin_powell(self._opt_common_mu, mu_start, full_output=1, disp=False)\n        llr = res[1]\n        mu_common = float(np.squeeze(res[0]))\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu_common, self.new_weights)\n        else:\n            return (llr, pval, mu_common)",
            "def compute_ANOVA(self, mu=None, mu_start=0, return_weights=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns -2 log likelihood, the pvalue and the maximum likelihood\\n        estimate for a common mean.\\n\\n        Parameters\\n        ----------\\n\\n        mu : float\\n            If a mu is specified, ANOVA is conducted with mu as the\\n            common mean.  Otherwise, the common mean is the maximum\\n            empirical likelihood estimate of the common mean.\\n            Default is None.\\n\\n        mu_start : float\\n            Starting value for commean mean if specific mu is not specified.\\n            Default = 0.\\n\\n        return_weights : bool\\n            if TRUE, returns the weights on observations that maximize the\\n            likelihood.  Default is FALSE.\\n\\n        Returns\\n        -------\\n\\n        res: tuple\\n            The log-likelihood, p-value and estimate for the common mean.\\n        '\n    if mu is not None:\n        llr = self._opt_common_mu(mu)\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu, self.new_weights)\n        else:\n            return (llr, pval, mu)\n    else:\n        res = optimize.fmin_powell(self._opt_common_mu, mu_start, full_output=1, disp=False)\n        llr = res[1]\n        mu_common = float(np.squeeze(res[0]))\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu_common, self.new_weights)\n        else:\n            return (llr, pval, mu_common)",
            "def compute_ANOVA(self, mu=None, mu_start=0, return_weights=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns -2 log likelihood, the pvalue and the maximum likelihood\\n        estimate for a common mean.\\n\\n        Parameters\\n        ----------\\n\\n        mu : float\\n            If a mu is specified, ANOVA is conducted with mu as the\\n            common mean.  Otherwise, the common mean is the maximum\\n            empirical likelihood estimate of the common mean.\\n            Default is None.\\n\\n        mu_start : float\\n            Starting value for commean mean if specific mu is not specified.\\n            Default = 0.\\n\\n        return_weights : bool\\n            if TRUE, returns the weights on observations that maximize the\\n            likelihood.  Default is FALSE.\\n\\n        Returns\\n        -------\\n\\n        res: tuple\\n            The log-likelihood, p-value and estimate for the common mean.\\n        '\n    if mu is not None:\n        llr = self._opt_common_mu(mu)\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu, self.new_weights)\n        else:\n            return (llr, pval, mu)\n    else:\n        res = optimize.fmin_powell(self._opt_common_mu, mu_start, full_output=1, disp=False)\n        llr = res[1]\n        mu_common = float(np.squeeze(res[0]))\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu_common, self.new_weights)\n        else:\n            return (llr, pval, mu_common)",
            "def compute_ANOVA(self, mu=None, mu_start=0, return_weights=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns -2 log likelihood, the pvalue and the maximum likelihood\\n        estimate for a common mean.\\n\\n        Parameters\\n        ----------\\n\\n        mu : float\\n            If a mu is specified, ANOVA is conducted with mu as the\\n            common mean.  Otherwise, the common mean is the maximum\\n            empirical likelihood estimate of the common mean.\\n            Default is None.\\n\\n        mu_start : float\\n            Starting value for commean mean if specific mu is not specified.\\n            Default = 0.\\n\\n        return_weights : bool\\n            if TRUE, returns the weights on observations that maximize the\\n            likelihood.  Default is FALSE.\\n\\n        Returns\\n        -------\\n\\n        res: tuple\\n            The log-likelihood, p-value and estimate for the common mean.\\n        '\n    if mu is not None:\n        llr = self._opt_common_mu(mu)\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu, self.new_weights)\n        else:\n            return (llr, pval, mu)\n    else:\n        res = optimize.fmin_powell(self._opt_common_mu, mu_start, full_output=1, disp=False)\n        llr = res[1]\n        mu_common = float(np.squeeze(res[0]))\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu_common, self.new_weights)\n        else:\n            return (llr, pval, mu_common)",
            "def compute_ANOVA(self, mu=None, mu_start=0, return_weights=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns -2 log likelihood, the pvalue and the maximum likelihood\\n        estimate for a common mean.\\n\\n        Parameters\\n        ----------\\n\\n        mu : float\\n            If a mu is specified, ANOVA is conducted with mu as the\\n            common mean.  Otherwise, the common mean is the maximum\\n            empirical likelihood estimate of the common mean.\\n            Default is None.\\n\\n        mu_start : float\\n            Starting value for commean mean if specific mu is not specified.\\n            Default = 0.\\n\\n        return_weights : bool\\n            if TRUE, returns the weights on observations that maximize the\\n            likelihood.  Default is FALSE.\\n\\n        Returns\\n        -------\\n\\n        res: tuple\\n            The log-likelihood, p-value and estimate for the common mean.\\n        '\n    if mu is not None:\n        llr = self._opt_common_mu(mu)\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu, self.new_weights)\n        else:\n            return (llr, pval, mu)\n    else:\n        res = optimize.fmin_powell(self._opt_common_mu, mu_start, full_output=1, disp=False)\n        llr = res[1]\n        mu_common = float(np.squeeze(res[0]))\n        pval = 1 - chi2.cdf(llr, self.num_groups - 1)\n        if return_weights:\n            return (llr, pval, mu_common, self.new_weights)\n        else:\n            return (llr, pval, mu_common)"
        ]
    }
]