[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_in_ch=3, num_out_ch=3, ngf=64):\n    \"\"\"Defines a video deinterlace module.\n           input a [b,c,h,w] tensor with range [0,1] as frame,\n           it will output a [b,c,h,w] tensor with range [0,1] whitout interlace.\n\n        Args:\n            num_in_ch (int): Channel number of inputs. Default: 3.\n            num_out_ch (int): Channel number of outputs. Default: 3.\n            ngf(int): Channel number of features. Default: 64.\n        \"\"\"\n    super(DeinterlaceFre, self).__init__()\n    self.inconv = DoubleConv(num_in_ch, 48)\n    self.down_0 = DownConv(48, 80)\n    self.down_1 = DownConv(80, 144)\n    self.opfre_0 = freup_Periodicpadding(80)\n    self.opfre_1 = freup_Periodicpadding(144)\n    self.conv_up1 = nn.Conv2d(80, ngf, 3, 1, 1)\n    self.conv_up2 = nn.Conv2d(144, 80, 3, 1, 1)\n    self.conv_hr = nn.Conv2d(ngf, ngf, 3, 1, 1)\n    self.conv_last = nn.Conv2d(ngf, num_out_ch, 3, 1, 1)\n    self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True)\n    self.enh_inconv = DoubleConv(num_in_ch + num_out_ch, 48)\n    self.enh_down_0 = DownConv(48, 80)\n    self.enh_down_1 = DownConv(80, 144)\n    self.enh_down_2 = DownConv(144, 256)\n    self.enh_down_3 = DownConv(256, 448, num_conv=3)\n    self.enh_up_3 = UpCatConv(704, 256)\n    self.enh_up_2 = UpCatConv(400, 144)\n    self.enh_up_1 = UpCatConv(224, 80)\n    self.enh_up_0 = UpCatConv(128, 48)\n    self.enh_outconv = nn.Conv2d(48, num_out_ch, 3, 1, 1, bias=False)",
        "mutated": [
            "def __init__(self, num_in_ch=3, num_out_ch=3, ngf=64):\n    if False:\n        i = 10\n    'Defines a video deinterlace module.\\n           input a [b,c,h,w] tensor with range [0,1] as frame,\\n           it will output a [b,c,h,w] tensor with range [0,1] whitout interlace.\\n\\n        Args:\\n            num_in_ch (int): Channel number of inputs. Default: 3.\\n            num_out_ch (int): Channel number of outputs. Default: 3.\\n            ngf(int): Channel number of features. Default: 64.\\n        '\n    super(DeinterlaceFre, self).__init__()\n    self.inconv = DoubleConv(num_in_ch, 48)\n    self.down_0 = DownConv(48, 80)\n    self.down_1 = DownConv(80, 144)\n    self.opfre_0 = freup_Periodicpadding(80)\n    self.opfre_1 = freup_Periodicpadding(144)\n    self.conv_up1 = nn.Conv2d(80, ngf, 3, 1, 1)\n    self.conv_up2 = nn.Conv2d(144, 80, 3, 1, 1)\n    self.conv_hr = nn.Conv2d(ngf, ngf, 3, 1, 1)\n    self.conv_last = nn.Conv2d(ngf, num_out_ch, 3, 1, 1)\n    self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True)\n    self.enh_inconv = DoubleConv(num_in_ch + num_out_ch, 48)\n    self.enh_down_0 = DownConv(48, 80)\n    self.enh_down_1 = DownConv(80, 144)\n    self.enh_down_2 = DownConv(144, 256)\n    self.enh_down_3 = DownConv(256, 448, num_conv=3)\n    self.enh_up_3 = UpCatConv(704, 256)\n    self.enh_up_2 = UpCatConv(400, 144)\n    self.enh_up_1 = UpCatConv(224, 80)\n    self.enh_up_0 = UpCatConv(128, 48)\n    self.enh_outconv = nn.Conv2d(48, num_out_ch, 3, 1, 1, bias=False)",
            "def __init__(self, num_in_ch=3, num_out_ch=3, ngf=64):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Defines a video deinterlace module.\\n           input a [b,c,h,w] tensor with range [0,1] as frame,\\n           it will output a [b,c,h,w] tensor with range [0,1] whitout interlace.\\n\\n        Args:\\n            num_in_ch (int): Channel number of inputs. Default: 3.\\n            num_out_ch (int): Channel number of outputs. Default: 3.\\n            ngf(int): Channel number of features. Default: 64.\\n        '\n    super(DeinterlaceFre, self).__init__()\n    self.inconv = DoubleConv(num_in_ch, 48)\n    self.down_0 = DownConv(48, 80)\n    self.down_1 = DownConv(80, 144)\n    self.opfre_0 = freup_Periodicpadding(80)\n    self.opfre_1 = freup_Periodicpadding(144)\n    self.conv_up1 = nn.Conv2d(80, ngf, 3, 1, 1)\n    self.conv_up2 = nn.Conv2d(144, 80, 3, 1, 1)\n    self.conv_hr = nn.Conv2d(ngf, ngf, 3, 1, 1)\n    self.conv_last = nn.Conv2d(ngf, num_out_ch, 3, 1, 1)\n    self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True)\n    self.enh_inconv = DoubleConv(num_in_ch + num_out_ch, 48)\n    self.enh_down_0 = DownConv(48, 80)\n    self.enh_down_1 = DownConv(80, 144)\n    self.enh_down_2 = DownConv(144, 256)\n    self.enh_down_3 = DownConv(256, 448, num_conv=3)\n    self.enh_up_3 = UpCatConv(704, 256)\n    self.enh_up_2 = UpCatConv(400, 144)\n    self.enh_up_1 = UpCatConv(224, 80)\n    self.enh_up_0 = UpCatConv(128, 48)\n    self.enh_outconv = nn.Conv2d(48, num_out_ch, 3, 1, 1, bias=False)",
            "def __init__(self, num_in_ch=3, num_out_ch=3, ngf=64):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Defines a video deinterlace module.\\n           input a [b,c,h,w] tensor with range [0,1] as frame,\\n           it will output a [b,c,h,w] tensor with range [0,1] whitout interlace.\\n\\n        Args:\\n            num_in_ch (int): Channel number of inputs. Default: 3.\\n            num_out_ch (int): Channel number of outputs. Default: 3.\\n            ngf(int): Channel number of features. Default: 64.\\n        '\n    super(DeinterlaceFre, self).__init__()\n    self.inconv = DoubleConv(num_in_ch, 48)\n    self.down_0 = DownConv(48, 80)\n    self.down_1 = DownConv(80, 144)\n    self.opfre_0 = freup_Periodicpadding(80)\n    self.opfre_1 = freup_Periodicpadding(144)\n    self.conv_up1 = nn.Conv2d(80, ngf, 3, 1, 1)\n    self.conv_up2 = nn.Conv2d(144, 80, 3, 1, 1)\n    self.conv_hr = nn.Conv2d(ngf, ngf, 3, 1, 1)\n    self.conv_last = nn.Conv2d(ngf, num_out_ch, 3, 1, 1)\n    self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True)\n    self.enh_inconv = DoubleConv(num_in_ch + num_out_ch, 48)\n    self.enh_down_0 = DownConv(48, 80)\n    self.enh_down_1 = DownConv(80, 144)\n    self.enh_down_2 = DownConv(144, 256)\n    self.enh_down_3 = DownConv(256, 448, num_conv=3)\n    self.enh_up_3 = UpCatConv(704, 256)\n    self.enh_up_2 = UpCatConv(400, 144)\n    self.enh_up_1 = UpCatConv(224, 80)\n    self.enh_up_0 = UpCatConv(128, 48)\n    self.enh_outconv = nn.Conv2d(48, num_out_ch, 3, 1, 1, bias=False)",
            "def __init__(self, num_in_ch=3, num_out_ch=3, ngf=64):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Defines a video deinterlace module.\\n           input a [b,c,h,w] tensor with range [0,1] as frame,\\n           it will output a [b,c,h,w] tensor with range [0,1] whitout interlace.\\n\\n        Args:\\n            num_in_ch (int): Channel number of inputs. Default: 3.\\n            num_out_ch (int): Channel number of outputs. Default: 3.\\n            ngf(int): Channel number of features. Default: 64.\\n        '\n    super(DeinterlaceFre, self).__init__()\n    self.inconv = DoubleConv(num_in_ch, 48)\n    self.down_0 = DownConv(48, 80)\n    self.down_1 = DownConv(80, 144)\n    self.opfre_0 = freup_Periodicpadding(80)\n    self.opfre_1 = freup_Periodicpadding(144)\n    self.conv_up1 = nn.Conv2d(80, ngf, 3, 1, 1)\n    self.conv_up2 = nn.Conv2d(144, 80, 3, 1, 1)\n    self.conv_hr = nn.Conv2d(ngf, ngf, 3, 1, 1)\n    self.conv_last = nn.Conv2d(ngf, num_out_ch, 3, 1, 1)\n    self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True)\n    self.enh_inconv = DoubleConv(num_in_ch + num_out_ch, 48)\n    self.enh_down_0 = DownConv(48, 80)\n    self.enh_down_1 = DownConv(80, 144)\n    self.enh_down_2 = DownConv(144, 256)\n    self.enh_down_3 = DownConv(256, 448, num_conv=3)\n    self.enh_up_3 = UpCatConv(704, 256)\n    self.enh_up_2 = UpCatConv(400, 144)\n    self.enh_up_1 = UpCatConv(224, 80)\n    self.enh_up_0 = UpCatConv(128, 48)\n    self.enh_outconv = nn.Conv2d(48, num_out_ch, 3, 1, 1, bias=False)",
            "def __init__(self, num_in_ch=3, num_out_ch=3, ngf=64):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Defines a video deinterlace module.\\n           input a [b,c,h,w] tensor with range [0,1] as frame,\\n           it will output a [b,c,h,w] tensor with range [0,1] whitout interlace.\\n\\n        Args:\\n            num_in_ch (int): Channel number of inputs. Default: 3.\\n            num_out_ch (int): Channel number of outputs. Default: 3.\\n            ngf(int): Channel number of features. Default: 64.\\n        '\n    super(DeinterlaceFre, self).__init__()\n    self.inconv = DoubleConv(num_in_ch, 48)\n    self.down_0 = DownConv(48, 80)\n    self.down_1 = DownConv(80, 144)\n    self.opfre_0 = freup_Periodicpadding(80)\n    self.opfre_1 = freup_Periodicpadding(144)\n    self.conv_up1 = nn.Conv2d(80, ngf, 3, 1, 1)\n    self.conv_up2 = nn.Conv2d(144, 80, 3, 1, 1)\n    self.conv_hr = nn.Conv2d(ngf, ngf, 3, 1, 1)\n    self.conv_last = nn.Conv2d(ngf, num_out_ch, 3, 1, 1)\n    self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True)\n    self.enh_inconv = DoubleConv(num_in_ch + num_out_ch, 48)\n    self.enh_down_0 = DownConv(48, 80)\n    self.enh_down_1 = DownConv(80, 144)\n    self.enh_down_2 = DownConv(144, 256)\n    self.enh_down_3 = DownConv(256, 448, num_conv=3)\n    self.enh_up_3 = UpCatConv(704, 256)\n    self.enh_up_2 = UpCatConv(400, 144)\n    self.enh_up_1 = UpCatConv(224, 80)\n    self.enh_up_0 = UpCatConv(128, 48)\n    self.enh_outconv = nn.Conv2d(48, num_out_ch, 3, 1, 1, bias=False)"
        ]
    },
    {
        "func_name": "interpolate",
        "original": "def interpolate(self, feat, x2, fn):\n    x1f = fn(feat)\n    x1 = F.interpolate(feat, scale_factor=2, mode='nearest')\n    diffY = x2.size()[2] - x1.size()[2]\n    diffX = x2.size()[3] - x1.size()[3]\n    x1f = F.pad(x1f, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    x1 = F.pad(x1, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    return x1 + x1f",
        "mutated": [
            "def interpolate(self, feat, x2, fn):\n    if False:\n        i = 10\n    x1f = fn(feat)\n    x1 = F.interpolate(feat, scale_factor=2, mode='nearest')\n    diffY = x2.size()[2] - x1.size()[2]\n    diffX = x2.size()[3] - x1.size()[3]\n    x1f = F.pad(x1f, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    x1 = F.pad(x1, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    return x1 + x1f",
            "def interpolate(self, feat, x2, fn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x1f = fn(feat)\n    x1 = F.interpolate(feat, scale_factor=2, mode='nearest')\n    diffY = x2.size()[2] - x1.size()[2]\n    diffX = x2.size()[3] - x1.size()[3]\n    x1f = F.pad(x1f, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    x1 = F.pad(x1, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    return x1 + x1f",
            "def interpolate(self, feat, x2, fn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x1f = fn(feat)\n    x1 = F.interpolate(feat, scale_factor=2, mode='nearest')\n    diffY = x2.size()[2] - x1.size()[2]\n    diffX = x2.size()[3] - x1.size()[3]\n    x1f = F.pad(x1f, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    x1 = F.pad(x1, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    return x1 + x1f",
            "def interpolate(self, feat, x2, fn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x1f = fn(feat)\n    x1 = F.interpolate(feat, scale_factor=2, mode='nearest')\n    diffY = x2.size()[2] - x1.size()[2]\n    diffX = x2.size()[3] - x1.size()[3]\n    x1f = F.pad(x1f, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    x1 = F.pad(x1, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    return x1 + x1f",
            "def interpolate(self, feat, x2, fn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x1f = fn(feat)\n    x1 = F.interpolate(feat, scale_factor=2, mode='nearest')\n    diffY = x2.size()[2] - x1.size()[2]\n    diffX = x2.size()[3] - x1.size()[3]\n    x1f = F.pad(x1f, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    x1 = F.pad(x1, [diffX // 2, diffX - diffX // 2, diffY // 2, diffY - diffY // 2])\n    return x1 + x1f"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, x):\n    x1_0 = self.inconv(x)\n    x1_1 = self.down_0(x1_0)\n    x1_2 = self.down_1(x1_1)\n    feat = self.lrelu(self.conv_up2(self.interpolate(x1_2, x1_1, self.opfre_1)))\n    feat = self.lrelu(self.conv_up1(self.interpolate(feat, x1_0, self.opfre_0)))\n    x_new = self.conv_last(self.lrelu(self.conv_hr(feat)))\n    x2_0 = self.enh_inconv(torch.cat([x_new, x], 1))\n    x2_1 = self.enh_down_0(x2_0)\n    x2_2 = self.enh_down_1(x2_1)\n    x2_3 = self.enh_down_2(x2_2)\n    x2_4 = self.enh_down_3(x2_3)\n    x2_5 = self.enh_up_3(x2_4, x2_3)\n    x2_5 = self.enh_up_2(x2_5, x2_2)\n    x2_5 = self.enh_up_1(x2_5, x2_1)\n    x2_5 = self.enh_up_0(x2_5, x2_0)\n    out = self.enh_outconv(x2_5)\n    return out",
        "mutated": [
            "def forward(self, x):\n    if False:\n        i = 10\n    x1_0 = self.inconv(x)\n    x1_1 = self.down_0(x1_0)\n    x1_2 = self.down_1(x1_1)\n    feat = self.lrelu(self.conv_up2(self.interpolate(x1_2, x1_1, self.opfre_1)))\n    feat = self.lrelu(self.conv_up1(self.interpolate(feat, x1_0, self.opfre_0)))\n    x_new = self.conv_last(self.lrelu(self.conv_hr(feat)))\n    x2_0 = self.enh_inconv(torch.cat([x_new, x], 1))\n    x2_1 = self.enh_down_0(x2_0)\n    x2_2 = self.enh_down_1(x2_1)\n    x2_3 = self.enh_down_2(x2_2)\n    x2_4 = self.enh_down_3(x2_3)\n    x2_5 = self.enh_up_3(x2_4, x2_3)\n    x2_5 = self.enh_up_2(x2_5, x2_2)\n    x2_5 = self.enh_up_1(x2_5, x2_1)\n    x2_5 = self.enh_up_0(x2_5, x2_0)\n    out = self.enh_outconv(x2_5)\n    return out",
            "def forward(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x1_0 = self.inconv(x)\n    x1_1 = self.down_0(x1_0)\n    x1_2 = self.down_1(x1_1)\n    feat = self.lrelu(self.conv_up2(self.interpolate(x1_2, x1_1, self.opfre_1)))\n    feat = self.lrelu(self.conv_up1(self.interpolate(feat, x1_0, self.opfre_0)))\n    x_new = self.conv_last(self.lrelu(self.conv_hr(feat)))\n    x2_0 = self.enh_inconv(torch.cat([x_new, x], 1))\n    x2_1 = self.enh_down_0(x2_0)\n    x2_2 = self.enh_down_1(x2_1)\n    x2_3 = self.enh_down_2(x2_2)\n    x2_4 = self.enh_down_3(x2_3)\n    x2_5 = self.enh_up_3(x2_4, x2_3)\n    x2_5 = self.enh_up_2(x2_5, x2_2)\n    x2_5 = self.enh_up_1(x2_5, x2_1)\n    x2_5 = self.enh_up_0(x2_5, x2_0)\n    out = self.enh_outconv(x2_5)\n    return out",
            "def forward(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x1_0 = self.inconv(x)\n    x1_1 = self.down_0(x1_0)\n    x1_2 = self.down_1(x1_1)\n    feat = self.lrelu(self.conv_up2(self.interpolate(x1_2, x1_1, self.opfre_1)))\n    feat = self.lrelu(self.conv_up1(self.interpolate(feat, x1_0, self.opfre_0)))\n    x_new = self.conv_last(self.lrelu(self.conv_hr(feat)))\n    x2_0 = self.enh_inconv(torch.cat([x_new, x], 1))\n    x2_1 = self.enh_down_0(x2_0)\n    x2_2 = self.enh_down_1(x2_1)\n    x2_3 = self.enh_down_2(x2_2)\n    x2_4 = self.enh_down_3(x2_3)\n    x2_5 = self.enh_up_3(x2_4, x2_3)\n    x2_5 = self.enh_up_2(x2_5, x2_2)\n    x2_5 = self.enh_up_1(x2_5, x2_1)\n    x2_5 = self.enh_up_0(x2_5, x2_0)\n    out = self.enh_outconv(x2_5)\n    return out",
            "def forward(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x1_0 = self.inconv(x)\n    x1_1 = self.down_0(x1_0)\n    x1_2 = self.down_1(x1_1)\n    feat = self.lrelu(self.conv_up2(self.interpolate(x1_2, x1_1, self.opfre_1)))\n    feat = self.lrelu(self.conv_up1(self.interpolate(feat, x1_0, self.opfre_0)))\n    x_new = self.conv_last(self.lrelu(self.conv_hr(feat)))\n    x2_0 = self.enh_inconv(torch.cat([x_new, x], 1))\n    x2_1 = self.enh_down_0(x2_0)\n    x2_2 = self.enh_down_1(x2_1)\n    x2_3 = self.enh_down_2(x2_2)\n    x2_4 = self.enh_down_3(x2_3)\n    x2_5 = self.enh_up_3(x2_4, x2_3)\n    x2_5 = self.enh_up_2(x2_5, x2_2)\n    x2_5 = self.enh_up_1(x2_5, x2_1)\n    x2_5 = self.enh_up_0(x2_5, x2_0)\n    out = self.enh_outconv(x2_5)\n    return out",
            "def forward(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x1_0 = self.inconv(x)\n    x1_1 = self.down_0(x1_0)\n    x1_2 = self.down_1(x1_1)\n    feat = self.lrelu(self.conv_up2(self.interpolate(x1_2, x1_1, self.opfre_1)))\n    feat = self.lrelu(self.conv_up1(self.interpolate(feat, x1_0, self.opfre_0)))\n    x_new = self.conv_last(self.lrelu(self.conv_hr(feat)))\n    x2_0 = self.enh_inconv(torch.cat([x_new, x], 1))\n    x2_1 = self.enh_down_0(x2_0)\n    x2_2 = self.enh_down_1(x2_1)\n    x2_3 = self.enh_down_2(x2_2)\n    x2_4 = self.enh_down_3(x2_3)\n    x2_5 = self.enh_up_3(x2_4, x2_3)\n    x2_5 = self.enh_up_2(x2_5, x2_2)\n    x2_5 = self.enh_up_1(x2_5, x2_1)\n    x2_5 = self.enh_up_0(x2_5, x2_0)\n    out = self.enh_outconv(x2_5)\n    return out"
        ]
    }
]