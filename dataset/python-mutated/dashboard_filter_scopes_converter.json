[
    {
        "func_name": "add_filter_scope",
        "original": "def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n    if isinstance(filter_field, str):\n        current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n        filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n    else:\n        logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)",
        "mutated": [
            "def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n    if False:\n        i = 10\n    if isinstance(filter_field, str):\n        current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n        filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n    else:\n        logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)",
            "def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(filter_field, str):\n        current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n        filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n    else:\n        logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)",
            "def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(filter_field, str):\n        current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n        filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n    else:\n        logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)",
            "def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(filter_field, str):\n        current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n        filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n    else:\n        logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)",
            "def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(filter_field, str):\n        current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n        filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n    else:\n        logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)"
        ]
    },
    {
        "func_name": "convert_filter_scopes",
        "original": "def convert_filter_scopes(json_metadata: dict[Any, Any], filter_boxes: list[Slice]) -> dict[int, dict[str, dict[str, Any]]]:\n    filter_scopes = {}\n    immuned_by_id: list[int] = json_metadata.get('filter_immune_slices') or []\n    immuned_by_column: dict[str, list[int]] = defaultdict(list)\n    for (slice_id, columns) in json_metadata.get('filter_immune_slice_fields', {}).items():\n        for column in columns:\n            immuned_by_column[column].append(int(slice_id))\n\n    def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n        if isinstance(filter_field, str):\n            current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n            filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n        else:\n            logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)\n    for filter_box in filter_boxes:\n        filter_fields: dict[str, dict[str, Any]] = {}\n        filter_id = filter_box.id\n        slice_params = json.loads(filter_box.params or '{}')\n        configs = slice_params.get('filter_configs') or []\n        if slice_params.get('date_filter'):\n            add_filter_scope(filter_fields, '__time_range', filter_id)\n        if slice_params.get('show_sqla_time_column'):\n            add_filter_scope(filter_fields, '__time_col', filter_id)\n        if slice_params.get('show_sqla_time_granularity'):\n            add_filter_scope(filter_fields, '__time_grain', filter_id)\n        for config in configs:\n            add_filter_scope(filter_fields, config.get('column'), filter_id)\n        if filter_fields:\n            filter_scopes[filter_id] = filter_fields\n    return filter_scopes",
        "mutated": [
            "def convert_filter_scopes(json_metadata: dict[Any, Any], filter_boxes: list[Slice]) -> dict[int, dict[str, dict[str, Any]]]:\n    if False:\n        i = 10\n    filter_scopes = {}\n    immuned_by_id: list[int] = json_metadata.get('filter_immune_slices') or []\n    immuned_by_column: dict[str, list[int]] = defaultdict(list)\n    for (slice_id, columns) in json_metadata.get('filter_immune_slice_fields', {}).items():\n        for column in columns:\n            immuned_by_column[column].append(int(slice_id))\n\n    def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n        if isinstance(filter_field, str):\n            current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n            filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n        else:\n            logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)\n    for filter_box in filter_boxes:\n        filter_fields: dict[str, dict[str, Any]] = {}\n        filter_id = filter_box.id\n        slice_params = json.loads(filter_box.params or '{}')\n        configs = slice_params.get('filter_configs') or []\n        if slice_params.get('date_filter'):\n            add_filter_scope(filter_fields, '__time_range', filter_id)\n        if slice_params.get('show_sqla_time_column'):\n            add_filter_scope(filter_fields, '__time_col', filter_id)\n        if slice_params.get('show_sqla_time_granularity'):\n            add_filter_scope(filter_fields, '__time_grain', filter_id)\n        for config in configs:\n            add_filter_scope(filter_fields, config.get('column'), filter_id)\n        if filter_fields:\n            filter_scopes[filter_id] = filter_fields\n    return filter_scopes",
            "def convert_filter_scopes(json_metadata: dict[Any, Any], filter_boxes: list[Slice]) -> dict[int, dict[str, dict[str, Any]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    filter_scopes = {}\n    immuned_by_id: list[int] = json_metadata.get('filter_immune_slices') or []\n    immuned_by_column: dict[str, list[int]] = defaultdict(list)\n    for (slice_id, columns) in json_metadata.get('filter_immune_slice_fields', {}).items():\n        for column in columns:\n            immuned_by_column[column].append(int(slice_id))\n\n    def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n        if isinstance(filter_field, str):\n            current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n            filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n        else:\n            logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)\n    for filter_box in filter_boxes:\n        filter_fields: dict[str, dict[str, Any]] = {}\n        filter_id = filter_box.id\n        slice_params = json.loads(filter_box.params or '{}')\n        configs = slice_params.get('filter_configs') or []\n        if slice_params.get('date_filter'):\n            add_filter_scope(filter_fields, '__time_range', filter_id)\n        if slice_params.get('show_sqla_time_column'):\n            add_filter_scope(filter_fields, '__time_col', filter_id)\n        if slice_params.get('show_sqla_time_granularity'):\n            add_filter_scope(filter_fields, '__time_grain', filter_id)\n        for config in configs:\n            add_filter_scope(filter_fields, config.get('column'), filter_id)\n        if filter_fields:\n            filter_scopes[filter_id] = filter_fields\n    return filter_scopes",
            "def convert_filter_scopes(json_metadata: dict[Any, Any], filter_boxes: list[Slice]) -> dict[int, dict[str, dict[str, Any]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    filter_scopes = {}\n    immuned_by_id: list[int] = json_metadata.get('filter_immune_slices') or []\n    immuned_by_column: dict[str, list[int]] = defaultdict(list)\n    for (slice_id, columns) in json_metadata.get('filter_immune_slice_fields', {}).items():\n        for column in columns:\n            immuned_by_column[column].append(int(slice_id))\n\n    def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n        if isinstance(filter_field, str):\n            current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n            filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n        else:\n            logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)\n    for filter_box in filter_boxes:\n        filter_fields: dict[str, dict[str, Any]] = {}\n        filter_id = filter_box.id\n        slice_params = json.loads(filter_box.params or '{}')\n        configs = slice_params.get('filter_configs') or []\n        if slice_params.get('date_filter'):\n            add_filter_scope(filter_fields, '__time_range', filter_id)\n        if slice_params.get('show_sqla_time_column'):\n            add_filter_scope(filter_fields, '__time_col', filter_id)\n        if slice_params.get('show_sqla_time_granularity'):\n            add_filter_scope(filter_fields, '__time_grain', filter_id)\n        for config in configs:\n            add_filter_scope(filter_fields, config.get('column'), filter_id)\n        if filter_fields:\n            filter_scopes[filter_id] = filter_fields\n    return filter_scopes",
            "def convert_filter_scopes(json_metadata: dict[Any, Any], filter_boxes: list[Slice]) -> dict[int, dict[str, dict[str, Any]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    filter_scopes = {}\n    immuned_by_id: list[int] = json_metadata.get('filter_immune_slices') or []\n    immuned_by_column: dict[str, list[int]] = defaultdict(list)\n    for (slice_id, columns) in json_metadata.get('filter_immune_slice_fields', {}).items():\n        for column in columns:\n            immuned_by_column[column].append(int(slice_id))\n\n    def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n        if isinstance(filter_field, str):\n            current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n            filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n        else:\n            logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)\n    for filter_box in filter_boxes:\n        filter_fields: dict[str, dict[str, Any]] = {}\n        filter_id = filter_box.id\n        slice_params = json.loads(filter_box.params or '{}')\n        configs = slice_params.get('filter_configs') or []\n        if slice_params.get('date_filter'):\n            add_filter_scope(filter_fields, '__time_range', filter_id)\n        if slice_params.get('show_sqla_time_column'):\n            add_filter_scope(filter_fields, '__time_col', filter_id)\n        if slice_params.get('show_sqla_time_granularity'):\n            add_filter_scope(filter_fields, '__time_grain', filter_id)\n        for config in configs:\n            add_filter_scope(filter_fields, config.get('column'), filter_id)\n        if filter_fields:\n            filter_scopes[filter_id] = filter_fields\n    return filter_scopes",
            "def convert_filter_scopes(json_metadata: dict[Any, Any], filter_boxes: list[Slice]) -> dict[int, dict[str, dict[str, Any]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    filter_scopes = {}\n    immuned_by_id: list[int] = json_metadata.get('filter_immune_slices') or []\n    immuned_by_column: dict[str, list[int]] = defaultdict(list)\n    for (slice_id, columns) in json_metadata.get('filter_immune_slice_fields', {}).items():\n        for column in columns:\n            immuned_by_column[column].append(int(slice_id))\n\n    def add_filter_scope(filter_fields: dict[str, dict[str, Any]], filter_field: str, filter_id: int) -> None:\n        if isinstance(filter_field, str):\n            current_filter_immune = list(set(immuned_by_id + immuned_by_column.get(filter_field, [])))\n            filter_fields[filter_field] = {'scope': ['ROOT_ID'], 'immune': current_filter_immune}\n        else:\n            logging.info('slice [%i] has invalid field: %s', filter_id, filter_field)\n    for filter_box in filter_boxes:\n        filter_fields: dict[str, dict[str, Any]] = {}\n        filter_id = filter_box.id\n        slice_params = json.loads(filter_box.params or '{}')\n        configs = slice_params.get('filter_configs') or []\n        if slice_params.get('date_filter'):\n            add_filter_scope(filter_fields, '__time_range', filter_id)\n        if slice_params.get('show_sqla_time_column'):\n            add_filter_scope(filter_fields, '__time_col', filter_id)\n        if slice_params.get('show_sqla_time_granularity'):\n            add_filter_scope(filter_fields, '__time_grain', filter_id)\n        for config in configs:\n            add_filter_scope(filter_fields, config.get('column'), filter_id)\n        if filter_fields:\n            filter_scopes[filter_id] = filter_fields\n    return filter_scopes"
        ]
    },
    {
        "func_name": "copy_filter_scopes",
        "original": "def copy_filter_scopes(old_to_new_slc_id_dict: dict[int, int], old_filter_scopes: dict[int, dict[str, dict[str, Any]]]) -> dict[str, dict[Any, Any]]:\n    new_filter_scopes: dict[str, dict[Any, Any]] = {}\n    for (filter_id, scopes) in old_filter_scopes.items():\n        new_filter_key = old_to_new_slc_id_dict.get(int(filter_id))\n        if new_filter_key:\n            new_filter_scopes[str(new_filter_key)] = scopes\n            for scope in scopes.values():\n                scope['immune'] = [old_to_new_slc_id_dict[int(slice_id)] for slice_id in scope.get('immune', []) if int(slice_id) in old_to_new_slc_id_dict]\n    return new_filter_scopes",
        "mutated": [
            "def copy_filter_scopes(old_to_new_slc_id_dict: dict[int, int], old_filter_scopes: dict[int, dict[str, dict[str, Any]]]) -> dict[str, dict[Any, Any]]:\n    if False:\n        i = 10\n    new_filter_scopes: dict[str, dict[Any, Any]] = {}\n    for (filter_id, scopes) in old_filter_scopes.items():\n        new_filter_key = old_to_new_slc_id_dict.get(int(filter_id))\n        if new_filter_key:\n            new_filter_scopes[str(new_filter_key)] = scopes\n            for scope in scopes.values():\n                scope['immune'] = [old_to_new_slc_id_dict[int(slice_id)] for slice_id in scope.get('immune', []) if int(slice_id) in old_to_new_slc_id_dict]\n    return new_filter_scopes",
            "def copy_filter_scopes(old_to_new_slc_id_dict: dict[int, int], old_filter_scopes: dict[int, dict[str, dict[str, Any]]]) -> dict[str, dict[Any, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    new_filter_scopes: dict[str, dict[Any, Any]] = {}\n    for (filter_id, scopes) in old_filter_scopes.items():\n        new_filter_key = old_to_new_slc_id_dict.get(int(filter_id))\n        if new_filter_key:\n            new_filter_scopes[str(new_filter_key)] = scopes\n            for scope in scopes.values():\n                scope['immune'] = [old_to_new_slc_id_dict[int(slice_id)] for slice_id in scope.get('immune', []) if int(slice_id) in old_to_new_slc_id_dict]\n    return new_filter_scopes",
            "def copy_filter_scopes(old_to_new_slc_id_dict: dict[int, int], old_filter_scopes: dict[int, dict[str, dict[str, Any]]]) -> dict[str, dict[Any, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    new_filter_scopes: dict[str, dict[Any, Any]] = {}\n    for (filter_id, scopes) in old_filter_scopes.items():\n        new_filter_key = old_to_new_slc_id_dict.get(int(filter_id))\n        if new_filter_key:\n            new_filter_scopes[str(new_filter_key)] = scopes\n            for scope in scopes.values():\n                scope['immune'] = [old_to_new_slc_id_dict[int(slice_id)] for slice_id in scope.get('immune', []) if int(slice_id) in old_to_new_slc_id_dict]\n    return new_filter_scopes",
            "def copy_filter_scopes(old_to_new_slc_id_dict: dict[int, int], old_filter_scopes: dict[int, dict[str, dict[str, Any]]]) -> dict[str, dict[Any, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    new_filter_scopes: dict[str, dict[Any, Any]] = {}\n    for (filter_id, scopes) in old_filter_scopes.items():\n        new_filter_key = old_to_new_slc_id_dict.get(int(filter_id))\n        if new_filter_key:\n            new_filter_scopes[str(new_filter_key)] = scopes\n            for scope in scopes.values():\n                scope['immune'] = [old_to_new_slc_id_dict[int(slice_id)] for slice_id in scope.get('immune', []) if int(slice_id) in old_to_new_slc_id_dict]\n    return new_filter_scopes",
            "def copy_filter_scopes(old_to_new_slc_id_dict: dict[int, int], old_filter_scopes: dict[int, dict[str, dict[str, Any]]]) -> dict[str, dict[Any, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    new_filter_scopes: dict[str, dict[Any, Any]] = {}\n    for (filter_id, scopes) in old_filter_scopes.items():\n        new_filter_key = old_to_new_slc_id_dict.get(int(filter_id))\n        if new_filter_key:\n            new_filter_scopes[str(new_filter_key)] = scopes\n            for scope in scopes.values():\n                scope['immune'] = [old_to_new_slc_id_dict[int(slice_id)] for slice_id in scope.get('immune', []) if int(slice_id) in old_to_new_slc_id_dict]\n    return new_filter_scopes"
        ]
    },
    {
        "func_name": "convert_filter_scopes_to_native_filters",
        "original": "def convert_filter_scopes_to_native_filters(json_metadata: dict[str, Any], position_json: dict[str, Any], filter_boxes: list[Slice]) -> list[dict[str, Any]]:\n    \"\"\"\n    Convert the legacy filter scopes et al. to the native filter configuration.\n\n    Dashboard filter scopes are implicitly defined where an undefined scope implies\n    no immunity, i.e., they apply to all applicable charts. The `convert_filter_scopes`\n    method provides an explicit definition by extracting the underlying filter-box\n    configurations.\n\n    Hierarchical legacy filters are defined via non-exclusion of peer or children\n    filter-box charts whereas native hierarchical filters are defined via explicit\n    parental relationships, i.e., the inverse.\n\n    :param json_metadata: The dashboard metadata\n    :param position_json: The dashboard layout\n    :param filter_boxes: The filter-box charts associated with the dashboard\n    :returns: The native filter configuration\n    :see: convert_filter_scopes\n    \"\"\"\n    shortid = ShortId()\n    default_filters = json.loads(json_metadata.get('default_filters') or '{}')\n    filter_scopes = json_metadata.get('filter_scopes', {})\n    filter_box_ids = {filter_box.id for filter_box in filter_boxes}\n    filter_scope_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    filter_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        filter_scope_by_key_and_field[key] = {**convert_filter_scopes(json_metadata, filter_boxes=[filter_box]).get(filter_box.id, {}), **filter_scopes.get(key, {})}\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        params = json.loads(filter_box.params or '{}')\n        for (field, filter_scope) in filter_scope_by_key_and_field[key].items():\n            default = default_filters.get(key, {}).get(field)\n            fltr: dict[str, Any] = {'cascadeParentIds': [], 'id': f'NATIVE_FILTER-{shortid.generate()}', 'scope': {'rootPath': filter_scope['scope'], 'excluded': [id_ for id_ in filter_scope['immune'] if id_ not in filter_box_ids]}, 'type': 'NATIVE_FILTER'}\n            if field == '__time_col' and params.get('show_sqla_time_column'):\n                fltr.update({'filterType': 'filter_timecolumn', 'name': 'Time Column', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('granularity_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'granularity_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_grain' and params.get('show_sqla_time_granularity'):\n                fltr.update({'filterType': 'filter_timegrain', 'name': 'Time Grain', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('time_grain_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_grain_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_range' and params.get('date_filter'):\n                fltr.update({'filterType': 'filter_time', 'name': 'Time Range', 'targets': [{}]})\n                if not default:\n                    default = params.get('time_range')\n                if default and default != 'No filter':\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_range': default}, 'filterState': {'value': default}}\n            else:\n                for config in params.get('filter_configs') or []:\n                    if config['column'] == field:\n                        fltr.update({'controlValues': {'defaultToFirstItem': False, 'enableEmptyFilter': not config.get('clearable', True), 'inverseSelection': False, 'multiSelect': config.get('multiple', False), 'searchAllOptions': config.get('searchAllOptions', False)}, 'filterType': 'filter_select', 'name': config.get('label') or field, 'targets': [{'column': {'name': field}, 'datasetId': filter_box.datasource_id}]})\n                        if 'metric' in config:\n                            fltr['sortMetric'] = config['metric']\n                            fltr['controlValues']['sortAscending'] = config['asc']\n                        if params.get('adhoc_filters'):\n                            fltr['adhoc_filters'] = params['adhoc_filters']\n                        time_range = params.get('time_range')\n                        if time_range and time_range != 'No filter':\n                            fltr.update({'time_range': time_range, 'granularity_sqla': params.get('granularity_sqla')})\n                        if not default:\n                            default = config.get('defaultValue')\n                            if default and config['multiple']:\n                                default = default.split(';')\n                        if default:\n                            if not isinstance(default, list):\n                                default = [default]\n                            fltr['defaultDataMask'] = {'extraFormData': {'filters': [{'col': field, 'op': 'IN', 'val': default}]}, 'filterState': {'value': default}}\n                        break\n            if 'filterType' in fltr:\n                filter_by_key_and_field[key][field] = fltr\n    ancestors_by_id = defaultdict(set)\n    for filter_box in filter_boxes:\n        for value in position_json.values():\n            try:\n                if isinstance(value, dict) and value['type'] == 'CHART' and (value['meta']['chartId'] == filter_box.id) and value['parents']:\n                    ancestors_by_id[filter_box.id] = set(value['parents'])\n            except KeyError:\n                pass\n    for this in filter_boxes:\n        for other in filter_boxes:\n            if this != other and any((this.id not in filter_scope['immune'] and set(filter_scope['scope']) <= ancestors_by_id[this.id] for filter_scope in filter_scope_by_key_and_field[str(other.id)].values())):\n                for child in filter_by_key_and_field[str(this.id)].values():\n                    if child['filterType'] == 'filter_select':\n                        for parent in filter_by_key_and_field[str(other.id)].values():\n                            if parent['filterType'] in {'filter_select', 'filter_time'} and parent['id'] not in child['cascadeParentIds']:\n                                child['cascadeParentIds'].append(parent['id'])\n    return sorted([fltr for key in filter_by_key_and_field for fltr in filter_by_key_and_field[key].values()], key=lambda fltr: fltr['filterType'])",
        "mutated": [
            "def convert_filter_scopes_to_native_filters(json_metadata: dict[str, Any], position_json: dict[str, Any], filter_boxes: list[Slice]) -> list[dict[str, Any]]:\n    if False:\n        i = 10\n    '\\n    Convert the legacy filter scopes et al. to the native filter configuration.\\n\\n    Dashboard filter scopes are implicitly defined where an undefined scope implies\\n    no immunity, i.e., they apply to all applicable charts. The `convert_filter_scopes`\\n    method provides an explicit definition by extracting the underlying filter-box\\n    configurations.\\n\\n    Hierarchical legacy filters are defined via non-exclusion of peer or children\\n    filter-box charts whereas native hierarchical filters are defined via explicit\\n    parental relationships, i.e., the inverse.\\n\\n    :param json_metadata: The dashboard metadata\\n    :param position_json: The dashboard layout\\n    :param filter_boxes: The filter-box charts associated with the dashboard\\n    :returns: The native filter configuration\\n    :see: convert_filter_scopes\\n    '\n    shortid = ShortId()\n    default_filters = json.loads(json_metadata.get('default_filters') or '{}')\n    filter_scopes = json_metadata.get('filter_scopes', {})\n    filter_box_ids = {filter_box.id for filter_box in filter_boxes}\n    filter_scope_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    filter_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        filter_scope_by_key_and_field[key] = {**convert_filter_scopes(json_metadata, filter_boxes=[filter_box]).get(filter_box.id, {}), **filter_scopes.get(key, {})}\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        params = json.loads(filter_box.params or '{}')\n        for (field, filter_scope) in filter_scope_by_key_and_field[key].items():\n            default = default_filters.get(key, {}).get(field)\n            fltr: dict[str, Any] = {'cascadeParentIds': [], 'id': f'NATIVE_FILTER-{shortid.generate()}', 'scope': {'rootPath': filter_scope['scope'], 'excluded': [id_ for id_ in filter_scope['immune'] if id_ not in filter_box_ids]}, 'type': 'NATIVE_FILTER'}\n            if field == '__time_col' and params.get('show_sqla_time_column'):\n                fltr.update({'filterType': 'filter_timecolumn', 'name': 'Time Column', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('granularity_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'granularity_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_grain' and params.get('show_sqla_time_granularity'):\n                fltr.update({'filterType': 'filter_timegrain', 'name': 'Time Grain', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('time_grain_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_grain_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_range' and params.get('date_filter'):\n                fltr.update({'filterType': 'filter_time', 'name': 'Time Range', 'targets': [{}]})\n                if not default:\n                    default = params.get('time_range')\n                if default and default != 'No filter':\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_range': default}, 'filterState': {'value': default}}\n            else:\n                for config in params.get('filter_configs') or []:\n                    if config['column'] == field:\n                        fltr.update({'controlValues': {'defaultToFirstItem': False, 'enableEmptyFilter': not config.get('clearable', True), 'inverseSelection': False, 'multiSelect': config.get('multiple', False), 'searchAllOptions': config.get('searchAllOptions', False)}, 'filterType': 'filter_select', 'name': config.get('label') or field, 'targets': [{'column': {'name': field}, 'datasetId': filter_box.datasource_id}]})\n                        if 'metric' in config:\n                            fltr['sortMetric'] = config['metric']\n                            fltr['controlValues']['sortAscending'] = config['asc']\n                        if params.get('adhoc_filters'):\n                            fltr['adhoc_filters'] = params['adhoc_filters']\n                        time_range = params.get('time_range')\n                        if time_range and time_range != 'No filter':\n                            fltr.update({'time_range': time_range, 'granularity_sqla': params.get('granularity_sqla')})\n                        if not default:\n                            default = config.get('defaultValue')\n                            if default and config['multiple']:\n                                default = default.split(';')\n                        if default:\n                            if not isinstance(default, list):\n                                default = [default]\n                            fltr['defaultDataMask'] = {'extraFormData': {'filters': [{'col': field, 'op': 'IN', 'val': default}]}, 'filterState': {'value': default}}\n                        break\n            if 'filterType' in fltr:\n                filter_by_key_and_field[key][field] = fltr\n    ancestors_by_id = defaultdict(set)\n    for filter_box in filter_boxes:\n        for value in position_json.values():\n            try:\n                if isinstance(value, dict) and value['type'] == 'CHART' and (value['meta']['chartId'] == filter_box.id) and value['parents']:\n                    ancestors_by_id[filter_box.id] = set(value['parents'])\n            except KeyError:\n                pass\n    for this in filter_boxes:\n        for other in filter_boxes:\n            if this != other and any((this.id not in filter_scope['immune'] and set(filter_scope['scope']) <= ancestors_by_id[this.id] for filter_scope in filter_scope_by_key_and_field[str(other.id)].values())):\n                for child in filter_by_key_and_field[str(this.id)].values():\n                    if child['filterType'] == 'filter_select':\n                        for parent in filter_by_key_and_field[str(other.id)].values():\n                            if parent['filterType'] in {'filter_select', 'filter_time'} and parent['id'] not in child['cascadeParentIds']:\n                                child['cascadeParentIds'].append(parent['id'])\n    return sorted([fltr for key in filter_by_key_and_field for fltr in filter_by_key_and_field[key].values()], key=lambda fltr: fltr['filterType'])",
            "def convert_filter_scopes_to_native_filters(json_metadata: dict[str, Any], position_json: dict[str, Any], filter_boxes: list[Slice]) -> list[dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Convert the legacy filter scopes et al. to the native filter configuration.\\n\\n    Dashboard filter scopes are implicitly defined where an undefined scope implies\\n    no immunity, i.e., they apply to all applicable charts. The `convert_filter_scopes`\\n    method provides an explicit definition by extracting the underlying filter-box\\n    configurations.\\n\\n    Hierarchical legacy filters are defined via non-exclusion of peer or children\\n    filter-box charts whereas native hierarchical filters are defined via explicit\\n    parental relationships, i.e., the inverse.\\n\\n    :param json_metadata: The dashboard metadata\\n    :param position_json: The dashboard layout\\n    :param filter_boxes: The filter-box charts associated with the dashboard\\n    :returns: The native filter configuration\\n    :see: convert_filter_scopes\\n    '\n    shortid = ShortId()\n    default_filters = json.loads(json_metadata.get('default_filters') or '{}')\n    filter_scopes = json_metadata.get('filter_scopes', {})\n    filter_box_ids = {filter_box.id for filter_box in filter_boxes}\n    filter_scope_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    filter_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        filter_scope_by_key_and_field[key] = {**convert_filter_scopes(json_metadata, filter_boxes=[filter_box]).get(filter_box.id, {}), **filter_scopes.get(key, {})}\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        params = json.loads(filter_box.params or '{}')\n        for (field, filter_scope) in filter_scope_by_key_and_field[key].items():\n            default = default_filters.get(key, {}).get(field)\n            fltr: dict[str, Any] = {'cascadeParentIds': [], 'id': f'NATIVE_FILTER-{shortid.generate()}', 'scope': {'rootPath': filter_scope['scope'], 'excluded': [id_ for id_ in filter_scope['immune'] if id_ not in filter_box_ids]}, 'type': 'NATIVE_FILTER'}\n            if field == '__time_col' and params.get('show_sqla_time_column'):\n                fltr.update({'filterType': 'filter_timecolumn', 'name': 'Time Column', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('granularity_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'granularity_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_grain' and params.get('show_sqla_time_granularity'):\n                fltr.update({'filterType': 'filter_timegrain', 'name': 'Time Grain', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('time_grain_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_grain_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_range' and params.get('date_filter'):\n                fltr.update({'filterType': 'filter_time', 'name': 'Time Range', 'targets': [{}]})\n                if not default:\n                    default = params.get('time_range')\n                if default and default != 'No filter':\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_range': default}, 'filterState': {'value': default}}\n            else:\n                for config in params.get('filter_configs') or []:\n                    if config['column'] == field:\n                        fltr.update({'controlValues': {'defaultToFirstItem': False, 'enableEmptyFilter': not config.get('clearable', True), 'inverseSelection': False, 'multiSelect': config.get('multiple', False), 'searchAllOptions': config.get('searchAllOptions', False)}, 'filterType': 'filter_select', 'name': config.get('label') or field, 'targets': [{'column': {'name': field}, 'datasetId': filter_box.datasource_id}]})\n                        if 'metric' in config:\n                            fltr['sortMetric'] = config['metric']\n                            fltr['controlValues']['sortAscending'] = config['asc']\n                        if params.get('adhoc_filters'):\n                            fltr['adhoc_filters'] = params['adhoc_filters']\n                        time_range = params.get('time_range')\n                        if time_range and time_range != 'No filter':\n                            fltr.update({'time_range': time_range, 'granularity_sqla': params.get('granularity_sqla')})\n                        if not default:\n                            default = config.get('defaultValue')\n                            if default and config['multiple']:\n                                default = default.split(';')\n                        if default:\n                            if not isinstance(default, list):\n                                default = [default]\n                            fltr['defaultDataMask'] = {'extraFormData': {'filters': [{'col': field, 'op': 'IN', 'val': default}]}, 'filterState': {'value': default}}\n                        break\n            if 'filterType' in fltr:\n                filter_by_key_and_field[key][field] = fltr\n    ancestors_by_id = defaultdict(set)\n    for filter_box in filter_boxes:\n        for value in position_json.values():\n            try:\n                if isinstance(value, dict) and value['type'] == 'CHART' and (value['meta']['chartId'] == filter_box.id) and value['parents']:\n                    ancestors_by_id[filter_box.id] = set(value['parents'])\n            except KeyError:\n                pass\n    for this in filter_boxes:\n        for other in filter_boxes:\n            if this != other and any((this.id not in filter_scope['immune'] and set(filter_scope['scope']) <= ancestors_by_id[this.id] for filter_scope in filter_scope_by_key_and_field[str(other.id)].values())):\n                for child in filter_by_key_and_field[str(this.id)].values():\n                    if child['filterType'] == 'filter_select':\n                        for parent in filter_by_key_and_field[str(other.id)].values():\n                            if parent['filterType'] in {'filter_select', 'filter_time'} and parent['id'] not in child['cascadeParentIds']:\n                                child['cascadeParentIds'].append(parent['id'])\n    return sorted([fltr for key in filter_by_key_and_field for fltr in filter_by_key_and_field[key].values()], key=lambda fltr: fltr['filterType'])",
            "def convert_filter_scopes_to_native_filters(json_metadata: dict[str, Any], position_json: dict[str, Any], filter_boxes: list[Slice]) -> list[dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Convert the legacy filter scopes et al. to the native filter configuration.\\n\\n    Dashboard filter scopes are implicitly defined where an undefined scope implies\\n    no immunity, i.e., they apply to all applicable charts. The `convert_filter_scopes`\\n    method provides an explicit definition by extracting the underlying filter-box\\n    configurations.\\n\\n    Hierarchical legacy filters are defined via non-exclusion of peer or children\\n    filter-box charts whereas native hierarchical filters are defined via explicit\\n    parental relationships, i.e., the inverse.\\n\\n    :param json_metadata: The dashboard metadata\\n    :param position_json: The dashboard layout\\n    :param filter_boxes: The filter-box charts associated with the dashboard\\n    :returns: The native filter configuration\\n    :see: convert_filter_scopes\\n    '\n    shortid = ShortId()\n    default_filters = json.loads(json_metadata.get('default_filters') or '{}')\n    filter_scopes = json_metadata.get('filter_scopes', {})\n    filter_box_ids = {filter_box.id for filter_box in filter_boxes}\n    filter_scope_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    filter_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        filter_scope_by_key_and_field[key] = {**convert_filter_scopes(json_metadata, filter_boxes=[filter_box]).get(filter_box.id, {}), **filter_scopes.get(key, {})}\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        params = json.loads(filter_box.params or '{}')\n        for (field, filter_scope) in filter_scope_by_key_and_field[key].items():\n            default = default_filters.get(key, {}).get(field)\n            fltr: dict[str, Any] = {'cascadeParentIds': [], 'id': f'NATIVE_FILTER-{shortid.generate()}', 'scope': {'rootPath': filter_scope['scope'], 'excluded': [id_ for id_ in filter_scope['immune'] if id_ not in filter_box_ids]}, 'type': 'NATIVE_FILTER'}\n            if field == '__time_col' and params.get('show_sqla_time_column'):\n                fltr.update({'filterType': 'filter_timecolumn', 'name': 'Time Column', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('granularity_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'granularity_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_grain' and params.get('show_sqla_time_granularity'):\n                fltr.update({'filterType': 'filter_timegrain', 'name': 'Time Grain', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('time_grain_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_grain_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_range' and params.get('date_filter'):\n                fltr.update({'filterType': 'filter_time', 'name': 'Time Range', 'targets': [{}]})\n                if not default:\n                    default = params.get('time_range')\n                if default and default != 'No filter':\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_range': default}, 'filterState': {'value': default}}\n            else:\n                for config in params.get('filter_configs') or []:\n                    if config['column'] == field:\n                        fltr.update({'controlValues': {'defaultToFirstItem': False, 'enableEmptyFilter': not config.get('clearable', True), 'inverseSelection': False, 'multiSelect': config.get('multiple', False), 'searchAllOptions': config.get('searchAllOptions', False)}, 'filterType': 'filter_select', 'name': config.get('label') or field, 'targets': [{'column': {'name': field}, 'datasetId': filter_box.datasource_id}]})\n                        if 'metric' in config:\n                            fltr['sortMetric'] = config['metric']\n                            fltr['controlValues']['sortAscending'] = config['asc']\n                        if params.get('adhoc_filters'):\n                            fltr['adhoc_filters'] = params['adhoc_filters']\n                        time_range = params.get('time_range')\n                        if time_range and time_range != 'No filter':\n                            fltr.update({'time_range': time_range, 'granularity_sqla': params.get('granularity_sqla')})\n                        if not default:\n                            default = config.get('defaultValue')\n                            if default and config['multiple']:\n                                default = default.split(';')\n                        if default:\n                            if not isinstance(default, list):\n                                default = [default]\n                            fltr['defaultDataMask'] = {'extraFormData': {'filters': [{'col': field, 'op': 'IN', 'val': default}]}, 'filterState': {'value': default}}\n                        break\n            if 'filterType' in fltr:\n                filter_by_key_and_field[key][field] = fltr\n    ancestors_by_id = defaultdict(set)\n    for filter_box in filter_boxes:\n        for value in position_json.values():\n            try:\n                if isinstance(value, dict) and value['type'] == 'CHART' and (value['meta']['chartId'] == filter_box.id) and value['parents']:\n                    ancestors_by_id[filter_box.id] = set(value['parents'])\n            except KeyError:\n                pass\n    for this in filter_boxes:\n        for other in filter_boxes:\n            if this != other and any((this.id not in filter_scope['immune'] and set(filter_scope['scope']) <= ancestors_by_id[this.id] for filter_scope in filter_scope_by_key_and_field[str(other.id)].values())):\n                for child in filter_by_key_and_field[str(this.id)].values():\n                    if child['filterType'] == 'filter_select':\n                        for parent in filter_by_key_and_field[str(other.id)].values():\n                            if parent['filterType'] in {'filter_select', 'filter_time'} and parent['id'] not in child['cascadeParentIds']:\n                                child['cascadeParentIds'].append(parent['id'])\n    return sorted([fltr for key in filter_by_key_and_field for fltr in filter_by_key_and_field[key].values()], key=lambda fltr: fltr['filterType'])",
            "def convert_filter_scopes_to_native_filters(json_metadata: dict[str, Any], position_json: dict[str, Any], filter_boxes: list[Slice]) -> list[dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Convert the legacy filter scopes et al. to the native filter configuration.\\n\\n    Dashboard filter scopes are implicitly defined where an undefined scope implies\\n    no immunity, i.e., they apply to all applicable charts. The `convert_filter_scopes`\\n    method provides an explicit definition by extracting the underlying filter-box\\n    configurations.\\n\\n    Hierarchical legacy filters are defined via non-exclusion of peer or children\\n    filter-box charts whereas native hierarchical filters are defined via explicit\\n    parental relationships, i.e., the inverse.\\n\\n    :param json_metadata: The dashboard metadata\\n    :param position_json: The dashboard layout\\n    :param filter_boxes: The filter-box charts associated with the dashboard\\n    :returns: The native filter configuration\\n    :see: convert_filter_scopes\\n    '\n    shortid = ShortId()\n    default_filters = json.loads(json_metadata.get('default_filters') or '{}')\n    filter_scopes = json_metadata.get('filter_scopes', {})\n    filter_box_ids = {filter_box.id for filter_box in filter_boxes}\n    filter_scope_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    filter_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        filter_scope_by_key_and_field[key] = {**convert_filter_scopes(json_metadata, filter_boxes=[filter_box]).get(filter_box.id, {}), **filter_scopes.get(key, {})}\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        params = json.loads(filter_box.params or '{}')\n        for (field, filter_scope) in filter_scope_by_key_and_field[key].items():\n            default = default_filters.get(key, {}).get(field)\n            fltr: dict[str, Any] = {'cascadeParentIds': [], 'id': f'NATIVE_FILTER-{shortid.generate()}', 'scope': {'rootPath': filter_scope['scope'], 'excluded': [id_ for id_ in filter_scope['immune'] if id_ not in filter_box_ids]}, 'type': 'NATIVE_FILTER'}\n            if field == '__time_col' and params.get('show_sqla_time_column'):\n                fltr.update({'filterType': 'filter_timecolumn', 'name': 'Time Column', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('granularity_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'granularity_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_grain' and params.get('show_sqla_time_granularity'):\n                fltr.update({'filterType': 'filter_timegrain', 'name': 'Time Grain', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('time_grain_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_grain_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_range' and params.get('date_filter'):\n                fltr.update({'filterType': 'filter_time', 'name': 'Time Range', 'targets': [{}]})\n                if not default:\n                    default = params.get('time_range')\n                if default and default != 'No filter':\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_range': default}, 'filterState': {'value': default}}\n            else:\n                for config in params.get('filter_configs') or []:\n                    if config['column'] == field:\n                        fltr.update({'controlValues': {'defaultToFirstItem': False, 'enableEmptyFilter': not config.get('clearable', True), 'inverseSelection': False, 'multiSelect': config.get('multiple', False), 'searchAllOptions': config.get('searchAllOptions', False)}, 'filterType': 'filter_select', 'name': config.get('label') or field, 'targets': [{'column': {'name': field}, 'datasetId': filter_box.datasource_id}]})\n                        if 'metric' in config:\n                            fltr['sortMetric'] = config['metric']\n                            fltr['controlValues']['sortAscending'] = config['asc']\n                        if params.get('adhoc_filters'):\n                            fltr['adhoc_filters'] = params['adhoc_filters']\n                        time_range = params.get('time_range')\n                        if time_range and time_range != 'No filter':\n                            fltr.update({'time_range': time_range, 'granularity_sqla': params.get('granularity_sqla')})\n                        if not default:\n                            default = config.get('defaultValue')\n                            if default and config['multiple']:\n                                default = default.split(';')\n                        if default:\n                            if not isinstance(default, list):\n                                default = [default]\n                            fltr['defaultDataMask'] = {'extraFormData': {'filters': [{'col': field, 'op': 'IN', 'val': default}]}, 'filterState': {'value': default}}\n                        break\n            if 'filterType' in fltr:\n                filter_by_key_and_field[key][field] = fltr\n    ancestors_by_id = defaultdict(set)\n    for filter_box in filter_boxes:\n        for value in position_json.values():\n            try:\n                if isinstance(value, dict) and value['type'] == 'CHART' and (value['meta']['chartId'] == filter_box.id) and value['parents']:\n                    ancestors_by_id[filter_box.id] = set(value['parents'])\n            except KeyError:\n                pass\n    for this in filter_boxes:\n        for other in filter_boxes:\n            if this != other and any((this.id not in filter_scope['immune'] and set(filter_scope['scope']) <= ancestors_by_id[this.id] for filter_scope in filter_scope_by_key_and_field[str(other.id)].values())):\n                for child in filter_by_key_and_field[str(this.id)].values():\n                    if child['filterType'] == 'filter_select':\n                        for parent in filter_by_key_and_field[str(other.id)].values():\n                            if parent['filterType'] in {'filter_select', 'filter_time'} and parent['id'] not in child['cascadeParentIds']:\n                                child['cascadeParentIds'].append(parent['id'])\n    return sorted([fltr for key in filter_by_key_and_field for fltr in filter_by_key_and_field[key].values()], key=lambda fltr: fltr['filterType'])",
            "def convert_filter_scopes_to_native_filters(json_metadata: dict[str, Any], position_json: dict[str, Any], filter_boxes: list[Slice]) -> list[dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Convert the legacy filter scopes et al. to the native filter configuration.\\n\\n    Dashboard filter scopes are implicitly defined where an undefined scope implies\\n    no immunity, i.e., they apply to all applicable charts. The `convert_filter_scopes`\\n    method provides an explicit definition by extracting the underlying filter-box\\n    configurations.\\n\\n    Hierarchical legacy filters are defined via non-exclusion of peer or children\\n    filter-box charts whereas native hierarchical filters are defined via explicit\\n    parental relationships, i.e., the inverse.\\n\\n    :param json_metadata: The dashboard metadata\\n    :param position_json: The dashboard layout\\n    :param filter_boxes: The filter-box charts associated with the dashboard\\n    :returns: The native filter configuration\\n    :see: convert_filter_scopes\\n    '\n    shortid = ShortId()\n    default_filters = json.loads(json_metadata.get('default_filters') or '{}')\n    filter_scopes = json_metadata.get('filter_scopes', {})\n    filter_box_ids = {filter_box.id for filter_box in filter_boxes}\n    filter_scope_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    filter_by_key_and_field: dict[str, dict[str, dict[str, Any]]] = defaultdict(dict)\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        filter_scope_by_key_and_field[key] = {**convert_filter_scopes(json_metadata, filter_boxes=[filter_box]).get(filter_box.id, {}), **filter_scopes.get(key, {})}\n    for filter_box in filter_boxes:\n        key = str(filter_box.id)\n        params = json.loads(filter_box.params or '{}')\n        for (field, filter_scope) in filter_scope_by_key_and_field[key].items():\n            default = default_filters.get(key, {}).get(field)\n            fltr: dict[str, Any] = {'cascadeParentIds': [], 'id': f'NATIVE_FILTER-{shortid.generate()}', 'scope': {'rootPath': filter_scope['scope'], 'excluded': [id_ for id_ in filter_scope['immune'] if id_ not in filter_box_ids]}, 'type': 'NATIVE_FILTER'}\n            if field == '__time_col' and params.get('show_sqla_time_column'):\n                fltr.update({'filterType': 'filter_timecolumn', 'name': 'Time Column', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('granularity_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'granularity_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_grain' and params.get('show_sqla_time_granularity'):\n                fltr.update({'filterType': 'filter_timegrain', 'name': 'Time Grain', 'targets': [{'datasetId': filter_box.datasource_id}]})\n                if not default:\n                    default = params.get('time_grain_sqla')\n                if default:\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_grain_sqla': default}, 'filterState': {'value': [default]}}\n            elif field == '__time_range' and params.get('date_filter'):\n                fltr.update({'filterType': 'filter_time', 'name': 'Time Range', 'targets': [{}]})\n                if not default:\n                    default = params.get('time_range')\n                if default and default != 'No filter':\n                    fltr['defaultDataMask'] = {'extraFormData': {'time_range': default}, 'filterState': {'value': default}}\n            else:\n                for config in params.get('filter_configs') or []:\n                    if config['column'] == field:\n                        fltr.update({'controlValues': {'defaultToFirstItem': False, 'enableEmptyFilter': not config.get('clearable', True), 'inverseSelection': False, 'multiSelect': config.get('multiple', False), 'searchAllOptions': config.get('searchAllOptions', False)}, 'filterType': 'filter_select', 'name': config.get('label') or field, 'targets': [{'column': {'name': field}, 'datasetId': filter_box.datasource_id}]})\n                        if 'metric' in config:\n                            fltr['sortMetric'] = config['metric']\n                            fltr['controlValues']['sortAscending'] = config['asc']\n                        if params.get('adhoc_filters'):\n                            fltr['adhoc_filters'] = params['adhoc_filters']\n                        time_range = params.get('time_range')\n                        if time_range and time_range != 'No filter':\n                            fltr.update({'time_range': time_range, 'granularity_sqla': params.get('granularity_sqla')})\n                        if not default:\n                            default = config.get('defaultValue')\n                            if default and config['multiple']:\n                                default = default.split(';')\n                        if default:\n                            if not isinstance(default, list):\n                                default = [default]\n                            fltr['defaultDataMask'] = {'extraFormData': {'filters': [{'col': field, 'op': 'IN', 'val': default}]}, 'filterState': {'value': default}}\n                        break\n            if 'filterType' in fltr:\n                filter_by_key_and_field[key][field] = fltr\n    ancestors_by_id = defaultdict(set)\n    for filter_box in filter_boxes:\n        for value in position_json.values():\n            try:\n                if isinstance(value, dict) and value['type'] == 'CHART' and (value['meta']['chartId'] == filter_box.id) and value['parents']:\n                    ancestors_by_id[filter_box.id] = set(value['parents'])\n            except KeyError:\n                pass\n    for this in filter_boxes:\n        for other in filter_boxes:\n            if this != other and any((this.id not in filter_scope['immune'] and set(filter_scope['scope']) <= ancestors_by_id[this.id] for filter_scope in filter_scope_by_key_and_field[str(other.id)].values())):\n                for child in filter_by_key_and_field[str(this.id)].values():\n                    if child['filterType'] == 'filter_select':\n                        for parent in filter_by_key_and_field[str(other.id)].values():\n                            if parent['filterType'] in {'filter_select', 'filter_time'} and parent['id'] not in child['cascadeParentIds']:\n                                child['cascadeParentIds'].append(parent['id'])\n    return sorted([fltr for key in filter_by_key_and_field for fltr in filter_by_key_and_field[key].values()], key=lambda fltr: fltr['filterType'])"
        ]
    }
]