[
    {
        "func_name": "sharpe_fun",
        "original": "def sharpe_fun(w):\n    return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)",
        "mutated": [
            "def sharpe_fun(w):\n    if False:\n        i = 10\n    return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)",
            "def sharpe_fun(w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)",
            "def sharpe_fun(w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)",
            "def sharpe_fun(w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)",
            "def sharpe_fun(w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)"
        ]
    },
    {
        "func_name": "optimal_weights",
        "original": "def optimal_weights(MU, COV, Rf=0, w_max=1, desired_mean=None, desired_std=None):\n    \"\"\"\n    Compute the optimal weights for a portfolio containing a risk free asset and stocks.\n    MU = vector of mean\n    COV = covariance matrix\n    Rf = risk free return\n    w_max = maximum weight bound for the stock portfolio\n    desired_mean = desired mean of the portfolio\n    desired_std = desired standard deviation of the portfolio\n    \"\"\"\n    if desired_mean is not None and desired_std is not None:\n        raise ValueError('One among desired_mean and desired_std must be None')\n    if (desired_mean is not None or desired_std is not None) and Rf == 0:\n        raise ValueError('We just optimize the Sharpe ratio, no computation of efficient frontier')\n    N = len(MU)\n    bounds = Bounds(0, w_max)\n    linear_constraint = LinearConstraint(np.ones(N, dtype=int), 1, 1)\n    weights = np.ones(N)\n    x0 = weights / np.sum(weights)\n\n    def sharpe_fun(w):\n        return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)\n    res = minimize(sharpe_fun, x0=x0, method='trust-constr', constraints=linear_constraint, bounds=bounds)\n    print(res.message + '\\n')\n    w_sr = res.x\n    std_stock_portf = np.sqrt(w_sr @ COV @ w_sr)\n    mean_stock_portf = MU @ w_sr\n    stock_port_results = {'Sharpe Ratio': -sharpe_fun(w_sr), 'stock weights': w_sr.round(4), 'stock portfolio': {'std': std_stock_portf.round(6), 'mean': mean_stock_portf.round(6)}}\n    if desired_mean is None and desired_std is None:\n        return stock_port_results\n    elif desired_mean is None and desired_std is not None:\n        w_stock = desired_std / std_stock_portf\n        if desired_std > std_stock_portf:\n            print('The risk you take is higher than the tangency portfolio risk                 ==> SHORT POSTION')\n        tot_port_mean = Rf + w_stock * (mean_stock_portf - Rf)\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': desired_std, 'mean': tot_port_mean.round(6)}}\n    elif desired_mean is not None and desired_std is None:\n        w_stock = (desired_mean - Rf) / (mean_stock_portf - Rf)\n        if desired_mean > mean_stock_portf:\n            print('The return you want is higher than the tangency portfolio return                     ==> SHORT POSTION')\n        tot_port_std = w_stock * std_stock_portf\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': tot_port_std.round(6), 'mean': desired_mean}}",
        "mutated": [
            "def optimal_weights(MU, COV, Rf=0, w_max=1, desired_mean=None, desired_std=None):\n    if False:\n        i = 10\n    '\\n    Compute the optimal weights for a portfolio containing a risk free asset and stocks.\\n    MU = vector of mean\\n    COV = covariance matrix\\n    Rf = risk free return\\n    w_max = maximum weight bound for the stock portfolio\\n    desired_mean = desired mean of the portfolio\\n    desired_std = desired standard deviation of the portfolio\\n    '\n    if desired_mean is not None and desired_std is not None:\n        raise ValueError('One among desired_mean and desired_std must be None')\n    if (desired_mean is not None or desired_std is not None) and Rf == 0:\n        raise ValueError('We just optimize the Sharpe ratio, no computation of efficient frontier')\n    N = len(MU)\n    bounds = Bounds(0, w_max)\n    linear_constraint = LinearConstraint(np.ones(N, dtype=int), 1, 1)\n    weights = np.ones(N)\n    x0 = weights / np.sum(weights)\n\n    def sharpe_fun(w):\n        return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)\n    res = minimize(sharpe_fun, x0=x0, method='trust-constr', constraints=linear_constraint, bounds=bounds)\n    print(res.message + '\\n')\n    w_sr = res.x\n    std_stock_portf = np.sqrt(w_sr @ COV @ w_sr)\n    mean_stock_portf = MU @ w_sr\n    stock_port_results = {'Sharpe Ratio': -sharpe_fun(w_sr), 'stock weights': w_sr.round(4), 'stock portfolio': {'std': std_stock_portf.round(6), 'mean': mean_stock_portf.round(6)}}\n    if desired_mean is None and desired_std is None:\n        return stock_port_results\n    elif desired_mean is None and desired_std is not None:\n        w_stock = desired_std / std_stock_portf\n        if desired_std > std_stock_portf:\n            print('The risk you take is higher than the tangency portfolio risk                 ==> SHORT POSTION')\n        tot_port_mean = Rf + w_stock * (mean_stock_portf - Rf)\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': desired_std, 'mean': tot_port_mean.round(6)}}\n    elif desired_mean is not None and desired_std is None:\n        w_stock = (desired_mean - Rf) / (mean_stock_portf - Rf)\n        if desired_mean > mean_stock_portf:\n            print('The return you want is higher than the tangency portfolio return                     ==> SHORT POSTION')\n        tot_port_std = w_stock * std_stock_portf\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': tot_port_std.round(6), 'mean': desired_mean}}",
            "def optimal_weights(MU, COV, Rf=0, w_max=1, desired_mean=None, desired_std=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the optimal weights for a portfolio containing a risk free asset and stocks.\\n    MU = vector of mean\\n    COV = covariance matrix\\n    Rf = risk free return\\n    w_max = maximum weight bound for the stock portfolio\\n    desired_mean = desired mean of the portfolio\\n    desired_std = desired standard deviation of the portfolio\\n    '\n    if desired_mean is not None and desired_std is not None:\n        raise ValueError('One among desired_mean and desired_std must be None')\n    if (desired_mean is not None or desired_std is not None) and Rf == 0:\n        raise ValueError('We just optimize the Sharpe ratio, no computation of efficient frontier')\n    N = len(MU)\n    bounds = Bounds(0, w_max)\n    linear_constraint = LinearConstraint(np.ones(N, dtype=int), 1, 1)\n    weights = np.ones(N)\n    x0 = weights / np.sum(weights)\n\n    def sharpe_fun(w):\n        return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)\n    res = minimize(sharpe_fun, x0=x0, method='trust-constr', constraints=linear_constraint, bounds=bounds)\n    print(res.message + '\\n')\n    w_sr = res.x\n    std_stock_portf = np.sqrt(w_sr @ COV @ w_sr)\n    mean_stock_portf = MU @ w_sr\n    stock_port_results = {'Sharpe Ratio': -sharpe_fun(w_sr), 'stock weights': w_sr.round(4), 'stock portfolio': {'std': std_stock_portf.round(6), 'mean': mean_stock_portf.round(6)}}\n    if desired_mean is None and desired_std is None:\n        return stock_port_results\n    elif desired_mean is None and desired_std is not None:\n        w_stock = desired_std / std_stock_portf\n        if desired_std > std_stock_portf:\n            print('The risk you take is higher than the tangency portfolio risk                 ==> SHORT POSTION')\n        tot_port_mean = Rf + w_stock * (mean_stock_portf - Rf)\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': desired_std, 'mean': tot_port_mean.round(6)}}\n    elif desired_mean is not None and desired_std is None:\n        w_stock = (desired_mean - Rf) / (mean_stock_portf - Rf)\n        if desired_mean > mean_stock_portf:\n            print('The return you want is higher than the tangency portfolio return                     ==> SHORT POSTION')\n        tot_port_std = w_stock * std_stock_portf\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': tot_port_std.round(6), 'mean': desired_mean}}",
            "def optimal_weights(MU, COV, Rf=0, w_max=1, desired_mean=None, desired_std=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the optimal weights for a portfolio containing a risk free asset and stocks.\\n    MU = vector of mean\\n    COV = covariance matrix\\n    Rf = risk free return\\n    w_max = maximum weight bound for the stock portfolio\\n    desired_mean = desired mean of the portfolio\\n    desired_std = desired standard deviation of the portfolio\\n    '\n    if desired_mean is not None and desired_std is not None:\n        raise ValueError('One among desired_mean and desired_std must be None')\n    if (desired_mean is not None or desired_std is not None) and Rf == 0:\n        raise ValueError('We just optimize the Sharpe ratio, no computation of efficient frontier')\n    N = len(MU)\n    bounds = Bounds(0, w_max)\n    linear_constraint = LinearConstraint(np.ones(N, dtype=int), 1, 1)\n    weights = np.ones(N)\n    x0 = weights / np.sum(weights)\n\n    def sharpe_fun(w):\n        return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)\n    res = minimize(sharpe_fun, x0=x0, method='trust-constr', constraints=linear_constraint, bounds=bounds)\n    print(res.message + '\\n')\n    w_sr = res.x\n    std_stock_portf = np.sqrt(w_sr @ COV @ w_sr)\n    mean_stock_portf = MU @ w_sr\n    stock_port_results = {'Sharpe Ratio': -sharpe_fun(w_sr), 'stock weights': w_sr.round(4), 'stock portfolio': {'std': std_stock_portf.round(6), 'mean': mean_stock_portf.round(6)}}\n    if desired_mean is None and desired_std is None:\n        return stock_port_results\n    elif desired_mean is None and desired_std is not None:\n        w_stock = desired_std / std_stock_portf\n        if desired_std > std_stock_portf:\n            print('The risk you take is higher than the tangency portfolio risk                 ==> SHORT POSTION')\n        tot_port_mean = Rf + w_stock * (mean_stock_portf - Rf)\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': desired_std, 'mean': tot_port_mean.round(6)}}\n    elif desired_mean is not None and desired_std is None:\n        w_stock = (desired_mean - Rf) / (mean_stock_portf - Rf)\n        if desired_mean > mean_stock_portf:\n            print('The return you want is higher than the tangency portfolio return                     ==> SHORT POSTION')\n        tot_port_std = w_stock * std_stock_portf\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': tot_port_std.round(6), 'mean': desired_mean}}",
            "def optimal_weights(MU, COV, Rf=0, w_max=1, desired_mean=None, desired_std=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the optimal weights for a portfolio containing a risk free asset and stocks.\\n    MU = vector of mean\\n    COV = covariance matrix\\n    Rf = risk free return\\n    w_max = maximum weight bound for the stock portfolio\\n    desired_mean = desired mean of the portfolio\\n    desired_std = desired standard deviation of the portfolio\\n    '\n    if desired_mean is not None and desired_std is not None:\n        raise ValueError('One among desired_mean and desired_std must be None')\n    if (desired_mean is not None or desired_std is not None) and Rf == 0:\n        raise ValueError('We just optimize the Sharpe ratio, no computation of efficient frontier')\n    N = len(MU)\n    bounds = Bounds(0, w_max)\n    linear_constraint = LinearConstraint(np.ones(N, dtype=int), 1, 1)\n    weights = np.ones(N)\n    x0 = weights / np.sum(weights)\n\n    def sharpe_fun(w):\n        return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)\n    res = minimize(sharpe_fun, x0=x0, method='trust-constr', constraints=linear_constraint, bounds=bounds)\n    print(res.message + '\\n')\n    w_sr = res.x\n    std_stock_portf = np.sqrt(w_sr @ COV @ w_sr)\n    mean_stock_portf = MU @ w_sr\n    stock_port_results = {'Sharpe Ratio': -sharpe_fun(w_sr), 'stock weights': w_sr.round(4), 'stock portfolio': {'std': std_stock_portf.round(6), 'mean': mean_stock_portf.round(6)}}\n    if desired_mean is None and desired_std is None:\n        return stock_port_results\n    elif desired_mean is None and desired_std is not None:\n        w_stock = desired_std / std_stock_portf\n        if desired_std > std_stock_portf:\n            print('The risk you take is higher than the tangency portfolio risk                 ==> SHORT POSTION')\n        tot_port_mean = Rf + w_stock * (mean_stock_portf - Rf)\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': desired_std, 'mean': tot_port_mean.round(6)}}\n    elif desired_mean is not None and desired_std is None:\n        w_stock = (desired_mean - Rf) / (mean_stock_portf - Rf)\n        if desired_mean > mean_stock_portf:\n            print('The return you want is higher than the tangency portfolio return                     ==> SHORT POSTION')\n        tot_port_std = w_stock * std_stock_portf\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': tot_port_std.round(6), 'mean': desired_mean}}",
            "def optimal_weights(MU, COV, Rf=0, w_max=1, desired_mean=None, desired_std=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the optimal weights for a portfolio containing a risk free asset and stocks.\\n    MU = vector of mean\\n    COV = covariance matrix\\n    Rf = risk free return\\n    w_max = maximum weight bound for the stock portfolio\\n    desired_mean = desired mean of the portfolio\\n    desired_std = desired standard deviation of the portfolio\\n    '\n    if desired_mean is not None and desired_std is not None:\n        raise ValueError('One among desired_mean and desired_std must be None')\n    if (desired_mean is not None or desired_std is not None) and Rf == 0:\n        raise ValueError('We just optimize the Sharpe ratio, no computation of efficient frontier')\n    N = len(MU)\n    bounds = Bounds(0, w_max)\n    linear_constraint = LinearConstraint(np.ones(N, dtype=int), 1, 1)\n    weights = np.ones(N)\n    x0 = weights / np.sum(weights)\n\n    def sharpe_fun(w):\n        return -(MU @ w - Rf) / np.sqrt(w.T @ COV @ w)\n    res = minimize(sharpe_fun, x0=x0, method='trust-constr', constraints=linear_constraint, bounds=bounds)\n    print(res.message + '\\n')\n    w_sr = res.x\n    std_stock_portf = np.sqrt(w_sr @ COV @ w_sr)\n    mean_stock_portf = MU @ w_sr\n    stock_port_results = {'Sharpe Ratio': -sharpe_fun(w_sr), 'stock weights': w_sr.round(4), 'stock portfolio': {'std': std_stock_portf.round(6), 'mean': mean_stock_portf.round(6)}}\n    if desired_mean is None and desired_std is None:\n        return stock_port_results\n    elif desired_mean is None and desired_std is not None:\n        w_stock = desired_std / std_stock_portf\n        if desired_std > std_stock_portf:\n            print('The risk you take is higher than the tangency portfolio risk                 ==> SHORT POSTION')\n        tot_port_mean = Rf + w_stock * (mean_stock_portf - Rf)\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': desired_std, 'mean': tot_port_mean.round(6)}}\n    elif desired_mean is not None and desired_std is None:\n        w_stock = (desired_mean - Rf) / (mean_stock_portf - Rf)\n        if desired_mean > mean_stock_portf:\n            print('The return you want is higher than the tangency portfolio return                     ==> SHORT POSTION')\n        tot_port_std = w_stock * std_stock_portf\n        return {**stock_port_results, 'Bond + Stock weights': {'Bond': (1 - w_stock).round(4), 'Stock': w_stock.round(4)}, 'Total portfolio': {'std': tot_port_std.round(6), 'mean': desired_mean}}"
        ]
    }
]