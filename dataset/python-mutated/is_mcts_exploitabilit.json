[
    {
        "func_name": "construct_is_mcts_policy",
        "original": "def construct_is_mcts_policy(game, state, tabular_policy, bot, searched):\n    \"\"\"Constructs a tabular policy from independent bot calls.\n\n  Args:\n    game: an OpenSpiel game,\n    state: an OpenSpiel state to start the tree walk from,\n    tabular_policy: a policy.TabularPolicy for this game,\n    bot: the bot to get the policy from at each state\n    searched: a dictionary of information states already search (empty to begin)\n  \"\"\"\n    if state.is_terminal():\n        return\n    elif state.is_chance_node():\n        outcomes = state.legal_actions()\n        for outcome in outcomes:\n            new_state = state.clone()\n            new_state.apply_action(outcome)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)\n    else:\n        infostate_key = state.information_state_string()\n        if infostate_key not in searched:\n            searched[infostate_key] = True\n            infostate_policy = bot.get_policy(state)\n            tabular_state_policy = tabular_policy.policy_for_key(infostate_key)\n            for (action, prob) in infostate_policy:\n                tabular_state_policy[action] = prob\n        for action in state.legal_actions():\n            new_state = state.clone()\n            new_state.apply_action(action)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)",
        "mutated": [
            "def construct_is_mcts_policy(game, state, tabular_policy, bot, searched):\n    if False:\n        i = 10\n    'Constructs a tabular policy from independent bot calls.\\n\\n  Args:\\n    game: an OpenSpiel game,\\n    state: an OpenSpiel state to start the tree walk from,\\n    tabular_policy: a policy.TabularPolicy for this game,\\n    bot: the bot to get the policy from at each state\\n    searched: a dictionary of information states already search (empty to begin)\\n  '\n    if state.is_terminal():\n        return\n    elif state.is_chance_node():\n        outcomes = state.legal_actions()\n        for outcome in outcomes:\n            new_state = state.clone()\n            new_state.apply_action(outcome)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)\n    else:\n        infostate_key = state.information_state_string()\n        if infostate_key not in searched:\n            searched[infostate_key] = True\n            infostate_policy = bot.get_policy(state)\n            tabular_state_policy = tabular_policy.policy_for_key(infostate_key)\n            for (action, prob) in infostate_policy:\n                tabular_state_policy[action] = prob\n        for action in state.legal_actions():\n            new_state = state.clone()\n            new_state.apply_action(action)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)",
            "def construct_is_mcts_policy(game, state, tabular_policy, bot, searched):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Constructs a tabular policy from independent bot calls.\\n\\n  Args:\\n    game: an OpenSpiel game,\\n    state: an OpenSpiel state to start the tree walk from,\\n    tabular_policy: a policy.TabularPolicy for this game,\\n    bot: the bot to get the policy from at each state\\n    searched: a dictionary of information states already search (empty to begin)\\n  '\n    if state.is_terminal():\n        return\n    elif state.is_chance_node():\n        outcomes = state.legal_actions()\n        for outcome in outcomes:\n            new_state = state.clone()\n            new_state.apply_action(outcome)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)\n    else:\n        infostate_key = state.information_state_string()\n        if infostate_key not in searched:\n            searched[infostate_key] = True\n            infostate_policy = bot.get_policy(state)\n            tabular_state_policy = tabular_policy.policy_for_key(infostate_key)\n            for (action, prob) in infostate_policy:\n                tabular_state_policy[action] = prob\n        for action in state.legal_actions():\n            new_state = state.clone()\n            new_state.apply_action(action)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)",
            "def construct_is_mcts_policy(game, state, tabular_policy, bot, searched):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Constructs a tabular policy from independent bot calls.\\n\\n  Args:\\n    game: an OpenSpiel game,\\n    state: an OpenSpiel state to start the tree walk from,\\n    tabular_policy: a policy.TabularPolicy for this game,\\n    bot: the bot to get the policy from at each state\\n    searched: a dictionary of information states already search (empty to begin)\\n  '\n    if state.is_terminal():\n        return\n    elif state.is_chance_node():\n        outcomes = state.legal_actions()\n        for outcome in outcomes:\n            new_state = state.clone()\n            new_state.apply_action(outcome)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)\n    else:\n        infostate_key = state.information_state_string()\n        if infostate_key not in searched:\n            searched[infostate_key] = True\n            infostate_policy = bot.get_policy(state)\n            tabular_state_policy = tabular_policy.policy_for_key(infostate_key)\n            for (action, prob) in infostate_policy:\n                tabular_state_policy[action] = prob\n        for action in state.legal_actions():\n            new_state = state.clone()\n            new_state.apply_action(action)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)",
            "def construct_is_mcts_policy(game, state, tabular_policy, bot, searched):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Constructs a tabular policy from independent bot calls.\\n\\n  Args:\\n    game: an OpenSpiel game,\\n    state: an OpenSpiel state to start the tree walk from,\\n    tabular_policy: a policy.TabularPolicy for this game,\\n    bot: the bot to get the policy from at each state\\n    searched: a dictionary of information states already search (empty to begin)\\n  '\n    if state.is_terminal():\n        return\n    elif state.is_chance_node():\n        outcomes = state.legal_actions()\n        for outcome in outcomes:\n            new_state = state.clone()\n            new_state.apply_action(outcome)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)\n    else:\n        infostate_key = state.information_state_string()\n        if infostate_key not in searched:\n            searched[infostate_key] = True\n            infostate_policy = bot.get_policy(state)\n            tabular_state_policy = tabular_policy.policy_for_key(infostate_key)\n            for (action, prob) in infostate_policy:\n                tabular_state_policy[action] = prob\n        for action in state.legal_actions():\n            new_state = state.clone()\n            new_state.apply_action(action)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)",
            "def construct_is_mcts_policy(game, state, tabular_policy, bot, searched):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Constructs a tabular policy from independent bot calls.\\n\\n  Args:\\n    game: an OpenSpiel game,\\n    state: an OpenSpiel state to start the tree walk from,\\n    tabular_policy: a policy.TabularPolicy for this game,\\n    bot: the bot to get the policy from at each state\\n    searched: a dictionary of information states already search (empty to begin)\\n  '\n    if state.is_terminal():\n        return\n    elif state.is_chance_node():\n        outcomes = state.legal_actions()\n        for outcome in outcomes:\n            new_state = state.clone()\n            new_state.apply_action(outcome)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)\n    else:\n        infostate_key = state.information_state_string()\n        if infostate_key not in searched:\n            searched[infostate_key] = True\n            infostate_policy = bot.get_policy(state)\n            tabular_state_policy = tabular_policy.policy_for_key(infostate_key)\n            for (action, prob) in infostate_policy:\n                tabular_state_policy[action] = prob\n        for action in state.legal_actions():\n            new_state = state.clone()\n            new_state.apply_action(action)\n            construct_is_mcts_policy(game, new_state, tabular_policy, bot, searched)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(_):\n    game = pyspiel.load_game(FLAGS.game)\n    evaluator = pyspiel.RandomRolloutEvaluator(1, SEED)\n    min_expl = game.max_utility() - game.min_utility()\n    print('{:>5} {:>10} {:>50} {:>20}'.format('max_sims', 'uct_c', 'final_policy_type', 'exploitability'))\n    for max_simulations in [10, 100, 1000, 10000]:\n        for uct_c in [0.2, 0.5, 1.0, 2.0, 4.0]:\n            for final_policy_type in [pyspiel.ISMCTSFinalPolicyType.NORMALIZED_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VALUE]:\n                tabular_policy = policy.TabularPolicy(game)\n                bot = pyspiel.ISMCTSBot(SEED, evaluator, uct_c, max_simulations, -1, final_policy_type, False, False)\n                searched = {}\n                construct_is_mcts_policy(game, game.new_initial_state(), tabular_policy, bot, searched)\n                expl = exploitability.exploitability(game, tabular_policy)\n                print('{:>5} {:>10} {:>50} {:>20}'.format(max_simulations, uct_c, str(final_policy_type), expl))\n                if expl < min_expl:\n                    min_expl = expl\n    print('Min expl: {}'.format(min_expl))",
        "mutated": [
            "def main(_):\n    if False:\n        i = 10\n    game = pyspiel.load_game(FLAGS.game)\n    evaluator = pyspiel.RandomRolloutEvaluator(1, SEED)\n    min_expl = game.max_utility() - game.min_utility()\n    print('{:>5} {:>10} {:>50} {:>20}'.format('max_sims', 'uct_c', 'final_policy_type', 'exploitability'))\n    for max_simulations in [10, 100, 1000, 10000]:\n        for uct_c in [0.2, 0.5, 1.0, 2.0, 4.0]:\n            for final_policy_type in [pyspiel.ISMCTSFinalPolicyType.NORMALIZED_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VALUE]:\n                tabular_policy = policy.TabularPolicy(game)\n                bot = pyspiel.ISMCTSBot(SEED, evaluator, uct_c, max_simulations, -1, final_policy_type, False, False)\n                searched = {}\n                construct_is_mcts_policy(game, game.new_initial_state(), tabular_policy, bot, searched)\n                expl = exploitability.exploitability(game, tabular_policy)\n                print('{:>5} {:>10} {:>50} {:>20}'.format(max_simulations, uct_c, str(final_policy_type), expl))\n                if expl < min_expl:\n                    min_expl = expl\n    print('Min expl: {}'.format(min_expl))",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    game = pyspiel.load_game(FLAGS.game)\n    evaluator = pyspiel.RandomRolloutEvaluator(1, SEED)\n    min_expl = game.max_utility() - game.min_utility()\n    print('{:>5} {:>10} {:>50} {:>20}'.format('max_sims', 'uct_c', 'final_policy_type', 'exploitability'))\n    for max_simulations in [10, 100, 1000, 10000]:\n        for uct_c in [0.2, 0.5, 1.0, 2.0, 4.0]:\n            for final_policy_type in [pyspiel.ISMCTSFinalPolicyType.NORMALIZED_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VALUE]:\n                tabular_policy = policy.TabularPolicy(game)\n                bot = pyspiel.ISMCTSBot(SEED, evaluator, uct_c, max_simulations, -1, final_policy_type, False, False)\n                searched = {}\n                construct_is_mcts_policy(game, game.new_initial_state(), tabular_policy, bot, searched)\n                expl = exploitability.exploitability(game, tabular_policy)\n                print('{:>5} {:>10} {:>50} {:>20}'.format(max_simulations, uct_c, str(final_policy_type), expl))\n                if expl < min_expl:\n                    min_expl = expl\n    print('Min expl: {}'.format(min_expl))",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    game = pyspiel.load_game(FLAGS.game)\n    evaluator = pyspiel.RandomRolloutEvaluator(1, SEED)\n    min_expl = game.max_utility() - game.min_utility()\n    print('{:>5} {:>10} {:>50} {:>20}'.format('max_sims', 'uct_c', 'final_policy_type', 'exploitability'))\n    for max_simulations in [10, 100, 1000, 10000]:\n        for uct_c in [0.2, 0.5, 1.0, 2.0, 4.0]:\n            for final_policy_type in [pyspiel.ISMCTSFinalPolicyType.NORMALIZED_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VALUE]:\n                tabular_policy = policy.TabularPolicy(game)\n                bot = pyspiel.ISMCTSBot(SEED, evaluator, uct_c, max_simulations, -1, final_policy_type, False, False)\n                searched = {}\n                construct_is_mcts_policy(game, game.new_initial_state(), tabular_policy, bot, searched)\n                expl = exploitability.exploitability(game, tabular_policy)\n                print('{:>5} {:>10} {:>50} {:>20}'.format(max_simulations, uct_c, str(final_policy_type), expl))\n                if expl < min_expl:\n                    min_expl = expl\n    print('Min expl: {}'.format(min_expl))",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    game = pyspiel.load_game(FLAGS.game)\n    evaluator = pyspiel.RandomRolloutEvaluator(1, SEED)\n    min_expl = game.max_utility() - game.min_utility()\n    print('{:>5} {:>10} {:>50} {:>20}'.format('max_sims', 'uct_c', 'final_policy_type', 'exploitability'))\n    for max_simulations in [10, 100, 1000, 10000]:\n        for uct_c in [0.2, 0.5, 1.0, 2.0, 4.0]:\n            for final_policy_type in [pyspiel.ISMCTSFinalPolicyType.NORMALIZED_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VALUE]:\n                tabular_policy = policy.TabularPolicy(game)\n                bot = pyspiel.ISMCTSBot(SEED, evaluator, uct_c, max_simulations, -1, final_policy_type, False, False)\n                searched = {}\n                construct_is_mcts_policy(game, game.new_initial_state(), tabular_policy, bot, searched)\n                expl = exploitability.exploitability(game, tabular_policy)\n                print('{:>5} {:>10} {:>50} {:>20}'.format(max_simulations, uct_c, str(final_policy_type), expl))\n                if expl < min_expl:\n                    min_expl = expl\n    print('Min expl: {}'.format(min_expl))",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    game = pyspiel.load_game(FLAGS.game)\n    evaluator = pyspiel.RandomRolloutEvaluator(1, SEED)\n    min_expl = game.max_utility() - game.min_utility()\n    print('{:>5} {:>10} {:>50} {:>20}'.format('max_sims', 'uct_c', 'final_policy_type', 'exploitability'))\n    for max_simulations in [10, 100, 1000, 10000]:\n        for uct_c in [0.2, 0.5, 1.0, 2.0, 4.0]:\n            for final_policy_type in [pyspiel.ISMCTSFinalPolicyType.NORMALIZED_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VISIT_COUNT, pyspiel.ISMCTSFinalPolicyType.MAX_VALUE]:\n                tabular_policy = policy.TabularPolicy(game)\n                bot = pyspiel.ISMCTSBot(SEED, evaluator, uct_c, max_simulations, -1, final_policy_type, False, False)\n                searched = {}\n                construct_is_mcts_policy(game, game.new_initial_state(), tabular_policy, bot, searched)\n                expl = exploitability.exploitability(game, tabular_policy)\n                print('{:>5} {:>10} {:>50} {:>20}'.format(max_simulations, uct_c, str(final_policy_type), expl))\n                if expl < min_expl:\n                    min_expl = expl\n    print('Min expl: {}'.format(min_expl))"
        ]
    }
]