[
    {
        "func_name": "__init__",
        "original": "def __init__(self, data='', gap_char='-', rf_table=None):\n    \"\"\"Initialize the class.\"\"\"\n    Seq.__init__(self, data.upper())\n    self.gap_char = gap_char\n    if rf_table is None:\n        length = len(self)\n        if length % 3 != 0:\n            raise ValueError('Sequence length is not a multiple of three (i.e. a whole number of codons)')\n        self.rf_table = list(range(0, length - self.count(gap_char), 3))\n    else:\n        if not isinstance(rf_table, (tuple, list)):\n            raise TypeError('rf_table should be a tuple or list object')\n        if not all((isinstance(i, int) for i in rf_table)):\n            raise TypeError('Elements in rf_table should be int that specify the codon positions of the sequence')\n        self.rf_table = rf_table",
        "mutated": [
            "def __init__(self, data='', gap_char='-', rf_table=None):\n    if False:\n        i = 10\n    'Initialize the class.'\n    Seq.__init__(self, data.upper())\n    self.gap_char = gap_char\n    if rf_table is None:\n        length = len(self)\n        if length % 3 != 0:\n            raise ValueError('Sequence length is not a multiple of three (i.e. a whole number of codons)')\n        self.rf_table = list(range(0, length - self.count(gap_char), 3))\n    else:\n        if not isinstance(rf_table, (tuple, list)):\n            raise TypeError('rf_table should be a tuple or list object')\n        if not all((isinstance(i, int) for i in rf_table)):\n            raise TypeError('Elements in rf_table should be int that specify the codon positions of the sequence')\n        self.rf_table = rf_table",
            "def __init__(self, data='', gap_char='-', rf_table=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize the class.'\n    Seq.__init__(self, data.upper())\n    self.gap_char = gap_char\n    if rf_table is None:\n        length = len(self)\n        if length % 3 != 0:\n            raise ValueError('Sequence length is not a multiple of three (i.e. a whole number of codons)')\n        self.rf_table = list(range(0, length - self.count(gap_char), 3))\n    else:\n        if not isinstance(rf_table, (tuple, list)):\n            raise TypeError('rf_table should be a tuple or list object')\n        if not all((isinstance(i, int) for i in rf_table)):\n            raise TypeError('Elements in rf_table should be int that specify the codon positions of the sequence')\n        self.rf_table = rf_table",
            "def __init__(self, data='', gap_char='-', rf_table=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize the class.'\n    Seq.__init__(self, data.upper())\n    self.gap_char = gap_char\n    if rf_table is None:\n        length = len(self)\n        if length % 3 != 0:\n            raise ValueError('Sequence length is not a multiple of three (i.e. a whole number of codons)')\n        self.rf_table = list(range(0, length - self.count(gap_char), 3))\n    else:\n        if not isinstance(rf_table, (tuple, list)):\n            raise TypeError('rf_table should be a tuple or list object')\n        if not all((isinstance(i, int) for i in rf_table)):\n            raise TypeError('Elements in rf_table should be int that specify the codon positions of the sequence')\n        self.rf_table = rf_table",
            "def __init__(self, data='', gap_char='-', rf_table=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize the class.'\n    Seq.__init__(self, data.upper())\n    self.gap_char = gap_char\n    if rf_table is None:\n        length = len(self)\n        if length % 3 != 0:\n            raise ValueError('Sequence length is not a multiple of three (i.e. a whole number of codons)')\n        self.rf_table = list(range(0, length - self.count(gap_char), 3))\n    else:\n        if not isinstance(rf_table, (tuple, list)):\n            raise TypeError('rf_table should be a tuple or list object')\n        if not all((isinstance(i, int) for i in rf_table)):\n            raise TypeError('Elements in rf_table should be int that specify the codon positions of the sequence')\n        self.rf_table = rf_table",
            "def __init__(self, data='', gap_char='-', rf_table=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize the class.'\n    Seq.__init__(self, data.upper())\n    self.gap_char = gap_char\n    if rf_table is None:\n        length = len(self)\n        if length % 3 != 0:\n            raise ValueError('Sequence length is not a multiple of three (i.e. a whole number of codons)')\n        self.rf_table = list(range(0, length - self.count(gap_char), 3))\n    else:\n        if not isinstance(rf_table, (tuple, list)):\n            raise TypeError('rf_table should be a tuple or list object')\n        if not all((isinstance(i, int) for i in rf_table)):\n            raise TypeError('Elements in rf_table should be int that specify the codon positions of the sequence')\n        self.rf_table = rf_table"
        ]
    },
    {
        "func_name": "cslice",
        "original": "def cslice(p):\n    aa_slice = aa_index[p]\n    codon_slice = ''\n    for i in aa_slice:\n        codon_slice += self[i * 3:i * 3 + 3]\n    return str(codon_slice)",
        "mutated": [
            "def cslice(p):\n    if False:\n        i = 10\n    aa_slice = aa_index[p]\n    codon_slice = ''\n    for i in aa_slice:\n        codon_slice += self[i * 3:i * 3 + 3]\n    return str(codon_slice)",
            "def cslice(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    aa_slice = aa_index[p]\n    codon_slice = ''\n    for i in aa_slice:\n        codon_slice += self[i * 3:i * 3 + 3]\n    return str(codon_slice)",
            "def cslice(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    aa_slice = aa_index[p]\n    codon_slice = ''\n    for i in aa_slice:\n        codon_slice += self[i * 3:i * 3 + 3]\n    return str(codon_slice)",
            "def cslice(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    aa_slice = aa_index[p]\n    codon_slice = ''\n    for i in aa_slice:\n        codon_slice += self[i * 3:i * 3 + 3]\n    return str(codon_slice)",
            "def cslice(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    aa_slice = aa_index[p]\n    codon_slice = ''\n    for i in aa_slice:\n        codon_slice += self[i * 3:i * 3 + 3]\n    return str(codon_slice)"
        ]
    },
    {
        "func_name": "get_codon",
        "original": "def get_codon(self, index):\n    \"\"\"Get the index codon from the sequence.\"\"\"\n    if len({i % 3 for i in self.rf_table}) != 1:\n        raise RuntimeError('frameshift detected. CodonSeq object is not able to deal with codon sequence with frameshift. Please use normal slice option.')\n    if isinstance(index, int):\n        if index != -1:\n            return str(self[index * 3:(index + 1) * 3])\n        else:\n            return str(self[index * 3:])\n    else:\n        aa_index = range(len(self) // 3)\n\n        def cslice(p):\n            aa_slice = aa_index[p]\n            codon_slice = ''\n            for i in aa_slice:\n                codon_slice += self[i * 3:i * 3 + 3]\n            return str(codon_slice)\n        codon_slice = cslice(index)\n        return CodonSeq(codon_slice)",
        "mutated": [
            "def get_codon(self, index):\n    if False:\n        i = 10\n    'Get the index codon from the sequence.'\n    if len({i % 3 for i in self.rf_table}) != 1:\n        raise RuntimeError('frameshift detected. CodonSeq object is not able to deal with codon sequence with frameshift. Please use normal slice option.')\n    if isinstance(index, int):\n        if index != -1:\n            return str(self[index * 3:(index + 1) * 3])\n        else:\n            return str(self[index * 3:])\n    else:\n        aa_index = range(len(self) // 3)\n\n        def cslice(p):\n            aa_slice = aa_index[p]\n            codon_slice = ''\n            for i in aa_slice:\n                codon_slice += self[i * 3:i * 3 + 3]\n            return str(codon_slice)\n        codon_slice = cslice(index)\n        return CodonSeq(codon_slice)",
            "def get_codon(self, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get the index codon from the sequence.'\n    if len({i % 3 for i in self.rf_table}) != 1:\n        raise RuntimeError('frameshift detected. CodonSeq object is not able to deal with codon sequence with frameshift. Please use normal slice option.')\n    if isinstance(index, int):\n        if index != -1:\n            return str(self[index * 3:(index + 1) * 3])\n        else:\n            return str(self[index * 3:])\n    else:\n        aa_index = range(len(self) // 3)\n\n        def cslice(p):\n            aa_slice = aa_index[p]\n            codon_slice = ''\n            for i in aa_slice:\n                codon_slice += self[i * 3:i * 3 + 3]\n            return str(codon_slice)\n        codon_slice = cslice(index)\n        return CodonSeq(codon_slice)",
            "def get_codon(self, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get the index codon from the sequence.'\n    if len({i % 3 for i in self.rf_table}) != 1:\n        raise RuntimeError('frameshift detected. CodonSeq object is not able to deal with codon sequence with frameshift. Please use normal slice option.')\n    if isinstance(index, int):\n        if index != -1:\n            return str(self[index * 3:(index + 1) * 3])\n        else:\n            return str(self[index * 3:])\n    else:\n        aa_index = range(len(self) // 3)\n\n        def cslice(p):\n            aa_slice = aa_index[p]\n            codon_slice = ''\n            for i in aa_slice:\n                codon_slice += self[i * 3:i * 3 + 3]\n            return str(codon_slice)\n        codon_slice = cslice(index)\n        return CodonSeq(codon_slice)",
            "def get_codon(self, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get the index codon from the sequence.'\n    if len({i % 3 for i in self.rf_table}) != 1:\n        raise RuntimeError('frameshift detected. CodonSeq object is not able to deal with codon sequence with frameshift. Please use normal slice option.')\n    if isinstance(index, int):\n        if index != -1:\n            return str(self[index * 3:(index + 1) * 3])\n        else:\n            return str(self[index * 3:])\n    else:\n        aa_index = range(len(self) // 3)\n\n        def cslice(p):\n            aa_slice = aa_index[p]\n            codon_slice = ''\n            for i in aa_slice:\n                codon_slice += self[i * 3:i * 3 + 3]\n            return str(codon_slice)\n        codon_slice = cslice(index)\n        return CodonSeq(codon_slice)",
            "def get_codon(self, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get the index codon from the sequence.'\n    if len({i % 3 for i in self.rf_table}) != 1:\n        raise RuntimeError('frameshift detected. CodonSeq object is not able to deal with codon sequence with frameshift. Please use normal slice option.')\n    if isinstance(index, int):\n        if index != -1:\n            return str(self[index * 3:(index + 1) * 3])\n        else:\n            return str(self[index * 3:])\n    else:\n        aa_index = range(len(self) // 3)\n\n        def cslice(p):\n            aa_slice = aa_index[p]\n            codon_slice = ''\n            for i in aa_slice:\n                codon_slice += self[i * 3:i * 3 + 3]\n            return str(codon_slice)\n        codon_slice = cslice(index)\n        return CodonSeq(codon_slice)"
        ]
    },
    {
        "func_name": "get_codon_num",
        "original": "def get_codon_num(self):\n    \"\"\"Return the number of codons in the CodonSeq.\"\"\"\n    return len(self.rf_table)",
        "mutated": [
            "def get_codon_num(self):\n    if False:\n        i = 10\n    'Return the number of codons in the CodonSeq.'\n    return len(self.rf_table)",
            "def get_codon_num(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the number of codons in the CodonSeq.'\n    return len(self.rf_table)",
            "def get_codon_num(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the number of codons in the CodonSeq.'\n    return len(self.rf_table)",
            "def get_codon_num(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the number of codons in the CodonSeq.'\n    return len(self.rf_table)",
            "def get_codon_num(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the number of codons in the CodonSeq.'\n    return len(self.rf_table)"
        ]
    },
    {
        "func_name": "translate",
        "original": "def translate(self, codon_table=None, stop_symbol='*', rf_table=None, ungap_seq=True):\n    \"\"\"Translate the CodonSeq based on the reading frame in rf_table.\n\n        It is possible for the user to specify\n        a rf_table at this point. If you want to include\n        gaps in the translated sequence, this is the only\n        way. ungap_seq should be set to true for this\n        purpose.\n        \"\"\"\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    amino_acids = []\n    if ungap_seq:\n        tr_seq = str(self).replace(self.gap_char, '')\n    else:\n        tr_seq = str(self)\n    if rf_table is None:\n        rf_table = self.rf_table\n    p = -1\n    for i in rf_table:\n        if isinstance(i, float):\n            amino_acids.append('-')\n            continue\n        elif '-' in tr_seq[i:i + 3]:\n            if p == -1 or p - i == 3:\n                p = i\n                codon = tr_seq[i:i + 6].replace('-', '')[:3]\n            elif p - i > 3:\n                codon = tr_seq[i:i + 3]\n                p = i\n        else:\n            codon = tr_seq[i:i + 3]\n            p = i\n        if codon in codon_table.stop_codons:\n            amino_acids.append(stop_symbol)\n            continue\n        try:\n            amino_acids.append(codon_table.forward_table[codon])\n        except KeyError:\n            raise RuntimeError(f'Unknown codon detected ({codon}). Did you forget to specify the ungap_seq argument?')\n    return ''.join(amino_acids)",
        "mutated": [
            "def translate(self, codon_table=None, stop_symbol='*', rf_table=None, ungap_seq=True):\n    if False:\n        i = 10\n    'Translate the CodonSeq based on the reading frame in rf_table.\\n\\n        It is possible for the user to specify\\n        a rf_table at this point. If you want to include\\n        gaps in the translated sequence, this is the only\\n        way. ungap_seq should be set to true for this\\n        purpose.\\n        '\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    amino_acids = []\n    if ungap_seq:\n        tr_seq = str(self).replace(self.gap_char, '')\n    else:\n        tr_seq = str(self)\n    if rf_table is None:\n        rf_table = self.rf_table\n    p = -1\n    for i in rf_table:\n        if isinstance(i, float):\n            amino_acids.append('-')\n            continue\n        elif '-' in tr_seq[i:i + 3]:\n            if p == -1 or p - i == 3:\n                p = i\n                codon = tr_seq[i:i + 6].replace('-', '')[:3]\n            elif p - i > 3:\n                codon = tr_seq[i:i + 3]\n                p = i\n        else:\n            codon = tr_seq[i:i + 3]\n            p = i\n        if codon in codon_table.stop_codons:\n            amino_acids.append(stop_symbol)\n            continue\n        try:\n            amino_acids.append(codon_table.forward_table[codon])\n        except KeyError:\n            raise RuntimeError(f'Unknown codon detected ({codon}). Did you forget to specify the ungap_seq argument?')\n    return ''.join(amino_acids)",
            "def translate(self, codon_table=None, stop_symbol='*', rf_table=None, ungap_seq=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Translate the CodonSeq based on the reading frame in rf_table.\\n\\n        It is possible for the user to specify\\n        a rf_table at this point. If you want to include\\n        gaps in the translated sequence, this is the only\\n        way. ungap_seq should be set to true for this\\n        purpose.\\n        '\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    amino_acids = []\n    if ungap_seq:\n        tr_seq = str(self).replace(self.gap_char, '')\n    else:\n        tr_seq = str(self)\n    if rf_table is None:\n        rf_table = self.rf_table\n    p = -1\n    for i in rf_table:\n        if isinstance(i, float):\n            amino_acids.append('-')\n            continue\n        elif '-' in tr_seq[i:i + 3]:\n            if p == -1 or p - i == 3:\n                p = i\n                codon = tr_seq[i:i + 6].replace('-', '')[:3]\n            elif p - i > 3:\n                codon = tr_seq[i:i + 3]\n                p = i\n        else:\n            codon = tr_seq[i:i + 3]\n            p = i\n        if codon in codon_table.stop_codons:\n            amino_acids.append(stop_symbol)\n            continue\n        try:\n            amino_acids.append(codon_table.forward_table[codon])\n        except KeyError:\n            raise RuntimeError(f'Unknown codon detected ({codon}). Did you forget to specify the ungap_seq argument?')\n    return ''.join(amino_acids)",
            "def translate(self, codon_table=None, stop_symbol='*', rf_table=None, ungap_seq=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Translate the CodonSeq based on the reading frame in rf_table.\\n\\n        It is possible for the user to specify\\n        a rf_table at this point. If you want to include\\n        gaps in the translated sequence, this is the only\\n        way. ungap_seq should be set to true for this\\n        purpose.\\n        '\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    amino_acids = []\n    if ungap_seq:\n        tr_seq = str(self).replace(self.gap_char, '')\n    else:\n        tr_seq = str(self)\n    if rf_table is None:\n        rf_table = self.rf_table\n    p = -1\n    for i in rf_table:\n        if isinstance(i, float):\n            amino_acids.append('-')\n            continue\n        elif '-' in tr_seq[i:i + 3]:\n            if p == -1 or p - i == 3:\n                p = i\n                codon = tr_seq[i:i + 6].replace('-', '')[:3]\n            elif p - i > 3:\n                codon = tr_seq[i:i + 3]\n                p = i\n        else:\n            codon = tr_seq[i:i + 3]\n            p = i\n        if codon in codon_table.stop_codons:\n            amino_acids.append(stop_symbol)\n            continue\n        try:\n            amino_acids.append(codon_table.forward_table[codon])\n        except KeyError:\n            raise RuntimeError(f'Unknown codon detected ({codon}). Did you forget to specify the ungap_seq argument?')\n    return ''.join(amino_acids)",
            "def translate(self, codon_table=None, stop_symbol='*', rf_table=None, ungap_seq=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Translate the CodonSeq based on the reading frame in rf_table.\\n\\n        It is possible for the user to specify\\n        a rf_table at this point. If you want to include\\n        gaps in the translated sequence, this is the only\\n        way. ungap_seq should be set to true for this\\n        purpose.\\n        '\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    amino_acids = []\n    if ungap_seq:\n        tr_seq = str(self).replace(self.gap_char, '')\n    else:\n        tr_seq = str(self)\n    if rf_table is None:\n        rf_table = self.rf_table\n    p = -1\n    for i in rf_table:\n        if isinstance(i, float):\n            amino_acids.append('-')\n            continue\n        elif '-' in tr_seq[i:i + 3]:\n            if p == -1 or p - i == 3:\n                p = i\n                codon = tr_seq[i:i + 6].replace('-', '')[:3]\n            elif p - i > 3:\n                codon = tr_seq[i:i + 3]\n                p = i\n        else:\n            codon = tr_seq[i:i + 3]\n            p = i\n        if codon in codon_table.stop_codons:\n            amino_acids.append(stop_symbol)\n            continue\n        try:\n            amino_acids.append(codon_table.forward_table[codon])\n        except KeyError:\n            raise RuntimeError(f'Unknown codon detected ({codon}). Did you forget to specify the ungap_seq argument?')\n    return ''.join(amino_acids)",
            "def translate(self, codon_table=None, stop_symbol='*', rf_table=None, ungap_seq=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Translate the CodonSeq based on the reading frame in rf_table.\\n\\n        It is possible for the user to specify\\n        a rf_table at this point. If you want to include\\n        gaps in the translated sequence, this is the only\\n        way. ungap_seq should be set to true for this\\n        purpose.\\n        '\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    amino_acids = []\n    if ungap_seq:\n        tr_seq = str(self).replace(self.gap_char, '')\n    else:\n        tr_seq = str(self)\n    if rf_table is None:\n        rf_table = self.rf_table\n    p = -1\n    for i in rf_table:\n        if isinstance(i, float):\n            amino_acids.append('-')\n            continue\n        elif '-' in tr_seq[i:i + 3]:\n            if p == -1 or p - i == 3:\n                p = i\n                codon = tr_seq[i:i + 6].replace('-', '')[:3]\n            elif p - i > 3:\n                codon = tr_seq[i:i + 3]\n                p = i\n        else:\n            codon = tr_seq[i:i + 3]\n            p = i\n        if codon in codon_table.stop_codons:\n            amino_acids.append(stop_symbol)\n            continue\n        try:\n            amino_acids.append(codon_table.forward_table[codon])\n        except KeyError:\n            raise RuntimeError(f'Unknown codon detected ({codon}). Did you forget to specify the ungap_seq argument?')\n    return ''.join(amino_acids)"
        ]
    },
    {
        "func_name": "toSeq",
        "original": "def toSeq(self):\n    \"\"\"Convert DNA to seq object.\"\"\"\n    return Seq(str(self))",
        "mutated": [
            "def toSeq(self):\n    if False:\n        i = 10\n    'Convert DNA to seq object.'\n    return Seq(str(self))",
            "def toSeq(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert DNA to seq object.'\n    return Seq(str(self))",
            "def toSeq(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert DNA to seq object.'\n    return Seq(str(self))",
            "def toSeq(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert DNA to seq object.'\n    return Seq(str(self))",
            "def toSeq(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert DNA to seq object.'\n    return Seq(str(self))"
        ]
    },
    {
        "func_name": "get_full_rf_table",
        "original": "def get_full_rf_table(self):\n    \"\"\"Return full rf_table of the CodonSeq records.\n\n        A full rf_table is different from a normal rf_table in that\n        it translate gaps in CodonSeq. It is helpful to construct\n        alignment containing frameshift.\n        \"\"\"\n    ungap_seq = str(self).replace('-', '')\n    relative_pos = [self.rf_table[0]]\n    for i in range(1, len(self.rf_table[1:]) + 1):\n        relative_pos.append(self.rf_table[i] - self.rf_table[i - 1])\n    full_rf_table = []\n    codon_num = 0\n    for i in range(0, len(self), 3):\n        if self[i:i + 3] == self.gap_char * 3:\n            full_rf_table.append(i + 0.0)\n        elif relative_pos[codon_num] == 0:\n            full_rf_table.append(i)\n            codon_num += 1\n        elif relative_pos[codon_num] in (-1, -2):\n            gap_stat = 3 - self.count('-', i - 3, i)\n            if gap_stat == 3:\n                full_rf_table.append(i + relative_pos[codon_num])\n            elif gap_stat == 2:\n                full_rf_table.append(i + 1 + relative_pos[codon_num])\n            elif gap_stat == 1:\n                full_rf_table.append(i + 2 + relative_pos[codon_num])\n            codon_num += 1\n        elif relative_pos[codon_num] > 0:\n            full_rf_table.append(i + 0.0)\n        try:\n            this_len = 3 - self.count('-', i, i + 3)\n            relative_pos[codon_num] -= this_len\n        except Exception:\n            pass\n    return full_rf_table",
        "mutated": [
            "def get_full_rf_table(self):\n    if False:\n        i = 10\n    'Return full rf_table of the CodonSeq records.\\n\\n        A full rf_table is different from a normal rf_table in that\\n        it translate gaps in CodonSeq. It is helpful to construct\\n        alignment containing frameshift.\\n        '\n    ungap_seq = str(self).replace('-', '')\n    relative_pos = [self.rf_table[0]]\n    for i in range(1, len(self.rf_table[1:]) + 1):\n        relative_pos.append(self.rf_table[i] - self.rf_table[i - 1])\n    full_rf_table = []\n    codon_num = 0\n    for i in range(0, len(self), 3):\n        if self[i:i + 3] == self.gap_char * 3:\n            full_rf_table.append(i + 0.0)\n        elif relative_pos[codon_num] == 0:\n            full_rf_table.append(i)\n            codon_num += 1\n        elif relative_pos[codon_num] in (-1, -2):\n            gap_stat = 3 - self.count('-', i - 3, i)\n            if gap_stat == 3:\n                full_rf_table.append(i + relative_pos[codon_num])\n            elif gap_stat == 2:\n                full_rf_table.append(i + 1 + relative_pos[codon_num])\n            elif gap_stat == 1:\n                full_rf_table.append(i + 2 + relative_pos[codon_num])\n            codon_num += 1\n        elif relative_pos[codon_num] > 0:\n            full_rf_table.append(i + 0.0)\n        try:\n            this_len = 3 - self.count('-', i, i + 3)\n            relative_pos[codon_num] -= this_len\n        except Exception:\n            pass\n    return full_rf_table",
            "def get_full_rf_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return full rf_table of the CodonSeq records.\\n\\n        A full rf_table is different from a normal rf_table in that\\n        it translate gaps in CodonSeq. It is helpful to construct\\n        alignment containing frameshift.\\n        '\n    ungap_seq = str(self).replace('-', '')\n    relative_pos = [self.rf_table[0]]\n    for i in range(1, len(self.rf_table[1:]) + 1):\n        relative_pos.append(self.rf_table[i] - self.rf_table[i - 1])\n    full_rf_table = []\n    codon_num = 0\n    for i in range(0, len(self), 3):\n        if self[i:i + 3] == self.gap_char * 3:\n            full_rf_table.append(i + 0.0)\n        elif relative_pos[codon_num] == 0:\n            full_rf_table.append(i)\n            codon_num += 1\n        elif relative_pos[codon_num] in (-1, -2):\n            gap_stat = 3 - self.count('-', i - 3, i)\n            if gap_stat == 3:\n                full_rf_table.append(i + relative_pos[codon_num])\n            elif gap_stat == 2:\n                full_rf_table.append(i + 1 + relative_pos[codon_num])\n            elif gap_stat == 1:\n                full_rf_table.append(i + 2 + relative_pos[codon_num])\n            codon_num += 1\n        elif relative_pos[codon_num] > 0:\n            full_rf_table.append(i + 0.0)\n        try:\n            this_len = 3 - self.count('-', i, i + 3)\n            relative_pos[codon_num] -= this_len\n        except Exception:\n            pass\n    return full_rf_table",
            "def get_full_rf_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return full rf_table of the CodonSeq records.\\n\\n        A full rf_table is different from a normal rf_table in that\\n        it translate gaps in CodonSeq. It is helpful to construct\\n        alignment containing frameshift.\\n        '\n    ungap_seq = str(self).replace('-', '')\n    relative_pos = [self.rf_table[0]]\n    for i in range(1, len(self.rf_table[1:]) + 1):\n        relative_pos.append(self.rf_table[i] - self.rf_table[i - 1])\n    full_rf_table = []\n    codon_num = 0\n    for i in range(0, len(self), 3):\n        if self[i:i + 3] == self.gap_char * 3:\n            full_rf_table.append(i + 0.0)\n        elif relative_pos[codon_num] == 0:\n            full_rf_table.append(i)\n            codon_num += 1\n        elif relative_pos[codon_num] in (-1, -2):\n            gap_stat = 3 - self.count('-', i - 3, i)\n            if gap_stat == 3:\n                full_rf_table.append(i + relative_pos[codon_num])\n            elif gap_stat == 2:\n                full_rf_table.append(i + 1 + relative_pos[codon_num])\n            elif gap_stat == 1:\n                full_rf_table.append(i + 2 + relative_pos[codon_num])\n            codon_num += 1\n        elif relative_pos[codon_num] > 0:\n            full_rf_table.append(i + 0.0)\n        try:\n            this_len = 3 - self.count('-', i, i + 3)\n            relative_pos[codon_num] -= this_len\n        except Exception:\n            pass\n    return full_rf_table",
            "def get_full_rf_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return full rf_table of the CodonSeq records.\\n\\n        A full rf_table is different from a normal rf_table in that\\n        it translate gaps in CodonSeq. It is helpful to construct\\n        alignment containing frameshift.\\n        '\n    ungap_seq = str(self).replace('-', '')\n    relative_pos = [self.rf_table[0]]\n    for i in range(1, len(self.rf_table[1:]) + 1):\n        relative_pos.append(self.rf_table[i] - self.rf_table[i - 1])\n    full_rf_table = []\n    codon_num = 0\n    for i in range(0, len(self), 3):\n        if self[i:i + 3] == self.gap_char * 3:\n            full_rf_table.append(i + 0.0)\n        elif relative_pos[codon_num] == 0:\n            full_rf_table.append(i)\n            codon_num += 1\n        elif relative_pos[codon_num] in (-1, -2):\n            gap_stat = 3 - self.count('-', i - 3, i)\n            if gap_stat == 3:\n                full_rf_table.append(i + relative_pos[codon_num])\n            elif gap_stat == 2:\n                full_rf_table.append(i + 1 + relative_pos[codon_num])\n            elif gap_stat == 1:\n                full_rf_table.append(i + 2 + relative_pos[codon_num])\n            codon_num += 1\n        elif relative_pos[codon_num] > 0:\n            full_rf_table.append(i + 0.0)\n        try:\n            this_len = 3 - self.count('-', i, i + 3)\n            relative_pos[codon_num] -= this_len\n        except Exception:\n            pass\n    return full_rf_table",
            "def get_full_rf_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return full rf_table of the CodonSeq records.\\n\\n        A full rf_table is different from a normal rf_table in that\\n        it translate gaps in CodonSeq. It is helpful to construct\\n        alignment containing frameshift.\\n        '\n    ungap_seq = str(self).replace('-', '')\n    relative_pos = [self.rf_table[0]]\n    for i in range(1, len(self.rf_table[1:]) + 1):\n        relative_pos.append(self.rf_table[i] - self.rf_table[i - 1])\n    full_rf_table = []\n    codon_num = 0\n    for i in range(0, len(self), 3):\n        if self[i:i + 3] == self.gap_char * 3:\n            full_rf_table.append(i + 0.0)\n        elif relative_pos[codon_num] == 0:\n            full_rf_table.append(i)\n            codon_num += 1\n        elif relative_pos[codon_num] in (-1, -2):\n            gap_stat = 3 - self.count('-', i - 3, i)\n            if gap_stat == 3:\n                full_rf_table.append(i + relative_pos[codon_num])\n            elif gap_stat == 2:\n                full_rf_table.append(i + 1 + relative_pos[codon_num])\n            elif gap_stat == 1:\n                full_rf_table.append(i + 2 + relative_pos[codon_num])\n            codon_num += 1\n        elif relative_pos[codon_num] > 0:\n            full_rf_table.append(i + 0.0)\n        try:\n            this_len = 3 - self.count('-', i, i + 3)\n            relative_pos[codon_num] -= this_len\n        except Exception:\n            pass\n    return full_rf_table"
        ]
    },
    {
        "func_name": "full_translate",
        "original": "def full_translate(self, codon_table=None, stop_symbol='*'):\n    \"\"\"Apply full translation with gaps considered.\"\"\"\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    full_rf_table = self.get_full_rf_table()\n    return self.translate(codon_table=codon_table, stop_symbol=stop_symbol, rf_table=full_rf_table, ungap_seq=False)",
        "mutated": [
            "def full_translate(self, codon_table=None, stop_symbol='*'):\n    if False:\n        i = 10\n    'Apply full translation with gaps considered.'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    full_rf_table = self.get_full_rf_table()\n    return self.translate(codon_table=codon_table, stop_symbol=stop_symbol, rf_table=full_rf_table, ungap_seq=False)",
            "def full_translate(self, codon_table=None, stop_symbol='*'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Apply full translation with gaps considered.'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    full_rf_table = self.get_full_rf_table()\n    return self.translate(codon_table=codon_table, stop_symbol=stop_symbol, rf_table=full_rf_table, ungap_seq=False)",
            "def full_translate(self, codon_table=None, stop_symbol='*'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Apply full translation with gaps considered.'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    full_rf_table = self.get_full_rf_table()\n    return self.translate(codon_table=codon_table, stop_symbol=stop_symbol, rf_table=full_rf_table, ungap_seq=False)",
            "def full_translate(self, codon_table=None, stop_symbol='*'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Apply full translation with gaps considered.'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    full_rf_table = self.get_full_rf_table()\n    return self.translate(codon_table=codon_table, stop_symbol=stop_symbol, rf_table=full_rf_table, ungap_seq=False)",
            "def full_translate(self, codon_table=None, stop_symbol='*'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Apply full translation with gaps considered.'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    full_rf_table = self.get_full_rf_table()\n    return self.translate(codon_table=codon_table, stop_symbol=stop_symbol, rf_table=full_rf_table, ungap_seq=False)"
        ]
    },
    {
        "func_name": "ungap",
        "original": "def ungap(self, gap='-'):\n    \"\"\"Return a copy of the sequence without the gap character(s).\"\"\"\n    if len(gap) != 1 or not isinstance(gap, str):\n        raise ValueError(f'Unexpected gap character, {gap!r}')\n    return CodonSeq(str(self).replace(gap, ''), rf_table=self.rf_table)",
        "mutated": [
            "def ungap(self, gap='-'):\n    if False:\n        i = 10\n    'Return a copy of the sequence without the gap character(s).'\n    if len(gap) != 1 or not isinstance(gap, str):\n        raise ValueError(f'Unexpected gap character, {gap!r}')\n    return CodonSeq(str(self).replace(gap, ''), rf_table=self.rf_table)",
            "def ungap(self, gap='-'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a copy of the sequence without the gap character(s).'\n    if len(gap) != 1 or not isinstance(gap, str):\n        raise ValueError(f'Unexpected gap character, {gap!r}')\n    return CodonSeq(str(self).replace(gap, ''), rf_table=self.rf_table)",
            "def ungap(self, gap='-'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a copy of the sequence without the gap character(s).'\n    if len(gap) != 1 or not isinstance(gap, str):\n        raise ValueError(f'Unexpected gap character, {gap!r}')\n    return CodonSeq(str(self).replace(gap, ''), rf_table=self.rf_table)",
            "def ungap(self, gap='-'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a copy of the sequence without the gap character(s).'\n    if len(gap) != 1 or not isinstance(gap, str):\n        raise ValueError(f'Unexpected gap character, {gap!r}')\n    return CodonSeq(str(self).replace(gap, ''), rf_table=self.rf_table)",
            "def ungap(self, gap='-'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a copy of the sequence without the gap character(s).'\n    if len(gap) != 1 or not isinstance(gap, str):\n        raise ValueError(f'Unexpected gap character, {gap!r}')\n    return CodonSeq(str(self).replace(gap, ''), rf_table=self.rf_table)"
        ]
    },
    {
        "func_name": "from_seq",
        "original": "@classmethod\ndef from_seq(cls, seq, rf_table=None):\n    \"\"\"Get codon sequence from sequence data.\"\"\"\n    if rf_table is None:\n        return cls(str(seq))\n    else:\n        return cls(str(seq), rf_table=rf_table)",
        "mutated": [
            "@classmethod\ndef from_seq(cls, seq, rf_table=None):\n    if False:\n        i = 10\n    'Get codon sequence from sequence data.'\n    if rf_table is None:\n        return cls(str(seq))\n    else:\n        return cls(str(seq), rf_table=rf_table)",
            "@classmethod\ndef from_seq(cls, seq, rf_table=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get codon sequence from sequence data.'\n    if rf_table is None:\n        return cls(str(seq))\n    else:\n        return cls(str(seq), rf_table=rf_table)",
            "@classmethod\ndef from_seq(cls, seq, rf_table=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get codon sequence from sequence data.'\n    if rf_table is None:\n        return cls(str(seq))\n    else:\n        return cls(str(seq), rf_table=rf_table)",
            "@classmethod\ndef from_seq(cls, seq, rf_table=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get codon sequence from sequence data.'\n    if rf_table is None:\n        return cls(str(seq))\n    else:\n        return cls(str(seq), rf_table=rf_table)",
            "@classmethod\ndef from_seq(cls, seq, rf_table=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get codon sequence from sequence data.'\n    if rf_table is None:\n        return cls(str(seq))\n    else:\n        return cls(str(seq), rf_table=rf_table)"
        ]
    },
    {
        "func_name": "_get_codon_list",
        "original": "def _get_codon_list(codonseq):\n    \"\"\"List of codons according to full_rf_table for counting (PRIVATE).\"\"\"\n    full_rf_table = codonseq.get_full_rf_table()\n    codon_lst = []\n    for (i, k) in enumerate(full_rf_table):\n        if isinstance(k, int):\n            start = k\n            try:\n                end = int(full_rf_table[i + 1])\n            except IndexError:\n                end = start + 3\n            this_codon = str(codonseq[start:end])\n            if len(this_codon) == 3:\n                codon_lst.append(this_codon)\n            else:\n                codon_lst.append(str(this_codon.ungap()))\n        elif str(codonseq[int(k):int(k) + 3]) == '---':\n            codon_lst.append('---')\n        else:\n            codon_lst.append(codonseq[int(k):int(k) + 3])\n    return codon_lst",
        "mutated": [
            "def _get_codon_list(codonseq):\n    if False:\n        i = 10\n    'List of codons according to full_rf_table for counting (PRIVATE).'\n    full_rf_table = codonseq.get_full_rf_table()\n    codon_lst = []\n    for (i, k) in enumerate(full_rf_table):\n        if isinstance(k, int):\n            start = k\n            try:\n                end = int(full_rf_table[i + 1])\n            except IndexError:\n                end = start + 3\n            this_codon = str(codonseq[start:end])\n            if len(this_codon) == 3:\n                codon_lst.append(this_codon)\n            else:\n                codon_lst.append(str(this_codon.ungap()))\n        elif str(codonseq[int(k):int(k) + 3]) == '---':\n            codon_lst.append('---')\n        else:\n            codon_lst.append(codonseq[int(k):int(k) + 3])\n    return codon_lst",
            "def _get_codon_list(codonseq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'List of codons according to full_rf_table for counting (PRIVATE).'\n    full_rf_table = codonseq.get_full_rf_table()\n    codon_lst = []\n    for (i, k) in enumerate(full_rf_table):\n        if isinstance(k, int):\n            start = k\n            try:\n                end = int(full_rf_table[i + 1])\n            except IndexError:\n                end = start + 3\n            this_codon = str(codonseq[start:end])\n            if len(this_codon) == 3:\n                codon_lst.append(this_codon)\n            else:\n                codon_lst.append(str(this_codon.ungap()))\n        elif str(codonseq[int(k):int(k) + 3]) == '---':\n            codon_lst.append('---')\n        else:\n            codon_lst.append(codonseq[int(k):int(k) + 3])\n    return codon_lst",
            "def _get_codon_list(codonseq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'List of codons according to full_rf_table for counting (PRIVATE).'\n    full_rf_table = codonseq.get_full_rf_table()\n    codon_lst = []\n    for (i, k) in enumerate(full_rf_table):\n        if isinstance(k, int):\n            start = k\n            try:\n                end = int(full_rf_table[i + 1])\n            except IndexError:\n                end = start + 3\n            this_codon = str(codonseq[start:end])\n            if len(this_codon) == 3:\n                codon_lst.append(this_codon)\n            else:\n                codon_lst.append(str(this_codon.ungap()))\n        elif str(codonseq[int(k):int(k) + 3]) == '---':\n            codon_lst.append('---')\n        else:\n            codon_lst.append(codonseq[int(k):int(k) + 3])\n    return codon_lst",
            "def _get_codon_list(codonseq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'List of codons according to full_rf_table for counting (PRIVATE).'\n    full_rf_table = codonseq.get_full_rf_table()\n    codon_lst = []\n    for (i, k) in enumerate(full_rf_table):\n        if isinstance(k, int):\n            start = k\n            try:\n                end = int(full_rf_table[i + 1])\n            except IndexError:\n                end = start + 3\n            this_codon = str(codonseq[start:end])\n            if len(this_codon) == 3:\n                codon_lst.append(this_codon)\n            else:\n                codon_lst.append(str(this_codon.ungap()))\n        elif str(codonseq[int(k):int(k) + 3]) == '---':\n            codon_lst.append('---')\n        else:\n            codon_lst.append(codonseq[int(k):int(k) + 3])\n    return codon_lst",
            "def _get_codon_list(codonseq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'List of codons according to full_rf_table for counting (PRIVATE).'\n    full_rf_table = codonseq.get_full_rf_table()\n    codon_lst = []\n    for (i, k) in enumerate(full_rf_table):\n        if isinstance(k, int):\n            start = k\n            try:\n                end = int(full_rf_table[i + 1])\n            except IndexError:\n                end = start + 3\n            this_codon = str(codonseq[start:end])\n            if len(this_codon) == 3:\n                codon_lst.append(this_codon)\n            else:\n                codon_lst.append(str(this_codon.ungap()))\n        elif str(codonseq[int(k):int(k) + 3]) == '---':\n            codon_lst.append('---')\n        else:\n            codon_lst.append(codonseq[int(k):int(k) + 3])\n    return codon_lst"
        ]
    },
    {
        "func_name": "cal_dn_ds",
        "original": "def cal_dn_ds(codon_seq1, codon_seq2, method='NG86', codon_table=None, k=1, cfreq=None):\n    \"\"\"Calculate dN and dS of the given two sequences.\n\n    Available methods:\n        - NG86  - `Nei and Gojobori (1986)`_ (PMID 3444411).\n        - LWL85 - `Li et al. (1985)`_ (PMID 3916709).\n        - ML    - `Goldman and Yang (1994)`_ (PMID 7968486).\n        - YN00  - `Yang and Nielsen (2000)`_ (PMID 10666704).\n\n    .. _`Nei and Gojobori (1986)`: http://www.ncbi.nlm.nih.gov/pubmed/3444411\n    .. _`Li et al. (1985)`: http://www.ncbi.nlm.nih.gov/pubmed/3916709\n    .. _`Goldman and Yang (1994)`: http://mbe.oxfordjournals.org/content/11/5/725\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\n\n    Arguments:\n     - codon_seq1 - CodonSeq or or SeqRecord that contains a CodonSeq\n     - codon_seq2 - CodonSeq or or SeqRecord that contains a CodonSeq\n     - w  - transition/transversion ratio\n     - cfreq - Current codon frequency vector can only be specified\n       when you are using ML method. Possible ways of\n       getting cfreq are: F1x4, F3x4 and F61.\n\n    \"\"\"\n    if isinstance(codon_seq1, CodonSeq) and isinstance(codon_seq2, CodonSeq):\n        pass\n    elif isinstance(codon_seq1, SeqRecord) and isinstance(codon_seq2, SeqRecord):\n        codon_seq1 = codon_seq1.seq\n        codon_seq2 = codon_seq2.seq\n    else:\n        raise TypeError('cal_dn_ds accepts two CodonSeq objects or SeqRecord that contains CodonSeq as its seq!')\n    if len(codon_seq1.get_full_rf_table()) != len(codon_seq2.get_full_rf_table()):\n        raise RuntimeError(f'full_rf_table length of seq1 ({len(codon_seq1.get_full_rf_table())}) and seq2 ({len(codon_seq2.get_full_rf_table())}) are not the same')\n    if cfreq is None:\n        cfreq = 'F3x4'\n    elif cfreq is not None and method != 'ML':\n        raise RuntimeError('cfreq can only be specified when you are using ML method')\n    if cfreq not in ('F1x4', 'F3x4', 'F61'):\n        import warnings\n        warnings.warn(f'Unknown cfreq ({cfreq}). Only F1x4, F3x4 and F61 are acceptable. Used F3x4 in the following.')\n        cfreq = 'F3x4'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    seq1_codon_lst = _get_codon_list(codon_seq1)\n    seq2_codon_lst = _get_codon_list(codon_seq2)\n    seq1 = []\n    seq2 = []\n    for (i, j) in zip(seq1_codon_lst, seq2_codon_lst):\n        if '-' not in i and '-' not in j:\n            seq1.append(i)\n            seq2.append(j)\n    dnds_func = {'ML': _ml, 'NG86': _ng86, 'LWL85': _lwl85, 'YN00': _yn00}\n    if method == 'ML':\n        return dnds_func[method](seq1, seq2, cfreq, codon_table)\n    else:\n        return dnds_func[method](seq1, seq2, k, codon_table)",
        "mutated": [
            "def cal_dn_ds(codon_seq1, codon_seq2, method='NG86', codon_table=None, k=1, cfreq=None):\n    if False:\n        i = 10\n    'Calculate dN and dS of the given two sequences.\\n\\n    Available methods:\\n        - NG86  - `Nei and Gojobori (1986)`_ (PMID 3444411).\\n        - LWL85 - `Li et al. (1985)`_ (PMID 3916709).\\n        - ML    - `Goldman and Yang (1994)`_ (PMID 7968486).\\n        - YN00  - `Yang and Nielsen (2000)`_ (PMID 10666704).\\n\\n    .. _`Nei and Gojobori (1986)`: http://www.ncbi.nlm.nih.gov/pubmed/3444411\\n    .. _`Li et al. (1985)`: http://www.ncbi.nlm.nih.gov/pubmed/3916709\\n    .. _`Goldman and Yang (1994)`: http://mbe.oxfordjournals.org/content/11/5/725\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    Arguments:\\n     - codon_seq1 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - codon_seq2 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - w  - transition/transversion ratio\\n     - cfreq - Current codon frequency vector can only be specified\\n       when you are using ML method. Possible ways of\\n       getting cfreq are: F1x4, F3x4 and F61.\\n\\n    '\n    if isinstance(codon_seq1, CodonSeq) and isinstance(codon_seq2, CodonSeq):\n        pass\n    elif isinstance(codon_seq1, SeqRecord) and isinstance(codon_seq2, SeqRecord):\n        codon_seq1 = codon_seq1.seq\n        codon_seq2 = codon_seq2.seq\n    else:\n        raise TypeError('cal_dn_ds accepts two CodonSeq objects or SeqRecord that contains CodonSeq as its seq!')\n    if len(codon_seq1.get_full_rf_table()) != len(codon_seq2.get_full_rf_table()):\n        raise RuntimeError(f'full_rf_table length of seq1 ({len(codon_seq1.get_full_rf_table())}) and seq2 ({len(codon_seq2.get_full_rf_table())}) are not the same')\n    if cfreq is None:\n        cfreq = 'F3x4'\n    elif cfreq is not None and method != 'ML':\n        raise RuntimeError('cfreq can only be specified when you are using ML method')\n    if cfreq not in ('F1x4', 'F3x4', 'F61'):\n        import warnings\n        warnings.warn(f'Unknown cfreq ({cfreq}). Only F1x4, F3x4 and F61 are acceptable. Used F3x4 in the following.')\n        cfreq = 'F3x4'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    seq1_codon_lst = _get_codon_list(codon_seq1)\n    seq2_codon_lst = _get_codon_list(codon_seq2)\n    seq1 = []\n    seq2 = []\n    for (i, j) in zip(seq1_codon_lst, seq2_codon_lst):\n        if '-' not in i and '-' not in j:\n            seq1.append(i)\n            seq2.append(j)\n    dnds_func = {'ML': _ml, 'NG86': _ng86, 'LWL85': _lwl85, 'YN00': _yn00}\n    if method == 'ML':\n        return dnds_func[method](seq1, seq2, cfreq, codon_table)\n    else:\n        return dnds_func[method](seq1, seq2, k, codon_table)",
            "def cal_dn_ds(codon_seq1, codon_seq2, method='NG86', codon_table=None, k=1, cfreq=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate dN and dS of the given two sequences.\\n\\n    Available methods:\\n        - NG86  - `Nei and Gojobori (1986)`_ (PMID 3444411).\\n        - LWL85 - `Li et al. (1985)`_ (PMID 3916709).\\n        - ML    - `Goldman and Yang (1994)`_ (PMID 7968486).\\n        - YN00  - `Yang and Nielsen (2000)`_ (PMID 10666704).\\n\\n    .. _`Nei and Gojobori (1986)`: http://www.ncbi.nlm.nih.gov/pubmed/3444411\\n    .. _`Li et al. (1985)`: http://www.ncbi.nlm.nih.gov/pubmed/3916709\\n    .. _`Goldman and Yang (1994)`: http://mbe.oxfordjournals.org/content/11/5/725\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    Arguments:\\n     - codon_seq1 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - codon_seq2 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - w  - transition/transversion ratio\\n     - cfreq - Current codon frequency vector can only be specified\\n       when you are using ML method. Possible ways of\\n       getting cfreq are: F1x4, F3x4 and F61.\\n\\n    '\n    if isinstance(codon_seq1, CodonSeq) and isinstance(codon_seq2, CodonSeq):\n        pass\n    elif isinstance(codon_seq1, SeqRecord) and isinstance(codon_seq2, SeqRecord):\n        codon_seq1 = codon_seq1.seq\n        codon_seq2 = codon_seq2.seq\n    else:\n        raise TypeError('cal_dn_ds accepts two CodonSeq objects or SeqRecord that contains CodonSeq as its seq!')\n    if len(codon_seq1.get_full_rf_table()) != len(codon_seq2.get_full_rf_table()):\n        raise RuntimeError(f'full_rf_table length of seq1 ({len(codon_seq1.get_full_rf_table())}) and seq2 ({len(codon_seq2.get_full_rf_table())}) are not the same')\n    if cfreq is None:\n        cfreq = 'F3x4'\n    elif cfreq is not None and method != 'ML':\n        raise RuntimeError('cfreq can only be specified when you are using ML method')\n    if cfreq not in ('F1x4', 'F3x4', 'F61'):\n        import warnings\n        warnings.warn(f'Unknown cfreq ({cfreq}). Only F1x4, F3x4 and F61 are acceptable. Used F3x4 in the following.')\n        cfreq = 'F3x4'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    seq1_codon_lst = _get_codon_list(codon_seq1)\n    seq2_codon_lst = _get_codon_list(codon_seq2)\n    seq1 = []\n    seq2 = []\n    for (i, j) in zip(seq1_codon_lst, seq2_codon_lst):\n        if '-' not in i and '-' not in j:\n            seq1.append(i)\n            seq2.append(j)\n    dnds_func = {'ML': _ml, 'NG86': _ng86, 'LWL85': _lwl85, 'YN00': _yn00}\n    if method == 'ML':\n        return dnds_func[method](seq1, seq2, cfreq, codon_table)\n    else:\n        return dnds_func[method](seq1, seq2, k, codon_table)",
            "def cal_dn_ds(codon_seq1, codon_seq2, method='NG86', codon_table=None, k=1, cfreq=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate dN and dS of the given two sequences.\\n\\n    Available methods:\\n        - NG86  - `Nei and Gojobori (1986)`_ (PMID 3444411).\\n        - LWL85 - `Li et al. (1985)`_ (PMID 3916709).\\n        - ML    - `Goldman and Yang (1994)`_ (PMID 7968486).\\n        - YN00  - `Yang and Nielsen (2000)`_ (PMID 10666704).\\n\\n    .. _`Nei and Gojobori (1986)`: http://www.ncbi.nlm.nih.gov/pubmed/3444411\\n    .. _`Li et al. (1985)`: http://www.ncbi.nlm.nih.gov/pubmed/3916709\\n    .. _`Goldman and Yang (1994)`: http://mbe.oxfordjournals.org/content/11/5/725\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    Arguments:\\n     - codon_seq1 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - codon_seq2 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - w  - transition/transversion ratio\\n     - cfreq - Current codon frequency vector can only be specified\\n       when you are using ML method. Possible ways of\\n       getting cfreq are: F1x4, F3x4 and F61.\\n\\n    '\n    if isinstance(codon_seq1, CodonSeq) and isinstance(codon_seq2, CodonSeq):\n        pass\n    elif isinstance(codon_seq1, SeqRecord) and isinstance(codon_seq2, SeqRecord):\n        codon_seq1 = codon_seq1.seq\n        codon_seq2 = codon_seq2.seq\n    else:\n        raise TypeError('cal_dn_ds accepts two CodonSeq objects or SeqRecord that contains CodonSeq as its seq!')\n    if len(codon_seq1.get_full_rf_table()) != len(codon_seq2.get_full_rf_table()):\n        raise RuntimeError(f'full_rf_table length of seq1 ({len(codon_seq1.get_full_rf_table())}) and seq2 ({len(codon_seq2.get_full_rf_table())}) are not the same')\n    if cfreq is None:\n        cfreq = 'F3x4'\n    elif cfreq is not None and method != 'ML':\n        raise RuntimeError('cfreq can only be specified when you are using ML method')\n    if cfreq not in ('F1x4', 'F3x4', 'F61'):\n        import warnings\n        warnings.warn(f'Unknown cfreq ({cfreq}). Only F1x4, F3x4 and F61 are acceptable. Used F3x4 in the following.')\n        cfreq = 'F3x4'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    seq1_codon_lst = _get_codon_list(codon_seq1)\n    seq2_codon_lst = _get_codon_list(codon_seq2)\n    seq1 = []\n    seq2 = []\n    for (i, j) in zip(seq1_codon_lst, seq2_codon_lst):\n        if '-' not in i and '-' not in j:\n            seq1.append(i)\n            seq2.append(j)\n    dnds_func = {'ML': _ml, 'NG86': _ng86, 'LWL85': _lwl85, 'YN00': _yn00}\n    if method == 'ML':\n        return dnds_func[method](seq1, seq2, cfreq, codon_table)\n    else:\n        return dnds_func[method](seq1, seq2, k, codon_table)",
            "def cal_dn_ds(codon_seq1, codon_seq2, method='NG86', codon_table=None, k=1, cfreq=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate dN and dS of the given two sequences.\\n\\n    Available methods:\\n        - NG86  - `Nei and Gojobori (1986)`_ (PMID 3444411).\\n        - LWL85 - `Li et al. (1985)`_ (PMID 3916709).\\n        - ML    - `Goldman and Yang (1994)`_ (PMID 7968486).\\n        - YN00  - `Yang and Nielsen (2000)`_ (PMID 10666704).\\n\\n    .. _`Nei and Gojobori (1986)`: http://www.ncbi.nlm.nih.gov/pubmed/3444411\\n    .. _`Li et al. (1985)`: http://www.ncbi.nlm.nih.gov/pubmed/3916709\\n    .. _`Goldman and Yang (1994)`: http://mbe.oxfordjournals.org/content/11/5/725\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    Arguments:\\n     - codon_seq1 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - codon_seq2 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - w  - transition/transversion ratio\\n     - cfreq - Current codon frequency vector can only be specified\\n       when you are using ML method. Possible ways of\\n       getting cfreq are: F1x4, F3x4 and F61.\\n\\n    '\n    if isinstance(codon_seq1, CodonSeq) and isinstance(codon_seq2, CodonSeq):\n        pass\n    elif isinstance(codon_seq1, SeqRecord) and isinstance(codon_seq2, SeqRecord):\n        codon_seq1 = codon_seq1.seq\n        codon_seq2 = codon_seq2.seq\n    else:\n        raise TypeError('cal_dn_ds accepts two CodonSeq objects or SeqRecord that contains CodonSeq as its seq!')\n    if len(codon_seq1.get_full_rf_table()) != len(codon_seq2.get_full_rf_table()):\n        raise RuntimeError(f'full_rf_table length of seq1 ({len(codon_seq1.get_full_rf_table())}) and seq2 ({len(codon_seq2.get_full_rf_table())}) are not the same')\n    if cfreq is None:\n        cfreq = 'F3x4'\n    elif cfreq is not None and method != 'ML':\n        raise RuntimeError('cfreq can only be specified when you are using ML method')\n    if cfreq not in ('F1x4', 'F3x4', 'F61'):\n        import warnings\n        warnings.warn(f'Unknown cfreq ({cfreq}). Only F1x4, F3x4 and F61 are acceptable. Used F3x4 in the following.')\n        cfreq = 'F3x4'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    seq1_codon_lst = _get_codon_list(codon_seq1)\n    seq2_codon_lst = _get_codon_list(codon_seq2)\n    seq1 = []\n    seq2 = []\n    for (i, j) in zip(seq1_codon_lst, seq2_codon_lst):\n        if '-' not in i and '-' not in j:\n            seq1.append(i)\n            seq2.append(j)\n    dnds_func = {'ML': _ml, 'NG86': _ng86, 'LWL85': _lwl85, 'YN00': _yn00}\n    if method == 'ML':\n        return dnds_func[method](seq1, seq2, cfreq, codon_table)\n    else:\n        return dnds_func[method](seq1, seq2, k, codon_table)",
            "def cal_dn_ds(codon_seq1, codon_seq2, method='NG86', codon_table=None, k=1, cfreq=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate dN and dS of the given two sequences.\\n\\n    Available methods:\\n        - NG86  - `Nei and Gojobori (1986)`_ (PMID 3444411).\\n        - LWL85 - `Li et al. (1985)`_ (PMID 3916709).\\n        - ML    - `Goldman and Yang (1994)`_ (PMID 7968486).\\n        - YN00  - `Yang and Nielsen (2000)`_ (PMID 10666704).\\n\\n    .. _`Nei and Gojobori (1986)`: http://www.ncbi.nlm.nih.gov/pubmed/3444411\\n    .. _`Li et al. (1985)`: http://www.ncbi.nlm.nih.gov/pubmed/3916709\\n    .. _`Goldman and Yang (1994)`: http://mbe.oxfordjournals.org/content/11/5/725\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    Arguments:\\n     - codon_seq1 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - codon_seq2 - CodonSeq or or SeqRecord that contains a CodonSeq\\n     - w  - transition/transversion ratio\\n     - cfreq - Current codon frequency vector can only be specified\\n       when you are using ML method. Possible ways of\\n       getting cfreq are: F1x4, F3x4 and F61.\\n\\n    '\n    if isinstance(codon_seq1, CodonSeq) and isinstance(codon_seq2, CodonSeq):\n        pass\n    elif isinstance(codon_seq1, SeqRecord) and isinstance(codon_seq2, SeqRecord):\n        codon_seq1 = codon_seq1.seq\n        codon_seq2 = codon_seq2.seq\n    else:\n        raise TypeError('cal_dn_ds accepts two CodonSeq objects or SeqRecord that contains CodonSeq as its seq!')\n    if len(codon_seq1.get_full_rf_table()) != len(codon_seq2.get_full_rf_table()):\n        raise RuntimeError(f'full_rf_table length of seq1 ({len(codon_seq1.get_full_rf_table())}) and seq2 ({len(codon_seq2.get_full_rf_table())}) are not the same')\n    if cfreq is None:\n        cfreq = 'F3x4'\n    elif cfreq is not None and method != 'ML':\n        raise RuntimeError('cfreq can only be specified when you are using ML method')\n    if cfreq not in ('F1x4', 'F3x4', 'F61'):\n        import warnings\n        warnings.warn(f'Unknown cfreq ({cfreq}). Only F1x4, F3x4 and F61 are acceptable. Used F3x4 in the following.')\n        cfreq = 'F3x4'\n    if codon_table is None:\n        codon_table = CodonTable.generic_by_id[1]\n    seq1_codon_lst = _get_codon_list(codon_seq1)\n    seq2_codon_lst = _get_codon_list(codon_seq2)\n    seq1 = []\n    seq2 = []\n    for (i, j) in zip(seq1_codon_lst, seq2_codon_lst):\n        if '-' not in i and '-' not in j:\n            seq1.append(i)\n            seq2.append(j)\n    dnds_func = {'ML': _ml, 'NG86': _ng86, 'LWL85': _lwl85, 'YN00': _yn00}\n    if method == 'ML':\n        return dnds_func[method](seq1, seq2, cfreq, codon_table)\n    else:\n        return dnds_func[method](seq1, seq2, k, codon_table)"
        ]
    },
    {
        "func_name": "_ng86",
        "original": "def _ng86(seq1, seq2, k, codon_table):\n    \"\"\"NG86 method main function (PRIVATE).\"\"\"\n    (S_sites1, N_sites1) = _count_site_NG86(seq1, codon_table=codon_table, k=k)\n    (S_sites2, N_sites2) = _count_site_NG86(seq2, codon_table=codon_table, k=k)\n    S_sites = (S_sites1 + S_sites2) / 2.0\n    N_sites = (N_sites1 + N_sites2) / 2.0\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    if ps < 3 / 4:\n        dS = abs(-3.0 / 4 * log(1 - 4.0 / 3 * ps))\n    else:\n        dS = -1\n    if pn < 3 / 4:\n        dN = abs(-3.0 / 4 * log(1 - 4.0 / 3 * pn))\n    else:\n        dN = -1\n    return (dN, dS)",
        "mutated": [
            "def _ng86(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n    'NG86 method main function (PRIVATE).'\n    (S_sites1, N_sites1) = _count_site_NG86(seq1, codon_table=codon_table, k=k)\n    (S_sites2, N_sites2) = _count_site_NG86(seq2, codon_table=codon_table, k=k)\n    S_sites = (S_sites1 + S_sites2) / 2.0\n    N_sites = (N_sites1 + N_sites2) / 2.0\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    if ps < 3 / 4:\n        dS = abs(-3.0 / 4 * log(1 - 4.0 / 3 * ps))\n    else:\n        dS = -1\n    if pn < 3 / 4:\n        dN = abs(-3.0 / 4 * log(1 - 4.0 / 3 * pn))\n    else:\n        dN = -1\n    return (dN, dS)",
            "def _ng86(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'NG86 method main function (PRIVATE).'\n    (S_sites1, N_sites1) = _count_site_NG86(seq1, codon_table=codon_table, k=k)\n    (S_sites2, N_sites2) = _count_site_NG86(seq2, codon_table=codon_table, k=k)\n    S_sites = (S_sites1 + S_sites2) / 2.0\n    N_sites = (N_sites1 + N_sites2) / 2.0\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    if ps < 3 / 4:\n        dS = abs(-3.0 / 4 * log(1 - 4.0 / 3 * ps))\n    else:\n        dS = -1\n    if pn < 3 / 4:\n        dN = abs(-3.0 / 4 * log(1 - 4.0 / 3 * pn))\n    else:\n        dN = -1\n    return (dN, dS)",
            "def _ng86(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'NG86 method main function (PRIVATE).'\n    (S_sites1, N_sites1) = _count_site_NG86(seq1, codon_table=codon_table, k=k)\n    (S_sites2, N_sites2) = _count_site_NG86(seq2, codon_table=codon_table, k=k)\n    S_sites = (S_sites1 + S_sites2) / 2.0\n    N_sites = (N_sites1 + N_sites2) / 2.0\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    if ps < 3 / 4:\n        dS = abs(-3.0 / 4 * log(1 - 4.0 / 3 * ps))\n    else:\n        dS = -1\n    if pn < 3 / 4:\n        dN = abs(-3.0 / 4 * log(1 - 4.0 / 3 * pn))\n    else:\n        dN = -1\n    return (dN, dS)",
            "def _ng86(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'NG86 method main function (PRIVATE).'\n    (S_sites1, N_sites1) = _count_site_NG86(seq1, codon_table=codon_table, k=k)\n    (S_sites2, N_sites2) = _count_site_NG86(seq2, codon_table=codon_table, k=k)\n    S_sites = (S_sites1 + S_sites2) / 2.0\n    N_sites = (N_sites1 + N_sites2) / 2.0\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    if ps < 3 / 4:\n        dS = abs(-3.0 / 4 * log(1 - 4.0 / 3 * ps))\n    else:\n        dS = -1\n    if pn < 3 / 4:\n        dN = abs(-3.0 / 4 * log(1 - 4.0 / 3 * pn))\n    else:\n        dN = -1\n    return (dN, dS)",
            "def _ng86(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'NG86 method main function (PRIVATE).'\n    (S_sites1, N_sites1) = _count_site_NG86(seq1, codon_table=codon_table, k=k)\n    (S_sites2, N_sites2) = _count_site_NG86(seq2, codon_table=codon_table, k=k)\n    S_sites = (S_sites1 + S_sites2) / 2.0\n    N_sites = (N_sites1 + N_sites2) / 2.0\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    if ps < 3 / 4:\n        dS = abs(-3.0 / 4 * log(1 - 4.0 / 3 * ps))\n    else:\n        dS = -1\n    if pn < 3 / 4:\n        dN = abs(-3.0 / 4 * log(1 - 4.0 / 3 * pn))\n    else:\n        dN = -1\n    return (dN, dS)"
        ]
    },
    {
        "func_name": "_count_site_NG86",
        "original": "def _count_site_NG86(codon_lst, codon_table, k=1):\n    \"\"\"Count synonymous and non-synonymous sites of a list of codons (PRIVATE).\n\n    Arguments:\n     - codon_lst - A three letter codon list from a CodonSeq object.\n       This can be returned from _get_codon_list method.\n     - k - transition/transversion rate ratio.\n\n    \"\"\"\n    S_site = 0\n    N_site = 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    for codon in codon_lst:\n        neighbor_codon = {'transition': [], 'transversion': []}\n        codon = codon.replace('U', 'T')\n        if codon == '---':\n            continue\n        for (n, i) in enumerate(codon):\n            for j in base_tuple:\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                elif i in pyrimidine and j in pyrimidine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                else:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transversion'].append(this_codon)\n        aa = codon_table.forward_table[codon]\n        this_codon_N_site = this_codon_S_site = 0\n        for neighbor in neighbor_codon['transition']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += 1\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += 1\n            else:\n                this_codon_N_site += 1\n        for neighbor in neighbor_codon['transversion']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += k\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += k\n            else:\n                this_codon_N_site += k\n        norm_const = (this_codon_N_site + this_codon_S_site) / 3\n        S_site += this_codon_S_site / norm_const\n        N_site += this_codon_N_site / norm_const\n    return (S_site, N_site)",
        "mutated": [
            "def _count_site_NG86(codon_lst, codon_table, k=1):\n    if False:\n        i = 10\n    'Count synonymous and non-synonymous sites of a list of codons (PRIVATE).\\n\\n    Arguments:\\n     - codon_lst - A three letter codon list from a CodonSeq object.\\n       This can be returned from _get_codon_list method.\\n     - k - transition/transversion rate ratio.\\n\\n    '\n    S_site = 0\n    N_site = 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    for codon in codon_lst:\n        neighbor_codon = {'transition': [], 'transversion': []}\n        codon = codon.replace('U', 'T')\n        if codon == '---':\n            continue\n        for (n, i) in enumerate(codon):\n            for j in base_tuple:\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                elif i in pyrimidine and j in pyrimidine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                else:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transversion'].append(this_codon)\n        aa = codon_table.forward_table[codon]\n        this_codon_N_site = this_codon_S_site = 0\n        for neighbor in neighbor_codon['transition']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += 1\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += 1\n            else:\n                this_codon_N_site += 1\n        for neighbor in neighbor_codon['transversion']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += k\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += k\n            else:\n                this_codon_N_site += k\n        norm_const = (this_codon_N_site + this_codon_S_site) / 3\n        S_site += this_codon_S_site / norm_const\n        N_site += this_codon_N_site / norm_const\n    return (S_site, N_site)",
            "def _count_site_NG86(codon_lst, codon_table, k=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Count synonymous and non-synonymous sites of a list of codons (PRIVATE).\\n\\n    Arguments:\\n     - codon_lst - A three letter codon list from a CodonSeq object.\\n       This can be returned from _get_codon_list method.\\n     - k - transition/transversion rate ratio.\\n\\n    '\n    S_site = 0\n    N_site = 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    for codon in codon_lst:\n        neighbor_codon = {'transition': [], 'transversion': []}\n        codon = codon.replace('U', 'T')\n        if codon == '---':\n            continue\n        for (n, i) in enumerate(codon):\n            for j in base_tuple:\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                elif i in pyrimidine and j in pyrimidine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                else:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transversion'].append(this_codon)\n        aa = codon_table.forward_table[codon]\n        this_codon_N_site = this_codon_S_site = 0\n        for neighbor in neighbor_codon['transition']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += 1\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += 1\n            else:\n                this_codon_N_site += 1\n        for neighbor in neighbor_codon['transversion']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += k\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += k\n            else:\n                this_codon_N_site += k\n        norm_const = (this_codon_N_site + this_codon_S_site) / 3\n        S_site += this_codon_S_site / norm_const\n        N_site += this_codon_N_site / norm_const\n    return (S_site, N_site)",
            "def _count_site_NG86(codon_lst, codon_table, k=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Count synonymous and non-synonymous sites of a list of codons (PRIVATE).\\n\\n    Arguments:\\n     - codon_lst - A three letter codon list from a CodonSeq object.\\n       This can be returned from _get_codon_list method.\\n     - k - transition/transversion rate ratio.\\n\\n    '\n    S_site = 0\n    N_site = 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    for codon in codon_lst:\n        neighbor_codon = {'transition': [], 'transversion': []}\n        codon = codon.replace('U', 'T')\n        if codon == '---':\n            continue\n        for (n, i) in enumerate(codon):\n            for j in base_tuple:\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                elif i in pyrimidine and j in pyrimidine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                else:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transversion'].append(this_codon)\n        aa = codon_table.forward_table[codon]\n        this_codon_N_site = this_codon_S_site = 0\n        for neighbor in neighbor_codon['transition']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += 1\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += 1\n            else:\n                this_codon_N_site += 1\n        for neighbor in neighbor_codon['transversion']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += k\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += k\n            else:\n                this_codon_N_site += k\n        norm_const = (this_codon_N_site + this_codon_S_site) / 3\n        S_site += this_codon_S_site / norm_const\n        N_site += this_codon_N_site / norm_const\n    return (S_site, N_site)",
            "def _count_site_NG86(codon_lst, codon_table, k=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Count synonymous and non-synonymous sites of a list of codons (PRIVATE).\\n\\n    Arguments:\\n     - codon_lst - A three letter codon list from a CodonSeq object.\\n       This can be returned from _get_codon_list method.\\n     - k - transition/transversion rate ratio.\\n\\n    '\n    S_site = 0\n    N_site = 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    for codon in codon_lst:\n        neighbor_codon = {'transition': [], 'transversion': []}\n        codon = codon.replace('U', 'T')\n        if codon == '---':\n            continue\n        for (n, i) in enumerate(codon):\n            for j in base_tuple:\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                elif i in pyrimidine and j in pyrimidine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                else:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transversion'].append(this_codon)\n        aa = codon_table.forward_table[codon]\n        this_codon_N_site = this_codon_S_site = 0\n        for neighbor in neighbor_codon['transition']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += 1\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += 1\n            else:\n                this_codon_N_site += 1\n        for neighbor in neighbor_codon['transversion']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += k\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += k\n            else:\n                this_codon_N_site += k\n        norm_const = (this_codon_N_site + this_codon_S_site) / 3\n        S_site += this_codon_S_site / norm_const\n        N_site += this_codon_N_site / norm_const\n    return (S_site, N_site)",
            "def _count_site_NG86(codon_lst, codon_table, k=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Count synonymous and non-synonymous sites of a list of codons (PRIVATE).\\n\\n    Arguments:\\n     - codon_lst - A three letter codon list from a CodonSeq object.\\n       This can be returned from _get_codon_list method.\\n     - k - transition/transversion rate ratio.\\n\\n    '\n    S_site = 0\n    N_site = 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    for codon in codon_lst:\n        neighbor_codon = {'transition': [], 'transversion': []}\n        codon = codon.replace('U', 'T')\n        if codon == '---':\n            continue\n        for (n, i) in enumerate(codon):\n            for j in base_tuple:\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                elif i in pyrimidine and j in pyrimidine:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transition'].append(this_codon)\n                else:\n                    codon_chars = list(codon)\n                    codon_chars[n] = j\n                    this_codon = ''.join(codon_chars)\n                    neighbor_codon['transversion'].append(this_codon)\n        aa = codon_table.forward_table[codon]\n        this_codon_N_site = this_codon_S_site = 0\n        for neighbor in neighbor_codon['transition']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += 1\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += 1\n            else:\n                this_codon_N_site += 1\n        for neighbor in neighbor_codon['transversion']:\n            if neighbor in codon_table.stop_codons:\n                this_codon_N_site += k\n            elif codon_table.forward_table[neighbor] == aa:\n                this_codon_S_site += k\n            else:\n                this_codon_N_site += k\n        norm_const = (this_codon_N_site + this_codon_S_site) / 3\n        S_site += this_codon_S_site / norm_const\n        N_site += this_codon_N_site / norm_const\n    return (S_site, N_site)"
        ]
    },
    {
        "func_name": "compare_codon",
        "original": "def compare_codon(codon1, codon2, codon_table, weight=1):\n    \"\"\"Compare two codon accounting for different pathways.\"\"\"\n    sd = nd = 0\n    if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n        sd += weight\n    else:\n        nd += weight\n    return (sd, nd)",
        "mutated": [
            "def compare_codon(codon1, codon2, codon_table, weight=1):\n    if False:\n        i = 10\n    'Compare two codon accounting for different pathways.'\n    sd = nd = 0\n    if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n        sd += weight\n    else:\n        nd += weight\n    return (sd, nd)",
            "def compare_codon(codon1, codon2, codon_table, weight=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compare two codon accounting for different pathways.'\n    sd = nd = 0\n    if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n        sd += weight\n    else:\n        nd += weight\n    return (sd, nd)",
            "def compare_codon(codon1, codon2, codon_table, weight=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compare two codon accounting for different pathways.'\n    sd = nd = 0\n    if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n        sd += weight\n    else:\n        nd += weight\n    return (sd, nd)",
            "def compare_codon(codon1, codon2, codon_table, weight=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compare two codon accounting for different pathways.'\n    sd = nd = 0\n    if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n        sd += weight\n    else:\n        nd += weight\n    return (sd, nd)",
            "def compare_codon(codon1, codon2, codon_table, weight=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compare two codon accounting for different pathways.'\n    sd = nd = 0\n    if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n        sd += weight\n    else:\n        nd += weight\n    return (sd, nd)"
        ]
    },
    {
        "func_name": "_count_diff_NG86",
        "original": "def _count_diff_NG86(codon1, codon2, codon_table):\n    \"\"\"Count differences between two codons, three-letter string (PRIVATE).\n\n    The function will take multiple pathways from codon1 to codon2\n    into account.\n    \"\"\"\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_NG86 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    SN = [0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return SN\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return SN\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def compare_codon(codon1, codon2, codon_table, weight=1):\n            \"\"\"Compare two codon accounting for different pathways.\"\"\"\n            sd = nd = 0\n            if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n                sd += weight\n            else:\n                nd += weight\n            return (sd, nd)\n        if len(diff_pos) == 1:\n            SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, codon2, codon_table=codon_table))]\n        elif len(diff_pos) == 2:\n            for i in diff_pos:\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, temp_codon, codon_table=codon_table, weight=0.5))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(temp_codon, codon2, codon_table=codon_table, weight=0.5))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, tmp1, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp1, tmp2, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp2, codon2, codon_table, weight=0.5 / 3))]\n    return SN",
        "mutated": [
            "def _count_diff_NG86(codon1, codon2, codon_table):\n    if False:\n        i = 10\n    'Count differences between two codons, three-letter string (PRIVATE).\\n\\n    The function will take multiple pathways from codon1 to codon2\\n    into account.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_NG86 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    SN = [0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return SN\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return SN\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def compare_codon(codon1, codon2, codon_table, weight=1):\n            \"\"\"Compare two codon accounting for different pathways.\"\"\"\n            sd = nd = 0\n            if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n                sd += weight\n            else:\n                nd += weight\n            return (sd, nd)\n        if len(diff_pos) == 1:\n            SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, codon2, codon_table=codon_table))]\n        elif len(diff_pos) == 2:\n            for i in diff_pos:\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, temp_codon, codon_table=codon_table, weight=0.5))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(temp_codon, codon2, codon_table=codon_table, weight=0.5))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, tmp1, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp1, tmp2, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp2, codon2, codon_table, weight=0.5 / 3))]\n    return SN",
            "def _count_diff_NG86(codon1, codon2, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Count differences between two codons, three-letter string (PRIVATE).\\n\\n    The function will take multiple pathways from codon1 to codon2\\n    into account.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_NG86 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    SN = [0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return SN\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return SN\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def compare_codon(codon1, codon2, codon_table, weight=1):\n            \"\"\"Compare two codon accounting for different pathways.\"\"\"\n            sd = nd = 0\n            if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n                sd += weight\n            else:\n                nd += weight\n            return (sd, nd)\n        if len(diff_pos) == 1:\n            SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, codon2, codon_table=codon_table))]\n        elif len(diff_pos) == 2:\n            for i in diff_pos:\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, temp_codon, codon_table=codon_table, weight=0.5))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(temp_codon, codon2, codon_table=codon_table, weight=0.5))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, tmp1, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp1, tmp2, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp2, codon2, codon_table, weight=0.5 / 3))]\n    return SN",
            "def _count_diff_NG86(codon1, codon2, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Count differences between two codons, three-letter string (PRIVATE).\\n\\n    The function will take multiple pathways from codon1 to codon2\\n    into account.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_NG86 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    SN = [0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return SN\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return SN\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def compare_codon(codon1, codon2, codon_table, weight=1):\n            \"\"\"Compare two codon accounting for different pathways.\"\"\"\n            sd = nd = 0\n            if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n                sd += weight\n            else:\n                nd += weight\n            return (sd, nd)\n        if len(diff_pos) == 1:\n            SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, codon2, codon_table=codon_table))]\n        elif len(diff_pos) == 2:\n            for i in diff_pos:\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, temp_codon, codon_table=codon_table, weight=0.5))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(temp_codon, codon2, codon_table=codon_table, weight=0.5))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, tmp1, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp1, tmp2, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp2, codon2, codon_table, weight=0.5 / 3))]\n    return SN",
            "def _count_diff_NG86(codon1, codon2, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Count differences between two codons, three-letter string (PRIVATE).\\n\\n    The function will take multiple pathways from codon1 to codon2\\n    into account.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_NG86 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    SN = [0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return SN\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return SN\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def compare_codon(codon1, codon2, codon_table, weight=1):\n            \"\"\"Compare two codon accounting for different pathways.\"\"\"\n            sd = nd = 0\n            if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n                sd += weight\n            else:\n                nd += weight\n            return (sd, nd)\n        if len(diff_pos) == 1:\n            SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, codon2, codon_table=codon_table))]\n        elif len(diff_pos) == 2:\n            for i in diff_pos:\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, temp_codon, codon_table=codon_table, weight=0.5))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(temp_codon, codon2, codon_table=codon_table, weight=0.5))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, tmp1, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp1, tmp2, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp2, codon2, codon_table, weight=0.5 / 3))]\n    return SN",
            "def _count_diff_NG86(codon1, codon2, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Count differences between two codons, three-letter string (PRIVATE).\\n\\n    The function will take multiple pathways from codon1 to codon2\\n    into account.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_NG86 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    SN = [0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return SN\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return SN\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def compare_codon(codon1, codon2, codon_table, weight=1):\n            \"\"\"Compare two codon accounting for different pathways.\"\"\"\n            sd = nd = 0\n            if len(set(map(codon_table.forward_table.get, [codon1, codon2]))) == 1:\n                sd += weight\n            else:\n                nd += weight\n            return (sd, nd)\n        if len(diff_pos) == 1:\n            SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, codon2, codon_table=codon_table))]\n        elif len(diff_pos) == 2:\n            for i in diff_pos:\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, temp_codon, codon_table=codon_table, weight=0.5))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(temp_codon, codon2, codon_table=codon_table, weight=0.5))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                SN = [i + j for (i, j) in zip(SN, compare_codon(codon1, tmp1, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp1, tmp2, codon_table, weight=0.5 / 3))]\n                SN = [i + j for (i, j) in zip(SN, compare_codon(tmp2, codon2, codon_table, weight=0.5 / 3))]\n    return SN"
        ]
    },
    {
        "func_name": "_lwl85",
        "original": "def _lwl85(seq1, seq2, k, codon_table):\n    \"\"\"LWL85 method main function (PRIVATE).\n\n    Nomenclature is according to Li et al. (1985), PMID 3916709.\n    \"\"\"\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0 = [0, 0]\n    fold2 = [0, 0]\n    fold4 = [0, 0]\n    for codon in seq1 + seq2:\n        fold_num = codon_fold_dict[codon]\n        for f in fold_num:\n            if f == '0':\n                fold0[0] += 1\n            elif f == '2':\n                fold2[0] += 1\n            elif f == '4':\n                fold4[0] += 1\n    L = [sum(fold0) / 2.0, sum(fold2) / 2.0, sum(fold4) / 2.0]\n    PQ = [0] * 6\n    for (codon1, codon2) in zip(seq1, seq2):\n        if (codon1 == '---' or codon2 == '---') or codon1 == codon2:\n            continue\n        else:\n            PQ = [i + j for (i, j) in zip(PQ, _diff_codon(codon1, codon2, fold_dict=codon_fold_dict))]\n    PQ = [i / j for (i, j) in zip(PQ, L * 2)]\n    P = PQ[:3]\n    Q = PQ[3:]\n    A = [1.0 / 2 * log(1.0 / (1 - 2 * i - j)) - 1.0 / 4 * log(1.0 / (1 - 2 * j)) for (i, j) in zip(P, Q)]\n    B = [1.0 / 2 * log(1.0 / (1 - 2 * i)) for i in Q]\n    dS = 3 * (L[2] * A[1] + L[2] * (A[2] + B[2])) / (L[1] + 3 * L[2])\n    dN = 3 * (L[2] * B[1] + L[0] * (A[0] + B[0])) / (2 * L[1] + 3 * L[0])\n    return (dN, dS)",
        "mutated": [
            "def _lwl85(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n    'LWL85 method main function (PRIVATE).\\n\\n    Nomenclature is according to Li et al. (1985), PMID 3916709.\\n    '\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0 = [0, 0]\n    fold2 = [0, 0]\n    fold4 = [0, 0]\n    for codon in seq1 + seq2:\n        fold_num = codon_fold_dict[codon]\n        for f in fold_num:\n            if f == '0':\n                fold0[0] += 1\n            elif f == '2':\n                fold2[0] += 1\n            elif f == '4':\n                fold4[0] += 1\n    L = [sum(fold0) / 2.0, sum(fold2) / 2.0, sum(fold4) / 2.0]\n    PQ = [0] * 6\n    for (codon1, codon2) in zip(seq1, seq2):\n        if (codon1 == '---' or codon2 == '---') or codon1 == codon2:\n            continue\n        else:\n            PQ = [i + j for (i, j) in zip(PQ, _diff_codon(codon1, codon2, fold_dict=codon_fold_dict))]\n    PQ = [i / j for (i, j) in zip(PQ, L * 2)]\n    P = PQ[:3]\n    Q = PQ[3:]\n    A = [1.0 / 2 * log(1.0 / (1 - 2 * i - j)) - 1.0 / 4 * log(1.0 / (1 - 2 * j)) for (i, j) in zip(P, Q)]\n    B = [1.0 / 2 * log(1.0 / (1 - 2 * i)) for i in Q]\n    dS = 3 * (L[2] * A[1] + L[2] * (A[2] + B[2])) / (L[1] + 3 * L[2])\n    dN = 3 * (L[2] * B[1] + L[0] * (A[0] + B[0])) / (2 * L[1] + 3 * L[0])\n    return (dN, dS)",
            "def _lwl85(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'LWL85 method main function (PRIVATE).\\n\\n    Nomenclature is according to Li et al. (1985), PMID 3916709.\\n    '\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0 = [0, 0]\n    fold2 = [0, 0]\n    fold4 = [0, 0]\n    for codon in seq1 + seq2:\n        fold_num = codon_fold_dict[codon]\n        for f in fold_num:\n            if f == '0':\n                fold0[0] += 1\n            elif f == '2':\n                fold2[0] += 1\n            elif f == '4':\n                fold4[0] += 1\n    L = [sum(fold0) / 2.0, sum(fold2) / 2.0, sum(fold4) / 2.0]\n    PQ = [0] * 6\n    for (codon1, codon2) in zip(seq1, seq2):\n        if (codon1 == '---' or codon2 == '---') or codon1 == codon2:\n            continue\n        else:\n            PQ = [i + j for (i, j) in zip(PQ, _diff_codon(codon1, codon2, fold_dict=codon_fold_dict))]\n    PQ = [i / j for (i, j) in zip(PQ, L * 2)]\n    P = PQ[:3]\n    Q = PQ[3:]\n    A = [1.0 / 2 * log(1.0 / (1 - 2 * i - j)) - 1.0 / 4 * log(1.0 / (1 - 2 * j)) for (i, j) in zip(P, Q)]\n    B = [1.0 / 2 * log(1.0 / (1 - 2 * i)) for i in Q]\n    dS = 3 * (L[2] * A[1] + L[2] * (A[2] + B[2])) / (L[1] + 3 * L[2])\n    dN = 3 * (L[2] * B[1] + L[0] * (A[0] + B[0])) / (2 * L[1] + 3 * L[0])\n    return (dN, dS)",
            "def _lwl85(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'LWL85 method main function (PRIVATE).\\n\\n    Nomenclature is according to Li et al. (1985), PMID 3916709.\\n    '\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0 = [0, 0]\n    fold2 = [0, 0]\n    fold4 = [0, 0]\n    for codon in seq1 + seq2:\n        fold_num = codon_fold_dict[codon]\n        for f in fold_num:\n            if f == '0':\n                fold0[0] += 1\n            elif f == '2':\n                fold2[0] += 1\n            elif f == '4':\n                fold4[0] += 1\n    L = [sum(fold0) / 2.0, sum(fold2) / 2.0, sum(fold4) / 2.0]\n    PQ = [0] * 6\n    for (codon1, codon2) in zip(seq1, seq2):\n        if (codon1 == '---' or codon2 == '---') or codon1 == codon2:\n            continue\n        else:\n            PQ = [i + j for (i, j) in zip(PQ, _diff_codon(codon1, codon2, fold_dict=codon_fold_dict))]\n    PQ = [i / j for (i, j) in zip(PQ, L * 2)]\n    P = PQ[:3]\n    Q = PQ[3:]\n    A = [1.0 / 2 * log(1.0 / (1 - 2 * i - j)) - 1.0 / 4 * log(1.0 / (1 - 2 * j)) for (i, j) in zip(P, Q)]\n    B = [1.0 / 2 * log(1.0 / (1 - 2 * i)) for i in Q]\n    dS = 3 * (L[2] * A[1] + L[2] * (A[2] + B[2])) / (L[1] + 3 * L[2])\n    dN = 3 * (L[2] * B[1] + L[0] * (A[0] + B[0])) / (2 * L[1] + 3 * L[0])\n    return (dN, dS)",
            "def _lwl85(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'LWL85 method main function (PRIVATE).\\n\\n    Nomenclature is according to Li et al. (1985), PMID 3916709.\\n    '\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0 = [0, 0]\n    fold2 = [0, 0]\n    fold4 = [0, 0]\n    for codon in seq1 + seq2:\n        fold_num = codon_fold_dict[codon]\n        for f in fold_num:\n            if f == '0':\n                fold0[0] += 1\n            elif f == '2':\n                fold2[0] += 1\n            elif f == '4':\n                fold4[0] += 1\n    L = [sum(fold0) / 2.0, sum(fold2) / 2.0, sum(fold4) / 2.0]\n    PQ = [0] * 6\n    for (codon1, codon2) in zip(seq1, seq2):\n        if (codon1 == '---' or codon2 == '---') or codon1 == codon2:\n            continue\n        else:\n            PQ = [i + j for (i, j) in zip(PQ, _diff_codon(codon1, codon2, fold_dict=codon_fold_dict))]\n    PQ = [i / j for (i, j) in zip(PQ, L * 2)]\n    P = PQ[:3]\n    Q = PQ[3:]\n    A = [1.0 / 2 * log(1.0 / (1 - 2 * i - j)) - 1.0 / 4 * log(1.0 / (1 - 2 * j)) for (i, j) in zip(P, Q)]\n    B = [1.0 / 2 * log(1.0 / (1 - 2 * i)) for i in Q]\n    dS = 3 * (L[2] * A[1] + L[2] * (A[2] + B[2])) / (L[1] + 3 * L[2])\n    dN = 3 * (L[2] * B[1] + L[0] * (A[0] + B[0])) / (2 * L[1] + 3 * L[0])\n    return (dN, dS)",
            "def _lwl85(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'LWL85 method main function (PRIVATE).\\n\\n    Nomenclature is according to Li et al. (1985), PMID 3916709.\\n    '\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0 = [0, 0]\n    fold2 = [0, 0]\n    fold4 = [0, 0]\n    for codon in seq1 + seq2:\n        fold_num = codon_fold_dict[codon]\n        for f in fold_num:\n            if f == '0':\n                fold0[0] += 1\n            elif f == '2':\n                fold2[0] += 1\n            elif f == '4':\n                fold4[0] += 1\n    L = [sum(fold0) / 2.0, sum(fold2) / 2.0, sum(fold4) / 2.0]\n    PQ = [0] * 6\n    for (codon1, codon2) in zip(seq1, seq2):\n        if (codon1 == '---' or codon2 == '---') or codon1 == codon2:\n            continue\n        else:\n            PQ = [i + j for (i, j) in zip(PQ, _diff_codon(codon1, codon2, fold_dict=codon_fold_dict))]\n    PQ = [i / j for (i, j) in zip(PQ, L * 2)]\n    P = PQ[:3]\n    Q = PQ[3:]\n    A = [1.0 / 2 * log(1.0 / (1 - 2 * i - j)) - 1.0 / 4 * log(1.0 / (1 - 2 * j)) for (i, j) in zip(P, Q)]\n    B = [1.0 / 2 * log(1.0 / (1 - 2 * i)) for i in Q]\n    dS = 3 * (L[2] * A[1] + L[2] * (A[2] + B[2])) / (L[1] + 3 * L[2])\n    dN = 3 * (L[2] * B[1] + L[0] * (A[0] + B[0])) / (2 * L[1] + 3 * L[0])\n    return (dN, dS)"
        ]
    },
    {
        "func_name": "find_fold_class",
        "original": "def find_fold_class(codon, forward_table):\n    base = {'A', 'T', 'C', 'G'}\n    fold = ''\n    codon_base_lst = list(codon)\n    for (i, b) in enumerate(codon_base_lst):\n        other_base = base - set(b)\n        aa = []\n        for j in other_base:\n            codon_base_lst[i] = j\n            try:\n                aa.append(forward_table[''.join(codon_base_lst)])\n            except KeyError:\n                aa.append('stop')\n        if aa.count(forward_table[codon]) == 0:\n            fold += '0'\n        elif aa.count(forward_table[codon]) in (1, 2):\n            fold += '2'\n        elif aa.count(forward_table[codon]) == 3:\n            fold += '4'\n        else:\n            raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n        codon_base_lst[i] = b\n    return fold",
        "mutated": [
            "def find_fold_class(codon, forward_table):\n    if False:\n        i = 10\n    base = {'A', 'T', 'C', 'G'}\n    fold = ''\n    codon_base_lst = list(codon)\n    for (i, b) in enumerate(codon_base_lst):\n        other_base = base - set(b)\n        aa = []\n        for j in other_base:\n            codon_base_lst[i] = j\n            try:\n                aa.append(forward_table[''.join(codon_base_lst)])\n            except KeyError:\n                aa.append('stop')\n        if aa.count(forward_table[codon]) == 0:\n            fold += '0'\n        elif aa.count(forward_table[codon]) in (1, 2):\n            fold += '2'\n        elif aa.count(forward_table[codon]) == 3:\n            fold += '4'\n        else:\n            raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n        codon_base_lst[i] = b\n    return fold",
            "def find_fold_class(codon, forward_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    base = {'A', 'T', 'C', 'G'}\n    fold = ''\n    codon_base_lst = list(codon)\n    for (i, b) in enumerate(codon_base_lst):\n        other_base = base - set(b)\n        aa = []\n        for j in other_base:\n            codon_base_lst[i] = j\n            try:\n                aa.append(forward_table[''.join(codon_base_lst)])\n            except KeyError:\n                aa.append('stop')\n        if aa.count(forward_table[codon]) == 0:\n            fold += '0'\n        elif aa.count(forward_table[codon]) in (1, 2):\n            fold += '2'\n        elif aa.count(forward_table[codon]) == 3:\n            fold += '4'\n        else:\n            raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n        codon_base_lst[i] = b\n    return fold",
            "def find_fold_class(codon, forward_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    base = {'A', 'T', 'C', 'G'}\n    fold = ''\n    codon_base_lst = list(codon)\n    for (i, b) in enumerate(codon_base_lst):\n        other_base = base - set(b)\n        aa = []\n        for j in other_base:\n            codon_base_lst[i] = j\n            try:\n                aa.append(forward_table[''.join(codon_base_lst)])\n            except KeyError:\n                aa.append('stop')\n        if aa.count(forward_table[codon]) == 0:\n            fold += '0'\n        elif aa.count(forward_table[codon]) in (1, 2):\n            fold += '2'\n        elif aa.count(forward_table[codon]) == 3:\n            fold += '4'\n        else:\n            raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n        codon_base_lst[i] = b\n    return fold",
            "def find_fold_class(codon, forward_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    base = {'A', 'T', 'C', 'G'}\n    fold = ''\n    codon_base_lst = list(codon)\n    for (i, b) in enumerate(codon_base_lst):\n        other_base = base - set(b)\n        aa = []\n        for j in other_base:\n            codon_base_lst[i] = j\n            try:\n                aa.append(forward_table[''.join(codon_base_lst)])\n            except KeyError:\n                aa.append('stop')\n        if aa.count(forward_table[codon]) == 0:\n            fold += '0'\n        elif aa.count(forward_table[codon]) in (1, 2):\n            fold += '2'\n        elif aa.count(forward_table[codon]) == 3:\n            fold += '4'\n        else:\n            raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n        codon_base_lst[i] = b\n    return fold",
            "def find_fold_class(codon, forward_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    base = {'A', 'T', 'C', 'G'}\n    fold = ''\n    codon_base_lst = list(codon)\n    for (i, b) in enumerate(codon_base_lst):\n        other_base = base - set(b)\n        aa = []\n        for j in other_base:\n            codon_base_lst[i] = j\n            try:\n                aa.append(forward_table[''.join(codon_base_lst)])\n            except KeyError:\n                aa.append('stop')\n        if aa.count(forward_table[codon]) == 0:\n            fold += '0'\n        elif aa.count(forward_table[codon]) in (1, 2):\n            fold += '2'\n        elif aa.count(forward_table[codon]) == 3:\n            fold += '4'\n        else:\n            raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n        codon_base_lst[i] = b\n    return fold"
        ]
    },
    {
        "func_name": "_get_codon_fold",
        "original": "def _get_codon_fold(codon_table):\n    \"\"\"Classify different position in a codon into different folds (PRIVATE).\"\"\"\n\n    def find_fold_class(codon, forward_table):\n        base = {'A', 'T', 'C', 'G'}\n        fold = ''\n        codon_base_lst = list(codon)\n        for (i, b) in enumerate(codon_base_lst):\n            other_base = base - set(b)\n            aa = []\n            for j in other_base:\n                codon_base_lst[i] = j\n                try:\n                    aa.append(forward_table[''.join(codon_base_lst)])\n                except KeyError:\n                    aa.append('stop')\n            if aa.count(forward_table[codon]) == 0:\n                fold += '0'\n            elif aa.count(forward_table[codon]) in (1, 2):\n                fold += '2'\n            elif aa.count(forward_table[codon]) == 3:\n                fold += '4'\n            else:\n                raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n            codon_base_lst[i] = b\n        return fold\n    fold_table = {}\n    for codon in codon_table.forward_table:\n        if 'U' not in codon:\n            fold_table[codon] = find_fold_class(codon, codon_table.forward_table)\n    fold_table['---'] = '---'\n    return fold_table",
        "mutated": [
            "def _get_codon_fold(codon_table):\n    if False:\n        i = 10\n    'Classify different position in a codon into different folds (PRIVATE).'\n\n    def find_fold_class(codon, forward_table):\n        base = {'A', 'T', 'C', 'G'}\n        fold = ''\n        codon_base_lst = list(codon)\n        for (i, b) in enumerate(codon_base_lst):\n            other_base = base - set(b)\n            aa = []\n            for j in other_base:\n                codon_base_lst[i] = j\n                try:\n                    aa.append(forward_table[''.join(codon_base_lst)])\n                except KeyError:\n                    aa.append('stop')\n            if aa.count(forward_table[codon]) == 0:\n                fold += '0'\n            elif aa.count(forward_table[codon]) in (1, 2):\n                fold += '2'\n            elif aa.count(forward_table[codon]) == 3:\n                fold += '4'\n            else:\n                raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n            codon_base_lst[i] = b\n        return fold\n    fold_table = {}\n    for codon in codon_table.forward_table:\n        if 'U' not in codon:\n            fold_table[codon] = find_fold_class(codon, codon_table.forward_table)\n    fold_table['---'] = '---'\n    return fold_table",
            "def _get_codon_fold(codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Classify different position in a codon into different folds (PRIVATE).'\n\n    def find_fold_class(codon, forward_table):\n        base = {'A', 'T', 'C', 'G'}\n        fold = ''\n        codon_base_lst = list(codon)\n        for (i, b) in enumerate(codon_base_lst):\n            other_base = base - set(b)\n            aa = []\n            for j in other_base:\n                codon_base_lst[i] = j\n                try:\n                    aa.append(forward_table[''.join(codon_base_lst)])\n                except KeyError:\n                    aa.append('stop')\n            if aa.count(forward_table[codon]) == 0:\n                fold += '0'\n            elif aa.count(forward_table[codon]) in (1, 2):\n                fold += '2'\n            elif aa.count(forward_table[codon]) == 3:\n                fold += '4'\n            else:\n                raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n            codon_base_lst[i] = b\n        return fold\n    fold_table = {}\n    for codon in codon_table.forward_table:\n        if 'U' not in codon:\n            fold_table[codon] = find_fold_class(codon, codon_table.forward_table)\n    fold_table['---'] = '---'\n    return fold_table",
            "def _get_codon_fold(codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Classify different position in a codon into different folds (PRIVATE).'\n\n    def find_fold_class(codon, forward_table):\n        base = {'A', 'T', 'C', 'G'}\n        fold = ''\n        codon_base_lst = list(codon)\n        for (i, b) in enumerate(codon_base_lst):\n            other_base = base - set(b)\n            aa = []\n            for j in other_base:\n                codon_base_lst[i] = j\n                try:\n                    aa.append(forward_table[''.join(codon_base_lst)])\n                except KeyError:\n                    aa.append('stop')\n            if aa.count(forward_table[codon]) == 0:\n                fold += '0'\n            elif aa.count(forward_table[codon]) in (1, 2):\n                fold += '2'\n            elif aa.count(forward_table[codon]) == 3:\n                fold += '4'\n            else:\n                raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n            codon_base_lst[i] = b\n        return fold\n    fold_table = {}\n    for codon in codon_table.forward_table:\n        if 'U' not in codon:\n            fold_table[codon] = find_fold_class(codon, codon_table.forward_table)\n    fold_table['---'] = '---'\n    return fold_table",
            "def _get_codon_fold(codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Classify different position in a codon into different folds (PRIVATE).'\n\n    def find_fold_class(codon, forward_table):\n        base = {'A', 'T', 'C', 'G'}\n        fold = ''\n        codon_base_lst = list(codon)\n        for (i, b) in enumerate(codon_base_lst):\n            other_base = base - set(b)\n            aa = []\n            for j in other_base:\n                codon_base_lst[i] = j\n                try:\n                    aa.append(forward_table[''.join(codon_base_lst)])\n                except KeyError:\n                    aa.append('stop')\n            if aa.count(forward_table[codon]) == 0:\n                fold += '0'\n            elif aa.count(forward_table[codon]) in (1, 2):\n                fold += '2'\n            elif aa.count(forward_table[codon]) == 3:\n                fold += '4'\n            else:\n                raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n            codon_base_lst[i] = b\n        return fold\n    fold_table = {}\n    for codon in codon_table.forward_table:\n        if 'U' not in codon:\n            fold_table[codon] = find_fold_class(codon, codon_table.forward_table)\n    fold_table['---'] = '---'\n    return fold_table",
            "def _get_codon_fold(codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Classify different position in a codon into different folds (PRIVATE).'\n\n    def find_fold_class(codon, forward_table):\n        base = {'A', 'T', 'C', 'G'}\n        fold = ''\n        codon_base_lst = list(codon)\n        for (i, b) in enumerate(codon_base_lst):\n            other_base = base - set(b)\n            aa = []\n            for j in other_base:\n                codon_base_lst[i] = j\n                try:\n                    aa.append(forward_table[''.join(codon_base_lst)])\n                except KeyError:\n                    aa.append('stop')\n            if aa.count(forward_table[codon]) == 0:\n                fold += '0'\n            elif aa.count(forward_table[codon]) in (1, 2):\n                fold += '2'\n            elif aa.count(forward_table[codon]) == 3:\n                fold += '4'\n            else:\n                raise RuntimeError('Unknown Error, cannot assign the position to a fold')\n            codon_base_lst[i] = b\n        return fold\n    fold_table = {}\n    for codon in codon_table.forward_table:\n        if 'U' not in codon:\n            fold_table[codon] = find_fold_class(codon, codon_table.forward_table)\n    fold_table['---'] = '---'\n    return fold_table"
        ]
    },
    {
        "func_name": "_diff_codon",
        "original": "def _diff_codon(codon1, codon2, fold_dict):\n    \"\"\"Count number of different substitution types between two codons (PRIVATE).\n\n    returns tuple (P0, P2, P4, Q0, Q2, Q4)\n\n    Nomenclature is according to Li et al. (1958), PMID 3916709.\n    \"\"\"\n    P0 = P2 = P4 = Q0 = Q2 = Q4 = 0\n    fold_num = fold_dict[codon1]\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    for (n, (i, j)) in enumerate(zip(codon1, codon2)):\n        if i != j and (i in purine and j in purine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in pyrimidine and j in pyrimidine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in purine and j in pyrimidine or (i in pyrimidine and j in purine)):\n            if fold_num[n] == '0':\n                Q0 += 1\n            elif fold_num[n] == '2':\n                Q2 += 1\n            elif fold_num[n] == '4':\n                Q4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n    return (P0, P2, P4, Q0, Q2, Q4)",
        "mutated": [
            "def _diff_codon(codon1, codon2, fold_dict):\n    if False:\n        i = 10\n    'Count number of different substitution types between two codons (PRIVATE).\\n\\n    returns tuple (P0, P2, P4, Q0, Q2, Q4)\\n\\n    Nomenclature is according to Li et al. (1958), PMID 3916709.\\n    '\n    P0 = P2 = P4 = Q0 = Q2 = Q4 = 0\n    fold_num = fold_dict[codon1]\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    for (n, (i, j)) in enumerate(zip(codon1, codon2)):\n        if i != j and (i in purine and j in purine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in pyrimidine and j in pyrimidine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in purine and j in pyrimidine or (i in pyrimidine and j in purine)):\n            if fold_num[n] == '0':\n                Q0 += 1\n            elif fold_num[n] == '2':\n                Q2 += 1\n            elif fold_num[n] == '4':\n                Q4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n    return (P0, P2, P4, Q0, Q2, Q4)",
            "def _diff_codon(codon1, codon2, fold_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Count number of different substitution types between two codons (PRIVATE).\\n\\n    returns tuple (P0, P2, P4, Q0, Q2, Q4)\\n\\n    Nomenclature is according to Li et al. (1958), PMID 3916709.\\n    '\n    P0 = P2 = P4 = Q0 = Q2 = Q4 = 0\n    fold_num = fold_dict[codon1]\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    for (n, (i, j)) in enumerate(zip(codon1, codon2)):\n        if i != j and (i in purine and j in purine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in pyrimidine and j in pyrimidine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in purine and j in pyrimidine or (i in pyrimidine and j in purine)):\n            if fold_num[n] == '0':\n                Q0 += 1\n            elif fold_num[n] == '2':\n                Q2 += 1\n            elif fold_num[n] == '4':\n                Q4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n    return (P0, P2, P4, Q0, Q2, Q4)",
            "def _diff_codon(codon1, codon2, fold_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Count number of different substitution types between two codons (PRIVATE).\\n\\n    returns tuple (P0, P2, P4, Q0, Q2, Q4)\\n\\n    Nomenclature is according to Li et al. (1958), PMID 3916709.\\n    '\n    P0 = P2 = P4 = Q0 = Q2 = Q4 = 0\n    fold_num = fold_dict[codon1]\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    for (n, (i, j)) in enumerate(zip(codon1, codon2)):\n        if i != j and (i in purine and j in purine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in pyrimidine and j in pyrimidine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in purine and j in pyrimidine or (i in pyrimidine and j in purine)):\n            if fold_num[n] == '0':\n                Q0 += 1\n            elif fold_num[n] == '2':\n                Q2 += 1\n            elif fold_num[n] == '4':\n                Q4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n    return (P0, P2, P4, Q0, Q2, Q4)",
            "def _diff_codon(codon1, codon2, fold_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Count number of different substitution types between two codons (PRIVATE).\\n\\n    returns tuple (P0, P2, P4, Q0, Q2, Q4)\\n\\n    Nomenclature is according to Li et al. (1958), PMID 3916709.\\n    '\n    P0 = P2 = P4 = Q0 = Q2 = Q4 = 0\n    fold_num = fold_dict[codon1]\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    for (n, (i, j)) in enumerate(zip(codon1, codon2)):\n        if i != j and (i in purine and j in purine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in pyrimidine and j in pyrimidine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in purine and j in pyrimidine or (i in pyrimidine and j in purine)):\n            if fold_num[n] == '0':\n                Q0 += 1\n            elif fold_num[n] == '2':\n                Q2 += 1\n            elif fold_num[n] == '4':\n                Q4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n    return (P0, P2, P4, Q0, Q2, Q4)",
            "def _diff_codon(codon1, codon2, fold_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Count number of different substitution types between two codons (PRIVATE).\\n\\n    returns tuple (P0, P2, P4, Q0, Q2, Q4)\\n\\n    Nomenclature is according to Li et al. (1958), PMID 3916709.\\n    '\n    P0 = P2 = P4 = Q0 = Q2 = Q4 = 0\n    fold_num = fold_dict[codon1]\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    for (n, (i, j)) in enumerate(zip(codon1, codon2)):\n        if i != j and (i in purine and j in purine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in pyrimidine and j in pyrimidine):\n            if fold_num[n] == '0':\n                P0 += 1\n            elif fold_num[n] == '2':\n                P2 += 1\n            elif fold_num[n] == '4':\n                P4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n        if i != j and (i in purine and j in pyrimidine or (i in pyrimidine and j in purine)):\n            if fold_num[n] == '0':\n                Q0 += 1\n            elif fold_num[n] == '2':\n                Q2 += 1\n            elif fold_num[n] == '4':\n                Q4 += 1\n            else:\n                raise RuntimeError('Unexpected fold_num %d' % fold_num[n])\n    return (P0, P2, P4, Q0, Q2, Q4)"
        ]
    },
    {
        "func_name": "_yn00",
        "original": "def _yn00(seq1, seq2, k, codon_table):\n    \"\"\"YN00 method main function (PRIVATE).\n\n    Nomenclature is according to Yang and Nielsen (2000), PMID 10666704.\n    \"\"\"\n    from collections import defaultdict\n    from scipy.linalg import expm\n    fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0_cnt = defaultdict(int)\n    fold4_cnt = defaultdict(int)\n    for codon in seq1 + seq2:\n        if codon != '---':\n            fcodon[0][codon[0]] += 1\n            fcodon[1][codon[1]] += 1\n            fcodon[2][codon[2]] += 1\n        fold_num = codon_fold_dict[codon]\n        for (i, f) in enumerate(fold_num):\n            if f == '0':\n                fold0_cnt[codon[i]] += 1\n            elif f == '4':\n                fold4_cnt[codon[i]] += 1\n    f0_total = sum(fold0_cnt.values())\n    f4_total = sum(fold4_cnt.values())\n    for (i, j) in zip(fold0_cnt, fold4_cnt):\n        fold0_cnt[i] = fold0_cnt[i] / f0_total\n        fold4_cnt[i] = fold4_cnt[i] / f4_total\n    TV = _get_TV(seq1, seq2, codon_table=codon_table)\n    k04 = (_get_kappa_t(fold0_cnt, TV), _get_kappa_t(fold4_cnt, TV))\n    kappa = (f0_total * k04[0] + f4_total * k04[1]) / (f0_total + f4_total)\n    for i in range(3):\n        tot = sum(fcodon[i].values())\n        fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n    pi = defaultdict(int)\n    for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n        if 'U' not in i:\n            pi[i] = 0\n    for i in seq1 + seq2:\n        pi[i] += 1\n    (S_sites1, N_sites1, bfreqSN1) = _count_site_YN00(seq1, seq2, pi, k=kappa, codon_table=codon_table)\n    (S_sites2, N_sites2, bfreqSN2) = _count_site_YN00(seq2, seq1, pi, k=kappa, codon_table=codon_table)\n    N_sites = (N_sites1 + N_sites2) / 2\n    S_sites = (S_sites1 + S_sites2) / 2\n    bfreqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for i in range(2):\n        for b in ('A', 'T', 'C', 'G'):\n            bfreqSN[i][b] = (bfreqSN1[i][b] + bfreqSN2[i][b]) / 2\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    p = sum(SN) / (S_sites + N_sites)\n    w = log(1 - 4.0 / 3 * pn) / log(1 - 4.0 / 3 * ps)\n    t = -3 / 4 * log(1 - 4 / 3 * p)\n    tolerance = 1e-05\n    dSdN_pre = [0, 0]\n    for temp in range(20):\n        codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n        Q = _get_Q(pi, kappa, w, codon_lst, codon_table)\n        P = expm(Q * t)\n        TV = [0, 0, 0, 0]\n        codon_npath = {}\n        for (i, j) in zip(seq1, seq2):\n            if i != '---' and j != '---':\n                codon_npath.setdefault((i, j), 0)\n                codon_npath[i, j] += 1\n        for i in codon_npath:\n            tv = _count_diff_YN00(i[0], i[1], P, codon_lst, codon_table)\n            TV = [m + n * codon_npath[i] for (m, n) in zip(TV, tv)]\n        TV = ((TV[0] / S_sites, TV[1] / S_sites), (TV[2] / N_sites, TV[3] / N_sites))\n        dSdN = []\n        for (f, tv) in zip(bfreqSN, TV):\n            dSdN.append(_get_kappa_t(f, tv, t=True))\n        t = dSdN[0] * 3 * S_sites / (S_sites + N_sites) + dSdN[1] * 3 * N_sites / (S_sites + N_sites)\n        w = dSdN[1] / dSdN[0]\n        if all((abs(i - j) < tolerance for (i, j) in zip(dSdN, dSdN_pre))):\n            return (dSdN[1], dSdN[0])\n        dSdN_pre = dSdN",
        "mutated": [
            "def _yn00(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n    'YN00 method main function (PRIVATE).\\n\\n    Nomenclature is according to Yang and Nielsen (2000), PMID 10666704.\\n    '\n    from collections import defaultdict\n    from scipy.linalg import expm\n    fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0_cnt = defaultdict(int)\n    fold4_cnt = defaultdict(int)\n    for codon in seq1 + seq2:\n        if codon != '---':\n            fcodon[0][codon[0]] += 1\n            fcodon[1][codon[1]] += 1\n            fcodon[2][codon[2]] += 1\n        fold_num = codon_fold_dict[codon]\n        for (i, f) in enumerate(fold_num):\n            if f == '0':\n                fold0_cnt[codon[i]] += 1\n            elif f == '4':\n                fold4_cnt[codon[i]] += 1\n    f0_total = sum(fold0_cnt.values())\n    f4_total = sum(fold4_cnt.values())\n    for (i, j) in zip(fold0_cnt, fold4_cnt):\n        fold0_cnt[i] = fold0_cnt[i] / f0_total\n        fold4_cnt[i] = fold4_cnt[i] / f4_total\n    TV = _get_TV(seq1, seq2, codon_table=codon_table)\n    k04 = (_get_kappa_t(fold0_cnt, TV), _get_kappa_t(fold4_cnt, TV))\n    kappa = (f0_total * k04[0] + f4_total * k04[1]) / (f0_total + f4_total)\n    for i in range(3):\n        tot = sum(fcodon[i].values())\n        fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n    pi = defaultdict(int)\n    for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n        if 'U' not in i:\n            pi[i] = 0\n    for i in seq1 + seq2:\n        pi[i] += 1\n    (S_sites1, N_sites1, bfreqSN1) = _count_site_YN00(seq1, seq2, pi, k=kappa, codon_table=codon_table)\n    (S_sites2, N_sites2, bfreqSN2) = _count_site_YN00(seq2, seq1, pi, k=kappa, codon_table=codon_table)\n    N_sites = (N_sites1 + N_sites2) / 2\n    S_sites = (S_sites1 + S_sites2) / 2\n    bfreqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for i in range(2):\n        for b in ('A', 'T', 'C', 'G'):\n            bfreqSN[i][b] = (bfreqSN1[i][b] + bfreqSN2[i][b]) / 2\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    p = sum(SN) / (S_sites + N_sites)\n    w = log(1 - 4.0 / 3 * pn) / log(1 - 4.0 / 3 * ps)\n    t = -3 / 4 * log(1 - 4 / 3 * p)\n    tolerance = 1e-05\n    dSdN_pre = [0, 0]\n    for temp in range(20):\n        codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n        Q = _get_Q(pi, kappa, w, codon_lst, codon_table)\n        P = expm(Q * t)\n        TV = [0, 0, 0, 0]\n        codon_npath = {}\n        for (i, j) in zip(seq1, seq2):\n            if i != '---' and j != '---':\n                codon_npath.setdefault((i, j), 0)\n                codon_npath[i, j] += 1\n        for i in codon_npath:\n            tv = _count_diff_YN00(i[0], i[1], P, codon_lst, codon_table)\n            TV = [m + n * codon_npath[i] for (m, n) in zip(TV, tv)]\n        TV = ((TV[0] / S_sites, TV[1] / S_sites), (TV[2] / N_sites, TV[3] / N_sites))\n        dSdN = []\n        for (f, tv) in zip(bfreqSN, TV):\n            dSdN.append(_get_kappa_t(f, tv, t=True))\n        t = dSdN[0] * 3 * S_sites / (S_sites + N_sites) + dSdN[1] * 3 * N_sites / (S_sites + N_sites)\n        w = dSdN[1] / dSdN[0]\n        if all((abs(i - j) < tolerance for (i, j) in zip(dSdN, dSdN_pre))):\n            return (dSdN[1], dSdN[0])\n        dSdN_pre = dSdN",
            "def _yn00(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'YN00 method main function (PRIVATE).\\n\\n    Nomenclature is according to Yang and Nielsen (2000), PMID 10666704.\\n    '\n    from collections import defaultdict\n    from scipy.linalg import expm\n    fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0_cnt = defaultdict(int)\n    fold4_cnt = defaultdict(int)\n    for codon in seq1 + seq2:\n        if codon != '---':\n            fcodon[0][codon[0]] += 1\n            fcodon[1][codon[1]] += 1\n            fcodon[2][codon[2]] += 1\n        fold_num = codon_fold_dict[codon]\n        for (i, f) in enumerate(fold_num):\n            if f == '0':\n                fold0_cnt[codon[i]] += 1\n            elif f == '4':\n                fold4_cnt[codon[i]] += 1\n    f0_total = sum(fold0_cnt.values())\n    f4_total = sum(fold4_cnt.values())\n    for (i, j) in zip(fold0_cnt, fold4_cnt):\n        fold0_cnt[i] = fold0_cnt[i] / f0_total\n        fold4_cnt[i] = fold4_cnt[i] / f4_total\n    TV = _get_TV(seq1, seq2, codon_table=codon_table)\n    k04 = (_get_kappa_t(fold0_cnt, TV), _get_kappa_t(fold4_cnt, TV))\n    kappa = (f0_total * k04[0] + f4_total * k04[1]) / (f0_total + f4_total)\n    for i in range(3):\n        tot = sum(fcodon[i].values())\n        fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n    pi = defaultdict(int)\n    for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n        if 'U' not in i:\n            pi[i] = 0\n    for i in seq1 + seq2:\n        pi[i] += 1\n    (S_sites1, N_sites1, bfreqSN1) = _count_site_YN00(seq1, seq2, pi, k=kappa, codon_table=codon_table)\n    (S_sites2, N_sites2, bfreqSN2) = _count_site_YN00(seq2, seq1, pi, k=kappa, codon_table=codon_table)\n    N_sites = (N_sites1 + N_sites2) / 2\n    S_sites = (S_sites1 + S_sites2) / 2\n    bfreqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for i in range(2):\n        for b in ('A', 'T', 'C', 'G'):\n            bfreqSN[i][b] = (bfreqSN1[i][b] + bfreqSN2[i][b]) / 2\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    p = sum(SN) / (S_sites + N_sites)\n    w = log(1 - 4.0 / 3 * pn) / log(1 - 4.0 / 3 * ps)\n    t = -3 / 4 * log(1 - 4 / 3 * p)\n    tolerance = 1e-05\n    dSdN_pre = [0, 0]\n    for temp in range(20):\n        codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n        Q = _get_Q(pi, kappa, w, codon_lst, codon_table)\n        P = expm(Q * t)\n        TV = [0, 0, 0, 0]\n        codon_npath = {}\n        for (i, j) in zip(seq1, seq2):\n            if i != '---' and j != '---':\n                codon_npath.setdefault((i, j), 0)\n                codon_npath[i, j] += 1\n        for i in codon_npath:\n            tv = _count_diff_YN00(i[0], i[1], P, codon_lst, codon_table)\n            TV = [m + n * codon_npath[i] for (m, n) in zip(TV, tv)]\n        TV = ((TV[0] / S_sites, TV[1] / S_sites), (TV[2] / N_sites, TV[3] / N_sites))\n        dSdN = []\n        for (f, tv) in zip(bfreqSN, TV):\n            dSdN.append(_get_kappa_t(f, tv, t=True))\n        t = dSdN[0] * 3 * S_sites / (S_sites + N_sites) + dSdN[1] * 3 * N_sites / (S_sites + N_sites)\n        w = dSdN[1] / dSdN[0]\n        if all((abs(i - j) < tolerance for (i, j) in zip(dSdN, dSdN_pre))):\n            return (dSdN[1], dSdN[0])\n        dSdN_pre = dSdN",
            "def _yn00(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'YN00 method main function (PRIVATE).\\n\\n    Nomenclature is according to Yang and Nielsen (2000), PMID 10666704.\\n    '\n    from collections import defaultdict\n    from scipy.linalg import expm\n    fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0_cnt = defaultdict(int)\n    fold4_cnt = defaultdict(int)\n    for codon in seq1 + seq2:\n        if codon != '---':\n            fcodon[0][codon[0]] += 1\n            fcodon[1][codon[1]] += 1\n            fcodon[2][codon[2]] += 1\n        fold_num = codon_fold_dict[codon]\n        for (i, f) in enumerate(fold_num):\n            if f == '0':\n                fold0_cnt[codon[i]] += 1\n            elif f == '4':\n                fold4_cnt[codon[i]] += 1\n    f0_total = sum(fold0_cnt.values())\n    f4_total = sum(fold4_cnt.values())\n    for (i, j) in zip(fold0_cnt, fold4_cnt):\n        fold0_cnt[i] = fold0_cnt[i] / f0_total\n        fold4_cnt[i] = fold4_cnt[i] / f4_total\n    TV = _get_TV(seq1, seq2, codon_table=codon_table)\n    k04 = (_get_kappa_t(fold0_cnt, TV), _get_kappa_t(fold4_cnt, TV))\n    kappa = (f0_total * k04[0] + f4_total * k04[1]) / (f0_total + f4_total)\n    for i in range(3):\n        tot = sum(fcodon[i].values())\n        fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n    pi = defaultdict(int)\n    for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n        if 'U' not in i:\n            pi[i] = 0\n    for i in seq1 + seq2:\n        pi[i] += 1\n    (S_sites1, N_sites1, bfreqSN1) = _count_site_YN00(seq1, seq2, pi, k=kappa, codon_table=codon_table)\n    (S_sites2, N_sites2, bfreqSN2) = _count_site_YN00(seq2, seq1, pi, k=kappa, codon_table=codon_table)\n    N_sites = (N_sites1 + N_sites2) / 2\n    S_sites = (S_sites1 + S_sites2) / 2\n    bfreqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for i in range(2):\n        for b in ('A', 'T', 'C', 'G'):\n            bfreqSN[i][b] = (bfreqSN1[i][b] + bfreqSN2[i][b]) / 2\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    p = sum(SN) / (S_sites + N_sites)\n    w = log(1 - 4.0 / 3 * pn) / log(1 - 4.0 / 3 * ps)\n    t = -3 / 4 * log(1 - 4 / 3 * p)\n    tolerance = 1e-05\n    dSdN_pre = [0, 0]\n    for temp in range(20):\n        codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n        Q = _get_Q(pi, kappa, w, codon_lst, codon_table)\n        P = expm(Q * t)\n        TV = [0, 0, 0, 0]\n        codon_npath = {}\n        for (i, j) in zip(seq1, seq2):\n            if i != '---' and j != '---':\n                codon_npath.setdefault((i, j), 0)\n                codon_npath[i, j] += 1\n        for i in codon_npath:\n            tv = _count_diff_YN00(i[0], i[1], P, codon_lst, codon_table)\n            TV = [m + n * codon_npath[i] for (m, n) in zip(TV, tv)]\n        TV = ((TV[0] / S_sites, TV[1] / S_sites), (TV[2] / N_sites, TV[3] / N_sites))\n        dSdN = []\n        for (f, tv) in zip(bfreqSN, TV):\n            dSdN.append(_get_kappa_t(f, tv, t=True))\n        t = dSdN[0] * 3 * S_sites / (S_sites + N_sites) + dSdN[1] * 3 * N_sites / (S_sites + N_sites)\n        w = dSdN[1] / dSdN[0]\n        if all((abs(i - j) < tolerance for (i, j) in zip(dSdN, dSdN_pre))):\n            return (dSdN[1], dSdN[0])\n        dSdN_pre = dSdN",
            "def _yn00(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'YN00 method main function (PRIVATE).\\n\\n    Nomenclature is according to Yang and Nielsen (2000), PMID 10666704.\\n    '\n    from collections import defaultdict\n    from scipy.linalg import expm\n    fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0_cnt = defaultdict(int)\n    fold4_cnt = defaultdict(int)\n    for codon in seq1 + seq2:\n        if codon != '---':\n            fcodon[0][codon[0]] += 1\n            fcodon[1][codon[1]] += 1\n            fcodon[2][codon[2]] += 1\n        fold_num = codon_fold_dict[codon]\n        for (i, f) in enumerate(fold_num):\n            if f == '0':\n                fold0_cnt[codon[i]] += 1\n            elif f == '4':\n                fold4_cnt[codon[i]] += 1\n    f0_total = sum(fold0_cnt.values())\n    f4_total = sum(fold4_cnt.values())\n    for (i, j) in zip(fold0_cnt, fold4_cnt):\n        fold0_cnt[i] = fold0_cnt[i] / f0_total\n        fold4_cnt[i] = fold4_cnt[i] / f4_total\n    TV = _get_TV(seq1, seq2, codon_table=codon_table)\n    k04 = (_get_kappa_t(fold0_cnt, TV), _get_kappa_t(fold4_cnt, TV))\n    kappa = (f0_total * k04[0] + f4_total * k04[1]) / (f0_total + f4_total)\n    for i in range(3):\n        tot = sum(fcodon[i].values())\n        fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n    pi = defaultdict(int)\n    for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n        if 'U' not in i:\n            pi[i] = 0\n    for i in seq1 + seq2:\n        pi[i] += 1\n    (S_sites1, N_sites1, bfreqSN1) = _count_site_YN00(seq1, seq2, pi, k=kappa, codon_table=codon_table)\n    (S_sites2, N_sites2, bfreqSN2) = _count_site_YN00(seq2, seq1, pi, k=kappa, codon_table=codon_table)\n    N_sites = (N_sites1 + N_sites2) / 2\n    S_sites = (S_sites1 + S_sites2) / 2\n    bfreqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for i in range(2):\n        for b in ('A', 'T', 'C', 'G'):\n            bfreqSN[i][b] = (bfreqSN1[i][b] + bfreqSN2[i][b]) / 2\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    p = sum(SN) / (S_sites + N_sites)\n    w = log(1 - 4.0 / 3 * pn) / log(1 - 4.0 / 3 * ps)\n    t = -3 / 4 * log(1 - 4 / 3 * p)\n    tolerance = 1e-05\n    dSdN_pre = [0, 0]\n    for temp in range(20):\n        codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n        Q = _get_Q(pi, kappa, w, codon_lst, codon_table)\n        P = expm(Q * t)\n        TV = [0, 0, 0, 0]\n        codon_npath = {}\n        for (i, j) in zip(seq1, seq2):\n            if i != '---' and j != '---':\n                codon_npath.setdefault((i, j), 0)\n                codon_npath[i, j] += 1\n        for i in codon_npath:\n            tv = _count_diff_YN00(i[0], i[1], P, codon_lst, codon_table)\n            TV = [m + n * codon_npath[i] for (m, n) in zip(TV, tv)]\n        TV = ((TV[0] / S_sites, TV[1] / S_sites), (TV[2] / N_sites, TV[3] / N_sites))\n        dSdN = []\n        for (f, tv) in zip(bfreqSN, TV):\n            dSdN.append(_get_kappa_t(f, tv, t=True))\n        t = dSdN[0] * 3 * S_sites / (S_sites + N_sites) + dSdN[1] * 3 * N_sites / (S_sites + N_sites)\n        w = dSdN[1] / dSdN[0]\n        if all((abs(i - j) < tolerance for (i, j) in zip(dSdN, dSdN_pre))):\n            return (dSdN[1], dSdN[0])\n        dSdN_pre = dSdN",
            "def _yn00(seq1, seq2, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'YN00 method main function (PRIVATE).\\n\\n    Nomenclature is according to Yang and Nielsen (2000), PMID 10666704.\\n    '\n    from collections import defaultdict\n    from scipy.linalg import expm\n    fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n    codon_fold_dict = _get_codon_fold(codon_table)\n    fold0_cnt = defaultdict(int)\n    fold4_cnt = defaultdict(int)\n    for codon in seq1 + seq2:\n        if codon != '---':\n            fcodon[0][codon[0]] += 1\n            fcodon[1][codon[1]] += 1\n            fcodon[2][codon[2]] += 1\n        fold_num = codon_fold_dict[codon]\n        for (i, f) in enumerate(fold_num):\n            if f == '0':\n                fold0_cnt[codon[i]] += 1\n            elif f == '4':\n                fold4_cnt[codon[i]] += 1\n    f0_total = sum(fold0_cnt.values())\n    f4_total = sum(fold4_cnt.values())\n    for (i, j) in zip(fold0_cnt, fold4_cnt):\n        fold0_cnt[i] = fold0_cnt[i] / f0_total\n        fold4_cnt[i] = fold4_cnt[i] / f4_total\n    TV = _get_TV(seq1, seq2, codon_table=codon_table)\n    k04 = (_get_kappa_t(fold0_cnt, TV), _get_kappa_t(fold4_cnt, TV))\n    kappa = (f0_total * k04[0] + f4_total * k04[1]) / (f0_total + f4_total)\n    for i in range(3):\n        tot = sum(fcodon[i].values())\n        fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n    pi = defaultdict(int)\n    for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n        if 'U' not in i:\n            pi[i] = 0\n    for i in seq1 + seq2:\n        pi[i] += 1\n    (S_sites1, N_sites1, bfreqSN1) = _count_site_YN00(seq1, seq2, pi, k=kappa, codon_table=codon_table)\n    (S_sites2, N_sites2, bfreqSN2) = _count_site_YN00(seq2, seq1, pi, k=kappa, codon_table=codon_table)\n    N_sites = (N_sites1 + N_sites2) / 2\n    S_sites = (S_sites1 + S_sites2) / 2\n    bfreqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for i in range(2):\n        for b in ('A', 'T', 'C', 'G'):\n            bfreqSN[i][b] = (bfreqSN1[i][b] + bfreqSN2[i][b]) / 2\n    SN = [0, 0]\n    for (i, j) in zip(seq1, seq2):\n        SN = [m + n for (m, n) in zip(SN, _count_diff_NG86(i, j, codon_table=codon_table))]\n    ps = SN[0] / S_sites\n    pn = SN[1] / N_sites\n    p = sum(SN) / (S_sites + N_sites)\n    w = log(1 - 4.0 / 3 * pn) / log(1 - 4.0 / 3 * ps)\n    t = -3 / 4 * log(1 - 4 / 3 * p)\n    tolerance = 1e-05\n    dSdN_pre = [0, 0]\n    for temp in range(20):\n        codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n        Q = _get_Q(pi, kappa, w, codon_lst, codon_table)\n        P = expm(Q * t)\n        TV = [0, 0, 0, 0]\n        codon_npath = {}\n        for (i, j) in zip(seq1, seq2):\n            if i != '---' and j != '---':\n                codon_npath.setdefault((i, j), 0)\n                codon_npath[i, j] += 1\n        for i in codon_npath:\n            tv = _count_diff_YN00(i[0], i[1], P, codon_lst, codon_table)\n            TV = [m + n * codon_npath[i] for (m, n) in zip(TV, tv)]\n        TV = ((TV[0] / S_sites, TV[1] / S_sites), (TV[2] / N_sites, TV[3] / N_sites))\n        dSdN = []\n        for (f, tv) in zip(bfreqSN, TV):\n            dSdN.append(_get_kappa_t(f, tv, t=True))\n        t = dSdN[0] * 3 * S_sites / (S_sites + N_sites) + dSdN[1] * 3 * N_sites / (S_sites + N_sites)\n        w = dSdN[1] / dSdN[0]\n        if all((abs(i - j) < tolerance for (i, j) in zip(dSdN, dSdN_pre))):\n            return (dSdN[1], dSdN[0])\n        dSdN_pre = dSdN"
        ]
    },
    {
        "func_name": "_get_TV",
        "original": "def _get_TV(codon_lst1, codon_lst2, codon_table):\n    \"\"\"Get TV (PRIVATE).\n\n    Arguments:\n     - T - proportions of transitional differences\n     - V - proportions of transversional differences\n\n    \"\"\"\n    purine = ('A', 'G')\n    pyrimidine = ('C', 'T')\n    TV = [0, 0]\n    sites = 0\n    for (codon1, codon2) in zip(codon_lst1, codon_lst2):\n        if '---' not in (codon1, codon2):\n            for (i, j) in zip(codon1, codon2):\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    TV[0] += 1\n                elif i in pyrimidine and j in pyrimidine:\n                    TV[0] += 1\n                else:\n                    TV[1] += 1\n                sites += 1\n    return (TV[0] / sites, TV[1] / sites)",
        "mutated": [
            "def _get_TV(codon_lst1, codon_lst2, codon_table):\n    if False:\n        i = 10\n    'Get TV (PRIVATE).\\n\\n    Arguments:\\n     - T - proportions of transitional differences\\n     - V - proportions of transversional differences\\n\\n    '\n    purine = ('A', 'G')\n    pyrimidine = ('C', 'T')\n    TV = [0, 0]\n    sites = 0\n    for (codon1, codon2) in zip(codon_lst1, codon_lst2):\n        if '---' not in (codon1, codon2):\n            for (i, j) in zip(codon1, codon2):\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    TV[0] += 1\n                elif i in pyrimidine and j in pyrimidine:\n                    TV[0] += 1\n                else:\n                    TV[1] += 1\n                sites += 1\n    return (TV[0] / sites, TV[1] / sites)",
            "def _get_TV(codon_lst1, codon_lst2, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get TV (PRIVATE).\\n\\n    Arguments:\\n     - T - proportions of transitional differences\\n     - V - proportions of transversional differences\\n\\n    '\n    purine = ('A', 'G')\n    pyrimidine = ('C', 'T')\n    TV = [0, 0]\n    sites = 0\n    for (codon1, codon2) in zip(codon_lst1, codon_lst2):\n        if '---' not in (codon1, codon2):\n            for (i, j) in zip(codon1, codon2):\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    TV[0] += 1\n                elif i in pyrimidine and j in pyrimidine:\n                    TV[0] += 1\n                else:\n                    TV[1] += 1\n                sites += 1\n    return (TV[0] / sites, TV[1] / sites)",
            "def _get_TV(codon_lst1, codon_lst2, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get TV (PRIVATE).\\n\\n    Arguments:\\n     - T - proportions of transitional differences\\n     - V - proportions of transversional differences\\n\\n    '\n    purine = ('A', 'G')\n    pyrimidine = ('C', 'T')\n    TV = [0, 0]\n    sites = 0\n    for (codon1, codon2) in zip(codon_lst1, codon_lst2):\n        if '---' not in (codon1, codon2):\n            for (i, j) in zip(codon1, codon2):\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    TV[0] += 1\n                elif i in pyrimidine and j in pyrimidine:\n                    TV[0] += 1\n                else:\n                    TV[1] += 1\n                sites += 1\n    return (TV[0] / sites, TV[1] / sites)",
            "def _get_TV(codon_lst1, codon_lst2, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get TV (PRIVATE).\\n\\n    Arguments:\\n     - T - proportions of transitional differences\\n     - V - proportions of transversional differences\\n\\n    '\n    purine = ('A', 'G')\n    pyrimidine = ('C', 'T')\n    TV = [0, 0]\n    sites = 0\n    for (codon1, codon2) in zip(codon_lst1, codon_lst2):\n        if '---' not in (codon1, codon2):\n            for (i, j) in zip(codon1, codon2):\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    TV[0] += 1\n                elif i in pyrimidine and j in pyrimidine:\n                    TV[0] += 1\n                else:\n                    TV[1] += 1\n                sites += 1\n    return (TV[0] / sites, TV[1] / sites)",
            "def _get_TV(codon_lst1, codon_lst2, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get TV (PRIVATE).\\n\\n    Arguments:\\n     - T - proportions of transitional differences\\n     - V - proportions of transversional differences\\n\\n    '\n    purine = ('A', 'G')\n    pyrimidine = ('C', 'T')\n    TV = [0, 0]\n    sites = 0\n    for (codon1, codon2) in zip(codon_lst1, codon_lst2):\n        if '---' not in (codon1, codon2):\n            for (i, j) in zip(codon1, codon2):\n                if i == j:\n                    pass\n                elif i in purine and j in purine:\n                    TV[0] += 1\n                elif i in pyrimidine and j in pyrimidine:\n                    TV[0] += 1\n                else:\n                    TV[1] += 1\n                sites += 1\n    return (TV[0] / sites, TV[1] / sites)"
        ]
    },
    {
        "func_name": "_get_kappa_t",
        "original": "def _get_kappa_t(pi, TV, t=False):\n    \"\"\"Calculate kappa (PRIVATE).\n\n    The following formula and variable names are according to PMID: 10666704\n    \"\"\"\n    pi['Y'] = pi['T'] + pi['C']\n    pi['R'] = pi['A'] + pi['G']\n    A = (2 * (pi['T'] * pi['C'] + pi['A'] * pi['G']) + 2 * (pi['T'] * pi['C'] * pi['R'] / pi['Y'] + pi['A'] * pi['G'] * pi['Y'] / pi['R']) * (1 - TV[1] / (2 * pi['Y'] * pi['R'])) - TV[0]) / (2 * (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']))\n    B = 1 - TV[1] / (2 * pi['Y'] * pi['R'])\n    a = -0.5 * log(A)\n    b = -0.5 * log(B)\n    kappaF84 = a / b - 1\n    if t is False:\n        kappaHKY85 = 1 + (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']) * kappaF84 / (pi['T'] * pi['C'] + pi['A'] * pi['G'])\n        return kappaHKY85\n    else:\n        t = (4 * pi['T'] * pi['C'] * (1 + kappaF84 / pi['Y']) + 4 * pi['A'] * pi['G'] * (1 + kappaF84 / pi['R']) + 4 * pi['Y'] * pi['R']) * b\n        return t",
        "mutated": [
            "def _get_kappa_t(pi, TV, t=False):\n    if False:\n        i = 10\n    'Calculate kappa (PRIVATE).\\n\\n    The following formula and variable names are according to PMID: 10666704\\n    '\n    pi['Y'] = pi['T'] + pi['C']\n    pi['R'] = pi['A'] + pi['G']\n    A = (2 * (pi['T'] * pi['C'] + pi['A'] * pi['G']) + 2 * (pi['T'] * pi['C'] * pi['R'] / pi['Y'] + pi['A'] * pi['G'] * pi['Y'] / pi['R']) * (1 - TV[1] / (2 * pi['Y'] * pi['R'])) - TV[0]) / (2 * (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']))\n    B = 1 - TV[1] / (2 * pi['Y'] * pi['R'])\n    a = -0.5 * log(A)\n    b = -0.5 * log(B)\n    kappaF84 = a / b - 1\n    if t is False:\n        kappaHKY85 = 1 + (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']) * kappaF84 / (pi['T'] * pi['C'] + pi['A'] * pi['G'])\n        return kappaHKY85\n    else:\n        t = (4 * pi['T'] * pi['C'] * (1 + kappaF84 / pi['Y']) + 4 * pi['A'] * pi['G'] * (1 + kappaF84 / pi['R']) + 4 * pi['Y'] * pi['R']) * b\n        return t",
            "def _get_kappa_t(pi, TV, t=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate kappa (PRIVATE).\\n\\n    The following formula and variable names are according to PMID: 10666704\\n    '\n    pi['Y'] = pi['T'] + pi['C']\n    pi['R'] = pi['A'] + pi['G']\n    A = (2 * (pi['T'] * pi['C'] + pi['A'] * pi['G']) + 2 * (pi['T'] * pi['C'] * pi['R'] / pi['Y'] + pi['A'] * pi['G'] * pi['Y'] / pi['R']) * (1 - TV[1] / (2 * pi['Y'] * pi['R'])) - TV[0]) / (2 * (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']))\n    B = 1 - TV[1] / (2 * pi['Y'] * pi['R'])\n    a = -0.5 * log(A)\n    b = -0.5 * log(B)\n    kappaF84 = a / b - 1\n    if t is False:\n        kappaHKY85 = 1 + (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']) * kappaF84 / (pi['T'] * pi['C'] + pi['A'] * pi['G'])\n        return kappaHKY85\n    else:\n        t = (4 * pi['T'] * pi['C'] * (1 + kappaF84 / pi['Y']) + 4 * pi['A'] * pi['G'] * (1 + kappaF84 / pi['R']) + 4 * pi['Y'] * pi['R']) * b\n        return t",
            "def _get_kappa_t(pi, TV, t=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate kappa (PRIVATE).\\n\\n    The following formula and variable names are according to PMID: 10666704\\n    '\n    pi['Y'] = pi['T'] + pi['C']\n    pi['R'] = pi['A'] + pi['G']\n    A = (2 * (pi['T'] * pi['C'] + pi['A'] * pi['G']) + 2 * (pi['T'] * pi['C'] * pi['R'] / pi['Y'] + pi['A'] * pi['G'] * pi['Y'] / pi['R']) * (1 - TV[1] / (2 * pi['Y'] * pi['R'])) - TV[0]) / (2 * (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']))\n    B = 1 - TV[1] / (2 * pi['Y'] * pi['R'])\n    a = -0.5 * log(A)\n    b = -0.5 * log(B)\n    kappaF84 = a / b - 1\n    if t is False:\n        kappaHKY85 = 1 + (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']) * kappaF84 / (pi['T'] * pi['C'] + pi['A'] * pi['G'])\n        return kappaHKY85\n    else:\n        t = (4 * pi['T'] * pi['C'] * (1 + kappaF84 / pi['Y']) + 4 * pi['A'] * pi['G'] * (1 + kappaF84 / pi['R']) + 4 * pi['Y'] * pi['R']) * b\n        return t",
            "def _get_kappa_t(pi, TV, t=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate kappa (PRIVATE).\\n\\n    The following formula and variable names are according to PMID: 10666704\\n    '\n    pi['Y'] = pi['T'] + pi['C']\n    pi['R'] = pi['A'] + pi['G']\n    A = (2 * (pi['T'] * pi['C'] + pi['A'] * pi['G']) + 2 * (pi['T'] * pi['C'] * pi['R'] / pi['Y'] + pi['A'] * pi['G'] * pi['Y'] / pi['R']) * (1 - TV[1] / (2 * pi['Y'] * pi['R'])) - TV[0]) / (2 * (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']))\n    B = 1 - TV[1] / (2 * pi['Y'] * pi['R'])\n    a = -0.5 * log(A)\n    b = -0.5 * log(B)\n    kappaF84 = a / b - 1\n    if t is False:\n        kappaHKY85 = 1 + (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']) * kappaF84 / (pi['T'] * pi['C'] + pi['A'] * pi['G'])\n        return kappaHKY85\n    else:\n        t = (4 * pi['T'] * pi['C'] * (1 + kappaF84 / pi['Y']) + 4 * pi['A'] * pi['G'] * (1 + kappaF84 / pi['R']) + 4 * pi['Y'] * pi['R']) * b\n        return t",
            "def _get_kappa_t(pi, TV, t=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate kappa (PRIVATE).\\n\\n    The following formula and variable names are according to PMID: 10666704\\n    '\n    pi['Y'] = pi['T'] + pi['C']\n    pi['R'] = pi['A'] + pi['G']\n    A = (2 * (pi['T'] * pi['C'] + pi['A'] * pi['G']) + 2 * (pi['T'] * pi['C'] * pi['R'] / pi['Y'] + pi['A'] * pi['G'] * pi['Y'] / pi['R']) * (1 - TV[1] / (2 * pi['Y'] * pi['R'])) - TV[0]) / (2 * (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']))\n    B = 1 - TV[1] / (2 * pi['Y'] * pi['R'])\n    a = -0.5 * log(A)\n    b = -0.5 * log(B)\n    kappaF84 = a / b - 1\n    if t is False:\n        kappaHKY85 = 1 + (pi['T'] * pi['C'] / pi['Y'] + pi['A'] * pi['G'] / pi['R']) * kappaF84 / (pi['T'] * pi['C'] + pi['A'] * pi['G'])\n        return kappaHKY85\n    else:\n        t = (4 * pi['T'] * pi['C'] * (1 + kappaF84 / pi['Y']) + 4 * pi['A'] * pi['G'] * (1 + kappaF84 / pi['R']) + 4 * pi['Y'] * pi['R']) * b\n        return t"
        ]
    },
    {
        "func_name": "_count_site_YN00",
        "original": "def _count_site_YN00(codon_lst1, codon_lst2, pi, k, codon_table):\n    \"\"\"Site counting method from Ina / Yang and Nielsen (PRIVATE).\n\n    Method from `Ina (1995)`_ as modified by `Yang and Nielsen (2000)`_.\n    This will return the total number of synonymous and nonsynonymous sites\n    and base frequencies in each category. The function is equivalent to\n    the ``CountSites()`` function in ``yn00.c`` of PAML.\n\n    .. _`Ina (1995)`: https://doi.org/10.1007/BF00167113\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\n\n    \"\"\"\n    if len(codon_lst1) != len(codon_lst2):\n        raise RuntimeError('Length of two codon_lst should be the same (%d and %d detected)' % (len(codon_lst1), len(codon_lst2)))\n    else:\n        length = len(codon_lst1)\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    codon_dict = codon_table.forward_table\n    stop = codon_table.stop_codons\n    codon_npath = {}\n    for (i, j) in zip(codon_lst1, codon_lst2):\n        if i != '---' and j != '---':\n            codon_npath.setdefault((i, j), 0)\n            codon_npath[i, j] += 1\n    S_sites = N_sites = 0\n    freqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for (codon_pair, npath) in codon_npath.items():\n        codon = codon_pair[0]\n        S = N = 0\n        for pos in range(3):\n            for base in base_tuple:\n                if codon[pos] == base:\n                    continue\n                neighbor_codon = codon[:pos] + base + codon[pos + 1:]\n                if neighbor_codon in stop:\n                    continue\n                weight = pi[neighbor_codon]\n                if codon[pos] in pyrimidine and base in pyrimidine:\n                    weight *= k\n                elif codon[pos] in purine and base in purine:\n                    weight *= k\n                if codon_dict[codon] == codon_dict[neighbor_codon]:\n                    S += weight\n                    freqSN[0][base] += weight * npath\n                else:\n                    N += weight\n                    freqSN[1][base] += weight * npath\n        S_sites += S * npath\n        N_sites += N * npath\n    norm_const = 3 * length / (S_sites + N_sites)\n    S_sites *= norm_const\n    N_sites *= norm_const\n    for i in freqSN:\n        norm_const = sum(i.values())\n        for b in i:\n            i[b] /= norm_const\n    return (S_sites, N_sites, freqSN)",
        "mutated": [
            "def _count_site_YN00(codon_lst1, codon_lst2, pi, k, codon_table):\n    if False:\n        i = 10\n    'Site counting method from Ina / Yang and Nielsen (PRIVATE).\\n\\n    Method from `Ina (1995)`_ as modified by `Yang and Nielsen (2000)`_.\\n    This will return the total number of synonymous and nonsynonymous sites\\n    and base frequencies in each category. The function is equivalent to\\n    the ``CountSites()`` function in ``yn00.c`` of PAML.\\n\\n    .. _`Ina (1995)`: https://doi.org/10.1007/BF00167113\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    '\n    if len(codon_lst1) != len(codon_lst2):\n        raise RuntimeError('Length of two codon_lst should be the same (%d and %d detected)' % (len(codon_lst1), len(codon_lst2)))\n    else:\n        length = len(codon_lst1)\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    codon_dict = codon_table.forward_table\n    stop = codon_table.stop_codons\n    codon_npath = {}\n    for (i, j) in zip(codon_lst1, codon_lst2):\n        if i != '---' and j != '---':\n            codon_npath.setdefault((i, j), 0)\n            codon_npath[i, j] += 1\n    S_sites = N_sites = 0\n    freqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for (codon_pair, npath) in codon_npath.items():\n        codon = codon_pair[0]\n        S = N = 0\n        for pos in range(3):\n            for base in base_tuple:\n                if codon[pos] == base:\n                    continue\n                neighbor_codon = codon[:pos] + base + codon[pos + 1:]\n                if neighbor_codon in stop:\n                    continue\n                weight = pi[neighbor_codon]\n                if codon[pos] in pyrimidine and base in pyrimidine:\n                    weight *= k\n                elif codon[pos] in purine and base in purine:\n                    weight *= k\n                if codon_dict[codon] == codon_dict[neighbor_codon]:\n                    S += weight\n                    freqSN[0][base] += weight * npath\n                else:\n                    N += weight\n                    freqSN[1][base] += weight * npath\n        S_sites += S * npath\n        N_sites += N * npath\n    norm_const = 3 * length / (S_sites + N_sites)\n    S_sites *= norm_const\n    N_sites *= norm_const\n    for i in freqSN:\n        norm_const = sum(i.values())\n        for b in i:\n            i[b] /= norm_const\n    return (S_sites, N_sites, freqSN)",
            "def _count_site_YN00(codon_lst1, codon_lst2, pi, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Site counting method from Ina / Yang and Nielsen (PRIVATE).\\n\\n    Method from `Ina (1995)`_ as modified by `Yang and Nielsen (2000)`_.\\n    This will return the total number of synonymous and nonsynonymous sites\\n    and base frequencies in each category. The function is equivalent to\\n    the ``CountSites()`` function in ``yn00.c`` of PAML.\\n\\n    .. _`Ina (1995)`: https://doi.org/10.1007/BF00167113\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    '\n    if len(codon_lst1) != len(codon_lst2):\n        raise RuntimeError('Length of two codon_lst should be the same (%d and %d detected)' % (len(codon_lst1), len(codon_lst2)))\n    else:\n        length = len(codon_lst1)\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    codon_dict = codon_table.forward_table\n    stop = codon_table.stop_codons\n    codon_npath = {}\n    for (i, j) in zip(codon_lst1, codon_lst2):\n        if i != '---' and j != '---':\n            codon_npath.setdefault((i, j), 0)\n            codon_npath[i, j] += 1\n    S_sites = N_sites = 0\n    freqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for (codon_pair, npath) in codon_npath.items():\n        codon = codon_pair[0]\n        S = N = 0\n        for pos in range(3):\n            for base in base_tuple:\n                if codon[pos] == base:\n                    continue\n                neighbor_codon = codon[:pos] + base + codon[pos + 1:]\n                if neighbor_codon in stop:\n                    continue\n                weight = pi[neighbor_codon]\n                if codon[pos] in pyrimidine and base in pyrimidine:\n                    weight *= k\n                elif codon[pos] in purine and base in purine:\n                    weight *= k\n                if codon_dict[codon] == codon_dict[neighbor_codon]:\n                    S += weight\n                    freqSN[0][base] += weight * npath\n                else:\n                    N += weight\n                    freqSN[1][base] += weight * npath\n        S_sites += S * npath\n        N_sites += N * npath\n    norm_const = 3 * length / (S_sites + N_sites)\n    S_sites *= norm_const\n    N_sites *= norm_const\n    for i in freqSN:\n        norm_const = sum(i.values())\n        for b in i:\n            i[b] /= norm_const\n    return (S_sites, N_sites, freqSN)",
            "def _count_site_YN00(codon_lst1, codon_lst2, pi, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Site counting method from Ina / Yang and Nielsen (PRIVATE).\\n\\n    Method from `Ina (1995)`_ as modified by `Yang and Nielsen (2000)`_.\\n    This will return the total number of synonymous and nonsynonymous sites\\n    and base frequencies in each category. The function is equivalent to\\n    the ``CountSites()`` function in ``yn00.c`` of PAML.\\n\\n    .. _`Ina (1995)`: https://doi.org/10.1007/BF00167113\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    '\n    if len(codon_lst1) != len(codon_lst2):\n        raise RuntimeError('Length of two codon_lst should be the same (%d and %d detected)' % (len(codon_lst1), len(codon_lst2)))\n    else:\n        length = len(codon_lst1)\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    codon_dict = codon_table.forward_table\n    stop = codon_table.stop_codons\n    codon_npath = {}\n    for (i, j) in zip(codon_lst1, codon_lst2):\n        if i != '---' and j != '---':\n            codon_npath.setdefault((i, j), 0)\n            codon_npath[i, j] += 1\n    S_sites = N_sites = 0\n    freqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for (codon_pair, npath) in codon_npath.items():\n        codon = codon_pair[0]\n        S = N = 0\n        for pos in range(3):\n            for base in base_tuple:\n                if codon[pos] == base:\n                    continue\n                neighbor_codon = codon[:pos] + base + codon[pos + 1:]\n                if neighbor_codon in stop:\n                    continue\n                weight = pi[neighbor_codon]\n                if codon[pos] in pyrimidine and base in pyrimidine:\n                    weight *= k\n                elif codon[pos] in purine and base in purine:\n                    weight *= k\n                if codon_dict[codon] == codon_dict[neighbor_codon]:\n                    S += weight\n                    freqSN[0][base] += weight * npath\n                else:\n                    N += weight\n                    freqSN[1][base] += weight * npath\n        S_sites += S * npath\n        N_sites += N * npath\n    norm_const = 3 * length / (S_sites + N_sites)\n    S_sites *= norm_const\n    N_sites *= norm_const\n    for i in freqSN:\n        norm_const = sum(i.values())\n        for b in i:\n            i[b] /= norm_const\n    return (S_sites, N_sites, freqSN)",
            "def _count_site_YN00(codon_lst1, codon_lst2, pi, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Site counting method from Ina / Yang and Nielsen (PRIVATE).\\n\\n    Method from `Ina (1995)`_ as modified by `Yang and Nielsen (2000)`_.\\n    This will return the total number of synonymous and nonsynonymous sites\\n    and base frequencies in each category. The function is equivalent to\\n    the ``CountSites()`` function in ``yn00.c`` of PAML.\\n\\n    .. _`Ina (1995)`: https://doi.org/10.1007/BF00167113\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    '\n    if len(codon_lst1) != len(codon_lst2):\n        raise RuntimeError('Length of two codon_lst should be the same (%d and %d detected)' % (len(codon_lst1), len(codon_lst2)))\n    else:\n        length = len(codon_lst1)\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    codon_dict = codon_table.forward_table\n    stop = codon_table.stop_codons\n    codon_npath = {}\n    for (i, j) in zip(codon_lst1, codon_lst2):\n        if i != '---' and j != '---':\n            codon_npath.setdefault((i, j), 0)\n            codon_npath[i, j] += 1\n    S_sites = N_sites = 0\n    freqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for (codon_pair, npath) in codon_npath.items():\n        codon = codon_pair[0]\n        S = N = 0\n        for pos in range(3):\n            for base in base_tuple:\n                if codon[pos] == base:\n                    continue\n                neighbor_codon = codon[:pos] + base + codon[pos + 1:]\n                if neighbor_codon in stop:\n                    continue\n                weight = pi[neighbor_codon]\n                if codon[pos] in pyrimidine and base in pyrimidine:\n                    weight *= k\n                elif codon[pos] in purine and base in purine:\n                    weight *= k\n                if codon_dict[codon] == codon_dict[neighbor_codon]:\n                    S += weight\n                    freqSN[0][base] += weight * npath\n                else:\n                    N += weight\n                    freqSN[1][base] += weight * npath\n        S_sites += S * npath\n        N_sites += N * npath\n    norm_const = 3 * length / (S_sites + N_sites)\n    S_sites *= norm_const\n    N_sites *= norm_const\n    for i in freqSN:\n        norm_const = sum(i.values())\n        for b in i:\n            i[b] /= norm_const\n    return (S_sites, N_sites, freqSN)",
            "def _count_site_YN00(codon_lst1, codon_lst2, pi, k, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Site counting method from Ina / Yang and Nielsen (PRIVATE).\\n\\n    Method from `Ina (1995)`_ as modified by `Yang and Nielsen (2000)`_.\\n    This will return the total number of synonymous and nonsynonymous sites\\n    and base frequencies in each category. The function is equivalent to\\n    the ``CountSites()`` function in ``yn00.c`` of PAML.\\n\\n    .. _`Ina (1995)`: https://doi.org/10.1007/BF00167113\\n    .. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\\n\\n    '\n    if len(codon_lst1) != len(codon_lst2):\n        raise RuntimeError('Length of two codon_lst should be the same (%d and %d detected)' % (len(codon_lst1), len(codon_lst2)))\n    else:\n        length = len(codon_lst1)\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    base_tuple = ('A', 'T', 'C', 'G')\n    codon_dict = codon_table.forward_table\n    stop = codon_table.stop_codons\n    codon_npath = {}\n    for (i, j) in zip(codon_lst1, codon_lst2):\n        if i != '---' and j != '---':\n            codon_npath.setdefault((i, j), 0)\n            codon_npath[i, j] += 1\n    S_sites = N_sites = 0\n    freqSN = [{'A': 0, 'T': 0, 'C': 0, 'G': 0}, {'A': 0, 'T': 0, 'C': 0, 'G': 0}]\n    for (codon_pair, npath) in codon_npath.items():\n        codon = codon_pair[0]\n        S = N = 0\n        for pos in range(3):\n            for base in base_tuple:\n                if codon[pos] == base:\n                    continue\n                neighbor_codon = codon[:pos] + base + codon[pos + 1:]\n                if neighbor_codon in stop:\n                    continue\n                weight = pi[neighbor_codon]\n                if codon[pos] in pyrimidine and base in pyrimidine:\n                    weight *= k\n                elif codon[pos] in purine and base in purine:\n                    weight *= k\n                if codon_dict[codon] == codon_dict[neighbor_codon]:\n                    S += weight\n                    freqSN[0][base] += weight * npath\n                else:\n                    N += weight\n                    freqSN[1][base] += weight * npath\n        S_sites += S * npath\n        N_sites += N * npath\n    norm_const = 3 * length / (S_sites + N_sites)\n    S_sites *= norm_const\n    N_sites *= norm_const\n    for i in freqSN:\n        norm_const = sum(i.values())\n        for b in i:\n            i[b] /= norm_const\n    return (S_sites, N_sites, freqSN)"
        ]
    },
    {
        "func_name": "count_TV",
        "original": "def count_TV(codon1, codon2, diff, codon_table, weight=1):\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    dic = codon_table.forward_table\n    stop = codon_table.stop_codons\n    if codon1 in stop or codon2 in stop:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [0, 0, weight, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [0, 0, weight, 0]\n        else:\n            return [0, 0, 0, weight]\n    elif dic[codon1] == dic[codon2]:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [weight, 0, 0, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [weight, 0, 0, 0]\n        else:\n            return [0, weight, 0, 0]\n    elif codon1[diff] in purine and codon2[diff] in purine:\n        return [0, 0, weight, 0]\n    elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n        return [0, 0, weight, 0]\n    else:\n        return [0, 0, 0, weight]",
        "mutated": [
            "def count_TV(codon1, codon2, diff, codon_table, weight=1):\n    if False:\n        i = 10\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    dic = codon_table.forward_table\n    stop = codon_table.stop_codons\n    if codon1 in stop or codon2 in stop:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [0, 0, weight, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [0, 0, weight, 0]\n        else:\n            return [0, 0, 0, weight]\n    elif dic[codon1] == dic[codon2]:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [weight, 0, 0, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [weight, 0, 0, 0]\n        else:\n            return [0, weight, 0, 0]\n    elif codon1[diff] in purine and codon2[diff] in purine:\n        return [0, 0, weight, 0]\n    elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n        return [0, 0, weight, 0]\n    else:\n        return [0, 0, 0, weight]",
            "def count_TV(codon1, codon2, diff, codon_table, weight=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    dic = codon_table.forward_table\n    stop = codon_table.stop_codons\n    if codon1 in stop or codon2 in stop:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [0, 0, weight, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [0, 0, weight, 0]\n        else:\n            return [0, 0, 0, weight]\n    elif dic[codon1] == dic[codon2]:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [weight, 0, 0, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [weight, 0, 0, 0]\n        else:\n            return [0, weight, 0, 0]\n    elif codon1[diff] in purine and codon2[diff] in purine:\n        return [0, 0, weight, 0]\n    elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n        return [0, 0, weight, 0]\n    else:\n        return [0, 0, 0, weight]",
            "def count_TV(codon1, codon2, diff, codon_table, weight=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    dic = codon_table.forward_table\n    stop = codon_table.stop_codons\n    if codon1 in stop or codon2 in stop:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [0, 0, weight, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [0, 0, weight, 0]\n        else:\n            return [0, 0, 0, weight]\n    elif dic[codon1] == dic[codon2]:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [weight, 0, 0, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [weight, 0, 0, 0]\n        else:\n            return [0, weight, 0, 0]\n    elif codon1[diff] in purine and codon2[diff] in purine:\n        return [0, 0, weight, 0]\n    elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n        return [0, 0, weight, 0]\n    else:\n        return [0, 0, 0, weight]",
            "def count_TV(codon1, codon2, diff, codon_table, weight=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    dic = codon_table.forward_table\n    stop = codon_table.stop_codons\n    if codon1 in stop or codon2 in stop:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [0, 0, weight, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [0, 0, weight, 0]\n        else:\n            return [0, 0, 0, weight]\n    elif dic[codon1] == dic[codon2]:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [weight, 0, 0, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [weight, 0, 0, 0]\n        else:\n            return [0, weight, 0, 0]\n    elif codon1[diff] in purine and codon2[diff] in purine:\n        return [0, 0, weight, 0]\n    elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n        return [0, 0, weight, 0]\n    else:\n        return [0, 0, 0, weight]",
            "def count_TV(codon1, codon2, diff, codon_table, weight=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    dic = codon_table.forward_table\n    stop = codon_table.stop_codons\n    if codon1 in stop or codon2 in stop:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [0, 0, weight, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [0, 0, weight, 0]\n        else:\n            return [0, 0, 0, weight]\n    elif dic[codon1] == dic[codon2]:\n        if codon1[diff] in purine and codon2[diff] in purine:\n            return [weight, 0, 0, 0]\n        elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n            return [weight, 0, 0, 0]\n        else:\n            return [0, weight, 0, 0]\n    elif codon1[diff] in purine and codon2[diff] in purine:\n        return [0, 0, weight, 0]\n    elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n        return [0, 0, weight, 0]\n    else:\n        return [0, 0, 0, weight]"
        ]
    },
    {
        "func_name": "_count_diff_YN00",
        "original": "def _count_diff_YN00(codon1, codon2, P, codon_lst, codon_table):\n    \"\"\"Count differences between two codons (three-letter string; PRIVATE).\n\n    The function will weighted multiple pathways from codon1 to codon2\n    according to P matrix of codon substitution. The proportion\n    of transition and transversion (TV) will also be calculated in\n    the function.\n    \"\"\"\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_YN00 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    TV = [0, 0, 0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return TV\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return TV\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def count_TV(codon1, codon2, diff, codon_table, weight=1):\n            purine = ('A', 'G')\n            pyrimidine = ('T', 'C')\n            dic = codon_table.forward_table\n            stop = codon_table.stop_codons\n            if codon1 in stop or codon2 in stop:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [0, 0, weight, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [0, 0, weight, 0]\n                else:\n                    return [0, 0, 0, weight]\n            elif dic[codon1] == dic[codon2]:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [weight, 0, 0, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [weight, 0, 0, 0]\n                else:\n                    return [0, weight, 0, 0]\n            elif codon1[diff] in purine and codon2[diff] in purine:\n                return [0, 0, weight, 0]\n            elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                return [0, 0, weight, 0]\n            else:\n                return [0, 0, 0, weight]\n        if len(diff_pos) == 1:\n            TV = [p + q for (p, q) in zip(TV, count_TV(codon1, codon2, diff_pos[0], codon_table))]\n        elif len(diff_pos) == 2:\n            tmp_codon = [codon1[:i] + codon2[i] + codon1[i + 1:] for i in diff_pos]\n            path_prob = []\n            for i in tmp_codon:\n                codon_idx = list(map(codon_lst.index, [codon1, i, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]])\n                path_prob.append(prob[0] * prob[1])\n            path_prob = [2 * i / sum(path_prob) for i in path_prob]\n            for (n, i) in enumerate(diff_pos):\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            path_prob = []\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                codon_idx = list(map(codon_lst.index, [codon1, tmp1, tmp2, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]], P[codon_idx[2], codon_idx[3]])\n                path_prob.append(prob[0] * prob[1] * prob[2])\n            path_prob = [3 * i / sum(path_prob) for i in path_prob]\n            for (i, j, k) in zip(tmp_codon, path_prob, paths):\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, i[0], k[0], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[0], i[1], k[1], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[1], codon2, k[1], codon_table, weight=j / 3))]\n    return TV",
        "mutated": [
            "def _count_diff_YN00(codon1, codon2, P, codon_lst, codon_table):\n    if False:\n        i = 10\n    'Count differences between two codons (three-letter string; PRIVATE).\\n\\n    The function will weighted multiple pathways from codon1 to codon2\\n    according to P matrix of codon substitution. The proportion\\n    of transition and transversion (TV) will also be calculated in\\n    the function.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_YN00 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    TV = [0, 0, 0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return TV\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return TV\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def count_TV(codon1, codon2, diff, codon_table, weight=1):\n            purine = ('A', 'G')\n            pyrimidine = ('T', 'C')\n            dic = codon_table.forward_table\n            stop = codon_table.stop_codons\n            if codon1 in stop or codon2 in stop:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [0, 0, weight, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [0, 0, weight, 0]\n                else:\n                    return [0, 0, 0, weight]\n            elif dic[codon1] == dic[codon2]:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [weight, 0, 0, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [weight, 0, 0, 0]\n                else:\n                    return [0, weight, 0, 0]\n            elif codon1[diff] in purine and codon2[diff] in purine:\n                return [0, 0, weight, 0]\n            elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                return [0, 0, weight, 0]\n            else:\n                return [0, 0, 0, weight]\n        if len(diff_pos) == 1:\n            TV = [p + q for (p, q) in zip(TV, count_TV(codon1, codon2, diff_pos[0], codon_table))]\n        elif len(diff_pos) == 2:\n            tmp_codon = [codon1[:i] + codon2[i] + codon1[i + 1:] for i in diff_pos]\n            path_prob = []\n            for i in tmp_codon:\n                codon_idx = list(map(codon_lst.index, [codon1, i, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]])\n                path_prob.append(prob[0] * prob[1])\n            path_prob = [2 * i / sum(path_prob) for i in path_prob]\n            for (n, i) in enumerate(diff_pos):\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            path_prob = []\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                codon_idx = list(map(codon_lst.index, [codon1, tmp1, tmp2, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]], P[codon_idx[2], codon_idx[3]])\n                path_prob.append(prob[0] * prob[1] * prob[2])\n            path_prob = [3 * i / sum(path_prob) for i in path_prob]\n            for (i, j, k) in zip(tmp_codon, path_prob, paths):\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, i[0], k[0], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[0], i[1], k[1], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[1], codon2, k[1], codon_table, weight=j / 3))]\n    return TV",
            "def _count_diff_YN00(codon1, codon2, P, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Count differences between two codons (three-letter string; PRIVATE).\\n\\n    The function will weighted multiple pathways from codon1 to codon2\\n    according to P matrix of codon substitution. The proportion\\n    of transition and transversion (TV) will also be calculated in\\n    the function.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_YN00 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    TV = [0, 0, 0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return TV\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return TV\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def count_TV(codon1, codon2, diff, codon_table, weight=1):\n            purine = ('A', 'G')\n            pyrimidine = ('T', 'C')\n            dic = codon_table.forward_table\n            stop = codon_table.stop_codons\n            if codon1 in stop or codon2 in stop:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [0, 0, weight, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [0, 0, weight, 0]\n                else:\n                    return [0, 0, 0, weight]\n            elif dic[codon1] == dic[codon2]:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [weight, 0, 0, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [weight, 0, 0, 0]\n                else:\n                    return [0, weight, 0, 0]\n            elif codon1[diff] in purine and codon2[diff] in purine:\n                return [0, 0, weight, 0]\n            elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                return [0, 0, weight, 0]\n            else:\n                return [0, 0, 0, weight]\n        if len(diff_pos) == 1:\n            TV = [p + q for (p, q) in zip(TV, count_TV(codon1, codon2, diff_pos[0], codon_table))]\n        elif len(diff_pos) == 2:\n            tmp_codon = [codon1[:i] + codon2[i] + codon1[i + 1:] for i in diff_pos]\n            path_prob = []\n            for i in tmp_codon:\n                codon_idx = list(map(codon_lst.index, [codon1, i, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]])\n                path_prob.append(prob[0] * prob[1])\n            path_prob = [2 * i / sum(path_prob) for i in path_prob]\n            for (n, i) in enumerate(diff_pos):\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            path_prob = []\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                codon_idx = list(map(codon_lst.index, [codon1, tmp1, tmp2, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]], P[codon_idx[2], codon_idx[3]])\n                path_prob.append(prob[0] * prob[1] * prob[2])\n            path_prob = [3 * i / sum(path_prob) for i in path_prob]\n            for (i, j, k) in zip(tmp_codon, path_prob, paths):\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, i[0], k[0], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[0], i[1], k[1], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[1], codon2, k[1], codon_table, weight=j / 3))]\n    return TV",
            "def _count_diff_YN00(codon1, codon2, P, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Count differences between two codons (three-letter string; PRIVATE).\\n\\n    The function will weighted multiple pathways from codon1 to codon2\\n    according to P matrix of codon substitution. The proportion\\n    of transition and transversion (TV) will also be calculated in\\n    the function.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_YN00 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    TV = [0, 0, 0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return TV\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return TV\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def count_TV(codon1, codon2, diff, codon_table, weight=1):\n            purine = ('A', 'G')\n            pyrimidine = ('T', 'C')\n            dic = codon_table.forward_table\n            stop = codon_table.stop_codons\n            if codon1 in stop or codon2 in stop:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [0, 0, weight, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [0, 0, weight, 0]\n                else:\n                    return [0, 0, 0, weight]\n            elif dic[codon1] == dic[codon2]:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [weight, 0, 0, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [weight, 0, 0, 0]\n                else:\n                    return [0, weight, 0, 0]\n            elif codon1[diff] in purine and codon2[diff] in purine:\n                return [0, 0, weight, 0]\n            elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                return [0, 0, weight, 0]\n            else:\n                return [0, 0, 0, weight]\n        if len(diff_pos) == 1:\n            TV = [p + q for (p, q) in zip(TV, count_TV(codon1, codon2, diff_pos[0], codon_table))]\n        elif len(diff_pos) == 2:\n            tmp_codon = [codon1[:i] + codon2[i] + codon1[i + 1:] for i in diff_pos]\n            path_prob = []\n            for i in tmp_codon:\n                codon_idx = list(map(codon_lst.index, [codon1, i, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]])\n                path_prob.append(prob[0] * prob[1])\n            path_prob = [2 * i / sum(path_prob) for i in path_prob]\n            for (n, i) in enumerate(diff_pos):\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            path_prob = []\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                codon_idx = list(map(codon_lst.index, [codon1, tmp1, tmp2, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]], P[codon_idx[2], codon_idx[3]])\n                path_prob.append(prob[0] * prob[1] * prob[2])\n            path_prob = [3 * i / sum(path_prob) for i in path_prob]\n            for (i, j, k) in zip(tmp_codon, path_prob, paths):\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, i[0], k[0], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[0], i[1], k[1], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[1], codon2, k[1], codon_table, weight=j / 3))]\n    return TV",
            "def _count_diff_YN00(codon1, codon2, P, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Count differences between two codons (three-letter string; PRIVATE).\\n\\n    The function will weighted multiple pathways from codon1 to codon2\\n    according to P matrix of codon substitution. The proportion\\n    of transition and transversion (TV) will also be calculated in\\n    the function.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_YN00 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    TV = [0, 0, 0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return TV\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return TV\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def count_TV(codon1, codon2, diff, codon_table, weight=1):\n            purine = ('A', 'G')\n            pyrimidine = ('T', 'C')\n            dic = codon_table.forward_table\n            stop = codon_table.stop_codons\n            if codon1 in stop or codon2 in stop:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [0, 0, weight, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [0, 0, weight, 0]\n                else:\n                    return [0, 0, 0, weight]\n            elif dic[codon1] == dic[codon2]:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [weight, 0, 0, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [weight, 0, 0, 0]\n                else:\n                    return [0, weight, 0, 0]\n            elif codon1[diff] in purine and codon2[diff] in purine:\n                return [0, 0, weight, 0]\n            elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                return [0, 0, weight, 0]\n            else:\n                return [0, 0, 0, weight]\n        if len(diff_pos) == 1:\n            TV = [p + q for (p, q) in zip(TV, count_TV(codon1, codon2, diff_pos[0], codon_table))]\n        elif len(diff_pos) == 2:\n            tmp_codon = [codon1[:i] + codon2[i] + codon1[i + 1:] for i in diff_pos]\n            path_prob = []\n            for i in tmp_codon:\n                codon_idx = list(map(codon_lst.index, [codon1, i, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]])\n                path_prob.append(prob[0] * prob[1])\n            path_prob = [2 * i / sum(path_prob) for i in path_prob]\n            for (n, i) in enumerate(diff_pos):\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            path_prob = []\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                codon_idx = list(map(codon_lst.index, [codon1, tmp1, tmp2, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]], P[codon_idx[2], codon_idx[3]])\n                path_prob.append(prob[0] * prob[1] * prob[2])\n            path_prob = [3 * i / sum(path_prob) for i in path_prob]\n            for (i, j, k) in zip(tmp_codon, path_prob, paths):\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, i[0], k[0], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[0], i[1], k[1], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[1], codon2, k[1], codon_table, weight=j / 3))]\n    return TV",
            "def _count_diff_YN00(codon1, codon2, P, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Count differences between two codons (three-letter string; PRIVATE).\\n\\n    The function will weighted multiple pathways from codon1 to codon2\\n    according to P matrix of codon substitution. The proportion\\n    of transition and transversion (TV) will also be calculated in\\n    the function.\\n    '\n    if not isinstance(codon1, str) or not isinstance(codon2, str):\n        raise TypeError(f'_count_diff_YN00 accepts string object to represent codon ({type(codon1)}, {type(codon2)} detected)')\n    if len(codon1) != 3 or len(codon2) != 3:\n        raise RuntimeError(f'codon should be three letter string ({len(codon1)}, {len(codon2)} detected)')\n    TV = [0, 0, 0, 0]\n    if codon1 == '---' or codon2 == '---':\n        return TV\n    base_tuple = ('A', 'C', 'G', 'T')\n    if not all((i in base_tuple for i in codon1)):\n        raise RuntimeError(f'Unrecognized character detected in codon1 {codon1} (Codons consist of A, T, C or G)')\n    if not all((i in base_tuple for i in codon2)):\n        raise RuntimeError(f'Unrecognized character detected in codon2 {codon2} (Codons consist of A, T, C or G)')\n    if codon1 == codon2:\n        return TV\n    else:\n        diff_pos = []\n        for (i, k) in enumerate(zip(codon1, codon2)):\n            if k[0] != k[1]:\n                diff_pos.append(i)\n\n        def count_TV(codon1, codon2, diff, codon_table, weight=1):\n            purine = ('A', 'G')\n            pyrimidine = ('T', 'C')\n            dic = codon_table.forward_table\n            stop = codon_table.stop_codons\n            if codon1 in stop or codon2 in stop:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [0, 0, weight, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [0, 0, weight, 0]\n                else:\n                    return [0, 0, 0, weight]\n            elif dic[codon1] == dic[codon2]:\n                if codon1[diff] in purine and codon2[diff] in purine:\n                    return [weight, 0, 0, 0]\n                elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                    return [weight, 0, 0, 0]\n                else:\n                    return [0, weight, 0, 0]\n            elif codon1[diff] in purine and codon2[diff] in purine:\n                return [0, 0, weight, 0]\n            elif codon1[diff] in pyrimidine and codon2[diff] in pyrimidine:\n                return [0, 0, weight, 0]\n            else:\n                return [0, 0, 0, weight]\n        if len(diff_pos) == 1:\n            TV = [p + q for (p, q) in zip(TV, count_TV(codon1, codon2, diff_pos[0], codon_table))]\n        elif len(diff_pos) == 2:\n            tmp_codon = [codon1[:i] + codon2[i] + codon1[i + 1:] for i in diff_pos]\n            path_prob = []\n            for i in tmp_codon:\n                codon_idx = list(map(codon_lst.index, [codon1, i, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]])\n                path_prob.append(prob[0] * prob[1])\n            path_prob = [2 * i / sum(path_prob) for i in path_prob]\n            for (n, i) in enumerate(diff_pos):\n                temp_codon = codon1[:i] + codon2[i] + codon1[i + 1:]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, temp_codon, i, codon_table, weight=path_prob[n] / 2))]\n        elif len(diff_pos) == 3:\n            paths = list(permutations([0, 1, 2], 3))\n            path_prob = []\n            tmp_codon = []\n            for p in paths:\n                tmp1 = codon1[:p[0]] + codon2[p[0]] + codon1[p[0] + 1:]\n                tmp2 = tmp1[:p[1]] + codon2[p[1]] + tmp1[p[1] + 1:]\n                tmp_codon.append((tmp1, tmp2))\n                codon_idx = list(map(codon_lst.index, [codon1, tmp1, tmp2, codon2]))\n                prob = (P[codon_idx[0], codon_idx[1]], P[codon_idx[1], codon_idx[2]], P[codon_idx[2], codon_idx[3]])\n                path_prob.append(prob[0] * prob[1] * prob[2])\n            path_prob = [3 * i / sum(path_prob) for i in path_prob]\n            for (i, j, k) in zip(tmp_codon, path_prob, paths):\n                TV = [p + q for (p, q) in zip(TV, count_TV(codon1, i[0], k[0], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[0], i[1], k[1], codon_table, weight=j / 3))]\n                TV = [p + q for (p, q) in zip(TV, count_TV(i[1], codon2, k[1], codon_table, weight=j / 3))]\n    return TV"
        ]
    },
    {
        "func_name": "func",
        "original": "def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    \"\"\"Temporary function, params = [t, k, w].\"\"\"\n    return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
        "mutated": [
            "def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n    'Temporary function, params = [t, k, w].'\n    return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
            "def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Temporary function, params = [t, k, w].'\n    return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
            "def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Temporary function, params = [t, k, w].'\n    return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
            "def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Temporary function, params = [t, k, w].'\n    return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
            "def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Temporary function, params = [t, k, w].'\n    return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)"
        ]
    },
    {
        "func_name": "func_w1",
        "original": "def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    \"\"\"Temporary function, params = [t, k]. w is fixed to 1.\"\"\"\n    return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
        "mutated": [
            "def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n    'Temporary function, params = [t, k]. w is fixed to 1.'\n    return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
            "def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Temporary function, params = [t, k]. w is fixed to 1.'\n    return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
            "def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Temporary function, params = [t, k]. w is fixed to 1.'\n    return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
            "def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Temporary function, params = [t, k]. w is fixed to 1.'\n    return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)",
            "def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Temporary function, params = [t, k]. w is fixed to 1.'\n    return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)"
        ]
    },
    {
        "func_name": "_ml",
        "original": "def _ml(seq1, seq2, cmethod, codon_table):\n    \"\"\"ML method main function (PRIVATE).\"\"\"\n    from collections import Counter\n    from scipy.optimize import minimize\n    codon_cnt = Counter()\n    pi = _get_pi(seq1, seq2, cmethod, codon_table=codon_table)\n    for (i, j) in zip(seq1, seq2):\n        if '---' not in (i, j):\n            codon_cnt[i, j] += 1\n    codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n\n    def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k, w].\"\"\"\n        return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func, [1, 0.1, 2], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20), (1e-10, 10)), tol=1e-05)\n    (t, k, w) = opt_res.x\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    Sd = Nd = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        Sd += pi[c1] * Q[i, j]\n                    else:\n                        Nd += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    Sd *= t\n    Nd *= t\n\n    def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k]. w is fixed to 1.\"\"\"\n        return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func_w1, [1, 0.1], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20)), tol=1e-05)\n    (t, k) = opt_res.x\n    w = 1.0\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    rhoS = rhoN = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        rhoS += pi[c1] * Q[i, j]\n                    else:\n                        rhoN += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    rhoS *= 3\n    rhoN *= 3\n    dN = Nd / rhoN\n    dS = Sd / rhoS\n    return (dN, dS)",
        "mutated": [
            "def _ml(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n    'ML method main function (PRIVATE).'\n    from collections import Counter\n    from scipy.optimize import minimize\n    codon_cnt = Counter()\n    pi = _get_pi(seq1, seq2, cmethod, codon_table=codon_table)\n    for (i, j) in zip(seq1, seq2):\n        if '---' not in (i, j):\n            codon_cnt[i, j] += 1\n    codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n\n    def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k, w].\"\"\"\n        return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func, [1, 0.1, 2], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20), (1e-10, 10)), tol=1e-05)\n    (t, k, w) = opt_res.x\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    Sd = Nd = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        Sd += pi[c1] * Q[i, j]\n                    else:\n                        Nd += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    Sd *= t\n    Nd *= t\n\n    def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k]. w is fixed to 1.\"\"\"\n        return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func_w1, [1, 0.1], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20)), tol=1e-05)\n    (t, k) = opt_res.x\n    w = 1.0\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    rhoS = rhoN = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        rhoS += pi[c1] * Q[i, j]\n                    else:\n                        rhoN += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    rhoS *= 3\n    rhoN *= 3\n    dN = Nd / rhoN\n    dS = Sd / rhoS\n    return (dN, dS)",
            "def _ml(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'ML method main function (PRIVATE).'\n    from collections import Counter\n    from scipy.optimize import minimize\n    codon_cnt = Counter()\n    pi = _get_pi(seq1, seq2, cmethod, codon_table=codon_table)\n    for (i, j) in zip(seq1, seq2):\n        if '---' not in (i, j):\n            codon_cnt[i, j] += 1\n    codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n\n    def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k, w].\"\"\"\n        return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func, [1, 0.1, 2], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20), (1e-10, 10)), tol=1e-05)\n    (t, k, w) = opt_res.x\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    Sd = Nd = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        Sd += pi[c1] * Q[i, j]\n                    else:\n                        Nd += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    Sd *= t\n    Nd *= t\n\n    def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k]. w is fixed to 1.\"\"\"\n        return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func_w1, [1, 0.1], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20)), tol=1e-05)\n    (t, k) = opt_res.x\n    w = 1.0\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    rhoS = rhoN = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        rhoS += pi[c1] * Q[i, j]\n                    else:\n                        rhoN += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    rhoS *= 3\n    rhoN *= 3\n    dN = Nd / rhoN\n    dS = Sd / rhoS\n    return (dN, dS)",
            "def _ml(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'ML method main function (PRIVATE).'\n    from collections import Counter\n    from scipy.optimize import minimize\n    codon_cnt = Counter()\n    pi = _get_pi(seq1, seq2, cmethod, codon_table=codon_table)\n    for (i, j) in zip(seq1, seq2):\n        if '---' not in (i, j):\n            codon_cnt[i, j] += 1\n    codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n\n    def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k, w].\"\"\"\n        return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func, [1, 0.1, 2], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20), (1e-10, 10)), tol=1e-05)\n    (t, k, w) = opt_res.x\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    Sd = Nd = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        Sd += pi[c1] * Q[i, j]\n                    else:\n                        Nd += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    Sd *= t\n    Nd *= t\n\n    def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k]. w is fixed to 1.\"\"\"\n        return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func_w1, [1, 0.1], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20)), tol=1e-05)\n    (t, k) = opt_res.x\n    w = 1.0\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    rhoS = rhoN = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        rhoS += pi[c1] * Q[i, j]\n                    else:\n                        rhoN += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    rhoS *= 3\n    rhoN *= 3\n    dN = Nd / rhoN\n    dS = Sd / rhoS\n    return (dN, dS)",
            "def _ml(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'ML method main function (PRIVATE).'\n    from collections import Counter\n    from scipy.optimize import minimize\n    codon_cnt = Counter()\n    pi = _get_pi(seq1, seq2, cmethod, codon_table=codon_table)\n    for (i, j) in zip(seq1, seq2):\n        if '---' not in (i, j):\n            codon_cnt[i, j] += 1\n    codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n\n    def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k, w].\"\"\"\n        return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func, [1, 0.1, 2], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20), (1e-10, 10)), tol=1e-05)\n    (t, k, w) = opt_res.x\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    Sd = Nd = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        Sd += pi[c1] * Q[i, j]\n                    else:\n                        Nd += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    Sd *= t\n    Nd *= t\n\n    def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k]. w is fixed to 1.\"\"\"\n        return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func_w1, [1, 0.1], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20)), tol=1e-05)\n    (t, k) = opt_res.x\n    w = 1.0\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    rhoS = rhoN = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        rhoS += pi[c1] * Q[i, j]\n                    else:\n                        rhoN += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    rhoS *= 3\n    rhoN *= 3\n    dN = Nd / rhoN\n    dS = Sd / rhoS\n    return (dN, dS)",
            "def _ml(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'ML method main function (PRIVATE).'\n    from collections import Counter\n    from scipy.optimize import minimize\n    codon_cnt = Counter()\n    pi = _get_pi(seq1, seq2, cmethod, codon_table=codon_table)\n    for (i, j) in zip(seq1, seq2):\n        if '---' not in (i, j):\n            codon_cnt[i, j] += 1\n    codon_lst = [i for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons if 'U' not in i]\n\n    def func(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k, w].\"\"\"\n        return -_likelihood_func(params[0], params[1], params[2], pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func, [1, 0.1, 2], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20), (1e-10, 10)), tol=1e-05)\n    (t, k, w) = opt_res.x\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    Sd = Nd = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        Sd += pi[c1] * Q[i, j]\n                    else:\n                        Nd += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    Sd *= t\n    Nd *= t\n\n    def func_w1(params, pi=pi, codon_cnt=codon_cnt, codon_lst=codon_lst, codon_table=codon_table):\n        \"\"\"Temporary function, params = [t, k]. w is fixed to 1.\"\"\"\n        return -_likelihood_func(params[0], params[1], 1.0, pi, codon_cnt, codon_lst=codon_lst, codon_table=codon_table)\n    opt_res = minimize(func_w1, [1, 0.1], method='L-BFGS-B', bounds=((1e-10, 20), (1e-10, 20)), tol=1e-05)\n    (t, k) = opt_res.x\n    w = 1.0\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    rhoS = rhoN = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if i != j:\n                try:\n                    if codon_table.forward_table[c1] == codon_table.forward_table[c2]:\n                        rhoS += pi[c1] * Q[i, j]\n                    else:\n                        rhoN += pi[c1] * Q[i, j]\n                except KeyError:\n                    pass\n    rhoS *= 3\n    rhoN *= 3\n    dN = Nd / rhoN\n    dS = Sd / rhoS\n    return (dN, dS)"
        ]
    },
    {
        "func_name": "_get_pi",
        "original": "def _get_pi(seq1, seq2, cmethod, codon_table):\n    \"\"\"Obtain codon frequency dict (pi) from two codon list (PRIVATE).\n\n    This function is designed for ML method. Available counting methods\n    (cfreq) are F1x4, F3x4 and F64.\n    \"\"\"\n    pi = {}\n    if cmethod == 'F1x4':\n        fcodon = {'A': 0, 'G': 0, 'C': 0, 'T': 0}\n        for i in seq1 + seq2:\n            if i != '---':\n                for c in i:\n                    fcodon[c] += 1\n        tot = sum(fcodon.values())\n        fcodon = {j: k / tot for (j, k) in fcodon.items()}\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[i[0]] * fcodon[i[1]] * fcodon[i[2]]\n    elif cmethod == 'F3x4':\n        fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n        for i in seq1 + seq2:\n            if i != '---':\n                fcodon[0][i[0]] += 1\n                fcodon[1][i[1]] += 1\n                fcodon[2][i[2]] += 1\n        for i in range(3):\n            tot = sum(fcodon[i].values())\n            fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n        for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[0][i[0]] * fcodon[1][i[1]] * fcodon[2][i[2]]\n    elif cmethod == 'F61':\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = 0.1\n        for i in seq1 + seq2:\n            if i != '---':\n                pi[i] += 1\n        tot = sum(pi.values())\n        pi = {j: k / tot for (j, k) in pi.items()}\n    return pi",
        "mutated": [
            "def _get_pi(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n    'Obtain codon frequency dict (pi) from two codon list (PRIVATE).\\n\\n    This function is designed for ML method. Available counting methods\\n    (cfreq) are F1x4, F3x4 and F64.\\n    '\n    pi = {}\n    if cmethod == 'F1x4':\n        fcodon = {'A': 0, 'G': 0, 'C': 0, 'T': 0}\n        for i in seq1 + seq2:\n            if i != '---':\n                for c in i:\n                    fcodon[c] += 1\n        tot = sum(fcodon.values())\n        fcodon = {j: k / tot for (j, k) in fcodon.items()}\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[i[0]] * fcodon[i[1]] * fcodon[i[2]]\n    elif cmethod == 'F3x4':\n        fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n        for i in seq1 + seq2:\n            if i != '---':\n                fcodon[0][i[0]] += 1\n                fcodon[1][i[1]] += 1\n                fcodon[2][i[2]] += 1\n        for i in range(3):\n            tot = sum(fcodon[i].values())\n            fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n        for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[0][i[0]] * fcodon[1][i[1]] * fcodon[2][i[2]]\n    elif cmethod == 'F61':\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = 0.1\n        for i in seq1 + seq2:\n            if i != '---':\n                pi[i] += 1\n        tot = sum(pi.values())\n        pi = {j: k / tot for (j, k) in pi.items()}\n    return pi",
            "def _get_pi(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Obtain codon frequency dict (pi) from two codon list (PRIVATE).\\n\\n    This function is designed for ML method. Available counting methods\\n    (cfreq) are F1x4, F3x4 and F64.\\n    '\n    pi = {}\n    if cmethod == 'F1x4':\n        fcodon = {'A': 0, 'G': 0, 'C': 0, 'T': 0}\n        for i in seq1 + seq2:\n            if i != '---':\n                for c in i:\n                    fcodon[c] += 1\n        tot = sum(fcodon.values())\n        fcodon = {j: k / tot for (j, k) in fcodon.items()}\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[i[0]] * fcodon[i[1]] * fcodon[i[2]]\n    elif cmethod == 'F3x4':\n        fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n        for i in seq1 + seq2:\n            if i != '---':\n                fcodon[0][i[0]] += 1\n                fcodon[1][i[1]] += 1\n                fcodon[2][i[2]] += 1\n        for i in range(3):\n            tot = sum(fcodon[i].values())\n            fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n        for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[0][i[0]] * fcodon[1][i[1]] * fcodon[2][i[2]]\n    elif cmethod == 'F61':\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = 0.1\n        for i in seq1 + seq2:\n            if i != '---':\n                pi[i] += 1\n        tot = sum(pi.values())\n        pi = {j: k / tot for (j, k) in pi.items()}\n    return pi",
            "def _get_pi(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Obtain codon frequency dict (pi) from two codon list (PRIVATE).\\n\\n    This function is designed for ML method. Available counting methods\\n    (cfreq) are F1x4, F3x4 and F64.\\n    '\n    pi = {}\n    if cmethod == 'F1x4':\n        fcodon = {'A': 0, 'G': 0, 'C': 0, 'T': 0}\n        for i in seq1 + seq2:\n            if i != '---':\n                for c in i:\n                    fcodon[c] += 1\n        tot = sum(fcodon.values())\n        fcodon = {j: k / tot for (j, k) in fcodon.items()}\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[i[0]] * fcodon[i[1]] * fcodon[i[2]]\n    elif cmethod == 'F3x4':\n        fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n        for i in seq1 + seq2:\n            if i != '---':\n                fcodon[0][i[0]] += 1\n                fcodon[1][i[1]] += 1\n                fcodon[2][i[2]] += 1\n        for i in range(3):\n            tot = sum(fcodon[i].values())\n            fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n        for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[0][i[0]] * fcodon[1][i[1]] * fcodon[2][i[2]]\n    elif cmethod == 'F61':\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = 0.1\n        for i in seq1 + seq2:\n            if i != '---':\n                pi[i] += 1\n        tot = sum(pi.values())\n        pi = {j: k / tot for (j, k) in pi.items()}\n    return pi",
            "def _get_pi(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Obtain codon frequency dict (pi) from two codon list (PRIVATE).\\n\\n    This function is designed for ML method. Available counting methods\\n    (cfreq) are F1x4, F3x4 and F64.\\n    '\n    pi = {}\n    if cmethod == 'F1x4':\n        fcodon = {'A': 0, 'G': 0, 'C': 0, 'T': 0}\n        for i in seq1 + seq2:\n            if i != '---':\n                for c in i:\n                    fcodon[c] += 1\n        tot = sum(fcodon.values())\n        fcodon = {j: k / tot for (j, k) in fcodon.items()}\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[i[0]] * fcodon[i[1]] * fcodon[i[2]]\n    elif cmethod == 'F3x4':\n        fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n        for i in seq1 + seq2:\n            if i != '---':\n                fcodon[0][i[0]] += 1\n                fcodon[1][i[1]] += 1\n                fcodon[2][i[2]] += 1\n        for i in range(3):\n            tot = sum(fcodon[i].values())\n            fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n        for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[0][i[0]] * fcodon[1][i[1]] * fcodon[2][i[2]]\n    elif cmethod == 'F61':\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = 0.1\n        for i in seq1 + seq2:\n            if i != '---':\n                pi[i] += 1\n        tot = sum(pi.values())\n        pi = {j: k / tot for (j, k) in pi.items()}\n    return pi",
            "def _get_pi(seq1, seq2, cmethod, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Obtain codon frequency dict (pi) from two codon list (PRIVATE).\\n\\n    This function is designed for ML method. Available counting methods\\n    (cfreq) are F1x4, F3x4 and F64.\\n    '\n    pi = {}\n    if cmethod == 'F1x4':\n        fcodon = {'A': 0, 'G': 0, 'C': 0, 'T': 0}\n        for i in seq1 + seq2:\n            if i != '---':\n                for c in i:\n                    fcodon[c] += 1\n        tot = sum(fcodon.values())\n        fcodon = {j: k / tot for (j, k) in fcodon.items()}\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[i[0]] * fcodon[i[1]] * fcodon[i[2]]\n    elif cmethod == 'F3x4':\n        fcodon = [{'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}, {'A': 0, 'G': 0, 'C': 0, 'T': 0}]\n        for i in seq1 + seq2:\n            if i != '---':\n                fcodon[0][i[0]] += 1\n                fcodon[1][i[1]] += 1\n                fcodon[2][i[2]] += 1\n        for i in range(3):\n            tot = sum(fcodon[i].values())\n            fcodon[i] = {j: k / tot for (j, k) in fcodon[i].items()}\n        for i in list(codon_table.forward_table.keys()) + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = fcodon[0][i[0]] * fcodon[1][i[1]] * fcodon[2][i[2]]\n    elif cmethod == 'F61':\n        for i in codon_table.forward_table.keys() + codon_table.stop_codons:\n            if 'U' not in i:\n                pi[i] = 0.1\n        for i in seq1 + seq2:\n            if i != '---':\n                pi[i] += 1\n        tot = sum(pi.values())\n        pi = {j: k / tot for (j, k) in pi.items()}\n    return pi"
        ]
    },
    {
        "func_name": "_q",
        "original": "def _q(i, j, pi, k, w, codon_table):\n    \"\"\"Q matrix for codon substitution (PRIVATE).\n\n    Arguments:\n     - i, j  : three letter codon string\n     - pi    : expected codon frequency\n     - k     : transition/transversion ratio\n     - w     : nonsynonymous/synonymous rate ratio\n     - codon_table: Bio.Data.CodonTable object\n\n    \"\"\"\n    if i == j:\n        return 0\n    if i in codon_table.stop_codons or j in codon_table.stop_codons:\n        return 0\n    if i not in pi or j not in pi:\n        return 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    diff = []\n    for (n, (c1, c2)) in enumerate(zip(i, j)):\n        if c1 != c2:\n            diff.append((n, c1, c2))\n    if len(diff) >= 2:\n        return 0\n    if codon_table.forward_table[i] == codon_table.forward_table[j]:\n        if diff[0][1] in purine and diff[0][2] in purine:\n            return k * pi[j]\n        elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n            return k * pi[j]\n        else:\n            return pi[j]\n    elif diff[0][1] in purine and diff[0][2] in purine:\n        return w * k * pi[j]\n    elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n        return w * k * pi[j]\n    else:\n        return w * pi[j]",
        "mutated": [
            "def _q(i, j, pi, k, w, codon_table):\n    if False:\n        i = 10\n    'Q matrix for codon substitution (PRIVATE).\\n\\n    Arguments:\\n     - i, j  : three letter codon string\\n     - pi    : expected codon frequency\\n     - k     : transition/transversion ratio\\n     - w     : nonsynonymous/synonymous rate ratio\\n     - codon_table: Bio.Data.CodonTable object\\n\\n    '\n    if i == j:\n        return 0\n    if i in codon_table.stop_codons or j in codon_table.stop_codons:\n        return 0\n    if i not in pi or j not in pi:\n        return 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    diff = []\n    for (n, (c1, c2)) in enumerate(zip(i, j)):\n        if c1 != c2:\n            diff.append((n, c1, c2))\n    if len(diff) >= 2:\n        return 0\n    if codon_table.forward_table[i] == codon_table.forward_table[j]:\n        if diff[0][1] in purine and diff[0][2] in purine:\n            return k * pi[j]\n        elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n            return k * pi[j]\n        else:\n            return pi[j]\n    elif diff[0][1] in purine and diff[0][2] in purine:\n        return w * k * pi[j]\n    elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n        return w * k * pi[j]\n    else:\n        return w * pi[j]",
            "def _q(i, j, pi, k, w, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Q matrix for codon substitution (PRIVATE).\\n\\n    Arguments:\\n     - i, j  : three letter codon string\\n     - pi    : expected codon frequency\\n     - k     : transition/transversion ratio\\n     - w     : nonsynonymous/synonymous rate ratio\\n     - codon_table: Bio.Data.CodonTable object\\n\\n    '\n    if i == j:\n        return 0\n    if i in codon_table.stop_codons or j in codon_table.stop_codons:\n        return 0\n    if i not in pi or j not in pi:\n        return 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    diff = []\n    for (n, (c1, c2)) in enumerate(zip(i, j)):\n        if c1 != c2:\n            diff.append((n, c1, c2))\n    if len(diff) >= 2:\n        return 0\n    if codon_table.forward_table[i] == codon_table.forward_table[j]:\n        if diff[0][1] in purine and diff[0][2] in purine:\n            return k * pi[j]\n        elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n            return k * pi[j]\n        else:\n            return pi[j]\n    elif diff[0][1] in purine and diff[0][2] in purine:\n        return w * k * pi[j]\n    elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n        return w * k * pi[j]\n    else:\n        return w * pi[j]",
            "def _q(i, j, pi, k, w, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Q matrix for codon substitution (PRIVATE).\\n\\n    Arguments:\\n     - i, j  : three letter codon string\\n     - pi    : expected codon frequency\\n     - k     : transition/transversion ratio\\n     - w     : nonsynonymous/synonymous rate ratio\\n     - codon_table: Bio.Data.CodonTable object\\n\\n    '\n    if i == j:\n        return 0\n    if i in codon_table.stop_codons or j in codon_table.stop_codons:\n        return 0\n    if i not in pi or j not in pi:\n        return 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    diff = []\n    for (n, (c1, c2)) in enumerate(zip(i, j)):\n        if c1 != c2:\n            diff.append((n, c1, c2))\n    if len(diff) >= 2:\n        return 0\n    if codon_table.forward_table[i] == codon_table.forward_table[j]:\n        if diff[0][1] in purine and diff[0][2] in purine:\n            return k * pi[j]\n        elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n            return k * pi[j]\n        else:\n            return pi[j]\n    elif diff[0][1] in purine and diff[0][2] in purine:\n        return w * k * pi[j]\n    elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n        return w * k * pi[j]\n    else:\n        return w * pi[j]",
            "def _q(i, j, pi, k, w, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Q matrix for codon substitution (PRIVATE).\\n\\n    Arguments:\\n     - i, j  : three letter codon string\\n     - pi    : expected codon frequency\\n     - k     : transition/transversion ratio\\n     - w     : nonsynonymous/synonymous rate ratio\\n     - codon_table: Bio.Data.CodonTable object\\n\\n    '\n    if i == j:\n        return 0\n    if i in codon_table.stop_codons or j in codon_table.stop_codons:\n        return 0\n    if i not in pi or j not in pi:\n        return 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    diff = []\n    for (n, (c1, c2)) in enumerate(zip(i, j)):\n        if c1 != c2:\n            diff.append((n, c1, c2))\n    if len(diff) >= 2:\n        return 0\n    if codon_table.forward_table[i] == codon_table.forward_table[j]:\n        if diff[0][1] in purine and diff[0][2] in purine:\n            return k * pi[j]\n        elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n            return k * pi[j]\n        else:\n            return pi[j]\n    elif diff[0][1] in purine and diff[0][2] in purine:\n        return w * k * pi[j]\n    elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n        return w * k * pi[j]\n    else:\n        return w * pi[j]",
            "def _q(i, j, pi, k, w, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Q matrix for codon substitution (PRIVATE).\\n\\n    Arguments:\\n     - i, j  : three letter codon string\\n     - pi    : expected codon frequency\\n     - k     : transition/transversion ratio\\n     - w     : nonsynonymous/synonymous rate ratio\\n     - codon_table: Bio.Data.CodonTable object\\n\\n    '\n    if i == j:\n        return 0\n    if i in codon_table.stop_codons or j in codon_table.stop_codons:\n        return 0\n    if i not in pi or j not in pi:\n        return 0\n    purine = ('A', 'G')\n    pyrimidine = ('T', 'C')\n    diff = []\n    for (n, (c1, c2)) in enumerate(zip(i, j)):\n        if c1 != c2:\n            diff.append((n, c1, c2))\n    if len(diff) >= 2:\n        return 0\n    if codon_table.forward_table[i] == codon_table.forward_table[j]:\n        if diff[0][1] in purine and diff[0][2] in purine:\n            return k * pi[j]\n        elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n            return k * pi[j]\n        else:\n            return pi[j]\n    elif diff[0][1] in purine and diff[0][2] in purine:\n        return w * k * pi[j]\n    elif diff[0][1] in pyrimidine and diff[0][2] in pyrimidine:\n        return w * k * pi[j]\n    else:\n        return w * pi[j]"
        ]
    },
    {
        "func_name": "_get_Q",
        "original": "def _get_Q(pi, k, w, codon_lst, codon_table):\n    \"\"\"Q matrix for codon substitution (PRIVATE).\"\"\"\n    import numpy as np\n    codon_num = len(codon_lst)\n    Q = np.zeros((codon_num, codon_num))\n    for i in range(codon_num):\n        for j in range(codon_num):\n            if i != j:\n                Q[i, j] = _q(codon_lst[i], codon_lst[j], pi, k, w, codon_table=codon_table)\n    nucl_substitutions = 0\n    for i in range(codon_num):\n        Q[i, i] = -sum(Q[i, :])\n        try:\n            nucl_substitutions += pi[codon_lst[i]] * -Q[i, i]\n        except KeyError:\n            pass\n    Q = Q / nucl_substitutions\n    return Q",
        "mutated": [
            "def _get_Q(pi, k, w, codon_lst, codon_table):\n    if False:\n        i = 10\n    'Q matrix for codon substitution (PRIVATE).'\n    import numpy as np\n    codon_num = len(codon_lst)\n    Q = np.zeros((codon_num, codon_num))\n    for i in range(codon_num):\n        for j in range(codon_num):\n            if i != j:\n                Q[i, j] = _q(codon_lst[i], codon_lst[j], pi, k, w, codon_table=codon_table)\n    nucl_substitutions = 0\n    for i in range(codon_num):\n        Q[i, i] = -sum(Q[i, :])\n        try:\n            nucl_substitutions += pi[codon_lst[i]] * -Q[i, i]\n        except KeyError:\n            pass\n    Q = Q / nucl_substitutions\n    return Q",
            "def _get_Q(pi, k, w, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Q matrix for codon substitution (PRIVATE).'\n    import numpy as np\n    codon_num = len(codon_lst)\n    Q = np.zeros((codon_num, codon_num))\n    for i in range(codon_num):\n        for j in range(codon_num):\n            if i != j:\n                Q[i, j] = _q(codon_lst[i], codon_lst[j], pi, k, w, codon_table=codon_table)\n    nucl_substitutions = 0\n    for i in range(codon_num):\n        Q[i, i] = -sum(Q[i, :])\n        try:\n            nucl_substitutions += pi[codon_lst[i]] * -Q[i, i]\n        except KeyError:\n            pass\n    Q = Q / nucl_substitutions\n    return Q",
            "def _get_Q(pi, k, w, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Q matrix for codon substitution (PRIVATE).'\n    import numpy as np\n    codon_num = len(codon_lst)\n    Q = np.zeros((codon_num, codon_num))\n    for i in range(codon_num):\n        for j in range(codon_num):\n            if i != j:\n                Q[i, j] = _q(codon_lst[i], codon_lst[j], pi, k, w, codon_table=codon_table)\n    nucl_substitutions = 0\n    for i in range(codon_num):\n        Q[i, i] = -sum(Q[i, :])\n        try:\n            nucl_substitutions += pi[codon_lst[i]] * -Q[i, i]\n        except KeyError:\n            pass\n    Q = Q / nucl_substitutions\n    return Q",
            "def _get_Q(pi, k, w, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Q matrix for codon substitution (PRIVATE).'\n    import numpy as np\n    codon_num = len(codon_lst)\n    Q = np.zeros((codon_num, codon_num))\n    for i in range(codon_num):\n        for j in range(codon_num):\n            if i != j:\n                Q[i, j] = _q(codon_lst[i], codon_lst[j], pi, k, w, codon_table=codon_table)\n    nucl_substitutions = 0\n    for i in range(codon_num):\n        Q[i, i] = -sum(Q[i, :])\n        try:\n            nucl_substitutions += pi[codon_lst[i]] * -Q[i, i]\n        except KeyError:\n            pass\n    Q = Q / nucl_substitutions\n    return Q",
            "def _get_Q(pi, k, w, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Q matrix for codon substitution (PRIVATE).'\n    import numpy as np\n    codon_num = len(codon_lst)\n    Q = np.zeros((codon_num, codon_num))\n    for i in range(codon_num):\n        for j in range(codon_num):\n            if i != j:\n                Q[i, j] = _q(codon_lst[i], codon_lst[j], pi, k, w, codon_table=codon_table)\n    nucl_substitutions = 0\n    for i in range(codon_num):\n        Q[i, i] = -sum(Q[i, :])\n        try:\n            nucl_substitutions += pi[codon_lst[i]] * -Q[i, i]\n        except KeyError:\n            pass\n    Q = Q / nucl_substitutions\n    return Q"
        ]
    },
    {
        "func_name": "_likelihood_func",
        "original": "def _likelihood_func(t, k, w, pi, codon_cnt, codon_lst, codon_table):\n    \"\"\"Likelihood function for ML method (PRIVATE).\"\"\"\n    from scipy.linalg import expm\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    P = expm(Q * t)\n    likelihood = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if (c1, c2) in codon_cnt:\n                if P[i, j] * pi[c1] <= 0:\n                    likelihood += codon_cnt[c1, c2] * 0\n                else:\n                    likelihood += codon_cnt[c1, c2] * log(pi[c1] * P[i, j])\n    return likelihood",
        "mutated": [
            "def _likelihood_func(t, k, w, pi, codon_cnt, codon_lst, codon_table):\n    if False:\n        i = 10\n    'Likelihood function for ML method (PRIVATE).'\n    from scipy.linalg import expm\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    P = expm(Q * t)\n    likelihood = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if (c1, c2) in codon_cnt:\n                if P[i, j] * pi[c1] <= 0:\n                    likelihood += codon_cnt[c1, c2] * 0\n                else:\n                    likelihood += codon_cnt[c1, c2] * log(pi[c1] * P[i, j])\n    return likelihood",
            "def _likelihood_func(t, k, w, pi, codon_cnt, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Likelihood function for ML method (PRIVATE).'\n    from scipy.linalg import expm\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    P = expm(Q * t)\n    likelihood = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if (c1, c2) in codon_cnt:\n                if P[i, j] * pi[c1] <= 0:\n                    likelihood += codon_cnt[c1, c2] * 0\n                else:\n                    likelihood += codon_cnt[c1, c2] * log(pi[c1] * P[i, j])\n    return likelihood",
            "def _likelihood_func(t, k, w, pi, codon_cnt, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Likelihood function for ML method (PRIVATE).'\n    from scipy.linalg import expm\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    P = expm(Q * t)\n    likelihood = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if (c1, c2) in codon_cnt:\n                if P[i, j] * pi[c1] <= 0:\n                    likelihood += codon_cnt[c1, c2] * 0\n                else:\n                    likelihood += codon_cnt[c1, c2] * log(pi[c1] * P[i, j])\n    return likelihood",
            "def _likelihood_func(t, k, w, pi, codon_cnt, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Likelihood function for ML method (PRIVATE).'\n    from scipy.linalg import expm\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    P = expm(Q * t)\n    likelihood = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if (c1, c2) in codon_cnt:\n                if P[i, j] * pi[c1] <= 0:\n                    likelihood += codon_cnt[c1, c2] * 0\n                else:\n                    likelihood += codon_cnt[c1, c2] * log(pi[c1] * P[i, j])\n    return likelihood",
            "def _likelihood_func(t, k, w, pi, codon_cnt, codon_lst, codon_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Likelihood function for ML method (PRIVATE).'\n    from scipy.linalg import expm\n    Q = _get_Q(pi, k, w, codon_lst, codon_table)\n    P = expm(Q * t)\n    likelihood = 0\n    for (i, c1) in enumerate(codon_lst):\n        for (j, c2) in enumerate(codon_lst):\n            if (c1, c2) in codon_cnt:\n                if P[i, j] * pi[c1] <= 0:\n                    likelihood += codon_cnt[c1, c2] * 0\n                else:\n                    likelihood += codon_cnt[c1, c2] * log(pi[c1] * P[i, j])\n    return likelihood"
        ]
    }
]