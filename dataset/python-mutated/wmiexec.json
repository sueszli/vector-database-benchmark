[
    {
        "func_name": "__init__",
        "original": "def __init__(self, host, username, password, domain, lmhash, nthash, doKerberos, kdcHost, aesKey, logger, interval_time, codec):\n    self.__host = host\n    self.__username = username\n    self.__password = password\n    self.__domain = domain\n    self.__lmhash = lmhash\n    self.__nthash = nthash\n    self.__doKerberos = doKerberos\n    self.__kdcHost = kdcHost\n    self.__aesKey = aesKey\n    self.logger = logger\n    self.__interval_time = interval_time\n    self.__registry_Path = ''\n    self.__outputBuffer = ''\n    self.__retOutput = True\n    self.__shell = 'cmd.exe /Q /c '\n    self.__pwd = str('C:\\\\')\n    self.__codec = codec\n    self.__dcom = DCOMConnection(self.__host, self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, oxidResolver=True, doKerberos=self.__doKerberos, kdcHost=self.__kdcHost, aesKey=self.__aesKey)\n    iInterface = self.__dcom.CoCreateInstanceEx(CLSID_WbemLevel1Login, IID_IWbemLevel1Login)\n    iWbemLevel1Login = IWbemLevel1Login(iInterface)\n    self.__iWbemServices = iWbemLevel1Login.NTLMLogin('//./root/cimv2', NULL, NULL)\n    iWbemLevel1Login.RemRelease()\n    (self.__win32Process, _) = self.__iWbemServices.GetObject('Win32_Process')",
        "mutated": [
            "def __init__(self, host, username, password, domain, lmhash, nthash, doKerberos, kdcHost, aesKey, logger, interval_time, codec):\n    if False:\n        i = 10\n    self.__host = host\n    self.__username = username\n    self.__password = password\n    self.__domain = domain\n    self.__lmhash = lmhash\n    self.__nthash = nthash\n    self.__doKerberos = doKerberos\n    self.__kdcHost = kdcHost\n    self.__aesKey = aesKey\n    self.logger = logger\n    self.__interval_time = interval_time\n    self.__registry_Path = ''\n    self.__outputBuffer = ''\n    self.__retOutput = True\n    self.__shell = 'cmd.exe /Q /c '\n    self.__pwd = str('C:\\\\')\n    self.__codec = codec\n    self.__dcom = DCOMConnection(self.__host, self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, oxidResolver=True, doKerberos=self.__doKerberos, kdcHost=self.__kdcHost, aesKey=self.__aesKey)\n    iInterface = self.__dcom.CoCreateInstanceEx(CLSID_WbemLevel1Login, IID_IWbemLevel1Login)\n    iWbemLevel1Login = IWbemLevel1Login(iInterface)\n    self.__iWbemServices = iWbemLevel1Login.NTLMLogin('//./root/cimv2', NULL, NULL)\n    iWbemLevel1Login.RemRelease()\n    (self.__win32Process, _) = self.__iWbemServices.GetObject('Win32_Process')",
            "def __init__(self, host, username, password, domain, lmhash, nthash, doKerberos, kdcHost, aesKey, logger, interval_time, codec):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__host = host\n    self.__username = username\n    self.__password = password\n    self.__domain = domain\n    self.__lmhash = lmhash\n    self.__nthash = nthash\n    self.__doKerberos = doKerberos\n    self.__kdcHost = kdcHost\n    self.__aesKey = aesKey\n    self.logger = logger\n    self.__interval_time = interval_time\n    self.__registry_Path = ''\n    self.__outputBuffer = ''\n    self.__retOutput = True\n    self.__shell = 'cmd.exe /Q /c '\n    self.__pwd = str('C:\\\\')\n    self.__codec = codec\n    self.__dcom = DCOMConnection(self.__host, self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, oxidResolver=True, doKerberos=self.__doKerberos, kdcHost=self.__kdcHost, aesKey=self.__aesKey)\n    iInterface = self.__dcom.CoCreateInstanceEx(CLSID_WbemLevel1Login, IID_IWbemLevel1Login)\n    iWbemLevel1Login = IWbemLevel1Login(iInterface)\n    self.__iWbemServices = iWbemLevel1Login.NTLMLogin('//./root/cimv2', NULL, NULL)\n    iWbemLevel1Login.RemRelease()\n    (self.__win32Process, _) = self.__iWbemServices.GetObject('Win32_Process')",
            "def __init__(self, host, username, password, domain, lmhash, nthash, doKerberos, kdcHost, aesKey, logger, interval_time, codec):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__host = host\n    self.__username = username\n    self.__password = password\n    self.__domain = domain\n    self.__lmhash = lmhash\n    self.__nthash = nthash\n    self.__doKerberos = doKerberos\n    self.__kdcHost = kdcHost\n    self.__aesKey = aesKey\n    self.logger = logger\n    self.__interval_time = interval_time\n    self.__registry_Path = ''\n    self.__outputBuffer = ''\n    self.__retOutput = True\n    self.__shell = 'cmd.exe /Q /c '\n    self.__pwd = str('C:\\\\')\n    self.__codec = codec\n    self.__dcom = DCOMConnection(self.__host, self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, oxidResolver=True, doKerberos=self.__doKerberos, kdcHost=self.__kdcHost, aesKey=self.__aesKey)\n    iInterface = self.__dcom.CoCreateInstanceEx(CLSID_WbemLevel1Login, IID_IWbemLevel1Login)\n    iWbemLevel1Login = IWbemLevel1Login(iInterface)\n    self.__iWbemServices = iWbemLevel1Login.NTLMLogin('//./root/cimv2', NULL, NULL)\n    iWbemLevel1Login.RemRelease()\n    (self.__win32Process, _) = self.__iWbemServices.GetObject('Win32_Process')",
            "def __init__(self, host, username, password, domain, lmhash, nthash, doKerberos, kdcHost, aesKey, logger, interval_time, codec):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__host = host\n    self.__username = username\n    self.__password = password\n    self.__domain = domain\n    self.__lmhash = lmhash\n    self.__nthash = nthash\n    self.__doKerberos = doKerberos\n    self.__kdcHost = kdcHost\n    self.__aesKey = aesKey\n    self.logger = logger\n    self.__interval_time = interval_time\n    self.__registry_Path = ''\n    self.__outputBuffer = ''\n    self.__retOutput = True\n    self.__shell = 'cmd.exe /Q /c '\n    self.__pwd = str('C:\\\\')\n    self.__codec = codec\n    self.__dcom = DCOMConnection(self.__host, self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, oxidResolver=True, doKerberos=self.__doKerberos, kdcHost=self.__kdcHost, aesKey=self.__aesKey)\n    iInterface = self.__dcom.CoCreateInstanceEx(CLSID_WbemLevel1Login, IID_IWbemLevel1Login)\n    iWbemLevel1Login = IWbemLevel1Login(iInterface)\n    self.__iWbemServices = iWbemLevel1Login.NTLMLogin('//./root/cimv2', NULL, NULL)\n    iWbemLevel1Login.RemRelease()\n    (self.__win32Process, _) = self.__iWbemServices.GetObject('Win32_Process')",
            "def __init__(self, host, username, password, domain, lmhash, nthash, doKerberos, kdcHost, aesKey, logger, interval_time, codec):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__host = host\n    self.__username = username\n    self.__password = password\n    self.__domain = domain\n    self.__lmhash = lmhash\n    self.__nthash = nthash\n    self.__doKerberos = doKerberos\n    self.__kdcHost = kdcHost\n    self.__aesKey = aesKey\n    self.logger = logger\n    self.__interval_time = interval_time\n    self.__registry_Path = ''\n    self.__outputBuffer = ''\n    self.__retOutput = True\n    self.__shell = 'cmd.exe /Q /c '\n    self.__pwd = str('C:\\\\')\n    self.__codec = codec\n    self.__dcom = DCOMConnection(self.__host, self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, oxidResolver=True, doKerberos=self.__doKerberos, kdcHost=self.__kdcHost, aesKey=self.__aesKey)\n    iInterface = self.__dcom.CoCreateInstanceEx(CLSID_WbemLevel1Login, IID_IWbemLevel1Login)\n    iWbemLevel1Login = IWbemLevel1Login(iInterface)\n    self.__iWbemServices = iWbemLevel1Login.NTLMLogin('//./root/cimv2', NULL, NULL)\n    iWbemLevel1Login.RemRelease()\n    (self.__win32Process, _) = self.__iWbemServices.GetObject('Win32_Process')"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, command, output=False):\n    self.__retOutput = output\n    if self.__retOutput:\n        self.execute_WithOutput(command)\n    else:\n        command = self.__shell + command\n        self.execute_remote(command)\n    self.__dcom.disconnect()\n    return self.__outputBuffer",
        "mutated": [
            "def execute(self, command, output=False):\n    if False:\n        i = 10\n    self.__retOutput = output\n    if self.__retOutput:\n        self.execute_WithOutput(command)\n    else:\n        command = self.__shell + command\n        self.execute_remote(command)\n    self.__dcom.disconnect()\n    return self.__outputBuffer",
            "def execute(self, command, output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__retOutput = output\n    if self.__retOutput:\n        self.execute_WithOutput(command)\n    else:\n        command = self.__shell + command\n        self.execute_remote(command)\n    self.__dcom.disconnect()\n    return self.__outputBuffer",
            "def execute(self, command, output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__retOutput = output\n    if self.__retOutput:\n        self.execute_WithOutput(command)\n    else:\n        command = self.__shell + command\n        self.execute_remote(command)\n    self.__dcom.disconnect()\n    return self.__outputBuffer",
            "def execute(self, command, output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__retOutput = output\n    if self.__retOutput:\n        self.execute_WithOutput(command)\n    else:\n        command = self.__shell + command\n        self.execute_remote(command)\n    self.__dcom.disconnect()\n    return self.__outputBuffer",
            "def execute(self, command, output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__retOutput = output\n    if self.__retOutput:\n        self.execute_WithOutput(command)\n    else:\n        command = self.__shell + command\n        self.execute_remote(command)\n    self.__dcom.disconnect()\n    return self.__outputBuffer"
        ]
    },
    {
        "func_name": "execute_remote",
        "original": "def execute_remote(self, command):\n    self.logger.info(f'Executing command: {command}')\n    try:\n        self.__win32Process.Create(command, self.__pwd, None)\n    except Exception as e:\n        self.logger.error(str(e))",
        "mutated": [
            "def execute_remote(self, command):\n    if False:\n        i = 10\n    self.logger.info(f'Executing command: {command}')\n    try:\n        self.__win32Process.Create(command, self.__pwd, None)\n    except Exception as e:\n        self.logger.error(str(e))",
            "def execute_remote(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.logger.info(f'Executing command: {command}')\n    try:\n        self.__win32Process.Create(command, self.__pwd, None)\n    except Exception as e:\n        self.logger.error(str(e))",
            "def execute_remote(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.logger.info(f'Executing command: {command}')\n    try:\n        self.__win32Process.Create(command, self.__pwd, None)\n    except Exception as e:\n        self.logger.error(str(e))",
            "def execute_remote(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.logger.info(f'Executing command: {command}')\n    try:\n        self.__win32Process.Create(command, self.__pwd, None)\n    except Exception as e:\n        self.logger.error(str(e))",
            "def execute_remote(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.logger.info(f'Executing command: {command}')\n    try:\n        self.__win32Process.Create(command, self.__pwd, None)\n    except Exception as e:\n        self.logger.error(str(e))"
        ]
    },
    {
        "func_name": "execute_WithOutput",
        "original": "def execute_WithOutput(self, command):\n    result_output = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    result_output_b64 = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    keyName = str(uuid.uuid4())\n    self.__registry_Path = f'Software\\\\Classes\\\\{gen_random_string(6)}'\n    command = f'{self.__shell} {command} 1> {result_output} 2>&1 && certutil -encodehex -f {result_output} {result_output_b64} 0x40000001 && for /F \"usebackq\" %G in (\"{result_output_b64}\") do reg add HKLM\\\\{self.__registry_Path} /v {keyName} /t REG_SZ /d \"%G\" /f && del /q /f /s {result_output} {result_output_b64}'\n    self.execute_remote(command)\n    self.logger.info('Waiting {}s for command completely executed.'.format(self.__interval_time))\n    time.sleep(self.__interval_time)\n    self.queryRegistry(keyName)",
        "mutated": [
            "def execute_WithOutput(self, command):\n    if False:\n        i = 10\n    result_output = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    result_output_b64 = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    keyName = str(uuid.uuid4())\n    self.__registry_Path = f'Software\\\\Classes\\\\{gen_random_string(6)}'\n    command = f'{self.__shell} {command} 1> {result_output} 2>&1 && certutil -encodehex -f {result_output} {result_output_b64} 0x40000001 && for /F \"usebackq\" %G in (\"{result_output_b64}\") do reg add HKLM\\\\{self.__registry_Path} /v {keyName} /t REG_SZ /d \"%G\" /f && del /q /f /s {result_output} {result_output_b64}'\n    self.execute_remote(command)\n    self.logger.info('Waiting {}s for command completely executed.'.format(self.__interval_time))\n    time.sleep(self.__interval_time)\n    self.queryRegistry(keyName)",
            "def execute_WithOutput(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result_output = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    result_output_b64 = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    keyName = str(uuid.uuid4())\n    self.__registry_Path = f'Software\\\\Classes\\\\{gen_random_string(6)}'\n    command = f'{self.__shell} {command} 1> {result_output} 2>&1 && certutil -encodehex -f {result_output} {result_output_b64} 0x40000001 && for /F \"usebackq\" %G in (\"{result_output_b64}\") do reg add HKLM\\\\{self.__registry_Path} /v {keyName} /t REG_SZ /d \"%G\" /f && del /q /f /s {result_output} {result_output_b64}'\n    self.execute_remote(command)\n    self.logger.info('Waiting {}s for command completely executed.'.format(self.__interval_time))\n    time.sleep(self.__interval_time)\n    self.queryRegistry(keyName)",
            "def execute_WithOutput(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result_output = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    result_output_b64 = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    keyName = str(uuid.uuid4())\n    self.__registry_Path = f'Software\\\\Classes\\\\{gen_random_string(6)}'\n    command = f'{self.__shell} {command} 1> {result_output} 2>&1 && certutil -encodehex -f {result_output} {result_output_b64} 0x40000001 && for /F \"usebackq\" %G in (\"{result_output_b64}\") do reg add HKLM\\\\{self.__registry_Path} /v {keyName} /t REG_SZ /d \"%G\" /f && del /q /f /s {result_output} {result_output_b64}'\n    self.execute_remote(command)\n    self.logger.info('Waiting {}s for command completely executed.'.format(self.__interval_time))\n    time.sleep(self.__interval_time)\n    self.queryRegistry(keyName)",
            "def execute_WithOutput(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result_output = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    result_output_b64 = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    keyName = str(uuid.uuid4())\n    self.__registry_Path = f'Software\\\\Classes\\\\{gen_random_string(6)}'\n    command = f'{self.__shell} {command} 1> {result_output} 2>&1 && certutil -encodehex -f {result_output} {result_output_b64} 0x40000001 && for /F \"usebackq\" %G in (\"{result_output_b64}\") do reg add HKLM\\\\{self.__registry_Path} /v {keyName} /t REG_SZ /d \"%G\" /f && del /q /f /s {result_output} {result_output_b64}'\n    self.execute_remote(command)\n    self.logger.info('Waiting {}s for command completely executed.'.format(self.__interval_time))\n    time.sleep(self.__interval_time)\n    self.queryRegistry(keyName)",
            "def execute_WithOutput(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result_output = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    result_output_b64 = f'C:\\\\windows\\\\temp\\\\{str(uuid.uuid4())}.txt'\n    keyName = str(uuid.uuid4())\n    self.__registry_Path = f'Software\\\\Classes\\\\{gen_random_string(6)}'\n    command = f'{self.__shell} {command} 1> {result_output} 2>&1 && certutil -encodehex -f {result_output} {result_output_b64} 0x40000001 && for /F \"usebackq\" %G in (\"{result_output_b64}\") do reg add HKLM\\\\{self.__registry_Path} /v {keyName} /t REG_SZ /d \"%G\" /f && del /q /f /s {result_output} {result_output_b64}'\n    self.execute_remote(command)\n    self.logger.info('Waiting {}s for command completely executed.'.format(self.__interval_time))\n    time.sleep(self.__interval_time)\n    self.queryRegistry(keyName)"
        ]
    },
    {
        "func_name": "queryRegistry",
        "original": "def queryRegistry(self, keyName):\n    try:\n        self.logger.debug(f'Querying registry key: HKLM\\\\{self.__registry_Path}')\n        (descriptor, _) = self.__iWbemServices.GetObject('StdRegProv')\n        descriptor = descriptor.SpawnInstance()\n        retVal = descriptor.GetStringValue(2147483650, self.__registry_Path, keyName)\n        self.__outputBuffer = base64.b64decode(retVal.sValue).decode(self.__codec, errors='replace').rstrip('\\r\\n')\n    except Exception as e:\n        self.logger.fail(f\"\"\"WMIEXEC: Get output file error, maybe command not executed successfully or got detected by AV software, please increase the interval time of command execution with \"--interval-time\" option. If it's still failing maybe something is blocking the schedule job in vbscript, try another exec method\"\"\")\n    try:\n        self.logger.debug(f'Removing temporary registry path: HKLM\\\\{self.__registry_Path}')\n        retVal = descriptor.DeleteKey(2147483650, self.__registry_Path)\n    except Exception as e:\n        self.logger.debug(f'Target: {self.__host} removing temporary registry path error: {str(e)}')",
        "mutated": [
            "def queryRegistry(self, keyName):\n    if False:\n        i = 10\n    try:\n        self.logger.debug(f'Querying registry key: HKLM\\\\{self.__registry_Path}')\n        (descriptor, _) = self.__iWbemServices.GetObject('StdRegProv')\n        descriptor = descriptor.SpawnInstance()\n        retVal = descriptor.GetStringValue(2147483650, self.__registry_Path, keyName)\n        self.__outputBuffer = base64.b64decode(retVal.sValue).decode(self.__codec, errors='replace').rstrip('\\r\\n')\n    except Exception as e:\n        self.logger.fail(f\"\"\"WMIEXEC: Get output file error, maybe command not executed successfully or got detected by AV software, please increase the interval time of command execution with \"--interval-time\" option. If it's still failing maybe something is blocking the schedule job in vbscript, try another exec method\"\"\")\n    try:\n        self.logger.debug(f'Removing temporary registry path: HKLM\\\\{self.__registry_Path}')\n        retVal = descriptor.DeleteKey(2147483650, self.__registry_Path)\n    except Exception as e:\n        self.logger.debug(f'Target: {self.__host} removing temporary registry path error: {str(e)}')",
            "def queryRegistry(self, keyName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        self.logger.debug(f'Querying registry key: HKLM\\\\{self.__registry_Path}')\n        (descriptor, _) = self.__iWbemServices.GetObject('StdRegProv')\n        descriptor = descriptor.SpawnInstance()\n        retVal = descriptor.GetStringValue(2147483650, self.__registry_Path, keyName)\n        self.__outputBuffer = base64.b64decode(retVal.sValue).decode(self.__codec, errors='replace').rstrip('\\r\\n')\n    except Exception as e:\n        self.logger.fail(f\"\"\"WMIEXEC: Get output file error, maybe command not executed successfully or got detected by AV software, please increase the interval time of command execution with \"--interval-time\" option. If it's still failing maybe something is blocking the schedule job in vbscript, try another exec method\"\"\")\n    try:\n        self.logger.debug(f'Removing temporary registry path: HKLM\\\\{self.__registry_Path}')\n        retVal = descriptor.DeleteKey(2147483650, self.__registry_Path)\n    except Exception as e:\n        self.logger.debug(f'Target: {self.__host} removing temporary registry path error: {str(e)}')",
            "def queryRegistry(self, keyName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        self.logger.debug(f'Querying registry key: HKLM\\\\{self.__registry_Path}')\n        (descriptor, _) = self.__iWbemServices.GetObject('StdRegProv')\n        descriptor = descriptor.SpawnInstance()\n        retVal = descriptor.GetStringValue(2147483650, self.__registry_Path, keyName)\n        self.__outputBuffer = base64.b64decode(retVal.sValue).decode(self.__codec, errors='replace').rstrip('\\r\\n')\n    except Exception as e:\n        self.logger.fail(f\"\"\"WMIEXEC: Get output file error, maybe command not executed successfully or got detected by AV software, please increase the interval time of command execution with \"--interval-time\" option. If it's still failing maybe something is blocking the schedule job in vbscript, try another exec method\"\"\")\n    try:\n        self.logger.debug(f'Removing temporary registry path: HKLM\\\\{self.__registry_Path}')\n        retVal = descriptor.DeleteKey(2147483650, self.__registry_Path)\n    except Exception as e:\n        self.logger.debug(f'Target: {self.__host} removing temporary registry path error: {str(e)}')",
            "def queryRegistry(self, keyName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        self.logger.debug(f'Querying registry key: HKLM\\\\{self.__registry_Path}')\n        (descriptor, _) = self.__iWbemServices.GetObject('StdRegProv')\n        descriptor = descriptor.SpawnInstance()\n        retVal = descriptor.GetStringValue(2147483650, self.__registry_Path, keyName)\n        self.__outputBuffer = base64.b64decode(retVal.sValue).decode(self.__codec, errors='replace').rstrip('\\r\\n')\n    except Exception as e:\n        self.logger.fail(f\"\"\"WMIEXEC: Get output file error, maybe command not executed successfully or got detected by AV software, please increase the interval time of command execution with \"--interval-time\" option. If it's still failing maybe something is blocking the schedule job in vbscript, try another exec method\"\"\")\n    try:\n        self.logger.debug(f'Removing temporary registry path: HKLM\\\\{self.__registry_Path}')\n        retVal = descriptor.DeleteKey(2147483650, self.__registry_Path)\n    except Exception as e:\n        self.logger.debug(f'Target: {self.__host} removing temporary registry path error: {str(e)}')",
            "def queryRegistry(self, keyName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        self.logger.debug(f'Querying registry key: HKLM\\\\{self.__registry_Path}')\n        (descriptor, _) = self.__iWbemServices.GetObject('StdRegProv')\n        descriptor = descriptor.SpawnInstance()\n        retVal = descriptor.GetStringValue(2147483650, self.__registry_Path, keyName)\n        self.__outputBuffer = base64.b64decode(retVal.sValue).decode(self.__codec, errors='replace').rstrip('\\r\\n')\n    except Exception as e:\n        self.logger.fail(f\"\"\"WMIEXEC: Get output file error, maybe command not executed successfully or got detected by AV software, please increase the interval time of command execution with \"--interval-time\" option. If it's still failing maybe something is blocking the schedule job in vbscript, try another exec method\"\"\")\n    try:\n        self.logger.debug(f'Removing temporary registry path: HKLM\\\\{self.__registry_Path}')\n        retVal = descriptor.DeleteKey(2147483650, self.__registry_Path)\n    except Exception as e:\n        self.logger.debug(f'Target: {self.__host} removing temporary registry path error: {str(e)}')"
        ]
    }
]