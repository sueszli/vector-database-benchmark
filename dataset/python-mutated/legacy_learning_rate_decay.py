"""Various learning rate decay functions."""
import functools
from tensorflow.python.eager import context
from tensorflow.python.framework import dtypes
from tensorflow.python.framework import tensor_conversion
from tensorflow.python.keras.optimizer_v2 import learning_rate_schedule
from tensorflow.python.ops import math_ops
from tensorflow.python.util import nest
from tensorflow.python.util.tf_export import tf_export

@tf_export(v1=['train.exponential_decay'])
def exponential_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None):
    if False:
        while True:
            i = 10
    "Applies exponential decay to the learning rate.\n\n  When training a model, it is often recommended to lower the learning rate as\n  the training progresses.  This function applies an exponential decay function\n  to a provided initial learning rate.  It requires a `global_step` value to\n  compute the decayed learning rate.  You can just pass a TensorFlow variable\n  that you increment at each training step.\n\n  The function returns the decayed learning rate.  It is computed as:\n\n  ```python\n  decayed_learning_rate = learning_rate *\n                          decay_rate ^ (global_step / decay_steps)\n  ```\n\n  If the argument `staircase` is `True`, then `global_step / decay_steps` is an\n  integer division and the decayed learning rate follows a staircase function.\n\n  Example: decay every 100000 steps with a base of 0.96:\n\n  ```python\n  ...\n  global_step = tf.Variable(0, trainable=False)\n  starter_learning_rate = 0.1\n  learning_rate = tf.compat.v1.train.exponential_decay(starter_learning_rate,\n  global_step,\n                                             100000, 0.96, staircase=True)\n  # Passing global_step to minimize() will increment it at each step.\n  learning_step = (\n      tf.compat.v1.train.GradientDescentOptimizer(learning_rate)\n      .minimize(...my loss..., global_step=global_step)\n  )\n  ```\n\n  Args:\n    learning_rate: A scalar `float32` or `float64` `Tensor` or a Python number.\n      The initial learning rate.\n    global_step: A scalar `int32` or `int64` `Tensor` or a Python number. Global\n      step to use for the decay computation.  Must not be negative.\n    decay_steps: A scalar `int32` or `int64` `Tensor` or a Python number. Must\n      be positive.  See the decay computation above.\n    decay_rate: A scalar `float32` or `float64` `Tensor` or a Python number.\n      The decay rate.\n    staircase: Boolean.  If `True` decay the learning rate at discrete intervals\n    name: String.  Optional name of the operation.  Defaults to\n      'ExponentialDecay'.\n\n  Returns:\n    A scalar `Tensor` of the same type as `learning_rate`.  The decayed\n    learning rate.\n\n  Raises:\n    ValueError: if `global_step` is not supplied.\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    decayed_lr = learning_rate_schedule.ExponentialDecay(learning_rate, decay_steps, decay_rate, staircase=staircase, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(global_step)
    else:
        decayed_lr = functools.partial(decayed_lr, global_step)
    return decayed_lr

@tf_export(v1=['train.piecewise_constant_decay', 'train.piecewise_constant'])
def piecewise_constant(x, boundaries, values, name=None):
    if False:
        print('Hello World!')
    "Piecewise constant from boundaries and interval values.\n\n  Example: use a learning rate that's 1.0 for the first 100001 steps, 0.5\n    for the next 10000 steps, and 0.1 for any additional steps.\n\n  ```python\n  global_step = tf.Variable(0, trainable=False)\n  boundaries = [100000, 110000]\n  values = [1.0, 0.5, 0.1]\n  learning_rate = tf.compat.v1.train.piecewise_constant(global_step, boundaries,\n  values)\n\n  # Later, whenever we perform an optimization step, we increment global_step.\n  ```\n\n  Args:\n    x: A 0-D scalar `Tensor`. Must be one of the following types: `float32`,\n      `float64`, `uint8`, `int8`, `int16`, `int32`, `int64`.\n    boundaries: A list of `Tensor`s or `int`s or `float`s with strictly\n      increasing entries, and with all elements having the same type as `x`.\n    values: A list of `Tensor`s or `float`s or `int`s that specifies the values\n      for the intervals defined by `boundaries`. It should have one more element\n      than `boundaries`, and all elements should have the same type.\n    name: A string. Optional name of the operation. Defaults to\n      'PiecewiseConstant'.\n\n  Returns:\n    A 0-D Tensor. Its value is `values[0]` when `x <= boundaries[0]`,\n    `values[1]` when `x > boundaries[0]` and `x <= boundaries[1]`, ...,\n    and values[-1] when `x > boundaries[-1]`.\n\n  Raises:\n    ValueError: if types of `x` and `boundaries` do not match, or types of all\n        `values` do not match or\n        the number of elements in the lists does not match.\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    boundaries = nest.map_structure(tensor_conversion.convert_to_tensor_v2_with_dispatch, nest.flatten(boundaries))
    values = nest.map_structure(tensor_conversion.convert_to_tensor_v2_with_dispatch, nest.flatten(values))
    x_recomp = tensor_conversion.convert_to_tensor_v2_with_dispatch(x)
    for (i, b) in enumerate(boundaries):
        if b.dtype.base_dtype != x_recomp.dtype.base_dtype:
            if b.dtype.base_dtype == dtypes.int32 and x_recomp.dtype.base_dtype == dtypes.int64:
                b = math_ops.cast(b, x_recomp.dtype.base_dtype)
                boundaries[i] = b
            else:
                raise ValueError('Boundaries (%s) must have the same dtype as x (%s).' % (b.dtype.base_dtype, x_recomp.dtype.base_dtype))
    for v in values[1:]:
        if v.dtype.base_dtype != values[0].dtype.base_dtype:
            raise ValueError('Values must have elements all with the same dtype (%s vs %s).' % (values[0].dtype.base_dtype, v.dtype.base_dtype))
    decayed_lr = learning_rate_schedule.PiecewiseConstantDecay(boundaries, values, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(x)
    else:
        decayed_lr = functools.partial(decayed_lr, x)
    return decayed_lr

@tf_export(v1=['train.polynomial_decay'])
def polynomial_decay(learning_rate, global_step, decay_steps, end_learning_rate=0.0001, power=1.0, cycle=False, name=None):
    if False:
        for i in range(10):
            print('nop')
    "Applies a polynomial decay to the learning rate.\n\n  It is commonly observed that a monotonically decreasing learning rate, whose\n  degree of change is carefully chosen, results in a better performing model.\n  This function applies a polynomial decay function to a provided initial\n  `learning_rate` to reach an `end_learning_rate` in the given `decay_steps`.\n\n  It requires a `global_step` value to compute the decayed learning rate.  You\n  can just pass a TensorFlow variable that you increment at each training step.\n\n  The function returns the decayed learning rate.  It is computed as:\n\n  ```python\n  global_step = min(global_step, decay_steps)\n  decayed_learning_rate = (learning_rate - end_learning_rate) *\n                          (1 - global_step / decay_steps) ^ (power) +\n                          end_learning_rate\n\n  ```\n\n  If `cycle` is True then a multiple of `decay_steps` is used, the first one\n  that is bigger than `global_steps`.\n\n  ```python\n  decay_steps = decay_steps * ceil(global_step / decay_steps)\n  decayed_learning_rate = (learning_rate - end_learning_rate) *\n                          (1 - global_step / decay_steps) ^ (power) +\n                          end_learning_rate\n\n  ```\n\n  Example: decay from 0.1 to 0.01 in 10000 steps using sqrt (i.e. power=0.5):\n\n  ```python\n  ...\n  global_step = tf.Variable(0, trainable=False)\n  starter_learning_rate = 0.1\n  end_learning_rate = 0.01\n  decay_steps = 10000\n  learning_rate = tf.compat.v1.train.polynomial_decay(starter_learning_rate,\n  global_step,\n                                            decay_steps, end_learning_rate,\n                                            power=0.5)\n  # Passing global_step to minimize() will increment it at each step.\n  learning_step = (\n      tf.compat.v1.train.GradientDescentOptimizer(learning_rate)\n      .minimize(...my loss..., global_step=global_step)\n  )\n  ```\n\n  Args:\n    learning_rate: A scalar `float32` or `float64` `Tensor` or a Python number.\n      The initial learning rate.\n    global_step: A scalar `int32` or `int64` `Tensor` or a Python number. Global\n      step to use for the decay computation.  Must not be negative.\n    decay_steps: A scalar `int32` or `int64` `Tensor` or a Python number. Must\n      be positive.  See the decay computation above.\n    end_learning_rate: A scalar `float32` or `float64` `Tensor` or a Python\n      number.  The minimal end learning rate.\n    power: A scalar `float32` or `float64` `Tensor` or a Python number.  The\n      power of the polynomial. Defaults to linear, 1.0.\n    cycle: A boolean, whether or not it should cycle beyond decay_steps.\n    name: String.  Optional name of the operation. Defaults to\n      'PolynomialDecay'.\n\n  Returns:\n    A scalar `Tensor` of the same type as `learning_rate`.  The decayed\n    learning rate.\n\n  Raises:\n    ValueError: if `global_step` is not supplied.\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    decayed_lr = learning_rate_schedule.PolynomialDecay(learning_rate, decay_steps, end_learning_rate=end_learning_rate, power=power, cycle=cycle, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(global_step)
    else:
        decayed_lr = functools.partial(decayed_lr, global_step)
    return decayed_lr

@tf_export(v1=['train.natural_exp_decay'])
def natural_exp_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None):
    if False:
        for i in range(10):
            print('nop')
    "Applies natural exponential decay to the initial learning rate.\n\n  When training a model, it is often recommended to lower the learning rate as\n  the training progresses.  This function applies an exponential decay function\n  to a provided initial learning rate.  It requires an `global_step` value to\n  compute the decayed learning rate.  You can just pass a TensorFlow variable\n  that you increment at each training step.\n\n  The function returns the decayed learning rate.  It is computed as:\n\n  ```python\n  decayed_learning_rate = learning_rate * exp(-decay_rate * global_step /\n  decay_step)\n  ```\n\n  or, if `staircase` is `True`, as:\n\n  ```python\n  decayed_learning_rate = learning_rate * exp(-decay_rate * floor(global_step /\n  decay_step))\n  ```\n\n  Example: decay exponentially with a base of 0.96:\n\n  ```python\n  ...\n  global_step = tf.Variable(0, trainable=False)\n  learning_rate = 0.1\n  decay_steps = 5\n  k = 0.5\n  learning_rate = tf.compat.v1.train.natural_exp_decay(learning_rate,\n  global_step,\n                                             decay_steps, k)\n\n  # Passing global_step to minimize() will increment it at each step.\n  learning_step = (\n      tf.compat.v1.train.GradientDescentOptimizer(learning_rate)\n      .minimize(...my loss..., global_step=global_step)\n  )\n  ```\n\n  Args:\n    learning_rate: A scalar `float32` or `float64` `Tensor` or a Python number.\n      The initial learning rate.\n    global_step: A Python number. Global step to use for the decay computation.\n      Must not be negative.\n    decay_steps: How often to apply decay.\n    decay_rate: A Python number.  The decay rate.\n    staircase: Whether to apply decay in a discrete staircase, as opposed to\n      continuous, fashion.\n    name: String.  Optional name of the operation.  Defaults to\n      'ExponentialTimeDecay'.\n\n  Returns:\n    A scalar `Tensor` of the same type as `learning_rate`.  The decayed\n    learning rate.\n\n  Raises:\n    ValueError: if `global_step` is not supplied.\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    natural_exp_rate = math_ops.exp(math_ops.negative(decay_rate))
    decayed_lr = learning_rate_schedule.ExponentialDecay(learning_rate, decay_steps, natural_exp_rate, staircase=staircase, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(global_step)
    else:
        decayed_lr = functools.partial(decayed_lr, global_step)
    return decayed_lr

@tf_export(v1=['train.inverse_time_decay'])
def inverse_time_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None):
    if False:
        while True:
            i = 10
    "Applies inverse time decay to the initial learning rate.\n\n  When training a model, it is often recommended to lower the learning rate as\n  the training progresses.  This function applies an inverse decay function\n  to a provided initial learning rate.  It requires an `global_step` value to\n  compute the decayed learning rate.  You can just pass a TensorFlow variable\n  that you increment at each training step.\n\n  The function returns the decayed learning rate.  It is computed as:\n\n  ```python\n  decayed_learning_rate = learning_rate / (1 + decay_rate * global_step /\n  decay_step)\n  ```\n\n  or, if `staircase` is `True`, as:\n\n  ```python\n  decayed_learning_rate = learning_rate / (1 + decay_rate * floor(global_step /\n  decay_step))\n  ```\n\n  Example: decay 1/t with a rate of 0.5:\n\n  ```python\n  ...\n  global_step = tf.Variable(0, trainable=False)\n  learning_rate = 0.1\n  decay_steps = 1.0\n  decay_rate = 0.5\n  learning_rate = tf.compat.v1.train.inverse_time_decay(learning_rate,\n  global_step,\n  decay_steps, decay_rate)\n\n  # Passing global_step to minimize() will increment it at each step.\n  learning_step = (\n      tf.compat.v1.train.GradientDescentOptimizer(learning_rate)\n      .minimize(...my loss..., global_step=global_step)\n  )\n  ```\n\n  Args:\n    learning_rate: A scalar `float32` or `float64` `Tensor` or a Python number.\n      The initial learning rate.\n    global_step: A Python number. Global step to use for the decay computation.\n      Must not be negative.\n    decay_steps: How often to apply decay.\n    decay_rate: A Python number.  The decay rate.\n    staircase: Whether to apply decay in a discrete staircase, as opposed to\n      continuous, fashion.\n    name: String.  Optional name of the operation.  Defaults to\n      'InverseTimeDecay'.\n\n  Returns:\n    A scalar `Tensor` of the same type as `learning_rate`.  The decayed\n    learning rate.\n\n  Raises:\n    ValueError: if `global_step` is not supplied.\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    decayed_lr = learning_rate_schedule.InverseTimeDecay(learning_rate, decay_steps, decay_rate, staircase=staircase, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(global_step)
    else:
        decayed_lr = functools.partial(decayed_lr, global_step)
    return decayed_lr

@tf_export(v1=['train.cosine_decay'])
def cosine_decay(learning_rate, global_step, decay_steps, alpha=0.0, name=None):
    if False:
        i = 10
        return i + 15
    "Applies cosine decay to the learning rate.\n\n  When training a model, it is often recommended to lower the learning rate as\n  the training progresses.  This function applies a cosine decay function\n  to a provided initial learning rate.  It requires a `global_step` value to\n  compute the decayed learning rate.  You can just pass a TensorFlow variable\n  that you increment at each training step.\n\n  The function returns the decayed learning rate.  It is computed as:\n  ```python\n  global_step = min(global_step, decay_steps)\n  cosine_decay = 0.5 * (1 + cos(pi * global_step / decay_steps))\n  decayed = (1 - alpha) * cosine_decay + alpha\n  decayed_learning_rate = learning_rate * decayed\n  ```\n\n  Example usage:\n  ```python\n  decay_steps = 1000\n  lr_decayed = cosine_decay(learning_rate, global_step, decay_steps)\n  ```\n\n  Args:\n    learning_rate: A scalar `float32` or `float64` Tensor or a Python number.\n      The initial learning rate.\n    global_step: A scalar `int32` or `int64` `Tensor` or a Python number. Global\n      step to use for the decay computation.\n    decay_steps: A scalar `int32` or `int64` `Tensor` or a Python number. Number\n      of steps to decay over.\n    alpha: A scalar `float32` or `float64` Tensor or a Python number. Minimum\n      learning rate value as a fraction of learning_rate.\n    name: String. Optional name of the operation.  Defaults to 'CosineDecay'.\n\n  Returns:\n    A scalar `Tensor` of the same type as `learning_rate`.  The decayed\n    learning rate.\n  Raises:\n    ValueError: if `global_step` is not supplied.\n\n  References:\n    Stochastic Gradient Descent with Warm Restarts:\n      [Loshchilov et al., 2017]\n      (https://openreview.net/forum?id=Skq89Scxx&noteId=Skq89Scxx)\n      ([pdf](https://openreview.net/pdf?id=Skq89Scxx))\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    decayed_lr = learning_rate_schedule.CosineDecay(learning_rate, decay_steps, alpha=alpha, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(global_step)
    else:
        decayed_lr = functools.partial(decayed_lr, global_step)
    return decayed_lr

@tf_export(v1=['train.cosine_decay_restarts'])
def cosine_decay_restarts(learning_rate, global_step, first_decay_steps, t_mul=2.0, m_mul=1.0, alpha=0.0, name=None):
    if False:
        while True:
            i = 10
    "Applies cosine decay with restarts to the learning rate.\n\n  When training a model, it is often recommended to lower the learning rate as\n  the training progresses.  This function applies a cosine decay function with\n  restarts to a provided initial learning rate.  It requires a `global_step`\n  value to compute the decayed learning rate.  You can just pass a TensorFlow\n  variable that you increment at each training step.\n\n  The function returns the decayed learning rate while taking into account\n  possible warm restarts. The learning rate multiplier first decays\n  from 1 to `alpha` for `first_decay_steps` steps. Then, a warm\n  restart is performed. Each new warm restart runs for `t_mul` times more steps\n  and with `m_mul` times smaller initial learning rate.\n\n  Example usage:\n  ```python\n  first_decay_steps = 1000\n  lr_decayed = cosine_decay_restarts(learning_rate, global_step,\n                                     first_decay_steps)\n  ```\n\n  Args:\n    learning_rate: A scalar `float32` or `float64` Tensor or a Python number.\n      The initial learning rate.\n    global_step: A scalar `int32` or `int64` `Tensor` or a Python number. Global\n      step to use for the decay computation.\n    first_decay_steps: A scalar `int32` or `int64` `Tensor` or a Python number.\n      Number of steps to decay over.\n    t_mul: A scalar `float32` or `float64` `Tensor` or a Python number. Used to\n      derive the number of iterations in the i-th period\n    m_mul: A scalar `float32` or `float64` `Tensor` or a Python number.\n      Used to derive the initial learning rate of the i-th period:\n    alpha: A scalar `float32` or `float64` Tensor or a Python number. Minimum\n      learning rate value as a fraction of the learning_rate.\n    name: String. Optional name of the operation.  Defaults to 'SGDRDecay'.\n\n  Returns:\n    A scalar `Tensor` of the same type as `learning_rate`.  The decayed\n    learning rate.\n  Raises:\n    ValueError: if `global_step` is not supplied.\n\n  References:\n    Stochastic Gradient Descent with Warm Restarts:\n      [Loshchilov et al., 2017]\n      (https://openreview.net/forum?id=Skq89Scxx&noteId=Skq89Scxx)\n      ([pdf](https://openreview.net/pdf?id=Skq89Scxx))\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    decayed_lr = learning_rate_schedule.CosineDecayRestarts(learning_rate, first_decay_steps, t_mul=t_mul, m_mul=m_mul, alpha=alpha, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(global_step)
    else:
        decayed_lr = functools.partial(decayed_lr, global_step)
    return decayed_lr

@tf_export(v1=['train.linear_cosine_decay'])
def linear_cosine_decay(learning_rate, global_step, decay_steps, num_periods=0.5, alpha=0.0, beta=0.001, name=None):
    if False:
        print('Hello World!')
    "Applies linear cosine decay to the learning rate.\n\n  Note that linear cosine decay is more aggressive than cosine decay and\n  larger initial learning rates can typically be used.\n\n  When training a model, it is often recommended to lower the learning rate as\n  the training progresses.  This function applies a linear cosine decay function\n  to a provided initial learning rate.  It requires a `global_step` value to\n  compute the decayed learning rate.  You can just pass a TensorFlow variable\n  that you increment at each training step.\n\n  The function returns the decayed learning rate.  It is computed as:\n  ```python\n  global_step = min(global_step, decay_steps)\n  linear_decay = (decay_steps - global_step) / decay_steps)\n  cosine_decay = 0.5 * (\n      1 + cos(pi * 2 * num_periods * global_step / decay_steps))\n  decayed = (alpha + linear_decay) * cosine_decay + beta\n  decayed_learning_rate = learning_rate * decayed\n  ```\n\n  Example usage:\n  ```python\n  decay_steps = 1000\n  lr_decayed = linear_cosine_decay(learning_rate, global_step, decay_steps)\n  ```\n\n  Args:\n    learning_rate: A scalar `float32` or `float64` Tensor or a Python number.\n      The initial learning rate.\n    global_step: A scalar `int32` or `int64` `Tensor` or a Python number. Global\n      step to use for the decay computation.\n    decay_steps: A scalar `int32` or `int64` `Tensor` or a Python number. Number\n      of steps to decay over.\n    num_periods: Number of periods in the cosine part of the decay. See\n      computation above.\n    alpha: See computation above.\n    beta: See computation above.\n    name: String.  Optional name of the operation.  Defaults to\n      'LinearCosineDecay'.\n\n  Returns:\n    A scalar `Tensor` of the same type as `learning_rate`.  The decayed\n    learning rate.\n  Raises:\n    ValueError: if `global_step` is not supplied.\n\n  References:\n    Neural Optimizer Search with Reinforcement Learning:\n      [Bello et al., 2017](http://proceedings.mlr.press/v70/bello17a.html)\n      ([pdf](http://proceedings.mlr.press/v70/bello17a/bello17a.pdf))\n    Stochastic Gradient Descent with Warm Restarts:\n      [Loshchilov et al., 2017]\n      (https://openreview.net/forum?id=Skq89Scxx&noteId=Skq89Scxx)\n      ([pdf](https://openreview.net/pdf?id=Skq89Scxx))\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    decayed_lr = learning_rate_schedule.LinearCosineDecay(learning_rate, decay_steps, num_periods=num_periods, alpha=alpha, beta=beta, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(global_step)
    else:
        decayed_lr = functools.partial(decayed_lr, global_step)
    return decayed_lr

@tf_export(v1=['train.noisy_linear_cosine_decay'])
def noisy_linear_cosine_decay(learning_rate, global_step, decay_steps, initial_variance=1.0, variance_decay=0.55, num_periods=0.5, alpha=0.0, beta=0.001, name=None):
    if False:
        i = 10
        return i + 15
    "Applies noisy linear cosine decay to the learning rate.\n\n  Note that linear cosine decay is more aggressive than cosine decay and\n  larger initial learning rates can typically be used.\n\n  When training a model, it is often recommended to lower the learning rate as\n  the training progresses.  This function applies a noisy linear\n  cosine decay function to a provided initial learning rate.\n  It requires a `global_step` value to compute the decayed learning rate.\n  You can just pass a TensorFlow variable that you increment at each\n  training step.\n\n  The function returns the decayed learning rate.  It is computed as:\n  ```python\n  global_step = min(global_step, decay_steps)\n  linear_decay = (decay_steps - global_step) / decay_steps)\n  cosine_decay = 0.5 * (\n      1 + cos(pi * 2 * num_periods * global_step / decay_steps))\n  decayed = (alpha + linear_decay + eps_t) * cosine_decay + beta\n  decayed_learning_rate = learning_rate * decayed\n  ```\n  where eps_t is 0-centered gaussian noise with variance\n  initial_variance / (1 + global_step) ** variance_decay\n\n  Example usage:\n  ```python\n  decay_steps = 1000\n  lr_decayed = noisy_linear_cosine_decay(\n    learning_rate, global_step, decay_steps)\n  ```\n\n  Args:\n    learning_rate: A scalar `float32` or `float64` Tensor or a Python number.\n      The initial learning rate.\n    global_step: A scalar `int32` or `int64` `Tensor` or a Python number. Global\n      step to use for the decay computation.\n    decay_steps: A scalar `int32` or `int64` `Tensor` or a Python number. Number\n      of steps to decay over.\n    initial_variance: initial variance for the noise. See computation above.\n    variance_decay: decay for the noise's variance. See computation above.\n    num_periods: Number of periods in the cosine part of the decay. See\n      computation above.\n    alpha: See computation above.\n    beta: See computation above.\n    name: String.  Optional name of the operation.  Defaults to\n      'NoisyLinearCosineDecay'.\n\n  Returns:\n    A scalar `Tensor` of the same type as `learning_rate`.  The decayed\n    learning rate.\n  Raises:\n    ValueError: if `global_step` is not supplied.\n\n  References:\n    Neural Optimizer Search with Reinforcement Learning:\n      [Bello et al., 2017](http://proceedings.mlr.press/v70/bello17a.html)\n      ([pdf](http://proceedings.mlr.press/v70/bello17a/bello17a.pdf))\n    Stochastic Gradient Descent with Warm Restarts:\n      [Loshchilov et al., 2017]\n      (https://openreview.net/forum?id=Skq89Scxx&noteId=Skq89Scxx)\n      ([pdf](https://openreview.net/pdf?id=Skq89Scxx))\n\n  @compatibility(eager)\n  When eager execution is enabled, this function returns a function which in\n  turn returns the decayed learning rate Tensor. This can be useful for changing\n  the learning rate value across different invocations of optimizer functions.\n  @end_compatibility\n  "
    decayed_lr = learning_rate_schedule.NoisyLinearCosineDecay(learning_rate, decay_steps, initial_variance=initial_variance, variance_decay=variance_decay, num_periods=num_periods, alpha=alpha, beta=beta, name=name)
    if not context.executing_eagerly():
        decayed_lr = decayed_lr(global_step)
    else:
        decayed_lr = functools.partial(decayed_lr, global_step)
    return decayed_lr