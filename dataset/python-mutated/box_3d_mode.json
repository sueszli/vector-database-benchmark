[
    {
        "func_name": "convert",
        "original": "@staticmethod\ndef convert(box, src, dst, rt_mat=None, with_yaw=True):\n    \"\"\"Convert boxes from `src` mode to `dst` mode.\n\n        Args:\n            box (tuple | list | np.ndarray |\n                torch.Tensor | :obj:`BaseInstance3DBoxes`):\n                Can be a k-tuple, k-list or an Nxk array/tensor, where k = 7.\n            src (:obj:`Box3DMode`): The src Box mode.\n            dst (:obj:`Box3DMode`): The target Box mode.\n            rt_mat (np.ndarray | torch.Tensor, optional): The rotation and\n                translation matrix between different coordinates.\n                Defaults to None.\n                The conversion from `src` coordinates to `dst` coordinates\n                usually comes along the change of sensors, e.g., from camera\n                to LiDAR. This requires a transformation matrix.\n            with_yaw (bool, optional): If `box` is an instance of\n                :obj:`BaseInstance3DBoxes`, whether or not it has a yaw angle.\n                Defaults to True.\n\n        Returns:\n            (tuple | list | np.ndarray | torch.Tensor |\n                :obj:`BaseInstance3DBoxes`):\n                The converted box of the same type.\n        \"\"\"\n    if src == dst:\n        return box\n    is_numpy = isinstance(box, np.ndarray)\n    is_Instance3DBoxes = isinstance(box, BaseInstance3DBoxes)\n    single_box = isinstance(box, (list, tuple))\n    if single_box:\n        assert len(box) >= 7, 'Box3DMode.convert takes either a k-tuple/list or an Nxk array/tensor, where k >= 7'\n        arr = torch.tensor(box)[None, :]\n    elif is_numpy:\n        arr = torch.from_numpy(np.asarray(box)).clone()\n    elif is_Instance3DBoxes:\n        arr = box.tensor.clone()\n    else:\n        arr = box.clone()\n    if is_Instance3DBoxes:\n        with_yaw = box.with_yaw\n    (x_size, y_size, z_size) = (arr[..., 3:4], arr[..., 4:5], arr[..., 5:6])\n    if with_yaw:\n        yaw = arr[..., 6:7]\n    if src == Box3DMode.LIDAR and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [0, 0, -1], [1, 0, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.CAM and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 0, 1], [-1, 0, 0], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, -1], [0, 1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.CAM and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, 1], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.LIDAR and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw + np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    else:\n        raise NotImplementedError(f'Conversion from Box3DMode {src} to {dst} is not supported yet')\n    if not isinstance(rt_mat, torch.Tensor):\n        rt_mat = arr.new_tensor(rt_mat)\n    if rt_mat.size(1) == 4:\n        extended_xyz = torch.cat([arr[..., :3], arr.new_ones(arr.size(0), 1)], dim=-1)\n        xyz = extended_xyz @ rt_mat.t()\n    else:\n        xyz = arr[..., :3] @ rt_mat.t()\n    if with_yaw:\n        remains = arr[..., 7:]\n        arr = torch.cat([xyz[..., :3], xyz_size, yaw, remains], dim=-1)\n    else:\n        remains = arr[..., 6:]\n        arr = torch.cat([xyz[..., :3], xyz_size, remains], dim=-1)\n    original_type = type(box)\n    if single_box:\n        return original_type(arr.flatten().tolist())\n    if is_numpy:\n        return arr.numpy()\n    elif is_Instance3DBoxes:\n        if dst == Box3DMode.CAM:\n            target_type = CameraInstance3DBoxes\n        elif dst == Box3DMode.LIDAR:\n            target_type = LiDARInstance3DBoxes\n        elif dst == Box3DMode.DEPTH:\n            target_type = DepthInstance3DBoxes\n        else:\n            raise NotImplementedError(f'Conversion to {dst} through {original_type} is not supported yet')\n        return target_type(arr, box_dim=arr.size(-1), with_yaw=with_yaw)\n    else:\n        return arr",
        "mutated": [
            "@staticmethod\ndef convert(box, src, dst, rt_mat=None, with_yaw=True):\n    if False:\n        i = 10\n    'Convert boxes from `src` mode to `dst` mode.\\n\\n        Args:\\n            box (tuple | list | np.ndarray |\\n                torch.Tensor | :obj:`BaseInstance3DBoxes`):\\n                Can be a k-tuple, k-list or an Nxk array/tensor, where k = 7.\\n            src (:obj:`Box3DMode`): The src Box mode.\\n            dst (:obj:`Box3DMode`): The target Box mode.\\n            rt_mat (np.ndarray | torch.Tensor, optional): The rotation and\\n                translation matrix between different coordinates.\\n                Defaults to None.\\n                The conversion from `src` coordinates to `dst` coordinates\\n                usually comes along the change of sensors, e.g., from camera\\n                to LiDAR. This requires a transformation matrix.\\n            with_yaw (bool, optional): If `box` is an instance of\\n                :obj:`BaseInstance3DBoxes`, whether or not it has a yaw angle.\\n                Defaults to True.\\n\\n        Returns:\\n            (tuple | list | np.ndarray | torch.Tensor |\\n                :obj:`BaseInstance3DBoxes`):\\n                The converted box of the same type.\\n        '\n    if src == dst:\n        return box\n    is_numpy = isinstance(box, np.ndarray)\n    is_Instance3DBoxes = isinstance(box, BaseInstance3DBoxes)\n    single_box = isinstance(box, (list, tuple))\n    if single_box:\n        assert len(box) >= 7, 'Box3DMode.convert takes either a k-tuple/list or an Nxk array/tensor, where k >= 7'\n        arr = torch.tensor(box)[None, :]\n    elif is_numpy:\n        arr = torch.from_numpy(np.asarray(box)).clone()\n    elif is_Instance3DBoxes:\n        arr = box.tensor.clone()\n    else:\n        arr = box.clone()\n    if is_Instance3DBoxes:\n        with_yaw = box.with_yaw\n    (x_size, y_size, z_size) = (arr[..., 3:4], arr[..., 4:5], arr[..., 5:6])\n    if with_yaw:\n        yaw = arr[..., 6:7]\n    if src == Box3DMode.LIDAR and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [0, 0, -1], [1, 0, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.CAM and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 0, 1], [-1, 0, 0], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, -1], [0, 1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.CAM and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, 1], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.LIDAR and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw + np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    else:\n        raise NotImplementedError(f'Conversion from Box3DMode {src} to {dst} is not supported yet')\n    if not isinstance(rt_mat, torch.Tensor):\n        rt_mat = arr.new_tensor(rt_mat)\n    if rt_mat.size(1) == 4:\n        extended_xyz = torch.cat([arr[..., :3], arr.new_ones(arr.size(0), 1)], dim=-1)\n        xyz = extended_xyz @ rt_mat.t()\n    else:\n        xyz = arr[..., :3] @ rt_mat.t()\n    if with_yaw:\n        remains = arr[..., 7:]\n        arr = torch.cat([xyz[..., :3], xyz_size, yaw, remains], dim=-1)\n    else:\n        remains = arr[..., 6:]\n        arr = torch.cat([xyz[..., :3], xyz_size, remains], dim=-1)\n    original_type = type(box)\n    if single_box:\n        return original_type(arr.flatten().tolist())\n    if is_numpy:\n        return arr.numpy()\n    elif is_Instance3DBoxes:\n        if dst == Box3DMode.CAM:\n            target_type = CameraInstance3DBoxes\n        elif dst == Box3DMode.LIDAR:\n            target_type = LiDARInstance3DBoxes\n        elif dst == Box3DMode.DEPTH:\n            target_type = DepthInstance3DBoxes\n        else:\n            raise NotImplementedError(f'Conversion to {dst} through {original_type} is not supported yet')\n        return target_type(arr, box_dim=arr.size(-1), with_yaw=with_yaw)\n    else:\n        return arr",
            "@staticmethod\ndef convert(box, src, dst, rt_mat=None, with_yaw=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert boxes from `src` mode to `dst` mode.\\n\\n        Args:\\n            box (tuple | list | np.ndarray |\\n                torch.Tensor | :obj:`BaseInstance3DBoxes`):\\n                Can be a k-tuple, k-list or an Nxk array/tensor, where k = 7.\\n            src (:obj:`Box3DMode`): The src Box mode.\\n            dst (:obj:`Box3DMode`): The target Box mode.\\n            rt_mat (np.ndarray | torch.Tensor, optional): The rotation and\\n                translation matrix between different coordinates.\\n                Defaults to None.\\n                The conversion from `src` coordinates to `dst` coordinates\\n                usually comes along the change of sensors, e.g., from camera\\n                to LiDAR. This requires a transformation matrix.\\n            with_yaw (bool, optional): If `box` is an instance of\\n                :obj:`BaseInstance3DBoxes`, whether or not it has a yaw angle.\\n                Defaults to True.\\n\\n        Returns:\\n            (tuple | list | np.ndarray | torch.Tensor |\\n                :obj:`BaseInstance3DBoxes`):\\n                The converted box of the same type.\\n        '\n    if src == dst:\n        return box\n    is_numpy = isinstance(box, np.ndarray)\n    is_Instance3DBoxes = isinstance(box, BaseInstance3DBoxes)\n    single_box = isinstance(box, (list, tuple))\n    if single_box:\n        assert len(box) >= 7, 'Box3DMode.convert takes either a k-tuple/list or an Nxk array/tensor, where k >= 7'\n        arr = torch.tensor(box)[None, :]\n    elif is_numpy:\n        arr = torch.from_numpy(np.asarray(box)).clone()\n    elif is_Instance3DBoxes:\n        arr = box.tensor.clone()\n    else:\n        arr = box.clone()\n    if is_Instance3DBoxes:\n        with_yaw = box.with_yaw\n    (x_size, y_size, z_size) = (arr[..., 3:4], arr[..., 4:5], arr[..., 5:6])\n    if with_yaw:\n        yaw = arr[..., 6:7]\n    if src == Box3DMode.LIDAR and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [0, 0, -1], [1, 0, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.CAM and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 0, 1], [-1, 0, 0], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, -1], [0, 1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.CAM and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, 1], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.LIDAR and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw + np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    else:\n        raise NotImplementedError(f'Conversion from Box3DMode {src} to {dst} is not supported yet')\n    if not isinstance(rt_mat, torch.Tensor):\n        rt_mat = arr.new_tensor(rt_mat)\n    if rt_mat.size(1) == 4:\n        extended_xyz = torch.cat([arr[..., :3], arr.new_ones(arr.size(0), 1)], dim=-1)\n        xyz = extended_xyz @ rt_mat.t()\n    else:\n        xyz = arr[..., :3] @ rt_mat.t()\n    if with_yaw:\n        remains = arr[..., 7:]\n        arr = torch.cat([xyz[..., :3], xyz_size, yaw, remains], dim=-1)\n    else:\n        remains = arr[..., 6:]\n        arr = torch.cat([xyz[..., :3], xyz_size, remains], dim=-1)\n    original_type = type(box)\n    if single_box:\n        return original_type(arr.flatten().tolist())\n    if is_numpy:\n        return arr.numpy()\n    elif is_Instance3DBoxes:\n        if dst == Box3DMode.CAM:\n            target_type = CameraInstance3DBoxes\n        elif dst == Box3DMode.LIDAR:\n            target_type = LiDARInstance3DBoxes\n        elif dst == Box3DMode.DEPTH:\n            target_type = DepthInstance3DBoxes\n        else:\n            raise NotImplementedError(f'Conversion to {dst} through {original_type} is not supported yet')\n        return target_type(arr, box_dim=arr.size(-1), with_yaw=with_yaw)\n    else:\n        return arr",
            "@staticmethod\ndef convert(box, src, dst, rt_mat=None, with_yaw=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert boxes from `src` mode to `dst` mode.\\n\\n        Args:\\n            box (tuple | list | np.ndarray |\\n                torch.Tensor | :obj:`BaseInstance3DBoxes`):\\n                Can be a k-tuple, k-list or an Nxk array/tensor, where k = 7.\\n            src (:obj:`Box3DMode`): The src Box mode.\\n            dst (:obj:`Box3DMode`): The target Box mode.\\n            rt_mat (np.ndarray | torch.Tensor, optional): The rotation and\\n                translation matrix between different coordinates.\\n                Defaults to None.\\n                The conversion from `src` coordinates to `dst` coordinates\\n                usually comes along the change of sensors, e.g., from camera\\n                to LiDAR. This requires a transformation matrix.\\n            with_yaw (bool, optional): If `box` is an instance of\\n                :obj:`BaseInstance3DBoxes`, whether or not it has a yaw angle.\\n                Defaults to True.\\n\\n        Returns:\\n            (tuple | list | np.ndarray | torch.Tensor |\\n                :obj:`BaseInstance3DBoxes`):\\n                The converted box of the same type.\\n        '\n    if src == dst:\n        return box\n    is_numpy = isinstance(box, np.ndarray)\n    is_Instance3DBoxes = isinstance(box, BaseInstance3DBoxes)\n    single_box = isinstance(box, (list, tuple))\n    if single_box:\n        assert len(box) >= 7, 'Box3DMode.convert takes either a k-tuple/list or an Nxk array/tensor, where k >= 7'\n        arr = torch.tensor(box)[None, :]\n    elif is_numpy:\n        arr = torch.from_numpy(np.asarray(box)).clone()\n    elif is_Instance3DBoxes:\n        arr = box.tensor.clone()\n    else:\n        arr = box.clone()\n    if is_Instance3DBoxes:\n        with_yaw = box.with_yaw\n    (x_size, y_size, z_size) = (arr[..., 3:4], arr[..., 4:5], arr[..., 5:6])\n    if with_yaw:\n        yaw = arr[..., 6:7]\n    if src == Box3DMode.LIDAR and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [0, 0, -1], [1, 0, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.CAM and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 0, 1], [-1, 0, 0], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, -1], [0, 1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.CAM and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, 1], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.LIDAR and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw + np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    else:\n        raise NotImplementedError(f'Conversion from Box3DMode {src} to {dst} is not supported yet')\n    if not isinstance(rt_mat, torch.Tensor):\n        rt_mat = arr.new_tensor(rt_mat)\n    if rt_mat.size(1) == 4:\n        extended_xyz = torch.cat([arr[..., :3], arr.new_ones(arr.size(0), 1)], dim=-1)\n        xyz = extended_xyz @ rt_mat.t()\n    else:\n        xyz = arr[..., :3] @ rt_mat.t()\n    if with_yaw:\n        remains = arr[..., 7:]\n        arr = torch.cat([xyz[..., :3], xyz_size, yaw, remains], dim=-1)\n    else:\n        remains = arr[..., 6:]\n        arr = torch.cat([xyz[..., :3], xyz_size, remains], dim=-1)\n    original_type = type(box)\n    if single_box:\n        return original_type(arr.flatten().tolist())\n    if is_numpy:\n        return arr.numpy()\n    elif is_Instance3DBoxes:\n        if dst == Box3DMode.CAM:\n            target_type = CameraInstance3DBoxes\n        elif dst == Box3DMode.LIDAR:\n            target_type = LiDARInstance3DBoxes\n        elif dst == Box3DMode.DEPTH:\n            target_type = DepthInstance3DBoxes\n        else:\n            raise NotImplementedError(f'Conversion to {dst} through {original_type} is not supported yet')\n        return target_type(arr, box_dim=arr.size(-1), with_yaw=with_yaw)\n    else:\n        return arr",
            "@staticmethod\ndef convert(box, src, dst, rt_mat=None, with_yaw=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert boxes from `src` mode to `dst` mode.\\n\\n        Args:\\n            box (tuple | list | np.ndarray |\\n                torch.Tensor | :obj:`BaseInstance3DBoxes`):\\n                Can be a k-tuple, k-list or an Nxk array/tensor, where k = 7.\\n            src (:obj:`Box3DMode`): The src Box mode.\\n            dst (:obj:`Box3DMode`): The target Box mode.\\n            rt_mat (np.ndarray | torch.Tensor, optional): The rotation and\\n                translation matrix between different coordinates.\\n                Defaults to None.\\n                The conversion from `src` coordinates to `dst` coordinates\\n                usually comes along the change of sensors, e.g., from camera\\n                to LiDAR. This requires a transformation matrix.\\n            with_yaw (bool, optional): If `box` is an instance of\\n                :obj:`BaseInstance3DBoxes`, whether or not it has a yaw angle.\\n                Defaults to True.\\n\\n        Returns:\\n            (tuple | list | np.ndarray | torch.Tensor |\\n                :obj:`BaseInstance3DBoxes`):\\n                The converted box of the same type.\\n        '\n    if src == dst:\n        return box\n    is_numpy = isinstance(box, np.ndarray)\n    is_Instance3DBoxes = isinstance(box, BaseInstance3DBoxes)\n    single_box = isinstance(box, (list, tuple))\n    if single_box:\n        assert len(box) >= 7, 'Box3DMode.convert takes either a k-tuple/list or an Nxk array/tensor, where k >= 7'\n        arr = torch.tensor(box)[None, :]\n    elif is_numpy:\n        arr = torch.from_numpy(np.asarray(box)).clone()\n    elif is_Instance3DBoxes:\n        arr = box.tensor.clone()\n    else:\n        arr = box.clone()\n    if is_Instance3DBoxes:\n        with_yaw = box.with_yaw\n    (x_size, y_size, z_size) = (arr[..., 3:4], arr[..., 4:5], arr[..., 5:6])\n    if with_yaw:\n        yaw = arr[..., 6:7]\n    if src == Box3DMode.LIDAR and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [0, 0, -1], [1, 0, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.CAM and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 0, 1], [-1, 0, 0], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, -1], [0, 1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.CAM and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, 1], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.LIDAR and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw + np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    else:\n        raise NotImplementedError(f'Conversion from Box3DMode {src} to {dst} is not supported yet')\n    if not isinstance(rt_mat, torch.Tensor):\n        rt_mat = arr.new_tensor(rt_mat)\n    if rt_mat.size(1) == 4:\n        extended_xyz = torch.cat([arr[..., :3], arr.new_ones(arr.size(0), 1)], dim=-1)\n        xyz = extended_xyz @ rt_mat.t()\n    else:\n        xyz = arr[..., :3] @ rt_mat.t()\n    if with_yaw:\n        remains = arr[..., 7:]\n        arr = torch.cat([xyz[..., :3], xyz_size, yaw, remains], dim=-1)\n    else:\n        remains = arr[..., 6:]\n        arr = torch.cat([xyz[..., :3], xyz_size, remains], dim=-1)\n    original_type = type(box)\n    if single_box:\n        return original_type(arr.flatten().tolist())\n    if is_numpy:\n        return arr.numpy()\n    elif is_Instance3DBoxes:\n        if dst == Box3DMode.CAM:\n            target_type = CameraInstance3DBoxes\n        elif dst == Box3DMode.LIDAR:\n            target_type = LiDARInstance3DBoxes\n        elif dst == Box3DMode.DEPTH:\n            target_type = DepthInstance3DBoxes\n        else:\n            raise NotImplementedError(f'Conversion to {dst} through {original_type} is not supported yet')\n        return target_type(arr, box_dim=arr.size(-1), with_yaw=with_yaw)\n    else:\n        return arr",
            "@staticmethod\ndef convert(box, src, dst, rt_mat=None, with_yaw=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert boxes from `src` mode to `dst` mode.\\n\\n        Args:\\n            box (tuple | list | np.ndarray |\\n                torch.Tensor | :obj:`BaseInstance3DBoxes`):\\n                Can be a k-tuple, k-list or an Nxk array/tensor, where k = 7.\\n            src (:obj:`Box3DMode`): The src Box mode.\\n            dst (:obj:`Box3DMode`): The target Box mode.\\n            rt_mat (np.ndarray | torch.Tensor, optional): The rotation and\\n                translation matrix between different coordinates.\\n                Defaults to None.\\n                The conversion from `src` coordinates to `dst` coordinates\\n                usually comes along the change of sensors, e.g., from camera\\n                to LiDAR. This requires a transformation matrix.\\n            with_yaw (bool, optional): If `box` is an instance of\\n                :obj:`BaseInstance3DBoxes`, whether or not it has a yaw angle.\\n                Defaults to True.\\n\\n        Returns:\\n            (tuple | list | np.ndarray | torch.Tensor |\\n                :obj:`BaseInstance3DBoxes`):\\n                The converted box of the same type.\\n        '\n    if src == dst:\n        return box\n    is_numpy = isinstance(box, np.ndarray)\n    is_Instance3DBoxes = isinstance(box, BaseInstance3DBoxes)\n    single_box = isinstance(box, (list, tuple))\n    if single_box:\n        assert len(box) >= 7, 'Box3DMode.convert takes either a k-tuple/list or an Nxk array/tensor, where k >= 7'\n        arr = torch.tensor(box)[None, :]\n    elif is_numpy:\n        arr = torch.from_numpy(np.asarray(box)).clone()\n    elif is_Instance3DBoxes:\n        arr = box.tensor.clone()\n    else:\n        arr = box.clone()\n    if is_Instance3DBoxes:\n        with_yaw = box.with_yaw\n    (x_size, y_size, z_size) = (arr[..., 3:4], arr[..., 4:5], arr[..., 5:6])\n    if with_yaw:\n        yaw = arr[..., 6:7]\n    if src == Box3DMode.LIDAR and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [0, 0, -1], [1, 0, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.CAM and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 0, 1], [-1, 0, 0], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.CAM:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, -1], [0, 1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.CAM and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[1, 0, 0], [0, 0, 1], [0, -1, 0]])\n        xyz_size = torch.cat([x_size, z_size, y_size], dim=-1)\n        if with_yaw:\n            yaw = -yaw\n    elif src == Box3DMode.LIDAR and dst == Box3DMode.DEPTH:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, -1, 0], [1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw + np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    elif src == Box3DMode.DEPTH and dst == Box3DMode.LIDAR:\n        if rt_mat is None:\n            rt_mat = arr.new_tensor([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])\n        xyz_size = torch.cat([x_size, y_size, z_size], dim=-1)\n        if with_yaw:\n            yaw = yaw - np.pi / 2\n            yaw = limit_period(yaw, period=np.pi * 2)\n    else:\n        raise NotImplementedError(f'Conversion from Box3DMode {src} to {dst} is not supported yet')\n    if not isinstance(rt_mat, torch.Tensor):\n        rt_mat = arr.new_tensor(rt_mat)\n    if rt_mat.size(1) == 4:\n        extended_xyz = torch.cat([arr[..., :3], arr.new_ones(arr.size(0), 1)], dim=-1)\n        xyz = extended_xyz @ rt_mat.t()\n    else:\n        xyz = arr[..., :3] @ rt_mat.t()\n    if with_yaw:\n        remains = arr[..., 7:]\n        arr = torch.cat([xyz[..., :3], xyz_size, yaw, remains], dim=-1)\n    else:\n        remains = arr[..., 6:]\n        arr = torch.cat([xyz[..., :3], xyz_size, remains], dim=-1)\n    original_type = type(box)\n    if single_box:\n        return original_type(arr.flatten().tolist())\n    if is_numpy:\n        return arr.numpy()\n    elif is_Instance3DBoxes:\n        if dst == Box3DMode.CAM:\n            target_type = CameraInstance3DBoxes\n        elif dst == Box3DMode.LIDAR:\n            target_type = LiDARInstance3DBoxes\n        elif dst == Box3DMode.DEPTH:\n            target_type = DepthInstance3DBoxes\n        else:\n            raise NotImplementedError(f'Conversion to {dst} through {original_type} is not supported yet')\n        return target_type(arr, box_dim=arr.size(-1), with_yaw=with_yaw)\n    else:\n        return arr"
        ]
    }
]