[
    {
        "func_name": "get_measured_qubits",
        "original": "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits(transpiled_circuits: List[QuantumCircuit]) -> Tuple[List[int], Dict[str, List[int]]]:\n    \"\"\"\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\n\n    Args:\n        transpiled_circuits: a list of transpiled circuits\n\n    Returns:\n        The used and sorted qubit index\n        Key is qubit index str connected by '_',\n              value is the experiment index. {str: list[int]}\n    Raises:\n        QiskitError: invalid qubit mapping\n    \"\"\"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, qc) in enumerate(transpiled_circuits):\n        measured_qubits = []\n        for instruction in qc.data:\n            if instruction.operation.name != 'measure':\n                continue\n            for qreg in qc.qregs:\n                if instruction.qubits[0] in qreg:\n                    index = qreg[:].index(instruction.qubits[0])\n                    measured_qubits.append(index)\n                    break\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
        "mutated": [
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits(transpiled_circuits: List[QuantumCircuit]) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        transpiled_circuits: a list of transpiled circuits\\n\\n    Returns:\\n        The used and sorted qubit index\\n        Key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n    Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, qc) in enumerate(transpiled_circuits):\n        measured_qubits = []\n        for instruction in qc.data:\n            if instruction.operation.name != 'measure':\n                continue\n            for qreg in qc.qregs:\n                if instruction.qubits[0] in qreg:\n                    index = qreg[:].index(instruction.qubits[0])\n                    measured_qubits.append(index)\n                    break\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits(transpiled_circuits: List[QuantumCircuit]) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        transpiled_circuits: a list of transpiled circuits\\n\\n    Returns:\\n        The used and sorted qubit index\\n        Key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n    Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, qc) in enumerate(transpiled_circuits):\n        measured_qubits = []\n        for instruction in qc.data:\n            if instruction.operation.name != 'measure':\n                continue\n            for qreg in qc.qregs:\n                if instruction.qubits[0] in qreg:\n                    index = qreg[:].index(instruction.qubits[0])\n                    measured_qubits.append(index)\n                    break\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits(transpiled_circuits: List[QuantumCircuit]) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        transpiled_circuits: a list of transpiled circuits\\n\\n    Returns:\\n        The used and sorted qubit index\\n        Key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n    Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, qc) in enumerate(transpiled_circuits):\n        measured_qubits = []\n        for instruction in qc.data:\n            if instruction.operation.name != 'measure':\n                continue\n            for qreg in qc.qregs:\n                if instruction.qubits[0] in qreg:\n                    index = qreg[:].index(instruction.qubits[0])\n                    measured_qubits.append(index)\n                    break\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits(transpiled_circuits: List[QuantumCircuit]) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        transpiled_circuits: a list of transpiled circuits\\n\\n    Returns:\\n        The used and sorted qubit index\\n        Key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n    Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, qc) in enumerate(transpiled_circuits):\n        measured_qubits = []\n        for instruction in qc.data:\n            if instruction.operation.name != 'measure':\n                continue\n            for qreg in qc.qregs:\n                if instruction.qubits[0] in qreg:\n                    index = qreg[:].index(instruction.qubits[0])\n                    measured_qubits.append(index)\n                    break\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits(transpiled_circuits: List[QuantumCircuit]) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        transpiled_circuits: a list of transpiled circuits\\n\\n    Returns:\\n        The used and sorted qubit index\\n        Key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n    Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, qc) in enumerate(transpiled_circuits):\n        measured_qubits = []\n        for instruction in qc.data:\n            if instruction.operation.name != 'measure':\n                continue\n            for qreg in qc.qregs:\n                if instruction.qubits[0] in qreg:\n                    index = qreg[:].index(instruction.qubits[0])\n                    measured_qubits.append(index)\n                    break\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)"
        ]
    },
    {
        "func_name": "get_measured_qubits_from_qobj",
        "original": "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits_from_qobj(qobj: QasmQobj) -> Tuple[List[int], Dict[str, List[int]]]:\n    \"\"\"\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\n\n    Args:\n        qobj: qobj\n\n    Returns:\n        the used and sorted qubit index\n        key is qubit index str connected by '_',\n              value is the experiment index. {str: list[int]}\n     Raises:\n        QiskitError: invalid qubit mapping\n    \"\"\"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, exp) in enumerate(qobj.experiments):\n        measured_qubits = []\n        for instr in exp.instructions:\n            if instr.name != 'measure':\n                continue\n            measured_qubits.append(instr.qubits[0])\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
        "mutated": [
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits_from_qobj(qobj: QasmQobj) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        qobj: qobj\\n\\n    Returns:\\n        the used and sorted qubit index\\n        key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n     Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, exp) in enumerate(qobj.experiments):\n        measured_qubits = []\n        for instr in exp.instructions:\n            if instr.name != 'measure':\n                continue\n            measured_qubits.append(instr.qubits[0])\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits_from_qobj(qobj: QasmQobj) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        qobj: qobj\\n\\n    Returns:\\n        the used and sorted qubit index\\n        key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n     Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, exp) in enumerate(qobj.experiments):\n        measured_qubits = []\n        for instr in exp.instructions:\n            if instr.name != 'measure':\n                continue\n            measured_qubits.append(instr.qubits[0])\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits_from_qobj(qobj: QasmQobj) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        qobj: qobj\\n\\n    Returns:\\n        the used and sorted qubit index\\n        key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n     Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, exp) in enumerate(qobj.experiments):\n        measured_qubits = []\n        for instr in exp.instructions:\n            if instr.name != 'measure':\n                continue\n            measured_qubits.append(instr.qubits[0])\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits_from_qobj(qobj: QasmQobj) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        qobj: qobj\\n\\n    Returns:\\n        the used and sorted qubit index\\n        key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n     Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, exp) in enumerate(qobj.experiments):\n        measured_qubits = []\n        for instr in exp.instructions:\n            if instr.name != 'measure':\n                continue\n            measured_qubits.append(instr.qubits[0])\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef get_measured_qubits_from_qobj(qobj: QasmQobj) -> Tuple[List[int], Dict[str, List[int]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Deprecated: Retrieve the measured qubits from transpiled circuits.\\n\\n    Args:\\n        qobj: qobj\\n\\n    Returns:\\n        the used and sorted qubit index\\n        key is qubit index str connected by '_',\\n              value is the experiment index. {str: list[int]}\\n     Raises:\\n        QiskitError: invalid qubit mapping\\n    \"\n    qubit_index = None\n    qubit_mappings = {}\n    for (idx, exp) in enumerate(qobj.experiments):\n        measured_qubits = []\n        for instr in exp.instructions:\n            if instr.name != 'measure':\n                continue\n            measured_qubits.append(instr.qubits[0])\n        measured_qubits_str = '_'.join([str(x) for x in measured_qubits])\n        if measured_qubits_str not in qubit_mappings:\n            qubit_mappings[measured_qubits_str] = []\n        qubit_mappings[measured_qubits_str].append(idx)\n        if qubit_index is None:\n            qubit_index = measured_qubits\n        elif set(qubit_index) != set(measured_qubits):\n            raise QiskitError('The used qubit index are different. ({}) vs ({}).\\nCurrently, we only support all circuits using the same set of qubits regardless qubit order.'.format(qubit_index, measured_qubits))\n    return (sorted(qubit_index), qubit_mappings)"
        ]
    },
    {
        "func_name": "build_measurement_error_mitigation_circuits",
        "original": "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_circuits(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QuantumCircuit, List[str], List[str]]:\n    \"\"\"Deprecated: Build measurement error mitigation circuits\n    Args:\n        qubit_list: list of ordered qubits used in the algorithm\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\n        backend: backend instance\n        backend_config: configuration for backend\n        compile_config: configuration for compilation\n        mit_pattern: Qubits on which to perform the\n            measurement correction, divided to groups according to tensors.\n            If `None` and `qr` is given then assumed to be performed over the entire\n            `qr` as one group (default `None`).\n\n    Returns:\n        the circuit\n        the state labels for build MeasFitter\n        the labels of the calibration circuits\n    Raises:\n        QiskitError: when the fitter_cls is not recognizable.\n    \"\"\"\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    run = False\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        run = True\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        run = True\n    if not run:\n        try:\n            from qiskit.ignis.mitigation.measurement import CompleteMeasFitter as CompleteMeasFitter_IG, TensoredMeasFitter as TensoredMeasFitter_IG\n        except ImportError as ex:\n            raise QiskitError(f'Unknown fitter {fitter_cls}') from ex\n        if fitter_cls == CompleteMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        elif fitter_cls == TensoredMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        else:\n            raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    return (t_meas_calibs_circuits, state_labels, circlabel)",
        "mutated": [
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_circuits(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QuantumCircuit, List[str], List[str]]:\n    if False:\n        i = 10\n    'Deprecated: Build measurement error mitigation circuits\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the circuit\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    run = False\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        run = True\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        run = True\n    if not run:\n        try:\n            from qiskit.ignis.mitigation.measurement import CompleteMeasFitter as CompleteMeasFitter_IG, TensoredMeasFitter as TensoredMeasFitter_IG\n        except ImportError as ex:\n            raise QiskitError(f'Unknown fitter {fitter_cls}') from ex\n        if fitter_cls == CompleteMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        elif fitter_cls == TensoredMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        else:\n            raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    return (t_meas_calibs_circuits, state_labels, circlabel)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_circuits(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QuantumCircuit, List[str], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Deprecated: Build measurement error mitigation circuits\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the circuit\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    run = False\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        run = True\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        run = True\n    if not run:\n        try:\n            from qiskit.ignis.mitigation.measurement import CompleteMeasFitter as CompleteMeasFitter_IG, TensoredMeasFitter as TensoredMeasFitter_IG\n        except ImportError as ex:\n            raise QiskitError(f'Unknown fitter {fitter_cls}') from ex\n        if fitter_cls == CompleteMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        elif fitter_cls == TensoredMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        else:\n            raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    return (t_meas_calibs_circuits, state_labels, circlabel)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_circuits(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QuantumCircuit, List[str], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Deprecated: Build measurement error mitigation circuits\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the circuit\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    run = False\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        run = True\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        run = True\n    if not run:\n        try:\n            from qiskit.ignis.mitigation.measurement import CompleteMeasFitter as CompleteMeasFitter_IG, TensoredMeasFitter as TensoredMeasFitter_IG\n        except ImportError as ex:\n            raise QiskitError(f'Unknown fitter {fitter_cls}') from ex\n        if fitter_cls == CompleteMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        elif fitter_cls == TensoredMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        else:\n            raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    return (t_meas_calibs_circuits, state_labels, circlabel)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_circuits(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QuantumCircuit, List[str], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Deprecated: Build measurement error mitigation circuits\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the circuit\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    run = False\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        run = True\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        run = True\n    if not run:\n        try:\n            from qiskit.ignis.mitigation.measurement import CompleteMeasFitter as CompleteMeasFitter_IG, TensoredMeasFitter as TensoredMeasFitter_IG\n        except ImportError as ex:\n            raise QiskitError(f'Unknown fitter {fitter_cls}') from ex\n        if fitter_cls == CompleteMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        elif fitter_cls == TensoredMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        else:\n            raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    return (t_meas_calibs_circuits, state_labels, circlabel)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_circuits(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QuantumCircuit, List[str], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Deprecated: Build measurement error mitigation circuits\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the circuit\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    run = False\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        run = True\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        run = True\n    if not run:\n        try:\n            from qiskit.ignis.mitigation.measurement import CompleteMeasFitter as CompleteMeasFitter_IG, TensoredMeasFitter as TensoredMeasFitter_IG\n        except ImportError as ex:\n            raise QiskitError(f'Unknown fitter {fitter_cls}') from ex\n        if fitter_cls == CompleteMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n        elif fitter_cls == TensoredMeasFitter_IG:\n            (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n        else:\n            raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    return (t_meas_calibs_circuits, state_labels, circlabel)"
        ]
    },
    {
        "func_name": "build_measurement_error_mitigation_qobj",
        "original": "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_qobj(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, run_config: Optional[RunConfig]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QasmQobj, List[str], List[str]]:\n    \"\"\"\n    Args:\n        qubit_list: list of ordered qubits used in the algorithm\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\n        backend: backend instance\n        backend_config: configuration for backend\n        compile_config: configuration for compilation\n        run_config: configuration for running a circuit\n        mit_pattern: Qubits on which to perform the\n            measurement correction, divided to groups according to tensors.\n            If `None` and `qr` is given then assumed to be performed over the entire\n            `qr` as one group (default `None`).\n\n    Returns:\n        the Qobj with calibration circuits at the beginning\n        the state labels for build MeasFitter\n        the labels of the calibration circuits\n\n    Raises:\n        QiskitError: when the fitter_cls is not recognizable.\n        MissingOptionalLibraryError: Qiskit-Ignis not installed\n    \"\"\"\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n    else:\n        raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    cals_qobj = compiler.assemble(t_meas_calibs_circuits, backend, **run_config.to_dict())\n    if hasattr(cals_qobj.config, 'parameterizations'):\n        del cals_qobj.config.parameterizations\n    return (cals_qobj, state_labels, circlabel)",
        "mutated": [
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_qobj(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, run_config: Optional[RunConfig]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QasmQobj, List[str], List[str]]:\n    if False:\n        i = 10\n    '\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        run_config: configuration for running a circuit\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the Qobj with calibration circuits at the beginning\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n        MissingOptionalLibraryError: Qiskit-Ignis not installed\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n    else:\n        raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    cals_qobj = compiler.assemble(t_meas_calibs_circuits, backend, **run_config.to_dict())\n    if hasattr(cals_qobj.config, 'parameterizations'):\n        del cals_qobj.config.parameterizations\n    return (cals_qobj, state_labels, circlabel)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_qobj(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, run_config: Optional[RunConfig]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QasmQobj, List[str], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        run_config: configuration for running a circuit\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the Qobj with calibration circuits at the beginning\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n        MissingOptionalLibraryError: Qiskit-Ignis not installed\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n    else:\n        raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    cals_qobj = compiler.assemble(t_meas_calibs_circuits, backend, **run_config.to_dict())\n    if hasattr(cals_qobj.config, 'parameterizations'):\n        del cals_qobj.config.parameterizations\n    return (cals_qobj, state_labels, circlabel)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_qobj(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, run_config: Optional[RunConfig]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QasmQobj, List[str], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        run_config: configuration for running a circuit\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the Qobj with calibration circuits at the beginning\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n        MissingOptionalLibraryError: Qiskit-Ignis not installed\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n    else:\n        raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    cals_qobj = compiler.assemble(t_meas_calibs_circuits, backend, **run_config.to_dict())\n    if hasattr(cals_qobj.config, 'parameterizations'):\n        del cals_qobj.config.parameterizations\n    return (cals_qobj, state_labels, circlabel)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_qobj(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, run_config: Optional[RunConfig]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QasmQobj, List[str], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        run_config: configuration for running a circuit\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the Qobj with calibration circuits at the beginning\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n        MissingOptionalLibraryError: Qiskit-Ignis not installed\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n    else:\n        raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    cals_qobj = compiler.assemble(t_meas_calibs_circuits, backend, **run_config.to_dict())\n    if hasattr(cals_qobj.config, 'parameterizations'):\n        del cals_qobj.config.parameterizations\n    return (cals_qobj, state_labels, circlabel)",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/qi_migration.')\ndef build_measurement_error_mitigation_qobj(qubit_list: List[int], fitter_cls: Callable, backend: Backend, backend_config: Optional[Dict]=None, compile_config: Optional[Dict]=None, run_config: Optional[RunConfig]=None, mit_pattern: Optional[List[List[int]]]=None) -> Tuple[QasmQobj, List[str], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Args:\\n        qubit_list: list of ordered qubits used in the algorithm\\n        fitter_cls: CompleteMeasFitter or TensoredMeasFitter\\n        backend: backend instance\\n        backend_config: configuration for backend\\n        compile_config: configuration for compilation\\n        run_config: configuration for running a circuit\\n        mit_pattern: Qubits on which to perform the\\n            measurement correction, divided to groups according to tensors.\\n            If `None` and `qr` is given then assumed to be performed over the entire\\n            `qr` as one group (default `None`).\\n\\n    Returns:\\n        the Qobj with calibration circuits at the beginning\\n        the state labels for build MeasFitter\\n        the labels of the calibration circuits\\n\\n    Raises:\\n        QiskitError: when the fitter_cls is not recognizable.\\n        MissingOptionalLibraryError: Qiskit-Ignis not installed\\n    '\n    circlabel = 'mcal'\n    if not qubit_list:\n        raise QiskitError('The measured qubit list can not be [].')\n    if fitter_cls == CompleteMeasFitter:\n        (meas_calibs_circuits, state_labels) = complete_meas_cal(qubit_list=range(len(qubit_list)), circlabel=circlabel)\n    elif fitter_cls == TensoredMeasFitter:\n        (meas_calibs_circuits, state_labels) = tensored_meas_cal(mit_pattern=mit_pattern, circlabel=circlabel)\n    else:\n        raise QiskitError(f'Unknown fitter {fitter_cls}')\n    tmp_compile_config = copy.deepcopy(compile_config)\n    tmp_compile_config['initial_layout'] = qubit_list\n    t_meas_calibs_circuits = compiler.transpile(meas_calibs_circuits, backend, **backend_config, **tmp_compile_config)\n    cals_qobj = compiler.assemble(t_meas_calibs_circuits, backend, **run_config.to_dict())\n    if hasattr(cals_qobj.config, 'parameterizations'):\n        del cals_qobj.config.parameterizations\n    return (cals_qobj, state_labels, circlabel)"
        ]
    }
]