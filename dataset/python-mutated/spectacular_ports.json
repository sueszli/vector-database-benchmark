[
    {
        "func_name": "get_type_hints",
        "original": "def get_type_hints(hint, **kwargs):\n    try:\n        return _get_type_hints(hint, **kwargs)\n    except NameError:\n        reload_module_with_type_checking_enabled(hint.__module__)\n        return _get_type_hints(hint, **kwargs)\n    except TypeError:\n        raise UnableToProceedError(f'Unable to resolve type hints for {hint}.\\n            Please use types imported from `typing` instead of the types enabled\\n            by PEP585 (`from __future__ import annotations`).\\n            e.g. instead of list[str], please use List[str].')",
        "mutated": [
            "def get_type_hints(hint, **kwargs):\n    if False:\n        i = 10\n    try:\n        return _get_type_hints(hint, **kwargs)\n    except NameError:\n        reload_module_with_type_checking_enabled(hint.__module__)\n        return _get_type_hints(hint, **kwargs)\n    except TypeError:\n        raise UnableToProceedError(f'Unable to resolve type hints for {hint}.\\n            Please use types imported from `typing` instead of the types enabled\\n            by PEP585 (`from __future__ import annotations`).\\n            e.g. instead of list[str], please use List[str].')",
            "def get_type_hints(hint, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        return _get_type_hints(hint, **kwargs)\n    except NameError:\n        reload_module_with_type_checking_enabled(hint.__module__)\n        return _get_type_hints(hint, **kwargs)\n    except TypeError:\n        raise UnableToProceedError(f'Unable to resolve type hints for {hint}.\\n            Please use types imported from `typing` instead of the types enabled\\n            by PEP585 (`from __future__ import annotations`).\\n            e.g. instead of list[str], please use List[str].')",
            "def get_type_hints(hint, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        return _get_type_hints(hint, **kwargs)\n    except NameError:\n        reload_module_with_type_checking_enabled(hint.__module__)\n        return _get_type_hints(hint, **kwargs)\n    except TypeError:\n        raise UnableToProceedError(f'Unable to resolve type hints for {hint}.\\n            Please use types imported from `typing` instead of the types enabled\\n            by PEP585 (`from __future__ import annotations`).\\n            e.g. instead of list[str], please use List[str].')",
            "def get_type_hints(hint, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        return _get_type_hints(hint, **kwargs)\n    except NameError:\n        reload_module_with_type_checking_enabled(hint.__module__)\n        return _get_type_hints(hint, **kwargs)\n    except TypeError:\n        raise UnableToProceedError(f'Unable to resolve type hints for {hint}.\\n            Please use types imported from `typing` instead of the types enabled\\n            by PEP585 (`from __future__ import annotations`).\\n            e.g. instead of list[str], please use List[str].')",
            "def get_type_hints(hint, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        return _get_type_hints(hint, **kwargs)\n    except NameError:\n        reload_module_with_type_checking_enabled(hint.__module__)\n        return _get_type_hints(hint, **kwargs)\n    except TypeError:\n        raise UnableToProceedError(f'Unable to resolve type hints for {hint}.\\n            Please use types imported from `typing` instead of the types enabled\\n            by PEP585 (`from __future__ import annotations`).\\n            e.g. instead of list[str], please use List[str].')"
        ]
    },
    {
        "func_name": "_get_type_hint_origin",
        "original": "def _get_type_hint_origin(hint):\n    return (typing.get_origin(hint), typing.get_args(hint))",
        "mutated": [
            "def _get_type_hint_origin(hint):\n    if False:\n        i = 10\n    return (typing.get_origin(hint), typing.get_args(hint))",
            "def _get_type_hint_origin(hint):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (typing.get_origin(hint), typing.get_args(hint))",
            "def _get_type_hint_origin(hint):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (typing.get_origin(hint), typing.get_args(hint))",
            "def _get_type_hint_origin(hint):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (typing.get_origin(hint), typing.get_args(hint))",
            "def _get_type_hint_origin(hint):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (typing.get_origin(hint), typing.get_args(hint))"
        ]
    },
    {
        "func_name": "resolve_type_hint",
        "original": "def resolve_type_hint(hint) -> Any:\n    \"\"\"drf-spectacular library method modified as described above\"\"\"\n    (origin, args) = _get_type_hint_origin(hint)\n    excluded_fields = get_override(hint, 'exclude_fields', [])\n    if origin is None and is_basic_type(hint, allow_none=False):\n        return build_basic_type(hint)\n    elif origin is None and inspect.isclass(hint) and issubclass(hint, tuple):\n        if get_type_hints(hint):\n            properties = {k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items()}\n        else:\n            properties = {k: build_basic_type(OpenApiTypes.ANY) for k in hint._fields}\n        return build_object_type(properties=properties, required=properties.keys())\n    elif origin is list or hint is list:\n        return build_array_type(resolve_type_hint(args[0]) if args else build_basic_type(OpenApiTypes.ANY))\n    elif origin is tuple:\n        return build_array_type(schema=build_basic_type(args[0]), max_length=len(args), min_length=len(args))\n    elif origin is dict or origin is defaultdict:\n        schema = build_basic_type(OpenApiTypes.OBJECT)\n        if args and args[1] is not typing.Any:\n            schema['additionalProperties'] = resolve_type_hint(args[1])\n        return schema\n    elif origin is set:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is frozenset:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is Literal:\n        schema = {'enum': list(args)}\n        if all((type(args[0]) is type(choice) for choice in args)):\n            schema.update(build_basic_type(type(args[0])))\n        return schema\n    elif inspect.isclass(hint) and issubclass(hint, Enum):\n        schema = {'enum': [item.value for item in hint]}\n        mixin_base_types = [t for t in hint.__mro__ if is_basic_type(t)]\n        if mixin_base_types:\n            schema.update(build_basic_type(mixin_base_types[0]))\n        return schema\n    elif isinstance(hint, _TypedDictMeta):\n        return build_object_type(properties={k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items() if k not in excluded_fields}, description=inspect.cleandoc(hint.__doc__ or ''), required=[h for h in hint.__required_keys__ if h not in excluded_fields])\n    elif origin is Union:\n        type_args = [arg for arg in args if arg is not type(None)]\n        if len(type_args) > 1:\n            schema = {'oneOf': [resolve_type_hint(arg) for arg in type_args]}\n        else:\n            schema = resolve_type_hint(type_args[0])\n        if type(None) in args:\n            schema['nullable'] = True\n        return schema\n    elif origin is collections.abc.Iterable:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif isinstance(hint, typing._TypedDictMeta):\n        raise UnableToProceedError('Wrong TypedDict class, please use typing_extensions.TypedDict')\n    else:\n        raise UnableToProceedError(hint)",
        "mutated": [
            "def resolve_type_hint(hint) -> Any:\n    if False:\n        i = 10\n    'drf-spectacular library method modified as described above'\n    (origin, args) = _get_type_hint_origin(hint)\n    excluded_fields = get_override(hint, 'exclude_fields', [])\n    if origin is None and is_basic_type(hint, allow_none=False):\n        return build_basic_type(hint)\n    elif origin is None and inspect.isclass(hint) and issubclass(hint, tuple):\n        if get_type_hints(hint):\n            properties = {k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items()}\n        else:\n            properties = {k: build_basic_type(OpenApiTypes.ANY) for k in hint._fields}\n        return build_object_type(properties=properties, required=properties.keys())\n    elif origin is list or hint is list:\n        return build_array_type(resolve_type_hint(args[0]) if args else build_basic_type(OpenApiTypes.ANY))\n    elif origin is tuple:\n        return build_array_type(schema=build_basic_type(args[0]), max_length=len(args), min_length=len(args))\n    elif origin is dict or origin is defaultdict:\n        schema = build_basic_type(OpenApiTypes.OBJECT)\n        if args and args[1] is not typing.Any:\n            schema['additionalProperties'] = resolve_type_hint(args[1])\n        return schema\n    elif origin is set:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is frozenset:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is Literal:\n        schema = {'enum': list(args)}\n        if all((type(args[0]) is type(choice) for choice in args)):\n            schema.update(build_basic_type(type(args[0])))\n        return schema\n    elif inspect.isclass(hint) and issubclass(hint, Enum):\n        schema = {'enum': [item.value for item in hint]}\n        mixin_base_types = [t for t in hint.__mro__ if is_basic_type(t)]\n        if mixin_base_types:\n            schema.update(build_basic_type(mixin_base_types[0]))\n        return schema\n    elif isinstance(hint, _TypedDictMeta):\n        return build_object_type(properties={k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items() if k not in excluded_fields}, description=inspect.cleandoc(hint.__doc__ or ''), required=[h for h in hint.__required_keys__ if h not in excluded_fields])\n    elif origin is Union:\n        type_args = [arg for arg in args if arg is not type(None)]\n        if len(type_args) > 1:\n            schema = {'oneOf': [resolve_type_hint(arg) for arg in type_args]}\n        else:\n            schema = resolve_type_hint(type_args[0])\n        if type(None) in args:\n            schema['nullable'] = True\n        return schema\n    elif origin is collections.abc.Iterable:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif isinstance(hint, typing._TypedDictMeta):\n        raise UnableToProceedError('Wrong TypedDict class, please use typing_extensions.TypedDict')\n    else:\n        raise UnableToProceedError(hint)",
            "def resolve_type_hint(hint) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'drf-spectacular library method modified as described above'\n    (origin, args) = _get_type_hint_origin(hint)\n    excluded_fields = get_override(hint, 'exclude_fields', [])\n    if origin is None and is_basic_type(hint, allow_none=False):\n        return build_basic_type(hint)\n    elif origin is None and inspect.isclass(hint) and issubclass(hint, tuple):\n        if get_type_hints(hint):\n            properties = {k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items()}\n        else:\n            properties = {k: build_basic_type(OpenApiTypes.ANY) for k in hint._fields}\n        return build_object_type(properties=properties, required=properties.keys())\n    elif origin is list or hint is list:\n        return build_array_type(resolve_type_hint(args[0]) if args else build_basic_type(OpenApiTypes.ANY))\n    elif origin is tuple:\n        return build_array_type(schema=build_basic_type(args[0]), max_length=len(args), min_length=len(args))\n    elif origin is dict or origin is defaultdict:\n        schema = build_basic_type(OpenApiTypes.OBJECT)\n        if args and args[1] is not typing.Any:\n            schema['additionalProperties'] = resolve_type_hint(args[1])\n        return schema\n    elif origin is set:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is frozenset:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is Literal:\n        schema = {'enum': list(args)}\n        if all((type(args[0]) is type(choice) for choice in args)):\n            schema.update(build_basic_type(type(args[0])))\n        return schema\n    elif inspect.isclass(hint) and issubclass(hint, Enum):\n        schema = {'enum': [item.value for item in hint]}\n        mixin_base_types = [t for t in hint.__mro__ if is_basic_type(t)]\n        if mixin_base_types:\n            schema.update(build_basic_type(mixin_base_types[0]))\n        return schema\n    elif isinstance(hint, _TypedDictMeta):\n        return build_object_type(properties={k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items() if k not in excluded_fields}, description=inspect.cleandoc(hint.__doc__ or ''), required=[h for h in hint.__required_keys__ if h not in excluded_fields])\n    elif origin is Union:\n        type_args = [arg for arg in args if arg is not type(None)]\n        if len(type_args) > 1:\n            schema = {'oneOf': [resolve_type_hint(arg) for arg in type_args]}\n        else:\n            schema = resolve_type_hint(type_args[0])\n        if type(None) in args:\n            schema['nullable'] = True\n        return schema\n    elif origin is collections.abc.Iterable:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif isinstance(hint, typing._TypedDictMeta):\n        raise UnableToProceedError('Wrong TypedDict class, please use typing_extensions.TypedDict')\n    else:\n        raise UnableToProceedError(hint)",
            "def resolve_type_hint(hint) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'drf-spectacular library method modified as described above'\n    (origin, args) = _get_type_hint_origin(hint)\n    excluded_fields = get_override(hint, 'exclude_fields', [])\n    if origin is None and is_basic_type(hint, allow_none=False):\n        return build_basic_type(hint)\n    elif origin is None and inspect.isclass(hint) and issubclass(hint, tuple):\n        if get_type_hints(hint):\n            properties = {k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items()}\n        else:\n            properties = {k: build_basic_type(OpenApiTypes.ANY) for k in hint._fields}\n        return build_object_type(properties=properties, required=properties.keys())\n    elif origin is list or hint is list:\n        return build_array_type(resolve_type_hint(args[0]) if args else build_basic_type(OpenApiTypes.ANY))\n    elif origin is tuple:\n        return build_array_type(schema=build_basic_type(args[0]), max_length=len(args), min_length=len(args))\n    elif origin is dict or origin is defaultdict:\n        schema = build_basic_type(OpenApiTypes.OBJECT)\n        if args and args[1] is not typing.Any:\n            schema['additionalProperties'] = resolve_type_hint(args[1])\n        return schema\n    elif origin is set:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is frozenset:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is Literal:\n        schema = {'enum': list(args)}\n        if all((type(args[0]) is type(choice) for choice in args)):\n            schema.update(build_basic_type(type(args[0])))\n        return schema\n    elif inspect.isclass(hint) and issubclass(hint, Enum):\n        schema = {'enum': [item.value for item in hint]}\n        mixin_base_types = [t for t in hint.__mro__ if is_basic_type(t)]\n        if mixin_base_types:\n            schema.update(build_basic_type(mixin_base_types[0]))\n        return schema\n    elif isinstance(hint, _TypedDictMeta):\n        return build_object_type(properties={k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items() if k not in excluded_fields}, description=inspect.cleandoc(hint.__doc__ or ''), required=[h for h in hint.__required_keys__ if h not in excluded_fields])\n    elif origin is Union:\n        type_args = [arg for arg in args if arg is not type(None)]\n        if len(type_args) > 1:\n            schema = {'oneOf': [resolve_type_hint(arg) for arg in type_args]}\n        else:\n            schema = resolve_type_hint(type_args[0])\n        if type(None) in args:\n            schema['nullable'] = True\n        return schema\n    elif origin is collections.abc.Iterable:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif isinstance(hint, typing._TypedDictMeta):\n        raise UnableToProceedError('Wrong TypedDict class, please use typing_extensions.TypedDict')\n    else:\n        raise UnableToProceedError(hint)",
            "def resolve_type_hint(hint) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'drf-spectacular library method modified as described above'\n    (origin, args) = _get_type_hint_origin(hint)\n    excluded_fields = get_override(hint, 'exclude_fields', [])\n    if origin is None and is_basic_type(hint, allow_none=False):\n        return build_basic_type(hint)\n    elif origin is None and inspect.isclass(hint) and issubclass(hint, tuple):\n        if get_type_hints(hint):\n            properties = {k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items()}\n        else:\n            properties = {k: build_basic_type(OpenApiTypes.ANY) for k in hint._fields}\n        return build_object_type(properties=properties, required=properties.keys())\n    elif origin is list or hint is list:\n        return build_array_type(resolve_type_hint(args[0]) if args else build_basic_type(OpenApiTypes.ANY))\n    elif origin is tuple:\n        return build_array_type(schema=build_basic_type(args[0]), max_length=len(args), min_length=len(args))\n    elif origin is dict or origin is defaultdict:\n        schema = build_basic_type(OpenApiTypes.OBJECT)\n        if args and args[1] is not typing.Any:\n            schema['additionalProperties'] = resolve_type_hint(args[1])\n        return schema\n    elif origin is set:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is frozenset:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is Literal:\n        schema = {'enum': list(args)}\n        if all((type(args[0]) is type(choice) for choice in args)):\n            schema.update(build_basic_type(type(args[0])))\n        return schema\n    elif inspect.isclass(hint) and issubclass(hint, Enum):\n        schema = {'enum': [item.value for item in hint]}\n        mixin_base_types = [t for t in hint.__mro__ if is_basic_type(t)]\n        if mixin_base_types:\n            schema.update(build_basic_type(mixin_base_types[0]))\n        return schema\n    elif isinstance(hint, _TypedDictMeta):\n        return build_object_type(properties={k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items() if k not in excluded_fields}, description=inspect.cleandoc(hint.__doc__ or ''), required=[h for h in hint.__required_keys__ if h not in excluded_fields])\n    elif origin is Union:\n        type_args = [arg for arg in args if arg is not type(None)]\n        if len(type_args) > 1:\n            schema = {'oneOf': [resolve_type_hint(arg) for arg in type_args]}\n        else:\n            schema = resolve_type_hint(type_args[0])\n        if type(None) in args:\n            schema['nullable'] = True\n        return schema\n    elif origin is collections.abc.Iterable:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif isinstance(hint, typing._TypedDictMeta):\n        raise UnableToProceedError('Wrong TypedDict class, please use typing_extensions.TypedDict')\n    else:\n        raise UnableToProceedError(hint)",
            "def resolve_type_hint(hint) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'drf-spectacular library method modified as described above'\n    (origin, args) = _get_type_hint_origin(hint)\n    excluded_fields = get_override(hint, 'exclude_fields', [])\n    if origin is None and is_basic_type(hint, allow_none=False):\n        return build_basic_type(hint)\n    elif origin is None and inspect.isclass(hint) and issubclass(hint, tuple):\n        if get_type_hints(hint):\n            properties = {k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items()}\n        else:\n            properties = {k: build_basic_type(OpenApiTypes.ANY) for k in hint._fields}\n        return build_object_type(properties=properties, required=properties.keys())\n    elif origin is list or hint is list:\n        return build_array_type(resolve_type_hint(args[0]) if args else build_basic_type(OpenApiTypes.ANY))\n    elif origin is tuple:\n        return build_array_type(schema=build_basic_type(args[0]), max_length=len(args), min_length=len(args))\n    elif origin is dict or origin is defaultdict:\n        schema = build_basic_type(OpenApiTypes.OBJECT)\n        if args and args[1] is not typing.Any:\n            schema['additionalProperties'] = resolve_type_hint(args[1])\n        return schema\n    elif origin is set:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is frozenset:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif origin is Literal:\n        schema = {'enum': list(args)}\n        if all((type(args[0]) is type(choice) for choice in args)):\n            schema.update(build_basic_type(type(args[0])))\n        return schema\n    elif inspect.isclass(hint) and issubclass(hint, Enum):\n        schema = {'enum': [item.value for item in hint]}\n        mixin_base_types = [t for t in hint.__mro__ if is_basic_type(t)]\n        if mixin_base_types:\n            schema.update(build_basic_type(mixin_base_types[0]))\n        return schema\n    elif isinstance(hint, _TypedDictMeta):\n        return build_object_type(properties={k: resolve_type_hint(v) for (k, v) in get_type_hints(hint).items() if k not in excluded_fields}, description=inspect.cleandoc(hint.__doc__ or ''), required=[h for h in hint.__required_keys__ if h not in excluded_fields])\n    elif origin is Union:\n        type_args = [arg for arg in args if arg is not type(None)]\n        if len(type_args) > 1:\n            schema = {'oneOf': [resolve_type_hint(arg) for arg in type_args]}\n        else:\n            schema = resolve_type_hint(type_args[0])\n        if type(None) in args:\n            schema['nullable'] = True\n        return schema\n    elif origin is collections.abc.Iterable:\n        return build_array_type(resolve_type_hint(args[0]))\n    elif isinstance(hint, typing._TypedDictMeta):\n        raise UnableToProceedError('Wrong TypedDict class, please use typing_extensions.TypedDict')\n    else:\n        raise UnableToProceedError(hint)"
        ]
    }
]