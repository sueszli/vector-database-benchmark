[
    {
        "func_name": "loadDataSet",
        "original": "def loadDataSet(fileName):\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
        "mutated": [
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)"
        ]
    },
    {
        "func_name": "stumpClassify",
        "original": "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    \"\"\"\n\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\n\tParameters:\n\t\tdataMatrix - \u6570\u636e\u77e9\u9635\n\t\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\n\t\tthreshVal - \u9608\u503c\n\t\tthreshIneq - \u6807\u5fd7\n\tReturns:\n\t\tretArray - \u5206\u7c7b\u7ed3\u679c\n\t\"\"\"\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
        "mutated": [
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray"
        ]
    },
    {
        "func_name": "buildStump",
        "original": "def buildStump(dataArr, classLabels, D):\n    \"\"\"\n\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\n\tParameters:\n\t\tdataArr - \u6570\u636e\u77e9\u9635\n\t\tclassLabels - \u6570\u636e\u6807\u7b7e\n\t\tD - \u6837\u672c\u6743\u91cd\n\tReturns:\n\t\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\n\t\tminError - \u6700\u5c0f\u8bef\u5dee\n\t\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\n\t\"\"\"\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
        "mutated": [
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)"
        ]
    },
    {
        "func_name": "adaBoostTrainDS",
        "original": "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    \"\"\"\n\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u8bad\u7ec3\u5206\u7c7b\u5668\n\tParameters:\n\t\tdataArr - \u6570\u636e\u77e9\u9635\n\t\tclassLabels - \u6570\u636e\u6807\u7b7e\n\t\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\n\tReturns:\n\t\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\n\t\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\n\t\"\"\"\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
        "mutated": [
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u8bad\u7ec3\u5206\u7c7b\u5668\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u8bad\u7ec3\u5206\u7c7b\u5668\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u8bad\u7ec3\u5206\u7c7b\u5668\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u8bad\u7ec3\u5206\u7c7b\u5668\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u8bad\u7ec3\u5206\u7c7b\u5668\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)"
        ]
    },
    {
        "func_name": "plotROC",
        "original": "def plotROC(predStrengths, classLabels):\n    \"\"\"\n\t\u7ed8\u5236ROC\n\tParameters:\n\t\tpredStrengths - \u5206\u7c7b\u5668\u7684\u9884\u6d4b\u5f3a\u5ea6\n\t\tclassLabels - \u7c7b\u522b\n\tReturns:\n\t\t\u65e0\n\t\"\"\"\n    font = FontProperties(fname='c:\\\\windows\\\\fonts\\\\simsun.ttc', size=14)\n    cur = (1.0, 1.0)\n    ySum = 0.0\n    numPosClas = np.sum(np.array(classLabels) == 1.0)\n    yStep = 1 / float(numPosClas)\n    xStep = 1 / float(len(classLabels) - numPosClas)\n    sortedIndicies = predStrengths.argsort()\n    fig = plt.figure()\n    fig.clf()\n    ax = plt.subplot(111)\n    for index in sortedIndicies.tolist()[0]:\n        if classLabels[index] == 1.0:\n            delX = 0\n            delY = yStep\n        else:\n            delX = xStep\n            delY = 0\n            ySum += cur[1]\n        ax.plot([cur[0], cur[0] - delX], [cur[1], cur[1] - delY], c='b')\n        cur = (cur[0] - delX, cur[1] - delY)\n    ax.plot([0, 1], [0, 1], 'b--')\n    plt.title('AdaBoost\u9a6c\u759d\u75c5\u68c0\u6d4b\u7cfb\u7edf\u7684ROC\u66f2\u7ebf', FontProperties=font)\n    plt.xlabel('\u5047\u9633\u7387', FontProperties=font)\n    plt.ylabel('\u771f\u9633\u7387', FontProperties=font)\n    ax.axis([0, 1, 0, 1])\n    print('AUC\u9762\u79ef\u4e3a:', ySum * xStep)\n    plt.show()",
        "mutated": [
            "def plotROC(predStrengths, classLabels):\n    if False:\n        i = 10\n    '\\n\\t\u7ed8\u5236ROC\\n\\tParameters:\\n\\t\\tpredStrengths - \u5206\u7c7b\u5668\u7684\u9884\u6d4b\u5f3a\u5ea6\\n\\t\\tclassLabels - \u7c7b\u522b\\n\\tReturns:\\n\\t\\t\u65e0\\n\\t'\n    font = FontProperties(fname='c:\\\\windows\\\\fonts\\\\simsun.ttc', size=14)\n    cur = (1.0, 1.0)\n    ySum = 0.0\n    numPosClas = np.sum(np.array(classLabels) == 1.0)\n    yStep = 1 / float(numPosClas)\n    xStep = 1 / float(len(classLabels) - numPosClas)\n    sortedIndicies = predStrengths.argsort()\n    fig = plt.figure()\n    fig.clf()\n    ax = plt.subplot(111)\n    for index in sortedIndicies.tolist()[0]:\n        if classLabels[index] == 1.0:\n            delX = 0\n            delY = yStep\n        else:\n            delX = xStep\n            delY = 0\n            ySum += cur[1]\n        ax.plot([cur[0], cur[0] - delX], [cur[1], cur[1] - delY], c='b')\n        cur = (cur[0] - delX, cur[1] - delY)\n    ax.plot([0, 1], [0, 1], 'b--')\n    plt.title('AdaBoost\u9a6c\u759d\u75c5\u68c0\u6d4b\u7cfb\u7edf\u7684ROC\u66f2\u7ebf', FontProperties=font)\n    plt.xlabel('\u5047\u9633\u7387', FontProperties=font)\n    plt.ylabel('\u771f\u9633\u7387', FontProperties=font)\n    ax.axis([0, 1, 0, 1])\n    print('AUC\u9762\u79ef\u4e3a:', ySum * xStep)\n    plt.show()",
            "def plotROC(predStrengths, classLabels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\u7ed8\u5236ROC\\n\\tParameters:\\n\\t\\tpredStrengths - \u5206\u7c7b\u5668\u7684\u9884\u6d4b\u5f3a\u5ea6\\n\\t\\tclassLabels - \u7c7b\u522b\\n\\tReturns:\\n\\t\\t\u65e0\\n\\t'\n    font = FontProperties(fname='c:\\\\windows\\\\fonts\\\\simsun.ttc', size=14)\n    cur = (1.0, 1.0)\n    ySum = 0.0\n    numPosClas = np.sum(np.array(classLabels) == 1.0)\n    yStep = 1 / float(numPosClas)\n    xStep = 1 / float(len(classLabels) - numPosClas)\n    sortedIndicies = predStrengths.argsort()\n    fig = plt.figure()\n    fig.clf()\n    ax = plt.subplot(111)\n    for index in sortedIndicies.tolist()[0]:\n        if classLabels[index] == 1.0:\n            delX = 0\n            delY = yStep\n        else:\n            delX = xStep\n            delY = 0\n            ySum += cur[1]\n        ax.plot([cur[0], cur[0] - delX], [cur[1], cur[1] - delY], c='b')\n        cur = (cur[0] - delX, cur[1] - delY)\n    ax.plot([0, 1], [0, 1], 'b--')\n    plt.title('AdaBoost\u9a6c\u759d\u75c5\u68c0\u6d4b\u7cfb\u7edf\u7684ROC\u66f2\u7ebf', FontProperties=font)\n    plt.xlabel('\u5047\u9633\u7387', FontProperties=font)\n    plt.ylabel('\u771f\u9633\u7387', FontProperties=font)\n    ax.axis([0, 1, 0, 1])\n    print('AUC\u9762\u79ef\u4e3a:', ySum * xStep)\n    plt.show()",
            "def plotROC(predStrengths, classLabels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\u7ed8\u5236ROC\\n\\tParameters:\\n\\t\\tpredStrengths - \u5206\u7c7b\u5668\u7684\u9884\u6d4b\u5f3a\u5ea6\\n\\t\\tclassLabels - \u7c7b\u522b\\n\\tReturns:\\n\\t\\t\u65e0\\n\\t'\n    font = FontProperties(fname='c:\\\\windows\\\\fonts\\\\simsun.ttc', size=14)\n    cur = (1.0, 1.0)\n    ySum = 0.0\n    numPosClas = np.sum(np.array(classLabels) == 1.0)\n    yStep = 1 / float(numPosClas)\n    xStep = 1 / float(len(classLabels) - numPosClas)\n    sortedIndicies = predStrengths.argsort()\n    fig = plt.figure()\n    fig.clf()\n    ax = plt.subplot(111)\n    for index in sortedIndicies.tolist()[0]:\n        if classLabels[index] == 1.0:\n            delX = 0\n            delY = yStep\n        else:\n            delX = xStep\n            delY = 0\n            ySum += cur[1]\n        ax.plot([cur[0], cur[0] - delX], [cur[1], cur[1] - delY], c='b')\n        cur = (cur[0] - delX, cur[1] - delY)\n    ax.plot([0, 1], [0, 1], 'b--')\n    plt.title('AdaBoost\u9a6c\u759d\u75c5\u68c0\u6d4b\u7cfb\u7edf\u7684ROC\u66f2\u7ebf', FontProperties=font)\n    plt.xlabel('\u5047\u9633\u7387', FontProperties=font)\n    plt.ylabel('\u771f\u9633\u7387', FontProperties=font)\n    ax.axis([0, 1, 0, 1])\n    print('AUC\u9762\u79ef\u4e3a:', ySum * xStep)\n    plt.show()",
            "def plotROC(predStrengths, classLabels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\u7ed8\u5236ROC\\n\\tParameters:\\n\\t\\tpredStrengths - \u5206\u7c7b\u5668\u7684\u9884\u6d4b\u5f3a\u5ea6\\n\\t\\tclassLabels - \u7c7b\u522b\\n\\tReturns:\\n\\t\\t\u65e0\\n\\t'\n    font = FontProperties(fname='c:\\\\windows\\\\fonts\\\\simsun.ttc', size=14)\n    cur = (1.0, 1.0)\n    ySum = 0.0\n    numPosClas = np.sum(np.array(classLabels) == 1.0)\n    yStep = 1 / float(numPosClas)\n    xStep = 1 / float(len(classLabels) - numPosClas)\n    sortedIndicies = predStrengths.argsort()\n    fig = plt.figure()\n    fig.clf()\n    ax = plt.subplot(111)\n    for index in sortedIndicies.tolist()[0]:\n        if classLabels[index] == 1.0:\n            delX = 0\n            delY = yStep\n        else:\n            delX = xStep\n            delY = 0\n            ySum += cur[1]\n        ax.plot([cur[0], cur[0] - delX], [cur[1], cur[1] - delY], c='b')\n        cur = (cur[0] - delX, cur[1] - delY)\n    ax.plot([0, 1], [0, 1], 'b--')\n    plt.title('AdaBoost\u9a6c\u759d\u75c5\u68c0\u6d4b\u7cfb\u7edf\u7684ROC\u66f2\u7ebf', FontProperties=font)\n    plt.xlabel('\u5047\u9633\u7387', FontProperties=font)\n    plt.ylabel('\u771f\u9633\u7387', FontProperties=font)\n    ax.axis([0, 1, 0, 1])\n    print('AUC\u9762\u79ef\u4e3a:', ySum * xStep)\n    plt.show()",
            "def plotROC(predStrengths, classLabels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\u7ed8\u5236ROC\\n\\tParameters:\\n\\t\\tpredStrengths - \u5206\u7c7b\u5668\u7684\u9884\u6d4b\u5f3a\u5ea6\\n\\t\\tclassLabels - \u7c7b\u522b\\n\\tReturns:\\n\\t\\t\u65e0\\n\\t'\n    font = FontProperties(fname='c:\\\\windows\\\\fonts\\\\simsun.ttc', size=14)\n    cur = (1.0, 1.0)\n    ySum = 0.0\n    numPosClas = np.sum(np.array(classLabels) == 1.0)\n    yStep = 1 / float(numPosClas)\n    xStep = 1 / float(len(classLabels) - numPosClas)\n    sortedIndicies = predStrengths.argsort()\n    fig = plt.figure()\n    fig.clf()\n    ax = plt.subplot(111)\n    for index in sortedIndicies.tolist()[0]:\n        if classLabels[index] == 1.0:\n            delX = 0\n            delY = yStep\n        else:\n            delX = xStep\n            delY = 0\n            ySum += cur[1]\n        ax.plot([cur[0], cur[0] - delX], [cur[1], cur[1] - delY], c='b')\n        cur = (cur[0] - delX, cur[1] - delY)\n    ax.plot([0, 1], [0, 1], 'b--')\n    plt.title('AdaBoost\u9a6c\u759d\u75c5\u68c0\u6d4b\u7cfb\u7edf\u7684ROC\u66f2\u7ebf', FontProperties=font)\n    plt.xlabel('\u5047\u9633\u7387', FontProperties=font)\n    plt.ylabel('\u771f\u9633\u7387', FontProperties=font)\n    ax.axis([0, 1, 0, 1])\n    print('AUC\u9762\u79ef\u4e3a:', ySum * xStep)\n    plt.show()"
        ]
    }
]