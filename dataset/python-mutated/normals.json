[
    {
        "func_name": "compact",
        "original": "def compact(vertices, indices, tolerance=0.001):\n    \"\"\"Compact vertices and indices within given tolerance\"\"\"\n    n = len(vertices)\n    V = np.zeros(n, dtype=[('pos', np.float32, 3)])\n    V['pos'][:, 0] = vertices[:, 0]\n    V['pos'][:, 1] = vertices[:, 1]\n    V['pos'][:, 2] = vertices[:, 2]\n    epsilon = 0.001\n    decimals = int(np.log(epsilon) / np.log(1 / 10.0))\n    V_ = np.zeros_like(V)\n    X = V['pos'][:, 0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n    V_['pos'][:, 0] = X\n    Y = V['pos'][:, 1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_['pos'][:, 1] = Y\n    Z = V['pos'][:, 2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_['pos'][:, 2] = Z\n    (U, RI) = np.unique(V_, return_inverse=True)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices) // 3, 3)\n    return (U.view(np.float32).reshape(len(U), 3), I_, RI)",
        "mutated": [
            "def compact(vertices, indices, tolerance=0.001):\n    if False:\n        i = 10\n    'Compact vertices and indices within given tolerance'\n    n = len(vertices)\n    V = np.zeros(n, dtype=[('pos', np.float32, 3)])\n    V['pos'][:, 0] = vertices[:, 0]\n    V['pos'][:, 1] = vertices[:, 1]\n    V['pos'][:, 2] = vertices[:, 2]\n    epsilon = 0.001\n    decimals = int(np.log(epsilon) / np.log(1 / 10.0))\n    V_ = np.zeros_like(V)\n    X = V['pos'][:, 0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n    V_['pos'][:, 0] = X\n    Y = V['pos'][:, 1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_['pos'][:, 1] = Y\n    Z = V['pos'][:, 2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_['pos'][:, 2] = Z\n    (U, RI) = np.unique(V_, return_inverse=True)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices) // 3, 3)\n    return (U.view(np.float32).reshape(len(U), 3), I_, RI)",
            "def compact(vertices, indices, tolerance=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compact vertices and indices within given tolerance'\n    n = len(vertices)\n    V = np.zeros(n, dtype=[('pos', np.float32, 3)])\n    V['pos'][:, 0] = vertices[:, 0]\n    V['pos'][:, 1] = vertices[:, 1]\n    V['pos'][:, 2] = vertices[:, 2]\n    epsilon = 0.001\n    decimals = int(np.log(epsilon) / np.log(1 / 10.0))\n    V_ = np.zeros_like(V)\n    X = V['pos'][:, 0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n    V_['pos'][:, 0] = X\n    Y = V['pos'][:, 1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_['pos'][:, 1] = Y\n    Z = V['pos'][:, 2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_['pos'][:, 2] = Z\n    (U, RI) = np.unique(V_, return_inverse=True)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices) // 3, 3)\n    return (U.view(np.float32).reshape(len(U), 3), I_, RI)",
            "def compact(vertices, indices, tolerance=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compact vertices and indices within given tolerance'\n    n = len(vertices)\n    V = np.zeros(n, dtype=[('pos', np.float32, 3)])\n    V['pos'][:, 0] = vertices[:, 0]\n    V['pos'][:, 1] = vertices[:, 1]\n    V['pos'][:, 2] = vertices[:, 2]\n    epsilon = 0.001\n    decimals = int(np.log(epsilon) / np.log(1 / 10.0))\n    V_ = np.zeros_like(V)\n    X = V['pos'][:, 0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n    V_['pos'][:, 0] = X\n    Y = V['pos'][:, 1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_['pos'][:, 1] = Y\n    Z = V['pos'][:, 2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_['pos'][:, 2] = Z\n    (U, RI) = np.unique(V_, return_inverse=True)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices) // 3, 3)\n    return (U.view(np.float32).reshape(len(U), 3), I_, RI)",
            "def compact(vertices, indices, tolerance=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compact vertices and indices within given tolerance'\n    n = len(vertices)\n    V = np.zeros(n, dtype=[('pos', np.float32, 3)])\n    V['pos'][:, 0] = vertices[:, 0]\n    V['pos'][:, 1] = vertices[:, 1]\n    V['pos'][:, 2] = vertices[:, 2]\n    epsilon = 0.001\n    decimals = int(np.log(epsilon) / np.log(1 / 10.0))\n    V_ = np.zeros_like(V)\n    X = V['pos'][:, 0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n    V_['pos'][:, 0] = X\n    Y = V['pos'][:, 1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_['pos'][:, 1] = Y\n    Z = V['pos'][:, 2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_['pos'][:, 2] = Z\n    (U, RI) = np.unique(V_, return_inverse=True)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices) // 3, 3)\n    return (U.view(np.float32).reshape(len(U), 3), I_, RI)",
            "def compact(vertices, indices, tolerance=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compact vertices and indices within given tolerance'\n    n = len(vertices)\n    V = np.zeros(n, dtype=[('pos', np.float32, 3)])\n    V['pos'][:, 0] = vertices[:, 0]\n    V['pos'][:, 1] = vertices[:, 1]\n    V['pos'][:, 2] = vertices[:, 2]\n    epsilon = 0.001\n    decimals = int(np.log(epsilon) / np.log(1 / 10.0))\n    V_ = np.zeros_like(V)\n    X = V['pos'][:, 0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n    V_['pos'][:, 0] = X\n    Y = V['pos'][:, 1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_['pos'][:, 1] = Y\n    Z = V['pos'][:, 2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_['pos'][:, 2] = Z\n    (U, RI) = np.unique(V_, return_inverse=True)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices) // 3, 3)\n    return (U.view(np.float32).reshape(len(U), 3), I_, RI)"
        ]
    },
    {
        "func_name": "normals",
        "original": "def normals(vertices, indices):\n    \"\"\"Compute normals over a triangulated surface\n\n    Parameters\n    ----------\n    vertices : ndarray (n,3)\n        triangles vertices\n\n    indices : ndarray (p,3)\n        triangles indices\n    \"\"\"\n    (vertices, indices, mapping) = compact(vertices, indices)\n    T = vertices[indices]\n    N = np.cross(T[:, 1] - T[:, 0], T[:, 2] - T[:, 0])\n    L = np.sqrt(np.sum(N * N, axis=1))\n    L[L == 0] = 1.0\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:, 0]] += N\n    normals[indices[:, 1]] += N\n    normals[indices[:, 2]] += N\n    L = np.sqrt(np.sum(normals * normals, axis=1))\n    L[L == 0] = 1.0\n    normals /= L[:, np.newaxis]\n    return normals[mapping]",
        "mutated": [
            "def normals(vertices, indices):\n    if False:\n        i = 10\n    'Compute normals over a triangulated surface\\n\\n    Parameters\\n    ----------\\n    vertices : ndarray (n,3)\\n        triangles vertices\\n\\n    indices : ndarray (p,3)\\n        triangles indices\\n    '\n    (vertices, indices, mapping) = compact(vertices, indices)\n    T = vertices[indices]\n    N = np.cross(T[:, 1] - T[:, 0], T[:, 2] - T[:, 0])\n    L = np.sqrt(np.sum(N * N, axis=1))\n    L[L == 0] = 1.0\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:, 0]] += N\n    normals[indices[:, 1]] += N\n    normals[indices[:, 2]] += N\n    L = np.sqrt(np.sum(normals * normals, axis=1))\n    L[L == 0] = 1.0\n    normals /= L[:, np.newaxis]\n    return normals[mapping]",
            "def normals(vertices, indices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute normals over a triangulated surface\\n\\n    Parameters\\n    ----------\\n    vertices : ndarray (n,3)\\n        triangles vertices\\n\\n    indices : ndarray (p,3)\\n        triangles indices\\n    '\n    (vertices, indices, mapping) = compact(vertices, indices)\n    T = vertices[indices]\n    N = np.cross(T[:, 1] - T[:, 0], T[:, 2] - T[:, 0])\n    L = np.sqrt(np.sum(N * N, axis=1))\n    L[L == 0] = 1.0\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:, 0]] += N\n    normals[indices[:, 1]] += N\n    normals[indices[:, 2]] += N\n    L = np.sqrt(np.sum(normals * normals, axis=1))\n    L[L == 0] = 1.0\n    normals /= L[:, np.newaxis]\n    return normals[mapping]",
            "def normals(vertices, indices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute normals over a triangulated surface\\n\\n    Parameters\\n    ----------\\n    vertices : ndarray (n,3)\\n        triangles vertices\\n\\n    indices : ndarray (p,3)\\n        triangles indices\\n    '\n    (vertices, indices, mapping) = compact(vertices, indices)\n    T = vertices[indices]\n    N = np.cross(T[:, 1] - T[:, 0], T[:, 2] - T[:, 0])\n    L = np.sqrt(np.sum(N * N, axis=1))\n    L[L == 0] = 1.0\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:, 0]] += N\n    normals[indices[:, 1]] += N\n    normals[indices[:, 2]] += N\n    L = np.sqrt(np.sum(normals * normals, axis=1))\n    L[L == 0] = 1.0\n    normals /= L[:, np.newaxis]\n    return normals[mapping]",
            "def normals(vertices, indices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute normals over a triangulated surface\\n\\n    Parameters\\n    ----------\\n    vertices : ndarray (n,3)\\n        triangles vertices\\n\\n    indices : ndarray (p,3)\\n        triangles indices\\n    '\n    (vertices, indices, mapping) = compact(vertices, indices)\n    T = vertices[indices]\n    N = np.cross(T[:, 1] - T[:, 0], T[:, 2] - T[:, 0])\n    L = np.sqrt(np.sum(N * N, axis=1))\n    L[L == 0] = 1.0\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:, 0]] += N\n    normals[indices[:, 1]] += N\n    normals[indices[:, 2]] += N\n    L = np.sqrt(np.sum(normals * normals, axis=1))\n    L[L == 0] = 1.0\n    normals /= L[:, np.newaxis]\n    return normals[mapping]",
            "def normals(vertices, indices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute normals over a triangulated surface\\n\\n    Parameters\\n    ----------\\n    vertices : ndarray (n,3)\\n        triangles vertices\\n\\n    indices : ndarray (p,3)\\n        triangles indices\\n    '\n    (vertices, indices, mapping) = compact(vertices, indices)\n    T = vertices[indices]\n    N = np.cross(T[:, 1] - T[:, 0], T[:, 2] - T[:, 0])\n    L = np.sqrt(np.sum(N * N, axis=1))\n    L[L == 0] = 1.0\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:, 0]] += N\n    normals[indices[:, 1]] += N\n    normals[indices[:, 2]] += N\n    L = np.sqrt(np.sum(normals * normals, axis=1))\n    L[L == 0] = 1.0\n    normals /= L[:, np.newaxis]\n    return normals[mapping]"
        ]
    }
]