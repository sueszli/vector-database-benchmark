[
    {
        "func_name": "upload_photo",
        "original": "def upload_photo(self, photo, caption=None, upload_id=None, from_video=False, options={}, user_tags=None, is_sidecar=False):\n    \"\"\"Upload photo to Instagram\n\n    @param photo       Path to photo file (String)\n    @param caption     Media description (String)\n    @param upload_id   Unique upload_id (String). When None, then\n                       generate automatically\n    @param from_video  A flag that signals whether the photo is loaded from\n                       the video or by itself (Boolean, DEPRECATED: not used)\n    @param options     Object with difference options, e.g.\n                       configure_timeout, rename (Dict)\n                       Designed to reduce the number of function arguments!\n                       This is the simplest request object.\n    @param user_tags   Tag other users (List)\n                       usertags = [\n                         {\"user_id\": user_id, \"position\": [x, y]}\n                       ]\n    @param is_sidecar  An album element (Boolean)\n\n    @return            Object with state of uploading to Instagram (or False), Dict for is_sidecar\n    \"\"\"\n    self.small_delay()\n    result = self.api.upload_photo(photo, caption, upload_id, from_video, options=options, user_tags=user_tags, is_sidecar=is_sidecar)\n    if not result:\n        self.logger.info(\"Photo '{}' is not uploaded.\".format(photo))\n        return False\n    self.logger.info(\"Photo '{}' is uploaded.\".format(photo))\n    return result",
        "mutated": [
            "def upload_photo(self, photo, caption=None, upload_id=None, from_video=False, options={}, user_tags=None, is_sidecar=False):\n    if False:\n        i = 10\n    'Upload photo to Instagram\\n\\n    @param photo       Path to photo file (String)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags   Tag other users (List)\\n                       usertags = [\\n                         {\"user_id\": user_id, \"position\": [x, y]}\\n                       ]\\n    @param is_sidecar  An album element (Boolean)\\n\\n    @return            Object with state of uploading to Instagram (or False), Dict for is_sidecar\\n    '\n    self.small_delay()\n    result = self.api.upload_photo(photo, caption, upload_id, from_video, options=options, user_tags=user_tags, is_sidecar=is_sidecar)\n    if not result:\n        self.logger.info(\"Photo '{}' is not uploaded.\".format(photo))\n        return False\n    self.logger.info(\"Photo '{}' is uploaded.\".format(photo))\n    return result",
            "def upload_photo(self, photo, caption=None, upload_id=None, from_video=False, options={}, user_tags=None, is_sidecar=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Upload photo to Instagram\\n\\n    @param photo       Path to photo file (String)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags   Tag other users (List)\\n                       usertags = [\\n                         {\"user_id\": user_id, \"position\": [x, y]}\\n                       ]\\n    @param is_sidecar  An album element (Boolean)\\n\\n    @return            Object with state of uploading to Instagram (or False), Dict for is_sidecar\\n    '\n    self.small_delay()\n    result = self.api.upload_photo(photo, caption, upload_id, from_video, options=options, user_tags=user_tags, is_sidecar=is_sidecar)\n    if not result:\n        self.logger.info(\"Photo '{}' is not uploaded.\".format(photo))\n        return False\n    self.logger.info(\"Photo '{}' is uploaded.\".format(photo))\n    return result",
            "def upload_photo(self, photo, caption=None, upload_id=None, from_video=False, options={}, user_tags=None, is_sidecar=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Upload photo to Instagram\\n\\n    @param photo       Path to photo file (String)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags   Tag other users (List)\\n                       usertags = [\\n                         {\"user_id\": user_id, \"position\": [x, y]}\\n                       ]\\n    @param is_sidecar  An album element (Boolean)\\n\\n    @return            Object with state of uploading to Instagram (or False), Dict for is_sidecar\\n    '\n    self.small_delay()\n    result = self.api.upload_photo(photo, caption, upload_id, from_video, options=options, user_tags=user_tags, is_sidecar=is_sidecar)\n    if not result:\n        self.logger.info(\"Photo '{}' is not uploaded.\".format(photo))\n        return False\n    self.logger.info(\"Photo '{}' is uploaded.\".format(photo))\n    return result",
            "def upload_photo(self, photo, caption=None, upload_id=None, from_video=False, options={}, user_tags=None, is_sidecar=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Upload photo to Instagram\\n\\n    @param photo       Path to photo file (String)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags   Tag other users (List)\\n                       usertags = [\\n                         {\"user_id\": user_id, \"position\": [x, y]}\\n                       ]\\n    @param is_sidecar  An album element (Boolean)\\n\\n    @return            Object with state of uploading to Instagram (or False), Dict for is_sidecar\\n    '\n    self.small_delay()\n    result = self.api.upload_photo(photo, caption, upload_id, from_video, options=options, user_tags=user_tags, is_sidecar=is_sidecar)\n    if not result:\n        self.logger.info(\"Photo '{}' is not uploaded.\".format(photo))\n        return False\n    self.logger.info(\"Photo '{}' is uploaded.\".format(photo))\n    return result",
            "def upload_photo(self, photo, caption=None, upload_id=None, from_video=False, options={}, user_tags=None, is_sidecar=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Upload photo to Instagram\\n\\n    @param photo       Path to photo file (String)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags   Tag other users (List)\\n                       usertags = [\\n                         {\"user_id\": user_id, \"position\": [x, y]}\\n                       ]\\n    @param is_sidecar  An album element (Boolean)\\n\\n    @return            Object with state of uploading to Instagram (or False), Dict for is_sidecar\\n    '\n    self.small_delay()\n    result = self.api.upload_photo(photo, caption, upload_id, from_video, options=options, user_tags=user_tags, is_sidecar=is_sidecar)\n    if not result:\n        self.logger.info(\"Photo '{}' is not uploaded.\".format(photo))\n        return False\n    self.logger.info(\"Photo '{}' is uploaded.\".format(photo))\n    return result"
        ]
    },
    {
        "func_name": "upload_album",
        "original": "def upload_album(self, photos, caption=None, upload_id=None, from_video=False, options={}, user_tags=None):\n    \"\"\"Upload album to Instagram\n\n    @param photos      List of paths to photo files (List of strings)\n    @param caption     Media description (String)\n    @param upload_id   Unique upload_id (String). When None, then\n                       generate automatically\n    @param from_video  A flag that signals whether the photo is loaded from\n                       the video or by itself (Boolean, DEPRECATED: not used)\n    @param options     Object with difference options, e.g.\n                       configure_timeout, rename (Dict)\n                       Designed to reduce the number of function arguments!\n                       This is the simplest request object.\n    @param user_tags\n\n    @return            Boolean\n    \"\"\"\n    self.small_delay()\n    result = self.api.upload_album(photos, caption, upload_id, from_video, options=options, user_tags=user_tags)\n    if not result:\n        self.logger.info('Photos are not uploaded.')\n        return False\n    self.logger.info('Photo are uploaded.')\n    return result",
        "mutated": [
            "def upload_album(self, photos, caption=None, upload_id=None, from_video=False, options={}, user_tags=None):\n    if False:\n        i = 10\n    'Upload album to Instagram\\n\\n    @param photos      List of paths to photo files (List of strings)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags\\n\\n    @return            Boolean\\n    '\n    self.small_delay()\n    result = self.api.upload_album(photos, caption, upload_id, from_video, options=options, user_tags=user_tags)\n    if not result:\n        self.logger.info('Photos are not uploaded.')\n        return False\n    self.logger.info('Photo are uploaded.')\n    return result",
            "def upload_album(self, photos, caption=None, upload_id=None, from_video=False, options={}, user_tags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Upload album to Instagram\\n\\n    @param photos      List of paths to photo files (List of strings)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags\\n\\n    @return            Boolean\\n    '\n    self.small_delay()\n    result = self.api.upload_album(photos, caption, upload_id, from_video, options=options, user_tags=user_tags)\n    if not result:\n        self.logger.info('Photos are not uploaded.')\n        return False\n    self.logger.info('Photo are uploaded.')\n    return result",
            "def upload_album(self, photos, caption=None, upload_id=None, from_video=False, options={}, user_tags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Upload album to Instagram\\n\\n    @param photos      List of paths to photo files (List of strings)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags\\n\\n    @return            Boolean\\n    '\n    self.small_delay()\n    result = self.api.upload_album(photos, caption, upload_id, from_video, options=options, user_tags=user_tags)\n    if not result:\n        self.logger.info('Photos are not uploaded.')\n        return False\n    self.logger.info('Photo are uploaded.')\n    return result",
            "def upload_album(self, photos, caption=None, upload_id=None, from_video=False, options={}, user_tags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Upload album to Instagram\\n\\n    @param photos      List of paths to photo files (List of strings)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags\\n\\n    @return            Boolean\\n    '\n    self.small_delay()\n    result = self.api.upload_album(photos, caption, upload_id, from_video, options=options, user_tags=user_tags)\n    if not result:\n        self.logger.info('Photos are not uploaded.')\n        return False\n    self.logger.info('Photo are uploaded.')\n    return result",
            "def upload_album(self, photos, caption=None, upload_id=None, from_video=False, options={}, user_tags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Upload album to Instagram\\n\\n    @param photos      List of paths to photo files (List of strings)\\n    @param caption     Media description (String)\\n    @param upload_id   Unique upload_id (String). When None, then\\n                       generate automatically\\n    @param from_video  A flag that signals whether the photo is loaded from\\n                       the video or by itself (Boolean, DEPRECATED: not used)\\n    @param options     Object with difference options, e.g.\\n                       configure_timeout, rename (Dict)\\n                       Designed to reduce the number of function arguments!\\n                       This is the simplest request object.\\n    @param user_tags\\n\\n    @return            Boolean\\n    '\n    self.small_delay()\n    result = self.api.upload_album(photos, caption, upload_id, from_video, options=options, user_tags=user_tags)\n    if not result:\n        self.logger.info('Photos are not uploaded.')\n        return False\n    self.logger.info('Photo are uploaded.')\n    return result"
        ]
    },
    {
        "func_name": "download_photo",
        "original": "def download_photo(self, media_id, folder='photos', filename=None, save_description=False):\n    self.small_delay()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    if save_description:\n        media = self.get_media_info(media_id)[0]\n        caption = media['caption']['text'] if media['caption'] else ''\n        username = media['user']['username']\n        fname = os.path.join(folder, '{}_{}.txt'.format(username, media_id))\n        with open(fname, encoding='utf8', mode='w') as f:\n            f.write(caption)\n    try:\n        return self.api.download_photo(media_id, filename, False, folder)\n    except Exception:\n        self.logger.info('Media with `{}` is not downloaded.'.format(media_id))\n        return False",
        "mutated": [
            "def download_photo(self, media_id, folder='photos', filename=None, save_description=False):\n    if False:\n        i = 10\n    self.small_delay()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    if save_description:\n        media = self.get_media_info(media_id)[0]\n        caption = media['caption']['text'] if media['caption'] else ''\n        username = media['user']['username']\n        fname = os.path.join(folder, '{}_{}.txt'.format(username, media_id))\n        with open(fname, encoding='utf8', mode='w') as f:\n            f.write(caption)\n    try:\n        return self.api.download_photo(media_id, filename, False, folder)\n    except Exception:\n        self.logger.info('Media with `{}` is not downloaded.'.format(media_id))\n        return False",
            "def download_photo(self, media_id, folder='photos', filename=None, save_description=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.small_delay()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    if save_description:\n        media = self.get_media_info(media_id)[0]\n        caption = media['caption']['text'] if media['caption'] else ''\n        username = media['user']['username']\n        fname = os.path.join(folder, '{}_{}.txt'.format(username, media_id))\n        with open(fname, encoding='utf8', mode='w') as f:\n            f.write(caption)\n    try:\n        return self.api.download_photo(media_id, filename, False, folder)\n    except Exception:\n        self.logger.info('Media with `{}` is not downloaded.'.format(media_id))\n        return False",
            "def download_photo(self, media_id, folder='photos', filename=None, save_description=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.small_delay()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    if save_description:\n        media = self.get_media_info(media_id)[0]\n        caption = media['caption']['text'] if media['caption'] else ''\n        username = media['user']['username']\n        fname = os.path.join(folder, '{}_{}.txt'.format(username, media_id))\n        with open(fname, encoding='utf8', mode='w') as f:\n            f.write(caption)\n    try:\n        return self.api.download_photo(media_id, filename, False, folder)\n    except Exception:\n        self.logger.info('Media with `{}` is not downloaded.'.format(media_id))\n        return False",
            "def download_photo(self, media_id, folder='photos', filename=None, save_description=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.small_delay()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    if save_description:\n        media = self.get_media_info(media_id)[0]\n        caption = media['caption']['text'] if media['caption'] else ''\n        username = media['user']['username']\n        fname = os.path.join(folder, '{}_{}.txt'.format(username, media_id))\n        with open(fname, encoding='utf8', mode='w') as f:\n            f.write(caption)\n    try:\n        return self.api.download_photo(media_id, filename, False, folder)\n    except Exception:\n        self.logger.info('Media with `{}` is not downloaded.'.format(media_id))\n        return False",
            "def download_photo(self, media_id, folder='photos', filename=None, save_description=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.small_delay()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    if save_description:\n        media = self.get_media_info(media_id)[0]\n        caption = media['caption']['text'] if media['caption'] else ''\n        username = media['user']['username']\n        fname = os.path.join(folder, '{}_{}.txt'.format(username, media_id))\n        with open(fname, encoding='utf8', mode='w') as f:\n            f.write(caption)\n    try:\n        return self.api.download_photo(media_id, filename, False, folder)\n    except Exception:\n        self.logger.info('Media with `{}` is not downloaded.'.format(media_id))\n        return False"
        ]
    },
    {
        "func_name": "download_photos",
        "original": "def download_photos(self, medias, folder, save_description=False):\n    broken_items = []\n    if not medias:\n        self.logger.info('Nothing to downloads.')\n        return broken_items\n    self.logger.info('Going to download {} medias.'.format(len(medias)))\n    for media in tqdm(medias):\n        if not self.download_photo(media, folder, save_description=save_description):\n            self.error_delay()\n            broken_items = medias[medias.index(media):]\n    return broken_items",
        "mutated": [
            "def download_photos(self, medias, folder, save_description=False):\n    if False:\n        i = 10\n    broken_items = []\n    if not medias:\n        self.logger.info('Nothing to downloads.')\n        return broken_items\n    self.logger.info('Going to download {} medias.'.format(len(medias)))\n    for media in tqdm(medias):\n        if not self.download_photo(media, folder, save_description=save_description):\n            self.error_delay()\n            broken_items = medias[medias.index(media):]\n    return broken_items",
            "def download_photos(self, medias, folder, save_description=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    broken_items = []\n    if not medias:\n        self.logger.info('Nothing to downloads.')\n        return broken_items\n    self.logger.info('Going to download {} medias.'.format(len(medias)))\n    for media in tqdm(medias):\n        if not self.download_photo(media, folder, save_description=save_description):\n            self.error_delay()\n            broken_items = medias[medias.index(media):]\n    return broken_items",
            "def download_photos(self, medias, folder, save_description=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    broken_items = []\n    if not medias:\n        self.logger.info('Nothing to downloads.')\n        return broken_items\n    self.logger.info('Going to download {} medias.'.format(len(medias)))\n    for media in tqdm(medias):\n        if not self.download_photo(media, folder, save_description=save_description):\n            self.error_delay()\n            broken_items = medias[medias.index(media):]\n    return broken_items",
            "def download_photos(self, medias, folder, save_description=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    broken_items = []\n    if not medias:\n        self.logger.info('Nothing to downloads.')\n        return broken_items\n    self.logger.info('Going to download {} medias.'.format(len(medias)))\n    for media in tqdm(medias):\n        if not self.download_photo(media, folder, save_description=save_description):\n            self.error_delay()\n            broken_items = medias[medias.index(media):]\n    return broken_items",
            "def download_photos(self, medias, folder, save_description=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    broken_items = []\n    if not medias:\n        self.logger.info('Nothing to downloads.')\n        return broken_items\n    self.logger.info('Going to download {} medias.'.format(len(medias)))\n    for media in tqdm(medias):\n        if not self.download_photo(media, folder, save_description=save_description):\n            self.error_delay()\n            broken_items = medias[medias.index(media):]\n    return broken_items"
        ]
    }
]