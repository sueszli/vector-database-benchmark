[
    {
        "func_name": "constrain_cplex_infty",
        "original": "def constrain_cplex_infty(v) -> None:\n    \"\"\"\n    Limit values of vector v between +/- infinity as\n    defined in the CPLEX package\n    \"\"\"\n    import cplex as cpx\n    n = len(v)\n    for i in range(n):\n        if v[i] >= cpx.infinity:\n            v[i] = cpx.infinity\n        if v[i] <= -cpx.infinity:\n            v[i] = -cpx.infinity",
        "mutated": [
            "def constrain_cplex_infty(v) -> None:\n    if False:\n        i = 10\n    '\\n    Limit values of vector v between +/- infinity as\\n    defined in the CPLEX package\\n    '\n    import cplex as cpx\n    n = len(v)\n    for i in range(n):\n        if v[i] >= cpx.infinity:\n            v[i] = cpx.infinity\n        if v[i] <= -cpx.infinity:\n            v[i] = -cpx.infinity",
            "def constrain_cplex_infty(v) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Limit values of vector v between +/- infinity as\\n    defined in the CPLEX package\\n    '\n    import cplex as cpx\n    n = len(v)\n    for i in range(n):\n        if v[i] >= cpx.infinity:\n            v[i] = cpx.infinity\n        if v[i] <= -cpx.infinity:\n            v[i] = -cpx.infinity",
            "def constrain_cplex_infty(v) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Limit values of vector v between +/- infinity as\\n    defined in the CPLEX package\\n    '\n    import cplex as cpx\n    n = len(v)\n    for i in range(n):\n        if v[i] >= cpx.infinity:\n            v[i] = cpx.infinity\n        if v[i] <= -cpx.infinity:\n            v[i] = -cpx.infinity",
            "def constrain_cplex_infty(v) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Limit values of vector v between +/- infinity as\\n    defined in the CPLEX package\\n    '\n    import cplex as cpx\n    n = len(v)\n    for i in range(n):\n        if v[i] >= cpx.infinity:\n            v[i] = cpx.infinity\n        if v[i] <= -cpx.infinity:\n            v[i] = -cpx.infinity",
            "def constrain_cplex_infty(v) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Limit values of vector v between +/- infinity as\\n    defined in the CPLEX package\\n    '\n    import cplex as cpx\n    n = len(v)\n    for i in range(n):\n        if v[i] >= cpx.infinity:\n            v[i] = cpx.infinity\n        if v[i] <= -cpx.infinity:\n            v[i] = -cpx.infinity"
        ]
    },
    {
        "func_name": "name",
        "original": "def name(self):\n    return s.CPLEX",
        "mutated": [
            "def name(self):\n    if False:\n        i = 10\n    return s.CPLEX",
            "def name(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return s.CPLEX",
            "def name(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return s.CPLEX",
            "def name(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return s.CPLEX",
            "def name(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return s.CPLEX"
        ]
    },
    {
        "func_name": "import_solver",
        "original": "def import_solver(self) -> None:\n    import cplex\n    cplex",
        "mutated": [
            "def import_solver(self) -> None:\n    if False:\n        i = 10\n    import cplex\n    cplex",
            "def import_solver(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    import cplex\n    cplex",
            "def import_solver(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    import cplex\n    cplex",
            "def import_solver(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    import cplex\n    cplex",
            "def import_solver(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    import cplex\n    cplex"
        ]
    },
    {
        "func_name": "invert",
        "original": "def invert(self, results, inverse_data):\n    model = results['model']\n    attr = {}\n    if 'cputime' in results:\n        attr[s.SOLVE_TIME] = results['cputime']\n    attr[s.NUM_ITERS] = int(model.solution.progress.get_num_barrier_iterations()) if not inverse_data[CPLEX.IS_MIP] else 0\n    status = get_status(model)\n    if status in s.SOLUTION_PRESENT:\n        opt_val = model.solution.get_objective_value() + inverse_data[s.OFFSET]\n        x = np.array(model.solution.get_values())\n        primal_vars = {CPLEX.VAR_ID: intf.DEFAULT_INTF.const_to_matrix(np.array(x))}\n        dual_vars = None\n        if not inverse_data[CPLEX.IS_MIP]:\n            y = -np.array(model.solution.get_dual_values())\n            dual_vars = {CPLEX.DUAL_VAR_ID: y}\n        sol = Solution(status, opt_val, primal_vars, dual_vars, attr)\n    else:\n        sol = failure_solution(status, attr)\n    return sol",
        "mutated": [
            "def invert(self, results, inverse_data):\n    if False:\n        i = 10\n    model = results['model']\n    attr = {}\n    if 'cputime' in results:\n        attr[s.SOLVE_TIME] = results['cputime']\n    attr[s.NUM_ITERS] = int(model.solution.progress.get_num_barrier_iterations()) if not inverse_data[CPLEX.IS_MIP] else 0\n    status = get_status(model)\n    if status in s.SOLUTION_PRESENT:\n        opt_val = model.solution.get_objective_value() + inverse_data[s.OFFSET]\n        x = np.array(model.solution.get_values())\n        primal_vars = {CPLEX.VAR_ID: intf.DEFAULT_INTF.const_to_matrix(np.array(x))}\n        dual_vars = None\n        if not inverse_data[CPLEX.IS_MIP]:\n            y = -np.array(model.solution.get_dual_values())\n            dual_vars = {CPLEX.DUAL_VAR_ID: y}\n        sol = Solution(status, opt_val, primal_vars, dual_vars, attr)\n    else:\n        sol = failure_solution(status, attr)\n    return sol",
            "def invert(self, results, inverse_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    model = results['model']\n    attr = {}\n    if 'cputime' in results:\n        attr[s.SOLVE_TIME] = results['cputime']\n    attr[s.NUM_ITERS] = int(model.solution.progress.get_num_barrier_iterations()) if not inverse_data[CPLEX.IS_MIP] else 0\n    status = get_status(model)\n    if status in s.SOLUTION_PRESENT:\n        opt_val = model.solution.get_objective_value() + inverse_data[s.OFFSET]\n        x = np.array(model.solution.get_values())\n        primal_vars = {CPLEX.VAR_ID: intf.DEFAULT_INTF.const_to_matrix(np.array(x))}\n        dual_vars = None\n        if not inverse_data[CPLEX.IS_MIP]:\n            y = -np.array(model.solution.get_dual_values())\n            dual_vars = {CPLEX.DUAL_VAR_ID: y}\n        sol = Solution(status, opt_val, primal_vars, dual_vars, attr)\n    else:\n        sol = failure_solution(status, attr)\n    return sol",
            "def invert(self, results, inverse_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    model = results['model']\n    attr = {}\n    if 'cputime' in results:\n        attr[s.SOLVE_TIME] = results['cputime']\n    attr[s.NUM_ITERS] = int(model.solution.progress.get_num_barrier_iterations()) if not inverse_data[CPLEX.IS_MIP] else 0\n    status = get_status(model)\n    if status in s.SOLUTION_PRESENT:\n        opt_val = model.solution.get_objective_value() + inverse_data[s.OFFSET]\n        x = np.array(model.solution.get_values())\n        primal_vars = {CPLEX.VAR_ID: intf.DEFAULT_INTF.const_to_matrix(np.array(x))}\n        dual_vars = None\n        if not inverse_data[CPLEX.IS_MIP]:\n            y = -np.array(model.solution.get_dual_values())\n            dual_vars = {CPLEX.DUAL_VAR_ID: y}\n        sol = Solution(status, opt_val, primal_vars, dual_vars, attr)\n    else:\n        sol = failure_solution(status, attr)\n    return sol",
            "def invert(self, results, inverse_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    model = results['model']\n    attr = {}\n    if 'cputime' in results:\n        attr[s.SOLVE_TIME] = results['cputime']\n    attr[s.NUM_ITERS] = int(model.solution.progress.get_num_barrier_iterations()) if not inverse_data[CPLEX.IS_MIP] else 0\n    status = get_status(model)\n    if status in s.SOLUTION_PRESENT:\n        opt_val = model.solution.get_objective_value() + inverse_data[s.OFFSET]\n        x = np.array(model.solution.get_values())\n        primal_vars = {CPLEX.VAR_ID: intf.DEFAULT_INTF.const_to_matrix(np.array(x))}\n        dual_vars = None\n        if not inverse_data[CPLEX.IS_MIP]:\n            y = -np.array(model.solution.get_dual_values())\n            dual_vars = {CPLEX.DUAL_VAR_ID: y}\n        sol = Solution(status, opt_val, primal_vars, dual_vars, attr)\n    else:\n        sol = failure_solution(status, attr)\n    return sol",
            "def invert(self, results, inverse_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    model = results['model']\n    attr = {}\n    if 'cputime' in results:\n        attr[s.SOLVE_TIME] = results['cputime']\n    attr[s.NUM_ITERS] = int(model.solution.progress.get_num_barrier_iterations()) if not inverse_data[CPLEX.IS_MIP] else 0\n    status = get_status(model)\n    if status in s.SOLUTION_PRESENT:\n        opt_val = model.solution.get_objective_value() + inverse_data[s.OFFSET]\n        x = np.array(model.solution.get_values())\n        primal_vars = {CPLEX.VAR_ID: intf.DEFAULT_INTF.const_to_matrix(np.array(x))}\n        dual_vars = None\n        if not inverse_data[CPLEX.IS_MIP]:\n            y = -np.array(model.solution.get_dual_values())\n            dual_vars = {CPLEX.DUAL_VAR_ID: y}\n        sol = Solution(status, opt_val, primal_vars, dual_vars, attr)\n    else:\n        sol = failure_solution(status, attr)\n    return sol"
        ]
    },
    {
        "func_name": "solve_via_data",
        "original": "def solve_via_data(self, data, warm_start: bool, verbose: bool, solver_opts, solver_cache=None):\n    import cplex as cpx\n    P = data[s.P].tocsr()\n    q = data[s.Q]\n    A = data[s.A].tocsr()\n    b = data[s.B]\n    F = data[s.F].tocsr()\n    g = data[s.G]\n    n_var = data['n_var']\n    n_eq = data['n_eq']\n    n_ineq = data['n_ineq']\n    constrain_cplex_infty(b)\n    constrain_cplex_infty(g)\n    model = cpx.Cplex()\n    model.objective.set_sense(model.objective.sense.minimize)\n    var_idx = list(model.variables.add(obj=q, lb=-cpx.infinity * np.ones(n_var), ub=cpx.infinity * np.ones(n_var)))\n    for i in data[s.BOOL_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.binary)\n    for i in data[s.INT_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.integer)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_eq):\n        start = A.indptr[i]\n        end = A.indptr[i + 1]\n        lin_expr.append([A.indices[start:end].tolist(), A.data[start:end].tolist()])\n        rhs.append(b[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['E'] * len(lin_expr), rhs=rhs)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_ineq):\n        start = F.indptr[i]\n        end = F.indptr[i + 1]\n        lin_expr.append([F.indices[start:end].tolist(), F.data[start:end].tolist()])\n        rhs.append(g[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['L'] * len(lin_expr), rhs=rhs)\n    if P.count_nonzero():\n        qmat = []\n        for i in range(n_var):\n            start = P.indptr[i]\n            end = P.indptr[i + 1]\n            qmat.append([P.indices[start:end].tolist(), P.data[start:end].tolist()])\n        model.objective.set_quadratic(qmat)\n    if not verbose:\n        hide_solver_output(model)\n    reoptimize = solver_opts.pop('reoptimize', False)\n    set_parameters(model, solver_opts)\n    results_dict = {}\n    try:\n        start = model.get_time()\n        model.solve()\n        end = model.get_time()\n        results_dict['cputime'] = end - start\n        ambiguous_status = get_status(model) == s.INFEASIBLE_OR_UNBOUNDED\n        if ambiguous_status and reoptimize:\n            model.parameters.preprocessing.presolve.set(0)\n            start_time = model.get_time()\n            model.solve()\n            results_dict['cputime'] += model.get_time() - start_time\n    except Exception:\n        results_dict['status'] = s.SOLVER_ERROR\n    results_dict['model'] = model\n    return results_dict",
        "mutated": [
            "def solve_via_data(self, data, warm_start: bool, verbose: bool, solver_opts, solver_cache=None):\n    if False:\n        i = 10\n    import cplex as cpx\n    P = data[s.P].tocsr()\n    q = data[s.Q]\n    A = data[s.A].tocsr()\n    b = data[s.B]\n    F = data[s.F].tocsr()\n    g = data[s.G]\n    n_var = data['n_var']\n    n_eq = data['n_eq']\n    n_ineq = data['n_ineq']\n    constrain_cplex_infty(b)\n    constrain_cplex_infty(g)\n    model = cpx.Cplex()\n    model.objective.set_sense(model.objective.sense.minimize)\n    var_idx = list(model.variables.add(obj=q, lb=-cpx.infinity * np.ones(n_var), ub=cpx.infinity * np.ones(n_var)))\n    for i in data[s.BOOL_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.binary)\n    for i in data[s.INT_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.integer)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_eq):\n        start = A.indptr[i]\n        end = A.indptr[i + 1]\n        lin_expr.append([A.indices[start:end].tolist(), A.data[start:end].tolist()])\n        rhs.append(b[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['E'] * len(lin_expr), rhs=rhs)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_ineq):\n        start = F.indptr[i]\n        end = F.indptr[i + 1]\n        lin_expr.append([F.indices[start:end].tolist(), F.data[start:end].tolist()])\n        rhs.append(g[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['L'] * len(lin_expr), rhs=rhs)\n    if P.count_nonzero():\n        qmat = []\n        for i in range(n_var):\n            start = P.indptr[i]\n            end = P.indptr[i + 1]\n            qmat.append([P.indices[start:end].tolist(), P.data[start:end].tolist()])\n        model.objective.set_quadratic(qmat)\n    if not verbose:\n        hide_solver_output(model)\n    reoptimize = solver_opts.pop('reoptimize', False)\n    set_parameters(model, solver_opts)\n    results_dict = {}\n    try:\n        start = model.get_time()\n        model.solve()\n        end = model.get_time()\n        results_dict['cputime'] = end - start\n        ambiguous_status = get_status(model) == s.INFEASIBLE_OR_UNBOUNDED\n        if ambiguous_status and reoptimize:\n            model.parameters.preprocessing.presolve.set(0)\n            start_time = model.get_time()\n            model.solve()\n            results_dict['cputime'] += model.get_time() - start_time\n    except Exception:\n        results_dict['status'] = s.SOLVER_ERROR\n    results_dict['model'] = model\n    return results_dict",
            "def solve_via_data(self, data, warm_start: bool, verbose: bool, solver_opts, solver_cache=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    import cplex as cpx\n    P = data[s.P].tocsr()\n    q = data[s.Q]\n    A = data[s.A].tocsr()\n    b = data[s.B]\n    F = data[s.F].tocsr()\n    g = data[s.G]\n    n_var = data['n_var']\n    n_eq = data['n_eq']\n    n_ineq = data['n_ineq']\n    constrain_cplex_infty(b)\n    constrain_cplex_infty(g)\n    model = cpx.Cplex()\n    model.objective.set_sense(model.objective.sense.minimize)\n    var_idx = list(model.variables.add(obj=q, lb=-cpx.infinity * np.ones(n_var), ub=cpx.infinity * np.ones(n_var)))\n    for i in data[s.BOOL_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.binary)\n    for i in data[s.INT_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.integer)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_eq):\n        start = A.indptr[i]\n        end = A.indptr[i + 1]\n        lin_expr.append([A.indices[start:end].tolist(), A.data[start:end].tolist()])\n        rhs.append(b[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['E'] * len(lin_expr), rhs=rhs)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_ineq):\n        start = F.indptr[i]\n        end = F.indptr[i + 1]\n        lin_expr.append([F.indices[start:end].tolist(), F.data[start:end].tolist()])\n        rhs.append(g[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['L'] * len(lin_expr), rhs=rhs)\n    if P.count_nonzero():\n        qmat = []\n        for i in range(n_var):\n            start = P.indptr[i]\n            end = P.indptr[i + 1]\n            qmat.append([P.indices[start:end].tolist(), P.data[start:end].tolist()])\n        model.objective.set_quadratic(qmat)\n    if not verbose:\n        hide_solver_output(model)\n    reoptimize = solver_opts.pop('reoptimize', False)\n    set_parameters(model, solver_opts)\n    results_dict = {}\n    try:\n        start = model.get_time()\n        model.solve()\n        end = model.get_time()\n        results_dict['cputime'] = end - start\n        ambiguous_status = get_status(model) == s.INFEASIBLE_OR_UNBOUNDED\n        if ambiguous_status and reoptimize:\n            model.parameters.preprocessing.presolve.set(0)\n            start_time = model.get_time()\n            model.solve()\n            results_dict['cputime'] += model.get_time() - start_time\n    except Exception:\n        results_dict['status'] = s.SOLVER_ERROR\n    results_dict['model'] = model\n    return results_dict",
            "def solve_via_data(self, data, warm_start: bool, verbose: bool, solver_opts, solver_cache=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    import cplex as cpx\n    P = data[s.P].tocsr()\n    q = data[s.Q]\n    A = data[s.A].tocsr()\n    b = data[s.B]\n    F = data[s.F].tocsr()\n    g = data[s.G]\n    n_var = data['n_var']\n    n_eq = data['n_eq']\n    n_ineq = data['n_ineq']\n    constrain_cplex_infty(b)\n    constrain_cplex_infty(g)\n    model = cpx.Cplex()\n    model.objective.set_sense(model.objective.sense.minimize)\n    var_idx = list(model.variables.add(obj=q, lb=-cpx.infinity * np.ones(n_var), ub=cpx.infinity * np.ones(n_var)))\n    for i in data[s.BOOL_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.binary)\n    for i in data[s.INT_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.integer)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_eq):\n        start = A.indptr[i]\n        end = A.indptr[i + 1]\n        lin_expr.append([A.indices[start:end].tolist(), A.data[start:end].tolist()])\n        rhs.append(b[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['E'] * len(lin_expr), rhs=rhs)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_ineq):\n        start = F.indptr[i]\n        end = F.indptr[i + 1]\n        lin_expr.append([F.indices[start:end].tolist(), F.data[start:end].tolist()])\n        rhs.append(g[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['L'] * len(lin_expr), rhs=rhs)\n    if P.count_nonzero():\n        qmat = []\n        for i in range(n_var):\n            start = P.indptr[i]\n            end = P.indptr[i + 1]\n            qmat.append([P.indices[start:end].tolist(), P.data[start:end].tolist()])\n        model.objective.set_quadratic(qmat)\n    if not verbose:\n        hide_solver_output(model)\n    reoptimize = solver_opts.pop('reoptimize', False)\n    set_parameters(model, solver_opts)\n    results_dict = {}\n    try:\n        start = model.get_time()\n        model.solve()\n        end = model.get_time()\n        results_dict['cputime'] = end - start\n        ambiguous_status = get_status(model) == s.INFEASIBLE_OR_UNBOUNDED\n        if ambiguous_status and reoptimize:\n            model.parameters.preprocessing.presolve.set(0)\n            start_time = model.get_time()\n            model.solve()\n            results_dict['cputime'] += model.get_time() - start_time\n    except Exception:\n        results_dict['status'] = s.SOLVER_ERROR\n    results_dict['model'] = model\n    return results_dict",
            "def solve_via_data(self, data, warm_start: bool, verbose: bool, solver_opts, solver_cache=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    import cplex as cpx\n    P = data[s.P].tocsr()\n    q = data[s.Q]\n    A = data[s.A].tocsr()\n    b = data[s.B]\n    F = data[s.F].tocsr()\n    g = data[s.G]\n    n_var = data['n_var']\n    n_eq = data['n_eq']\n    n_ineq = data['n_ineq']\n    constrain_cplex_infty(b)\n    constrain_cplex_infty(g)\n    model = cpx.Cplex()\n    model.objective.set_sense(model.objective.sense.minimize)\n    var_idx = list(model.variables.add(obj=q, lb=-cpx.infinity * np.ones(n_var), ub=cpx.infinity * np.ones(n_var)))\n    for i in data[s.BOOL_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.binary)\n    for i in data[s.INT_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.integer)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_eq):\n        start = A.indptr[i]\n        end = A.indptr[i + 1]\n        lin_expr.append([A.indices[start:end].tolist(), A.data[start:end].tolist()])\n        rhs.append(b[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['E'] * len(lin_expr), rhs=rhs)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_ineq):\n        start = F.indptr[i]\n        end = F.indptr[i + 1]\n        lin_expr.append([F.indices[start:end].tolist(), F.data[start:end].tolist()])\n        rhs.append(g[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['L'] * len(lin_expr), rhs=rhs)\n    if P.count_nonzero():\n        qmat = []\n        for i in range(n_var):\n            start = P.indptr[i]\n            end = P.indptr[i + 1]\n            qmat.append([P.indices[start:end].tolist(), P.data[start:end].tolist()])\n        model.objective.set_quadratic(qmat)\n    if not verbose:\n        hide_solver_output(model)\n    reoptimize = solver_opts.pop('reoptimize', False)\n    set_parameters(model, solver_opts)\n    results_dict = {}\n    try:\n        start = model.get_time()\n        model.solve()\n        end = model.get_time()\n        results_dict['cputime'] = end - start\n        ambiguous_status = get_status(model) == s.INFEASIBLE_OR_UNBOUNDED\n        if ambiguous_status and reoptimize:\n            model.parameters.preprocessing.presolve.set(0)\n            start_time = model.get_time()\n            model.solve()\n            results_dict['cputime'] += model.get_time() - start_time\n    except Exception:\n        results_dict['status'] = s.SOLVER_ERROR\n    results_dict['model'] = model\n    return results_dict",
            "def solve_via_data(self, data, warm_start: bool, verbose: bool, solver_opts, solver_cache=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    import cplex as cpx\n    P = data[s.P].tocsr()\n    q = data[s.Q]\n    A = data[s.A].tocsr()\n    b = data[s.B]\n    F = data[s.F].tocsr()\n    g = data[s.G]\n    n_var = data['n_var']\n    n_eq = data['n_eq']\n    n_ineq = data['n_ineq']\n    constrain_cplex_infty(b)\n    constrain_cplex_infty(g)\n    model = cpx.Cplex()\n    model.objective.set_sense(model.objective.sense.minimize)\n    var_idx = list(model.variables.add(obj=q, lb=-cpx.infinity * np.ones(n_var), ub=cpx.infinity * np.ones(n_var)))\n    for i in data[s.BOOL_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.binary)\n    for i in data[s.INT_IDX]:\n        model.variables.set_types(var_idx[i], model.variables.type.integer)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_eq):\n        start = A.indptr[i]\n        end = A.indptr[i + 1]\n        lin_expr.append([A.indices[start:end].tolist(), A.data[start:end].tolist()])\n        rhs.append(b[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['E'] * len(lin_expr), rhs=rhs)\n    (lin_expr, rhs) = ([], [])\n    for i in range(n_ineq):\n        start = F.indptr[i]\n        end = F.indptr[i + 1]\n        lin_expr.append([F.indices[start:end].tolist(), F.data[start:end].tolist()])\n        rhs.append(g[i])\n    if lin_expr:\n        model.linear_constraints.add(lin_expr=lin_expr, senses=['L'] * len(lin_expr), rhs=rhs)\n    if P.count_nonzero():\n        qmat = []\n        for i in range(n_var):\n            start = P.indptr[i]\n            end = P.indptr[i + 1]\n            qmat.append([P.indices[start:end].tolist(), P.data[start:end].tolist()])\n        model.objective.set_quadratic(qmat)\n    if not verbose:\n        hide_solver_output(model)\n    reoptimize = solver_opts.pop('reoptimize', False)\n    set_parameters(model, solver_opts)\n    results_dict = {}\n    try:\n        start = model.get_time()\n        model.solve()\n        end = model.get_time()\n        results_dict['cputime'] = end - start\n        ambiguous_status = get_status(model) == s.INFEASIBLE_OR_UNBOUNDED\n        if ambiguous_status and reoptimize:\n            model.parameters.preprocessing.presolve.set(0)\n            start_time = model.get_time()\n            model.solve()\n            results_dict['cputime'] += model.get_time() - start_time\n    except Exception:\n        results_dict['status'] = s.SOLVER_ERROR\n    results_dict['model'] = model\n    return results_dict"
        ]
    }
]