[
    {
        "func_name": "options",
        "original": "def options(self, context, module_options):\n    \"\"\"\n        add-computer: Specify add-computer to call the module using smb\n        NAME: Specify the NAME option to name the Computer to be added\n        PASSWORD: Specify the PASSWORD option to supply a password for the Computer to be added\n        DELETE: Specify DELETE to remove a Computer\n        CHANGEPW: Specify CHANGEPW to modify a Computer password\n        Usage: cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password1\"\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" DELETE=True\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password2\" CHANGEPW=True\n        \"\"\"\n    self.__baseDN = None\n    self.__computerGroup = None\n    self.__method = 'SAMR'\n    self.__noAdd = False\n    self.__delete = False\n    self.noLDAPRequired = False\n    if 'DELETE' in module_options:\n        self.__delete = True\n    if 'CHANGEPW' in module_options and ('NAME' not in module_options or 'PASSWORD' not in module_options):\n        context.log.error('NAME  and PASSWORD options are required!')\n    elif 'CHANGEPW' in module_options:\n        self.__noAdd = True\n    if 'NAME' in module_options:\n        self.__computerName = module_options['NAME']\n        if self.__computerName[-1] != '$':\n            self.__computerName += '$'\n    else:\n        context.log.error('NAME option is required!')\n        exit(1)\n    if 'PASSWORD' in module_options:\n        self.__computerPassword = module_options['PASSWORD']\n    elif 'PASSWORD' not in module_options and (not self.__delete):\n        context.log.error('PASSWORD option is required!')\n        exit(1)",
        "mutated": [
            "def options(self, context, module_options):\n    if False:\n        i = 10\n    '\\n        add-computer: Specify add-computer to call the module using smb\\n        NAME: Specify the NAME option to name the Computer to be added\\n        PASSWORD: Specify the PASSWORD option to supply a password for the Computer to be added\\n        DELETE: Specify DELETE to remove a Computer\\n        CHANGEPW: Specify CHANGEPW to modify a Computer password\\n        Usage: cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password1\"\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" DELETE=True\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password2\" CHANGEPW=True\\n        '\n    self.__baseDN = None\n    self.__computerGroup = None\n    self.__method = 'SAMR'\n    self.__noAdd = False\n    self.__delete = False\n    self.noLDAPRequired = False\n    if 'DELETE' in module_options:\n        self.__delete = True\n    if 'CHANGEPW' in module_options and ('NAME' not in module_options or 'PASSWORD' not in module_options):\n        context.log.error('NAME  and PASSWORD options are required!')\n    elif 'CHANGEPW' in module_options:\n        self.__noAdd = True\n    if 'NAME' in module_options:\n        self.__computerName = module_options['NAME']\n        if self.__computerName[-1] != '$':\n            self.__computerName += '$'\n    else:\n        context.log.error('NAME option is required!')\n        exit(1)\n    if 'PASSWORD' in module_options:\n        self.__computerPassword = module_options['PASSWORD']\n    elif 'PASSWORD' not in module_options and (not self.__delete):\n        context.log.error('PASSWORD option is required!')\n        exit(1)",
            "def options(self, context, module_options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        add-computer: Specify add-computer to call the module using smb\\n        NAME: Specify the NAME option to name the Computer to be added\\n        PASSWORD: Specify the PASSWORD option to supply a password for the Computer to be added\\n        DELETE: Specify DELETE to remove a Computer\\n        CHANGEPW: Specify CHANGEPW to modify a Computer password\\n        Usage: cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password1\"\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" DELETE=True\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password2\" CHANGEPW=True\\n        '\n    self.__baseDN = None\n    self.__computerGroup = None\n    self.__method = 'SAMR'\n    self.__noAdd = False\n    self.__delete = False\n    self.noLDAPRequired = False\n    if 'DELETE' in module_options:\n        self.__delete = True\n    if 'CHANGEPW' in module_options and ('NAME' not in module_options or 'PASSWORD' not in module_options):\n        context.log.error('NAME  and PASSWORD options are required!')\n    elif 'CHANGEPW' in module_options:\n        self.__noAdd = True\n    if 'NAME' in module_options:\n        self.__computerName = module_options['NAME']\n        if self.__computerName[-1] != '$':\n            self.__computerName += '$'\n    else:\n        context.log.error('NAME option is required!')\n        exit(1)\n    if 'PASSWORD' in module_options:\n        self.__computerPassword = module_options['PASSWORD']\n    elif 'PASSWORD' not in module_options and (not self.__delete):\n        context.log.error('PASSWORD option is required!')\n        exit(1)",
            "def options(self, context, module_options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        add-computer: Specify add-computer to call the module using smb\\n        NAME: Specify the NAME option to name the Computer to be added\\n        PASSWORD: Specify the PASSWORD option to supply a password for the Computer to be added\\n        DELETE: Specify DELETE to remove a Computer\\n        CHANGEPW: Specify CHANGEPW to modify a Computer password\\n        Usage: cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password1\"\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" DELETE=True\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password2\" CHANGEPW=True\\n        '\n    self.__baseDN = None\n    self.__computerGroup = None\n    self.__method = 'SAMR'\n    self.__noAdd = False\n    self.__delete = False\n    self.noLDAPRequired = False\n    if 'DELETE' in module_options:\n        self.__delete = True\n    if 'CHANGEPW' in module_options and ('NAME' not in module_options or 'PASSWORD' not in module_options):\n        context.log.error('NAME  and PASSWORD options are required!')\n    elif 'CHANGEPW' in module_options:\n        self.__noAdd = True\n    if 'NAME' in module_options:\n        self.__computerName = module_options['NAME']\n        if self.__computerName[-1] != '$':\n            self.__computerName += '$'\n    else:\n        context.log.error('NAME option is required!')\n        exit(1)\n    if 'PASSWORD' in module_options:\n        self.__computerPassword = module_options['PASSWORD']\n    elif 'PASSWORD' not in module_options and (not self.__delete):\n        context.log.error('PASSWORD option is required!')\n        exit(1)",
            "def options(self, context, module_options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        add-computer: Specify add-computer to call the module using smb\\n        NAME: Specify the NAME option to name the Computer to be added\\n        PASSWORD: Specify the PASSWORD option to supply a password for the Computer to be added\\n        DELETE: Specify DELETE to remove a Computer\\n        CHANGEPW: Specify CHANGEPW to modify a Computer password\\n        Usage: cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password1\"\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" DELETE=True\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password2\" CHANGEPW=True\\n        '\n    self.__baseDN = None\n    self.__computerGroup = None\n    self.__method = 'SAMR'\n    self.__noAdd = False\n    self.__delete = False\n    self.noLDAPRequired = False\n    if 'DELETE' in module_options:\n        self.__delete = True\n    if 'CHANGEPW' in module_options and ('NAME' not in module_options or 'PASSWORD' not in module_options):\n        context.log.error('NAME  and PASSWORD options are required!')\n    elif 'CHANGEPW' in module_options:\n        self.__noAdd = True\n    if 'NAME' in module_options:\n        self.__computerName = module_options['NAME']\n        if self.__computerName[-1] != '$':\n            self.__computerName += '$'\n    else:\n        context.log.error('NAME option is required!')\n        exit(1)\n    if 'PASSWORD' in module_options:\n        self.__computerPassword = module_options['PASSWORD']\n    elif 'PASSWORD' not in module_options and (not self.__delete):\n        context.log.error('PASSWORD option is required!')\n        exit(1)",
            "def options(self, context, module_options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        add-computer: Specify add-computer to call the module using smb\\n        NAME: Specify the NAME option to name the Computer to be added\\n        PASSWORD: Specify the PASSWORD option to supply a password for the Computer to be added\\n        DELETE: Specify DELETE to remove a Computer\\n        CHANGEPW: Specify CHANGEPW to modify a Computer password\\n        Usage: cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password1\"\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" DELETE=True\\n               cme smb $DC-IP -u Username -p Password -M add-computer -o NAME=\"BADPC\" PASSWORD=\"Password2\" CHANGEPW=True\\n        '\n    self.__baseDN = None\n    self.__computerGroup = None\n    self.__method = 'SAMR'\n    self.__noAdd = False\n    self.__delete = False\n    self.noLDAPRequired = False\n    if 'DELETE' in module_options:\n        self.__delete = True\n    if 'CHANGEPW' in module_options and ('NAME' not in module_options or 'PASSWORD' not in module_options):\n        context.log.error('NAME  and PASSWORD options are required!')\n    elif 'CHANGEPW' in module_options:\n        self.__noAdd = True\n    if 'NAME' in module_options:\n        self.__computerName = module_options['NAME']\n        if self.__computerName[-1] != '$':\n            self.__computerName += '$'\n    else:\n        context.log.error('NAME option is required!')\n        exit(1)\n    if 'PASSWORD' in module_options:\n        self.__computerPassword = module_options['PASSWORD']\n    elif 'PASSWORD' not in module_options and (not self.__delete):\n        context.log.error('PASSWORD option is required!')\n        exit(1)"
        ]
    },
    {
        "func_name": "on_login",
        "original": "def on_login(self, context, connection):\n    self.__domain = connection.domain\n    self.__domainNetbios = connection.domain\n    self.__kdcHost = connection.hostname + '.' + connection.domain\n    self.__target = self.__kdcHost\n    self.__username = connection.username\n    self.__password = connection.password\n    self.__targetIp = connection.host\n    self.__port = context.smb_server_port\n    self.__aesKey = context.aesKey\n    self.__hashes = context.hash\n    self.__doKerberos = connection.kerberos\n    self.__nthash = ''\n    self.__lmhash = ''\n    if context.hash and ':' in context.hash[0]:\n        hashList = context.hash[0].split(':')\n        self.__nthash = hashList[-1]\n        self.__lmhash = hashList[0]\n    elif context.hash and ':' not in context.hash[0]:\n        self.__nthash = context.hash[0]\n        self.__lmhash = '00000000000000000000000000000000'\n    self.doSAMRAdd(context)\n    if not self.noLDAPRequired:\n        self.doLDAPSAdd(connection, context)\n    else:\n        exit(1)",
        "mutated": [
            "def on_login(self, context, connection):\n    if False:\n        i = 10\n    self.__domain = connection.domain\n    self.__domainNetbios = connection.domain\n    self.__kdcHost = connection.hostname + '.' + connection.domain\n    self.__target = self.__kdcHost\n    self.__username = connection.username\n    self.__password = connection.password\n    self.__targetIp = connection.host\n    self.__port = context.smb_server_port\n    self.__aesKey = context.aesKey\n    self.__hashes = context.hash\n    self.__doKerberos = connection.kerberos\n    self.__nthash = ''\n    self.__lmhash = ''\n    if context.hash and ':' in context.hash[0]:\n        hashList = context.hash[0].split(':')\n        self.__nthash = hashList[-1]\n        self.__lmhash = hashList[0]\n    elif context.hash and ':' not in context.hash[0]:\n        self.__nthash = context.hash[0]\n        self.__lmhash = '00000000000000000000000000000000'\n    self.doSAMRAdd(context)\n    if not self.noLDAPRequired:\n        self.doLDAPSAdd(connection, context)\n    else:\n        exit(1)",
            "def on_login(self, context, connection):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__domain = connection.domain\n    self.__domainNetbios = connection.domain\n    self.__kdcHost = connection.hostname + '.' + connection.domain\n    self.__target = self.__kdcHost\n    self.__username = connection.username\n    self.__password = connection.password\n    self.__targetIp = connection.host\n    self.__port = context.smb_server_port\n    self.__aesKey = context.aesKey\n    self.__hashes = context.hash\n    self.__doKerberos = connection.kerberos\n    self.__nthash = ''\n    self.__lmhash = ''\n    if context.hash and ':' in context.hash[0]:\n        hashList = context.hash[0].split(':')\n        self.__nthash = hashList[-1]\n        self.__lmhash = hashList[0]\n    elif context.hash and ':' not in context.hash[0]:\n        self.__nthash = context.hash[0]\n        self.__lmhash = '00000000000000000000000000000000'\n    self.doSAMRAdd(context)\n    if not self.noLDAPRequired:\n        self.doLDAPSAdd(connection, context)\n    else:\n        exit(1)",
            "def on_login(self, context, connection):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__domain = connection.domain\n    self.__domainNetbios = connection.domain\n    self.__kdcHost = connection.hostname + '.' + connection.domain\n    self.__target = self.__kdcHost\n    self.__username = connection.username\n    self.__password = connection.password\n    self.__targetIp = connection.host\n    self.__port = context.smb_server_port\n    self.__aesKey = context.aesKey\n    self.__hashes = context.hash\n    self.__doKerberos = connection.kerberos\n    self.__nthash = ''\n    self.__lmhash = ''\n    if context.hash and ':' in context.hash[0]:\n        hashList = context.hash[0].split(':')\n        self.__nthash = hashList[-1]\n        self.__lmhash = hashList[0]\n    elif context.hash and ':' not in context.hash[0]:\n        self.__nthash = context.hash[0]\n        self.__lmhash = '00000000000000000000000000000000'\n    self.doSAMRAdd(context)\n    if not self.noLDAPRequired:\n        self.doLDAPSAdd(connection, context)\n    else:\n        exit(1)",
            "def on_login(self, context, connection):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__domain = connection.domain\n    self.__domainNetbios = connection.domain\n    self.__kdcHost = connection.hostname + '.' + connection.domain\n    self.__target = self.__kdcHost\n    self.__username = connection.username\n    self.__password = connection.password\n    self.__targetIp = connection.host\n    self.__port = context.smb_server_port\n    self.__aesKey = context.aesKey\n    self.__hashes = context.hash\n    self.__doKerberos = connection.kerberos\n    self.__nthash = ''\n    self.__lmhash = ''\n    if context.hash and ':' in context.hash[0]:\n        hashList = context.hash[0].split(':')\n        self.__nthash = hashList[-1]\n        self.__lmhash = hashList[0]\n    elif context.hash and ':' not in context.hash[0]:\n        self.__nthash = context.hash[0]\n        self.__lmhash = '00000000000000000000000000000000'\n    self.doSAMRAdd(context)\n    if not self.noLDAPRequired:\n        self.doLDAPSAdd(connection, context)\n    else:\n        exit(1)",
            "def on_login(self, context, connection):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__domain = connection.domain\n    self.__domainNetbios = connection.domain\n    self.__kdcHost = connection.hostname + '.' + connection.domain\n    self.__target = self.__kdcHost\n    self.__username = connection.username\n    self.__password = connection.password\n    self.__targetIp = connection.host\n    self.__port = context.smb_server_port\n    self.__aesKey = context.aesKey\n    self.__hashes = context.hash\n    self.__doKerberos = connection.kerberos\n    self.__nthash = ''\n    self.__lmhash = ''\n    if context.hash and ':' in context.hash[0]:\n        hashList = context.hash[0].split(':')\n        self.__nthash = hashList[-1]\n        self.__lmhash = hashList[0]\n    elif context.hash and ':' not in context.hash[0]:\n        self.__nthash = context.hash[0]\n        self.__lmhash = '00000000000000000000000000000000'\n    self.doSAMRAdd(context)\n    if not self.noLDAPRequired:\n        self.doLDAPSAdd(connection, context)\n    else:\n        exit(1)"
        ]
    },
    {
        "func_name": "doSAMRAdd",
        "original": "def doSAMRAdd(self, context):\n    if self.__targetIp is not None:\n        stringBinding = epm.hept_map(self.__targetIp, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    else:\n        stringBinding = epm.hept_map(self.__target, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    rpctransport = transport.DCERPCTransportFactory(stringBinding)\n    rpctransport.set_dport(self.__port)\n    if self.__targetIp is not None:\n        rpctransport.setRemoteHost(self.__targetIp)\n        rpctransport.setRemoteName(self.__target)\n    if hasattr(rpctransport, 'set_credentials'):\n        rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey)\n    rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)\n    dce = rpctransport.get_dce_rpc()\n    servHandle = None\n    domainHandle = None\n    userHandle = None\n    try:\n        dce.connect()\n        dce.bind(samr.MSRPC_UUID_SAMR)\n        samrConnectResponse = samr.hSamrConnect5(dce, '\\\\\\\\%s\\x00' % self.__target, samr.SAM_SERVER_ENUMERATE_DOMAINS | samr.SAM_SERVER_LOOKUP_DOMAIN)\n        servHandle = samrConnectResponse['ServerHandle']\n        samrEnumResponse = samr.hSamrEnumerateDomainsInSamServer(dce, servHandle)\n        domains = samrEnumResponse['Buffer']['Buffer']\n        domainsWithoutBuiltin = list(filter(lambda x: x['Name'].lower() != 'builtin', domains))\n        if len(domainsWithoutBuiltin) > 1:\n            domain = list(filter(lambda x: x['Name'].lower() == self.__domainNetbios, domains))\n            if len(domain) != 1:\n                context.log.highlight(u'{}'.format('This domain does not exist: \"' + self.__domainNetbios + '\"'))\n                logging.critical('Available domain(s):')\n                for domain in domains:\n                    logging.error(' * %s' % domain['Name'])\n                raise Exception()\n            else:\n                selectedDomain = domain[0]['Name']\n        else:\n            selectedDomain = domainsWithoutBuiltin[0]['Name']\n        samrLookupDomainResponse = samr.hSamrLookupDomainInSamServer(dce, servHandle, selectedDomain)\n        domainSID = samrLookupDomainResponse['DomainId']\n        if logging.getLogger().level == logging.DEBUG:\n            logging.info('Opening domain %s...' % selectedDomain)\n        samrOpenDomainResponse = samr.hSamrOpenDomain(dce, servHandle, samr.DOMAIN_LOOKUP | samr.DOMAIN_CREATE_USER, domainSID)\n        domainHandle = samrOpenDomainResponse['DomainHandle']\n        if self.__noAdd or self.__delete:\n            try:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225587:\n                    context.log.highlight(u'{}'.format(self.__computerName + ' not found in domain ' + selectedDomain))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n            userRID = checkForUser['RelativeIds']['Element'][0]\n            if self.__delete:\n                access = samr.DELETE\n                message = 'delete'\n            else:\n                access = samr.USER_FORCE_PASSWORD_CHANGE\n                message = 'set the password for'\n            try:\n                openUser = samr.hSamrOpenUser(dce, domainHandle, access, userRID)\n                userHandle = openUser['UserHandle']\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format(self.__username + ' does not have the right to ' + message + ' ' + self.__computerName))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n        else:\n            if self.__computerName is not None:\n                try:\n                    checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    self.noLDAPRequired = True\n                    context.log.highlight(u'{}'.format('Computer account already exists with the name: \"' + self.__computerName + '\"'))\n                    raise Exception()\n                except samr.DCERPCSessionError as e:\n                    if e.error_code != 3221225587:\n                        raise\n            else:\n                foundUnused = False\n                while not foundUnused:\n                    self.__computerName = self.generateComputerName()\n                    try:\n                        checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    except samr.DCERPCSessionError as e:\n                        if e.error_code == 3221225587:\n                            foundUnused = True\n                        else:\n                            raise\n            try:\n                createUser = samr.hSamrCreateUser2InDomain(dce, domainHandle, self.__computerName, samr.USER_WORKSTATION_TRUST_ACCOUNT, samr.USER_FORCE_PASSWORD_CHANGE)\n                self.noLDAPRequired = True\n                context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format('The following user does not have the right to create a computer account: \"' + self.__username + '\"'))\n                    raise Exception()\n                elif e.error_code == 3221226215:\n                    context.log.highlight(u'{}'.format('The following user exceeded their machine account quota: \"' + self.__username + '\"'))\n                    raise Exception()\n                else:\n                    raise\n            userHandle = createUser['UserHandle']\n        if self.__delete:\n            samr.hSamrDeleteUser(dce, userHandle)\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n            self.noLDAPRequired = True\n            userHandle = None\n        else:\n            samr.hSamrSetPasswordInternal4New(dce, userHandle, self.__computerPassword)\n            if self.__noAdd:\n                context.log.highlight(u'{}'.format('Successfully set the password of machine \"' + self.__computerName + '\" with password \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n            else:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                userRID = checkForUser['RelativeIds']['Element'][0]\n                openUser = samr.hSamrOpenUser(dce, domainHandle, samr.MAXIMUM_ALLOWED, userRID)\n                userHandle = openUser['UserHandle']\n                req = samr.SAMPR_USER_INFO_BUFFER()\n                req['tag'] = samr.USER_INFORMATION_CLASS.UserControlInformation\n                req['Control']['UserAccountControl'] = samr.USER_WORKSTATION_TRUST_ACCOUNT\n                samr.hSamrSetInformationUser2(dce, userHandle, req)\n                if not self.noLDAPRequired:\n                    context.log.highlight(u'{}'.format('Successfully added the machine account \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            import traceback\n            traceback.print_exc()\n    finally:\n        if userHandle is not None:\n            samr.hSamrCloseHandle(dce, userHandle)\n        if domainHandle is not None:\n            samr.hSamrCloseHandle(dce, domainHandle)\n        if servHandle is not None:\n            samr.hSamrCloseHandle(dce, servHandle)\n        dce.disconnect()",
        "mutated": [
            "def doSAMRAdd(self, context):\n    if False:\n        i = 10\n    if self.__targetIp is not None:\n        stringBinding = epm.hept_map(self.__targetIp, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    else:\n        stringBinding = epm.hept_map(self.__target, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    rpctransport = transport.DCERPCTransportFactory(stringBinding)\n    rpctransport.set_dport(self.__port)\n    if self.__targetIp is not None:\n        rpctransport.setRemoteHost(self.__targetIp)\n        rpctransport.setRemoteName(self.__target)\n    if hasattr(rpctransport, 'set_credentials'):\n        rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey)\n    rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)\n    dce = rpctransport.get_dce_rpc()\n    servHandle = None\n    domainHandle = None\n    userHandle = None\n    try:\n        dce.connect()\n        dce.bind(samr.MSRPC_UUID_SAMR)\n        samrConnectResponse = samr.hSamrConnect5(dce, '\\\\\\\\%s\\x00' % self.__target, samr.SAM_SERVER_ENUMERATE_DOMAINS | samr.SAM_SERVER_LOOKUP_DOMAIN)\n        servHandle = samrConnectResponse['ServerHandle']\n        samrEnumResponse = samr.hSamrEnumerateDomainsInSamServer(dce, servHandle)\n        domains = samrEnumResponse['Buffer']['Buffer']\n        domainsWithoutBuiltin = list(filter(lambda x: x['Name'].lower() != 'builtin', domains))\n        if len(domainsWithoutBuiltin) > 1:\n            domain = list(filter(lambda x: x['Name'].lower() == self.__domainNetbios, domains))\n            if len(domain) != 1:\n                context.log.highlight(u'{}'.format('This domain does not exist: \"' + self.__domainNetbios + '\"'))\n                logging.critical('Available domain(s):')\n                for domain in domains:\n                    logging.error(' * %s' % domain['Name'])\n                raise Exception()\n            else:\n                selectedDomain = domain[0]['Name']\n        else:\n            selectedDomain = domainsWithoutBuiltin[0]['Name']\n        samrLookupDomainResponse = samr.hSamrLookupDomainInSamServer(dce, servHandle, selectedDomain)\n        domainSID = samrLookupDomainResponse['DomainId']\n        if logging.getLogger().level == logging.DEBUG:\n            logging.info('Opening domain %s...' % selectedDomain)\n        samrOpenDomainResponse = samr.hSamrOpenDomain(dce, servHandle, samr.DOMAIN_LOOKUP | samr.DOMAIN_CREATE_USER, domainSID)\n        domainHandle = samrOpenDomainResponse['DomainHandle']\n        if self.__noAdd or self.__delete:\n            try:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225587:\n                    context.log.highlight(u'{}'.format(self.__computerName + ' not found in domain ' + selectedDomain))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n            userRID = checkForUser['RelativeIds']['Element'][0]\n            if self.__delete:\n                access = samr.DELETE\n                message = 'delete'\n            else:\n                access = samr.USER_FORCE_PASSWORD_CHANGE\n                message = 'set the password for'\n            try:\n                openUser = samr.hSamrOpenUser(dce, domainHandle, access, userRID)\n                userHandle = openUser['UserHandle']\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format(self.__username + ' does not have the right to ' + message + ' ' + self.__computerName))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n        else:\n            if self.__computerName is not None:\n                try:\n                    checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    self.noLDAPRequired = True\n                    context.log.highlight(u'{}'.format('Computer account already exists with the name: \"' + self.__computerName + '\"'))\n                    raise Exception()\n                except samr.DCERPCSessionError as e:\n                    if e.error_code != 3221225587:\n                        raise\n            else:\n                foundUnused = False\n                while not foundUnused:\n                    self.__computerName = self.generateComputerName()\n                    try:\n                        checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    except samr.DCERPCSessionError as e:\n                        if e.error_code == 3221225587:\n                            foundUnused = True\n                        else:\n                            raise\n            try:\n                createUser = samr.hSamrCreateUser2InDomain(dce, domainHandle, self.__computerName, samr.USER_WORKSTATION_TRUST_ACCOUNT, samr.USER_FORCE_PASSWORD_CHANGE)\n                self.noLDAPRequired = True\n                context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format('The following user does not have the right to create a computer account: \"' + self.__username + '\"'))\n                    raise Exception()\n                elif e.error_code == 3221226215:\n                    context.log.highlight(u'{}'.format('The following user exceeded their machine account quota: \"' + self.__username + '\"'))\n                    raise Exception()\n                else:\n                    raise\n            userHandle = createUser['UserHandle']\n        if self.__delete:\n            samr.hSamrDeleteUser(dce, userHandle)\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n            self.noLDAPRequired = True\n            userHandle = None\n        else:\n            samr.hSamrSetPasswordInternal4New(dce, userHandle, self.__computerPassword)\n            if self.__noAdd:\n                context.log.highlight(u'{}'.format('Successfully set the password of machine \"' + self.__computerName + '\" with password \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n            else:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                userRID = checkForUser['RelativeIds']['Element'][0]\n                openUser = samr.hSamrOpenUser(dce, domainHandle, samr.MAXIMUM_ALLOWED, userRID)\n                userHandle = openUser['UserHandle']\n                req = samr.SAMPR_USER_INFO_BUFFER()\n                req['tag'] = samr.USER_INFORMATION_CLASS.UserControlInformation\n                req['Control']['UserAccountControl'] = samr.USER_WORKSTATION_TRUST_ACCOUNT\n                samr.hSamrSetInformationUser2(dce, userHandle, req)\n                if not self.noLDAPRequired:\n                    context.log.highlight(u'{}'.format('Successfully added the machine account \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            import traceback\n            traceback.print_exc()\n    finally:\n        if userHandle is not None:\n            samr.hSamrCloseHandle(dce, userHandle)\n        if domainHandle is not None:\n            samr.hSamrCloseHandle(dce, domainHandle)\n        if servHandle is not None:\n            samr.hSamrCloseHandle(dce, servHandle)\n        dce.disconnect()",
            "def doSAMRAdd(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.__targetIp is not None:\n        stringBinding = epm.hept_map(self.__targetIp, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    else:\n        stringBinding = epm.hept_map(self.__target, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    rpctransport = transport.DCERPCTransportFactory(stringBinding)\n    rpctransport.set_dport(self.__port)\n    if self.__targetIp is not None:\n        rpctransport.setRemoteHost(self.__targetIp)\n        rpctransport.setRemoteName(self.__target)\n    if hasattr(rpctransport, 'set_credentials'):\n        rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey)\n    rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)\n    dce = rpctransport.get_dce_rpc()\n    servHandle = None\n    domainHandle = None\n    userHandle = None\n    try:\n        dce.connect()\n        dce.bind(samr.MSRPC_UUID_SAMR)\n        samrConnectResponse = samr.hSamrConnect5(dce, '\\\\\\\\%s\\x00' % self.__target, samr.SAM_SERVER_ENUMERATE_DOMAINS | samr.SAM_SERVER_LOOKUP_DOMAIN)\n        servHandle = samrConnectResponse['ServerHandle']\n        samrEnumResponse = samr.hSamrEnumerateDomainsInSamServer(dce, servHandle)\n        domains = samrEnumResponse['Buffer']['Buffer']\n        domainsWithoutBuiltin = list(filter(lambda x: x['Name'].lower() != 'builtin', domains))\n        if len(domainsWithoutBuiltin) > 1:\n            domain = list(filter(lambda x: x['Name'].lower() == self.__domainNetbios, domains))\n            if len(domain) != 1:\n                context.log.highlight(u'{}'.format('This domain does not exist: \"' + self.__domainNetbios + '\"'))\n                logging.critical('Available domain(s):')\n                for domain in domains:\n                    logging.error(' * %s' % domain['Name'])\n                raise Exception()\n            else:\n                selectedDomain = domain[0]['Name']\n        else:\n            selectedDomain = domainsWithoutBuiltin[0]['Name']\n        samrLookupDomainResponse = samr.hSamrLookupDomainInSamServer(dce, servHandle, selectedDomain)\n        domainSID = samrLookupDomainResponse['DomainId']\n        if logging.getLogger().level == logging.DEBUG:\n            logging.info('Opening domain %s...' % selectedDomain)\n        samrOpenDomainResponse = samr.hSamrOpenDomain(dce, servHandle, samr.DOMAIN_LOOKUP | samr.DOMAIN_CREATE_USER, domainSID)\n        domainHandle = samrOpenDomainResponse['DomainHandle']\n        if self.__noAdd or self.__delete:\n            try:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225587:\n                    context.log.highlight(u'{}'.format(self.__computerName + ' not found in domain ' + selectedDomain))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n            userRID = checkForUser['RelativeIds']['Element'][0]\n            if self.__delete:\n                access = samr.DELETE\n                message = 'delete'\n            else:\n                access = samr.USER_FORCE_PASSWORD_CHANGE\n                message = 'set the password for'\n            try:\n                openUser = samr.hSamrOpenUser(dce, domainHandle, access, userRID)\n                userHandle = openUser['UserHandle']\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format(self.__username + ' does not have the right to ' + message + ' ' + self.__computerName))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n        else:\n            if self.__computerName is not None:\n                try:\n                    checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    self.noLDAPRequired = True\n                    context.log.highlight(u'{}'.format('Computer account already exists with the name: \"' + self.__computerName + '\"'))\n                    raise Exception()\n                except samr.DCERPCSessionError as e:\n                    if e.error_code != 3221225587:\n                        raise\n            else:\n                foundUnused = False\n                while not foundUnused:\n                    self.__computerName = self.generateComputerName()\n                    try:\n                        checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    except samr.DCERPCSessionError as e:\n                        if e.error_code == 3221225587:\n                            foundUnused = True\n                        else:\n                            raise\n            try:\n                createUser = samr.hSamrCreateUser2InDomain(dce, domainHandle, self.__computerName, samr.USER_WORKSTATION_TRUST_ACCOUNT, samr.USER_FORCE_PASSWORD_CHANGE)\n                self.noLDAPRequired = True\n                context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format('The following user does not have the right to create a computer account: \"' + self.__username + '\"'))\n                    raise Exception()\n                elif e.error_code == 3221226215:\n                    context.log.highlight(u'{}'.format('The following user exceeded their machine account quota: \"' + self.__username + '\"'))\n                    raise Exception()\n                else:\n                    raise\n            userHandle = createUser['UserHandle']\n        if self.__delete:\n            samr.hSamrDeleteUser(dce, userHandle)\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n            self.noLDAPRequired = True\n            userHandle = None\n        else:\n            samr.hSamrSetPasswordInternal4New(dce, userHandle, self.__computerPassword)\n            if self.__noAdd:\n                context.log.highlight(u'{}'.format('Successfully set the password of machine \"' + self.__computerName + '\" with password \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n            else:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                userRID = checkForUser['RelativeIds']['Element'][0]\n                openUser = samr.hSamrOpenUser(dce, domainHandle, samr.MAXIMUM_ALLOWED, userRID)\n                userHandle = openUser['UserHandle']\n                req = samr.SAMPR_USER_INFO_BUFFER()\n                req['tag'] = samr.USER_INFORMATION_CLASS.UserControlInformation\n                req['Control']['UserAccountControl'] = samr.USER_WORKSTATION_TRUST_ACCOUNT\n                samr.hSamrSetInformationUser2(dce, userHandle, req)\n                if not self.noLDAPRequired:\n                    context.log.highlight(u'{}'.format('Successfully added the machine account \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            import traceback\n            traceback.print_exc()\n    finally:\n        if userHandle is not None:\n            samr.hSamrCloseHandle(dce, userHandle)\n        if domainHandle is not None:\n            samr.hSamrCloseHandle(dce, domainHandle)\n        if servHandle is not None:\n            samr.hSamrCloseHandle(dce, servHandle)\n        dce.disconnect()",
            "def doSAMRAdd(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.__targetIp is not None:\n        stringBinding = epm.hept_map(self.__targetIp, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    else:\n        stringBinding = epm.hept_map(self.__target, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    rpctransport = transport.DCERPCTransportFactory(stringBinding)\n    rpctransport.set_dport(self.__port)\n    if self.__targetIp is not None:\n        rpctransport.setRemoteHost(self.__targetIp)\n        rpctransport.setRemoteName(self.__target)\n    if hasattr(rpctransport, 'set_credentials'):\n        rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey)\n    rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)\n    dce = rpctransport.get_dce_rpc()\n    servHandle = None\n    domainHandle = None\n    userHandle = None\n    try:\n        dce.connect()\n        dce.bind(samr.MSRPC_UUID_SAMR)\n        samrConnectResponse = samr.hSamrConnect5(dce, '\\\\\\\\%s\\x00' % self.__target, samr.SAM_SERVER_ENUMERATE_DOMAINS | samr.SAM_SERVER_LOOKUP_DOMAIN)\n        servHandle = samrConnectResponse['ServerHandle']\n        samrEnumResponse = samr.hSamrEnumerateDomainsInSamServer(dce, servHandle)\n        domains = samrEnumResponse['Buffer']['Buffer']\n        domainsWithoutBuiltin = list(filter(lambda x: x['Name'].lower() != 'builtin', domains))\n        if len(domainsWithoutBuiltin) > 1:\n            domain = list(filter(lambda x: x['Name'].lower() == self.__domainNetbios, domains))\n            if len(domain) != 1:\n                context.log.highlight(u'{}'.format('This domain does not exist: \"' + self.__domainNetbios + '\"'))\n                logging.critical('Available domain(s):')\n                for domain in domains:\n                    logging.error(' * %s' % domain['Name'])\n                raise Exception()\n            else:\n                selectedDomain = domain[0]['Name']\n        else:\n            selectedDomain = domainsWithoutBuiltin[0]['Name']\n        samrLookupDomainResponse = samr.hSamrLookupDomainInSamServer(dce, servHandle, selectedDomain)\n        domainSID = samrLookupDomainResponse['DomainId']\n        if logging.getLogger().level == logging.DEBUG:\n            logging.info('Opening domain %s...' % selectedDomain)\n        samrOpenDomainResponse = samr.hSamrOpenDomain(dce, servHandle, samr.DOMAIN_LOOKUP | samr.DOMAIN_CREATE_USER, domainSID)\n        domainHandle = samrOpenDomainResponse['DomainHandle']\n        if self.__noAdd or self.__delete:\n            try:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225587:\n                    context.log.highlight(u'{}'.format(self.__computerName + ' not found in domain ' + selectedDomain))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n            userRID = checkForUser['RelativeIds']['Element'][0]\n            if self.__delete:\n                access = samr.DELETE\n                message = 'delete'\n            else:\n                access = samr.USER_FORCE_PASSWORD_CHANGE\n                message = 'set the password for'\n            try:\n                openUser = samr.hSamrOpenUser(dce, domainHandle, access, userRID)\n                userHandle = openUser['UserHandle']\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format(self.__username + ' does not have the right to ' + message + ' ' + self.__computerName))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n        else:\n            if self.__computerName is not None:\n                try:\n                    checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    self.noLDAPRequired = True\n                    context.log.highlight(u'{}'.format('Computer account already exists with the name: \"' + self.__computerName + '\"'))\n                    raise Exception()\n                except samr.DCERPCSessionError as e:\n                    if e.error_code != 3221225587:\n                        raise\n            else:\n                foundUnused = False\n                while not foundUnused:\n                    self.__computerName = self.generateComputerName()\n                    try:\n                        checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    except samr.DCERPCSessionError as e:\n                        if e.error_code == 3221225587:\n                            foundUnused = True\n                        else:\n                            raise\n            try:\n                createUser = samr.hSamrCreateUser2InDomain(dce, domainHandle, self.__computerName, samr.USER_WORKSTATION_TRUST_ACCOUNT, samr.USER_FORCE_PASSWORD_CHANGE)\n                self.noLDAPRequired = True\n                context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format('The following user does not have the right to create a computer account: \"' + self.__username + '\"'))\n                    raise Exception()\n                elif e.error_code == 3221226215:\n                    context.log.highlight(u'{}'.format('The following user exceeded their machine account quota: \"' + self.__username + '\"'))\n                    raise Exception()\n                else:\n                    raise\n            userHandle = createUser['UserHandle']\n        if self.__delete:\n            samr.hSamrDeleteUser(dce, userHandle)\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n            self.noLDAPRequired = True\n            userHandle = None\n        else:\n            samr.hSamrSetPasswordInternal4New(dce, userHandle, self.__computerPassword)\n            if self.__noAdd:\n                context.log.highlight(u'{}'.format('Successfully set the password of machine \"' + self.__computerName + '\" with password \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n            else:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                userRID = checkForUser['RelativeIds']['Element'][0]\n                openUser = samr.hSamrOpenUser(dce, domainHandle, samr.MAXIMUM_ALLOWED, userRID)\n                userHandle = openUser['UserHandle']\n                req = samr.SAMPR_USER_INFO_BUFFER()\n                req['tag'] = samr.USER_INFORMATION_CLASS.UserControlInformation\n                req['Control']['UserAccountControl'] = samr.USER_WORKSTATION_TRUST_ACCOUNT\n                samr.hSamrSetInformationUser2(dce, userHandle, req)\n                if not self.noLDAPRequired:\n                    context.log.highlight(u'{}'.format('Successfully added the machine account \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            import traceback\n            traceback.print_exc()\n    finally:\n        if userHandle is not None:\n            samr.hSamrCloseHandle(dce, userHandle)\n        if domainHandle is not None:\n            samr.hSamrCloseHandle(dce, domainHandle)\n        if servHandle is not None:\n            samr.hSamrCloseHandle(dce, servHandle)\n        dce.disconnect()",
            "def doSAMRAdd(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.__targetIp is not None:\n        stringBinding = epm.hept_map(self.__targetIp, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    else:\n        stringBinding = epm.hept_map(self.__target, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    rpctransport = transport.DCERPCTransportFactory(stringBinding)\n    rpctransport.set_dport(self.__port)\n    if self.__targetIp is not None:\n        rpctransport.setRemoteHost(self.__targetIp)\n        rpctransport.setRemoteName(self.__target)\n    if hasattr(rpctransport, 'set_credentials'):\n        rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey)\n    rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)\n    dce = rpctransport.get_dce_rpc()\n    servHandle = None\n    domainHandle = None\n    userHandle = None\n    try:\n        dce.connect()\n        dce.bind(samr.MSRPC_UUID_SAMR)\n        samrConnectResponse = samr.hSamrConnect5(dce, '\\\\\\\\%s\\x00' % self.__target, samr.SAM_SERVER_ENUMERATE_DOMAINS | samr.SAM_SERVER_LOOKUP_DOMAIN)\n        servHandle = samrConnectResponse['ServerHandle']\n        samrEnumResponse = samr.hSamrEnumerateDomainsInSamServer(dce, servHandle)\n        domains = samrEnumResponse['Buffer']['Buffer']\n        domainsWithoutBuiltin = list(filter(lambda x: x['Name'].lower() != 'builtin', domains))\n        if len(domainsWithoutBuiltin) > 1:\n            domain = list(filter(lambda x: x['Name'].lower() == self.__domainNetbios, domains))\n            if len(domain) != 1:\n                context.log.highlight(u'{}'.format('This domain does not exist: \"' + self.__domainNetbios + '\"'))\n                logging.critical('Available domain(s):')\n                for domain in domains:\n                    logging.error(' * %s' % domain['Name'])\n                raise Exception()\n            else:\n                selectedDomain = domain[0]['Name']\n        else:\n            selectedDomain = domainsWithoutBuiltin[0]['Name']\n        samrLookupDomainResponse = samr.hSamrLookupDomainInSamServer(dce, servHandle, selectedDomain)\n        domainSID = samrLookupDomainResponse['DomainId']\n        if logging.getLogger().level == logging.DEBUG:\n            logging.info('Opening domain %s...' % selectedDomain)\n        samrOpenDomainResponse = samr.hSamrOpenDomain(dce, servHandle, samr.DOMAIN_LOOKUP | samr.DOMAIN_CREATE_USER, domainSID)\n        domainHandle = samrOpenDomainResponse['DomainHandle']\n        if self.__noAdd or self.__delete:\n            try:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225587:\n                    context.log.highlight(u'{}'.format(self.__computerName + ' not found in domain ' + selectedDomain))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n            userRID = checkForUser['RelativeIds']['Element'][0]\n            if self.__delete:\n                access = samr.DELETE\n                message = 'delete'\n            else:\n                access = samr.USER_FORCE_PASSWORD_CHANGE\n                message = 'set the password for'\n            try:\n                openUser = samr.hSamrOpenUser(dce, domainHandle, access, userRID)\n                userHandle = openUser['UserHandle']\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format(self.__username + ' does not have the right to ' + message + ' ' + self.__computerName))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n        else:\n            if self.__computerName is not None:\n                try:\n                    checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    self.noLDAPRequired = True\n                    context.log.highlight(u'{}'.format('Computer account already exists with the name: \"' + self.__computerName + '\"'))\n                    raise Exception()\n                except samr.DCERPCSessionError as e:\n                    if e.error_code != 3221225587:\n                        raise\n            else:\n                foundUnused = False\n                while not foundUnused:\n                    self.__computerName = self.generateComputerName()\n                    try:\n                        checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    except samr.DCERPCSessionError as e:\n                        if e.error_code == 3221225587:\n                            foundUnused = True\n                        else:\n                            raise\n            try:\n                createUser = samr.hSamrCreateUser2InDomain(dce, domainHandle, self.__computerName, samr.USER_WORKSTATION_TRUST_ACCOUNT, samr.USER_FORCE_PASSWORD_CHANGE)\n                self.noLDAPRequired = True\n                context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format('The following user does not have the right to create a computer account: \"' + self.__username + '\"'))\n                    raise Exception()\n                elif e.error_code == 3221226215:\n                    context.log.highlight(u'{}'.format('The following user exceeded their machine account quota: \"' + self.__username + '\"'))\n                    raise Exception()\n                else:\n                    raise\n            userHandle = createUser['UserHandle']\n        if self.__delete:\n            samr.hSamrDeleteUser(dce, userHandle)\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n            self.noLDAPRequired = True\n            userHandle = None\n        else:\n            samr.hSamrSetPasswordInternal4New(dce, userHandle, self.__computerPassword)\n            if self.__noAdd:\n                context.log.highlight(u'{}'.format('Successfully set the password of machine \"' + self.__computerName + '\" with password \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n            else:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                userRID = checkForUser['RelativeIds']['Element'][0]\n                openUser = samr.hSamrOpenUser(dce, domainHandle, samr.MAXIMUM_ALLOWED, userRID)\n                userHandle = openUser['UserHandle']\n                req = samr.SAMPR_USER_INFO_BUFFER()\n                req['tag'] = samr.USER_INFORMATION_CLASS.UserControlInformation\n                req['Control']['UserAccountControl'] = samr.USER_WORKSTATION_TRUST_ACCOUNT\n                samr.hSamrSetInformationUser2(dce, userHandle, req)\n                if not self.noLDAPRequired:\n                    context.log.highlight(u'{}'.format('Successfully added the machine account \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            import traceback\n            traceback.print_exc()\n    finally:\n        if userHandle is not None:\n            samr.hSamrCloseHandle(dce, userHandle)\n        if domainHandle is not None:\n            samr.hSamrCloseHandle(dce, domainHandle)\n        if servHandle is not None:\n            samr.hSamrCloseHandle(dce, servHandle)\n        dce.disconnect()",
            "def doSAMRAdd(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.__targetIp is not None:\n        stringBinding = epm.hept_map(self.__targetIp, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    else:\n        stringBinding = epm.hept_map(self.__target, samr.MSRPC_UUID_SAMR, protocol='ncacn_np')\n    rpctransport = transport.DCERPCTransportFactory(stringBinding)\n    rpctransport.set_dport(self.__port)\n    if self.__targetIp is not None:\n        rpctransport.setRemoteHost(self.__targetIp)\n        rpctransport.setRemoteName(self.__target)\n    if hasattr(rpctransport, 'set_credentials'):\n        rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey)\n    rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)\n    dce = rpctransport.get_dce_rpc()\n    servHandle = None\n    domainHandle = None\n    userHandle = None\n    try:\n        dce.connect()\n        dce.bind(samr.MSRPC_UUID_SAMR)\n        samrConnectResponse = samr.hSamrConnect5(dce, '\\\\\\\\%s\\x00' % self.__target, samr.SAM_SERVER_ENUMERATE_DOMAINS | samr.SAM_SERVER_LOOKUP_DOMAIN)\n        servHandle = samrConnectResponse['ServerHandle']\n        samrEnumResponse = samr.hSamrEnumerateDomainsInSamServer(dce, servHandle)\n        domains = samrEnumResponse['Buffer']['Buffer']\n        domainsWithoutBuiltin = list(filter(lambda x: x['Name'].lower() != 'builtin', domains))\n        if len(domainsWithoutBuiltin) > 1:\n            domain = list(filter(lambda x: x['Name'].lower() == self.__domainNetbios, domains))\n            if len(domain) != 1:\n                context.log.highlight(u'{}'.format('This domain does not exist: \"' + self.__domainNetbios + '\"'))\n                logging.critical('Available domain(s):')\n                for domain in domains:\n                    logging.error(' * %s' % domain['Name'])\n                raise Exception()\n            else:\n                selectedDomain = domain[0]['Name']\n        else:\n            selectedDomain = domainsWithoutBuiltin[0]['Name']\n        samrLookupDomainResponse = samr.hSamrLookupDomainInSamServer(dce, servHandle, selectedDomain)\n        domainSID = samrLookupDomainResponse['DomainId']\n        if logging.getLogger().level == logging.DEBUG:\n            logging.info('Opening domain %s...' % selectedDomain)\n        samrOpenDomainResponse = samr.hSamrOpenDomain(dce, servHandle, samr.DOMAIN_LOOKUP | samr.DOMAIN_CREATE_USER, domainSID)\n        domainHandle = samrOpenDomainResponse['DomainHandle']\n        if self.__noAdd or self.__delete:\n            try:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225587:\n                    context.log.highlight(u'{}'.format(self.__computerName + ' not found in domain ' + selectedDomain))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n            userRID = checkForUser['RelativeIds']['Element'][0]\n            if self.__delete:\n                access = samr.DELETE\n                message = 'delete'\n            else:\n                access = samr.USER_FORCE_PASSWORD_CHANGE\n                message = 'set the password for'\n            try:\n                openUser = samr.hSamrOpenUser(dce, domainHandle, access, userRID)\n                userHandle = openUser['UserHandle']\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format(self.__username + ' does not have the right to ' + message + ' ' + self.__computerName))\n                    self.noLDAPRequired = True\n                    raise Exception()\n                else:\n                    raise\n        else:\n            if self.__computerName is not None:\n                try:\n                    checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    self.noLDAPRequired = True\n                    context.log.highlight(u'{}'.format('Computer account already exists with the name: \"' + self.__computerName + '\"'))\n                    raise Exception()\n                except samr.DCERPCSessionError as e:\n                    if e.error_code != 3221225587:\n                        raise\n            else:\n                foundUnused = False\n                while not foundUnused:\n                    self.__computerName = self.generateComputerName()\n                    try:\n                        checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                    except samr.DCERPCSessionError as e:\n                        if e.error_code == 3221225587:\n                            foundUnused = True\n                        else:\n                            raise\n            try:\n                createUser = samr.hSamrCreateUser2InDomain(dce, domainHandle, self.__computerName, samr.USER_WORKSTATION_TRUST_ACCOUNT, samr.USER_FORCE_PASSWORD_CHANGE)\n                self.noLDAPRequired = True\n                context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            except samr.DCERPCSessionError as e:\n                if e.error_code == 3221225506:\n                    context.log.highlight(u'{}'.format('The following user does not have the right to create a computer account: \"' + self.__username + '\"'))\n                    raise Exception()\n                elif e.error_code == 3221226215:\n                    context.log.highlight(u'{}'.format('The following user exceeded their machine account quota: \"' + self.__username + '\"'))\n                    raise Exception()\n                else:\n                    raise\n            userHandle = createUser['UserHandle']\n        if self.__delete:\n            samr.hSamrDeleteUser(dce, userHandle)\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n            self.noLDAPRequired = True\n            userHandle = None\n        else:\n            samr.hSamrSetPasswordInternal4New(dce, userHandle, self.__computerPassword)\n            if self.__noAdd:\n                context.log.highlight(u'{}'.format('Successfully set the password of machine \"' + self.__computerName + '\" with password \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n            else:\n                checkForUser = samr.hSamrLookupNamesInDomain(dce, domainHandle, [self.__computerName])\n                userRID = checkForUser['RelativeIds']['Element'][0]\n                openUser = samr.hSamrOpenUser(dce, domainHandle, samr.MAXIMUM_ALLOWED, userRID)\n                userHandle = openUser['UserHandle']\n                req = samr.SAMPR_USER_INFO_BUFFER()\n                req['tag'] = samr.USER_INFORMATION_CLASS.UserControlInformation\n                req['Control']['UserAccountControl'] = samr.USER_WORKSTATION_TRUST_ACCOUNT\n                samr.hSamrSetInformationUser2(dce, userHandle, req)\n                if not self.noLDAPRequired:\n                    context.log.highlight(u'{}'.format('Successfully added the machine account \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"'))\n                self.noLDAPRequired = True\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            import traceback\n            traceback.print_exc()\n    finally:\n        if userHandle is not None:\n            samr.hSamrCloseHandle(dce, userHandle)\n        if domainHandle is not None:\n            samr.hSamrCloseHandle(dce, domainHandle)\n        if servHandle is not None:\n            samr.hSamrCloseHandle(dce, servHandle)\n        dce.disconnect()"
        ]
    },
    {
        "func_name": "doLDAPSAdd",
        "original": "def doLDAPSAdd(self, connection, context):\n    ldap_domain = connection.domain.replace('.', ',dc=')\n    spns = ['HOST/%s' % self.__computerName, 'HOST/%s.%s' % (self.__computerName, connection.domain), 'RestrictedKrbHost/%s' % self.__computerName, 'RestrictedKrbHost/%s.%s' % (self.__computerName, connection.domain)]\n    ucd = {'dnsHostName': '%s.%s' % (self.__computerName, connection.domain), 'userAccountControl': 4096, 'servicePrincipalName': spns, 'sAMAccountName': self.__computerName, 'unicodePwd': ('\"%s\"' % self.__computerPassword).encode('utf-16-le')}\n    tls = ldap3.Tls(validate=ssl.CERT_NONE, version=ssl.PROTOCOL_TLSv1_2, ciphers='ALL:@SECLEVEL=0')\n    ldapServer = ldap3.Server(connection.host, use_ssl=True, port=636, get_info=ldap3.ALL, tls=tls)\n    c = Connection(ldapServer, connection.username + '@' + connection.domain, connection.password)\n    c.bind()\n    if self.__delete:\n        result = c.delete('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain)\n        if result:\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n        elif result == False and c.last_error == 'noSuchObject':\n            context.log.highlight(u'{}'.format('Computer named \"' + self.__computerName + '\" was not found'))\n        elif result == False and c.last_error == 'insufficientAccessRights':\n            context.log.highlight(u'{}'.format('Insufficient Access Rights to delete the Computer \"' + self.__computerName + '\"'))\n        else:\n            context.log.highlight(u'{}'.format('Unable to delete the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    else:\n        result = c.add('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain, ['top', 'person', 'organizationalPerson', 'user', 'computer'], ucd)\n        if result:\n            context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            context.log.highlight(u'{}'.format('You can try to verify this with the CME command:'))\n            context.log.highlight(u'{}'.format('cme ldap ' + connection.host + ' -u ' + connection.username + ' -p ' + connection.password + ' -M group-mem -o GROUP=\"Domain Computers\"'))\n        elif result == False and c.last_error == 'entryAlreadyExists':\n            context.log.highlight(u'{}'.format('The Computer account \"' + self.__computerName + '\" already exists'))\n        elif not result:\n            context.log.highlight(u'{}'.format('Unable to add the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    c.unbind()",
        "mutated": [
            "def doLDAPSAdd(self, connection, context):\n    if False:\n        i = 10\n    ldap_domain = connection.domain.replace('.', ',dc=')\n    spns = ['HOST/%s' % self.__computerName, 'HOST/%s.%s' % (self.__computerName, connection.domain), 'RestrictedKrbHost/%s' % self.__computerName, 'RestrictedKrbHost/%s.%s' % (self.__computerName, connection.domain)]\n    ucd = {'dnsHostName': '%s.%s' % (self.__computerName, connection.domain), 'userAccountControl': 4096, 'servicePrincipalName': spns, 'sAMAccountName': self.__computerName, 'unicodePwd': ('\"%s\"' % self.__computerPassword).encode('utf-16-le')}\n    tls = ldap3.Tls(validate=ssl.CERT_NONE, version=ssl.PROTOCOL_TLSv1_2, ciphers='ALL:@SECLEVEL=0')\n    ldapServer = ldap3.Server(connection.host, use_ssl=True, port=636, get_info=ldap3.ALL, tls=tls)\n    c = Connection(ldapServer, connection.username + '@' + connection.domain, connection.password)\n    c.bind()\n    if self.__delete:\n        result = c.delete('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain)\n        if result:\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n        elif result == False and c.last_error == 'noSuchObject':\n            context.log.highlight(u'{}'.format('Computer named \"' + self.__computerName + '\" was not found'))\n        elif result == False and c.last_error == 'insufficientAccessRights':\n            context.log.highlight(u'{}'.format('Insufficient Access Rights to delete the Computer \"' + self.__computerName + '\"'))\n        else:\n            context.log.highlight(u'{}'.format('Unable to delete the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    else:\n        result = c.add('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain, ['top', 'person', 'organizationalPerson', 'user', 'computer'], ucd)\n        if result:\n            context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            context.log.highlight(u'{}'.format('You can try to verify this with the CME command:'))\n            context.log.highlight(u'{}'.format('cme ldap ' + connection.host + ' -u ' + connection.username + ' -p ' + connection.password + ' -M group-mem -o GROUP=\"Domain Computers\"'))\n        elif result == False and c.last_error == 'entryAlreadyExists':\n            context.log.highlight(u'{}'.format('The Computer account \"' + self.__computerName + '\" already exists'))\n        elif not result:\n            context.log.highlight(u'{}'.format('Unable to add the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    c.unbind()",
            "def doLDAPSAdd(self, connection, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ldap_domain = connection.domain.replace('.', ',dc=')\n    spns = ['HOST/%s' % self.__computerName, 'HOST/%s.%s' % (self.__computerName, connection.domain), 'RestrictedKrbHost/%s' % self.__computerName, 'RestrictedKrbHost/%s.%s' % (self.__computerName, connection.domain)]\n    ucd = {'dnsHostName': '%s.%s' % (self.__computerName, connection.domain), 'userAccountControl': 4096, 'servicePrincipalName': spns, 'sAMAccountName': self.__computerName, 'unicodePwd': ('\"%s\"' % self.__computerPassword).encode('utf-16-le')}\n    tls = ldap3.Tls(validate=ssl.CERT_NONE, version=ssl.PROTOCOL_TLSv1_2, ciphers='ALL:@SECLEVEL=0')\n    ldapServer = ldap3.Server(connection.host, use_ssl=True, port=636, get_info=ldap3.ALL, tls=tls)\n    c = Connection(ldapServer, connection.username + '@' + connection.domain, connection.password)\n    c.bind()\n    if self.__delete:\n        result = c.delete('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain)\n        if result:\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n        elif result == False and c.last_error == 'noSuchObject':\n            context.log.highlight(u'{}'.format('Computer named \"' + self.__computerName + '\" was not found'))\n        elif result == False and c.last_error == 'insufficientAccessRights':\n            context.log.highlight(u'{}'.format('Insufficient Access Rights to delete the Computer \"' + self.__computerName + '\"'))\n        else:\n            context.log.highlight(u'{}'.format('Unable to delete the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    else:\n        result = c.add('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain, ['top', 'person', 'organizationalPerson', 'user', 'computer'], ucd)\n        if result:\n            context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            context.log.highlight(u'{}'.format('You can try to verify this with the CME command:'))\n            context.log.highlight(u'{}'.format('cme ldap ' + connection.host + ' -u ' + connection.username + ' -p ' + connection.password + ' -M group-mem -o GROUP=\"Domain Computers\"'))\n        elif result == False and c.last_error == 'entryAlreadyExists':\n            context.log.highlight(u'{}'.format('The Computer account \"' + self.__computerName + '\" already exists'))\n        elif not result:\n            context.log.highlight(u'{}'.format('Unable to add the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    c.unbind()",
            "def doLDAPSAdd(self, connection, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ldap_domain = connection.domain.replace('.', ',dc=')\n    spns = ['HOST/%s' % self.__computerName, 'HOST/%s.%s' % (self.__computerName, connection.domain), 'RestrictedKrbHost/%s' % self.__computerName, 'RestrictedKrbHost/%s.%s' % (self.__computerName, connection.domain)]\n    ucd = {'dnsHostName': '%s.%s' % (self.__computerName, connection.domain), 'userAccountControl': 4096, 'servicePrincipalName': spns, 'sAMAccountName': self.__computerName, 'unicodePwd': ('\"%s\"' % self.__computerPassword).encode('utf-16-le')}\n    tls = ldap3.Tls(validate=ssl.CERT_NONE, version=ssl.PROTOCOL_TLSv1_2, ciphers='ALL:@SECLEVEL=0')\n    ldapServer = ldap3.Server(connection.host, use_ssl=True, port=636, get_info=ldap3.ALL, tls=tls)\n    c = Connection(ldapServer, connection.username + '@' + connection.domain, connection.password)\n    c.bind()\n    if self.__delete:\n        result = c.delete('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain)\n        if result:\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n        elif result == False and c.last_error == 'noSuchObject':\n            context.log.highlight(u'{}'.format('Computer named \"' + self.__computerName + '\" was not found'))\n        elif result == False and c.last_error == 'insufficientAccessRights':\n            context.log.highlight(u'{}'.format('Insufficient Access Rights to delete the Computer \"' + self.__computerName + '\"'))\n        else:\n            context.log.highlight(u'{}'.format('Unable to delete the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    else:\n        result = c.add('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain, ['top', 'person', 'organizationalPerson', 'user', 'computer'], ucd)\n        if result:\n            context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            context.log.highlight(u'{}'.format('You can try to verify this with the CME command:'))\n            context.log.highlight(u'{}'.format('cme ldap ' + connection.host + ' -u ' + connection.username + ' -p ' + connection.password + ' -M group-mem -o GROUP=\"Domain Computers\"'))\n        elif result == False and c.last_error == 'entryAlreadyExists':\n            context.log.highlight(u'{}'.format('The Computer account \"' + self.__computerName + '\" already exists'))\n        elif not result:\n            context.log.highlight(u'{}'.format('Unable to add the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    c.unbind()",
            "def doLDAPSAdd(self, connection, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ldap_domain = connection.domain.replace('.', ',dc=')\n    spns = ['HOST/%s' % self.__computerName, 'HOST/%s.%s' % (self.__computerName, connection.domain), 'RestrictedKrbHost/%s' % self.__computerName, 'RestrictedKrbHost/%s.%s' % (self.__computerName, connection.domain)]\n    ucd = {'dnsHostName': '%s.%s' % (self.__computerName, connection.domain), 'userAccountControl': 4096, 'servicePrincipalName': spns, 'sAMAccountName': self.__computerName, 'unicodePwd': ('\"%s\"' % self.__computerPassword).encode('utf-16-le')}\n    tls = ldap3.Tls(validate=ssl.CERT_NONE, version=ssl.PROTOCOL_TLSv1_2, ciphers='ALL:@SECLEVEL=0')\n    ldapServer = ldap3.Server(connection.host, use_ssl=True, port=636, get_info=ldap3.ALL, tls=tls)\n    c = Connection(ldapServer, connection.username + '@' + connection.domain, connection.password)\n    c.bind()\n    if self.__delete:\n        result = c.delete('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain)\n        if result:\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n        elif result == False and c.last_error == 'noSuchObject':\n            context.log.highlight(u'{}'.format('Computer named \"' + self.__computerName + '\" was not found'))\n        elif result == False and c.last_error == 'insufficientAccessRights':\n            context.log.highlight(u'{}'.format('Insufficient Access Rights to delete the Computer \"' + self.__computerName + '\"'))\n        else:\n            context.log.highlight(u'{}'.format('Unable to delete the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    else:\n        result = c.add('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain, ['top', 'person', 'organizationalPerson', 'user', 'computer'], ucd)\n        if result:\n            context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            context.log.highlight(u'{}'.format('You can try to verify this with the CME command:'))\n            context.log.highlight(u'{}'.format('cme ldap ' + connection.host + ' -u ' + connection.username + ' -p ' + connection.password + ' -M group-mem -o GROUP=\"Domain Computers\"'))\n        elif result == False and c.last_error == 'entryAlreadyExists':\n            context.log.highlight(u'{}'.format('The Computer account \"' + self.__computerName + '\" already exists'))\n        elif not result:\n            context.log.highlight(u'{}'.format('Unable to add the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    c.unbind()",
            "def doLDAPSAdd(self, connection, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ldap_domain = connection.domain.replace('.', ',dc=')\n    spns = ['HOST/%s' % self.__computerName, 'HOST/%s.%s' % (self.__computerName, connection.domain), 'RestrictedKrbHost/%s' % self.__computerName, 'RestrictedKrbHost/%s.%s' % (self.__computerName, connection.domain)]\n    ucd = {'dnsHostName': '%s.%s' % (self.__computerName, connection.domain), 'userAccountControl': 4096, 'servicePrincipalName': spns, 'sAMAccountName': self.__computerName, 'unicodePwd': ('\"%s\"' % self.__computerPassword).encode('utf-16-le')}\n    tls = ldap3.Tls(validate=ssl.CERT_NONE, version=ssl.PROTOCOL_TLSv1_2, ciphers='ALL:@SECLEVEL=0')\n    ldapServer = ldap3.Server(connection.host, use_ssl=True, port=636, get_info=ldap3.ALL, tls=tls)\n    c = Connection(ldapServer, connection.username + '@' + connection.domain, connection.password)\n    c.bind()\n    if self.__delete:\n        result = c.delete('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain)\n        if result:\n            context.log.highlight(u'{}'.format('Successfully deleted the \"' + self.__computerName + '\" Computer account'))\n        elif result == False and c.last_error == 'noSuchObject':\n            context.log.highlight(u'{}'.format('Computer named \"' + self.__computerName + '\" was not found'))\n        elif result == False and c.last_error == 'insufficientAccessRights':\n            context.log.highlight(u'{}'.format('Insufficient Access Rights to delete the Computer \"' + self.__computerName + '\"'))\n        else:\n            context.log.highlight(u'{}'.format('Unable to delete the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    else:\n        result = c.add('cn=' + self.__computerName + ',cn=Computers,dc=' + ldap_domain, ['top', 'person', 'organizationalPerson', 'user', 'computer'], ucd)\n        if result:\n            context.log.highlight('Successfully added the machine account: \"' + self.__computerName + '\" with Password: \"' + self.__computerPassword + '\"')\n            context.log.highlight(u'{}'.format('You can try to verify this with the CME command:'))\n            context.log.highlight(u'{}'.format('cme ldap ' + connection.host + ' -u ' + connection.username + ' -p ' + connection.password + ' -M group-mem -o GROUP=\"Domain Computers\"'))\n        elif result == False and c.last_error == 'entryAlreadyExists':\n            context.log.highlight(u'{}'.format('The Computer account \"' + self.__computerName + '\" already exists'))\n        elif not result:\n            context.log.highlight(u'{}'.format('Unable to add the \"' + self.__computerName + '\" Computer account. The error was: ' + c.last_error))\n    c.unbind()"
        ]
    }
]