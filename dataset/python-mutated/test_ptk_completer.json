[
    {
        "func_name": "test_rich_completion",
        "original": "@pytest.mark.parametrize('completion, lprefix, ptk_completion', [(RichCompletion('x', 0, 'x()', 'func'), 0, None), (RichCompletion('x', 1, 'xx', 'instance'), 0, None), (RichCompletion('x', description='wow'), 5, PTKCompletion(RichCompletion('x'), -5, 'x', 'wow')), (RichCompletion('x'), 5, PTKCompletion(RichCompletion('x'), -5, 'x')), ('x', 5, PTKCompletion('x', -5, 'x'))])\ndef test_rich_completion(completion, lprefix, ptk_completion, monkeypatch, xession):\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = ({completion}, lprefix)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    document_mock = MagicMock()\n    document_mock.text = ''\n    document_mock.current_line = ''\n    document_mock.cursor_position_col = 0\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases())\n    completions = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    if isinstance(completion, RichCompletion) and (not ptk_completion):\n        assert completions == [PTKCompletion(completion, -completion.prefix_len, completion.display, completion.description)]\n    else:\n        assert completions == [ptk_completion]",
        "mutated": [
            "@pytest.mark.parametrize('completion, lprefix, ptk_completion', [(RichCompletion('x', 0, 'x()', 'func'), 0, None), (RichCompletion('x', 1, 'xx', 'instance'), 0, None), (RichCompletion('x', description='wow'), 5, PTKCompletion(RichCompletion('x'), -5, 'x', 'wow')), (RichCompletion('x'), 5, PTKCompletion(RichCompletion('x'), -5, 'x')), ('x', 5, PTKCompletion('x', -5, 'x'))])\ndef test_rich_completion(completion, lprefix, ptk_completion, monkeypatch, xession):\n    if False:\n        i = 10\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = ({completion}, lprefix)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    document_mock = MagicMock()\n    document_mock.text = ''\n    document_mock.current_line = ''\n    document_mock.cursor_position_col = 0\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases())\n    completions = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    if isinstance(completion, RichCompletion) and (not ptk_completion):\n        assert completions == [PTKCompletion(completion, -completion.prefix_len, completion.display, completion.description)]\n    else:\n        assert completions == [ptk_completion]",
            "@pytest.mark.parametrize('completion, lprefix, ptk_completion', [(RichCompletion('x', 0, 'x()', 'func'), 0, None), (RichCompletion('x', 1, 'xx', 'instance'), 0, None), (RichCompletion('x', description='wow'), 5, PTKCompletion(RichCompletion('x'), -5, 'x', 'wow')), (RichCompletion('x'), 5, PTKCompletion(RichCompletion('x'), -5, 'x')), ('x', 5, PTKCompletion('x', -5, 'x'))])\ndef test_rich_completion(completion, lprefix, ptk_completion, monkeypatch, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = ({completion}, lprefix)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    document_mock = MagicMock()\n    document_mock.text = ''\n    document_mock.current_line = ''\n    document_mock.cursor_position_col = 0\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases())\n    completions = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    if isinstance(completion, RichCompletion) and (not ptk_completion):\n        assert completions == [PTKCompletion(completion, -completion.prefix_len, completion.display, completion.description)]\n    else:\n        assert completions == [ptk_completion]",
            "@pytest.mark.parametrize('completion, lprefix, ptk_completion', [(RichCompletion('x', 0, 'x()', 'func'), 0, None), (RichCompletion('x', 1, 'xx', 'instance'), 0, None), (RichCompletion('x', description='wow'), 5, PTKCompletion(RichCompletion('x'), -5, 'x', 'wow')), (RichCompletion('x'), 5, PTKCompletion(RichCompletion('x'), -5, 'x')), ('x', 5, PTKCompletion('x', -5, 'x'))])\ndef test_rich_completion(completion, lprefix, ptk_completion, monkeypatch, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = ({completion}, lprefix)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    document_mock = MagicMock()\n    document_mock.text = ''\n    document_mock.current_line = ''\n    document_mock.cursor_position_col = 0\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases())\n    completions = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    if isinstance(completion, RichCompletion) and (not ptk_completion):\n        assert completions == [PTKCompletion(completion, -completion.prefix_len, completion.display, completion.description)]\n    else:\n        assert completions == [ptk_completion]",
            "@pytest.mark.parametrize('completion, lprefix, ptk_completion', [(RichCompletion('x', 0, 'x()', 'func'), 0, None), (RichCompletion('x', 1, 'xx', 'instance'), 0, None), (RichCompletion('x', description='wow'), 5, PTKCompletion(RichCompletion('x'), -5, 'x', 'wow')), (RichCompletion('x'), 5, PTKCompletion(RichCompletion('x'), -5, 'x')), ('x', 5, PTKCompletion('x', -5, 'x'))])\ndef test_rich_completion(completion, lprefix, ptk_completion, monkeypatch, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = ({completion}, lprefix)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    document_mock = MagicMock()\n    document_mock.text = ''\n    document_mock.current_line = ''\n    document_mock.cursor_position_col = 0\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases())\n    completions = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    if isinstance(completion, RichCompletion) and (not ptk_completion):\n        assert completions == [PTKCompletion(completion, -completion.prefix_len, completion.display, completion.description)]\n    else:\n        assert completions == [ptk_completion]",
            "@pytest.mark.parametrize('completion, lprefix, ptk_completion', [(RichCompletion('x', 0, 'x()', 'func'), 0, None), (RichCompletion('x', 1, 'xx', 'instance'), 0, None), (RichCompletion('x', description='wow'), 5, PTKCompletion(RichCompletion('x'), -5, 'x', 'wow')), (RichCompletion('x'), 5, PTKCompletion(RichCompletion('x'), -5, 'x')), ('x', 5, PTKCompletion('x', -5, 'x'))])\ndef test_rich_completion(completion, lprefix, ptk_completion, monkeypatch, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = ({completion}, lprefix)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    document_mock = MagicMock()\n    document_mock.text = ''\n    document_mock.current_line = ''\n    document_mock.cursor_position_col = 0\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases())\n    completions = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    if isinstance(completion, RichCompletion) and (not ptk_completion):\n        assert completions == [PTKCompletion(completion, -completion.prefix_len, completion.display, completion.description)]\n    else:\n        assert completions == [ptk_completion]"
        ]
    },
    {
        "func_name": "test_auto_suggest_completion",
        "original": "@pytest.mark.parametrize('completions, document_text, ptk_completion', [(set(), '', 'test_completion'), (set(), 'test_', 'test_completion'), ({RichCompletion('test', 4, 'test()', 'func')}, 'test', 'test_completion')])\ndef test_auto_suggest_completion(completions, document_text, ptk_completion, xession):\n    lprefix = len(document_text)\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = (completions, lprefix)\n    xession.env['AUTO_SUGGEST_IN_COMPLETIONS'] = True\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: ptk_completion\n    document_mock = MagicMock()\n    document_mock.text = document_text\n    document_mock.current_line = document_text\n    document_mock.cursor_position_col = lprefix\n    auto_suggested = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    assert PTKCompletion(ptk_completion, -lprefix) in auto_suggested",
        "mutated": [
            "@pytest.mark.parametrize('completions, document_text, ptk_completion', [(set(), '', 'test_completion'), (set(), 'test_', 'test_completion'), ({RichCompletion('test', 4, 'test()', 'func')}, 'test', 'test_completion')])\ndef test_auto_suggest_completion(completions, document_text, ptk_completion, xession):\n    if False:\n        i = 10\n    lprefix = len(document_text)\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = (completions, lprefix)\n    xession.env['AUTO_SUGGEST_IN_COMPLETIONS'] = True\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: ptk_completion\n    document_mock = MagicMock()\n    document_mock.text = document_text\n    document_mock.current_line = document_text\n    document_mock.cursor_position_col = lprefix\n    auto_suggested = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    assert PTKCompletion(ptk_completion, -lprefix) in auto_suggested",
            "@pytest.mark.parametrize('completions, document_text, ptk_completion', [(set(), '', 'test_completion'), (set(), 'test_', 'test_completion'), ({RichCompletion('test', 4, 'test()', 'func')}, 'test', 'test_completion')])\ndef test_auto_suggest_completion(completions, document_text, ptk_completion, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lprefix = len(document_text)\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = (completions, lprefix)\n    xession.env['AUTO_SUGGEST_IN_COMPLETIONS'] = True\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: ptk_completion\n    document_mock = MagicMock()\n    document_mock.text = document_text\n    document_mock.current_line = document_text\n    document_mock.cursor_position_col = lprefix\n    auto_suggested = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    assert PTKCompletion(ptk_completion, -lprefix) in auto_suggested",
            "@pytest.mark.parametrize('completions, document_text, ptk_completion', [(set(), '', 'test_completion'), (set(), 'test_', 'test_completion'), ({RichCompletion('test', 4, 'test()', 'func')}, 'test', 'test_completion')])\ndef test_auto_suggest_completion(completions, document_text, ptk_completion, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lprefix = len(document_text)\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = (completions, lprefix)\n    xession.env['AUTO_SUGGEST_IN_COMPLETIONS'] = True\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: ptk_completion\n    document_mock = MagicMock()\n    document_mock.text = document_text\n    document_mock.current_line = document_text\n    document_mock.cursor_position_col = lprefix\n    auto_suggested = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    assert PTKCompletion(ptk_completion, -lprefix) in auto_suggested",
            "@pytest.mark.parametrize('completions, document_text, ptk_completion', [(set(), '', 'test_completion'), (set(), 'test_', 'test_completion'), ({RichCompletion('test', 4, 'test()', 'func')}, 'test', 'test_completion')])\ndef test_auto_suggest_completion(completions, document_text, ptk_completion, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lprefix = len(document_text)\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = (completions, lprefix)\n    xession.env['AUTO_SUGGEST_IN_COMPLETIONS'] = True\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: ptk_completion\n    document_mock = MagicMock()\n    document_mock.text = document_text\n    document_mock.current_line = document_text\n    document_mock.cursor_position_col = lprefix\n    auto_suggested = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    assert PTKCompletion(ptk_completion, -lprefix) in auto_suggested",
            "@pytest.mark.parametrize('completions, document_text, ptk_completion', [(set(), '', 'test_completion'), (set(), 'test_', 'test_completion'), ({RichCompletion('test', 4, 'test()', 'func')}, 'test', 'test_completion')])\ndef test_auto_suggest_completion(completions, document_text, ptk_completion, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lprefix = len(document_text)\n    xonsh_completer_mock = MagicMock()\n    xonsh_completer_mock.complete.return_value = (completions, lprefix)\n    xession.env['AUTO_SUGGEST_IN_COMPLETIONS'] = True\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: ptk_completion\n    document_mock = MagicMock()\n    document_mock.text = document_text\n    document_mock.current_line = document_text\n    document_mock.cursor_position_col = lprefix\n    auto_suggested = list(ptk_completer.get_completions(document_mock, MagicMock()))\n    assert PTKCompletion(ptk_completion, -lprefix) in auto_suggested"
        ]
    },
    {
        "func_name": "test_alias_expansion",
        "original": "@pytest.mark.parametrize('code, index, expected_args', EXPANSION_CASES)\ndef test_alias_expansion(code, index, expected_args, monkeypatch, xession):\n    xonsh_completer_mock = MagicMock(spec=Completer)\n    xonsh_completer_mock.complete.return_value = (set(), 0)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases(gb=['git branch']))\n    list(ptk_completer.get_completions(Document(code, index), MagicMock()))\n    mock_call = xonsh_completer_mock.complete.call_args\n    (args, kwargs) = mock_call\n    expected_args['self'] = None\n    expected_args['ctx'] = None\n    assert signature(Completer.complete).bind(None, *args, **kwargs).arguments == expected_args",
        "mutated": [
            "@pytest.mark.parametrize('code, index, expected_args', EXPANSION_CASES)\ndef test_alias_expansion(code, index, expected_args, monkeypatch, xession):\n    if False:\n        i = 10\n    xonsh_completer_mock = MagicMock(spec=Completer)\n    xonsh_completer_mock.complete.return_value = (set(), 0)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases(gb=['git branch']))\n    list(ptk_completer.get_completions(Document(code, index), MagicMock()))\n    mock_call = xonsh_completer_mock.complete.call_args\n    (args, kwargs) = mock_call\n    expected_args['self'] = None\n    expected_args['ctx'] = None\n    assert signature(Completer.complete).bind(None, *args, **kwargs).arguments == expected_args",
            "@pytest.mark.parametrize('code, index, expected_args', EXPANSION_CASES)\ndef test_alias_expansion(code, index, expected_args, monkeypatch, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    xonsh_completer_mock = MagicMock(spec=Completer)\n    xonsh_completer_mock.complete.return_value = (set(), 0)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases(gb=['git branch']))\n    list(ptk_completer.get_completions(Document(code, index), MagicMock()))\n    mock_call = xonsh_completer_mock.complete.call_args\n    (args, kwargs) = mock_call\n    expected_args['self'] = None\n    expected_args['ctx'] = None\n    assert signature(Completer.complete).bind(None, *args, **kwargs).arguments == expected_args",
            "@pytest.mark.parametrize('code, index, expected_args', EXPANSION_CASES)\ndef test_alias_expansion(code, index, expected_args, monkeypatch, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    xonsh_completer_mock = MagicMock(spec=Completer)\n    xonsh_completer_mock.complete.return_value = (set(), 0)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases(gb=['git branch']))\n    list(ptk_completer.get_completions(Document(code, index), MagicMock()))\n    mock_call = xonsh_completer_mock.complete.call_args\n    (args, kwargs) = mock_call\n    expected_args['self'] = None\n    expected_args['ctx'] = None\n    assert signature(Completer.complete).bind(None, *args, **kwargs).arguments == expected_args",
            "@pytest.mark.parametrize('code, index, expected_args', EXPANSION_CASES)\ndef test_alias_expansion(code, index, expected_args, monkeypatch, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    xonsh_completer_mock = MagicMock(spec=Completer)\n    xonsh_completer_mock.complete.return_value = (set(), 0)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases(gb=['git branch']))\n    list(ptk_completer.get_completions(Document(code, index), MagicMock()))\n    mock_call = xonsh_completer_mock.complete.call_args\n    (args, kwargs) = mock_call\n    expected_args['self'] = None\n    expected_args['ctx'] = None\n    assert signature(Completer.complete).bind(None, *args, **kwargs).arguments == expected_args",
            "@pytest.mark.parametrize('code, index, expected_args', EXPANSION_CASES)\ndef test_alias_expansion(code, index, expected_args, monkeypatch, xession):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    xonsh_completer_mock = MagicMock(spec=Completer)\n    xonsh_completer_mock.complete.return_value = (set(), 0)\n    ptk_completer = PromptToolkitCompleter(xonsh_completer_mock, None, None)\n    ptk_completer.reserve_space = lambda : None\n    ptk_completer.suggestion_completion = lambda _, __: None\n    monkeypatch.setattr(xession.commands_cache, 'aliases', Aliases(gb=['git branch']))\n    list(ptk_completer.get_completions(Document(code, index), MagicMock()))\n    mock_call = xonsh_completer_mock.complete.call_args\n    (args, kwargs) = mock_call\n    expected_args['self'] = None\n    expected_args['ctx'] = None\n    assert signature(Completer.complete).bind(None, *args, **kwargs).arguments == expected_args"
        ]
    }
]