[
    {
        "func_name": "get_feature_range_mask",
        "original": "def get_feature_range_mask(X, filler_feature_values=None, filler_feature_ranges=None):\n    \"\"\"\n    Function that constucts a boolean array to get rid of samples\n    in X that are outside the feature range specified by filler_feature_values\n    and filler_feature_ranges\n    \"\"\"\n    if not isinstance(X, np.ndarray) or not len(X.shape) == 2:\n        raise ValueError('X must be a 2D array')\n    elif filler_feature_values is None:\n        raise ValueError('filler_feature_values must not be None')\n    elif filler_feature_ranges is None:\n        raise ValueError('filler_feature_ranges must not be None')\n    mask = np.ones(X.shape[0], dtype=bool)\n    for feature_idx in filler_feature_ranges:\n        feature_value = filler_feature_values[feature_idx]\n        feature_width = filler_feature_ranges[feature_idx]\n        upp_limit = feature_value + feature_width\n        low_limit = feature_value - feature_width\n        feature_mask = (X[:, feature_idx] > low_limit) & (X[:, feature_idx] < upp_limit)\n        mask = mask & feature_mask\n    return mask",
        "mutated": [
            "def get_feature_range_mask(X, filler_feature_values=None, filler_feature_ranges=None):\n    if False:\n        i = 10\n    '\\n    Function that constucts a boolean array to get rid of samples\\n    in X that are outside the feature range specified by filler_feature_values\\n    and filler_feature_ranges\\n    '\n    if not isinstance(X, np.ndarray) or not len(X.shape) == 2:\n        raise ValueError('X must be a 2D array')\n    elif filler_feature_values is None:\n        raise ValueError('filler_feature_values must not be None')\n    elif filler_feature_ranges is None:\n        raise ValueError('filler_feature_ranges must not be None')\n    mask = np.ones(X.shape[0], dtype=bool)\n    for feature_idx in filler_feature_ranges:\n        feature_value = filler_feature_values[feature_idx]\n        feature_width = filler_feature_ranges[feature_idx]\n        upp_limit = feature_value + feature_width\n        low_limit = feature_value - feature_width\n        feature_mask = (X[:, feature_idx] > low_limit) & (X[:, feature_idx] < upp_limit)\n        mask = mask & feature_mask\n    return mask",
            "def get_feature_range_mask(X, filler_feature_values=None, filler_feature_ranges=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Function that constucts a boolean array to get rid of samples\\n    in X that are outside the feature range specified by filler_feature_values\\n    and filler_feature_ranges\\n    '\n    if not isinstance(X, np.ndarray) or not len(X.shape) == 2:\n        raise ValueError('X must be a 2D array')\n    elif filler_feature_values is None:\n        raise ValueError('filler_feature_values must not be None')\n    elif filler_feature_ranges is None:\n        raise ValueError('filler_feature_ranges must not be None')\n    mask = np.ones(X.shape[0], dtype=bool)\n    for feature_idx in filler_feature_ranges:\n        feature_value = filler_feature_values[feature_idx]\n        feature_width = filler_feature_ranges[feature_idx]\n        upp_limit = feature_value + feature_width\n        low_limit = feature_value - feature_width\n        feature_mask = (X[:, feature_idx] > low_limit) & (X[:, feature_idx] < upp_limit)\n        mask = mask & feature_mask\n    return mask",
            "def get_feature_range_mask(X, filler_feature_values=None, filler_feature_ranges=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Function that constucts a boolean array to get rid of samples\\n    in X that are outside the feature range specified by filler_feature_values\\n    and filler_feature_ranges\\n    '\n    if not isinstance(X, np.ndarray) or not len(X.shape) == 2:\n        raise ValueError('X must be a 2D array')\n    elif filler_feature_values is None:\n        raise ValueError('filler_feature_values must not be None')\n    elif filler_feature_ranges is None:\n        raise ValueError('filler_feature_ranges must not be None')\n    mask = np.ones(X.shape[0], dtype=bool)\n    for feature_idx in filler_feature_ranges:\n        feature_value = filler_feature_values[feature_idx]\n        feature_width = filler_feature_ranges[feature_idx]\n        upp_limit = feature_value + feature_width\n        low_limit = feature_value - feature_width\n        feature_mask = (X[:, feature_idx] > low_limit) & (X[:, feature_idx] < upp_limit)\n        mask = mask & feature_mask\n    return mask",
            "def get_feature_range_mask(X, filler_feature_values=None, filler_feature_ranges=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Function that constucts a boolean array to get rid of samples\\n    in X that are outside the feature range specified by filler_feature_values\\n    and filler_feature_ranges\\n    '\n    if not isinstance(X, np.ndarray) or not len(X.shape) == 2:\n        raise ValueError('X must be a 2D array')\n    elif filler_feature_values is None:\n        raise ValueError('filler_feature_values must not be None')\n    elif filler_feature_ranges is None:\n        raise ValueError('filler_feature_ranges must not be None')\n    mask = np.ones(X.shape[0], dtype=bool)\n    for feature_idx in filler_feature_ranges:\n        feature_value = filler_feature_values[feature_idx]\n        feature_width = filler_feature_ranges[feature_idx]\n        upp_limit = feature_value + feature_width\n        low_limit = feature_value - feature_width\n        feature_mask = (X[:, feature_idx] > low_limit) & (X[:, feature_idx] < upp_limit)\n        mask = mask & feature_mask\n    return mask",
            "def get_feature_range_mask(X, filler_feature_values=None, filler_feature_ranges=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Function that constucts a boolean array to get rid of samples\\n    in X that are outside the feature range specified by filler_feature_values\\n    and filler_feature_ranges\\n    '\n    if not isinstance(X, np.ndarray) or not len(X.shape) == 2:\n        raise ValueError('X must be a 2D array')\n    elif filler_feature_values is None:\n        raise ValueError('filler_feature_values must not be None')\n    elif filler_feature_ranges is None:\n        raise ValueError('filler_feature_ranges must not be None')\n    mask = np.ones(X.shape[0], dtype=bool)\n    for feature_idx in filler_feature_ranges:\n        feature_value = filler_feature_values[feature_idx]\n        feature_width = filler_feature_ranges[feature_idx]\n        upp_limit = feature_value + feature_width\n        low_limit = feature_value - feature_width\n        feature_mask = (X[:, feature_idx] > low_limit) & (X[:, feature_idx] < upp_limit)\n        mask = mask & feature_mask\n    return mask"
        ]
    },
    {
        "func_name": "parallel",
        "original": "def parallel(X_predict, clf, xtype):\n    Z = clf.predict(X_predict.astype(xtype))\n    return Z",
        "mutated": [
            "def parallel(X_predict, clf, xtype):\n    if False:\n        i = 10\n    Z = clf.predict(X_predict.astype(xtype))\n    return Z",
            "def parallel(X_predict, clf, xtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Z = clf.predict(X_predict.astype(xtype))\n    return Z",
            "def parallel(X_predict, clf, xtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Z = clf.predict(X_predict.astype(xtype))\n    return Z",
            "def parallel(X_predict, clf, xtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Z = clf.predict(X_predict.astype(xtype))\n    return Z",
            "def parallel(X_predict, clf, xtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Z = clf.predict(X_predict.astype(xtype))\n    return Z"
        ]
    },
    {
        "func_name": "plot_decision_regions",
        "original": "def plot_decision_regions(X, y, clf, feature_index=None, filler_feature_values=None, filler_feature_ranges=None, ax=None, X_highlight=None, zoom_factor=1.0, legend=1, hide_spines=True, markers='s^oxv<>', colors='#1f77b4,#ff7f0e,#3ca02c,#d62728,#9467bd,#8c564b,#e377c2,#7f7f7f,#bcbd22,#17becf', scatter_kwargs=None, contourf_kwargs=None, contour_kwargs=None, scatter_highlight_kwargs=None, n_jobs=None):\n    \"\"\"Plot decision regions of a classifier.\n\n    Please note that this functions assumes that class labels are\n    labeled consecutively, e.g,. 0, 1, 2, 3, 4, and 5. If you have class\n    labels with integer labels > 4, you may want to provide additional colors\n    and/or markers as `colors` and `markers` arguments.\n    See https://matplotlib.org/examples/color/named_colors.html for more\n    information.\n\n    Parameters\n    ----------\n    X : array-like, shape = [n_samples, n_features]\n        Feature Matrix.\n\n    y : array-like, shape = [n_samples]\n        True class labels.\n\n    clf : Classifier object.\n        Must have a .predict method.\n\n    feature_index : array-like (default: (0,) for 1D, (0, 1) otherwise)\n        Feature indices to use for plotting. The first index in\n        `feature_index` will be on the x-axis, the second index will be\n        on the y-axis.\n\n    filler_feature_values : dict (default: None)\n        Only needed for number features > 2. Dictionary of feature\n        index-value pairs for the features not being plotted.\n\n    filler_feature_ranges : dict (default: None)\n        Only needed for number features > 2. Dictionary of feature\n        index-value pairs for the features not being plotted. Will use the\n        ranges provided to select training samples for plotting.\n\n    ax : matplotlib.axes.Axes (default: None)\n        An existing matplotlib Axes. Creates\n        one if ax=None.\n\n    X_highlight : array-like, shape = [n_samples, n_features] (default: None)\n        An array with data points that are used to highlight samples in `X`.\n\n    zoom_factor : float (default: 1.0)\n        Controls the scale of the x- and y-axis of the decision plot.\n\n    hide_spines : bool (default: True)\n        Hide axis spines if True.\n\n    legend : int (default: 1)\n        Integer to specify the legend location.\n        No legend if legend is 0.\n\n    markers : str (default: 's^oxv<>')\n        Scatterplot markers.\n\n    colors : str (default: 'red,blue,limegreen,gray,cyan')\n        Comma separated list of colors.\n\n    scatter_kwargs : dict (default: None)\n        Keyword arguments for underlying matplotlib scatter function.\n\n    contourf_kwargs : dict (default: None)\n        Keyword arguments for underlying matplotlib contourf function.\n\n    contour_kwargs : dict (default: None)\n        Keyword arguments for underlying matplotlib contour function\n        (which draws the lines between decision regions).\n\n    scatter_highlight_kwargs : dict (default: None)\n        Keyword arguments for underlying matplotlib scatter function.\n\n    n_jobs : int or None, optional (default=None)\n        The number of CPUs to use to do the computation using Python's\n        multiprocessing library.\n        `None` means 1.\n        `-1` means using all processors. New in v0.22.0.\n\n    Returns\n    ---------\n    ax : matplotlib.axes.Axes object\n\n    Examples\n    -----------\n    For usage examples, please see\n    https://rasbt.github.io/mlxtend/user_guide/plotting/plot_decision_regions/\n\n    \"\"\"\n    check_Xy(X, y, y_int=True)\n    dim = X.shape[1]\n    if n_jobs is None:\n        n_jobs = 1\n    if ax is None:\n        ax = plt.gca()\n    plot_testdata = True\n    if not isinstance(X_highlight, np.ndarray):\n        if X_highlight is not None:\n            raise ValueError('X_highlight must be a NumPy array or None')\n        else:\n            plot_testdata = False\n    elif len(X_highlight.shape) < 2:\n        raise ValueError('X_highlight must be a 2D array')\n    if feature_index is not None:\n        if dim == 1:\n            raise ValueError('feature_index requires more than one training feature')\n        try:\n            (x_index, y_index) = feature_index\n        except ValueError:\n            raise ValueError('Unable to unpack feature_index. Make sure feature_index only has two dimensions.')\n        try:\n            (X[:, x_index], X[:, y_index])\n        except IndexError:\n            raise IndexError('feature_index values out of range. X.shape is {}, but feature_index is {}'.format(X.shape, feature_index))\n    else:\n        feature_index = (0, 1)\n        (x_index, y_index) = feature_index\n    if dim > 2:\n        if filler_feature_values is None:\n            raise ValueError('Filler values must be provided when X has more than 2 training features.')\n        if filler_feature_ranges is not None:\n            if not set(filler_feature_values) == set(filler_feature_ranges):\n                raise ValueError('filler_feature_values and filler_feature_ranges must have the same keys')\n        column_check = np.zeros(dim, dtype=bool)\n        for idx in filler_feature_values:\n            column_check[idx] = True\n        for idx in feature_index:\n            column_check[idx] = True\n        if not all(column_check):\n            missing_cols = np.argwhere(~column_check).flatten()\n            raise ValueError('Column(s) {} need to be accounted for in either feature_index or filler_feature_values'.format(missing_cols))\n    if n_jobs > mp.cpu_count():\n        raise ValueError('Number of defined CPU cores is more than the available resources {} '.format(mp.cpu_count()))\n    marker_gen = cycle(list(markers))\n    n_classes = np.unique(y).shape[0]\n    colors = colors.split(',')\n    colors_gen = cycle(colors)\n    colors = [next(colors_gen) for c in range(n_classes)]\n    (x_min, x_max) = (X[:, x_index].min() - 1.0 / zoom_factor, X[:, x_index].max() + 1.0 / zoom_factor)\n    if dim == 1:\n        (y_min, y_max) = (-1, 1)\n    else:\n        (y_min, y_max) = (X[:, y_index].min() - 1.0 / zoom_factor, X[:, y_index].max() + 1.0 / zoom_factor)\n    (xnum, ynum) = plt.gcf().dpi * plt.gcf().get_size_inches()\n    (xnum, ynum) = (floor(xnum), ceil(ynum))\n    (xx, yy) = np.meshgrid(np.linspace(x_min, x_max, num=xnum), np.linspace(y_min, y_max, num=ynum))\n    if dim == 1:\n        X_predict = np.array([xx.ravel()]).T\n    else:\n        X_grid = np.array([xx.ravel(), yy.ravel()]).T\n        X_predict = np.zeros((X_grid.shape[0], dim))\n        X_predict[:, x_index] = X_grid[:, 0]\n        X_predict[:, y_index] = X_grid[:, 1]\n        if dim > 2:\n            for feature_idx in filler_feature_values:\n                X_predict[:, feature_idx] = filler_feature_values[feature_idx]\n    if n_jobs == 1:\n        Z = clf.predict(X_predict.astype(X.dtype))\n        Z = Z.reshape(xx.shape)\n    else:\n        if n_jobs == -1:\n            cpus = mp.cpu_count()\n        else:\n            cpus = n_jobs\n        pool = mp.Pool(cpus)\n        partQuant = len(X_predict) / cpus\n        partitions = []\n        for n in range(cpus - 1):\n            (start, end) = (np.floor(partQuant * n).astype(int), np.floor(partQuant * (n + 1)).astype(int))\n            partitions.append(X_predict[start:end])\n        partitions.append(X_predict[end:])\n        xtype = X.dtype\n        Z = pool.starmap(parallel, [(x, clf, xtype) for x in partitions])\n        pool.close()\n        Z = np.concatenate(Z)\n        Z = Z.reshape(xx.shape)\n    contourf_kwargs_default = {'alpha': 0.45, 'antialiased': True}\n    contourf_kwargs = format_kwarg_dictionaries(default_kwargs=contourf_kwargs_default, user_kwargs=contourf_kwargs, protected_keys=['colors', 'levels'])\n    cset = ax.contourf(xx, yy, Z, colors=colors, levels=np.arange(Z.max() + 2) - 0.5, **contourf_kwargs)\n    contour_kwargs_default = {'linewidths': 0.5, 'colors': 'k', 'antialiased': True}\n    contour_kwargs = format_kwarg_dictionaries(default_kwargs=contour_kwargs_default, user_kwargs=contour_kwargs, protected_keys=[])\n    ax.contour(xx, yy, Z, cset.levels, **contour_kwargs)\n    ax.axis([xx.min(), xx.max(), yy.min(), yy.max()])\n    scatter_kwargs_default = {'alpha': 0.8, 'edgecolor': 'black'}\n    scatter_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_kwargs_default, user_kwargs=scatter_kwargs, protected_keys=['c', 'marker', 'label'])\n    for (idx, c) in enumerate(np.unique(y)):\n        if dim == 1:\n            y_data = [0 for i in X[y == c]]\n            x_data = X[y == c]\n        elif dim == 2:\n            y_data = X[y == c, y_index]\n            x_data = X[y == c, x_index]\n        elif dim > 2 and filler_feature_ranges is not None:\n            class_mask = y == c\n            feature_range_mask = get_feature_range_mask(X, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X[class_mask & feature_range_mask, y_index]\n            x_data = X[class_mask & feature_range_mask, x_index]\n        else:\n            continue\n        ax.scatter(x=x_data, y=y_data, c=colors[idx], marker=next(marker_gen), label=c, **scatter_kwargs)\n    if hide_spines:\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['bottom'].set_visible(False)\n    ax.yaxis.set_ticks_position('left')\n    ax.xaxis.set_ticks_position('bottom')\n    if dim == 1:\n        ax.axes.get_yaxis().set_ticks([])\n    if plot_testdata:\n        if dim == 1:\n            x_data = X_highlight\n            y_data = [0 for i in X_highlight]\n        elif dim == 2:\n            x_data = X_highlight[:, x_index]\n            y_data = X_highlight[:, y_index]\n        else:\n            feature_range_mask = get_feature_range_mask(X_highlight, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X_highlight[feature_range_mask, y_index]\n            x_data = X_highlight[feature_range_mask, x_index]\n        scatter_highlight_defaults = {'c': 'none', 'edgecolor': 'black', 'alpha': 1.0, 'linewidths': 1, 'marker': 'o', 's': 80}\n        scatter_highlight_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_highlight_defaults, user_kwargs=scatter_highlight_kwargs)\n        ax.scatter(x_data, y_data, **scatter_highlight_kwargs)\n    if legend:\n        if dim > 2 and filler_feature_ranges is None:\n            pass\n        else:\n            (handles, labels) = ax.get_legend_handles_labels()\n            ax.legend(handles, labels, framealpha=0.3, scatterpoints=1, loc=legend)\n    return ax",
        "mutated": [
            "def plot_decision_regions(X, y, clf, feature_index=None, filler_feature_values=None, filler_feature_ranges=None, ax=None, X_highlight=None, zoom_factor=1.0, legend=1, hide_spines=True, markers='s^oxv<>', colors='#1f77b4,#ff7f0e,#3ca02c,#d62728,#9467bd,#8c564b,#e377c2,#7f7f7f,#bcbd22,#17becf', scatter_kwargs=None, contourf_kwargs=None, contour_kwargs=None, scatter_highlight_kwargs=None, n_jobs=None):\n    if False:\n        i = 10\n    \"Plot decision regions of a classifier.\\n\\n    Please note that this functions assumes that class labels are\\n    labeled consecutively, e.g,. 0, 1, 2, 3, 4, and 5. If you have class\\n    labels with integer labels > 4, you may want to provide additional colors\\n    and/or markers as `colors` and `markers` arguments.\\n    See https://matplotlib.org/examples/color/named_colors.html for more\\n    information.\\n\\n    Parameters\\n    ----------\\n    X : array-like, shape = [n_samples, n_features]\\n        Feature Matrix.\\n\\n    y : array-like, shape = [n_samples]\\n        True class labels.\\n\\n    clf : Classifier object.\\n        Must have a .predict method.\\n\\n    feature_index : array-like (default: (0,) for 1D, (0, 1) otherwise)\\n        Feature indices to use for plotting. The first index in\\n        `feature_index` will be on the x-axis, the second index will be\\n        on the y-axis.\\n\\n    filler_feature_values : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted.\\n\\n    filler_feature_ranges : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted. Will use the\\n        ranges provided to select training samples for plotting.\\n\\n    ax : matplotlib.axes.Axes (default: None)\\n        An existing matplotlib Axes. Creates\\n        one if ax=None.\\n\\n    X_highlight : array-like, shape = [n_samples, n_features] (default: None)\\n        An array with data points that are used to highlight samples in `X`.\\n\\n    zoom_factor : float (default: 1.0)\\n        Controls the scale of the x- and y-axis of the decision plot.\\n\\n    hide_spines : bool (default: True)\\n        Hide axis spines if True.\\n\\n    legend : int (default: 1)\\n        Integer to specify the legend location.\\n        No legend if legend is 0.\\n\\n    markers : str (default: 's^oxv<>')\\n        Scatterplot markers.\\n\\n    colors : str (default: 'red,blue,limegreen,gray,cyan')\\n        Comma separated list of colors.\\n\\n    scatter_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    contourf_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contourf function.\\n\\n    contour_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contour function\\n        (which draws the lines between decision regions).\\n\\n    scatter_highlight_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    n_jobs : int or None, optional (default=None)\\n        The number of CPUs to use to do the computation using Python's\\n        multiprocessing library.\\n        `None` means 1.\\n        `-1` means using all processors. New in v0.22.0.\\n\\n    Returns\\n    ---------\\n    ax : matplotlib.axes.Axes object\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/plotting/plot_decision_regions/\\n\\n    \"\n    check_Xy(X, y, y_int=True)\n    dim = X.shape[1]\n    if n_jobs is None:\n        n_jobs = 1\n    if ax is None:\n        ax = plt.gca()\n    plot_testdata = True\n    if not isinstance(X_highlight, np.ndarray):\n        if X_highlight is not None:\n            raise ValueError('X_highlight must be a NumPy array or None')\n        else:\n            plot_testdata = False\n    elif len(X_highlight.shape) < 2:\n        raise ValueError('X_highlight must be a 2D array')\n    if feature_index is not None:\n        if dim == 1:\n            raise ValueError('feature_index requires more than one training feature')\n        try:\n            (x_index, y_index) = feature_index\n        except ValueError:\n            raise ValueError('Unable to unpack feature_index. Make sure feature_index only has two dimensions.')\n        try:\n            (X[:, x_index], X[:, y_index])\n        except IndexError:\n            raise IndexError('feature_index values out of range. X.shape is {}, but feature_index is {}'.format(X.shape, feature_index))\n    else:\n        feature_index = (0, 1)\n        (x_index, y_index) = feature_index\n    if dim > 2:\n        if filler_feature_values is None:\n            raise ValueError('Filler values must be provided when X has more than 2 training features.')\n        if filler_feature_ranges is not None:\n            if not set(filler_feature_values) == set(filler_feature_ranges):\n                raise ValueError('filler_feature_values and filler_feature_ranges must have the same keys')\n        column_check = np.zeros(dim, dtype=bool)\n        for idx in filler_feature_values:\n            column_check[idx] = True\n        for idx in feature_index:\n            column_check[idx] = True\n        if not all(column_check):\n            missing_cols = np.argwhere(~column_check).flatten()\n            raise ValueError('Column(s) {} need to be accounted for in either feature_index or filler_feature_values'.format(missing_cols))\n    if n_jobs > mp.cpu_count():\n        raise ValueError('Number of defined CPU cores is more than the available resources {} '.format(mp.cpu_count()))\n    marker_gen = cycle(list(markers))\n    n_classes = np.unique(y).shape[0]\n    colors = colors.split(',')\n    colors_gen = cycle(colors)\n    colors = [next(colors_gen) for c in range(n_classes)]\n    (x_min, x_max) = (X[:, x_index].min() - 1.0 / zoom_factor, X[:, x_index].max() + 1.0 / zoom_factor)\n    if dim == 1:\n        (y_min, y_max) = (-1, 1)\n    else:\n        (y_min, y_max) = (X[:, y_index].min() - 1.0 / zoom_factor, X[:, y_index].max() + 1.0 / zoom_factor)\n    (xnum, ynum) = plt.gcf().dpi * plt.gcf().get_size_inches()\n    (xnum, ynum) = (floor(xnum), ceil(ynum))\n    (xx, yy) = np.meshgrid(np.linspace(x_min, x_max, num=xnum), np.linspace(y_min, y_max, num=ynum))\n    if dim == 1:\n        X_predict = np.array([xx.ravel()]).T\n    else:\n        X_grid = np.array([xx.ravel(), yy.ravel()]).T\n        X_predict = np.zeros((X_grid.shape[0], dim))\n        X_predict[:, x_index] = X_grid[:, 0]\n        X_predict[:, y_index] = X_grid[:, 1]\n        if dim > 2:\n            for feature_idx in filler_feature_values:\n                X_predict[:, feature_idx] = filler_feature_values[feature_idx]\n    if n_jobs == 1:\n        Z = clf.predict(X_predict.astype(X.dtype))\n        Z = Z.reshape(xx.shape)\n    else:\n        if n_jobs == -1:\n            cpus = mp.cpu_count()\n        else:\n            cpus = n_jobs\n        pool = mp.Pool(cpus)\n        partQuant = len(X_predict) / cpus\n        partitions = []\n        for n in range(cpus - 1):\n            (start, end) = (np.floor(partQuant * n).astype(int), np.floor(partQuant * (n + 1)).astype(int))\n            partitions.append(X_predict[start:end])\n        partitions.append(X_predict[end:])\n        xtype = X.dtype\n        Z = pool.starmap(parallel, [(x, clf, xtype) for x in partitions])\n        pool.close()\n        Z = np.concatenate(Z)\n        Z = Z.reshape(xx.shape)\n    contourf_kwargs_default = {'alpha': 0.45, 'antialiased': True}\n    contourf_kwargs = format_kwarg_dictionaries(default_kwargs=contourf_kwargs_default, user_kwargs=contourf_kwargs, protected_keys=['colors', 'levels'])\n    cset = ax.contourf(xx, yy, Z, colors=colors, levels=np.arange(Z.max() + 2) - 0.5, **contourf_kwargs)\n    contour_kwargs_default = {'linewidths': 0.5, 'colors': 'k', 'antialiased': True}\n    contour_kwargs = format_kwarg_dictionaries(default_kwargs=contour_kwargs_default, user_kwargs=contour_kwargs, protected_keys=[])\n    ax.contour(xx, yy, Z, cset.levels, **contour_kwargs)\n    ax.axis([xx.min(), xx.max(), yy.min(), yy.max()])\n    scatter_kwargs_default = {'alpha': 0.8, 'edgecolor': 'black'}\n    scatter_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_kwargs_default, user_kwargs=scatter_kwargs, protected_keys=['c', 'marker', 'label'])\n    for (idx, c) in enumerate(np.unique(y)):\n        if dim == 1:\n            y_data = [0 for i in X[y == c]]\n            x_data = X[y == c]\n        elif dim == 2:\n            y_data = X[y == c, y_index]\n            x_data = X[y == c, x_index]\n        elif dim > 2 and filler_feature_ranges is not None:\n            class_mask = y == c\n            feature_range_mask = get_feature_range_mask(X, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X[class_mask & feature_range_mask, y_index]\n            x_data = X[class_mask & feature_range_mask, x_index]\n        else:\n            continue\n        ax.scatter(x=x_data, y=y_data, c=colors[idx], marker=next(marker_gen), label=c, **scatter_kwargs)\n    if hide_spines:\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['bottom'].set_visible(False)\n    ax.yaxis.set_ticks_position('left')\n    ax.xaxis.set_ticks_position('bottom')\n    if dim == 1:\n        ax.axes.get_yaxis().set_ticks([])\n    if plot_testdata:\n        if dim == 1:\n            x_data = X_highlight\n            y_data = [0 for i in X_highlight]\n        elif dim == 2:\n            x_data = X_highlight[:, x_index]\n            y_data = X_highlight[:, y_index]\n        else:\n            feature_range_mask = get_feature_range_mask(X_highlight, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X_highlight[feature_range_mask, y_index]\n            x_data = X_highlight[feature_range_mask, x_index]\n        scatter_highlight_defaults = {'c': 'none', 'edgecolor': 'black', 'alpha': 1.0, 'linewidths': 1, 'marker': 'o', 's': 80}\n        scatter_highlight_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_highlight_defaults, user_kwargs=scatter_highlight_kwargs)\n        ax.scatter(x_data, y_data, **scatter_highlight_kwargs)\n    if legend:\n        if dim > 2 and filler_feature_ranges is None:\n            pass\n        else:\n            (handles, labels) = ax.get_legend_handles_labels()\n            ax.legend(handles, labels, framealpha=0.3, scatterpoints=1, loc=legend)\n    return ax",
            "def plot_decision_regions(X, y, clf, feature_index=None, filler_feature_values=None, filler_feature_ranges=None, ax=None, X_highlight=None, zoom_factor=1.0, legend=1, hide_spines=True, markers='s^oxv<>', colors='#1f77b4,#ff7f0e,#3ca02c,#d62728,#9467bd,#8c564b,#e377c2,#7f7f7f,#bcbd22,#17becf', scatter_kwargs=None, contourf_kwargs=None, contour_kwargs=None, scatter_highlight_kwargs=None, n_jobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Plot decision regions of a classifier.\\n\\n    Please note that this functions assumes that class labels are\\n    labeled consecutively, e.g,. 0, 1, 2, 3, 4, and 5. If you have class\\n    labels with integer labels > 4, you may want to provide additional colors\\n    and/or markers as `colors` and `markers` arguments.\\n    See https://matplotlib.org/examples/color/named_colors.html for more\\n    information.\\n\\n    Parameters\\n    ----------\\n    X : array-like, shape = [n_samples, n_features]\\n        Feature Matrix.\\n\\n    y : array-like, shape = [n_samples]\\n        True class labels.\\n\\n    clf : Classifier object.\\n        Must have a .predict method.\\n\\n    feature_index : array-like (default: (0,) for 1D, (0, 1) otherwise)\\n        Feature indices to use for plotting. The first index in\\n        `feature_index` will be on the x-axis, the second index will be\\n        on the y-axis.\\n\\n    filler_feature_values : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted.\\n\\n    filler_feature_ranges : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted. Will use the\\n        ranges provided to select training samples for plotting.\\n\\n    ax : matplotlib.axes.Axes (default: None)\\n        An existing matplotlib Axes. Creates\\n        one if ax=None.\\n\\n    X_highlight : array-like, shape = [n_samples, n_features] (default: None)\\n        An array with data points that are used to highlight samples in `X`.\\n\\n    zoom_factor : float (default: 1.0)\\n        Controls the scale of the x- and y-axis of the decision plot.\\n\\n    hide_spines : bool (default: True)\\n        Hide axis spines if True.\\n\\n    legend : int (default: 1)\\n        Integer to specify the legend location.\\n        No legend if legend is 0.\\n\\n    markers : str (default: 's^oxv<>')\\n        Scatterplot markers.\\n\\n    colors : str (default: 'red,blue,limegreen,gray,cyan')\\n        Comma separated list of colors.\\n\\n    scatter_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    contourf_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contourf function.\\n\\n    contour_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contour function\\n        (which draws the lines between decision regions).\\n\\n    scatter_highlight_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    n_jobs : int or None, optional (default=None)\\n        The number of CPUs to use to do the computation using Python's\\n        multiprocessing library.\\n        `None` means 1.\\n        `-1` means using all processors. New in v0.22.0.\\n\\n    Returns\\n    ---------\\n    ax : matplotlib.axes.Axes object\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/plotting/plot_decision_regions/\\n\\n    \"\n    check_Xy(X, y, y_int=True)\n    dim = X.shape[1]\n    if n_jobs is None:\n        n_jobs = 1\n    if ax is None:\n        ax = plt.gca()\n    plot_testdata = True\n    if not isinstance(X_highlight, np.ndarray):\n        if X_highlight is not None:\n            raise ValueError('X_highlight must be a NumPy array or None')\n        else:\n            plot_testdata = False\n    elif len(X_highlight.shape) < 2:\n        raise ValueError('X_highlight must be a 2D array')\n    if feature_index is not None:\n        if dim == 1:\n            raise ValueError('feature_index requires more than one training feature')\n        try:\n            (x_index, y_index) = feature_index\n        except ValueError:\n            raise ValueError('Unable to unpack feature_index. Make sure feature_index only has two dimensions.')\n        try:\n            (X[:, x_index], X[:, y_index])\n        except IndexError:\n            raise IndexError('feature_index values out of range. X.shape is {}, but feature_index is {}'.format(X.shape, feature_index))\n    else:\n        feature_index = (0, 1)\n        (x_index, y_index) = feature_index\n    if dim > 2:\n        if filler_feature_values is None:\n            raise ValueError('Filler values must be provided when X has more than 2 training features.')\n        if filler_feature_ranges is not None:\n            if not set(filler_feature_values) == set(filler_feature_ranges):\n                raise ValueError('filler_feature_values and filler_feature_ranges must have the same keys')\n        column_check = np.zeros(dim, dtype=bool)\n        for idx in filler_feature_values:\n            column_check[idx] = True\n        for idx in feature_index:\n            column_check[idx] = True\n        if not all(column_check):\n            missing_cols = np.argwhere(~column_check).flatten()\n            raise ValueError('Column(s) {} need to be accounted for in either feature_index or filler_feature_values'.format(missing_cols))\n    if n_jobs > mp.cpu_count():\n        raise ValueError('Number of defined CPU cores is more than the available resources {} '.format(mp.cpu_count()))\n    marker_gen = cycle(list(markers))\n    n_classes = np.unique(y).shape[0]\n    colors = colors.split(',')\n    colors_gen = cycle(colors)\n    colors = [next(colors_gen) for c in range(n_classes)]\n    (x_min, x_max) = (X[:, x_index].min() - 1.0 / zoom_factor, X[:, x_index].max() + 1.0 / zoom_factor)\n    if dim == 1:\n        (y_min, y_max) = (-1, 1)\n    else:\n        (y_min, y_max) = (X[:, y_index].min() - 1.0 / zoom_factor, X[:, y_index].max() + 1.0 / zoom_factor)\n    (xnum, ynum) = plt.gcf().dpi * plt.gcf().get_size_inches()\n    (xnum, ynum) = (floor(xnum), ceil(ynum))\n    (xx, yy) = np.meshgrid(np.linspace(x_min, x_max, num=xnum), np.linspace(y_min, y_max, num=ynum))\n    if dim == 1:\n        X_predict = np.array([xx.ravel()]).T\n    else:\n        X_grid = np.array([xx.ravel(), yy.ravel()]).T\n        X_predict = np.zeros((X_grid.shape[0], dim))\n        X_predict[:, x_index] = X_grid[:, 0]\n        X_predict[:, y_index] = X_grid[:, 1]\n        if dim > 2:\n            for feature_idx in filler_feature_values:\n                X_predict[:, feature_idx] = filler_feature_values[feature_idx]\n    if n_jobs == 1:\n        Z = clf.predict(X_predict.astype(X.dtype))\n        Z = Z.reshape(xx.shape)\n    else:\n        if n_jobs == -1:\n            cpus = mp.cpu_count()\n        else:\n            cpus = n_jobs\n        pool = mp.Pool(cpus)\n        partQuant = len(X_predict) / cpus\n        partitions = []\n        for n in range(cpus - 1):\n            (start, end) = (np.floor(partQuant * n).astype(int), np.floor(partQuant * (n + 1)).astype(int))\n            partitions.append(X_predict[start:end])\n        partitions.append(X_predict[end:])\n        xtype = X.dtype\n        Z = pool.starmap(parallel, [(x, clf, xtype) for x in partitions])\n        pool.close()\n        Z = np.concatenate(Z)\n        Z = Z.reshape(xx.shape)\n    contourf_kwargs_default = {'alpha': 0.45, 'antialiased': True}\n    contourf_kwargs = format_kwarg_dictionaries(default_kwargs=contourf_kwargs_default, user_kwargs=contourf_kwargs, protected_keys=['colors', 'levels'])\n    cset = ax.contourf(xx, yy, Z, colors=colors, levels=np.arange(Z.max() + 2) - 0.5, **contourf_kwargs)\n    contour_kwargs_default = {'linewidths': 0.5, 'colors': 'k', 'antialiased': True}\n    contour_kwargs = format_kwarg_dictionaries(default_kwargs=contour_kwargs_default, user_kwargs=contour_kwargs, protected_keys=[])\n    ax.contour(xx, yy, Z, cset.levels, **contour_kwargs)\n    ax.axis([xx.min(), xx.max(), yy.min(), yy.max()])\n    scatter_kwargs_default = {'alpha': 0.8, 'edgecolor': 'black'}\n    scatter_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_kwargs_default, user_kwargs=scatter_kwargs, protected_keys=['c', 'marker', 'label'])\n    for (idx, c) in enumerate(np.unique(y)):\n        if dim == 1:\n            y_data = [0 for i in X[y == c]]\n            x_data = X[y == c]\n        elif dim == 2:\n            y_data = X[y == c, y_index]\n            x_data = X[y == c, x_index]\n        elif dim > 2 and filler_feature_ranges is not None:\n            class_mask = y == c\n            feature_range_mask = get_feature_range_mask(X, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X[class_mask & feature_range_mask, y_index]\n            x_data = X[class_mask & feature_range_mask, x_index]\n        else:\n            continue\n        ax.scatter(x=x_data, y=y_data, c=colors[idx], marker=next(marker_gen), label=c, **scatter_kwargs)\n    if hide_spines:\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['bottom'].set_visible(False)\n    ax.yaxis.set_ticks_position('left')\n    ax.xaxis.set_ticks_position('bottom')\n    if dim == 1:\n        ax.axes.get_yaxis().set_ticks([])\n    if plot_testdata:\n        if dim == 1:\n            x_data = X_highlight\n            y_data = [0 for i in X_highlight]\n        elif dim == 2:\n            x_data = X_highlight[:, x_index]\n            y_data = X_highlight[:, y_index]\n        else:\n            feature_range_mask = get_feature_range_mask(X_highlight, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X_highlight[feature_range_mask, y_index]\n            x_data = X_highlight[feature_range_mask, x_index]\n        scatter_highlight_defaults = {'c': 'none', 'edgecolor': 'black', 'alpha': 1.0, 'linewidths': 1, 'marker': 'o', 's': 80}\n        scatter_highlight_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_highlight_defaults, user_kwargs=scatter_highlight_kwargs)\n        ax.scatter(x_data, y_data, **scatter_highlight_kwargs)\n    if legend:\n        if dim > 2 and filler_feature_ranges is None:\n            pass\n        else:\n            (handles, labels) = ax.get_legend_handles_labels()\n            ax.legend(handles, labels, framealpha=0.3, scatterpoints=1, loc=legend)\n    return ax",
            "def plot_decision_regions(X, y, clf, feature_index=None, filler_feature_values=None, filler_feature_ranges=None, ax=None, X_highlight=None, zoom_factor=1.0, legend=1, hide_spines=True, markers='s^oxv<>', colors='#1f77b4,#ff7f0e,#3ca02c,#d62728,#9467bd,#8c564b,#e377c2,#7f7f7f,#bcbd22,#17becf', scatter_kwargs=None, contourf_kwargs=None, contour_kwargs=None, scatter_highlight_kwargs=None, n_jobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Plot decision regions of a classifier.\\n\\n    Please note that this functions assumes that class labels are\\n    labeled consecutively, e.g,. 0, 1, 2, 3, 4, and 5. If you have class\\n    labels with integer labels > 4, you may want to provide additional colors\\n    and/or markers as `colors` and `markers` arguments.\\n    See https://matplotlib.org/examples/color/named_colors.html for more\\n    information.\\n\\n    Parameters\\n    ----------\\n    X : array-like, shape = [n_samples, n_features]\\n        Feature Matrix.\\n\\n    y : array-like, shape = [n_samples]\\n        True class labels.\\n\\n    clf : Classifier object.\\n        Must have a .predict method.\\n\\n    feature_index : array-like (default: (0,) for 1D, (0, 1) otherwise)\\n        Feature indices to use for plotting. The first index in\\n        `feature_index` will be on the x-axis, the second index will be\\n        on the y-axis.\\n\\n    filler_feature_values : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted.\\n\\n    filler_feature_ranges : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted. Will use the\\n        ranges provided to select training samples for plotting.\\n\\n    ax : matplotlib.axes.Axes (default: None)\\n        An existing matplotlib Axes. Creates\\n        one if ax=None.\\n\\n    X_highlight : array-like, shape = [n_samples, n_features] (default: None)\\n        An array with data points that are used to highlight samples in `X`.\\n\\n    zoom_factor : float (default: 1.0)\\n        Controls the scale of the x- and y-axis of the decision plot.\\n\\n    hide_spines : bool (default: True)\\n        Hide axis spines if True.\\n\\n    legend : int (default: 1)\\n        Integer to specify the legend location.\\n        No legend if legend is 0.\\n\\n    markers : str (default: 's^oxv<>')\\n        Scatterplot markers.\\n\\n    colors : str (default: 'red,blue,limegreen,gray,cyan')\\n        Comma separated list of colors.\\n\\n    scatter_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    contourf_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contourf function.\\n\\n    contour_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contour function\\n        (which draws the lines between decision regions).\\n\\n    scatter_highlight_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    n_jobs : int or None, optional (default=None)\\n        The number of CPUs to use to do the computation using Python's\\n        multiprocessing library.\\n        `None` means 1.\\n        `-1` means using all processors. New in v0.22.0.\\n\\n    Returns\\n    ---------\\n    ax : matplotlib.axes.Axes object\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/plotting/plot_decision_regions/\\n\\n    \"\n    check_Xy(X, y, y_int=True)\n    dim = X.shape[1]\n    if n_jobs is None:\n        n_jobs = 1\n    if ax is None:\n        ax = plt.gca()\n    plot_testdata = True\n    if not isinstance(X_highlight, np.ndarray):\n        if X_highlight is not None:\n            raise ValueError('X_highlight must be a NumPy array or None')\n        else:\n            plot_testdata = False\n    elif len(X_highlight.shape) < 2:\n        raise ValueError('X_highlight must be a 2D array')\n    if feature_index is not None:\n        if dim == 1:\n            raise ValueError('feature_index requires more than one training feature')\n        try:\n            (x_index, y_index) = feature_index\n        except ValueError:\n            raise ValueError('Unable to unpack feature_index. Make sure feature_index only has two dimensions.')\n        try:\n            (X[:, x_index], X[:, y_index])\n        except IndexError:\n            raise IndexError('feature_index values out of range. X.shape is {}, but feature_index is {}'.format(X.shape, feature_index))\n    else:\n        feature_index = (0, 1)\n        (x_index, y_index) = feature_index\n    if dim > 2:\n        if filler_feature_values is None:\n            raise ValueError('Filler values must be provided when X has more than 2 training features.')\n        if filler_feature_ranges is not None:\n            if not set(filler_feature_values) == set(filler_feature_ranges):\n                raise ValueError('filler_feature_values and filler_feature_ranges must have the same keys')\n        column_check = np.zeros(dim, dtype=bool)\n        for idx in filler_feature_values:\n            column_check[idx] = True\n        for idx in feature_index:\n            column_check[idx] = True\n        if not all(column_check):\n            missing_cols = np.argwhere(~column_check).flatten()\n            raise ValueError('Column(s) {} need to be accounted for in either feature_index or filler_feature_values'.format(missing_cols))\n    if n_jobs > mp.cpu_count():\n        raise ValueError('Number of defined CPU cores is more than the available resources {} '.format(mp.cpu_count()))\n    marker_gen = cycle(list(markers))\n    n_classes = np.unique(y).shape[0]\n    colors = colors.split(',')\n    colors_gen = cycle(colors)\n    colors = [next(colors_gen) for c in range(n_classes)]\n    (x_min, x_max) = (X[:, x_index].min() - 1.0 / zoom_factor, X[:, x_index].max() + 1.0 / zoom_factor)\n    if dim == 1:\n        (y_min, y_max) = (-1, 1)\n    else:\n        (y_min, y_max) = (X[:, y_index].min() - 1.0 / zoom_factor, X[:, y_index].max() + 1.0 / zoom_factor)\n    (xnum, ynum) = plt.gcf().dpi * plt.gcf().get_size_inches()\n    (xnum, ynum) = (floor(xnum), ceil(ynum))\n    (xx, yy) = np.meshgrid(np.linspace(x_min, x_max, num=xnum), np.linspace(y_min, y_max, num=ynum))\n    if dim == 1:\n        X_predict = np.array([xx.ravel()]).T\n    else:\n        X_grid = np.array([xx.ravel(), yy.ravel()]).T\n        X_predict = np.zeros((X_grid.shape[0], dim))\n        X_predict[:, x_index] = X_grid[:, 0]\n        X_predict[:, y_index] = X_grid[:, 1]\n        if dim > 2:\n            for feature_idx in filler_feature_values:\n                X_predict[:, feature_idx] = filler_feature_values[feature_idx]\n    if n_jobs == 1:\n        Z = clf.predict(X_predict.astype(X.dtype))\n        Z = Z.reshape(xx.shape)\n    else:\n        if n_jobs == -1:\n            cpus = mp.cpu_count()\n        else:\n            cpus = n_jobs\n        pool = mp.Pool(cpus)\n        partQuant = len(X_predict) / cpus\n        partitions = []\n        for n in range(cpus - 1):\n            (start, end) = (np.floor(partQuant * n).astype(int), np.floor(partQuant * (n + 1)).astype(int))\n            partitions.append(X_predict[start:end])\n        partitions.append(X_predict[end:])\n        xtype = X.dtype\n        Z = pool.starmap(parallel, [(x, clf, xtype) for x in partitions])\n        pool.close()\n        Z = np.concatenate(Z)\n        Z = Z.reshape(xx.shape)\n    contourf_kwargs_default = {'alpha': 0.45, 'antialiased': True}\n    contourf_kwargs = format_kwarg_dictionaries(default_kwargs=contourf_kwargs_default, user_kwargs=contourf_kwargs, protected_keys=['colors', 'levels'])\n    cset = ax.contourf(xx, yy, Z, colors=colors, levels=np.arange(Z.max() + 2) - 0.5, **contourf_kwargs)\n    contour_kwargs_default = {'linewidths': 0.5, 'colors': 'k', 'antialiased': True}\n    contour_kwargs = format_kwarg_dictionaries(default_kwargs=contour_kwargs_default, user_kwargs=contour_kwargs, protected_keys=[])\n    ax.contour(xx, yy, Z, cset.levels, **contour_kwargs)\n    ax.axis([xx.min(), xx.max(), yy.min(), yy.max()])\n    scatter_kwargs_default = {'alpha': 0.8, 'edgecolor': 'black'}\n    scatter_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_kwargs_default, user_kwargs=scatter_kwargs, protected_keys=['c', 'marker', 'label'])\n    for (idx, c) in enumerate(np.unique(y)):\n        if dim == 1:\n            y_data = [0 for i in X[y == c]]\n            x_data = X[y == c]\n        elif dim == 2:\n            y_data = X[y == c, y_index]\n            x_data = X[y == c, x_index]\n        elif dim > 2 and filler_feature_ranges is not None:\n            class_mask = y == c\n            feature_range_mask = get_feature_range_mask(X, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X[class_mask & feature_range_mask, y_index]\n            x_data = X[class_mask & feature_range_mask, x_index]\n        else:\n            continue\n        ax.scatter(x=x_data, y=y_data, c=colors[idx], marker=next(marker_gen), label=c, **scatter_kwargs)\n    if hide_spines:\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['bottom'].set_visible(False)\n    ax.yaxis.set_ticks_position('left')\n    ax.xaxis.set_ticks_position('bottom')\n    if dim == 1:\n        ax.axes.get_yaxis().set_ticks([])\n    if plot_testdata:\n        if dim == 1:\n            x_data = X_highlight\n            y_data = [0 for i in X_highlight]\n        elif dim == 2:\n            x_data = X_highlight[:, x_index]\n            y_data = X_highlight[:, y_index]\n        else:\n            feature_range_mask = get_feature_range_mask(X_highlight, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X_highlight[feature_range_mask, y_index]\n            x_data = X_highlight[feature_range_mask, x_index]\n        scatter_highlight_defaults = {'c': 'none', 'edgecolor': 'black', 'alpha': 1.0, 'linewidths': 1, 'marker': 'o', 's': 80}\n        scatter_highlight_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_highlight_defaults, user_kwargs=scatter_highlight_kwargs)\n        ax.scatter(x_data, y_data, **scatter_highlight_kwargs)\n    if legend:\n        if dim > 2 and filler_feature_ranges is None:\n            pass\n        else:\n            (handles, labels) = ax.get_legend_handles_labels()\n            ax.legend(handles, labels, framealpha=0.3, scatterpoints=1, loc=legend)\n    return ax",
            "def plot_decision_regions(X, y, clf, feature_index=None, filler_feature_values=None, filler_feature_ranges=None, ax=None, X_highlight=None, zoom_factor=1.0, legend=1, hide_spines=True, markers='s^oxv<>', colors='#1f77b4,#ff7f0e,#3ca02c,#d62728,#9467bd,#8c564b,#e377c2,#7f7f7f,#bcbd22,#17becf', scatter_kwargs=None, contourf_kwargs=None, contour_kwargs=None, scatter_highlight_kwargs=None, n_jobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Plot decision regions of a classifier.\\n\\n    Please note that this functions assumes that class labels are\\n    labeled consecutively, e.g,. 0, 1, 2, 3, 4, and 5. If you have class\\n    labels with integer labels > 4, you may want to provide additional colors\\n    and/or markers as `colors` and `markers` arguments.\\n    See https://matplotlib.org/examples/color/named_colors.html for more\\n    information.\\n\\n    Parameters\\n    ----------\\n    X : array-like, shape = [n_samples, n_features]\\n        Feature Matrix.\\n\\n    y : array-like, shape = [n_samples]\\n        True class labels.\\n\\n    clf : Classifier object.\\n        Must have a .predict method.\\n\\n    feature_index : array-like (default: (0,) for 1D, (0, 1) otherwise)\\n        Feature indices to use for plotting. The first index in\\n        `feature_index` will be on the x-axis, the second index will be\\n        on the y-axis.\\n\\n    filler_feature_values : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted.\\n\\n    filler_feature_ranges : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted. Will use the\\n        ranges provided to select training samples for plotting.\\n\\n    ax : matplotlib.axes.Axes (default: None)\\n        An existing matplotlib Axes. Creates\\n        one if ax=None.\\n\\n    X_highlight : array-like, shape = [n_samples, n_features] (default: None)\\n        An array with data points that are used to highlight samples in `X`.\\n\\n    zoom_factor : float (default: 1.0)\\n        Controls the scale of the x- and y-axis of the decision plot.\\n\\n    hide_spines : bool (default: True)\\n        Hide axis spines if True.\\n\\n    legend : int (default: 1)\\n        Integer to specify the legend location.\\n        No legend if legend is 0.\\n\\n    markers : str (default: 's^oxv<>')\\n        Scatterplot markers.\\n\\n    colors : str (default: 'red,blue,limegreen,gray,cyan')\\n        Comma separated list of colors.\\n\\n    scatter_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    contourf_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contourf function.\\n\\n    contour_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contour function\\n        (which draws the lines between decision regions).\\n\\n    scatter_highlight_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    n_jobs : int or None, optional (default=None)\\n        The number of CPUs to use to do the computation using Python's\\n        multiprocessing library.\\n        `None` means 1.\\n        `-1` means using all processors. New in v0.22.0.\\n\\n    Returns\\n    ---------\\n    ax : matplotlib.axes.Axes object\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/plotting/plot_decision_regions/\\n\\n    \"\n    check_Xy(X, y, y_int=True)\n    dim = X.shape[1]\n    if n_jobs is None:\n        n_jobs = 1\n    if ax is None:\n        ax = plt.gca()\n    plot_testdata = True\n    if not isinstance(X_highlight, np.ndarray):\n        if X_highlight is not None:\n            raise ValueError('X_highlight must be a NumPy array or None')\n        else:\n            plot_testdata = False\n    elif len(X_highlight.shape) < 2:\n        raise ValueError('X_highlight must be a 2D array')\n    if feature_index is not None:\n        if dim == 1:\n            raise ValueError('feature_index requires more than one training feature')\n        try:\n            (x_index, y_index) = feature_index\n        except ValueError:\n            raise ValueError('Unable to unpack feature_index. Make sure feature_index only has two dimensions.')\n        try:\n            (X[:, x_index], X[:, y_index])\n        except IndexError:\n            raise IndexError('feature_index values out of range. X.shape is {}, but feature_index is {}'.format(X.shape, feature_index))\n    else:\n        feature_index = (0, 1)\n        (x_index, y_index) = feature_index\n    if dim > 2:\n        if filler_feature_values is None:\n            raise ValueError('Filler values must be provided when X has more than 2 training features.')\n        if filler_feature_ranges is not None:\n            if not set(filler_feature_values) == set(filler_feature_ranges):\n                raise ValueError('filler_feature_values and filler_feature_ranges must have the same keys')\n        column_check = np.zeros(dim, dtype=bool)\n        for idx in filler_feature_values:\n            column_check[idx] = True\n        for idx in feature_index:\n            column_check[idx] = True\n        if not all(column_check):\n            missing_cols = np.argwhere(~column_check).flatten()\n            raise ValueError('Column(s) {} need to be accounted for in either feature_index or filler_feature_values'.format(missing_cols))\n    if n_jobs > mp.cpu_count():\n        raise ValueError('Number of defined CPU cores is more than the available resources {} '.format(mp.cpu_count()))\n    marker_gen = cycle(list(markers))\n    n_classes = np.unique(y).shape[0]\n    colors = colors.split(',')\n    colors_gen = cycle(colors)\n    colors = [next(colors_gen) for c in range(n_classes)]\n    (x_min, x_max) = (X[:, x_index].min() - 1.0 / zoom_factor, X[:, x_index].max() + 1.0 / zoom_factor)\n    if dim == 1:\n        (y_min, y_max) = (-1, 1)\n    else:\n        (y_min, y_max) = (X[:, y_index].min() - 1.0 / zoom_factor, X[:, y_index].max() + 1.0 / zoom_factor)\n    (xnum, ynum) = plt.gcf().dpi * plt.gcf().get_size_inches()\n    (xnum, ynum) = (floor(xnum), ceil(ynum))\n    (xx, yy) = np.meshgrid(np.linspace(x_min, x_max, num=xnum), np.linspace(y_min, y_max, num=ynum))\n    if dim == 1:\n        X_predict = np.array([xx.ravel()]).T\n    else:\n        X_grid = np.array([xx.ravel(), yy.ravel()]).T\n        X_predict = np.zeros((X_grid.shape[0], dim))\n        X_predict[:, x_index] = X_grid[:, 0]\n        X_predict[:, y_index] = X_grid[:, 1]\n        if dim > 2:\n            for feature_idx in filler_feature_values:\n                X_predict[:, feature_idx] = filler_feature_values[feature_idx]\n    if n_jobs == 1:\n        Z = clf.predict(X_predict.astype(X.dtype))\n        Z = Z.reshape(xx.shape)\n    else:\n        if n_jobs == -1:\n            cpus = mp.cpu_count()\n        else:\n            cpus = n_jobs\n        pool = mp.Pool(cpus)\n        partQuant = len(X_predict) / cpus\n        partitions = []\n        for n in range(cpus - 1):\n            (start, end) = (np.floor(partQuant * n).astype(int), np.floor(partQuant * (n + 1)).astype(int))\n            partitions.append(X_predict[start:end])\n        partitions.append(X_predict[end:])\n        xtype = X.dtype\n        Z = pool.starmap(parallel, [(x, clf, xtype) for x in partitions])\n        pool.close()\n        Z = np.concatenate(Z)\n        Z = Z.reshape(xx.shape)\n    contourf_kwargs_default = {'alpha': 0.45, 'antialiased': True}\n    contourf_kwargs = format_kwarg_dictionaries(default_kwargs=contourf_kwargs_default, user_kwargs=contourf_kwargs, protected_keys=['colors', 'levels'])\n    cset = ax.contourf(xx, yy, Z, colors=colors, levels=np.arange(Z.max() + 2) - 0.5, **contourf_kwargs)\n    contour_kwargs_default = {'linewidths': 0.5, 'colors': 'k', 'antialiased': True}\n    contour_kwargs = format_kwarg_dictionaries(default_kwargs=contour_kwargs_default, user_kwargs=contour_kwargs, protected_keys=[])\n    ax.contour(xx, yy, Z, cset.levels, **contour_kwargs)\n    ax.axis([xx.min(), xx.max(), yy.min(), yy.max()])\n    scatter_kwargs_default = {'alpha': 0.8, 'edgecolor': 'black'}\n    scatter_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_kwargs_default, user_kwargs=scatter_kwargs, protected_keys=['c', 'marker', 'label'])\n    for (idx, c) in enumerate(np.unique(y)):\n        if dim == 1:\n            y_data = [0 for i in X[y == c]]\n            x_data = X[y == c]\n        elif dim == 2:\n            y_data = X[y == c, y_index]\n            x_data = X[y == c, x_index]\n        elif dim > 2 and filler_feature_ranges is not None:\n            class_mask = y == c\n            feature_range_mask = get_feature_range_mask(X, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X[class_mask & feature_range_mask, y_index]\n            x_data = X[class_mask & feature_range_mask, x_index]\n        else:\n            continue\n        ax.scatter(x=x_data, y=y_data, c=colors[idx], marker=next(marker_gen), label=c, **scatter_kwargs)\n    if hide_spines:\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['bottom'].set_visible(False)\n    ax.yaxis.set_ticks_position('left')\n    ax.xaxis.set_ticks_position('bottom')\n    if dim == 1:\n        ax.axes.get_yaxis().set_ticks([])\n    if plot_testdata:\n        if dim == 1:\n            x_data = X_highlight\n            y_data = [0 for i in X_highlight]\n        elif dim == 2:\n            x_data = X_highlight[:, x_index]\n            y_data = X_highlight[:, y_index]\n        else:\n            feature_range_mask = get_feature_range_mask(X_highlight, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X_highlight[feature_range_mask, y_index]\n            x_data = X_highlight[feature_range_mask, x_index]\n        scatter_highlight_defaults = {'c': 'none', 'edgecolor': 'black', 'alpha': 1.0, 'linewidths': 1, 'marker': 'o', 's': 80}\n        scatter_highlight_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_highlight_defaults, user_kwargs=scatter_highlight_kwargs)\n        ax.scatter(x_data, y_data, **scatter_highlight_kwargs)\n    if legend:\n        if dim > 2 and filler_feature_ranges is None:\n            pass\n        else:\n            (handles, labels) = ax.get_legend_handles_labels()\n            ax.legend(handles, labels, framealpha=0.3, scatterpoints=1, loc=legend)\n    return ax",
            "def plot_decision_regions(X, y, clf, feature_index=None, filler_feature_values=None, filler_feature_ranges=None, ax=None, X_highlight=None, zoom_factor=1.0, legend=1, hide_spines=True, markers='s^oxv<>', colors='#1f77b4,#ff7f0e,#3ca02c,#d62728,#9467bd,#8c564b,#e377c2,#7f7f7f,#bcbd22,#17becf', scatter_kwargs=None, contourf_kwargs=None, contour_kwargs=None, scatter_highlight_kwargs=None, n_jobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Plot decision regions of a classifier.\\n\\n    Please note that this functions assumes that class labels are\\n    labeled consecutively, e.g,. 0, 1, 2, 3, 4, and 5. If you have class\\n    labels with integer labels > 4, you may want to provide additional colors\\n    and/or markers as `colors` and `markers` arguments.\\n    See https://matplotlib.org/examples/color/named_colors.html for more\\n    information.\\n\\n    Parameters\\n    ----------\\n    X : array-like, shape = [n_samples, n_features]\\n        Feature Matrix.\\n\\n    y : array-like, shape = [n_samples]\\n        True class labels.\\n\\n    clf : Classifier object.\\n        Must have a .predict method.\\n\\n    feature_index : array-like (default: (0,) for 1D, (0, 1) otherwise)\\n        Feature indices to use for plotting. The first index in\\n        `feature_index` will be on the x-axis, the second index will be\\n        on the y-axis.\\n\\n    filler_feature_values : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted.\\n\\n    filler_feature_ranges : dict (default: None)\\n        Only needed for number features > 2. Dictionary of feature\\n        index-value pairs for the features not being plotted. Will use the\\n        ranges provided to select training samples for plotting.\\n\\n    ax : matplotlib.axes.Axes (default: None)\\n        An existing matplotlib Axes. Creates\\n        one if ax=None.\\n\\n    X_highlight : array-like, shape = [n_samples, n_features] (default: None)\\n        An array with data points that are used to highlight samples in `X`.\\n\\n    zoom_factor : float (default: 1.0)\\n        Controls the scale of the x- and y-axis of the decision plot.\\n\\n    hide_spines : bool (default: True)\\n        Hide axis spines if True.\\n\\n    legend : int (default: 1)\\n        Integer to specify the legend location.\\n        No legend if legend is 0.\\n\\n    markers : str (default: 's^oxv<>')\\n        Scatterplot markers.\\n\\n    colors : str (default: 'red,blue,limegreen,gray,cyan')\\n        Comma separated list of colors.\\n\\n    scatter_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    contourf_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contourf function.\\n\\n    contour_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib contour function\\n        (which draws the lines between decision regions).\\n\\n    scatter_highlight_kwargs : dict (default: None)\\n        Keyword arguments for underlying matplotlib scatter function.\\n\\n    n_jobs : int or None, optional (default=None)\\n        The number of CPUs to use to do the computation using Python's\\n        multiprocessing library.\\n        `None` means 1.\\n        `-1` means using all processors. New in v0.22.0.\\n\\n    Returns\\n    ---------\\n    ax : matplotlib.axes.Axes object\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/plotting/plot_decision_regions/\\n\\n    \"\n    check_Xy(X, y, y_int=True)\n    dim = X.shape[1]\n    if n_jobs is None:\n        n_jobs = 1\n    if ax is None:\n        ax = plt.gca()\n    plot_testdata = True\n    if not isinstance(X_highlight, np.ndarray):\n        if X_highlight is not None:\n            raise ValueError('X_highlight must be a NumPy array or None')\n        else:\n            plot_testdata = False\n    elif len(X_highlight.shape) < 2:\n        raise ValueError('X_highlight must be a 2D array')\n    if feature_index is not None:\n        if dim == 1:\n            raise ValueError('feature_index requires more than one training feature')\n        try:\n            (x_index, y_index) = feature_index\n        except ValueError:\n            raise ValueError('Unable to unpack feature_index. Make sure feature_index only has two dimensions.')\n        try:\n            (X[:, x_index], X[:, y_index])\n        except IndexError:\n            raise IndexError('feature_index values out of range. X.shape is {}, but feature_index is {}'.format(X.shape, feature_index))\n    else:\n        feature_index = (0, 1)\n        (x_index, y_index) = feature_index\n    if dim > 2:\n        if filler_feature_values is None:\n            raise ValueError('Filler values must be provided when X has more than 2 training features.')\n        if filler_feature_ranges is not None:\n            if not set(filler_feature_values) == set(filler_feature_ranges):\n                raise ValueError('filler_feature_values and filler_feature_ranges must have the same keys')\n        column_check = np.zeros(dim, dtype=bool)\n        for idx in filler_feature_values:\n            column_check[idx] = True\n        for idx in feature_index:\n            column_check[idx] = True\n        if not all(column_check):\n            missing_cols = np.argwhere(~column_check).flatten()\n            raise ValueError('Column(s) {} need to be accounted for in either feature_index or filler_feature_values'.format(missing_cols))\n    if n_jobs > mp.cpu_count():\n        raise ValueError('Number of defined CPU cores is more than the available resources {} '.format(mp.cpu_count()))\n    marker_gen = cycle(list(markers))\n    n_classes = np.unique(y).shape[0]\n    colors = colors.split(',')\n    colors_gen = cycle(colors)\n    colors = [next(colors_gen) for c in range(n_classes)]\n    (x_min, x_max) = (X[:, x_index].min() - 1.0 / zoom_factor, X[:, x_index].max() + 1.0 / zoom_factor)\n    if dim == 1:\n        (y_min, y_max) = (-1, 1)\n    else:\n        (y_min, y_max) = (X[:, y_index].min() - 1.0 / zoom_factor, X[:, y_index].max() + 1.0 / zoom_factor)\n    (xnum, ynum) = plt.gcf().dpi * plt.gcf().get_size_inches()\n    (xnum, ynum) = (floor(xnum), ceil(ynum))\n    (xx, yy) = np.meshgrid(np.linspace(x_min, x_max, num=xnum), np.linspace(y_min, y_max, num=ynum))\n    if dim == 1:\n        X_predict = np.array([xx.ravel()]).T\n    else:\n        X_grid = np.array([xx.ravel(), yy.ravel()]).T\n        X_predict = np.zeros((X_grid.shape[0], dim))\n        X_predict[:, x_index] = X_grid[:, 0]\n        X_predict[:, y_index] = X_grid[:, 1]\n        if dim > 2:\n            for feature_idx in filler_feature_values:\n                X_predict[:, feature_idx] = filler_feature_values[feature_idx]\n    if n_jobs == 1:\n        Z = clf.predict(X_predict.astype(X.dtype))\n        Z = Z.reshape(xx.shape)\n    else:\n        if n_jobs == -1:\n            cpus = mp.cpu_count()\n        else:\n            cpus = n_jobs\n        pool = mp.Pool(cpus)\n        partQuant = len(X_predict) / cpus\n        partitions = []\n        for n in range(cpus - 1):\n            (start, end) = (np.floor(partQuant * n).astype(int), np.floor(partQuant * (n + 1)).astype(int))\n            partitions.append(X_predict[start:end])\n        partitions.append(X_predict[end:])\n        xtype = X.dtype\n        Z = pool.starmap(parallel, [(x, clf, xtype) for x in partitions])\n        pool.close()\n        Z = np.concatenate(Z)\n        Z = Z.reshape(xx.shape)\n    contourf_kwargs_default = {'alpha': 0.45, 'antialiased': True}\n    contourf_kwargs = format_kwarg_dictionaries(default_kwargs=contourf_kwargs_default, user_kwargs=contourf_kwargs, protected_keys=['colors', 'levels'])\n    cset = ax.contourf(xx, yy, Z, colors=colors, levels=np.arange(Z.max() + 2) - 0.5, **contourf_kwargs)\n    contour_kwargs_default = {'linewidths': 0.5, 'colors': 'k', 'antialiased': True}\n    contour_kwargs = format_kwarg_dictionaries(default_kwargs=contour_kwargs_default, user_kwargs=contour_kwargs, protected_keys=[])\n    ax.contour(xx, yy, Z, cset.levels, **contour_kwargs)\n    ax.axis([xx.min(), xx.max(), yy.min(), yy.max()])\n    scatter_kwargs_default = {'alpha': 0.8, 'edgecolor': 'black'}\n    scatter_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_kwargs_default, user_kwargs=scatter_kwargs, protected_keys=['c', 'marker', 'label'])\n    for (idx, c) in enumerate(np.unique(y)):\n        if dim == 1:\n            y_data = [0 for i in X[y == c]]\n            x_data = X[y == c]\n        elif dim == 2:\n            y_data = X[y == c, y_index]\n            x_data = X[y == c, x_index]\n        elif dim > 2 and filler_feature_ranges is not None:\n            class_mask = y == c\n            feature_range_mask = get_feature_range_mask(X, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X[class_mask & feature_range_mask, y_index]\n            x_data = X[class_mask & feature_range_mask, x_index]\n        else:\n            continue\n        ax.scatter(x=x_data, y=y_data, c=colors[idx], marker=next(marker_gen), label=c, **scatter_kwargs)\n    if hide_spines:\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['bottom'].set_visible(False)\n    ax.yaxis.set_ticks_position('left')\n    ax.xaxis.set_ticks_position('bottom')\n    if dim == 1:\n        ax.axes.get_yaxis().set_ticks([])\n    if plot_testdata:\n        if dim == 1:\n            x_data = X_highlight\n            y_data = [0 for i in X_highlight]\n        elif dim == 2:\n            x_data = X_highlight[:, x_index]\n            y_data = X_highlight[:, y_index]\n        else:\n            feature_range_mask = get_feature_range_mask(X_highlight, filler_feature_values=filler_feature_values, filler_feature_ranges=filler_feature_ranges)\n            y_data = X_highlight[feature_range_mask, y_index]\n            x_data = X_highlight[feature_range_mask, x_index]\n        scatter_highlight_defaults = {'c': 'none', 'edgecolor': 'black', 'alpha': 1.0, 'linewidths': 1, 'marker': 'o', 's': 80}\n        scatter_highlight_kwargs = format_kwarg_dictionaries(default_kwargs=scatter_highlight_defaults, user_kwargs=scatter_highlight_kwargs)\n        ax.scatter(x_data, y_data, **scatter_highlight_kwargs)\n    if legend:\n        if dim > 2 and filler_feature_ranges is None:\n            pass\n        else:\n            (handles, labels) = ax.get_legend_handles_labels()\n            ax.legend(handles, labels, framealpha=0.3, scatterpoints=1, loc=legend)\n    return ax"
        ]
    }
]