[
    {
        "func_name": "start",
        "original": "def start():\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=1), _check_ws)",
        "mutated": [
            "def start():\n    if False:\n        i = 10\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=1), _check_ws)",
            "def start():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=1), _check_ws)",
            "def start():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=1), _check_ws)",
            "def start():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=1), _check_ws)",
            "def start():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=1), _check_ws)"
        ]
    },
    {
        "func_name": "_during_working_schedule",
        "original": "def _during_working_schedule(now, working_schedule):\n    parts = working_schedule.split('|')\n    if len(parts) < 7:\n        return False\n    ws_day = parts[now.weekday()]\n    parts = ws_day.split('-')\n    if len(parts) != 2:\n        return False\n    (_from, to) = parts\n    if not _from or not to:\n        return False\n    _from = _from.split(':')\n    to = to.split(':')\n    if len(_from) != 2 or len(to) != 2:\n        return False\n    try:\n        from_h = int(_from[0])\n        from_m = int(_from[1])\n        to_h = int(to[0])\n        to_m = int(to[1])\n    except ValueError:\n        return False\n    if now.hour < from_h or now.hour > to_h:\n        return False\n    if now.hour == from_h and now.minute < from_m:\n        return False\n    if now.hour == to_h and now.minute > to_m:\n        return False\n    return True",
        "mutated": [
            "def _during_working_schedule(now, working_schedule):\n    if False:\n        i = 10\n    parts = working_schedule.split('|')\n    if len(parts) < 7:\n        return False\n    ws_day = parts[now.weekday()]\n    parts = ws_day.split('-')\n    if len(parts) != 2:\n        return False\n    (_from, to) = parts\n    if not _from or not to:\n        return False\n    _from = _from.split(':')\n    to = to.split(':')\n    if len(_from) != 2 or len(to) != 2:\n        return False\n    try:\n        from_h = int(_from[0])\n        from_m = int(_from[1])\n        to_h = int(to[0])\n        to_m = int(to[1])\n    except ValueError:\n        return False\n    if now.hour < from_h or now.hour > to_h:\n        return False\n    if now.hour == from_h and now.minute < from_m:\n        return False\n    if now.hour == to_h and now.minute > to_m:\n        return False\n    return True",
            "def _during_working_schedule(now, working_schedule):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parts = working_schedule.split('|')\n    if len(parts) < 7:\n        return False\n    ws_day = parts[now.weekday()]\n    parts = ws_day.split('-')\n    if len(parts) != 2:\n        return False\n    (_from, to) = parts\n    if not _from or not to:\n        return False\n    _from = _from.split(':')\n    to = to.split(':')\n    if len(_from) != 2 or len(to) != 2:\n        return False\n    try:\n        from_h = int(_from[0])\n        from_m = int(_from[1])\n        to_h = int(to[0])\n        to_m = int(to[1])\n    except ValueError:\n        return False\n    if now.hour < from_h or now.hour > to_h:\n        return False\n    if now.hour == from_h and now.minute < from_m:\n        return False\n    if now.hour == to_h and now.minute > to_m:\n        return False\n    return True",
            "def _during_working_schedule(now, working_schedule):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parts = working_schedule.split('|')\n    if len(parts) < 7:\n        return False\n    ws_day = parts[now.weekday()]\n    parts = ws_day.split('-')\n    if len(parts) != 2:\n        return False\n    (_from, to) = parts\n    if not _from or not to:\n        return False\n    _from = _from.split(':')\n    to = to.split(':')\n    if len(_from) != 2 or len(to) != 2:\n        return False\n    try:\n        from_h = int(_from[0])\n        from_m = int(_from[1])\n        to_h = int(to[0])\n        to_m = int(to[1])\n    except ValueError:\n        return False\n    if now.hour < from_h or now.hour > to_h:\n        return False\n    if now.hour == from_h and now.minute < from_m:\n        return False\n    if now.hour == to_h and now.minute > to_m:\n        return False\n    return True",
            "def _during_working_schedule(now, working_schedule):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parts = working_schedule.split('|')\n    if len(parts) < 7:\n        return False\n    ws_day = parts[now.weekday()]\n    parts = ws_day.split('-')\n    if len(parts) != 2:\n        return False\n    (_from, to) = parts\n    if not _from or not to:\n        return False\n    _from = _from.split(':')\n    to = to.split(':')\n    if len(_from) != 2 or len(to) != 2:\n        return False\n    try:\n        from_h = int(_from[0])\n        from_m = int(_from[1])\n        to_h = int(to[0])\n        to_m = int(to[1])\n    except ValueError:\n        return False\n    if now.hour < from_h or now.hour > to_h:\n        return False\n    if now.hour == from_h and now.minute < from_m:\n        return False\n    if now.hour == to_h and now.minute > to_m:\n        return False\n    return True",
            "def _during_working_schedule(now, working_schedule):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parts = working_schedule.split('|')\n    if len(parts) < 7:\n        return False\n    ws_day = parts[now.weekday()]\n    parts = ws_day.split('-')\n    if len(parts) != 2:\n        return False\n    (_from, to) = parts\n    if not _from or not to:\n        return False\n    _from = _from.split(':')\n    to = to.split(':')\n    if len(_from) != 2 or len(to) != 2:\n        return False\n    try:\n        from_h = int(_from[0])\n        from_m = int(_from[1])\n        to_h = int(to[0])\n        to_m = int(to[1])\n    except ValueError:\n        return False\n    if now.hour < from_h or now.hour > to_h:\n        return False\n    if now.hour == from_h and now.minute < from_m:\n        return False\n    if now.hour == to_h and now.minute > to_m:\n        return False\n    return True"
        ]
    },
    {
        "func_name": "on_motion_detection_status",
        "original": "def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n    if error:\n        return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n    if enabled and (not must_be_enabled):\n        logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, False)\n    elif not enabled and must_be_enabled:\n        logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, True)",
        "mutated": [
            "def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n    if False:\n        i = 10\n    if error:\n        return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n    if enabled and (not must_be_enabled):\n        logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, False)\n    elif not enabled and must_be_enabled:\n        logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, True)",
            "def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if error:\n        return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n    if enabled and (not must_be_enabled):\n        logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, False)\n    elif not enabled and must_be_enabled:\n        logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, True)",
            "def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if error:\n        return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n    if enabled and (not must_be_enabled):\n        logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, False)\n    elif not enabled and must_be_enabled:\n        logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, True)",
            "def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if error:\n        return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n    if enabled and (not must_be_enabled):\n        logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, False)\n    elif not enabled and must_be_enabled:\n        logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, True)",
            "def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if error:\n        return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n    if enabled and (not must_be_enabled):\n        logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, False)\n    elif not enabled and must_be_enabled:\n        logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n        motionctl.set_motion_detection(camera_id, True)"
        ]
    },
    {
        "func_name": "_check_ws",
        "original": "def _check_ws():\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=10), _check_ws)\n    if not motionctl.running():\n        return\n\n    def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n        if error:\n            return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n        if enabled and (not must_be_enabled):\n            logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, False)\n        elif not enabled and must_be_enabled:\n            logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, True)\n    now = datetime.datetime.now()\n    for camera_id in config.get_camera_ids():\n        camera_config = config.get_camera(camera_id)\n        if not utils.is_local_motion_camera(camera_config):\n            continue\n        working_schedule = camera_config.get('@working_schedule')\n        motion_detection = camera_config.get('@motion_detection')\n        working_schedule_type = camera_config.get('@working_schedule_type') or 'outside'\n        if not working_schedule:\n            continue\n        if not motion_detection:\n            continue\n        now_during = _during_working_schedule(now, working_schedule)\n        must_be_enabled = now_during and working_schedule_type == 'during' or (not now_during and working_schedule_type == 'outside')\n        motionctl.get_motion_detection(camera_id, functools.partial(on_motion_detection_status, camera_id, must_be_enabled, working_schedule_type))",
        "mutated": [
            "def _check_ws():\n    if False:\n        i = 10\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=10), _check_ws)\n    if not motionctl.running():\n        return\n\n    def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n        if error:\n            return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n        if enabled and (not must_be_enabled):\n            logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, False)\n        elif not enabled and must_be_enabled:\n            logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, True)\n    now = datetime.datetime.now()\n    for camera_id in config.get_camera_ids():\n        camera_config = config.get_camera(camera_id)\n        if not utils.is_local_motion_camera(camera_config):\n            continue\n        working_schedule = camera_config.get('@working_schedule')\n        motion_detection = camera_config.get('@motion_detection')\n        working_schedule_type = camera_config.get('@working_schedule_type') or 'outside'\n        if not working_schedule:\n            continue\n        if not motion_detection:\n            continue\n        now_during = _during_working_schedule(now, working_schedule)\n        must_be_enabled = now_during and working_schedule_type == 'during' or (not now_during and working_schedule_type == 'outside')\n        motionctl.get_motion_detection(camera_id, functools.partial(on_motion_detection_status, camera_id, must_be_enabled, working_schedule_type))",
            "def _check_ws():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=10), _check_ws)\n    if not motionctl.running():\n        return\n\n    def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n        if error:\n            return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n        if enabled and (not must_be_enabled):\n            logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, False)\n        elif not enabled and must_be_enabled:\n            logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, True)\n    now = datetime.datetime.now()\n    for camera_id in config.get_camera_ids():\n        camera_config = config.get_camera(camera_id)\n        if not utils.is_local_motion_camera(camera_config):\n            continue\n        working_schedule = camera_config.get('@working_schedule')\n        motion_detection = camera_config.get('@motion_detection')\n        working_schedule_type = camera_config.get('@working_schedule_type') or 'outside'\n        if not working_schedule:\n            continue\n        if not motion_detection:\n            continue\n        now_during = _during_working_schedule(now, working_schedule)\n        must_be_enabled = now_during and working_schedule_type == 'during' or (not now_during and working_schedule_type == 'outside')\n        motionctl.get_motion_detection(camera_id, functools.partial(on_motion_detection_status, camera_id, must_be_enabled, working_schedule_type))",
            "def _check_ws():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=10), _check_ws)\n    if not motionctl.running():\n        return\n\n    def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n        if error:\n            return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n        if enabled and (not must_be_enabled):\n            logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, False)\n        elif not enabled and must_be_enabled:\n            logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, True)\n    now = datetime.datetime.now()\n    for camera_id in config.get_camera_ids():\n        camera_config = config.get_camera(camera_id)\n        if not utils.is_local_motion_camera(camera_config):\n            continue\n        working_schedule = camera_config.get('@working_schedule')\n        motion_detection = camera_config.get('@motion_detection')\n        working_schedule_type = camera_config.get('@working_schedule_type') or 'outside'\n        if not working_schedule:\n            continue\n        if not motion_detection:\n            continue\n        now_during = _during_working_schedule(now, working_schedule)\n        must_be_enabled = now_during and working_schedule_type == 'during' or (not now_during and working_schedule_type == 'outside')\n        motionctl.get_motion_detection(camera_id, functools.partial(on_motion_detection_status, camera_id, must_be_enabled, working_schedule_type))",
            "def _check_ws():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=10), _check_ws)\n    if not motionctl.running():\n        return\n\n    def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n        if error:\n            return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n        if enabled and (not must_be_enabled):\n            logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, False)\n        elif not enabled and must_be_enabled:\n            logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, True)\n    now = datetime.datetime.now()\n    for camera_id in config.get_camera_ids():\n        camera_config = config.get_camera(camera_id)\n        if not utils.is_local_motion_camera(camera_config):\n            continue\n        working_schedule = camera_config.get('@working_schedule')\n        motion_detection = camera_config.get('@motion_detection')\n        working_schedule_type = camera_config.get('@working_schedule_type') or 'outside'\n        if not working_schedule:\n            continue\n        if not motion_detection:\n            continue\n        now_during = _during_working_schedule(now, working_schedule)\n        must_be_enabled = now_during and working_schedule_type == 'during' or (not now_during and working_schedule_type == 'outside')\n        motionctl.get_motion_detection(camera_id, functools.partial(on_motion_detection_status, camera_id, must_be_enabled, working_schedule_type))",
            "def _check_ws():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    io_loop = IOLoop.instance()\n    io_loop.add_timeout(datetime.timedelta(seconds=10), _check_ws)\n    if not motionctl.running():\n        return\n\n    def on_motion_detection_status(camera_id, must_be_enabled, working_schedule_type, enabled=None, error=None):\n        if error:\n            return logging.warn('skipping motion detection status update for camera with id %(id)s: %(error)s' % {'id': camera_id, 'error': error})\n        if enabled and (not must_be_enabled):\n            logging.debug('must disable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, False)\n        elif not enabled and must_be_enabled:\n            logging.debug('must enable motion detection for camera with id %(id)s (%(what)s working schedule)' % {'id': camera_id, 'what': working_schedule_type})\n            motionctl.set_motion_detection(camera_id, True)\n    now = datetime.datetime.now()\n    for camera_id in config.get_camera_ids():\n        camera_config = config.get_camera(camera_id)\n        if not utils.is_local_motion_camera(camera_config):\n            continue\n        working_schedule = camera_config.get('@working_schedule')\n        motion_detection = camera_config.get('@motion_detection')\n        working_schedule_type = camera_config.get('@working_schedule_type') or 'outside'\n        if not working_schedule:\n            continue\n        if not motion_detection:\n            continue\n        now_during = _during_working_schedule(now, working_schedule)\n        must_be_enabled = now_during and working_schedule_type == 'during' or (not now_during and working_schedule_type == 'outside')\n        motionctl.get_motion_detection(camera_id, functools.partial(on_motion_detection_status, camera_id, must_be_enabled, working_schedule_type))"
        ]
    }
]