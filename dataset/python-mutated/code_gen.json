[
    {
        "func_name": "_ufunc_gen",
        "original": "def _ufunc_gen(scipy_dist: str, types: list, ctor_args: tuple, filename: str, boost_dist: str, x_funcs: list, no_x_funcs: list):\n    \"\"\"\n    We need methods defined for each rv_continuous/_discrete internal method:\n        i.e.: _pdf, _cdf, etc.\n    Some of these methods take constructor arguments and 1 extra argument,\n        e.g.: _pdf(x, *ctor_args), _ppf(q, *ctor_args)\n    while some of the methods take only constructor arguments:\n        e.g.: _stats(*ctor_args)\n    \"\"\"\n    num_ctor_args = len(ctor_args)\n    methods = [_MethodDef(ufunc_name=f'_{scipy_dist}_{x_func}', num_inputs=num_ctor_args + 1, boost_func_name=x_func if boost_dist != 'beta_distribution' else 'pdf_beta' if x_func == 'pdf' else x_func) for x_func in x_funcs]\n    methods += [_MethodDef(ufunc_name=f'_{scipy_dist}_{func}', num_inputs=num_ctor_args, boost_func_name=func) for func in no_x_funcs]\n    no_input_methods = [m for m in methods if m.num_inputs == 0]\n    if no_input_methods:\n        raise ValueError(f'ufuncs must have >0 arguments! Cannot construct these ufuncs: {no_input_methods}')\n    boost_hdr_name = boost_dist.split('_distribution')[0]\n    unique_num_inputs = set({m.num_inputs for m in methods})\n    has_NPY_FLOAT16 = 'NPY_FLOAT16' in types\n    line_joiner = ',\\n    ' + ' ' * 12\n    num_types = len(types)\n    loop_fun = 'PyUFunc_T'\n    func_defs_cimports = line_joiner.join((f'boost_{m.boost_func_name}{num_ctor_args}' for m in methods))\n    nontype_params = line_joiner[1:].join((f'ctypedef int NINPUTS{n} \"{n}\"' for n in unique_num_inputs))\n    with open(filename, 'w') as fp:\n        boost_hdr = f'boost/math/distributions/{boost_hdr_name}.hpp'\n        relimport = '.'\n        fp.write(dedent(f'''            # cython: language_level=3\\n\\n            # This file was generated by stats/_boost/include/code_gen.py\\n            # All modifications to this file will be overwritten.\\n\\n            from numpy cimport (\\n                import_array,\\n                import_ufunc,\\n                PyUFunc_FromFuncAndData,\\n                PyUFuncGenericFunction,\\n                PyUFunc_None,\\n                {line_joiner.join(types)}\\n            )\\n            from {relimport}templated_pyufunc cimport PyUFunc_T\\n            from {relimport}func_defs cimport (\\n                {func_defs_cimports},\\n            )\\n            cdef extern from \"{boost_hdr}\" namespace \"boost::math\" nogil:\\n                cdef cppclass {boost_dist} nogil:\\n                    pass\\n\\n            # Workaround for Cython's lack of non-type template parameter\\n            # support\\n            cdef extern from * nogil:\\n                {nontype_params}\\n\\n            _DUMMY = \"\"\\n            import_array()\\n            import_ufunc()\\n            '''))\n        if has_NPY_FLOAT16:\n            warn('Boost stats NPY_FLOAT16 ufunc generation not currently not supported!')\n        for (ii, m) in enumerate(methods):\n            fp.write(dedent(f'\\n                cdef PyUFuncGenericFunction loop_func{ii}[{num_types}]\\n                cdef void* func{ii}[1*{num_types}]\\n                cdef char types{ii}[{m.num_inputs + 1}*{num_types}]\\n                '))\n            for (jj, T) in enumerate(types):\n                ctype = {'NPY_DOUBLE': 'double', 'NPY_FLOAT': 'float', 'NPY_FLOAT16': 'npy_half'}[T]\n                boost_fun = f'boost_{m.boost_func_name}{num_ctor_args}'\n                type_str = ', '.join([ctype] * (1 + num_ctor_args))\n                boost_tmpl = f'{boost_dist}, {type_str}'\n                N = m.num_inputs\n                fp.write(f'loop_func{ii}[{jj}] = <PyUFuncGenericFunction>{loop_fun}[{ctype}, NINPUTS{N}]\\nfunc{ii}[{jj}] = <void*>{boost_fun}[{boost_tmpl}]\\n')\n                for tidx in range(m.num_inputs + 1):\n                    fp.write(f'types{ii}[{tidx}+{jj}*{m.num_inputs + 1}] = {T}\\n')\n            arg_list_str = ', '.join(ctor_args)\n            if m.boost_func_name in x_funcs:\n                arg_list_str = 'x, ' + arg_list_str\n            fp.write(dedent(f'\\n                {m.ufunc_name} = PyUFunc_FromFuncAndData(\\n                    loop_func{ii},\\n                    func{ii},\\n                    types{ii},\\n                    {num_types},  # number of supported input types\\n                    {m.num_inputs},  # number of input args\\n                    1,  # number of output args\\n                    PyUFunc_None,  # `identity` element, never mind this\\n                    \"{m.ufunc_name}\",  # function name\\n                    (\"{m.ufunc_name}({arg_list_str}) -> computes \"\\n                     \"{m.boost_func_name} of {scipy_dist} distribution\"),\\n                    0  # unused\\n                )\\n                '))",
        "mutated": [
            "def _ufunc_gen(scipy_dist: str, types: list, ctor_args: tuple, filename: str, boost_dist: str, x_funcs: list, no_x_funcs: list):\n    if False:\n        i = 10\n    '\\n    We need methods defined for each rv_continuous/_discrete internal method:\\n        i.e.: _pdf, _cdf, etc.\\n    Some of these methods take constructor arguments and 1 extra argument,\\n        e.g.: _pdf(x, *ctor_args), _ppf(q, *ctor_args)\\n    while some of the methods take only constructor arguments:\\n        e.g.: _stats(*ctor_args)\\n    '\n    num_ctor_args = len(ctor_args)\n    methods = [_MethodDef(ufunc_name=f'_{scipy_dist}_{x_func}', num_inputs=num_ctor_args + 1, boost_func_name=x_func if boost_dist != 'beta_distribution' else 'pdf_beta' if x_func == 'pdf' else x_func) for x_func in x_funcs]\n    methods += [_MethodDef(ufunc_name=f'_{scipy_dist}_{func}', num_inputs=num_ctor_args, boost_func_name=func) for func in no_x_funcs]\n    no_input_methods = [m for m in methods if m.num_inputs == 0]\n    if no_input_methods:\n        raise ValueError(f'ufuncs must have >0 arguments! Cannot construct these ufuncs: {no_input_methods}')\n    boost_hdr_name = boost_dist.split('_distribution')[0]\n    unique_num_inputs = set({m.num_inputs for m in methods})\n    has_NPY_FLOAT16 = 'NPY_FLOAT16' in types\n    line_joiner = ',\\n    ' + ' ' * 12\n    num_types = len(types)\n    loop_fun = 'PyUFunc_T'\n    func_defs_cimports = line_joiner.join((f'boost_{m.boost_func_name}{num_ctor_args}' for m in methods))\n    nontype_params = line_joiner[1:].join((f'ctypedef int NINPUTS{n} \"{n}\"' for n in unique_num_inputs))\n    with open(filename, 'w') as fp:\n        boost_hdr = f'boost/math/distributions/{boost_hdr_name}.hpp'\n        relimport = '.'\n        fp.write(dedent(f'''            # cython: language_level=3\\n\\n            # This file was generated by stats/_boost/include/code_gen.py\\n            # All modifications to this file will be overwritten.\\n\\n            from numpy cimport (\\n                import_array,\\n                import_ufunc,\\n                PyUFunc_FromFuncAndData,\\n                PyUFuncGenericFunction,\\n                PyUFunc_None,\\n                {line_joiner.join(types)}\\n            )\\n            from {relimport}templated_pyufunc cimport PyUFunc_T\\n            from {relimport}func_defs cimport (\\n                {func_defs_cimports},\\n            )\\n            cdef extern from \"{boost_hdr}\" namespace \"boost::math\" nogil:\\n                cdef cppclass {boost_dist} nogil:\\n                    pass\\n\\n            # Workaround for Cython's lack of non-type template parameter\\n            # support\\n            cdef extern from * nogil:\\n                {nontype_params}\\n\\n            _DUMMY = \"\"\\n            import_array()\\n            import_ufunc()\\n            '''))\n        if has_NPY_FLOAT16:\n            warn('Boost stats NPY_FLOAT16 ufunc generation not currently not supported!')\n        for (ii, m) in enumerate(methods):\n            fp.write(dedent(f'\\n                cdef PyUFuncGenericFunction loop_func{ii}[{num_types}]\\n                cdef void* func{ii}[1*{num_types}]\\n                cdef char types{ii}[{m.num_inputs + 1}*{num_types}]\\n                '))\n            for (jj, T) in enumerate(types):\n                ctype = {'NPY_DOUBLE': 'double', 'NPY_FLOAT': 'float', 'NPY_FLOAT16': 'npy_half'}[T]\n                boost_fun = f'boost_{m.boost_func_name}{num_ctor_args}'\n                type_str = ', '.join([ctype] * (1 + num_ctor_args))\n                boost_tmpl = f'{boost_dist}, {type_str}'\n                N = m.num_inputs\n                fp.write(f'loop_func{ii}[{jj}] = <PyUFuncGenericFunction>{loop_fun}[{ctype}, NINPUTS{N}]\\nfunc{ii}[{jj}] = <void*>{boost_fun}[{boost_tmpl}]\\n')\n                for tidx in range(m.num_inputs + 1):\n                    fp.write(f'types{ii}[{tidx}+{jj}*{m.num_inputs + 1}] = {T}\\n')\n            arg_list_str = ', '.join(ctor_args)\n            if m.boost_func_name in x_funcs:\n                arg_list_str = 'x, ' + arg_list_str\n            fp.write(dedent(f'\\n                {m.ufunc_name} = PyUFunc_FromFuncAndData(\\n                    loop_func{ii},\\n                    func{ii},\\n                    types{ii},\\n                    {num_types},  # number of supported input types\\n                    {m.num_inputs},  # number of input args\\n                    1,  # number of output args\\n                    PyUFunc_None,  # `identity` element, never mind this\\n                    \"{m.ufunc_name}\",  # function name\\n                    (\"{m.ufunc_name}({arg_list_str}) -> computes \"\\n                     \"{m.boost_func_name} of {scipy_dist} distribution\"),\\n                    0  # unused\\n                )\\n                '))",
            "def _ufunc_gen(scipy_dist: str, types: list, ctor_args: tuple, filename: str, boost_dist: str, x_funcs: list, no_x_funcs: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    We need methods defined for each rv_continuous/_discrete internal method:\\n        i.e.: _pdf, _cdf, etc.\\n    Some of these methods take constructor arguments and 1 extra argument,\\n        e.g.: _pdf(x, *ctor_args), _ppf(q, *ctor_args)\\n    while some of the methods take only constructor arguments:\\n        e.g.: _stats(*ctor_args)\\n    '\n    num_ctor_args = len(ctor_args)\n    methods = [_MethodDef(ufunc_name=f'_{scipy_dist}_{x_func}', num_inputs=num_ctor_args + 1, boost_func_name=x_func if boost_dist != 'beta_distribution' else 'pdf_beta' if x_func == 'pdf' else x_func) for x_func in x_funcs]\n    methods += [_MethodDef(ufunc_name=f'_{scipy_dist}_{func}', num_inputs=num_ctor_args, boost_func_name=func) for func in no_x_funcs]\n    no_input_methods = [m for m in methods if m.num_inputs == 0]\n    if no_input_methods:\n        raise ValueError(f'ufuncs must have >0 arguments! Cannot construct these ufuncs: {no_input_methods}')\n    boost_hdr_name = boost_dist.split('_distribution')[0]\n    unique_num_inputs = set({m.num_inputs for m in methods})\n    has_NPY_FLOAT16 = 'NPY_FLOAT16' in types\n    line_joiner = ',\\n    ' + ' ' * 12\n    num_types = len(types)\n    loop_fun = 'PyUFunc_T'\n    func_defs_cimports = line_joiner.join((f'boost_{m.boost_func_name}{num_ctor_args}' for m in methods))\n    nontype_params = line_joiner[1:].join((f'ctypedef int NINPUTS{n} \"{n}\"' for n in unique_num_inputs))\n    with open(filename, 'w') as fp:\n        boost_hdr = f'boost/math/distributions/{boost_hdr_name}.hpp'\n        relimport = '.'\n        fp.write(dedent(f'''            # cython: language_level=3\\n\\n            # This file was generated by stats/_boost/include/code_gen.py\\n            # All modifications to this file will be overwritten.\\n\\n            from numpy cimport (\\n                import_array,\\n                import_ufunc,\\n                PyUFunc_FromFuncAndData,\\n                PyUFuncGenericFunction,\\n                PyUFunc_None,\\n                {line_joiner.join(types)}\\n            )\\n            from {relimport}templated_pyufunc cimport PyUFunc_T\\n            from {relimport}func_defs cimport (\\n                {func_defs_cimports},\\n            )\\n            cdef extern from \"{boost_hdr}\" namespace \"boost::math\" nogil:\\n                cdef cppclass {boost_dist} nogil:\\n                    pass\\n\\n            # Workaround for Cython's lack of non-type template parameter\\n            # support\\n            cdef extern from * nogil:\\n                {nontype_params}\\n\\n            _DUMMY = \"\"\\n            import_array()\\n            import_ufunc()\\n            '''))\n        if has_NPY_FLOAT16:\n            warn('Boost stats NPY_FLOAT16 ufunc generation not currently not supported!')\n        for (ii, m) in enumerate(methods):\n            fp.write(dedent(f'\\n                cdef PyUFuncGenericFunction loop_func{ii}[{num_types}]\\n                cdef void* func{ii}[1*{num_types}]\\n                cdef char types{ii}[{m.num_inputs + 1}*{num_types}]\\n                '))\n            for (jj, T) in enumerate(types):\n                ctype = {'NPY_DOUBLE': 'double', 'NPY_FLOAT': 'float', 'NPY_FLOAT16': 'npy_half'}[T]\n                boost_fun = f'boost_{m.boost_func_name}{num_ctor_args}'\n                type_str = ', '.join([ctype] * (1 + num_ctor_args))\n                boost_tmpl = f'{boost_dist}, {type_str}'\n                N = m.num_inputs\n                fp.write(f'loop_func{ii}[{jj}] = <PyUFuncGenericFunction>{loop_fun}[{ctype}, NINPUTS{N}]\\nfunc{ii}[{jj}] = <void*>{boost_fun}[{boost_tmpl}]\\n')\n                for tidx in range(m.num_inputs + 1):\n                    fp.write(f'types{ii}[{tidx}+{jj}*{m.num_inputs + 1}] = {T}\\n')\n            arg_list_str = ', '.join(ctor_args)\n            if m.boost_func_name in x_funcs:\n                arg_list_str = 'x, ' + arg_list_str\n            fp.write(dedent(f'\\n                {m.ufunc_name} = PyUFunc_FromFuncAndData(\\n                    loop_func{ii},\\n                    func{ii},\\n                    types{ii},\\n                    {num_types},  # number of supported input types\\n                    {m.num_inputs},  # number of input args\\n                    1,  # number of output args\\n                    PyUFunc_None,  # `identity` element, never mind this\\n                    \"{m.ufunc_name}\",  # function name\\n                    (\"{m.ufunc_name}({arg_list_str}) -> computes \"\\n                     \"{m.boost_func_name} of {scipy_dist} distribution\"),\\n                    0  # unused\\n                )\\n                '))",
            "def _ufunc_gen(scipy_dist: str, types: list, ctor_args: tuple, filename: str, boost_dist: str, x_funcs: list, no_x_funcs: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    We need methods defined for each rv_continuous/_discrete internal method:\\n        i.e.: _pdf, _cdf, etc.\\n    Some of these methods take constructor arguments and 1 extra argument,\\n        e.g.: _pdf(x, *ctor_args), _ppf(q, *ctor_args)\\n    while some of the methods take only constructor arguments:\\n        e.g.: _stats(*ctor_args)\\n    '\n    num_ctor_args = len(ctor_args)\n    methods = [_MethodDef(ufunc_name=f'_{scipy_dist}_{x_func}', num_inputs=num_ctor_args + 1, boost_func_name=x_func if boost_dist != 'beta_distribution' else 'pdf_beta' if x_func == 'pdf' else x_func) for x_func in x_funcs]\n    methods += [_MethodDef(ufunc_name=f'_{scipy_dist}_{func}', num_inputs=num_ctor_args, boost_func_name=func) for func in no_x_funcs]\n    no_input_methods = [m for m in methods if m.num_inputs == 0]\n    if no_input_methods:\n        raise ValueError(f'ufuncs must have >0 arguments! Cannot construct these ufuncs: {no_input_methods}')\n    boost_hdr_name = boost_dist.split('_distribution')[0]\n    unique_num_inputs = set({m.num_inputs for m in methods})\n    has_NPY_FLOAT16 = 'NPY_FLOAT16' in types\n    line_joiner = ',\\n    ' + ' ' * 12\n    num_types = len(types)\n    loop_fun = 'PyUFunc_T'\n    func_defs_cimports = line_joiner.join((f'boost_{m.boost_func_name}{num_ctor_args}' for m in methods))\n    nontype_params = line_joiner[1:].join((f'ctypedef int NINPUTS{n} \"{n}\"' for n in unique_num_inputs))\n    with open(filename, 'w') as fp:\n        boost_hdr = f'boost/math/distributions/{boost_hdr_name}.hpp'\n        relimport = '.'\n        fp.write(dedent(f'''            # cython: language_level=3\\n\\n            # This file was generated by stats/_boost/include/code_gen.py\\n            # All modifications to this file will be overwritten.\\n\\n            from numpy cimport (\\n                import_array,\\n                import_ufunc,\\n                PyUFunc_FromFuncAndData,\\n                PyUFuncGenericFunction,\\n                PyUFunc_None,\\n                {line_joiner.join(types)}\\n            )\\n            from {relimport}templated_pyufunc cimport PyUFunc_T\\n            from {relimport}func_defs cimport (\\n                {func_defs_cimports},\\n            )\\n            cdef extern from \"{boost_hdr}\" namespace \"boost::math\" nogil:\\n                cdef cppclass {boost_dist} nogil:\\n                    pass\\n\\n            # Workaround for Cython's lack of non-type template parameter\\n            # support\\n            cdef extern from * nogil:\\n                {nontype_params}\\n\\n            _DUMMY = \"\"\\n            import_array()\\n            import_ufunc()\\n            '''))\n        if has_NPY_FLOAT16:\n            warn('Boost stats NPY_FLOAT16 ufunc generation not currently not supported!')\n        for (ii, m) in enumerate(methods):\n            fp.write(dedent(f'\\n                cdef PyUFuncGenericFunction loop_func{ii}[{num_types}]\\n                cdef void* func{ii}[1*{num_types}]\\n                cdef char types{ii}[{m.num_inputs + 1}*{num_types}]\\n                '))\n            for (jj, T) in enumerate(types):\n                ctype = {'NPY_DOUBLE': 'double', 'NPY_FLOAT': 'float', 'NPY_FLOAT16': 'npy_half'}[T]\n                boost_fun = f'boost_{m.boost_func_name}{num_ctor_args}'\n                type_str = ', '.join([ctype] * (1 + num_ctor_args))\n                boost_tmpl = f'{boost_dist}, {type_str}'\n                N = m.num_inputs\n                fp.write(f'loop_func{ii}[{jj}] = <PyUFuncGenericFunction>{loop_fun}[{ctype}, NINPUTS{N}]\\nfunc{ii}[{jj}] = <void*>{boost_fun}[{boost_tmpl}]\\n')\n                for tidx in range(m.num_inputs + 1):\n                    fp.write(f'types{ii}[{tidx}+{jj}*{m.num_inputs + 1}] = {T}\\n')\n            arg_list_str = ', '.join(ctor_args)\n            if m.boost_func_name in x_funcs:\n                arg_list_str = 'x, ' + arg_list_str\n            fp.write(dedent(f'\\n                {m.ufunc_name} = PyUFunc_FromFuncAndData(\\n                    loop_func{ii},\\n                    func{ii},\\n                    types{ii},\\n                    {num_types},  # number of supported input types\\n                    {m.num_inputs},  # number of input args\\n                    1,  # number of output args\\n                    PyUFunc_None,  # `identity` element, never mind this\\n                    \"{m.ufunc_name}\",  # function name\\n                    (\"{m.ufunc_name}({arg_list_str}) -> computes \"\\n                     \"{m.boost_func_name} of {scipy_dist} distribution\"),\\n                    0  # unused\\n                )\\n                '))",
            "def _ufunc_gen(scipy_dist: str, types: list, ctor_args: tuple, filename: str, boost_dist: str, x_funcs: list, no_x_funcs: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    We need methods defined for each rv_continuous/_discrete internal method:\\n        i.e.: _pdf, _cdf, etc.\\n    Some of these methods take constructor arguments and 1 extra argument,\\n        e.g.: _pdf(x, *ctor_args), _ppf(q, *ctor_args)\\n    while some of the methods take only constructor arguments:\\n        e.g.: _stats(*ctor_args)\\n    '\n    num_ctor_args = len(ctor_args)\n    methods = [_MethodDef(ufunc_name=f'_{scipy_dist}_{x_func}', num_inputs=num_ctor_args + 1, boost_func_name=x_func if boost_dist != 'beta_distribution' else 'pdf_beta' if x_func == 'pdf' else x_func) for x_func in x_funcs]\n    methods += [_MethodDef(ufunc_name=f'_{scipy_dist}_{func}', num_inputs=num_ctor_args, boost_func_name=func) for func in no_x_funcs]\n    no_input_methods = [m for m in methods if m.num_inputs == 0]\n    if no_input_methods:\n        raise ValueError(f'ufuncs must have >0 arguments! Cannot construct these ufuncs: {no_input_methods}')\n    boost_hdr_name = boost_dist.split('_distribution')[0]\n    unique_num_inputs = set({m.num_inputs for m in methods})\n    has_NPY_FLOAT16 = 'NPY_FLOAT16' in types\n    line_joiner = ',\\n    ' + ' ' * 12\n    num_types = len(types)\n    loop_fun = 'PyUFunc_T'\n    func_defs_cimports = line_joiner.join((f'boost_{m.boost_func_name}{num_ctor_args}' for m in methods))\n    nontype_params = line_joiner[1:].join((f'ctypedef int NINPUTS{n} \"{n}\"' for n in unique_num_inputs))\n    with open(filename, 'w') as fp:\n        boost_hdr = f'boost/math/distributions/{boost_hdr_name}.hpp'\n        relimport = '.'\n        fp.write(dedent(f'''            # cython: language_level=3\\n\\n            # This file was generated by stats/_boost/include/code_gen.py\\n            # All modifications to this file will be overwritten.\\n\\n            from numpy cimport (\\n                import_array,\\n                import_ufunc,\\n                PyUFunc_FromFuncAndData,\\n                PyUFuncGenericFunction,\\n                PyUFunc_None,\\n                {line_joiner.join(types)}\\n            )\\n            from {relimport}templated_pyufunc cimport PyUFunc_T\\n            from {relimport}func_defs cimport (\\n                {func_defs_cimports},\\n            )\\n            cdef extern from \"{boost_hdr}\" namespace \"boost::math\" nogil:\\n                cdef cppclass {boost_dist} nogil:\\n                    pass\\n\\n            # Workaround for Cython's lack of non-type template parameter\\n            # support\\n            cdef extern from * nogil:\\n                {nontype_params}\\n\\n            _DUMMY = \"\"\\n            import_array()\\n            import_ufunc()\\n            '''))\n        if has_NPY_FLOAT16:\n            warn('Boost stats NPY_FLOAT16 ufunc generation not currently not supported!')\n        for (ii, m) in enumerate(methods):\n            fp.write(dedent(f'\\n                cdef PyUFuncGenericFunction loop_func{ii}[{num_types}]\\n                cdef void* func{ii}[1*{num_types}]\\n                cdef char types{ii}[{m.num_inputs + 1}*{num_types}]\\n                '))\n            for (jj, T) in enumerate(types):\n                ctype = {'NPY_DOUBLE': 'double', 'NPY_FLOAT': 'float', 'NPY_FLOAT16': 'npy_half'}[T]\n                boost_fun = f'boost_{m.boost_func_name}{num_ctor_args}'\n                type_str = ', '.join([ctype] * (1 + num_ctor_args))\n                boost_tmpl = f'{boost_dist}, {type_str}'\n                N = m.num_inputs\n                fp.write(f'loop_func{ii}[{jj}] = <PyUFuncGenericFunction>{loop_fun}[{ctype}, NINPUTS{N}]\\nfunc{ii}[{jj}] = <void*>{boost_fun}[{boost_tmpl}]\\n')\n                for tidx in range(m.num_inputs + 1):\n                    fp.write(f'types{ii}[{tidx}+{jj}*{m.num_inputs + 1}] = {T}\\n')\n            arg_list_str = ', '.join(ctor_args)\n            if m.boost_func_name in x_funcs:\n                arg_list_str = 'x, ' + arg_list_str\n            fp.write(dedent(f'\\n                {m.ufunc_name} = PyUFunc_FromFuncAndData(\\n                    loop_func{ii},\\n                    func{ii},\\n                    types{ii},\\n                    {num_types},  # number of supported input types\\n                    {m.num_inputs},  # number of input args\\n                    1,  # number of output args\\n                    PyUFunc_None,  # `identity` element, never mind this\\n                    \"{m.ufunc_name}\",  # function name\\n                    (\"{m.ufunc_name}({arg_list_str}) -> computes \"\\n                     \"{m.boost_func_name} of {scipy_dist} distribution\"),\\n                    0  # unused\\n                )\\n                '))",
            "def _ufunc_gen(scipy_dist: str, types: list, ctor_args: tuple, filename: str, boost_dist: str, x_funcs: list, no_x_funcs: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    We need methods defined for each rv_continuous/_discrete internal method:\\n        i.e.: _pdf, _cdf, etc.\\n    Some of these methods take constructor arguments and 1 extra argument,\\n        e.g.: _pdf(x, *ctor_args), _ppf(q, *ctor_args)\\n    while some of the methods take only constructor arguments:\\n        e.g.: _stats(*ctor_args)\\n    '\n    num_ctor_args = len(ctor_args)\n    methods = [_MethodDef(ufunc_name=f'_{scipy_dist}_{x_func}', num_inputs=num_ctor_args + 1, boost_func_name=x_func if boost_dist != 'beta_distribution' else 'pdf_beta' if x_func == 'pdf' else x_func) for x_func in x_funcs]\n    methods += [_MethodDef(ufunc_name=f'_{scipy_dist}_{func}', num_inputs=num_ctor_args, boost_func_name=func) for func in no_x_funcs]\n    no_input_methods = [m for m in methods if m.num_inputs == 0]\n    if no_input_methods:\n        raise ValueError(f'ufuncs must have >0 arguments! Cannot construct these ufuncs: {no_input_methods}')\n    boost_hdr_name = boost_dist.split('_distribution')[0]\n    unique_num_inputs = set({m.num_inputs for m in methods})\n    has_NPY_FLOAT16 = 'NPY_FLOAT16' in types\n    line_joiner = ',\\n    ' + ' ' * 12\n    num_types = len(types)\n    loop_fun = 'PyUFunc_T'\n    func_defs_cimports = line_joiner.join((f'boost_{m.boost_func_name}{num_ctor_args}' for m in methods))\n    nontype_params = line_joiner[1:].join((f'ctypedef int NINPUTS{n} \"{n}\"' for n in unique_num_inputs))\n    with open(filename, 'w') as fp:\n        boost_hdr = f'boost/math/distributions/{boost_hdr_name}.hpp'\n        relimport = '.'\n        fp.write(dedent(f'''            # cython: language_level=3\\n\\n            # This file was generated by stats/_boost/include/code_gen.py\\n            # All modifications to this file will be overwritten.\\n\\n            from numpy cimport (\\n                import_array,\\n                import_ufunc,\\n                PyUFunc_FromFuncAndData,\\n                PyUFuncGenericFunction,\\n                PyUFunc_None,\\n                {line_joiner.join(types)}\\n            )\\n            from {relimport}templated_pyufunc cimport PyUFunc_T\\n            from {relimport}func_defs cimport (\\n                {func_defs_cimports},\\n            )\\n            cdef extern from \"{boost_hdr}\" namespace \"boost::math\" nogil:\\n                cdef cppclass {boost_dist} nogil:\\n                    pass\\n\\n            # Workaround for Cython's lack of non-type template parameter\\n            # support\\n            cdef extern from * nogil:\\n                {nontype_params}\\n\\n            _DUMMY = \"\"\\n            import_array()\\n            import_ufunc()\\n            '''))\n        if has_NPY_FLOAT16:\n            warn('Boost stats NPY_FLOAT16 ufunc generation not currently not supported!')\n        for (ii, m) in enumerate(methods):\n            fp.write(dedent(f'\\n                cdef PyUFuncGenericFunction loop_func{ii}[{num_types}]\\n                cdef void* func{ii}[1*{num_types}]\\n                cdef char types{ii}[{m.num_inputs + 1}*{num_types}]\\n                '))\n            for (jj, T) in enumerate(types):\n                ctype = {'NPY_DOUBLE': 'double', 'NPY_FLOAT': 'float', 'NPY_FLOAT16': 'npy_half'}[T]\n                boost_fun = f'boost_{m.boost_func_name}{num_ctor_args}'\n                type_str = ', '.join([ctype] * (1 + num_ctor_args))\n                boost_tmpl = f'{boost_dist}, {type_str}'\n                N = m.num_inputs\n                fp.write(f'loop_func{ii}[{jj}] = <PyUFuncGenericFunction>{loop_fun}[{ctype}, NINPUTS{N}]\\nfunc{ii}[{jj}] = <void*>{boost_fun}[{boost_tmpl}]\\n')\n                for tidx in range(m.num_inputs + 1):\n                    fp.write(f'types{ii}[{tidx}+{jj}*{m.num_inputs + 1}] = {T}\\n')\n            arg_list_str = ', '.join(ctor_args)\n            if m.boost_func_name in x_funcs:\n                arg_list_str = 'x, ' + arg_list_str\n            fp.write(dedent(f'\\n                {m.ufunc_name} = PyUFunc_FromFuncAndData(\\n                    loop_func{ii},\\n                    func{ii},\\n                    types{ii},\\n                    {num_types},  # number of supported input types\\n                    {m.num_inputs},  # number of input args\\n                    1,  # number of output args\\n                    PyUFunc_None,  # `identity` element, never mind this\\n                    \"{m.ufunc_name}\",  # function name\\n                    (\"{m.ufunc_name}({arg_list_str}) -> computes \"\\n                     \"{m.boost_func_name} of {scipy_dist} distribution\"),\\n                    0  # unused\\n                )\\n                '))"
        ]
    }
]