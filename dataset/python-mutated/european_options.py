"""Sabr Approximations to European Option prices."""
import tensorflow.compat.v2 as tf
from tf_quant_finance.black_scholes import vanilla_prices
from tf_quant_finance.models.sabr.approximations.implied_volatility import implied_volatility
from tf_quant_finance.models.sabr.approximations.implied_volatility import SabrApproximationType
from tf_quant_finance.models.sabr.approximations.implied_volatility import SabrImpliedVolatilityType

def option_price(*, strikes, expiries, forwards, is_call_options, alpha, beta, volvol, rho, shift=0.0, volatility_type=SabrImpliedVolatilityType.LOGNORMAL, approximation_type=SabrApproximationType.HAGAN, dtype=None, name=None):
    if False:
        i = 10
        return i + 15
    "Computes the approximate European option price under the SABR model.\n\n  For a review of the SABR model and the conventions used, please see the\n  docstring for `implied_volatility`.\n\n  #### Example\n  ```python\n  import tf_quant_finance as tff\n  import tensorflow.compat.v2 as tf\n\n  prices = tff.models.sabr.approximations.european_option_price(\n    strikes=np.array([90.0, 100.0]),\n    expiries=np.array([0.5, 1.0]),\n    forwards=np.array([100.0, 110.0]),\n    is_call_options=np.array([True, False]),\n    alpha=3.2,\n    beta=0.2,\n    volvol=1.4,\n    rho=0.0005,\n    dtype=tf.float64)\n\n  # Expected: [10.41244961, 1.47123225]\n\n  ```\n\n  Args:\n    strikes: Real `Tensor` of arbitrary shape, specifying the strike prices.\n      Values must be strictly positive.\n    expiries: Real `Tensor` of shape compatible with that of `strikes`,\n      specifying the corresponding time-to-expiries of the options. Values must\n      be strictly positive.\n    forwards: Real `Tensor` of shape compatible with that of `strikes`,\n      specifying the observed forward prices of the underlying. Values must be\n      strictly positive.\n    is_call_options: Boolean `Tensor` of shape compatible with that of\n      `forward`, indicating whether the option is a call option (true) or put\n      option (false).\n    alpha: Real `Tensor` of shape compatible with that of `strikes`, specifying\n      the initial values of the stochastic volatility. Values must be strictly\n      positive.\n    beta: Real `Tensor` of shape compatible with that of `strikes`, specifying\n      the model exponent `beta`. Values must satisfy 0 <= `beta` <= 1.\n    volvol: Real `Tensor` of shape compatible with that of `strikes`,\n      specifying the model vol-vol multipliers. Values must satisfy\n      `0 <= volvol`.\n    rho: Real `Tensor` of shape compatible with that of `strikes`, specifying\n      the correlation factors between the Wiener processes modeling the forward\n      and the volatility. Values must satisfy -1 < `rho` < 1.\n    shift: Optional `Tensor` of shape compatible with that of `strkies`,\n      specifying the shift parameter(s). In the shifted model, the process\n      modeling the forward is modified as: dF = sigma * (F + shift) ^ beta * dW.\n      With this modification, negative forward rates are valid as long as\n      F > -shift.\n      Default value: 0.0\n    volatility_type: Either SabrImpliedVolatility.NORMAL or LOGNORMAL.\n      Default value: `LOGNORMAL`.\n    approximation_type: Instance of `SabrApproxmationScheme`.\n      Default value: `HAGAN`.\n    dtype: Optional: `tf.DType`. If supplied, the dtype to be used for\n      converting values to `Tensor`s.\n      Default value: `None`, which means that the default dtypes inferred from\n        `strikes` is used.\n    name: str. The name for the ops created by this function.\n      Default value: 'sabr_approx_eu_option_price'.\n\n  Returns:\n    A real `Tensor` of the same shape as `strikes`, containing the\n    corresponding options price.\n  "
    name = name or 'sabr_approx_eu_option_price'
    with tf.name_scope(name):
        forwards = tf.convert_to_tensor(forwards, dtype=dtype, name='forwards')
        dtype = dtype or forwards.dtype
        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')
        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')
        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')
        if volatility_type == SabrImpliedVolatilityType.NORMAL:
            sigma_normal = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)
            return vanilla_prices.option_price(volatilities=sigma_normal, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=True)
        elif volatility_type == SabrImpliedVolatilityType.LOGNORMAL:
            sigma_black = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)
            return vanilla_prices.option_price(volatilities=sigma_black, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=False)