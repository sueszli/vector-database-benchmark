__all__ = ['splrep', 'splprep', 'splev', 'splint', 'sproot', 'spalde', 'bisplrep', 'bisplev', 'insert', 'splder', 'splantider']
import numpy as np
from ._fitpack_impl import bisplrep, bisplev, dblint
from . import _fitpack_impl as _impl
from ._bsplines import BSpline

def splprep(x, w=None, u=None, ub=None, ue=None, k=3, task=0, s=None, t=None, full_output=0, nest=None, per=0, quiet=1):
    if False:
        return 10
    '\n    Find the B-spline representation of an N-D curve.\n\n    Given a list of N rank-1 arrays, `x`, which represent a curve in\n    N-dimensional space parametrized by `u`, find a smooth approximating\n    spline curve g(`u`). Uses the FORTRAN routine parcur from FITPACK.\n\n    Parameters\n    ----------\n    x : array_like\n        A list of sample vector arrays representing the curve.\n    w : array_like, optional\n        Strictly positive rank-1 array of weights the same length as `x[0]`.\n        The weights are used in computing the weighted least-squares spline\n        fit. If the errors in the `x` values have standard-deviation given by\n        the vector d, then `w` should be 1/d. Default is ``ones(len(x[0]))``.\n    u : array_like, optional\n        An array of parameter values. If not given, these values are\n        calculated automatically as ``M = len(x[0])``, where\n\n            v[0] = 0\n\n            v[i] = v[i-1] + distance(`x[i]`, `x[i-1]`)\n\n            u[i] = v[i] / v[M-1]\n\n    ub, ue : int, optional\n        The end-points of the parameters interval.  Defaults to\n        u[0] and u[-1].\n    k : int, optional\n        Degree of the spline. Cubic splines are recommended.\n        Even values of `k` should be avoided especially with a small s-value.\n        ``1 <= k <= 5``, default is 3.\n    task : int, optional\n        If task==0 (default), find t and c for a given smoothing factor, s.\n        If task==1, find t and c for another value of the smoothing factor, s.\n        There must have been a previous call with task=0 or task=1\n        for the same set of data.\n        If task=-1 find the weighted least square spline for a given set of\n        knots, t.\n    s : float, optional\n        A smoothing condition.  The amount of smoothness is determined by\n        satisfying the conditions: ``sum((w * (y - g))**2,axis=0) <= s``,\n        where g(x) is the smoothed interpolation of (x,y).  The user can\n        use `s` to control the trade-off between closeness and smoothness\n        of fit.  Larger `s` means more smoothing while smaller values of `s`\n        indicate less smoothing. Recommended values of `s` depend on the\n        weights, w.  If the weights represent the inverse of the\n        standard-deviation of y, then a good `s` value should be found in\n        the range ``(m-sqrt(2*m),m+sqrt(2*m))``, where m is the number of\n        data points in x, y, and w.\n    t : array, optional\n        The knots needed for ``task=-1``.\n        There must be at least ``2*k+2`` knots.\n    full_output : int, optional\n        If non-zero, then return optional outputs.\n    nest : int, optional\n        An over-estimate of the total number of knots of the spline to\n        help in determining the storage space.  By default nest=m/2.\n        Always large enough is nest=m+k+1.\n    per : int, optional\n       If non-zero, data points are considered periodic with period\n       ``x[m-1] - x[0]`` and a smooth periodic spline approximation is\n       returned.  Values of ``y[m-1]`` and ``w[m-1]`` are not used.\n    quiet : int, optional\n         Non-zero to suppress messages.\n\n    Returns\n    -------\n    tck : tuple\n        A tuple, ``(t,c,k)`` containing the vector of knots, the B-spline\n        coefficients, and the degree of the spline.\n    u : array\n        An array of the values of the parameter.\n    fp : float\n        The weighted sum of squared residuals of the spline approximation.\n    ier : int\n        An integer flag about splrep success.  Success is indicated\n        if ier<=0. If ier in [1,2,3] an error occurred but was not raised.\n        Otherwise an error is raised.\n    msg : str\n        A message corresponding to the integer flag, ier.\n\n    See Also\n    --------\n    splrep, splev, sproot, spalde, splint,\n    bisplrep, bisplev\n    UnivariateSpline, BivariateSpline\n    BSpline\n    make_interp_spline\n\n    Notes\n    -----\n    See `splev` for evaluation of the spline and its derivatives.\n    The number of dimensions N must be smaller than 11.\n\n    The number of coefficients in the `c` array is ``k+1`` less than the number\n    of knots, ``len(t)``. This is in contrast with `splrep`, which zero-pads\n    the array of coefficients to have the same length as the array of knots.\n    These additional coefficients are ignored by evaluation routines, `splev`\n    and `BSpline`.\n\n    References\n    ----------\n    .. [1] P. Dierckx, "Algorithms for smoothing data with periodic and\n        parametric splines, Computer Graphics and Image Processing",\n        20 (1982) 171-184.\n    .. [2] P. Dierckx, "Algorithms for smoothing data with periodic and\n        parametric splines", report tw55, Dept. Computer Science,\n        K.U.Leuven, 1981.\n    .. [3] P. Dierckx, "Curve and surface fitting with splines", Monographs on\n        Numerical Analysis, Oxford University Press, 1993.\n\n    Examples\n    --------\n    Generate a discretization of a limacon curve in the polar coordinates:\n\n    >>> import numpy as np\n    >>> phi = np.linspace(0, 2.*np.pi, 40)\n    >>> r = 0.5 + np.cos(phi)         # polar coords\n    >>> x, y = r * np.cos(phi), r * np.sin(phi)    # convert to cartesian\n\n    And interpolate:\n\n    >>> from scipy.interpolate import splprep, splev\n    >>> tck, u = splprep([x, y], s=0)\n    >>> new_points = splev(u, tck)\n\n    Notice that (i) we force interpolation by using `s=0`,\n    (ii) the parameterization, ``u``, is generated automatically.\n    Now plot the result:\n\n    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot(x, y, \'ro\')\n    >>> ax.plot(new_points[0], new_points[1], \'r-\')\n    >>> plt.show()\n\n    '
    res = _impl.splprep(x, w, u, ub, ue, k, task, s, t, full_output, nest, per, quiet)
    return res

def splrep(x, y, w=None, xb=None, xe=None, k=3, task=0, s=None, t=None, full_output=0, per=0, quiet=1):
    if False:
        i = 10
        return i + 15
    '\n    Find the B-spline representation of a 1-D curve.\n\n    Given the set of data points ``(x[i], y[i])`` determine a smooth spline\n    approximation of degree k on the interval ``xb <= x <= xe``.\n\n    Parameters\n    ----------\n    x, y : array_like\n        The data points defining a curve y = f(x).\n    w : array_like, optional\n        Strictly positive rank-1 array of weights the same length as x and y.\n        The weights are used in computing the weighted least-squares spline\n        fit. If the errors in the y values have standard-deviation given by the\n        vector d, then w should be 1/d. Default is ones(len(x)).\n    xb, xe : float, optional\n        The interval to fit.  If None, these default to x[0] and x[-1]\n        respectively.\n    k : int, optional\n        The degree of the spline fit. It is recommended to use cubic splines.\n        Even values of k should be avoided especially with small s values.\n        1 <= k <= 5\n    task : {1, 0, -1}, optional\n        If task==0 find t and c for a given smoothing factor, s.\n\n        If task==1 find t and c for another value of the smoothing factor, s.\n        There must have been a previous call with task=0 or task=1 for the same\n        set of data (t will be stored an used internally)\n\n        If task=-1 find the weighted least square spline for a given set of\n        knots, t. These should be interior knots as knots on the ends will be\n        added automatically.\n    s : float, optional\n        A smoothing condition. The amount of smoothness is determined by\n        satisfying the conditions: ``sum((w * (y - g))**2,axis=0) <= s`` where g(x)\n        is the smoothed interpolation of (x,y). The user can use s to control\n        the tradeoff between closeness and smoothness of fit. Larger s means\n        more smoothing while smaller values of s indicate less smoothing.\n        Recommended values of s depend on the weights, w. If the weights\n        represent the inverse of the standard-deviation of y, then a good s\n        value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) where m is\n        the number of datapoints in x, y, and w. default : s=m-sqrt(2*m) if\n        weights are supplied. s = 0.0 (interpolating) if no weights are\n        supplied.\n    t : array_like, optional\n        The knots needed for task=-1. If given then task is automatically set\n        to -1.\n    full_output : bool, optional\n        If non-zero, then return optional outputs.\n    per : bool, optional\n        If non-zero, data points are considered periodic with period x[m-1] -\n        x[0] and a smooth periodic spline approximation is returned. Values of\n        y[m-1] and w[m-1] are not used.\n    quiet : bool, optional\n        Non-zero to suppress messages.\n\n    Returns\n    -------\n    tck : tuple\n        A tuple (t,c,k) containing the vector of knots, the B-spline\n        coefficients, and the degree of the spline.\n    fp : array, optional\n        The weighted sum of squared residuals of the spline approximation.\n    ier : int, optional\n        An integer flag about splrep success. Success is indicated if ier<=0.\n        If ier in [1,2,3] an error occurred but was not raised. Otherwise an\n        error is raised.\n    msg : str, optional\n        A message corresponding to the integer flag, ier.\n\n    See Also\n    --------\n    UnivariateSpline, BivariateSpline\n    splprep, splev, sproot, spalde, splint\n    bisplrep, bisplev\n    BSpline\n    make_interp_spline\n\n    Notes\n    -----\n    See `splev` for evaluation of the spline and its derivatives. Uses the\n    FORTRAN routine ``curfit`` from FITPACK.\n\n    The user is responsible for assuring that the values of `x` are unique.\n    Otherwise, `splrep` will not return sensible results.\n\n    If provided, knots `t` must satisfy the Schoenberg-Whitney conditions,\n    i.e., there must be a subset of data points ``x[j]`` such that\n    ``t[j] < x[j] < t[j+k+1]``, for ``j=0, 1,...,n-k-2``.\n\n    This routine zero-pads the coefficients array ``c`` to have the same length\n    as the array of knots ``t`` (the trailing ``k + 1`` coefficients are ignored\n    by the evaluation routines, `splev` and `BSpline`.) This is in contrast with\n    `splprep`, which does not zero-pad the coefficients.\n\n    References\n    ----------\n    Based on algorithms described in [1]_, [2]_, [3]_, and [4]_:\n\n    .. [1] P. Dierckx, "An algorithm for smoothing, differentiation and\n       integration of experimental data using spline functions",\n       J.Comp.Appl.Maths 1 (1975) 165-184.\n    .. [2] P. Dierckx, "A fast algorithm for smoothing data on a rectangular\n       grid while using spline functions", SIAM J.Numer.Anal. 19 (1982)\n       1286-1304.\n    .. [3] P. Dierckx, "An improved algorithm for curve fitting with spline\n       functions", report tw54, Dept. Computer Science,K.U. Leuven, 1981.\n    .. [4] P. Dierckx, "Curve and surface fitting with splines", Monographs on\n       Numerical Analysis, Oxford University Press, 1993.\n\n    Examples\n    --------\n    You can interpolate 1-D points with a B-spline curve.\n    Further examples are given in\n    :ref:`in the tutorial <tutorial-interpolate_splXXX>`.\n\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> from scipy.interpolate import splev, splrep\n    >>> x = np.linspace(0, 10, 10)\n    >>> y = np.sin(x)\n    >>> spl = splrep(x, y)\n    >>> x2 = np.linspace(0, 10, 200)\n    >>> y2 = splev(x2, spl)\n    >>> plt.plot(x, y, \'o\', x2, y2)\n    >>> plt.show()\n\n    '
    res = _impl.splrep(x, y, w, xb, xe, k, task, s, t, full_output, per, quiet)
    return res

def splev(x, tck, der=0, ext=0):
    if False:
        while True:
            i = 10
    '\n    Evaluate a B-spline or its derivatives.\n\n    Given the knots and coefficients of a B-spline representation, evaluate\n    the value of the smoothing polynomial and its derivatives. This is a\n    wrapper around the FORTRAN routines splev and splder of FITPACK.\n\n    Parameters\n    ----------\n    x : array_like\n        An array of points at which to return the value of the smoothed\n        spline or its derivatives. If `tck` was returned from `splprep`,\n        then the parameter values, u should be given.\n    tck : 3-tuple or a BSpline object\n        If a tuple, then it should be a sequence of length 3 returned by\n        `splrep` or `splprep` containing the knots, coefficients, and degree\n        of the spline. (Also see Notes.)\n    der : int, optional\n        The order of derivative of the spline to compute (must be less than\n        or equal to k, the degree of the spline).\n    ext : int, optional\n        Controls the value returned for elements of ``x`` not in the\n        interval defined by the knot sequence.\n\n        * if ext=0, return the extrapolated value.\n        * if ext=1, return 0\n        * if ext=2, raise a ValueError\n        * if ext=3, return the boundary value.\n\n        The default value is 0.\n\n    Returns\n    -------\n    y : ndarray or list of ndarrays\n        An array of values representing the spline function evaluated at\n        the points in `x`.  If `tck` was returned from `splprep`, then this\n        is a list of arrays representing the curve in an N-D space.\n\n    See Also\n    --------\n    splprep, splrep, sproot, spalde, splint\n    bisplrep, bisplev\n    BSpline\n\n    Notes\n    -----\n    Manipulating the tck-tuples directly is not recommended. In new code,\n    prefer using `BSpline` objects.\n\n    References\n    ----------\n    .. [1] C. de Boor, "On calculating with b-splines", J. Approximation\n        Theory, 6, p.50-62, 1972.\n    .. [2] M. G. Cox, "The numerical evaluation of b-splines", J. Inst. Maths\n        Applics, 10, p.134-149, 1972.\n    .. [3] P. Dierckx, "Curve and surface fitting with splines", Monographs\n        on Numerical Analysis, Oxford University Press, 1993.\n\n    Examples\n    --------\n    Examples are given :ref:`in the tutorial <tutorial-interpolate_splXXX>`.\n\n    '
    if isinstance(tck, BSpline):
        if tck.c.ndim > 1:
            mesg = 'Calling splev() with BSpline objects with c.ndim > 1 is not allowed. Use BSpline.__call__(x) instead.'
            raise ValueError(mesg)
        try:
            extrapolate = {0: True}[ext]
        except KeyError as e:
            raise ValueError('Extrapolation mode %s is not supported by BSpline.' % ext) from e
        return tck(x, der, extrapolate=extrapolate)
    else:
        return _impl.splev(x, tck, der, ext)

def splint(a, b, tck, full_output=0):
    if False:
        return 10
    '\n    Evaluate the definite integral of a B-spline between two given points.\n\n    Parameters\n    ----------\n    a, b : float\n        The end-points of the integration interval.\n    tck : tuple or a BSpline instance\n        If a tuple, then it should be a sequence of length 3, containing the\n        vector of knots, the B-spline coefficients, and the degree of the\n        spline (see `splev`).\n    full_output : int, optional\n        Non-zero to return optional output.\n\n    Returns\n    -------\n    integral : float\n        The resulting integral.\n    wrk : ndarray\n        An array containing the integrals of the normalized B-splines\n        defined on the set of knots.\n        (Only returned if `full_output` is non-zero)\n\n    See Also\n    --------\n    splprep, splrep, sproot, spalde, splev\n    bisplrep, bisplev\n    BSpline\n\n    Notes\n    -----\n    `splint` silently assumes that the spline function is zero outside the data\n    interval (`a`, `b`).\n\n    Manipulating the tck-tuples directly is not recommended. In new code,\n    prefer using the `BSpline` objects.\n\n    References\n    ----------\n    .. [1] P.W. Gaffney, The calculation of indefinite integrals of b-splines",\n        J. Inst. Maths Applics, 17, p.37-41, 1976.\n    .. [2] P. Dierckx, "Curve and surface fitting with splines", Monographs\n        on Numerical Analysis, Oxford University Press, 1993.\n\n    Examples\n    --------\n    Examples are given :ref:`in the tutorial <tutorial-interpolate_splXXX>`.\n\n    '
    if isinstance(tck, BSpline):
        if tck.c.ndim > 1:
            mesg = 'Calling splint() with BSpline objects with c.ndim > 1 is not allowed. Use BSpline.integrate() instead.'
            raise ValueError(mesg)
        if full_output != 0:
            mesg = 'full_output = %s is not supported. Proceeding as if full_output = 0' % full_output
        return tck.integrate(a, b, extrapolate=False)
    else:
        return _impl.splint(a, b, tck, full_output)

def sproot(tck, mest=10):
    if False:
        i = 10
        return i + 15
    '\n    Find the roots of a cubic B-spline.\n\n    Given the knots (>=8) and coefficients of a cubic B-spline return the\n    roots of the spline.\n\n    Parameters\n    ----------\n    tck : tuple or a BSpline object\n        If a tuple, then it should be a sequence of length 3, containing the\n        vector of knots, the B-spline coefficients, and the degree of the\n        spline.\n        The number of knots must be >= 8, and the degree must be 3.\n        The knots must be a montonically increasing sequence.\n    mest : int, optional\n        An estimate of the number of zeros (Default is 10).\n\n    Returns\n    -------\n    zeros : ndarray\n        An array giving the roots of the spline.\n\n    See Also\n    --------\n    splprep, splrep, splint, spalde, splev\n    bisplrep, bisplev\n    BSpline\n\n    Notes\n    -----\n    Manipulating the tck-tuples directly is not recommended. In new code,\n    prefer using the `BSpline` objects.\n\n    References\n    ----------\n    .. [1] C. de Boor, "On calculating with b-splines", J. Approximation\n        Theory, 6, p.50-62, 1972.\n    .. [2] M. G. Cox, "The numerical evaluation of b-splines", J. Inst. Maths\n        Applics, 10, p.134-149, 1972.\n    .. [3] P. Dierckx, "Curve and surface fitting with splines", Monographs\n        on Numerical Analysis, Oxford University Press, 1993.\n\n    Examples\n    --------\n\n    For some data, this method may miss a root. This happens when one of\n    the spline knots (which FITPACK places automatically) happens to\n    coincide with the true root. A workaround is to convert to `PPoly`,\n    which uses a different root-finding algorithm.\n\n    For example,\n\n    >>> x = [1.96, 1.97, 1.98, 1.99, 2.00, 2.01, 2.02, 2.03, 2.04, 2.05]\n    >>> y = [-6.365470e-03, -4.790580e-03, -3.204320e-03, -1.607270e-03,\n    ...      4.440892e-16,  1.616930e-03,  3.243000e-03,  4.877670e-03,\n    ...      6.520430e-03,  8.170770e-03]\n    >>> from scipy.interpolate import splrep, sproot, PPoly\n    >>> tck = splrep(x, y, s=0)\n    >>> sproot(tck)\n    array([], dtype=float64)\n\n    Converting to a PPoly object does find the roots at `x=2`:\n\n    >>> ppoly = PPoly.from_spline(tck)\n    >>> ppoly.roots(extrapolate=False)\n    array([2.])\n\n\n    Further examples are given :ref:`in the tutorial\n    <tutorial-interpolate_splXXX>`.\n\n    '
    if isinstance(tck, BSpline):
        if tck.c.ndim > 1:
            mesg = 'Calling sproot() with BSpline objects with c.ndim > 1 is not allowed.'
            raise ValueError(mesg)
        (t, c, k) = tck.tck
        sh = tuple(range(c.ndim))
        c = c.transpose(sh[1:] + (0,))
        return _impl.sproot((t, c, k), mest)
    else:
        return _impl.sproot(tck, mest)

def spalde(x, tck):
    if False:
        return 10
    '\n    Evaluate all derivatives of a B-spline.\n\n    Given the knots and coefficients of a cubic B-spline compute all\n    derivatives up to order k at a point (or set of points).\n\n    Parameters\n    ----------\n    x : array_like\n        A point or a set of points at which to evaluate the derivatives.\n        Note that ``t(k) <= x <= t(n-k+1)`` must hold for each `x`.\n    tck : tuple\n        A tuple (t,c,k) containing the vector of knots,\n        the B-spline coefficients, and the degree of the spline.\n\n    Returns\n    -------\n    results : {ndarray, list of ndarrays}\n        An array (or a list of arrays) containing all derivatives\n        up to order k inclusive for each point `x`.\n\n    See Also\n    --------\n    splprep, splrep, splint, sproot, splev, bisplrep, bisplev,\n    UnivariateSpline, BivariateSpline\n\n    References\n    ----------\n    .. [1] de Boor C : On calculating with b-splines, J. Approximation Theory\n       6 (1972) 50-62.\n    .. [2] Cox M.G. : The numerical evaluation of b-splines, J. Inst. Maths\n       applics 10 (1972) 134-149.\n    .. [3] Dierckx P. : Curve and surface fitting with splines, Monographs on\n       Numerical Analysis, Oxford University Press, 1993.\n\n    '
    if isinstance(tck, BSpline):
        raise TypeError('spalde does not accept BSpline instances.')
    else:
        return _impl.spalde(x, tck)

def insert(x, tck, m=1, per=0):
    if False:
        for i in range(10):
            print('nop')
    '\n    Insert knots into a B-spline.\n\n    Given the knots and coefficients of a B-spline representation, create a\n    new B-spline with a knot inserted `m` times at point `x`.\n    This is a wrapper around the FORTRAN routine insert of FITPACK.\n\n    Parameters\n    ----------\n    x (u) : array_like\n        A 1-D point at which to insert a new knot(s).  If `tck` was returned\n        from ``splprep``, then the parameter values, u should be given.\n    tck : a `BSpline` instance or a tuple\n        If tuple, then it is expected to be a tuple (t,c,k) containing\n        the vector of knots, the B-spline coefficients, and the degree of\n        the spline.\n    m : int, optional\n        The number of times to insert the given knot (its multiplicity).\n        Default is 1.\n    per : int, optional\n        If non-zero, the input spline is considered periodic.\n\n    Returns\n    -------\n    BSpline instance or a tuple\n        A new B-spline with knots t, coefficients c, and degree k.\n        ``t(k+1) <= x <= t(n-k)``, where k is the degree of the spline.\n        In case of a periodic spline (``per != 0``) there must be\n        either at least k interior knots t(j) satisfying ``t(k+1)<t(j)<=x``\n        or at least k interior knots t(j) satisfying ``x<=t(j)<t(n-k)``.\n        A tuple is returned iff the input argument `tck` is a tuple, otherwise\n        a BSpline object is constructed and returned.\n\n    Notes\n    -----\n    Based on algorithms from [1]_ and [2]_.\n\n    Manipulating the tck-tuples directly is not recommended. In new code,\n    prefer using the `BSpline` objects.\n\n    References\n    ----------\n    .. [1] W. Boehm, "Inserting new knots into b-spline curves.",\n        Computer Aided Design, 12, p.199-201, 1980.\n    .. [2] P. Dierckx, "Curve and surface fitting with splines, Monographs on\n        Numerical Analysis", Oxford University Press, 1993.\n\n    Examples\n    --------\n    You can insert knots into a B-spline.\n\n    >>> from scipy.interpolate import splrep, insert\n    >>> import numpy as np\n    >>> x = np.linspace(0, 10, 5)\n    >>> y = np.sin(x)\n    >>> tck = splrep(x, y)\n    >>> tck[0]\n    array([ 0.,  0.,  0.,  0.,  5., 10., 10., 10., 10.])\n\n    A knot is inserted:\n\n    >>> tck_inserted = insert(3, tck)\n    >>> tck_inserted[0]\n    array([ 0.,  0.,  0.,  0.,  3.,  5., 10., 10., 10., 10.])\n\n    Some knots are inserted:\n\n    >>> tck_inserted2 = insert(8, tck, m=3)\n    >>> tck_inserted2[0]\n    array([ 0.,  0.,  0.,  0.,  5.,  8.,  8.,  8., 10., 10., 10., 10.])\n\n    '
    if isinstance(tck, BSpline):
        (t, c, k) = tck.tck
        sh = tuple(range(c.ndim))
        c = c.transpose(sh[1:] + (0,))
        (t_, c_, k_) = _impl.insert(x, (t, c, k), m, per)
        c_ = np.asarray(c_)
        c_ = c_.transpose((sh[-1],) + sh[:-1])
        return BSpline(t_, c_, k_)
    else:
        return _impl.insert(x, tck, m, per)

def splder(tck, n=1):
    if False:
        for i in range(10):
            print('nop')
    "\n    Compute the spline representation of the derivative of a given spline\n\n    Parameters\n    ----------\n    tck : BSpline instance or a tuple of (t, c, k)\n        Spline whose derivative to compute\n    n : int, optional\n        Order of derivative to evaluate. Default: 1\n\n    Returns\n    -------\n    `BSpline` instance or tuple\n        Spline of order k2=k-n representing the derivative\n        of the input spline.\n        A tuple is returned iff the input argument `tck` is a tuple, otherwise\n        a BSpline object is constructed and returned.\n\n    See Also\n    --------\n    splantider, splev, spalde\n    BSpline\n\n    Notes\n    -----\n\n    .. versionadded:: 0.13.0\n\n    Examples\n    --------\n    This can be used for finding maxima of a curve:\n\n    >>> from scipy.interpolate import splrep, splder, sproot\n    >>> import numpy as np\n    >>> x = np.linspace(0, 10, 70)\n    >>> y = np.sin(x)\n    >>> spl = splrep(x, y, k=4)\n\n    Now, differentiate the spline and find the zeros of the\n    derivative. (NB: `sproot` only works for order 3 splines, so we\n    fit an order 4 spline):\n\n    >>> dspl = splder(spl)\n    >>> sproot(dspl) / np.pi\n    array([ 0.50000001,  1.5       ,  2.49999998])\n\n    This agrees well with roots :math:`\\pi/2 + n\\pi` of\n    :math:`\\cos(x) = \\sin'(x)`.\n\n    "
    if isinstance(tck, BSpline):
        return tck.derivative(n)
    else:
        return _impl.splder(tck, n)

def splantider(tck, n=1):
    if False:
        while True:
            i = 10
    '\n    Compute the spline for the antiderivative (integral) of a given spline.\n\n    Parameters\n    ----------\n    tck : BSpline instance or a tuple of (t, c, k)\n        Spline whose antiderivative to compute\n    n : int, optional\n        Order of antiderivative to evaluate. Default: 1\n\n    Returns\n    -------\n    BSpline instance or a tuple of (t2, c2, k2)\n        Spline of order k2=k+n representing the antiderivative of the input\n        spline.\n        A tuple is returned iff the input argument `tck` is a tuple, otherwise\n        a BSpline object is constructed and returned.\n\n    See Also\n    --------\n    splder, splev, spalde\n    BSpline\n\n    Notes\n    -----\n    The `splder` function is the inverse operation of this function.\n    Namely, ``splder(splantider(tck))`` is identical to `tck`, modulo\n    rounding error.\n\n    .. versionadded:: 0.13.0\n\n    Examples\n    --------\n    >>> from scipy.interpolate import splrep, splder, splantider, splev\n    >>> import numpy as np\n    >>> x = np.linspace(0, np.pi/2, 70)\n    >>> y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2)\n    >>> spl = splrep(x, y)\n\n    The derivative is the inverse operation of the antiderivative,\n    although some floating point error accumulates:\n\n    >>> splev(1.7, spl), splev(1.7, splder(splantider(spl)))\n    (array(2.1565429877197317), array(2.1565429877201865))\n\n    Antiderivative can be used to evaluate definite integrals:\n\n    >>> ispl = splantider(spl)\n    >>> splev(np.pi/2, ispl) - splev(0, ispl)\n    2.2572053588768486\n\n    This is indeed an approximation to the complete elliptic integral\n    :math:`K(m) = \\int_0^{\\pi/2} [1 - m\\sin^2 x]^{-1/2} dx`:\n\n    >>> from scipy.special import ellipk\n    >>> ellipk(0.8)\n    2.2572053268208538\n\n    '
    if isinstance(tck, BSpline):
        return tck.antiderivative(n)
    else:
        return _impl.splantider(tck, n)