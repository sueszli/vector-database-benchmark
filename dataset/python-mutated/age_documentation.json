[
    {
        "func_name": "other_page",
        "original": "@ui.page('/other_page')\ndef other_page():\n    ui.label('Welcome to the other side')\n    ui.link('Back to main page', '/documentation#page')",
        "mutated": [
            "@ui.page('/other_page')\ndef other_page():\n    if False:\n        i = 10\n    ui.label('Welcome to the other side')\n    ui.link('Back to main page', '/documentation#page')",
            "@ui.page('/other_page')\ndef other_page():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ui.label('Welcome to the other side')\n    ui.link('Back to main page', '/documentation#page')",
            "@ui.page('/other_page')\ndef other_page():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ui.label('Welcome to the other side')\n    ui.link('Back to main page', '/documentation#page')",
            "@ui.page('/other_page')\ndef other_page():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ui.label('Welcome to the other side')\n    ui.link('Back to main page', '/documentation#page')",
            "@ui.page('/other_page')\ndef other_page():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ui.label('Welcome to the other side')\n    ui.link('Back to main page', '/documentation#page')"
        ]
    },
    {
        "func_name": "dark_page",
        "original": "@ui.page('/dark_page', dark=True)\ndef dark_page():\n    ui.label('Welcome to the dark side')\n    ui.link('Back to main page', '/documentation#page')",
        "mutated": [
            "@ui.page('/dark_page', dark=True)\ndef dark_page():\n    if False:\n        i = 10\n    ui.label('Welcome to the dark side')\n    ui.link('Back to main page', '/documentation#page')",
            "@ui.page('/dark_page', dark=True)\ndef dark_page():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ui.label('Welcome to the dark side')\n    ui.link('Back to main page', '/documentation#page')",
            "@ui.page('/dark_page', dark=True)\ndef dark_page():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ui.label('Welcome to the dark side')\n    ui.link('Back to main page', '/documentation#page')",
            "@ui.page('/dark_page', dark=True)\ndef dark_page():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ui.label('Welcome to the dark side')\n    ui.link('Back to main page', '/documentation#page')",
            "@ui.page('/dark_page', dark=True)\ndef dark_page():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ui.label('Welcome to the dark side')\n    ui.link('Back to main page', '/documentation#page')"
        ]
    },
    {
        "func_name": "main_demo",
        "original": "def main_demo() -> None:\n\n    @ui.page('/other_page')\n    def other_page():\n        ui.label('Welcome to the other side')\n        ui.link('Back to main page', '/documentation#page')\n\n    @ui.page('/dark_page', dark=True)\n    def dark_page():\n        ui.label('Welcome to the dark side')\n        ui.link('Back to main page', '/documentation#page')\n    ui.link('Visit other page', other_page)\n    ui.link('Visit dark page', dark_page)",
        "mutated": [
            "def main_demo() -> None:\n    if False:\n        i = 10\n\n    @ui.page('/other_page')\n    def other_page():\n        ui.label('Welcome to the other side')\n        ui.link('Back to main page', '/documentation#page')\n\n    @ui.page('/dark_page', dark=True)\n    def dark_page():\n        ui.label('Welcome to the dark side')\n        ui.link('Back to main page', '/documentation#page')\n    ui.link('Visit other page', other_page)\n    ui.link('Visit dark page', dark_page)",
            "def main_demo() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    @ui.page('/other_page')\n    def other_page():\n        ui.label('Welcome to the other side')\n        ui.link('Back to main page', '/documentation#page')\n\n    @ui.page('/dark_page', dark=True)\n    def dark_page():\n        ui.label('Welcome to the dark side')\n        ui.link('Back to main page', '/documentation#page')\n    ui.link('Visit other page', other_page)\n    ui.link('Visit dark page', dark_page)",
            "def main_demo() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    @ui.page('/other_page')\n    def other_page():\n        ui.label('Welcome to the other side')\n        ui.link('Back to main page', '/documentation#page')\n\n    @ui.page('/dark_page', dark=True)\n    def dark_page():\n        ui.label('Welcome to the dark side')\n        ui.link('Back to main page', '/documentation#page')\n    ui.link('Visit other page', other_page)\n    ui.link('Visit dark page', dark_page)",
            "def main_demo() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    @ui.page('/other_page')\n    def other_page():\n        ui.label('Welcome to the other side')\n        ui.link('Back to main page', '/documentation#page')\n\n    @ui.page('/dark_page', dark=True)\n    def dark_page():\n        ui.label('Welcome to the dark side')\n        ui.link('Back to main page', '/documentation#page')\n    ui.link('Visit other page', other_page)\n    ui.link('Visit dark page', dark_page)",
            "def main_demo() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    @ui.page('/other_page')\n    def other_page():\n        ui.label('Welcome to the other side')\n        ui.link('Back to main page', '/documentation#page')\n\n    @ui.page('/dark_page', dark=True)\n    def dark_page():\n        ui.label('Welcome to the dark side')\n        ui.link('Back to main page', '/documentation#page')\n    ui.link('Visit other page', other_page)\n    ui.link('Visit dark page', dark_page)"
        ]
    },
    {
        "func_name": "page",
        "original": "@ui.page('/repeat/{word}/{count}')\ndef page(word: str, count: int):\n    ui.label(word * count)",
        "mutated": [
            "@ui.page('/repeat/{word}/{count}')\ndef page(word: str, count: int):\n    if False:\n        i = 10\n    ui.label(word * count)",
            "@ui.page('/repeat/{word}/{count}')\ndef page(word: str, count: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ui.label(word * count)",
            "@ui.page('/repeat/{word}/{count}')\ndef page(word: str, count: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ui.label(word * count)",
            "@ui.page('/repeat/{word}/{count}')\ndef page(word: str, count: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ui.label(word * count)",
            "@ui.page('/repeat/{word}/{count}')\ndef page(word: str, count: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ui.label(word * count)"
        ]
    },
    {
        "func_name": "page_with_path_parameters_demo",
        "original": "@text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\ndef page_with_path_parameters_demo():\n\n    @ui.page('/repeat/{word}/{count}')\n    def page(word: str, count: int):\n        ui.label(word * count)\n    ui.link('Say hi to Santa!', '/repeat/Ho! /3')",
        "mutated": [
            "@text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\ndef page_with_path_parameters_demo():\n    if False:\n        i = 10\n\n    @ui.page('/repeat/{word}/{count}')\n    def page(word: str, count: int):\n        ui.label(word * count)\n    ui.link('Say hi to Santa!', '/repeat/Ho! /3')",
            "@text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\ndef page_with_path_parameters_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    @ui.page('/repeat/{word}/{count}')\n    def page(word: str, count: int):\n        ui.label(word * count)\n    ui.link('Say hi to Santa!', '/repeat/Ho! /3')",
            "@text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\ndef page_with_path_parameters_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    @ui.page('/repeat/{word}/{count}')\n    def page(word: str, count: int):\n        ui.label(word * count)\n    ui.link('Say hi to Santa!', '/repeat/Ho! /3')",
            "@text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\ndef page_with_path_parameters_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    @ui.page('/repeat/{word}/{count}')\n    def page(word: str, count: int):\n        ui.label(word * count)\n    ui.link('Say hi to Santa!', '/repeat/Ho! /3')",
            "@text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\ndef page_with_path_parameters_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    @ui.page('/repeat/{word}/{count}')\n    def page(word: str, count: int):\n        ui.label(word * count)\n    ui.link('Say hi to Santa!', '/repeat/Ho! /3')"
        ]
    },
    {
        "func_name": "wait_for_connected_demo",
        "original": "@text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\ndef wait_for_connected_demo():\n    import asyncio\n    from nicegui import Client\n\n    @ui.page('/wait_for_connection')\n    async def wait_for_connection(client: Client):\n        ui.label('This text is displayed immediately.')\n        await client.connected()\n        await asyncio.sleep(2)\n        ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n        ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n    ui.link('wait for connection', wait_for_connection)",
        "mutated": [
            "@text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\ndef wait_for_connected_demo():\n    if False:\n        i = 10\n    import asyncio\n    from nicegui import Client\n\n    @ui.page('/wait_for_connection')\n    async def wait_for_connection(client: Client):\n        ui.label('This text is displayed immediately.')\n        await client.connected()\n        await asyncio.sleep(2)\n        ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n        ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n    ui.link('wait for connection', wait_for_connection)",
            "@text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\ndef wait_for_connected_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    import asyncio\n    from nicegui import Client\n\n    @ui.page('/wait_for_connection')\n    async def wait_for_connection(client: Client):\n        ui.label('This text is displayed immediately.')\n        await client.connected()\n        await asyncio.sleep(2)\n        ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n        ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n    ui.link('wait for connection', wait_for_connection)",
            "@text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\ndef wait_for_connected_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    import asyncio\n    from nicegui import Client\n\n    @ui.page('/wait_for_connection')\n    async def wait_for_connection(client: Client):\n        ui.label('This text is displayed immediately.')\n        await client.connected()\n        await asyncio.sleep(2)\n        ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n        ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n    ui.link('wait for connection', wait_for_connection)",
            "@text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\ndef wait_for_connected_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    import asyncio\n    from nicegui import Client\n\n    @ui.page('/wait_for_connection')\n    async def wait_for_connection(client: Client):\n        ui.label('This text is displayed immediately.')\n        await client.connected()\n        await asyncio.sleep(2)\n        ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n        ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n    ui.link('wait for connection', wait_for_connection)",
            "@text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\ndef wait_for_connected_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    import asyncio\n    from nicegui import Client\n\n    @ui.page('/wait_for_connection')\n    async def wait_for_connection(client: Client):\n        ui.label('This text is displayed immediately.')\n        await client.connected()\n        await asyncio.sleep(2)\n        ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n        ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n    ui.link('wait for connection', wait_for_connection)"
        ]
    },
    {
        "func_name": "api_router_demo",
        "original": "@text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\ndef api_router_demo():\n    ui.label('Shows up on /sub-path')",
        "mutated": [
            "@text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\ndef api_router_demo():\n    if False:\n        i = 10\n    ui.label('Shows up on /sub-path')",
            "@text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\ndef api_router_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ui.label('Shows up on /sub-path')",
            "@text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\ndef api_router_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ui.label('Shows up on /sub-path')",
            "@text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\ndef api_router_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ui.label('Shows up on /sub-path')",
            "@text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\ndef api_router_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ui.label('Shows up on /sub-path')"
        ]
    },
    {
        "func_name": "more",
        "original": "def more() -> None:\n\n    @text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\n    def page_with_path_parameters_demo():\n\n        @ui.page('/repeat/{word}/{count}')\n        def page(word: str, count: int):\n            ui.label(word * count)\n        ui.link('Say hi to Santa!', '/repeat/Ho! /3')\n\n    @text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\n    def wait_for_connected_demo():\n        import asyncio\n        from nicegui import Client\n\n        @ui.page('/wait_for_connection')\n        async def wait_for_connection(client: Client):\n            ui.label('This text is displayed immediately.')\n            await client.connected()\n            await asyncio.sleep(2)\n            ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n            ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n        ui.link('wait for connection', wait_for_connection)\n\n    @text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\n    def api_router_demo():\n        ui.label('Shows up on /sub-path')",
        "mutated": [
            "def more() -> None:\n    if False:\n        i = 10\n\n    @text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\n    def page_with_path_parameters_demo():\n\n        @ui.page('/repeat/{word}/{count}')\n        def page(word: str, count: int):\n            ui.label(word * count)\n        ui.link('Say hi to Santa!', '/repeat/Ho! /3')\n\n    @text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\n    def wait_for_connected_demo():\n        import asyncio\n        from nicegui import Client\n\n        @ui.page('/wait_for_connection')\n        async def wait_for_connection(client: Client):\n            ui.label('This text is displayed immediately.')\n            await client.connected()\n            await asyncio.sleep(2)\n            ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n            ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n        ui.link('wait for connection', wait_for_connection)\n\n    @text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\n    def api_router_demo():\n        ui.label('Shows up on /sub-path')",
            "def more() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    @text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\n    def page_with_path_parameters_demo():\n\n        @ui.page('/repeat/{word}/{count}')\n        def page(word: str, count: int):\n            ui.label(word * count)\n        ui.link('Say hi to Santa!', '/repeat/Ho! /3')\n\n    @text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\n    def wait_for_connected_demo():\n        import asyncio\n        from nicegui import Client\n\n        @ui.page('/wait_for_connection')\n        async def wait_for_connection(client: Client):\n            ui.label('This text is displayed immediately.')\n            await client.connected()\n            await asyncio.sleep(2)\n            ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n            ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n        ui.link('wait for connection', wait_for_connection)\n\n    @text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\n    def api_router_demo():\n        ui.label('Shows up on /sub-path')",
            "def more() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    @text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\n    def page_with_path_parameters_demo():\n\n        @ui.page('/repeat/{word}/{count}')\n        def page(word: str, count: int):\n            ui.label(word * count)\n        ui.link('Say hi to Santa!', '/repeat/Ho! /3')\n\n    @text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\n    def wait_for_connected_demo():\n        import asyncio\n        from nicegui import Client\n\n        @ui.page('/wait_for_connection')\n        async def wait_for_connection(client: Client):\n            ui.label('This text is displayed immediately.')\n            await client.connected()\n            await asyncio.sleep(2)\n            ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n            ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n        ui.link('wait for connection', wait_for_connection)\n\n    @text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\n    def api_router_demo():\n        ui.label('Shows up on /sub-path')",
            "def more() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    @text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\n    def page_with_path_parameters_demo():\n\n        @ui.page('/repeat/{word}/{count}')\n        def page(word: str, count: int):\n            ui.label(word * count)\n        ui.link('Say hi to Santa!', '/repeat/Ho! /3')\n\n    @text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\n    def wait_for_connected_demo():\n        import asyncio\n        from nicegui import Client\n\n        @ui.page('/wait_for_connection')\n        async def wait_for_connection(client: Client):\n            ui.label('This text is displayed immediately.')\n            await client.connected()\n            await asyncio.sleep(2)\n            ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n            ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n        ui.link('wait for connection', wait_for_connection)\n\n    @text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\n    def api_router_demo():\n        ui.label('Shows up on /sub-path')",
            "def more() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    @text_demo('Pages with Path Parameters', '\\n        Page routes can contain parameters like [FastAPI](https://fastapi.tiangolo.com/tutorial/path-params/>).\\n        If type-annotated, they are automatically converted to bool, int, float and complex values.\\n        If the page function expects a `request` argument, the request object is automatically provided.\\n        The `client` argument provides access to the websocket connection, layout, etc.\\n    ')\n    def page_with_path_parameters_demo():\n\n        @ui.page('/repeat/{word}/{count}')\n        def page(word: str, count: int):\n            ui.label(word * count)\n        ui.link('Say hi to Santa!', '/repeat/Ho! /3')\n\n    @text_demo('Wait for Client Connection', '\\n        To wait for a client connection, you can add a `client` argument to the decorated page function\\n        and await `client.connected()`.\\n        All code below that statement is executed after the websocket connection between server and client has been established.\\n\\n        For example, this allows you to run JavaScript commands; which is only possible with a client connection (see [#112](https://github.com/zauberzeug/nicegui/issues/112)).\\n        Also it is possible to do async stuff while the user already sees some content.\\n    ')\n    def wait_for_connected_demo():\n        import asyncio\n        from nicegui import Client\n\n        @ui.page('/wait_for_connection')\n        async def wait_for_connection(client: Client):\n            ui.label('This text is displayed immediately.')\n            await client.connected()\n            await asyncio.sleep(2)\n            ui.label('This text is displayed 2 seconds after the page has been fully loaded.')\n            ui.label(f'The IP address {client.ip} was obtained from the websocket.')\n        ui.link('wait for connection', wait_for_connection)\n\n    @text_demo('Modularize with APIRouter', \"\\n        You can use the NiceGUI specialization of\\n        [FastAPI's APIRouter](https://fastapi.tiangolo.com/tutorial/bigger-applications/?h=apirouter#apirouter)\\n        to modularize your code by grouping pages and other routes together.\\n        This is especially useful if you want to reuse the same prefix for multiple pages.\\n        The router and its pages can be neatly tugged away in a separate module (e.g. file) and\\n        the router is simply imported and included in the main app.\\n        See our [modularization example](https://github.com/zauberzeug/nicegui/blob/main/examples/modularization/example_c.py)\\n        for a multi-file app structure.\\n    \", tab='/sub-path')\n    def api_router_demo():\n        ui.label('Shows up on /sub-path')"
        ]
    }
]