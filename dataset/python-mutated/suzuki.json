[
    {
        "func_name": "__init__",
        "original": "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/opflow_migration.')\ndef __init__(self, reps: int=1, order: int=2) -> None:\n    \"\"\"\n        Args:\n            reps: The number of times to repeat the expansion circuit.\n            order: The order of the expansion to perform.\n\n        \"\"\"\n    super().__init__(reps=reps)\n    self._order = order",
        "mutated": [
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/opflow_migration.')\ndef __init__(self, reps: int=1, order: int=2) -> None:\n    if False:\n        i = 10\n    '\\n        Args:\\n            reps: The number of times to repeat the expansion circuit.\\n            order: The order of the expansion to perform.\\n\\n        '\n    super().__init__(reps=reps)\n    self._order = order",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/opflow_migration.')\ndef __init__(self, reps: int=1, order: int=2) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Args:\\n            reps: The number of times to repeat the expansion circuit.\\n            order: The order of the expansion to perform.\\n\\n        '\n    super().__init__(reps=reps)\n    self._order = order",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/opflow_migration.')\ndef __init__(self, reps: int=1, order: int=2) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Args:\\n            reps: The number of times to repeat the expansion circuit.\\n            order: The order of the expansion to perform.\\n\\n        '\n    super().__init__(reps=reps)\n    self._order = order",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/opflow_migration.')\ndef __init__(self, reps: int=1, order: int=2) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Args:\\n            reps: The number of times to repeat the expansion circuit.\\n            order: The order of the expansion to perform.\\n\\n        '\n    super().__init__(reps=reps)\n    self._order = order",
            "@deprecate_func(since='0.24.0', package_name='qiskit-terra', additional_msg='For code migration guidelines, visit https://qisk.it/opflow_migration.')\ndef __init__(self, reps: int=1, order: int=2) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Args:\\n            reps: The number of times to repeat the expansion circuit.\\n            order: The order of the expansion to perform.\\n\\n        '\n    super().__init__(reps=reps)\n    self._order = order"
        ]
    },
    {
        "func_name": "order",
        "original": "@property\ndef order(self) -> int:\n    \"\"\"returns order\"\"\"\n    return self._order",
        "mutated": [
            "@property\ndef order(self) -> int:\n    if False:\n        i = 10\n    'returns order'\n    return self._order",
            "@property\ndef order(self) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'returns order'\n    return self._order",
            "@property\ndef order(self) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'returns order'\n    return self._order",
            "@property\ndef order(self) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'returns order'\n    return self._order",
            "@property\ndef order(self) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'returns order'\n    return self._order"
        ]
    },
    {
        "func_name": "order",
        "original": "@order.setter\ndef order(self, order: int) -> None:\n    \"\"\"sets order\"\"\"\n    self._order = order",
        "mutated": [
            "@order.setter\ndef order(self, order: int) -> None:\n    if False:\n        i = 10\n    'sets order'\n    self._order = order",
            "@order.setter\ndef order(self, order: int) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'sets order'\n    self._order = order",
            "@order.setter\ndef order(self, order: int) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'sets order'\n    self._order = order",
            "@order.setter\ndef order(self, order: int) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'sets order'\n    self._order = order",
            "@order.setter\ndef order(self, order: int) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'sets order'\n    self._order = order"
        ]
    },
    {
        "func_name": "convert",
        "original": "def convert(self, operator: OperatorBase) -> OperatorBase:\n    if not isinstance(operator, (SummedOp, PauliSumOp)):\n        raise TypeError('Trotterization converters can only convert SummedOp or PauliSumOp.')\n    if isinstance(operator.coeff, (float, ParameterExpression)):\n        coeff = operator.coeff\n    elif isreal(operator.coeff):\n        coeff = operator.coeff.real\n    else:\n        raise TypeError(f'Coefficient of the operator must be float or ParameterExpression, but {operator.coeff}:{type(operator.coeff)} is given.')\n    if isinstance(operator, PauliSumOp):\n        comp_list = self._recursive_expansion(operator, coeff, self.order, self.reps)\n    if isinstance(operator, SummedOp):\n        comp_list = Suzuki._recursive_expansion(operator.oplist, coeff, self.order, self.reps)\n    single_rep = ComposedOp(cast(List[OperatorBase], comp_list))\n    full_evo = single_rep.power(self.reps)\n    return full_evo.reduce()",
        "mutated": [
            "def convert(self, operator: OperatorBase) -> OperatorBase:\n    if False:\n        i = 10\n    if not isinstance(operator, (SummedOp, PauliSumOp)):\n        raise TypeError('Trotterization converters can only convert SummedOp or PauliSumOp.')\n    if isinstance(operator.coeff, (float, ParameterExpression)):\n        coeff = operator.coeff\n    elif isreal(operator.coeff):\n        coeff = operator.coeff.real\n    else:\n        raise TypeError(f'Coefficient of the operator must be float or ParameterExpression, but {operator.coeff}:{type(operator.coeff)} is given.')\n    if isinstance(operator, PauliSumOp):\n        comp_list = self._recursive_expansion(operator, coeff, self.order, self.reps)\n    if isinstance(operator, SummedOp):\n        comp_list = Suzuki._recursive_expansion(operator.oplist, coeff, self.order, self.reps)\n    single_rep = ComposedOp(cast(List[OperatorBase], comp_list))\n    full_evo = single_rep.power(self.reps)\n    return full_evo.reduce()",
            "def convert(self, operator: OperatorBase) -> OperatorBase:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not isinstance(operator, (SummedOp, PauliSumOp)):\n        raise TypeError('Trotterization converters can only convert SummedOp or PauliSumOp.')\n    if isinstance(operator.coeff, (float, ParameterExpression)):\n        coeff = operator.coeff\n    elif isreal(operator.coeff):\n        coeff = operator.coeff.real\n    else:\n        raise TypeError(f'Coefficient of the operator must be float or ParameterExpression, but {operator.coeff}:{type(operator.coeff)} is given.')\n    if isinstance(operator, PauliSumOp):\n        comp_list = self._recursive_expansion(operator, coeff, self.order, self.reps)\n    if isinstance(operator, SummedOp):\n        comp_list = Suzuki._recursive_expansion(operator.oplist, coeff, self.order, self.reps)\n    single_rep = ComposedOp(cast(List[OperatorBase], comp_list))\n    full_evo = single_rep.power(self.reps)\n    return full_evo.reduce()",
            "def convert(self, operator: OperatorBase) -> OperatorBase:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not isinstance(operator, (SummedOp, PauliSumOp)):\n        raise TypeError('Trotterization converters can only convert SummedOp or PauliSumOp.')\n    if isinstance(operator.coeff, (float, ParameterExpression)):\n        coeff = operator.coeff\n    elif isreal(operator.coeff):\n        coeff = operator.coeff.real\n    else:\n        raise TypeError(f'Coefficient of the operator must be float or ParameterExpression, but {operator.coeff}:{type(operator.coeff)} is given.')\n    if isinstance(operator, PauliSumOp):\n        comp_list = self._recursive_expansion(operator, coeff, self.order, self.reps)\n    if isinstance(operator, SummedOp):\n        comp_list = Suzuki._recursive_expansion(operator.oplist, coeff, self.order, self.reps)\n    single_rep = ComposedOp(cast(List[OperatorBase], comp_list))\n    full_evo = single_rep.power(self.reps)\n    return full_evo.reduce()",
            "def convert(self, operator: OperatorBase) -> OperatorBase:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not isinstance(operator, (SummedOp, PauliSumOp)):\n        raise TypeError('Trotterization converters can only convert SummedOp or PauliSumOp.')\n    if isinstance(operator.coeff, (float, ParameterExpression)):\n        coeff = operator.coeff\n    elif isreal(operator.coeff):\n        coeff = operator.coeff.real\n    else:\n        raise TypeError(f'Coefficient of the operator must be float or ParameterExpression, but {operator.coeff}:{type(operator.coeff)} is given.')\n    if isinstance(operator, PauliSumOp):\n        comp_list = self._recursive_expansion(operator, coeff, self.order, self.reps)\n    if isinstance(operator, SummedOp):\n        comp_list = Suzuki._recursive_expansion(operator.oplist, coeff, self.order, self.reps)\n    single_rep = ComposedOp(cast(List[OperatorBase], comp_list))\n    full_evo = single_rep.power(self.reps)\n    return full_evo.reduce()",
            "def convert(self, operator: OperatorBase) -> OperatorBase:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not isinstance(operator, (SummedOp, PauliSumOp)):\n        raise TypeError('Trotterization converters can only convert SummedOp or PauliSumOp.')\n    if isinstance(operator.coeff, (float, ParameterExpression)):\n        coeff = operator.coeff\n    elif isreal(operator.coeff):\n        coeff = operator.coeff.real\n    else:\n        raise TypeError(f'Coefficient of the operator must be float or ParameterExpression, but {operator.coeff}:{type(operator.coeff)} is given.')\n    if isinstance(operator, PauliSumOp):\n        comp_list = self._recursive_expansion(operator, coeff, self.order, self.reps)\n    if isinstance(operator, SummedOp):\n        comp_list = Suzuki._recursive_expansion(operator.oplist, coeff, self.order, self.reps)\n    single_rep = ComposedOp(cast(List[OperatorBase], comp_list))\n    full_evo = single_rep.power(self.reps)\n    return full_evo.reduce()"
        ]
    },
    {
        "func_name": "_recursive_expansion",
        "original": "@staticmethod\ndef _recursive_expansion(op_list: Union[List[OperatorBase], PauliSumOp], evo_time: Union[float, ParameterExpression], expansion_order: int, reps: int) -> List[PrimitiveOp]:\n    \"\"\"\n        Compute the list of pauli terms for a single slice of the Suzuki expansion\n        following the paper https://arxiv.org/pdf/quant-ph/0508139.pdf.\n\n        Args:\n            op_list: The slice's weighted Pauli list for the Suzuki expansion\n            evo_time: The parameter lambda as defined in said paper,\n                adjusted for the evolution time and the number of time slices\n            expansion_order: The order for the Suzuki expansion.\n            reps: The number of times to repeat the expansion circuit.\n\n        Returns:\n            The evolution list after expansion.\n        \"\"\"\n    if expansion_order == 1:\n        return [(op * (evo_time / reps)).exp_i() for op in op_list]\n    if expansion_order == 2:\n        half = Suzuki._recursive_expansion(op_list, evo_time / 2, expansion_order - 1, reps)\n        return list(reversed(half)) + half\n    else:\n        p_k = (4 - 4 ** (1 / (2 * expansion_order - 1))) ** (-1)\n        side = 2 * Suzuki._recursive_expansion(op_list, evo_time * p_k, expansion_order - 2, reps)\n        middle = Suzuki._recursive_expansion(op_list, evo_time * (1 - 4 * p_k), expansion_order - 2, reps)\n        return side + middle + side",
        "mutated": [
            "@staticmethod\ndef _recursive_expansion(op_list: Union[List[OperatorBase], PauliSumOp], evo_time: Union[float, ParameterExpression], expansion_order: int, reps: int) -> List[PrimitiveOp]:\n    if False:\n        i = 10\n    \"\\n        Compute the list of pauli terms for a single slice of the Suzuki expansion\\n        following the paper https://arxiv.org/pdf/quant-ph/0508139.pdf.\\n\\n        Args:\\n            op_list: The slice's weighted Pauli list for the Suzuki expansion\\n            evo_time: The parameter lambda as defined in said paper,\\n                adjusted for the evolution time and the number of time slices\\n            expansion_order: The order for the Suzuki expansion.\\n            reps: The number of times to repeat the expansion circuit.\\n\\n        Returns:\\n            The evolution list after expansion.\\n        \"\n    if expansion_order == 1:\n        return [(op * (evo_time / reps)).exp_i() for op in op_list]\n    if expansion_order == 2:\n        half = Suzuki._recursive_expansion(op_list, evo_time / 2, expansion_order - 1, reps)\n        return list(reversed(half)) + half\n    else:\n        p_k = (4 - 4 ** (1 / (2 * expansion_order - 1))) ** (-1)\n        side = 2 * Suzuki._recursive_expansion(op_list, evo_time * p_k, expansion_order - 2, reps)\n        middle = Suzuki._recursive_expansion(op_list, evo_time * (1 - 4 * p_k), expansion_order - 2, reps)\n        return side + middle + side",
            "@staticmethod\ndef _recursive_expansion(op_list: Union[List[OperatorBase], PauliSumOp], evo_time: Union[float, ParameterExpression], expansion_order: int, reps: int) -> List[PrimitiveOp]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Compute the list of pauli terms for a single slice of the Suzuki expansion\\n        following the paper https://arxiv.org/pdf/quant-ph/0508139.pdf.\\n\\n        Args:\\n            op_list: The slice's weighted Pauli list for the Suzuki expansion\\n            evo_time: The parameter lambda as defined in said paper,\\n                adjusted for the evolution time and the number of time slices\\n            expansion_order: The order for the Suzuki expansion.\\n            reps: The number of times to repeat the expansion circuit.\\n\\n        Returns:\\n            The evolution list after expansion.\\n        \"\n    if expansion_order == 1:\n        return [(op * (evo_time / reps)).exp_i() for op in op_list]\n    if expansion_order == 2:\n        half = Suzuki._recursive_expansion(op_list, evo_time / 2, expansion_order - 1, reps)\n        return list(reversed(half)) + half\n    else:\n        p_k = (4 - 4 ** (1 / (2 * expansion_order - 1))) ** (-1)\n        side = 2 * Suzuki._recursive_expansion(op_list, evo_time * p_k, expansion_order - 2, reps)\n        middle = Suzuki._recursive_expansion(op_list, evo_time * (1 - 4 * p_k), expansion_order - 2, reps)\n        return side + middle + side",
            "@staticmethod\ndef _recursive_expansion(op_list: Union[List[OperatorBase], PauliSumOp], evo_time: Union[float, ParameterExpression], expansion_order: int, reps: int) -> List[PrimitiveOp]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Compute the list of pauli terms for a single slice of the Suzuki expansion\\n        following the paper https://arxiv.org/pdf/quant-ph/0508139.pdf.\\n\\n        Args:\\n            op_list: The slice's weighted Pauli list for the Suzuki expansion\\n            evo_time: The parameter lambda as defined in said paper,\\n                adjusted for the evolution time and the number of time slices\\n            expansion_order: The order for the Suzuki expansion.\\n            reps: The number of times to repeat the expansion circuit.\\n\\n        Returns:\\n            The evolution list after expansion.\\n        \"\n    if expansion_order == 1:\n        return [(op * (evo_time / reps)).exp_i() for op in op_list]\n    if expansion_order == 2:\n        half = Suzuki._recursive_expansion(op_list, evo_time / 2, expansion_order - 1, reps)\n        return list(reversed(half)) + half\n    else:\n        p_k = (4 - 4 ** (1 / (2 * expansion_order - 1))) ** (-1)\n        side = 2 * Suzuki._recursive_expansion(op_list, evo_time * p_k, expansion_order - 2, reps)\n        middle = Suzuki._recursive_expansion(op_list, evo_time * (1 - 4 * p_k), expansion_order - 2, reps)\n        return side + middle + side",
            "@staticmethod\ndef _recursive_expansion(op_list: Union[List[OperatorBase], PauliSumOp], evo_time: Union[float, ParameterExpression], expansion_order: int, reps: int) -> List[PrimitiveOp]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Compute the list of pauli terms for a single slice of the Suzuki expansion\\n        following the paper https://arxiv.org/pdf/quant-ph/0508139.pdf.\\n\\n        Args:\\n            op_list: The slice's weighted Pauli list for the Suzuki expansion\\n            evo_time: The parameter lambda as defined in said paper,\\n                adjusted for the evolution time and the number of time slices\\n            expansion_order: The order for the Suzuki expansion.\\n            reps: The number of times to repeat the expansion circuit.\\n\\n        Returns:\\n            The evolution list after expansion.\\n        \"\n    if expansion_order == 1:\n        return [(op * (evo_time / reps)).exp_i() for op in op_list]\n    if expansion_order == 2:\n        half = Suzuki._recursive_expansion(op_list, evo_time / 2, expansion_order - 1, reps)\n        return list(reversed(half)) + half\n    else:\n        p_k = (4 - 4 ** (1 / (2 * expansion_order - 1))) ** (-1)\n        side = 2 * Suzuki._recursive_expansion(op_list, evo_time * p_k, expansion_order - 2, reps)\n        middle = Suzuki._recursive_expansion(op_list, evo_time * (1 - 4 * p_k), expansion_order - 2, reps)\n        return side + middle + side",
            "@staticmethod\ndef _recursive_expansion(op_list: Union[List[OperatorBase], PauliSumOp], evo_time: Union[float, ParameterExpression], expansion_order: int, reps: int) -> List[PrimitiveOp]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Compute the list of pauli terms for a single slice of the Suzuki expansion\\n        following the paper https://arxiv.org/pdf/quant-ph/0508139.pdf.\\n\\n        Args:\\n            op_list: The slice's weighted Pauli list for the Suzuki expansion\\n            evo_time: The parameter lambda as defined in said paper,\\n                adjusted for the evolution time and the number of time slices\\n            expansion_order: The order for the Suzuki expansion.\\n            reps: The number of times to repeat the expansion circuit.\\n\\n        Returns:\\n            The evolution list after expansion.\\n        \"\n    if expansion_order == 1:\n        return [(op * (evo_time / reps)).exp_i() for op in op_list]\n    if expansion_order == 2:\n        half = Suzuki._recursive_expansion(op_list, evo_time / 2, expansion_order - 1, reps)\n        return list(reversed(half)) + half\n    else:\n        p_k = (4 - 4 ** (1 / (2 * expansion_order - 1))) ** (-1)\n        side = 2 * Suzuki._recursive_expansion(op_list, evo_time * p_k, expansion_order - 2, reps)\n        middle = Suzuki._recursive_expansion(op_list, evo_time * (1 - 4 * p_k), expansion_order - 2, reps)\n        return side + middle + side"
        ]
    }
]