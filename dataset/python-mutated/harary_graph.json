[
    {
        "func_name": "hnm_harary_graph",
        "original": "@nx._dispatch(graphs=None)\ndef hnm_harary_graph(n, m, create_using=None):\n    \"\"\"Returns the Harary graph with given numbers of nodes and edges.\n\n    The Harary graph $H_{n,m}$ is the graph that maximizes node connectivity\n    with $n$ nodes and $m$ edges.\n\n    This maximum node connectivity is known to be floor($2m/n$). [1]_\n\n    Parameters\n    ----------\n    n: integer\n       The number of nodes the generated graph is to contain\n\n    m: integer\n       The number of edges the generated graph is to contain\n\n    create_using : NetworkX graph constructor, optional Graph type\n     to create (default=nx.Graph). If graph instance, then cleared\n     before populated.\n\n    Returns\n    -------\n    NetworkX graph\n        The Harary graph $H_{n,m}$.\n\n    See Also\n    --------\n    hkn_harary_graph\n\n    Notes\n    -----\n    This algorithm runs in $O(m)$ time.\n    It is implemented by following the Reference [2]_.\n\n    References\n    ----------\n    .. [1] F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\n       \"A Survey of Some Network Reliability Analysis and Synthesis Results,\"\n       Networks, pp. 99-107, 2009.\n\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\n       Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\n    \"\"\"\n    if n < 1:\n        raise NetworkXError('The number of nodes must be >= 1!')\n    if m < n - 1:\n        raise NetworkXError('The number of edges must be >= n - 1 !')\n    if m > n * (n - 1) // 2:\n        raise NetworkXError('The number of edges must be <= n(n-1)/2')\n    H = nx.empty_graph(n, create_using)\n    d = 2 * m // n\n    if n % 2 == 0 or d % 2 == 0:\n        offset = d // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if d & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n        r = 2 * m % n\n        if r > 0:\n            for i in range(r // 2):\n                H.add_edge(i, i + offset + 1)\n    else:\n        offset = (d - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(m - n * offset):\n            H.add_edge(i, (i + half) % n)\n    return H",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef hnm_harary_graph(n, m, create_using=None):\n    if False:\n        i = 10\n    'Returns the Harary graph with given numbers of nodes and edges.\\n\\n    The Harary graph $H_{n,m}$ is the graph that maximizes node connectivity\\n    with $n$ nodes and $m$ edges.\\n\\n    This maximum node connectivity is known to be floor($2m/n$). [1]_\\n\\n    Parameters\\n    ----------\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    m: integer\\n       The number of edges the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{n,m}$.\\n\\n    See Also\\n    --------\\n    hkn_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(m)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\\n       \"A Survey of Some Network Reliability Analysis and Synthesis Results,\"\\n       Networks, pp. 99-107, 2009.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n       Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if n < 1:\n        raise NetworkXError('The number of nodes must be >= 1!')\n    if m < n - 1:\n        raise NetworkXError('The number of edges must be >= n - 1 !')\n    if m > n * (n - 1) // 2:\n        raise NetworkXError('The number of edges must be <= n(n-1)/2')\n    H = nx.empty_graph(n, create_using)\n    d = 2 * m // n\n    if n % 2 == 0 or d % 2 == 0:\n        offset = d // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if d & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n        r = 2 * m % n\n        if r > 0:\n            for i in range(r // 2):\n                H.add_edge(i, i + offset + 1)\n    else:\n        offset = (d - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(m - n * offset):\n            H.add_edge(i, (i + half) % n)\n    return H",
            "@nx._dispatch(graphs=None)\ndef hnm_harary_graph(n, m, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the Harary graph with given numbers of nodes and edges.\\n\\n    The Harary graph $H_{n,m}$ is the graph that maximizes node connectivity\\n    with $n$ nodes and $m$ edges.\\n\\n    This maximum node connectivity is known to be floor($2m/n$). [1]_\\n\\n    Parameters\\n    ----------\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    m: integer\\n       The number of edges the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{n,m}$.\\n\\n    See Also\\n    --------\\n    hkn_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(m)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\\n       \"A Survey of Some Network Reliability Analysis and Synthesis Results,\"\\n       Networks, pp. 99-107, 2009.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n       Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if n < 1:\n        raise NetworkXError('The number of nodes must be >= 1!')\n    if m < n - 1:\n        raise NetworkXError('The number of edges must be >= n - 1 !')\n    if m > n * (n - 1) // 2:\n        raise NetworkXError('The number of edges must be <= n(n-1)/2')\n    H = nx.empty_graph(n, create_using)\n    d = 2 * m // n\n    if n % 2 == 0 or d % 2 == 0:\n        offset = d // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if d & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n        r = 2 * m % n\n        if r > 0:\n            for i in range(r // 2):\n                H.add_edge(i, i + offset + 1)\n    else:\n        offset = (d - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(m - n * offset):\n            H.add_edge(i, (i + half) % n)\n    return H",
            "@nx._dispatch(graphs=None)\ndef hnm_harary_graph(n, m, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the Harary graph with given numbers of nodes and edges.\\n\\n    The Harary graph $H_{n,m}$ is the graph that maximizes node connectivity\\n    with $n$ nodes and $m$ edges.\\n\\n    This maximum node connectivity is known to be floor($2m/n$). [1]_\\n\\n    Parameters\\n    ----------\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    m: integer\\n       The number of edges the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{n,m}$.\\n\\n    See Also\\n    --------\\n    hkn_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(m)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\\n       \"A Survey of Some Network Reliability Analysis and Synthesis Results,\"\\n       Networks, pp. 99-107, 2009.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n       Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if n < 1:\n        raise NetworkXError('The number of nodes must be >= 1!')\n    if m < n - 1:\n        raise NetworkXError('The number of edges must be >= n - 1 !')\n    if m > n * (n - 1) // 2:\n        raise NetworkXError('The number of edges must be <= n(n-1)/2')\n    H = nx.empty_graph(n, create_using)\n    d = 2 * m // n\n    if n % 2 == 0 or d % 2 == 0:\n        offset = d // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if d & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n        r = 2 * m % n\n        if r > 0:\n            for i in range(r // 2):\n                H.add_edge(i, i + offset + 1)\n    else:\n        offset = (d - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(m - n * offset):\n            H.add_edge(i, (i + half) % n)\n    return H",
            "@nx._dispatch(graphs=None)\ndef hnm_harary_graph(n, m, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the Harary graph with given numbers of nodes and edges.\\n\\n    The Harary graph $H_{n,m}$ is the graph that maximizes node connectivity\\n    with $n$ nodes and $m$ edges.\\n\\n    This maximum node connectivity is known to be floor($2m/n$). [1]_\\n\\n    Parameters\\n    ----------\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    m: integer\\n       The number of edges the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{n,m}$.\\n\\n    See Also\\n    --------\\n    hkn_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(m)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\\n       \"A Survey of Some Network Reliability Analysis and Synthesis Results,\"\\n       Networks, pp. 99-107, 2009.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n       Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if n < 1:\n        raise NetworkXError('The number of nodes must be >= 1!')\n    if m < n - 1:\n        raise NetworkXError('The number of edges must be >= n - 1 !')\n    if m > n * (n - 1) // 2:\n        raise NetworkXError('The number of edges must be <= n(n-1)/2')\n    H = nx.empty_graph(n, create_using)\n    d = 2 * m // n\n    if n % 2 == 0 or d % 2 == 0:\n        offset = d // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if d & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n        r = 2 * m % n\n        if r > 0:\n            for i in range(r // 2):\n                H.add_edge(i, i + offset + 1)\n    else:\n        offset = (d - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(m - n * offset):\n            H.add_edge(i, (i + half) % n)\n    return H",
            "@nx._dispatch(graphs=None)\ndef hnm_harary_graph(n, m, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the Harary graph with given numbers of nodes and edges.\\n\\n    The Harary graph $H_{n,m}$ is the graph that maximizes node connectivity\\n    with $n$ nodes and $m$ edges.\\n\\n    This maximum node connectivity is known to be floor($2m/n$). [1]_\\n\\n    Parameters\\n    ----------\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    m: integer\\n       The number of edges the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{n,m}$.\\n\\n    See Also\\n    --------\\n    hkn_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(m)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\\n       \"A Survey of Some Network Reliability Analysis and Synthesis Results,\"\\n       Networks, pp. 99-107, 2009.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n       Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if n < 1:\n        raise NetworkXError('The number of nodes must be >= 1!')\n    if m < n - 1:\n        raise NetworkXError('The number of edges must be >= n - 1 !')\n    if m > n * (n - 1) // 2:\n        raise NetworkXError('The number of edges must be <= n(n-1)/2')\n    H = nx.empty_graph(n, create_using)\n    d = 2 * m // n\n    if n % 2 == 0 or d % 2 == 0:\n        offset = d // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if d & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n        r = 2 * m % n\n        if r > 0:\n            for i in range(r // 2):\n                H.add_edge(i, i + offset + 1)\n    else:\n        offset = (d - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(m - n * offset):\n            H.add_edge(i, (i + half) % n)\n    return H"
        ]
    },
    {
        "func_name": "hkn_harary_graph",
        "original": "@nx._dispatch(graphs=None)\ndef hkn_harary_graph(k, n, create_using=None):\n    \"\"\"Returns the Harary graph with given node connectivity and node number.\n\n    The Harary graph $H_{k,n}$ is the graph that minimizes the number of\n    edges needed with given node connectivity $k$ and node number $n$.\n\n    This smallest number of edges is known to be ceil($kn/2$) [1]_.\n\n    Parameters\n    ----------\n    k: integer\n       The node connectivity of the generated graph\n\n    n: integer\n       The number of nodes the generated graph is to contain\n\n    create_using : NetworkX graph constructor, optional Graph type\n     to create (default=nx.Graph). If graph instance, then cleared\n     before populated.\n\n    Returns\n    -------\n    NetworkX graph\n        The Harary graph $H_{k,n}$.\n\n    See Also\n    --------\n    hnm_harary_graph\n\n    Notes\n    -----\n    This algorithm runs in $O(kn)$ time.\n    It is implemented by following the Reference [2]_.\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Harary Graph.\" From MathWorld--A Wolfram Web\n     Resource. http://mathworld.wolfram.com/HararyGraph.html.\n\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\n      Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\n    \"\"\"\n    if k < 1:\n        raise NetworkXError('The node connectivity must be >= 1!')\n    if n < k + 1:\n        raise NetworkXError('The number of nodes must be >= k+1 !')\n    if k == 1:\n        H = nx.path_graph(n, create_using)\n        return H\n    H = nx.empty_graph(n, create_using)\n    if k % 2 == 0 or n % 2 == 0:\n        offset = k // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if k & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n    else:\n        offset = (k - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(half + 1):\n            H.add_edge(i, (i + half) % n)\n    return H",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef hkn_harary_graph(k, n, create_using=None):\n    if False:\n        i = 10\n    'Returns the Harary graph with given node connectivity and node number.\\n\\n    The Harary graph $H_{k,n}$ is the graph that minimizes the number of\\n    edges needed with given node connectivity $k$ and node number $n$.\\n\\n    This smallest number of edges is known to be ceil($kn/2$) [1]_.\\n\\n    Parameters\\n    ----------\\n    k: integer\\n       The node connectivity of the generated graph\\n\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{k,n}$.\\n\\n    See Also\\n    --------\\n    hnm_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(kn)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Weisstein, Eric W. \"Harary Graph.\" From MathWorld--A Wolfram Web\\n     Resource. http://mathworld.wolfram.com/HararyGraph.html.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n      Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if k < 1:\n        raise NetworkXError('The node connectivity must be >= 1!')\n    if n < k + 1:\n        raise NetworkXError('The number of nodes must be >= k+1 !')\n    if k == 1:\n        H = nx.path_graph(n, create_using)\n        return H\n    H = nx.empty_graph(n, create_using)\n    if k % 2 == 0 or n % 2 == 0:\n        offset = k // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if k & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n    else:\n        offset = (k - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(half + 1):\n            H.add_edge(i, (i + half) % n)\n    return H",
            "@nx._dispatch(graphs=None)\ndef hkn_harary_graph(k, n, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the Harary graph with given node connectivity and node number.\\n\\n    The Harary graph $H_{k,n}$ is the graph that minimizes the number of\\n    edges needed with given node connectivity $k$ and node number $n$.\\n\\n    This smallest number of edges is known to be ceil($kn/2$) [1]_.\\n\\n    Parameters\\n    ----------\\n    k: integer\\n       The node connectivity of the generated graph\\n\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{k,n}$.\\n\\n    See Also\\n    --------\\n    hnm_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(kn)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Weisstein, Eric W. \"Harary Graph.\" From MathWorld--A Wolfram Web\\n     Resource. http://mathworld.wolfram.com/HararyGraph.html.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n      Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if k < 1:\n        raise NetworkXError('The node connectivity must be >= 1!')\n    if n < k + 1:\n        raise NetworkXError('The number of nodes must be >= k+1 !')\n    if k == 1:\n        H = nx.path_graph(n, create_using)\n        return H\n    H = nx.empty_graph(n, create_using)\n    if k % 2 == 0 or n % 2 == 0:\n        offset = k // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if k & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n    else:\n        offset = (k - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(half + 1):\n            H.add_edge(i, (i + half) % n)\n    return H",
            "@nx._dispatch(graphs=None)\ndef hkn_harary_graph(k, n, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the Harary graph with given node connectivity and node number.\\n\\n    The Harary graph $H_{k,n}$ is the graph that minimizes the number of\\n    edges needed with given node connectivity $k$ and node number $n$.\\n\\n    This smallest number of edges is known to be ceil($kn/2$) [1]_.\\n\\n    Parameters\\n    ----------\\n    k: integer\\n       The node connectivity of the generated graph\\n\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{k,n}$.\\n\\n    See Also\\n    --------\\n    hnm_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(kn)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Weisstein, Eric W. \"Harary Graph.\" From MathWorld--A Wolfram Web\\n     Resource. http://mathworld.wolfram.com/HararyGraph.html.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n      Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if k < 1:\n        raise NetworkXError('The node connectivity must be >= 1!')\n    if n < k + 1:\n        raise NetworkXError('The number of nodes must be >= k+1 !')\n    if k == 1:\n        H = nx.path_graph(n, create_using)\n        return H\n    H = nx.empty_graph(n, create_using)\n    if k % 2 == 0 or n % 2 == 0:\n        offset = k // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if k & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n    else:\n        offset = (k - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(half + 1):\n            H.add_edge(i, (i + half) % n)\n    return H",
            "@nx._dispatch(graphs=None)\ndef hkn_harary_graph(k, n, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the Harary graph with given node connectivity and node number.\\n\\n    The Harary graph $H_{k,n}$ is the graph that minimizes the number of\\n    edges needed with given node connectivity $k$ and node number $n$.\\n\\n    This smallest number of edges is known to be ceil($kn/2$) [1]_.\\n\\n    Parameters\\n    ----------\\n    k: integer\\n       The node connectivity of the generated graph\\n\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{k,n}$.\\n\\n    See Also\\n    --------\\n    hnm_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(kn)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Weisstein, Eric W. \"Harary Graph.\" From MathWorld--A Wolfram Web\\n     Resource. http://mathworld.wolfram.com/HararyGraph.html.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n      Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if k < 1:\n        raise NetworkXError('The node connectivity must be >= 1!')\n    if n < k + 1:\n        raise NetworkXError('The number of nodes must be >= k+1 !')\n    if k == 1:\n        H = nx.path_graph(n, create_using)\n        return H\n    H = nx.empty_graph(n, create_using)\n    if k % 2 == 0 or n % 2 == 0:\n        offset = k // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if k & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n    else:\n        offset = (k - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(half + 1):\n            H.add_edge(i, (i + half) % n)\n    return H",
            "@nx._dispatch(graphs=None)\ndef hkn_harary_graph(k, n, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the Harary graph with given node connectivity and node number.\\n\\n    The Harary graph $H_{k,n}$ is the graph that minimizes the number of\\n    edges needed with given node connectivity $k$ and node number $n$.\\n\\n    This smallest number of edges is known to be ceil($kn/2$) [1]_.\\n\\n    Parameters\\n    ----------\\n    k: integer\\n       The node connectivity of the generated graph\\n\\n    n: integer\\n       The number of nodes the generated graph is to contain\\n\\n    create_using : NetworkX graph constructor, optional Graph type\\n     to create (default=nx.Graph). If graph instance, then cleared\\n     before populated.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        The Harary graph $H_{k,n}$.\\n\\n    See Also\\n    --------\\n    hnm_harary_graph\\n\\n    Notes\\n    -----\\n    This algorithm runs in $O(kn)$ time.\\n    It is implemented by following the Reference [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Weisstein, Eric W. \"Harary Graph.\" From MathWorld--A Wolfram Web\\n     Resource. http://mathworld.wolfram.com/HararyGraph.html.\\n\\n    .. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\\n      Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.\\n    '\n    if k < 1:\n        raise NetworkXError('The node connectivity must be >= 1!')\n    if n < k + 1:\n        raise NetworkXError('The number of nodes must be >= k+1 !')\n    if k == 1:\n        H = nx.path_graph(n, create_using)\n        return H\n    H = nx.empty_graph(n, create_using)\n    if k % 2 == 0 or n % 2 == 0:\n        offset = k // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if k & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n    else:\n        offset = (k - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(half + 1):\n            H.add_edge(i, (i + half) % n)\n    return H"
        ]
    }
]