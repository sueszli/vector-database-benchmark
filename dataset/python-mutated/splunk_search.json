[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Only load this module if splunk is installed on this minion.\n    \"\"\"\n    if HAS_LIBS:\n        return __virtualname__\n    return (False, 'The splunk_search execution module failed to load: requires both the requests and the splunk-sdk python library to be installed.')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Only load this module if splunk is installed on this minion.\\n    '\n    if HAS_LIBS:\n        return __virtualname__\n    return (False, 'The splunk_search execution module failed to load: requires both the requests and the splunk-sdk python library to be installed.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Only load this module if splunk is installed on this minion.\\n    '\n    if HAS_LIBS:\n        return __virtualname__\n    return (False, 'The splunk_search execution module failed to load: requires both the requests and the splunk-sdk python library to be installed.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Only load this module if splunk is installed on this minion.\\n    '\n    if HAS_LIBS:\n        return __virtualname__\n    return (False, 'The splunk_search execution module failed to load: requires both the requests and the splunk-sdk python library to be installed.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Only load this module if splunk is installed on this minion.\\n    '\n    if HAS_LIBS:\n        return __virtualname__\n    return (False, 'The splunk_search execution module failed to load: requires both the requests and the splunk-sdk python library to be installed.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Only load this module if splunk is installed on this minion.\\n    '\n    if HAS_LIBS:\n        return __virtualname__\n    return (False, 'The splunk_search execution module failed to load: requires both the requests and the splunk-sdk python library to be installed.')"
        ]
    },
    {
        "func_name": "_get_splunk",
        "original": "def _get_splunk(profile):\n    \"\"\"\n    Return the splunk client, cached into __context__ for performance\n    \"\"\"\n    config = __salt__['config.option'](profile)\n    key = 'splunk_search.{}:{}:{}:{}'.format(config.get('host'), config.get('port'), config.get('username'), config.get('password'))\n    if key not in __context__:\n        __context__[key] = splunklib.client.connect(host=config.get('host'), port=config.get('port'), username=config.get('username'), password=config.get('password'))\n    return __context__[key]",
        "mutated": [
            "def _get_splunk(profile):\n    if False:\n        i = 10\n    '\\n    Return the splunk client, cached into __context__ for performance\\n    '\n    config = __salt__['config.option'](profile)\n    key = 'splunk_search.{}:{}:{}:{}'.format(config.get('host'), config.get('port'), config.get('username'), config.get('password'))\n    if key not in __context__:\n        __context__[key] = splunklib.client.connect(host=config.get('host'), port=config.get('port'), username=config.get('username'), password=config.get('password'))\n    return __context__[key]",
            "def _get_splunk(profile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return the splunk client, cached into __context__ for performance\\n    '\n    config = __salt__['config.option'](profile)\n    key = 'splunk_search.{}:{}:{}:{}'.format(config.get('host'), config.get('port'), config.get('username'), config.get('password'))\n    if key not in __context__:\n        __context__[key] = splunklib.client.connect(host=config.get('host'), port=config.get('port'), username=config.get('username'), password=config.get('password'))\n    return __context__[key]",
            "def _get_splunk(profile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return the splunk client, cached into __context__ for performance\\n    '\n    config = __salt__['config.option'](profile)\n    key = 'splunk_search.{}:{}:{}:{}'.format(config.get('host'), config.get('port'), config.get('username'), config.get('password'))\n    if key not in __context__:\n        __context__[key] = splunklib.client.connect(host=config.get('host'), port=config.get('port'), username=config.get('username'), password=config.get('password'))\n    return __context__[key]",
            "def _get_splunk(profile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return the splunk client, cached into __context__ for performance\\n    '\n    config = __salt__['config.option'](profile)\n    key = 'splunk_search.{}:{}:{}:{}'.format(config.get('host'), config.get('port'), config.get('username'), config.get('password'))\n    if key not in __context__:\n        __context__[key] = splunklib.client.connect(host=config.get('host'), port=config.get('port'), username=config.get('username'), password=config.get('password'))\n    return __context__[key]",
            "def _get_splunk(profile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return the splunk client, cached into __context__ for performance\\n    '\n    config = __salt__['config.option'](profile)\n    key = 'splunk_search.{}:{}:{}:{}'.format(config.get('host'), config.get('port'), config.get('username'), config.get('password'))\n    if key not in __context__:\n        __context__[key] = splunklib.client.connect(host=config.get('host'), port=config.get('port'), username=config.get('username'), password=config.get('password'))\n    return __context__[key]"
        ]
    },
    {
        "func_name": "_get_splunk_search_props",
        "original": "def _get_splunk_search_props(search):\n    \"\"\"\n    Get splunk search properties from an object\n    \"\"\"\n    props = search.content\n    props['app'] = search.access.app\n    props['sharing'] = search.access.sharing\n    return props",
        "mutated": [
            "def _get_splunk_search_props(search):\n    if False:\n        i = 10\n    '\\n    Get splunk search properties from an object\\n    '\n    props = search.content\n    props['app'] = search.access.app\n    props['sharing'] = search.access.sharing\n    return props",
            "def _get_splunk_search_props(search):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get splunk search properties from an object\\n    '\n    props = search.content\n    props['app'] = search.access.app\n    props['sharing'] = search.access.sharing\n    return props",
            "def _get_splunk_search_props(search):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get splunk search properties from an object\\n    '\n    props = search.content\n    props['app'] = search.access.app\n    props['sharing'] = search.access.sharing\n    return props",
            "def _get_splunk_search_props(search):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get splunk search properties from an object\\n    '\n    props = search.content\n    props['app'] = search.access.app\n    props['sharing'] = search.access.sharing\n    return props",
            "def _get_splunk_search_props(search):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get splunk search properties from an object\\n    '\n    props = search.content\n    props['app'] = search.access.app\n    props['sharing'] = search.access.sharing\n    return props"
        ]
    },
    {
        "func_name": "get",
        "original": "def get(name, profile='splunk'):\n    \"\"\"\n    Get a splunk search\n\n    CLI Example:\n\n        splunk_search.get 'my search name'\n    \"\"\"\n    client = _get_splunk(profile)\n    search = None\n    try:\n        search = client.saved_searches[name]\n    except KeyError:\n        pass\n    return search",
        "mutated": [
            "def get(name, profile='splunk'):\n    if False:\n        i = 10\n    \"\\n    Get a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.get 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    search = None\n    try:\n        search = client.saved_searches[name]\n    except KeyError:\n        pass\n    return search",
            "def get(name, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.get 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    search = None\n    try:\n        search = client.saved_searches[name]\n    except KeyError:\n        pass\n    return search",
            "def get(name, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.get 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    search = None\n    try:\n        search = client.saved_searches[name]\n    except KeyError:\n        pass\n    return search",
            "def get(name, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.get 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    search = None\n    try:\n        search = client.saved_searches[name]\n    except KeyError:\n        pass\n    return search",
            "def get(name, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.get 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    search = None\n    try:\n        search = client.saved_searches[name]\n    except KeyError:\n        pass\n    return search"
        ]
    },
    {
        "func_name": "update",
        "original": "def update(name, profile='splunk', **kwargs):\n    \"\"\"\n    Update a splunk search\n\n    CLI Example:\n\n        splunk_search.update 'my search name' sharing=app\n    \"\"\"\n    client = _get_splunk(profile)\n    search = client.saved_searches[name]\n    props = _get_splunk_search_props(search)\n    updates = kwargs\n    update_needed = False\n    update_set = dict()\n    diffs = []\n    for key in sorted(kwargs):\n        old_value = props.get(key, None)\n        new_value = updates.get(key, None)\n        if isinstance(old_value, str):\n            old_value = old_value.strip()\n        if isinstance(new_value, str):\n            new_value = new_value.strip()\n        if old_value != new_value:\n            update_set[key] = new_value\n            update_needed = True\n            diffs.append(\"{}: '{}' => '{}'\".format(key, old_value, new_value))\n    if update_needed:\n        search.update(**update_set).refresh()\n        return (update_set, diffs)\n    return False",
        "mutated": [
            "def update(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n    \"\\n    Update a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.update 'my search name' sharing=app\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches[name]\n    props = _get_splunk_search_props(search)\n    updates = kwargs\n    update_needed = False\n    update_set = dict()\n    diffs = []\n    for key in sorted(kwargs):\n        old_value = props.get(key, None)\n        new_value = updates.get(key, None)\n        if isinstance(old_value, str):\n            old_value = old_value.strip()\n        if isinstance(new_value, str):\n            new_value = new_value.strip()\n        if old_value != new_value:\n            update_set[key] = new_value\n            update_needed = True\n            diffs.append(\"{}: '{}' => '{}'\".format(key, old_value, new_value))\n    if update_needed:\n        search.update(**update_set).refresh()\n        return (update_set, diffs)\n    return False",
            "def update(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Update a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.update 'my search name' sharing=app\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches[name]\n    props = _get_splunk_search_props(search)\n    updates = kwargs\n    update_needed = False\n    update_set = dict()\n    diffs = []\n    for key in sorted(kwargs):\n        old_value = props.get(key, None)\n        new_value = updates.get(key, None)\n        if isinstance(old_value, str):\n            old_value = old_value.strip()\n        if isinstance(new_value, str):\n            new_value = new_value.strip()\n        if old_value != new_value:\n            update_set[key] = new_value\n            update_needed = True\n            diffs.append(\"{}: '{}' => '{}'\".format(key, old_value, new_value))\n    if update_needed:\n        search.update(**update_set).refresh()\n        return (update_set, diffs)\n    return False",
            "def update(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Update a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.update 'my search name' sharing=app\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches[name]\n    props = _get_splunk_search_props(search)\n    updates = kwargs\n    update_needed = False\n    update_set = dict()\n    diffs = []\n    for key in sorted(kwargs):\n        old_value = props.get(key, None)\n        new_value = updates.get(key, None)\n        if isinstance(old_value, str):\n            old_value = old_value.strip()\n        if isinstance(new_value, str):\n            new_value = new_value.strip()\n        if old_value != new_value:\n            update_set[key] = new_value\n            update_needed = True\n            diffs.append(\"{}: '{}' => '{}'\".format(key, old_value, new_value))\n    if update_needed:\n        search.update(**update_set).refresh()\n        return (update_set, diffs)\n    return False",
            "def update(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Update a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.update 'my search name' sharing=app\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches[name]\n    props = _get_splunk_search_props(search)\n    updates = kwargs\n    update_needed = False\n    update_set = dict()\n    diffs = []\n    for key in sorted(kwargs):\n        old_value = props.get(key, None)\n        new_value = updates.get(key, None)\n        if isinstance(old_value, str):\n            old_value = old_value.strip()\n        if isinstance(new_value, str):\n            new_value = new_value.strip()\n        if old_value != new_value:\n            update_set[key] = new_value\n            update_needed = True\n            diffs.append(\"{}: '{}' => '{}'\".format(key, old_value, new_value))\n    if update_needed:\n        search.update(**update_set).refresh()\n        return (update_set, diffs)\n    return False",
            "def update(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Update a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.update 'my search name' sharing=app\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches[name]\n    props = _get_splunk_search_props(search)\n    updates = kwargs\n    update_needed = False\n    update_set = dict()\n    diffs = []\n    for key in sorted(kwargs):\n        old_value = props.get(key, None)\n        new_value = updates.get(key, None)\n        if isinstance(old_value, str):\n            old_value = old_value.strip()\n        if isinstance(new_value, str):\n            new_value = new_value.strip()\n        if old_value != new_value:\n            update_set[key] = new_value\n            update_needed = True\n            diffs.append(\"{}: '{}' => '{}'\".format(key, old_value, new_value))\n    if update_needed:\n        search.update(**update_set).refresh()\n        return (update_set, diffs)\n    return False"
        ]
    },
    {
        "func_name": "create",
        "original": "def create(name, profile='splunk', **kwargs):\n    \"\"\"\n    Create a splunk search\n\n    CLI Example:\n\n        splunk_search.create 'my search name' search='error msg'\n    \"\"\"\n    client = _get_splunk(profile)\n    search = client.saved_searches.create(name, **kwargs)\n    config = __salt__['config.option'](profile)\n    url = 'https://{}:{}'.format(config.get('host'), config.get('port'))\n    auth = (config.get('username'), config.get('password'))\n    data = {'owner': config.get('username'), 'sharing': 'app', 'perms.read': '*'}\n    _req_url = '{}/servicesNS/{}/search/saved/searches/{}/acl'.format(url, config.get('username'), urllib.parse.quote(name))\n    requests.post(_req_url, auth=auth, verify=True, data=data)\n    return _get_splunk_search_props(search)",
        "mutated": [
            "def create(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n    \"\\n    Create a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.create 'my search name' search='error msg'\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches.create(name, **kwargs)\n    config = __salt__['config.option'](profile)\n    url = 'https://{}:{}'.format(config.get('host'), config.get('port'))\n    auth = (config.get('username'), config.get('password'))\n    data = {'owner': config.get('username'), 'sharing': 'app', 'perms.read': '*'}\n    _req_url = '{}/servicesNS/{}/search/saved/searches/{}/acl'.format(url, config.get('username'), urllib.parse.quote(name))\n    requests.post(_req_url, auth=auth, verify=True, data=data)\n    return _get_splunk_search_props(search)",
            "def create(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Create a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.create 'my search name' search='error msg'\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches.create(name, **kwargs)\n    config = __salt__['config.option'](profile)\n    url = 'https://{}:{}'.format(config.get('host'), config.get('port'))\n    auth = (config.get('username'), config.get('password'))\n    data = {'owner': config.get('username'), 'sharing': 'app', 'perms.read': '*'}\n    _req_url = '{}/servicesNS/{}/search/saved/searches/{}/acl'.format(url, config.get('username'), urllib.parse.quote(name))\n    requests.post(_req_url, auth=auth, verify=True, data=data)\n    return _get_splunk_search_props(search)",
            "def create(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Create a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.create 'my search name' search='error msg'\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches.create(name, **kwargs)\n    config = __salt__['config.option'](profile)\n    url = 'https://{}:{}'.format(config.get('host'), config.get('port'))\n    auth = (config.get('username'), config.get('password'))\n    data = {'owner': config.get('username'), 'sharing': 'app', 'perms.read': '*'}\n    _req_url = '{}/servicesNS/{}/search/saved/searches/{}/acl'.format(url, config.get('username'), urllib.parse.quote(name))\n    requests.post(_req_url, auth=auth, verify=True, data=data)\n    return _get_splunk_search_props(search)",
            "def create(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Create a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.create 'my search name' search='error msg'\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches.create(name, **kwargs)\n    config = __salt__['config.option'](profile)\n    url = 'https://{}:{}'.format(config.get('host'), config.get('port'))\n    auth = (config.get('username'), config.get('password'))\n    data = {'owner': config.get('username'), 'sharing': 'app', 'perms.read': '*'}\n    _req_url = '{}/servicesNS/{}/search/saved/searches/{}/acl'.format(url, config.get('username'), urllib.parse.quote(name))\n    requests.post(_req_url, auth=auth, verify=True, data=data)\n    return _get_splunk_search_props(search)",
            "def create(name, profile='splunk', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Create a splunk search\\n\\n    CLI Example:\\n\\n        splunk_search.create 'my search name' search='error msg'\\n    \"\n    client = _get_splunk(profile)\n    search = client.saved_searches.create(name, **kwargs)\n    config = __salt__['config.option'](profile)\n    url = 'https://{}:{}'.format(config.get('host'), config.get('port'))\n    auth = (config.get('username'), config.get('password'))\n    data = {'owner': config.get('username'), 'sharing': 'app', 'perms.read': '*'}\n    _req_url = '{}/servicesNS/{}/search/saved/searches/{}/acl'.format(url, config.get('username'), urllib.parse.quote(name))\n    requests.post(_req_url, auth=auth, verify=True, data=data)\n    return _get_splunk_search_props(search)"
        ]
    },
    {
        "func_name": "delete",
        "original": "def delete(name, profile='splunk'):\n    \"\"\"\n    Delete a splunk search\n\n    CLI Example:\n\n       splunk_search.delete 'my search name'\n    \"\"\"\n    client = _get_splunk(profile)\n    try:\n        client.saved_searches.delete(name)\n        return True\n    except KeyError:\n        return None",
        "mutated": [
            "def delete(name, profile='splunk'):\n    if False:\n        i = 10\n    \"\\n    Delete a splunk search\\n\\n    CLI Example:\\n\\n       splunk_search.delete 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    try:\n        client.saved_searches.delete(name)\n        return True\n    except KeyError:\n        return None",
            "def delete(name, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Delete a splunk search\\n\\n    CLI Example:\\n\\n       splunk_search.delete 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    try:\n        client.saved_searches.delete(name)\n        return True\n    except KeyError:\n        return None",
            "def delete(name, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Delete a splunk search\\n\\n    CLI Example:\\n\\n       splunk_search.delete 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    try:\n        client.saved_searches.delete(name)\n        return True\n    except KeyError:\n        return None",
            "def delete(name, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Delete a splunk search\\n\\n    CLI Example:\\n\\n       splunk_search.delete 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    try:\n        client.saved_searches.delete(name)\n        return True\n    except KeyError:\n        return None",
            "def delete(name, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Delete a splunk search\\n\\n    CLI Example:\\n\\n       splunk_search.delete 'my search name'\\n    \"\n    client = _get_splunk(profile)\n    try:\n        client.saved_searches.delete(name)\n        return True\n    except KeyError:\n        return None"
        ]
    },
    {
        "func_name": "list_",
        "original": "def list_(profile='splunk'):\n    \"\"\"\n    List splunk searches (names only)\n\n    CLI Example:\n\n        splunk_search.list\n    \"\"\"\n    client = _get_splunk(profile)\n    searches = [x['name'] for x in client.saved_searches]\n    return searches",
        "mutated": [
            "def list_(profile='splunk'):\n    if False:\n        i = 10\n    '\\n    List splunk searches (names only)\\n\\n    CLI Example:\\n\\n        splunk_search.list\\n    '\n    client = _get_splunk(profile)\n    searches = [x['name'] for x in client.saved_searches]\n    return searches",
            "def list_(profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    List splunk searches (names only)\\n\\n    CLI Example:\\n\\n        splunk_search.list\\n    '\n    client = _get_splunk(profile)\n    searches = [x['name'] for x in client.saved_searches]\n    return searches",
            "def list_(profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    List splunk searches (names only)\\n\\n    CLI Example:\\n\\n        splunk_search.list\\n    '\n    client = _get_splunk(profile)\n    searches = [x['name'] for x in client.saved_searches]\n    return searches",
            "def list_(profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    List splunk searches (names only)\\n\\n    CLI Example:\\n\\n        splunk_search.list\\n    '\n    client = _get_splunk(profile)\n    searches = [x['name'] for x in client.saved_searches]\n    return searches",
            "def list_(profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    List splunk searches (names only)\\n\\n    CLI Example:\\n\\n        splunk_search.list\\n    '\n    client = _get_splunk(profile)\n    searches = [x['name'] for x in client.saved_searches]\n    return searches"
        ]
    },
    {
        "func_name": "list_all",
        "original": "def list_all(prefix=None, app=None, owner=None, description_contains=None, name_not_contains=None, profile='splunk'):\n    \"\"\"\n    Get all splunk search details. Produces results that can be used to create\n    an sls file.\n\n    if app or owner are specified, results will be limited to matching saved\n    searches.\n\n    if description_contains is specified, results will be limited to those\n    where \"description_contains in description\" is true if name_not_contains is\n    specified, results will be limited to those where \"name_not_contains not in\n    name\" is true.\n\n    If prefix parameter is given, alarm names in the output will be prepended\n    with the prefix; alarms that have the prefix will be skipped. This can be\n    used to convert existing alarms to be managed by salt, as follows:\n\n    CLI Example:\n\n            1. Make a \"backup\" of all existing searches\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > legacy_searches.sls\n\n            2. Get all searches with new prefixed names\n                $ salt-call splunk_search.list_all \"prefix=**MANAGED BY SALT** \" --out=txt | sed \"s/local: //\" > managed_searches.sls\n\n            3. Insert the managed searches into splunk\n                $ salt-call state.sls managed_searches.sls\n\n            4.  Manually verify that the new searches look right\n\n            5.  Delete the original searches\n                $ sed s/present/absent/ legacy_searches.sls > remove_legacy_searches.sls\n                $ salt-call state.sls remove_legacy_searches.sls\n\n            6.  Get all searches again, verify no changes\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > final_searches.sls\n                $ diff final_searches.sls managed_searches.sls\n    \"\"\"\n    client = _get_splunk(profile)\n    name = 'splunk_search.list_all get defaults'\n    try:\n        client.saved_searches.delete(name)\n    except Exception:\n        pass\n    search = client.saved_searches.create(name, search='nothing')\n    defaults = dict(search.content)\n    client.saved_searches.delete(name)\n    readonly_keys = ('triggered_alert_count', 'action.email', 'action.populate_lookup', 'action.rss', 'action.script', 'action.summary_index', 'qualifiedSearch', 'next_scheduled_time')\n    results = OrderedDict()\n    searches = sorted(((s.name, s) for s in client.saved_searches))\n    for (name, search) in searches:\n        if app and search.access.app != app:\n            continue\n        if owner and search.access.owner != owner:\n            continue\n        if name_not_contains and name_not_contains in name:\n            continue\n        if prefix:\n            if name.startswith(prefix):\n                continue\n            name = prefix + name\n        d = [{'name': name}]\n        description = ''\n        for (k, v) in sorted(search.content.items()):\n            if k in readonly_keys:\n                continue\n            if k.startswith('display.'):\n                continue\n            if not v:\n                continue\n            if k in defaults and defaults[k] == v:\n                continue\n            d.append({k: v})\n            if k == 'description':\n                description = v\n        if description_contains and description_contains not in description:\n            continue\n        results['manage splunk search ' + name] = {'splunk_search.present': d}\n    return salt.utils.yaml.safe_dump(results, default_flow_style=False, width=120)",
        "mutated": [
            "def list_all(prefix=None, app=None, owner=None, description_contains=None, name_not_contains=None, profile='splunk'):\n    if False:\n        i = 10\n    '\\n    Get all splunk search details. Produces results that can be used to create\\n    an sls file.\\n\\n    if app or owner are specified, results will be limited to matching saved\\n    searches.\\n\\n    if description_contains is specified, results will be limited to those\\n    where \"description_contains in description\" is true if name_not_contains is\\n    specified, results will be limited to those where \"name_not_contains not in\\n    name\" is true.\\n\\n    If prefix parameter is given, alarm names in the output will be prepended\\n    with the prefix; alarms that have the prefix will be skipped. This can be\\n    used to convert existing alarms to be managed by salt, as follows:\\n\\n    CLI Example:\\n\\n            1. Make a \"backup\" of all existing searches\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > legacy_searches.sls\\n\\n            2. Get all searches with new prefixed names\\n                $ salt-call splunk_search.list_all \"prefix=**MANAGED BY SALT** \" --out=txt | sed \"s/local: //\" > managed_searches.sls\\n\\n            3. Insert the managed searches into splunk\\n                $ salt-call state.sls managed_searches.sls\\n\\n            4.  Manually verify that the new searches look right\\n\\n            5.  Delete the original searches\\n                $ sed s/present/absent/ legacy_searches.sls > remove_legacy_searches.sls\\n                $ salt-call state.sls remove_legacy_searches.sls\\n\\n            6.  Get all searches again, verify no changes\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > final_searches.sls\\n                $ diff final_searches.sls managed_searches.sls\\n    '\n    client = _get_splunk(profile)\n    name = 'splunk_search.list_all get defaults'\n    try:\n        client.saved_searches.delete(name)\n    except Exception:\n        pass\n    search = client.saved_searches.create(name, search='nothing')\n    defaults = dict(search.content)\n    client.saved_searches.delete(name)\n    readonly_keys = ('triggered_alert_count', 'action.email', 'action.populate_lookup', 'action.rss', 'action.script', 'action.summary_index', 'qualifiedSearch', 'next_scheduled_time')\n    results = OrderedDict()\n    searches = sorted(((s.name, s) for s in client.saved_searches))\n    for (name, search) in searches:\n        if app and search.access.app != app:\n            continue\n        if owner and search.access.owner != owner:\n            continue\n        if name_not_contains and name_not_contains in name:\n            continue\n        if prefix:\n            if name.startswith(prefix):\n                continue\n            name = prefix + name\n        d = [{'name': name}]\n        description = ''\n        for (k, v) in sorted(search.content.items()):\n            if k in readonly_keys:\n                continue\n            if k.startswith('display.'):\n                continue\n            if not v:\n                continue\n            if k in defaults and defaults[k] == v:\n                continue\n            d.append({k: v})\n            if k == 'description':\n                description = v\n        if description_contains and description_contains not in description:\n            continue\n        results['manage splunk search ' + name] = {'splunk_search.present': d}\n    return salt.utils.yaml.safe_dump(results, default_flow_style=False, width=120)",
            "def list_all(prefix=None, app=None, owner=None, description_contains=None, name_not_contains=None, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get all splunk search details. Produces results that can be used to create\\n    an sls file.\\n\\n    if app or owner are specified, results will be limited to matching saved\\n    searches.\\n\\n    if description_contains is specified, results will be limited to those\\n    where \"description_contains in description\" is true if name_not_contains is\\n    specified, results will be limited to those where \"name_not_contains not in\\n    name\" is true.\\n\\n    If prefix parameter is given, alarm names in the output will be prepended\\n    with the prefix; alarms that have the prefix will be skipped. This can be\\n    used to convert existing alarms to be managed by salt, as follows:\\n\\n    CLI Example:\\n\\n            1. Make a \"backup\" of all existing searches\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > legacy_searches.sls\\n\\n            2. Get all searches with new prefixed names\\n                $ salt-call splunk_search.list_all \"prefix=**MANAGED BY SALT** \" --out=txt | sed \"s/local: //\" > managed_searches.sls\\n\\n            3. Insert the managed searches into splunk\\n                $ salt-call state.sls managed_searches.sls\\n\\n            4.  Manually verify that the new searches look right\\n\\n            5.  Delete the original searches\\n                $ sed s/present/absent/ legacy_searches.sls > remove_legacy_searches.sls\\n                $ salt-call state.sls remove_legacy_searches.sls\\n\\n            6.  Get all searches again, verify no changes\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > final_searches.sls\\n                $ diff final_searches.sls managed_searches.sls\\n    '\n    client = _get_splunk(profile)\n    name = 'splunk_search.list_all get defaults'\n    try:\n        client.saved_searches.delete(name)\n    except Exception:\n        pass\n    search = client.saved_searches.create(name, search='nothing')\n    defaults = dict(search.content)\n    client.saved_searches.delete(name)\n    readonly_keys = ('triggered_alert_count', 'action.email', 'action.populate_lookup', 'action.rss', 'action.script', 'action.summary_index', 'qualifiedSearch', 'next_scheduled_time')\n    results = OrderedDict()\n    searches = sorted(((s.name, s) for s in client.saved_searches))\n    for (name, search) in searches:\n        if app and search.access.app != app:\n            continue\n        if owner and search.access.owner != owner:\n            continue\n        if name_not_contains and name_not_contains in name:\n            continue\n        if prefix:\n            if name.startswith(prefix):\n                continue\n            name = prefix + name\n        d = [{'name': name}]\n        description = ''\n        for (k, v) in sorted(search.content.items()):\n            if k in readonly_keys:\n                continue\n            if k.startswith('display.'):\n                continue\n            if not v:\n                continue\n            if k in defaults and defaults[k] == v:\n                continue\n            d.append({k: v})\n            if k == 'description':\n                description = v\n        if description_contains and description_contains not in description:\n            continue\n        results['manage splunk search ' + name] = {'splunk_search.present': d}\n    return salt.utils.yaml.safe_dump(results, default_flow_style=False, width=120)",
            "def list_all(prefix=None, app=None, owner=None, description_contains=None, name_not_contains=None, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get all splunk search details. Produces results that can be used to create\\n    an sls file.\\n\\n    if app or owner are specified, results will be limited to matching saved\\n    searches.\\n\\n    if description_contains is specified, results will be limited to those\\n    where \"description_contains in description\" is true if name_not_contains is\\n    specified, results will be limited to those where \"name_not_contains not in\\n    name\" is true.\\n\\n    If prefix parameter is given, alarm names in the output will be prepended\\n    with the prefix; alarms that have the prefix will be skipped. This can be\\n    used to convert existing alarms to be managed by salt, as follows:\\n\\n    CLI Example:\\n\\n            1. Make a \"backup\" of all existing searches\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > legacy_searches.sls\\n\\n            2. Get all searches with new prefixed names\\n                $ salt-call splunk_search.list_all \"prefix=**MANAGED BY SALT** \" --out=txt | sed \"s/local: //\" > managed_searches.sls\\n\\n            3. Insert the managed searches into splunk\\n                $ salt-call state.sls managed_searches.sls\\n\\n            4.  Manually verify that the new searches look right\\n\\n            5.  Delete the original searches\\n                $ sed s/present/absent/ legacy_searches.sls > remove_legacy_searches.sls\\n                $ salt-call state.sls remove_legacy_searches.sls\\n\\n            6.  Get all searches again, verify no changes\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > final_searches.sls\\n                $ diff final_searches.sls managed_searches.sls\\n    '\n    client = _get_splunk(profile)\n    name = 'splunk_search.list_all get defaults'\n    try:\n        client.saved_searches.delete(name)\n    except Exception:\n        pass\n    search = client.saved_searches.create(name, search='nothing')\n    defaults = dict(search.content)\n    client.saved_searches.delete(name)\n    readonly_keys = ('triggered_alert_count', 'action.email', 'action.populate_lookup', 'action.rss', 'action.script', 'action.summary_index', 'qualifiedSearch', 'next_scheduled_time')\n    results = OrderedDict()\n    searches = sorted(((s.name, s) for s in client.saved_searches))\n    for (name, search) in searches:\n        if app and search.access.app != app:\n            continue\n        if owner and search.access.owner != owner:\n            continue\n        if name_not_contains and name_not_contains in name:\n            continue\n        if prefix:\n            if name.startswith(prefix):\n                continue\n            name = prefix + name\n        d = [{'name': name}]\n        description = ''\n        for (k, v) in sorted(search.content.items()):\n            if k in readonly_keys:\n                continue\n            if k.startswith('display.'):\n                continue\n            if not v:\n                continue\n            if k in defaults and defaults[k] == v:\n                continue\n            d.append({k: v})\n            if k == 'description':\n                description = v\n        if description_contains and description_contains not in description:\n            continue\n        results['manage splunk search ' + name] = {'splunk_search.present': d}\n    return salt.utils.yaml.safe_dump(results, default_flow_style=False, width=120)",
            "def list_all(prefix=None, app=None, owner=None, description_contains=None, name_not_contains=None, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get all splunk search details. Produces results that can be used to create\\n    an sls file.\\n\\n    if app or owner are specified, results will be limited to matching saved\\n    searches.\\n\\n    if description_contains is specified, results will be limited to those\\n    where \"description_contains in description\" is true if name_not_contains is\\n    specified, results will be limited to those where \"name_not_contains not in\\n    name\" is true.\\n\\n    If prefix parameter is given, alarm names in the output will be prepended\\n    with the prefix; alarms that have the prefix will be skipped. This can be\\n    used to convert existing alarms to be managed by salt, as follows:\\n\\n    CLI Example:\\n\\n            1. Make a \"backup\" of all existing searches\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > legacy_searches.sls\\n\\n            2. Get all searches with new prefixed names\\n                $ salt-call splunk_search.list_all \"prefix=**MANAGED BY SALT** \" --out=txt | sed \"s/local: //\" > managed_searches.sls\\n\\n            3. Insert the managed searches into splunk\\n                $ salt-call state.sls managed_searches.sls\\n\\n            4.  Manually verify that the new searches look right\\n\\n            5.  Delete the original searches\\n                $ sed s/present/absent/ legacy_searches.sls > remove_legacy_searches.sls\\n                $ salt-call state.sls remove_legacy_searches.sls\\n\\n            6.  Get all searches again, verify no changes\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > final_searches.sls\\n                $ diff final_searches.sls managed_searches.sls\\n    '\n    client = _get_splunk(profile)\n    name = 'splunk_search.list_all get defaults'\n    try:\n        client.saved_searches.delete(name)\n    except Exception:\n        pass\n    search = client.saved_searches.create(name, search='nothing')\n    defaults = dict(search.content)\n    client.saved_searches.delete(name)\n    readonly_keys = ('triggered_alert_count', 'action.email', 'action.populate_lookup', 'action.rss', 'action.script', 'action.summary_index', 'qualifiedSearch', 'next_scheduled_time')\n    results = OrderedDict()\n    searches = sorted(((s.name, s) for s in client.saved_searches))\n    for (name, search) in searches:\n        if app and search.access.app != app:\n            continue\n        if owner and search.access.owner != owner:\n            continue\n        if name_not_contains and name_not_contains in name:\n            continue\n        if prefix:\n            if name.startswith(prefix):\n                continue\n            name = prefix + name\n        d = [{'name': name}]\n        description = ''\n        for (k, v) in sorted(search.content.items()):\n            if k in readonly_keys:\n                continue\n            if k.startswith('display.'):\n                continue\n            if not v:\n                continue\n            if k in defaults and defaults[k] == v:\n                continue\n            d.append({k: v})\n            if k == 'description':\n                description = v\n        if description_contains and description_contains not in description:\n            continue\n        results['manage splunk search ' + name] = {'splunk_search.present': d}\n    return salt.utils.yaml.safe_dump(results, default_flow_style=False, width=120)",
            "def list_all(prefix=None, app=None, owner=None, description_contains=None, name_not_contains=None, profile='splunk'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get all splunk search details. Produces results that can be used to create\\n    an sls file.\\n\\n    if app or owner are specified, results will be limited to matching saved\\n    searches.\\n\\n    if description_contains is specified, results will be limited to those\\n    where \"description_contains in description\" is true if name_not_contains is\\n    specified, results will be limited to those where \"name_not_contains not in\\n    name\" is true.\\n\\n    If prefix parameter is given, alarm names in the output will be prepended\\n    with the prefix; alarms that have the prefix will be skipped. This can be\\n    used to convert existing alarms to be managed by salt, as follows:\\n\\n    CLI Example:\\n\\n            1. Make a \"backup\" of all existing searches\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > legacy_searches.sls\\n\\n            2. Get all searches with new prefixed names\\n                $ salt-call splunk_search.list_all \"prefix=**MANAGED BY SALT** \" --out=txt | sed \"s/local: //\" > managed_searches.sls\\n\\n            3. Insert the managed searches into splunk\\n                $ salt-call state.sls managed_searches.sls\\n\\n            4.  Manually verify that the new searches look right\\n\\n            5.  Delete the original searches\\n                $ sed s/present/absent/ legacy_searches.sls > remove_legacy_searches.sls\\n                $ salt-call state.sls remove_legacy_searches.sls\\n\\n            6.  Get all searches again, verify no changes\\n                $ salt-call splunk_search.list_all --out=txt | sed \"s/local: //\" > final_searches.sls\\n                $ diff final_searches.sls managed_searches.sls\\n    '\n    client = _get_splunk(profile)\n    name = 'splunk_search.list_all get defaults'\n    try:\n        client.saved_searches.delete(name)\n    except Exception:\n        pass\n    search = client.saved_searches.create(name, search='nothing')\n    defaults = dict(search.content)\n    client.saved_searches.delete(name)\n    readonly_keys = ('triggered_alert_count', 'action.email', 'action.populate_lookup', 'action.rss', 'action.script', 'action.summary_index', 'qualifiedSearch', 'next_scheduled_time')\n    results = OrderedDict()\n    searches = sorted(((s.name, s) for s in client.saved_searches))\n    for (name, search) in searches:\n        if app and search.access.app != app:\n            continue\n        if owner and search.access.owner != owner:\n            continue\n        if name_not_contains and name_not_contains in name:\n            continue\n        if prefix:\n            if name.startswith(prefix):\n                continue\n            name = prefix + name\n        d = [{'name': name}]\n        description = ''\n        for (k, v) in sorted(search.content.items()):\n            if k in readonly_keys:\n                continue\n            if k.startswith('display.'):\n                continue\n            if not v:\n                continue\n            if k in defaults and defaults[k] == v:\n                continue\n            d.append({k: v})\n            if k == 'description':\n                description = v\n        if description_contains and description_contains not in description:\n            continue\n        results['manage splunk search ' + name] = {'splunk_search.present': d}\n    return salt.utils.yaml.safe_dump(results, default_flow_style=False, width=120)"
        ]
    }
]