[
    {
        "func_name": "dig",
        "original": "def dig(cfg, keys: str):\n    \"\"\"\n    Receives a string such as 'foo.bar' and returns `cfg['foo']['bar']`, or `NotFound`.\n\n    A list of single-item dicts gets converted to a flat dict. This is intended for `plugins` config.\n    \"\"\"\n    (key, _, rest) = keys.partition('.')\n    try:\n        cfg = cfg[key]\n    except (KeyError, TypeError):\n        return NotFound\n    if isinstance(cfg, list):\n        orig_cfg = cfg\n        cfg = {}\n        for item in reversed(orig_cfg):\n            if isinstance(item, dict) and len(item) == 1:\n                cfg.update(item)\n            elif isinstance(item, str):\n                cfg[item] = {}\n    if not rest:\n        return cfg\n    return dig(cfg, rest)",
        "mutated": [
            "def dig(cfg, keys: str):\n    if False:\n        i = 10\n    \"\\n    Receives a string such as 'foo.bar' and returns `cfg['foo']['bar']`, or `NotFound`.\\n\\n    A list of single-item dicts gets converted to a flat dict. This is intended for `plugins` config.\\n    \"\n    (key, _, rest) = keys.partition('.')\n    try:\n        cfg = cfg[key]\n    except (KeyError, TypeError):\n        return NotFound\n    if isinstance(cfg, list):\n        orig_cfg = cfg\n        cfg = {}\n        for item in reversed(orig_cfg):\n            if isinstance(item, dict) and len(item) == 1:\n                cfg.update(item)\n            elif isinstance(item, str):\n                cfg[item] = {}\n    if not rest:\n        return cfg\n    return dig(cfg, rest)",
            "def dig(cfg, keys: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Receives a string such as 'foo.bar' and returns `cfg['foo']['bar']`, or `NotFound`.\\n\\n    A list of single-item dicts gets converted to a flat dict. This is intended for `plugins` config.\\n    \"\n    (key, _, rest) = keys.partition('.')\n    try:\n        cfg = cfg[key]\n    except (KeyError, TypeError):\n        return NotFound\n    if isinstance(cfg, list):\n        orig_cfg = cfg\n        cfg = {}\n        for item in reversed(orig_cfg):\n            if isinstance(item, dict) and len(item) == 1:\n                cfg.update(item)\n            elif isinstance(item, str):\n                cfg[item] = {}\n    if not rest:\n        return cfg\n    return dig(cfg, rest)",
            "def dig(cfg, keys: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Receives a string such as 'foo.bar' and returns `cfg['foo']['bar']`, or `NotFound`.\\n\\n    A list of single-item dicts gets converted to a flat dict. This is intended for `plugins` config.\\n    \"\n    (key, _, rest) = keys.partition('.')\n    try:\n        cfg = cfg[key]\n    except (KeyError, TypeError):\n        return NotFound\n    if isinstance(cfg, list):\n        orig_cfg = cfg\n        cfg = {}\n        for item in reversed(orig_cfg):\n            if isinstance(item, dict) and len(item) == 1:\n                cfg.update(item)\n            elif isinstance(item, str):\n                cfg[item] = {}\n    if not rest:\n        return cfg\n    return dig(cfg, rest)",
            "def dig(cfg, keys: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Receives a string such as 'foo.bar' and returns `cfg['foo']['bar']`, or `NotFound`.\\n\\n    A list of single-item dicts gets converted to a flat dict. This is intended for `plugins` config.\\n    \"\n    (key, _, rest) = keys.partition('.')\n    try:\n        cfg = cfg[key]\n    except (KeyError, TypeError):\n        return NotFound\n    if isinstance(cfg, list):\n        orig_cfg = cfg\n        cfg = {}\n        for item in reversed(orig_cfg):\n            if isinstance(item, dict) and len(item) == 1:\n                cfg.update(item)\n            elif isinstance(item, str):\n                cfg[item] = {}\n    if not rest:\n        return cfg\n    return dig(cfg, rest)",
            "def dig(cfg, keys: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Receives a string such as 'foo.bar' and returns `cfg['foo']['bar']`, or `NotFound`.\\n\\n    A list of single-item dicts gets converted to a flat dict. This is intended for `plugins` config.\\n    \"\n    (key, _, rest) = keys.partition('.')\n    try:\n        cfg = cfg[key]\n    except (KeyError, TypeError):\n        return NotFound\n    if isinstance(cfg, list):\n        orig_cfg = cfg\n        cfg = {}\n        for item in reversed(orig_cfg):\n            if isinstance(item, dict) and len(item) == 1:\n                cfg.update(item)\n            elif isinstance(item, str):\n                cfg[item] = {}\n    if not rest:\n        return cfg\n    return dig(cfg, rest)"
        ]
    },
    {
        "func_name": "strings",
        "original": "def strings(obj) -> Sequence[str]:\n    if isinstance(obj, str):\n        return (obj,)\n    else:\n        return tuple(obj)",
        "mutated": [
            "def strings(obj) -> Sequence[str]:\n    if False:\n        i = 10\n    if isinstance(obj, str):\n        return (obj,)\n    else:\n        return tuple(obj)",
            "def strings(obj) -> Sequence[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(obj, str):\n        return (obj,)\n    else:\n        return tuple(obj)",
            "def strings(obj) -> Sequence[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(obj, str):\n        return (obj,)\n    else:\n        return tuple(obj)",
            "def strings(obj) -> Sequence[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(obj, str):\n        return (obj,)\n    else:\n        return tuple(obj)",
            "def strings(obj) -> Sequence[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(obj, str):\n        return (obj,)\n    else:\n        return tuple(obj)"
        ]
    },
    {
        "func_name": "_entry_points",
        "original": "@functools.lru_cache\ndef _entry_points(group: str) -> Mapping[str, EntryPoint]:\n    eps = {ep.name: ep for ep in entry_points(group=group)}\n    log.debug(f\"Available '{group}' entry points: {sorted(eps)}\")\n    return eps",
        "mutated": [
            "@functools.lru_cache\ndef _entry_points(group: str) -> Mapping[str, EntryPoint]:\n    if False:\n        i = 10\n    eps = {ep.name: ep for ep in entry_points(group=group)}\n    log.debug(f\"Available '{group}' entry points: {sorted(eps)}\")\n    return eps",
            "@functools.lru_cache\ndef _entry_points(group: str) -> Mapping[str, EntryPoint]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    eps = {ep.name: ep for ep in entry_points(group=group)}\n    log.debug(f\"Available '{group}' entry points: {sorted(eps)}\")\n    return eps",
            "@functools.lru_cache\ndef _entry_points(group: str) -> Mapping[str, EntryPoint]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    eps = {ep.name: ep for ep in entry_points(group=group)}\n    log.debug(f\"Available '{group}' entry points: {sorted(eps)}\")\n    return eps",
            "@functools.lru_cache\ndef _entry_points(group: str) -> Mapping[str, EntryPoint]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    eps = {ep.name: ep for ep in entry_points(group=group)}\n    log.debug(f\"Available '{group}' entry points: {sorted(eps)}\")\n    return eps",
            "@functools.lru_cache\ndef _entry_points(group: str) -> Mapping[str, EntryPoint]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    eps = {ep.name: ep for ep in entry_points(group=group)}\n    log.debug(f\"Available '{group}' entry points: {sorted(eps)}\")\n    return eps"
        ]
    },
    {
        "func_name": "__str__",
        "original": "def __str__(self) -> str:\n    return self.projects_key.rpartition('_')[-1]",
        "mutated": [
            "def __str__(self) -> str:\n    if False:\n        i = 10\n    return self.projects_key.rpartition('_')[-1]",
            "def __str__(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.projects_key.rpartition('_')[-1]",
            "def __str__(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.projects_key.rpartition('_')[-1]",
            "def __str__(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.projects_key.rpartition('_')[-1]",
            "def __str__(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.projects_key.rpartition('_')[-1]"
        ]
    },
    {
        "func_name": "get_deps",
        "original": "def get_deps(projects_file_url: str, config_file_path: str | None=None) -> None:\n    \"\"\"\n    Print PyPI package dependencies inferred from a mkdocs.yml file based on a reverse mapping of known projects.\n\n    Args:\n        projects_file_url: URL or local path of the registry file that declares all known MkDocs-related projects.\n            The file is in YAML format and contains `projects: [{mkdocs_theme:, mkdocs_plugin:, markdown_extension:}]\n        config_file_path: Non-default path to mkdocs.yml.\n    \"\"\"\n    with _open_config_file(config_file_path) as f:\n        cfg = utils.yaml_load(f, loader=YamlLoader)\n    packages_to_install = set()\n    if all((c not in cfg for c in ('site_name', 'theme', 'plugins', 'markdown_extensions'))):\n        log.warning(\"The passed config file doesn't seem to be a mkdocs.yml config file\")\n    elif dig(cfg, 'theme.locale') not in (NotFound, 'en'):\n        packages_to_install.add('mkdocs[i18n]')\n    else:\n        packages_to_install.add('mkdocs')\n    try:\n        theme = cfg['theme']['name']\n    except (KeyError, TypeError):\n        theme = cfg.get('theme')\n    themes = {theme} if theme else set()\n    plugins = set(strings(dig(cfg, 'plugins')))\n    extensions = set(strings(dig(cfg, 'markdown_extensions')))\n    wanted_plugins = ((PluginKind('mkdocs_theme', 'mkdocs.themes'), themes - {'mkdocs', 'readthedocs'}), (PluginKind('mkdocs_plugin', 'mkdocs.plugins'), plugins - {'search'}), (PluginKind('markdown_extension', 'markdown.extensions'), extensions))\n    for (kind, wanted) in wanted_plugins:\n        log.debug(f'Wanted {kind}s: {sorted(wanted)}')\n    content = download_and_cache_url(projects_file_url, datetime.timedelta(days=7))\n    projects = yaml.safe_load(content)['projects']\n    for project in projects:\n        for (kind, wanted) in wanted_plugins:\n            available = strings(project.get(kind.projects_key, ()))\n            for entry_name in available:\n                if '/' in entry_name and theme is not None and (kind.projects_key == 'mkdocs_plugin') and entry_name.startswith(f'{theme}/') and (entry_name[len(theme) + 1:] in wanted) and (entry_name not in wanted):\n                    entry_name = entry_name[len(theme) + 1:]\n                if entry_name in wanted:\n                    if 'pypi_id' in project:\n                        install_name = project['pypi_id']\n                    elif 'github_id' in project:\n                        install_name = 'git+https://github.com/{github_id}'.format_map(project)\n                    else:\n                        log.error(f\"Can't find how to install {kind} '{entry_name}' although it was identified as {project}\")\n                        continue\n                    packages_to_install.add(install_name)\n                    for (extra_key, extra_pkgs) in project.get('extra_dependencies', {}).items():\n                        if dig(cfg, extra_key) is not NotFound:\n                            packages_to_install.update(strings(extra_pkgs))\n                    wanted.remove(entry_name)\n    for (kind, wanted) in wanted_plugins:\n        for entry_name in sorted(wanted):\n            dist_name = None\n            ep = _entry_points(kind.entry_points_key).get(entry_name)\n            if ep is not None and ep.dist is not None:\n                dist_name = ep.dist.name\n            if dist_name not in ('mkdocs', 'Markdown'):\n                warning = f\"{str(kind).capitalize()} '{entry_name}' is not provided by any registered project\"\n                if ep is not None:\n                    warning += ' but is installed locally'\n                    if dist_name:\n                        warning += f\" from '{dist_name}'\"\n                    log.info(warning)\n                else:\n                    log.warning(warning)\n    for pkg in sorted(packages_to_install):\n        print(pkg)",
        "mutated": [
            "def get_deps(projects_file_url: str, config_file_path: str | None=None) -> None:\n    if False:\n        i = 10\n    '\\n    Print PyPI package dependencies inferred from a mkdocs.yml file based on a reverse mapping of known projects.\\n\\n    Args:\\n        projects_file_url: URL or local path of the registry file that declares all known MkDocs-related projects.\\n            The file is in YAML format and contains `projects: [{mkdocs_theme:, mkdocs_plugin:, markdown_extension:}]\\n        config_file_path: Non-default path to mkdocs.yml.\\n    '\n    with _open_config_file(config_file_path) as f:\n        cfg = utils.yaml_load(f, loader=YamlLoader)\n    packages_to_install = set()\n    if all((c not in cfg for c in ('site_name', 'theme', 'plugins', 'markdown_extensions'))):\n        log.warning(\"The passed config file doesn't seem to be a mkdocs.yml config file\")\n    elif dig(cfg, 'theme.locale') not in (NotFound, 'en'):\n        packages_to_install.add('mkdocs[i18n]')\n    else:\n        packages_to_install.add('mkdocs')\n    try:\n        theme = cfg['theme']['name']\n    except (KeyError, TypeError):\n        theme = cfg.get('theme')\n    themes = {theme} if theme else set()\n    plugins = set(strings(dig(cfg, 'plugins')))\n    extensions = set(strings(dig(cfg, 'markdown_extensions')))\n    wanted_plugins = ((PluginKind('mkdocs_theme', 'mkdocs.themes'), themes - {'mkdocs', 'readthedocs'}), (PluginKind('mkdocs_plugin', 'mkdocs.plugins'), plugins - {'search'}), (PluginKind('markdown_extension', 'markdown.extensions'), extensions))\n    for (kind, wanted) in wanted_plugins:\n        log.debug(f'Wanted {kind}s: {sorted(wanted)}')\n    content = download_and_cache_url(projects_file_url, datetime.timedelta(days=7))\n    projects = yaml.safe_load(content)['projects']\n    for project in projects:\n        for (kind, wanted) in wanted_plugins:\n            available = strings(project.get(kind.projects_key, ()))\n            for entry_name in available:\n                if '/' in entry_name and theme is not None and (kind.projects_key == 'mkdocs_plugin') and entry_name.startswith(f'{theme}/') and (entry_name[len(theme) + 1:] in wanted) and (entry_name not in wanted):\n                    entry_name = entry_name[len(theme) + 1:]\n                if entry_name in wanted:\n                    if 'pypi_id' in project:\n                        install_name = project['pypi_id']\n                    elif 'github_id' in project:\n                        install_name = 'git+https://github.com/{github_id}'.format_map(project)\n                    else:\n                        log.error(f\"Can't find how to install {kind} '{entry_name}' although it was identified as {project}\")\n                        continue\n                    packages_to_install.add(install_name)\n                    for (extra_key, extra_pkgs) in project.get('extra_dependencies', {}).items():\n                        if dig(cfg, extra_key) is not NotFound:\n                            packages_to_install.update(strings(extra_pkgs))\n                    wanted.remove(entry_name)\n    for (kind, wanted) in wanted_plugins:\n        for entry_name in sorted(wanted):\n            dist_name = None\n            ep = _entry_points(kind.entry_points_key).get(entry_name)\n            if ep is not None and ep.dist is not None:\n                dist_name = ep.dist.name\n            if dist_name not in ('mkdocs', 'Markdown'):\n                warning = f\"{str(kind).capitalize()} '{entry_name}' is not provided by any registered project\"\n                if ep is not None:\n                    warning += ' but is installed locally'\n                    if dist_name:\n                        warning += f\" from '{dist_name}'\"\n                    log.info(warning)\n                else:\n                    log.warning(warning)\n    for pkg in sorted(packages_to_install):\n        print(pkg)",
            "def get_deps(projects_file_url: str, config_file_path: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Print PyPI package dependencies inferred from a mkdocs.yml file based on a reverse mapping of known projects.\\n\\n    Args:\\n        projects_file_url: URL or local path of the registry file that declares all known MkDocs-related projects.\\n            The file is in YAML format and contains `projects: [{mkdocs_theme:, mkdocs_plugin:, markdown_extension:}]\\n        config_file_path: Non-default path to mkdocs.yml.\\n    '\n    with _open_config_file(config_file_path) as f:\n        cfg = utils.yaml_load(f, loader=YamlLoader)\n    packages_to_install = set()\n    if all((c not in cfg for c in ('site_name', 'theme', 'plugins', 'markdown_extensions'))):\n        log.warning(\"The passed config file doesn't seem to be a mkdocs.yml config file\")\n    elif dig(cfg, 'theme.locale') not in (NotFound, 'en'):\n        packages_to_install.add('mkdocs[i18n]')\n    else:\n        packages_to_install.add('mkdocs')\n    try:\n        theme = cfg['theme']['name']\n    except (KeyError, TypeError):\n        theme = cfg.get('theme')\n    themes = {theme} if theme else set()\n    plugins = set(strings(dig(cfg, 'plugins')))\n    extensions = set(strings(dig(cfg, 'markdown_extensions')))\n    wanted_plugins = ((PluginKind('mkdocs_theme', 'mkdocs.themes'), themes - {'mkdocs', 'readthedocs'}), (PluginKind('mkdocs_plugin', 'mkdocs.plugins'), plugins - {'search'}), (PluginKind('markdown_extension', 'markdown.extensions'), extensions))\n    for (kind, wanted) in wanted_plugins:\n        log.debug(f'Wanted {kind}s: {sorted(wanted)}')\n    content = download_and_cache_url(projects_file_url, datetime.timedelta(days=7))\n    projects = yaml.safe_load(content)['projects']\n    for project in projects:\n        for (kind, wanted) in wanted_plugins:\n            available = strings(project.get(kind.projects_key, ()))\n            for entry_name in available:\n                if '/' in entry_name and theme is not None and (kind.projects_key == 'mkdocs_plugin') and entry_name.startswith(f'{theme}/') and (entry_name[len(theme) + 1:] in wanted) and (entry_name not in wanted):\n                    entry_name = entry_name[len(theme) + 1:]\n                if entry_name in wanted:\n                    if 'pypi_id' in project:\n                        install_name = project['pypi_id']\n                    elif 'github_id' in project:\n                        install_name = 'git+https://github.com/{github_id}'.format_map(project)\n                    else:\n                        log.error(f\"Can't find how to install {kind} '{entry_name}' although it was identified as {project}\")\n                        continue\n                    packages_to_install.add(install_name)\n                    for (extra_key, extra_pkgs) in project.get('extra_dependencies', {}).items():\n                        if dig(cfg, extra_key) is not NotFound:\n                            packages_to_install.update(strings(extra_pkgs))\n                    wanted.remove(entry_name)\n    for (kind, wanted) in wanted_plugins:\n        for entry_name in sorted(wanted):\n            dist_name = None\n            ep = _entry_points(kind.entry_points_key).get(entry_name)\n            if ep is not None and ep.dist is not None:\n                dist_name = ep.dist.name\n            if dist_name not in ('mkdocs', 'Markdown'):\n                warning = f\"{str(kind).capitalize()} '{entry_name}' is not provided by any registered project\"\n                if ep is not None:\n                    warning += ' but is installed locally'\n                    if dist_name:\n                        warning += f\" from '{dist_name}'\"\n                    log.info(warning)\n                else:\n                    log.warning(warning)\n    for pkg in sorted(packages_to_install):\n        print(pkg)",
            "def get_deps(projects_file_url: str, config_file_path: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Print PyPI package dependencies inferred from a mkdocs.yml file based on a reverse mapping of known projects.\\n\\n    Args:\\n        projects_file_url: URL or local path of the registry file that declares all known MkDocs-related projects.\\n            The file is in YAML format and contains `projects: [{mkdocs_theme:, mkdocs_plugin:, markdown_extension:}]\\n        config_file_path: Non-default path to mkdocs.yml.\\n    '\n    with _open_config_file(config_file_path) as f:\n        cfg = utils.yaml_load(f, loader=YamlLoader)\n    packages_to_install = set()\n    if all((c not in cfg for c in ('site_name', 'theme', 'plugins', 'markdown_extensions'))):\n        log.warning(\"The passed config file doesn't seem to be a mkdocs.yml config file\")\n    elif dig(cfg, 'theme.locale') not in (NotFound, 'en'):\n        packages_to_install.add('mkdocs[i18n]')\n    else:\n        packages_to_install.add('mkdocs')\n    try:\n        theme = cfg['theme']['name']\n    except (KeyError, TypeError):\n        theme = cfg.get('theme')\n    themes = {theme} if theme else set()\n    plugins = set(strings(dig(cfg, 'plugins')))\n    extensions = set(strings(dig(cfg, 'markdown_extensions')))\n    wanted_plugins = ((PluginKind('mkdocs_theme', 'mkdocs.themes'), themes - {'mkdocs', 'readthedocs'}), (PluginKind('mkdocs_plugin', 'mkdocs.plugins'), plugins - {'search'}), (PluginKind('markdown_extension', 'markdown.extensions'), extensions))\n    for (kind, wanted) in wanted_plugins:\n        log.debug(f'Wanted {kind}s: {sorted(wanted)}')\n    content = download_and_cache_url(projects_file_url, datetime.timedelta(days=7))\n    projects = yaml.safe_load(content)['projects']\n    for project in projects:\n        for (kind, wanted) in wanted_plugins:\n            available = strings(project.get(kind.projects_key, ()))\n            for entry_name in available:\n                if '/' in entry_name and theme is not None and (kind.projects_key == 'mkdocs_plugin') and entry_name.startswith(f'{theme}/') and (entry_name[len(theme) + 1:] in wanted) and (entry_name not in wanted):\n                    entry_name = entry_name[len(theme) + 1:]\n                if entry_name in wanted:\n                    if 'pypi_id' in project:\n                        install_name = project['pypi_id']\n                    elif 'github_id' in project:\n                        install_name = 'git+https://github.com/{github_id}'.format_map(project)\n                    else:\n                        log.error(f\"Can't find how to install {kind} '{entry_name}' although it was identified as {project}\")\n                        continue\n                    packages_to_install.add(install_name)\n                    for (extra_key, extra_pkgs) in project.get('extra_dependencies', {}).items():\n                        if dig(cfg, extra_key) is not NotFound:\n                            packages_to_install.update(strings(extra_pkgs))\n                    wanted.remove(entry_name)\n    for (kind, wanted) in wanted_plugins:\n        for entry_name in sorted(wanted):\n            dist_name = None\n            ep = _entry_points(kind.entry_points_key).get(entry_name)\n            if ep is not None and ep.dist is not None:\n                dist_name = ep.dist.name\n            if dist_name not in ('mkdocs', 'Markdown'):\n                warning = f\"{str(kind).capitalize()} '{entry_name}' is not provided by any registered project\"\n                if ep is not None:\n                    warning += ' but is installed locally'\n                    if dist_name:\n                        warning += f\" from '{dist_name}'\"\n                    log.info(warning)\n                else:\n                    log.warning(warning)\n    for pkg in sorted(packages_to_install):\n        print(pkg)",
            "def get_deps(projects_file_url: str, config_file_path: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Print PyPI package dependencies inferred from a mkdocs.yml file based on a reverse mapping of known projects.\\n\\n    Args:\\n        projects_file_url: URL or local path of the registry file that declares all known MkDocs-related projects.\\n            The file is in YAML format and contains `projects: [{mkdocs_theme:, mkdocs_plugin:, markdown_extension:}]\\n        config_file_path: Non-default path to mkdocs.yml.\\n    '\n    with _open_config_file(config_file_path) as f:\n        cfg = utils.yaml_load(f, loader=YamlLoader)\n    packages_to_install = set()\n    if all((c not in cfg for c in ('site_name', 'theme', 'plugins', 'markdown_extensions'))):\n        log.warning(\"The passed config file doesn't seem to be a mkdocs.yml config file\")\n    elif dig(cfg, 'theme.locale') not in (NotFound, 'en'):\n        packages_to_install.add('mkdocs[i18n]')\n    else:\n        packages_to_install.add('mkdocs')\n    try:\n        theme = cfg['theme']['name']\n    except (KeyError, TypeError):\n        theme = cfg.get('theme')\n    themes = {theme} if theme else set()\n    plugins = set(strings(dig(cfg, 'plugins')))\n    extensions = set(strings(dig(cfg, 'markdown_extensions')))\n    wanted_plugins = ((PluginKind('mkdocs_theme', 'mkdocs.themes'), themes - {'mkdocs', 'readthedocs'}), (PluginKind('mkdocs_plugin', 'mkdocs.plugins'), plugins - {'search'}), (PluginKind('markdown_extension', 'markdown.extensions'), extensions))\n    for (kind, wanted) in wanted_plugins:\n        log.debug(f'Wanted {kind}s: {sorted(wanted)}')\n    content = download_and_cache_url(projects_file_url, datetime.timedelta(days=7))\n    projects = yaml.safe_load(content)['projects']\n    for project in projects:\n        for (kind, wanted) in wanted_plugins:\n            available = strings(project.get(kind.projects_key, ()))\n            for entry_name in available:\n                if '/' in entry_name and theme is not None and (kind.projects_key == 'mkdocs_plugin') and entry_name.startswith(f'{theme}/') and (entry_name[len(theme) + 1:] in wanted) and (entry_name not in wanted):\n                    entry_name = entry_name[len(theme) + 1:]\n                if entry_name in wanted:\n                    if 'pypi_id' in project:\n                        install_name = project['pypi_id']\n                    elif 'github_id' in project:\n                        install_name = 'git+https://github.com/{github_id}'.format_map(project)\n                    else:\n                        log.error(f\"Can't find how to install {kind} '{entry_name}' although it was identified as {project}\")\n                        continue\n                    packages_to_install.add(install_name)\n                    for (extra_key, extra_pkgs) in project.get('extra_dependencies', {}).items():\n                        if dig(cfg, extra_key) is not NotFound:\n                            packages_to_install.update(strings(extra_pkgs))\n                    wanted.remove(entry_name)\n    for (kind, wanted) in wanted_plugins:\n        for entry_name in sorted(wanted):\n            dist_name = None\n            ep = _entry_points(kind.entry_points_key).get(entry_name)\n            if ep is not None and ep.dist is not None:\n                dist_name = ep.dist.name\n            if dist_name not in ('mkdocs', 'Markdown'):\n                warning = f\"{str(kind).capitalize()} '{entry_name}' is not provided by any registered project\"\n                if ep is not None:\n                    warning += ' but is installed locally'\n                    if dist_name:\n                        warning += f\" from '{dist_name}'\"\n                    log.info(warning)\n                else:\n                    log.warning(warning)\n    for pkg in sorted(packages_to_install):\n        print(pkg)",
            "def get_deps(projects_file_url: str, config_file_path: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Print PyPI package dependencies inferred from a mkdocs.yml file based on a reverse mapping of known projects.\\n\\n    Args:\\n        projects_file_url: URL or local path of the registry file that declares all known MkDocs-related projects.\\n            The file is in YAML format and contains `projects: [{mkdocs_theme:, mkdocs_plugin:, markdown_extension:}]\\n        config_file_path: Non-default path to mkdocs.yml.\\n    '\n    with _open_config_file(config_file_path) as f:\n        cfg = utils.yaml_load(f, loader=YamlLoader)\n    packages_to_install = set()\n    if all((c not in cfg for c in ('site_name', 'theme', 'plugins', 'markdown_extensions'))):\n        log.warning(\"The passed config file doesn't seem to be a mkdocs.yml config file\")\n    elif dig(cfg, 'theme.locale') not in (NotFound, 'en'):\n        packages_to_install.add('mkdocs[i18n]')\n    else:\n        packages_to_install.add('mkdocs')\n    try:\n        theme = cfg['theme']['name']\n    except (KeyError, TypeError):\n        theme = cfg.get('theme')\n    themes = {theme} if theme else set()\n    plugins = set(strings(dig(cfg, 'plugins')))\n    extensions = set(strings(dig(cfg, 'markdown_extensions')))\n    wanted_plugins = ((PluginKind('mkdocs_theme', 'mkdocs.themes'), themes - {'mkdocs', 'readthedocs'}), (PluginKind('mkdocs_plugin', 'mkdocs.plugins'), plugins - {'search'}), (PluginKind('markdown_extension', 'markdown.extensions'), extensions))\n    for (kind, wanted) in wanted_plugins:\n        log.debug(f'Wanted {kind}s: {sorted(wanted)}')\n    content = download_and_cache_url(projects_file_url, datetime.timedelta(days=7))\n    projects = yaml.safe_load(content)['projects']\n    for project in projects:\n        for (kind, wanted) in wanted_plugins:\n            available = strings(project.get(kind.projects_key, ()))\n            for entry_name in available:\n                if '/' in entry_name and theme is not None and (kind.projects_key == 'mkdocs_plugin') and entry_name.startswith(f'{theme}/') and (entry_name[len(theme) + 1:] in wanted) and (entry_name not in wanted):\n                    entry_name = entry_name[len(theme) + 1:]\n                if entry_name in wanted:\n                    if 'pypi_id' in project:\n                        install_name = project['pypi_id']\n                    elif 'github_id' in project:\n                        install_name = 'git+https://github.com/{github_id}'.format_map(project)\n                    else:\n                        log.error(f\"Can't find how to install {kind} '{entry_name}' although it was identified as {project}\")\n                        continue\n                    packages_to_install.add(install_name)\n                    for (extra_key, extra_pkgs) in project.get('extra_dependencies', {}).items():\n                        if dig(cfg, extra_key) is not NotFound:\n                            packages_to_install.update(strings(extra_pkgs))\n                    wanted.remove(entry_name)\n    for (kind, wanted) in wanted_plugins:\n        for entry_name in sorted(wanted):\n            dist_name = None\n            ep = _entry_points(kind.entry_points_key).get(entry_name)\n            if ep is not None and ep.dist is not None:\n                dist_name = ep.dist.name\n            if dist_name not in ('mkdocs', 'Markdown'):\n                warning = f\"{str(kind).capitalize()} '{entry_name}' is not provided by any registered project\"\n                if ep is not None:\n                    warning += ' but is installed locally'\n                    if dist_name:\n                        warning += f\" from '{dist_name}'\"\n                    log.info(warning)\n                else:\n                    log.warning(warning)\n    for pkg in sorted(packages_to_install):\n        print(pkg)"
        ]
    }
]