[
    {
        "func_name": "select_ks",
        "original": "def select_ks(index):\n    ks_stack.setCurrentIndex(index)",
        "mutated": [
            "def select_ks(index):\n    if False:\n        i = 10\n    ks_stack.setCurrentIndex(index)",
            "def select_ks(index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ks_stack.setCurrentIndex(index)",
            "def select_ks(index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ks_stack.setCurrentIndex(index)",
            "def select_ks(index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ks_stack.setCurrentIndex(index)",
            "def select_ks(index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ks_stack.setCurrentIndex(index)"
        ]
    },
    {
        "func_name": "label",
        "original": "def label(idx, ks):\n    if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n        return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n    else:\n        return _('keystore') + f' {idx + 1}'",
        "mutated": [
            "def label(idx, ks):\n    if False:\n        i = 10\n    if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n        return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n    else:\n        return _('keystore') + f' {idx + 1}'",
            "def label(idx, ks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n        return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n    else:\n        return _('keystore') + f' {idx + 1}'",
            "def label(idx, ks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n        return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n    else:\n        return _('keystore') + f' {idx + 1}'",
            "def label(idx, ks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n        return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n    else:\n        return _('keystore') + f' {idx + 1}'",
            "def label(idx, ks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n        return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n    else:\n        return _('keystore') + f' {idx + 1}'"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, parent: QWidget, *, window: 'ElectrumWindow'):\n    WindowModalDialog.__init__(self, parent, _('Wallet Information'))\n    self.setMinimumSize(800, 100)\n    wallet = window.wallet\n    config = window.config\n    vbox = QVBoxLayout()\n    wallet_type = wallet.db.get('wallet_type', '')\n    if wallet.is_watching_only():\n        wallet_type += ' [{}]'.format(_('watching-only'))\n    seed_available = _('False')\n    if wallet.has_seed():\n        seed_available = _('True')\n        ks = wallet.keystore\n        assert isinstance(ks, keystore.Deterministic_KeyStore)\n        seed_available += f' ({ks.get_seed_type()})'\n    keystore_types = [k.get_type_text() for k in wallet.get_keystores()]\n    grid = QGridLayout()\n    basename = os.path.basename(wallet.storage.path)\n    cur_row = 0\n    grid.addWidget(WWLabel(_('Wallet name') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(basename), cur_row, 1)\n    cur_row += 1\n    if (db_metadata := wallet.db.get_db_metadata()):\n        grid.addWidget(WWLabel(_('File created') + ':'), cur_row, 0)\n        grid.addWidget(WWLabel(db_metadata.to_str()), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Wallet type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Script type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet.txin_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Seed available') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(str(seed_available)), cur_row, 1)\n    cur_row += 1\n    if len(keystore_types) <= 1:\n        grid.addWidget(WWLabel(_('Keystore type') + ':'), cur_row, 0)\n        ks_type = str(keystore_types[0]) if keystore_types else _('No keystore')\n        grid.addWidget(WWLabel(ks_type), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Lightning') + ':'), cur_row, 0)\n    from .util import IconLabel\n    if wallet.has_lightning():\n        if wallet.lnworker.has_deterministic_node_id():\n            grid.addWidget(WWLabel(_('Enabled')), cur_row, 1)\n        else:\n            label = IconLabel(text='Enabled, non-recoverable channels')\n            label.setIcon(read_QIcon('cloud_no'))\n            grid.addWidget(label, cur_row, 1)\n            if wallet.db.get('seed_type') == 'segwit':\n                msg = _('Your channels cannot be recovered from seed, because they were created with an old version of Electrum. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want this wallet to have recoverable channels, you must close your existing channels and restore this wallet from seed')\n            else:\n                msg = _('Your channels cannot be recovered from seed. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want to have recoverable channels, you must create a new wallet with an Electrum seed')\n            grid.addWidget(HelpButton(msg), cur_row, 3)\n        cur_row += 1\n        grid.addWidget(WWLabel(_('Lightning Node ID:')), cur_row, 0)\n        cur_row += 1\n        nodeid_text = wallet.lnworker.node_keypair.pubkey.hex()\n        nodeid_e = ShowQRLineEdit(nodeid_text, config, title=_('Node ID'))\n        grid.addWidget(nodeid_e, cur_row, 0, 1, 4)\n        cur_row += 1\n    else:\n        if wallet.can_have_lightning():\n            grid.addWidget(WWLabel('Not enabled'), cur_row, 1)\n            button = QPushButton(_('Enable'))\n            button.pressed.connect(lambda : window.init_lightning_dialog(self))\n            grid.addWidget(button, cur_row, 3)\n        else:\n            grid.addWidget(WWLabel(_('Not available for this wallet.')), cur_row, 1)\n            grid.addWidget(HelpButton(_('Lightning is currently restricted to HD wallets with p2wpkh addresses.')), cur_row, 2)\n        cur_row += 1\n    vbox.addLayout(grid)\n    labels_clayout = None\n    if wallet.is_deterministic():\n        keystores = wallet.get_keystores()\n        ks_stack = QStackedWidget()\n\n        def select_ks(index):\n            ks_stack.setCurrentIndex(index)\n        if len(keystores) > 1:\n\n            def label(idx, ks):\n                if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n                    return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n                else:\n                    return _('keystore') + f' {idx + 1}'\n            labels = [label(idx, ks) for (idx, ks) in enumerate(wallet.get_keystores())]\n            on_click = lambda clayout: select_ks(clayout.selected_index())\n            labels_clayout = ChoicesLayout(_('Select keystore'), labels, on_click)\n            vbox.addLayout(labels_clayout.layout())\n        for ks in keystores:\n            ks_w = QWidget()\n            ks_vbox = QVBoxLayout()\n            ks_vbox.setContentsMargins(0, 0, 0, 0)\n            ks_w.setLayout(ks_vbox)\n            mpk_text = ShowQRTextEdit(ks.get_master_public_key(), config=config)\n            mpk_text.setMaximumHeight(max(150, 10 * font_height()))\n            mpk_text.addCopyButton()\n            run_hook('show_xpub_button', mpk_text, ks)\n            ks_vbox.addWidget(WWLabel(_('Master Public Key')))\n            ks_vbox.addWidget(mpk_text)\n            der_path_hbox = QHBoxLayout()\n            der_path_hbox.setContentsMargins(0, 0, 0, 0)\n            der_path_hbox.addWidget(WWLabel(_('Derivation path') + ':'))\n            der_path_text = WWLabel(ks.get_derivation_prefix() or _('unknown'))\n            der_path_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            der_path_hbox.addWidget(der_path_text)\n            der_path_hbox.addStretch()\n            ks_vbox.addLayout(der_path_hbox)\n            bip32fp_hbox = QHBoxLayout()\n            bip32fp_hbox.setContentsMargins(0, 0, 0, 0)\n            bip32fp_hbox.addWidget(QLabel('BIP32 root fingerprint:'))\n            bip32fp_text = WWLabel(ks.get_root_fingerprint() or _('unknown'))\n            bip32fp_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            bip32fp_hbox.addWidget(bip32fp_text)\n            bip32fp_hbox.addStretch()\n            ks_vbox.addLayout(bip32fp_hbox)\n            ks_stack.addWidget(ks_w)\n        select_ks(0)\n        vbox.addWidget(ks_stack)\n    vbox.addStretch(1)\n    btn_export_info = run_hook('wallet_info_buttons', self, self)\n    btn_close = CloseButton(self)\n    btns = Buttons(btn_export_info, btn_close)\n    vbox.addLayout(btns)\n    self.setLayout(vbox)",
        "mutated": [
            "def __init__(self, parent: QWidget, *, window: 'ElectrumWindow'):\n    if False:\n        i = 10\n    WindowModalDialog.__init__(self, parent, _('Wallet Information'))\n    self.setMinimumSize(800, 100)\n    wallet = window.wallet\n    config = window.config\n    vbox = QVBoxLayout()\n    wallet_type = wallet.db.get('wallet_type', '')\n    if wallet.is_watching_only():\n        wallet_type += ' [{}]'.format(_('watching-only'))\n    seed_available = _('False')\n    if wallet.has_seed():\n        seed_available = _('True')\n        ks = wallet.keystore\n        assert isinstance(ks, keystore.Deterministic_KeyStore)\n        seed_available += f' ({ks.get_seed_type()})'\n    keystore_types = [k.get_type_text() for k in wallet.get_keystores()]\n    grid = QGridLayout()\n    basename = os.path.basename(wallet.storage.path)\n    cur_row = 0\n    grid.addWidget(WWLabel(_('Wallet name') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(basename), cur_row, 1)\n    cur_row += 1\n    if (db_metadata := wallet.db.get_db_metadata()):\n        grid.addWidget(WWLabel(_('File created') + ':'), cur_row, 0)\n        grid.addWidget(WWLabel(db_metadata.to_str()), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Wallet type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Script type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet.txin_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Seed available') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(str(seed_available)), cur_row, 1)\n    cur_row += 1\n    if len(keystore_types) <= 1:\n        grid.addWidget(WWLabel(_('Keystore type') + ':'), cur_row, 0)\n        ks_type = str(keystore_types[0]) if keystore_types else _('No keystore')\n        grid.addWidget(WWLabel(ks_type), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Lightning') + ':'), cur_row, 0)\n    from .util import IconLabel\n    if wallet.has_lightning():\n        if wallet.lnworker.has_deterministic_node_id():\n            grid.addWidget(WWLabel(_('Enabled')), cur_row, 1)\n        else:\n            label = IconLabel(text='Enabled, non-recoverable channels')\n            label.setIcon(read_QIcon('cloud_no'))\n            grid.addWidget(label, cur_row, 1)\n            if wallet.db.get('seed_type') == 'segwit':\n                msg = _('Your channels cannot be recovered from seed, because they were created with an old version of Electrum. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want this wallet to have recoverable channels, you must close your existing channels and restore this wallet from seed')\n            else:\n                msg = _('Your channels cannot be recovered from seed. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want to have recoverable channels, you must create a new wallet with an Electrum seed')\n            grid.addWidget(HelpButton(msg), cur_row, 3)\n        cur_row += 1\n        grid.addWidget(WWLabel(_('Lightning Node ID:')), cur_row, 0)\n        cur_row += 1\n        nodeid_text = wallet.lnworker.node_keypair.pubkey.hex()\n        nodeid_e = ShowQRLineEdit(nodeid_text, config, title=_('Node ID'))\n        grid.addWidget(nodeid_e, cur_row, 0, 1, 4)\n        cur_row += 1\n    else:\n        if wallet.can_have_lightning():\n            grid.addWidget(WWLabel('Not enabled'), cur_row, 1)\n            button = QPushButton(_('Enable'))\n            button.pressed.connect(lambda : window.init_lightning_dialog(self))\n            grid.addWidget(button, cur_row, 3)\n        else:\n            grid.addWidget(WWLabel(_('Not available for this wallet.')), cur_row, 1)\n            grid.addWidget(HelpButton(_('Lightning is currently restricted to HD wallets with p2wpkh addresses.')), cur_row, 2)\n        cur_row += 1\n    vbox.addLayout(grid)\n    labels_clayout = None\n    if wallet.is_deterministic():\n        keystores = wallet.get_keystores()\n        ks_stack = QStackedWidget()\n\n        def select_ks(index):\n            ks_stack.setCurrentIndex(index)\n        if len(keystores) > 1:\n\n            def label(idx, ks):\n                if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n                    return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n                else:\n                    return _('keystore') + f' {idx + 1}'\n            labels = [label(idx, ks) for (idx, ks) in enumerate(wallet.get_keystores())]\n            on_click = lambda clayout: select_ks(clayout.selected_index())\n            labels_clayout = ChoicesLayout(_('Select keystore'), labels, on_click)\n            vbox.addLayout(labels_clayout.layout())\n        for ks in keystores:\n            ks_w = QWidget()\n            ks_vbox = QVBoxLayout()\n            ks_vbox.setContentsMargins(0, 0, 0, 0)\n            ks_w.setLayout(ks_vbox)\n            mpk_text = ShowQRTextEdit(ks.get_master_public_key(), config=config)\n            mpk_text.setMaximumHeight(max(150, 10 * font_height()))\n            mpk_text.addCopyButton()\n            run_hook('show_xpub_button', mpk_text, ks)\n            ks_vbox.addWidget(WWLabel(_('Master Public Key')))\n            ks_vbox.addWidget(mpk_text)\n            der_path_hbox = QHBoxLayout()\n            der_path_hbox.setContentsMargins(0, 0, 0, 0)\n            der_path_hbox.addWidget(WWLabel(_('Derivation path') + ':'))\n            der_path_text = WWLabel(ks.get_derivation_prefix() or _('unknown'))\n            der_path_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            der_path_hbox.addWidget(der_path_text)\n            der_path_hbox.addStretch()\n            ks_vbox.addLayout(der_path_hbox)\n            bip32fp_hbox = QHBoxLayout()\n            bip32fp_hbox.setContentsMargins(0, 0, 0, 0)\n            bip32fp_hbox.addWidget(QLabel('BIP32 root fingerprint:'))\n            bip32fp_text = WWLabel(ks.get_root_fingerprint() or _('unknown'))\n            bip32fp_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            bip32fp_hbox.addWidget(bip32fp_text)\n            bip32fp_hbox.addStretch()\n            ks_vbox.addLayout(bip32fp_hbox)\n            ks_stack.addWidget(ks_w)\n        select_ks(0)\n        vbox.addWidget(ks_stack)\n    vbox.addStretch(1)\n    btn_export_info = run_hook('wallet_info_buttons', self, self)\n    btn_close = CloseButton(self)\n    btns = Buttons(btn_export_info, btn_close)\n    vbox.addLayout(btns)\n    self.setLayout(vbox)",
            "def __init__(self, parent: QWidget, *, window: 'ElectrumWindow'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    WindowModalDialog.__init__(self, parent, _('Wallet Information'))\n    self.setMinimumSize(800, 100)\n    wallet = window.wallet\n    config = window.config\n    vbox = QVBoxLayout()\n    wallet_type = wallet.db.get('wallet_type', '')\n    if wallet.is_watching_only():\n        wallet_type += ' [{}]'.format(_('watching-only'))\n    seed_available = _('False')\n    if wallet.has_seed():\n        seed_available = _('True')\n        ks = wallet.keystore\n        assert isinstance(ks, keystore.Deterministic_KeyStore)\n        seed_available += f' ({ks.get_seed_type()})'\n    keystore_types = [k.get_type_text() for k in wallet.get_keystores()]\n    grid = QGridLayout()\n    basename = os.path.basename(wallet.storage.path)\n    cur_row = 0\n    grid.addWidget(WWLabel(_('Wallet name') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(basename), cur_row, 1)\n    cur_row += 1\n    if (db_metadata := wallet.db.get_db_metadata()):\n        grid.addWidget(WWLabel(_('File created') + ':'), cur_row, 0)\n        grid.addWidget(WWLabel(db_metadata.to_str()), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Wallet type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Script type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet.txin_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Seed available') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(str(seed_available)), cur_row, 1)\n    cur_row += 1\n    if len(keystore_types) <= 1:\n        grid.addWidget(WWLabel(_('Keystore type') + ':'), cur_row, 0)\n        ks_type = str(keystore_types[0]) if keystore_types else _('No keystore')\n        grid.addWidget(WWLabel(ks_type), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Lightning') + ':'), cur_row, 0)\n    from .util import IconLabel\n    if wallet.has_lightning():\n        if wallet.lnworker.has_deterministic_node_id():\n            grid.addWidget(WWLabel(_('Enabled')), cur_row, 1)\n        else:\n            label = IconLabel(text='Enabled, non-recoverable channels')\n            label.setIcon(read_QIcon('cloud_no'))\n            grid.addWidget(label, cur_row, 1)\n            if wallet.db.get('seed_type') == 'segwit':\n                msg = _('Your channels cannot be recovered from seed, because they were created with an old version of Electrum. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want this wallet to have recoverable channels, you must close your existing channels and restore this wallet from seed')\n            else:\n                msg = _('Your channels cannot be recovered from seed. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want to have recoverable channels, you must create a new wallet with an Electrum seed')\n            grid.addWidget(HelpButton(msg), cur_row, 3)\n        cur_row += 1\n        grid.addWidget(WWLabel(_('Lightning Node ID:')), cur_row, 0)\n        cur_row += 1\n        nodeid_text = wallet.lnworker.node_keypair.pubkey.hex()\n        nodeid_e = ShowQRLineEdit(nodeid_text, config, title=_('Node ID'))\n        grid.addWidget(nodeid_e, cur_row, 0, 1, 4)\n        cur_row += 1\n    else:\n        if wallet.can_have_lightning():\n            grid.addWidget(WWLabel('Not enabled'), cur_row, 1)\n            button = QPushButton(_('Enable'))\n            button.pressed.connect(lambda : window.init_lightning_dialog(self))\n            grid.addWidget(button, cur_row, 3)\n        else:\n            grid.addWidget(WWLabel(_('Not available for this wallet.')), cur_row, 1)\n            grid.addWidget(HelpButton(_('Lightning is currently restricted to HD wallets with p2wpkh addresses.')), cur_row, 2)\n        cur_row += 1\n    vbox.addLayout(grid)\n    labels_clayout = None\n    if wallet.is_deterministic():\n        keystores = wallet.get_keystores()\n        ks_stack = QStackedWidget()\n\n        def select_ks(index):\n            ks_stack.setCurrentIndex(index)\n        if len(keystores) > 1:\n\n            def label(idx, ks):\n                if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n                    return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n                else:\n                    return _('keystore') + f' {idx + 1}'\n            labels = [label(idx, ks) for (idx, ks) in enumerate(wallet.get_keystores())]\n            on_click = lambda clayout: select_ks(clayout.selected_index())\n            labels_clayout = ChoicesLayout(_('Select keystore'), labels, on_click)\n            vbox.addLayout(labels_clayout.layout())\n        for ks in keystores:\n            ks_w = QWidget()\n            ks_vbox = QVBoxLayout()\n            ks_vbox.setContentsMargins(0, 0, 0, 0)\n            ks_w.setLayout(ks_vbox)\n            mpk_text = ShowQRTextEdit(ks.get_master_public_key(), config=config)\n            mpk_text.setMaximumHeight(max(150, 10 * font_height()))\n            mpk_text.addCopyButton()\n            run_hook('show_xpub_button', mpk_text, ks)\n            ks_vbox.addWidget(WWLabel(_('Master Public Key')))\n            ks_vbox.addWidget(mpk_text)\n            der_path_hbox = QHBoxLayout()\n            der_path_hbox.setContentsMargins(0, 0, 0, 0)\n            der_path_hbox.addWidget(WWLabel(_('Derivation path') + ':'))\n            der_path_text = WWLabel(ks.get_derivation_prefix() or _('unknown'))\n            der_path_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            der_path_hbox.addWidget(der_path_text)\n            der_path_hbox.addStretch()\n            ks_vbox.addLayout(der_path_hbox)\n            bip32fp_hbox = QHBoxLayout()\n            bip32fp_hbox.setContentsMargins(0, 0, 0, 0)\n            bip32fp_hbox.addWidget(QLabel('BIP32 root fingerprint:'))\n            bip32fp_text = WWLabel(ks.get_root_fingerprint() or _('unknown'))\n            bip32fp_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            bip32fp_hbox.addWidget(bip32fp_text)\n            bip32fp_hbox.addStretch()\n            ks_vbox.addLayout(bip32fp_hbox)\n            ks_stack.addWidget(ks_w)\n        select_ks(0)\n        vbox.addWidget(ks_stack)\n    vbox.addStretch(1)\n    btn_export_info = run_hook('wallet_info_buttons', self, self)\n    btn_close = CloseButton(self)\n    btns = Buttons(btn_export_info, btn_close)\n    vbox.addLayout(btns)\n    self.setLayout(vbox)",
            "def __init__(self, parent: QWidget, *, window: 'ElectrumWindow'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    WindowModalDialog.__init__(self, parent, _('Wallet Information'))\n    self.setMinimumSize(800, 100)\n    wallet = window.wallet\n    config = window.config\n    vbox = QVBoxLayout()\n    wallet_type = wallet.db.get('wallet_type', '')\n    if wallet.is_watching_only():\n        wallet_type += ' [{}]'.format(_('watching-only'))\n    seed_available = _('False')\n    if wallet.has_seed():\n        seed_available = _('True')\n        ks = wallet.keystore\n        assert isinstance(ks, keystore.Deterministic_KeyStore)\n        seed_available += f' ({ks.get_seed_type()})'\n    keystore_types = [k.get_type_text() for k in wallet.get_keystores()]\n    grid = QGridLayout()\n    basename = os.path.basename(wallet.storage.path)\n    cur_row = 0\n    grid.addWidget(WWLabel(_('Wallet name') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(basename), cur_row, 1)\n    cur_row += 1\n    if (db_metadata := wallet.db.get_db_metadata()):\n        grid.addWidget(WWLabel(_('File created') + ':'), cur_row, 0)\n        grid.addWidget(WWLabel(db_metadata.to_str()), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Wallet type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Script type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet.txin_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Seed available') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(str(seed_available)), cur_row, 1)\n    cur_row += 1\n    if len(keystore_types) <= 1:\n        grid.addWidget(WWLabel(_('Keystore type') + ':'), cur_row, 0)\n        ks_type = str(keystore_types[0]) if keystore_types else _('No keystore')\n        grid.addWidget(WWLabel(ks_type), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Lightning') + ':'), cur_row, 0)\n    from .util import IconLabel\n    if wallet.has_lightning():\n        if wallet.lnworker.has_deterministic_node_id():\n            grid.addWidget(WWLabel(_('Enabled')), cur_row, 1)\n        else:\n            label = IconLabel(text='Enabled, non-recoverable channels')\n            label.setIcon(read_QIcon('cloud_no'))\n            grid.addWidget(label, cur_row, 1)\n            if wallet.db.get('seed_type') == 'segwit':\n                msg = _('Your channels cannot be recovered from seed, because they were created with an old version of Electrum. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want this wallet to have recoverable channels, you must close your existing channels and restore this wallet from seed')\n            else:\n                msg = _('Your channels cannot be recovered from seed. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want to have recoverable channels, you must create a new wallet with an Electrum seed')\n            grid.addWidget(HelpButton(msg), cur_row, 3)\n        cur_row += 1\n        grid.addWidget(WWLabel(_('Lightning Node ID:')), cur_row, 0)\n        cur_row += 1\n        nodeid_text = wallet.lnworker.node_keypair.pubkey.hex()\n        nodeid_e = ShowQRLineEdit(nodeid_text, config, title=_('Node ID'))\n        grid.addWidget(nodeid_e, cur_row, 0, 1, 4)\n        cur_row += 1\n    else:\n        if wallet.can_have_lightning():\n            grid.addWidget(WWLabel('Not enabled'), cur_row, 1)\n            button = QPushButton(_('Enable'))\n            button.pressed.connect(lambda : window.init_lightning_dialog(self))\n            grid.addWidget(button, cur_row, 3)\n        else:\n            grid.addWidget(WWLabel(_('Not available for this wallet.')), cur_row, 1)\n            grid.addWidget(HelpButton(_('Lightning is currently restricted to HD wallets with p2wpkh addresses.')), cur_row, 2)\n        cur_row += 1\n    vbox.addLayout(grid)\n    labels_clayout = None\n    if wallet.is_deterministic():\n        keystores = wallet.get_keystores()\n        ks_stack = QStackedWidget()\n\n        def select_ks(index):\n            ks_stack.setCurrentIndex(index)\n        if len(keystores) > 1:\n\n            def label(idx, ks):\n                if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n                    return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n                else:\n                    return _('keystore') + f' {idx + 1}'\n            labels = [label(idx, ks) for (idx, ks) in enumerate(wallet.get_keystores())]\n            on_click = lambda clayout: select_ks(clayout.selected_index())\n            labels_clayout = ChoicesLayout(_('Select keystore'), labels, on_click)\n            vbox.addLayout(labels_clayout.layout())\n        for ks in keystores:\n            ks_w = QWidget()\n            ks_vbox = QVBoxLayout()\n            ks_vbox.setContentsMargins(0, 0, 0, 0)\n            ks_w.setLayout(ks_vbox)\n            mpk_text = ShowQRTextEdit(ks.get_master_public_key(), config=config)\n            mpk_text.setMaximumHeight(max(150, 10 * font_height()))\n            mpk_text.addCopyButton()\n            run_hook('show_xpub_button', mpk_text, ks)\n            ks_vbox.addWidget(WWLabel(_('Master Public Key')))\n            ks_vbox.addWidget(mpk_text)\n            der_path_hbox = QHBoxLayout()\n            der_path_hbox.setContentsMargins(0, 0, 0, 0)\n            der_path_hbox.addWidget(WWLabel(_('Derivation path') + ':'))\n            der_path_text = WWLabel(ks.get_derivation_prefix() or _('unknown'))\n            der_path_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            der_path_hbox.addWidget(der_path_text)\n            der_path_hbox.addStretch()\n            ks_vbox.addLayout(der_path_hbox)\n            bip32fp_hbox = QHBoxLayout()\n            bip32fp_hbox.setContentsMargins(0, 0, 0, 0)\n            bip32fp_hbox.addWidget(QLabel('BIP32 root fingerprint:'))\n            bip32fp_text = WWLabel(ks.get_root_fingerprint() or _('unknown'))\n            bip32fp_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            bip32fp_hbox.addWidget(bip32fp_text)\n            bip32fp_hbox.addStretch()\n            ks_vbox.addLayout(bip32fp_hbox)\n            ks_stack.addWidget(ks_w)\n        select_ks(0)\n        vbox.addWidget(ks_stack)\n    vbox.addStretch(1)\n    btn_export_info = run_hook('wallet_info_buttons', self, self)\n    btn_close = CloseButton(self)\n    btns = Buttons(btn_export_info, btn_close)\n    vbox.addLayout(btns)\n    self.setLayout(vbox)",
            "def __init__(self, parent: QWidget, *, window: 'ElectrumWindow'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    WindowModalDialog.__init__(self, parent, _('Wallet Information'))\n    self.setMinimumSize(800, 100)\n    wallet = window.wallet\n    config = window.config\n    vbox = QVBoxLayout()\n    wallet_type = wallet.db.get('wallet_type', '')\n    if wallet.is_watching_only():\n        wallet_type += ' [{}]'.format(_('watching-only'))\n    seed_available = _('False')\n    if wallet.has_seed():\n        seed_available = _('True')\n        ks = wallet.keystore\n        assert isinstance(ks, keystore.Deterministic_KeyStore)\n        seed_available += f' ({ks.get_seed_type()})'\n    keystore_types = [k.get_type_text() for k in wallet.get_keystores()]\n    grid = QGridLayout()\n    basename = os.path.basename(wallet.storage.path)\n    cur_row = 0\n    grid.addWidget(WWLabel(_('Wallet name') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(basename), cur_row, 1)\n    cur_row += 1\n    if (db_metadata := wallet.db.get_db_metadata()):\n        grid.addWidget(WWLabel(_('File created') + ':'), cur_row, 0)\n        grid.addWidget(WWLabel(db_metadata.to_str()), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Wallet type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Script type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet.txin_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Seed available') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(str(seed_available)), cur_row, 1)\n    cur_row += 1\n    if len(keystore_types) <= 1:\n        grid.addWidget(WWLabel(_('Keystore type') + ':'), cur_row, 0)\n        ks_type = str(keystore_types[0]) if keystore_types else _('No keystore')\n        grid.addWidget(WWLabel(ks_type), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Lightning') + ':'), cur_row, 0)\n    from .util import IconLabel\n    if wallet.has_lightning():\n        if wallet.lnworker.has_deterministic_node_id():\n            grid.addWidget(WWLabel(_('Enabled')), cur_row, 1)\n        else:\n            label = IconLabel(text='Enabled, non-recoverable channels')\n            label.setIcon(read_QIcon('cloud_no'))\n            grid.addWidget(label, cur_row, 1)\n            if wallet.db.get('seed_type') == 'segwit':\n                msg = _('Your channels cannot be recovered from seed, because they were created with an old version of Electrum. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want this wallet to have recoverable channels, you must close your existing channels and restore this wallet from seed')\n            else:\n                msg = _('Your channels cannot be recovered from seed. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want to have recoverable channels, you must create a new wallet with an Electrum seed')\n            grid.addWidget(HelpButton(msg), cur_row, 3)\n        cur_row += 1\n        grid.addWidget(WWLabel(_('Lightning Node ID:')), cur_row, 0)\n        cur_row += 1\n        nodeid_text = wallet.lnworker.node_keypair.pubkey.hex()\n        nodeid_e = ShowQRLineEdit(nodeid_text, config, title=_('Node ID'))\n        grid.addWidget(nodeid_e, cur_row, 0, 1, 4)\n        cur_row += 1\n    else:\n        if wallet.can_have_lightning():\n            grid.addWidget(WWLabel('Not enabled'), cur_row, 1)\n            button = QPushButton(_('Enable'))\n            button.pressed.connect(lambda : window.init_lightning_dialog(self))\n            grid.addWidget(button, cur_row, 3)\n        else:\n            grid.addWidget(WWLabel(_('Not available for this wallet.')), cur_row, 1)\n            grid.addWidget(HelpButton(_('Lightning is currently restricted to HD wallets with p2wpkh addresses.')), cur_row, 2)\n        cur_row += 1\n    vbox.addLayout(grid)\n    labels_clayout = None\n    if wallet.is_deterministic():\n        keystores = wallet.get_keystores()\n        ks_stack = QStackedWidget()\n\n        def select_ks(index):\n            ks_stack.setCurrentIndex(index)\n        if len(keystores) > 1:\n\n            def label(idx, ks):\n                if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n                    return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n                else:\n                    return _('keystore') + f' {idx + 1}'\n            labels = [label(idx, ks) for (idx, ks) in enumerate(wallet.get_keystores())]\n            on_click = lambda clayout: select_ks(clayout.selected_index())\n            labels_clayout = ChoicesLayout(_('Select keystore'), labels, on_click)\n            vbox.addLayout(labels_clayout.layout())\n        for ks in keystores:\n            ks_w = QWidget()\n            ks_vbox = QVBoxLayout()\n            ks_vbox.setContentsMargins(0, 0, 0, 0)\n            ks_w.setLayout(ks_vbox)\n            mpk_text = ShowQRTextEdit(ks.get_master_public_key(), config=config)\n            mpk_text.setMaximumHeight(max(150, 10 * font_height()))\n            mpk_text.addCopyButton()\n            run_hook('show_xpub_button', mpk_text, ks)\n            ks_vbox.addWidget(WWLabel(_('Master Public Key')))\n            ks_vbox.addWidget(mpk_text)\n            der_path_hbox = QHBoxLayout()\n            der_path_hbox.setContentsMargins(0, 0, 0, 0)\n            der_path_hbox.addWidget(WWLabel(_('Derivation path') + ':'))\n            der_path_text = WWLabel(ks.get_derivation_prefix() or _('unknown'))\n            der_path_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            der_path_hbox.addWidget(der_path_text)\n            der_path_hbox.addStretch()\n            ks_vbox.addLayout(der_path_hbox)\n            bip32fp_hbox = QHBoxLayout()\n            bip32fp_hbox.setContentsMargins(0, 0, 0, 0)\n            bip32fp_hbox.addWidget(QLabel('BIP32 root fingerprint:'))\n            bip32fp_text = WWLabel(ks.get_root_fingerprint() or _('unknown'))\n            bip32fp_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            bip32fp_hbox.addWidget(bip32fp_text)\n            bip32fp_hbox.addStretch()\n            ks_vbox.addLayout(bip32fp_hbox)\n            ks_stack.addWidget(ks_w)\n        select_ks(0)\n        vbox.addWidget(ks_stack)\n    vbox.addStretch(1)\n    btn_export_info = run_hook('wallet_info_buttons', self, self)\n    btn_close = CloseButton(self)\n    btns = Buttons(btn_export_info, btn_close)\n    vbox.addLayout(btns)\n    self.setLayout(vbox)",
            "def __init__(self, parent: QWidget, *, window: 'ElectrumWindow'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    WindowModalDialog.__init__(self, parent, _('Wallet Information'))\n    self.setMinimumSize(800, 100)\n    wallet = window.wallet\n    config = window.config\n    vbox = QVBoxLayout()\n    wallet_type = wallet.db.get('wallet_type', '')\n    if wallet.is_watching_only():\n        wallet_type += ' [{}]'.format(_('watching-only'))\n    seed_available = _('False')\n    if wallet.has_seed():\n        seed_available = _('True')\n        ks = wallet.keystore\n        assert isinstance(ks, keystore.Deterministic_KeyStore)\n        seed_available += f' ({ks.get_seed_type()})'\n    keystore_types = [k.get_type_text() for k in wallet.get_keystores()]\n    grid = QGridLayout()\n    basename = os.path.basename(wallet.storage.path)\n    cur_row = 0\n    grid.addWidget(WWLabel(_('Wallet name') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(basename), cur_row, 1)\n    cur_row += 1\n    if (db_metadata := wallet.db.get_db_metadata()):\n        grid.addWidget(WWLabel(_('File created') + ':'), cur_row, 0)\n        grid.addWidget(WWLabel(db_metadata.to_str()), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Wallet type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Script type') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(wallet.txin_type), cur_row, 1)\n    cur_row += 1\n    grid.addWidget(WWLabel(_('Seed available') + ':'), cur_row, 0)\n    grid.addWidget(WWLabel(str(seed_available)), cur_row, 1)\n    cur_row += 1\n    if len(keystore_types) <= 1:\n        grid.addWidget(WWLabel(_('Keystore type') + ':'), cur_row, 0)\n        ks_type = str(keystore_types[0]) if keystore_types else _('No keystore')\n        grid.addWidget(WWLabel(ks_type), cur_row, 1)\n        cur_row += 1\n    grid.addWidget(WWLabel(_('Lightning') + ':'), cur_row, 0)\n    from .util import IconLabel\n    if wallet.has_lightning():\n        if wallet.lnworker.has_deterministic_node_id():\n            grid.addWidget(WWLabel(_('Enabled')), cur_row, 1)\n        else:\n            label = IconLabel(text='Enabled, non-recoverable channels')\n            label.setIcon(read_QIcon('cloud_no'))\n            grid.addWidget(label, cur_row, 1)\n            if wallet.db.get('seed_type') == 'segwit':\n                msg = _('Your channels cannot be recovered from seed, because they were created with an old version of Electrum. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want this wallet to have recoverable channels, you must close your existing channels and restore this wallet from seed')\n            else:\n                msg = _('Your channels cannot be recovered from seed. This means that you must save a backup of your wallet everytime you create a new channel.\\n\\nIf you want to have recoverable channels, you must create a new wallet with an Electrum seed')\n            grid.addWidget(HelpButton(msg), cur_row, 3)\n        cur_row += 1\n        grid.addWidget(WWLabel(_('Lightning Node ID:')), cur_row, 0)\n        cur_row += 1\n        nodeid_text = wallet.lnworker.node_keypair.pubkey.hex()\n        nodeid_e = ShowQRLineEdit(nodeid_text, config, title=_('Node ID'))\n        grid.addWidget(nodeid_e, cur_row, 0, 1, 4)\n        cur_row += 1\n    else:\n        if wallet.can_have_lightning():\n            grid.addWidget(WWLabel('Not enabled'), cur_row, 1)\n            button = QPushButton(_('Enable'))\n            button.pressed.connect(lambda : window.init_lightning_dialog(self))\n            grid.addWidget(button, cur_row, 3)\n        else:\n            grid.addWidget(WWLabel(_('Not available for this wallet.')), cur_row, 1)\n            grid.addWidget(HelpButton(_('Lightning is currently restricted to HD wallets with p2wpkh addresses.')), cur_row, 2)\n        cur_row += 1\n    vbox.addLayout(grid)\n    labels_clayout = None\n    if wallet.is_deterministic():\n        keystores = wallet.get_keystores()\n        ks_stack = QStackedWidget()\n\n        def select_ks(index):\n            ks_stack.setCurrentIndex(index)\n        if len(keystores) > 1:\n\n            def label(idx, ks):\n                if isinstance(wallet, Multisig_Wallet) and hasattr(ks, 'label'):\n                    return _('cosigner') + f' {idx + 1}: {ks.get_type_text()} {ks.label}'\n                else:\n                    return _('keystore') + f' {idx + 1}'\n            labels = [label(idx, ks) for (idx, ks) in enumerate(wallet.get_keystores())]\n            on_click = lambda clayout: select_ks(clayout.selected_index())\n            labels_clayout = ChoicesLayout(_('Select keystore'), labels, on_click)\n            vbox.addLayout(labels_clayout.layout())\n        for ks in keystores:\n            ks_w = QWidget()\n            ks_vbox = QVBoxLayout()\n            ks_vbox.setContentsMargins(0, 0, 0, 0)\n            ks_w.setLayout(ks_vbox)\n            mpk_text = ShowQRTextEdit(ks.get_master_public_key(), config=config)\n            mpk_text.setMaximumHeight(max(150, 10 * font_height()))\n            mpk_text.addCopyButton()\n            run_hook('show_xpub_button', mpk_text, ks)\n            ks_vbox.addWidget(WWLabel(_('Master Public Key')))\n            ks_vbox.addWidget(mpk_text)\n            der_path_hbox = QHBoxLayout()\n            der_path_hbox.setContentsMargins(0, 0, 0, 0)\n            der_path_hbox.addWidget(WWLabel(_('Derivation path') + ':'))\n            der_path_text = WWLabel(ks.get_derivation_prefix() or _('unknown'))\n            der_path_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            der_path_hbox.addWidget(der_path_text)\n            der_path_hbox.addStretch()\n            ks_vbox.addLayout(der_path_hbox)\n            bip32fp_hbox = QHBoxLayout()\n            bip32fp_hbox.setContentsMargins(0, 0, 0, 0)\n            bip32fp_hbox.addWidget(QLabel('BIP32 root fingerprint:'))\n            bip32fp_text = WWLabel(ks.get_root_fingerprint() or _('unknown'))\n            bip32fp_text.setTextInteractionFlags(Qt.TextSelectableByMouse)\n            bip32fp_hbox.addWidget(bip32fp_text)\n            bip32fp_hbox.addStretch()\n            ks_vbox.addLayout(bip32fp_hbox)\n            ks_stack.addWidget(ks_w)\n        select_ks(0)\n        vbox.addWidget(ks_stack)\n    vbox.addStretch(1)\n    btn_export_info = run_hook('wallet_info_buttons', self, self)\n    btn_close = CloseButton(self)\n    btns = Buttons(btn_export_info, btn_close)\n    vbox.addLayout(btns)\n    self.setLayout(vbox)"
        ]
    }
]