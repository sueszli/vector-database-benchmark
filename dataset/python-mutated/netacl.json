[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    This module requires both NAPALM and Capirca.\n    \"\"\"\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl state cannot be loaded: Please install capirca and napalm.')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl state cannot be loaded: Please install capirca and napalm.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl state cannot be loaded: Please install capirca and napalm.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl state cannot be loaded: Please install capirca and napalm.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl state cannot be loaded: Please install capirca and napalm.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl state cannot be loaded: Please install capirca and napalm.')"
        ]
    },
    {
        "func_name": "term",
        "original": "def term(name, filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    \"\"\"\n    Manage the configuration of a specific policy term.\n\n    filter_name\n        The name of the policy filter.\n\n    term_name\n        The name of the term.\n\n    filter_options\n        Additional filter options. These options are platform-specific.\n        See the complete list of options_.\n\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\n\n    pillar_key: ``acl``\n        The key in the pillar containing the default attributes values. Default: ``acl``.\n\n    pillarenv\n        Query the master to generate fresh pillar data on the fly,\n        specifically from the requested pillar environment.\n\n    saltenv\n        Included only for compatibility with\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\n\n    merge_pillar: ``False``\n        Merge the CLI variables with the pillar. Default: ``False``.\n\n        The properties specified through the state arguments have higher priority than the pillar.\n\n    revision_id\n        Add a comment in the term config having the description for the changes applied.\n\n    revision_no\n        The revision count.\n\n    revision_date: ``True``\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\n\n    revision_date_format: ``%Y/%m/%d``\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\n        Default: ``False`` and will commit the changes on the device.\n\n    commit: ``True``\n        Commit? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw configuration loaded on the device.\n\n    source_service\n        A special service to choose from. This is a helper so the user is able to\n        select a source just using the name, instead of specifying a source_port and protocol.\n\n        As this module is available on Unix platforms only,\n        it reads the IANA_ port assignment from /etc/services.\n\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\n        which can be managed using the :mod:`file state <salt.states.file>`.\n\n        .. _IANA: http://www.iana.org/assignments/port-numbers\n\n    destination_service\n        A special service to choose from. This is a helper so the user is able to\n        select a source just using the name, instead of specifying a destination_port and protocol.\n        Allows the same options as ``source_service``.\n\n    term_fields\n        Term attributes. To see what fields are supported, please consult the\n        list of supported keywords_. Some platforms have few other optional_\n        keywords.\n\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\n\n    .. note::\n        The following fields are accepted:\n\n        - action\n        - address\n        - address_exclude\n        - comment\n        - counter\n        - expiration\n        - destination_address\n        - destination_address_exclude\n        - destination_port\n        - destination_prefix\n        - forwarding_class\n        - forwarding_class_except\n        - logging\n        - log_name\n        - loss_priority\n        - option\n        - policer\n        - port\n        - precedence\n        - principals\n        - protocol\n        - protocol_except\n        - qos\n        - pan_application\n        - routing_instance\n        - source_address\n        - source_address_exclude\n        - source_port\n        - source_prefix\n        - verbatim\n        - packet_length\n        - fragment_offset\n        - hop_limit\n        - icmp_type\n        - ether_type\n        - traffic_class_count\n        - traffic_type\n        - translated\n        - dscp_set\n        - dscp_match\n        - dscp_except\n        - next_ip\n        - flexible_match_range\n        - source_prefix_except\n        - destination_prefix_except\n        - vpn\n        - source_tag\n        - destination_tag\n        - source_interface\n        - destination_interface\n        - flattened\n        - flattened_addr\n        - flattened_saddr\n        - flattened_daddr\n        - priority\n\n    .. note::\n        The following fields can be also a single value and a list of values:\n\n        - action\n        - address\n        - address_exclude\n        - comment\n        - destination_address\n        - destination_address_exclude\n        - destination_port\n        - destination_prefix\n        - forwarding_class\n        - forwarding_class_except\n        - logging\n        - option\n        - port\n        - precedence\n        - principals\n        - protocol\n        - protocol_except\n        - pan_application\n        - source_address\n        - source_address_exclude\n        - source_port\n        - source_prefix\n        - verbatim\n        - icmp_type\n        - ether_type\n        - traffic_type\n        - dscp_match\n        - dscp_except\n        - flexible_match_range\n        - source_prefix_except\n        - destination_prefix_except\n        - source_tag\n        - destination_tag\n        - source_service\n        - destination_service\n\n        Example: ``destination_address`` can be either defined as:\n\n        .. code-block:: yaml\n\n            destination_address: 172.17.17.1/24\n\n        or as a list of destination IP addresses:\n\n        .. code-block:: yaml\n\n            destination_address:\n                - 172.17.17.1/24\n                - 172.17.19.1/24\n\n        or a list of services to be matched:\n\n        .. code-block:: yaml\n\n            source_service:\n                - ntp\n                - snmp\n                - ldap\n                - bgpd\n\n    .. note::\n        The port fields ``source_port`` and ``destination_port`` can be used as\n        above to select either a single value, either a list of values, but\n        also they can select port ranges. Example:\n\n        .. code-block:: yaml\n\n            source_port:\n                - [1000, 2000]\n                - [3000, 4000]\n\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt 'edge01.bjm01' state.sls router.acl\n\n    Output Example:\n\n    .. code-block:: text\n\n        edge01.bjm01:\n        ----------\n                  ID: update_icmp_first_term\n            Function: netacl.term\n              Result: None\n             Comment: Testing mode: Configuration discarded.\n             Started: 12:49:09.174179\n            Duration: 5751.882 ms\n             Changes:\n                      ----------\n                      diff:\n                          [edit firewall]\n                          +    family inet {\n                          +        /*\n                          +         ** $Id: update_icmp_first_term $\n                          +         ** $Date: 2017/02/30 $\n                          +         **\n                          +         */\n                          +        filter block-icmp {\n                          +            term first-term {\n                          +                from {\n                          +                    protocol icmp;\n                          +                }\n                          +                then {\n                          +                    reject;\n                          +                }\n                          +            }\n                          +        }\n                          +    }\n\n        Summary for edge01.bjm01\n        ------------\n        Succeeded: 1 (unchanged=1, changed=1)\n        Failed:    0\n        ------------\n        Total states run:     1\n        Total run time:   5.752 s\n\n    Pillar example:\n\n    .. code-block:: yaml\n\n        firewall:\n          - block-icmp:\n              terms:\n                - first-term:\n                    protocol:\n                      - icmp\n                    action: reject\n\n    State SLS example:\n\n    .. code-block:: jinja\n\n        {%- set filter_name = 'block-icmp' -%}\n        {%- set term_name = 'first-term' -%}\n        {%- set my_term_cfg = salt.netacl.get_term_pillar(filter_name, term_name) -%}\n\n        update_icmp_first_term:\n          netacl.term:\n            - filter_name: {{ filter_name }}\n            - filter_options:\n                - not-interface-specific\n            - term_name: {{ term_name }}\n            - {{ my_term_cfg | json }}\n\n    Or directly referencing the pillar keys:\n\n    .. code-block:: yaml\n\n        update_icmp_first_term:\n          netacl.term:\n            - filter_name: block-icmp\n            - filter_options:\n                - not-interface-specific\n            - term_name: first-term\n            - merge_pillar: true\n\n    .. note::\n        The first method allows the user to eventually apply complex manipulation\n        and / or retrieve the data from external services before passing the\n        data to the state. The second one is more straightforward, for less\n        complex cases when loading the data directly from the pillar is sufficient.\n\n    .. note::\n        When passing retrieved pillar data into the state file, it is strongly\n        recommended to use the json serializer explicitly (`` | json``),\n        instead of relying on the default Python serializer.\n    \"\"\"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    loaded = __salt__['netacl.load_term_config'](filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, test=test, commit=commit, debug=debug, **term_fields)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
        "mutated": [
            "def term(name, filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n    \"\\n    Manage the configuration of a specific policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the CLI variables with the pillar. Default: ``False``.\\n\\n        The properties specified through the state arguments have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as\\n        above to select either a single value, either a list of values, but\\n        also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - [1000, 2000]\\n                - [3000, 4000]\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        ----------\\n                  ID: update_icmp_first_term\\n            Function: netacl.term\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:49:09.174179\\n            Duration: 5751.882 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit firewall]\\n                          +    family inet {\\n                          +        /*\\n                          +         ** $Id: update_icmp_first_term $\\n                          +         ** $Date: 2017/02/30 $\\n                          +         **\\n                          +         */\\n                          +        filter block-icmp {\\n                          +            term first-term {\\n                          +                from {\\n                          +                    protocol icmp;\\n                          +                }\\n                          +                then {\\n                          +                    reject;\\n                          +                }\\n                          +            }\\n                          +        }\\n                          +    }\\n\\n        Summary for edge01.bjm01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   5.752 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'block-icmp' -%}\\n        {%- set term_name = 'first-term' -%}\\n        {%- set my_term_cfg = salt.netacl.get_term_pillar(filter_name, term_name) -%}\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: {{ filter_name }}\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: {{ term_name }}\\n            - {{ my_term_cfg | json }}\\n\\n    Or directly referencing the pillar keys:\\n\\n    .. code-block:: yaml\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: block-icmp\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: first-term\\n            - merge_pillar: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    loaded = __salt__['netacl.load_term_config'](filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, test=test, commit=commit, debug=debug, **term_fields)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def term(name, filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Manage the configuration of a specific policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the CLI variables with the pillar. Default: ``False``.\\n\\n        The properties specified through the state arguments have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as\\n        above to select either a single value, either a list of values, but\\n        also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - [1000, 2000]\\n                - [3000, 4000]\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        ----------\\n                  ID: update_icmp_first_term\\n            Function: netacl.term\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:49:09.174179\\n            Duration: 5751.882 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit firewall]\\n                          +    family inet {\\n                          +        /*\\n                          +         ** $Id: update_icmp_first_term $\\n                          +         ** $Date: 2017/02/30 $\\n                          +         **\\n                          +         */\\n                          +        filter block-icmp {\\n                          +            term first-term {\\n                          +                from {\\n                          +                    protocol icmp;\\n                          +                }\\n                          +                then {\\n                          +                    reject;\\n                          +                }\\n                          +            }\\n                          +        }\\n                          +    }\\n\\n        Summary for edge01.bjm01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   5.752 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'block-icmp' -%}\\n        {%- set term_name = 'first-term' -%}\\n        {%- set my_term_cfg = salt.netacl.get_term_pillar(filter_name, term_name) -%}\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: {{ filter_name }}\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: {{ term_name }}\\n            - {{ my_term_cfg | json }}\\n\\n    Or directly referencing the pillar keys:\\n\\n    .. code-block:: yaml\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: block-icmp\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: first-term\\n            - merge_pillar: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    loaded = __salt__['netacl.load_term_config'](filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, test=test, commit=commit, debug=debug, **term_fields)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def term(name, filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Manage the configuration of a specific policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the CLI variables with the pillar. Default: ``False``.\\n\\n        The properties specified through the state arguments have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as\\n        above to select either a single value, either a list of values, but\\n        also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - [1000, 2000]\\n                - [3000, 4000]\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        ----------\\n                  ID: update_icmp_first_term\\n            Function: netacl.term\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:49:09.174179\\n            Duration: 5751.882 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit firewall]\\n                          +    family inet {\\n                          +        /*\\n                          +         ** $Id: update_icmp_first_term $\\n                          +         ** $Date: 2017/02/30 $\\n                          +         **\\n                          +         */\\n                          +        filter block-icmp {\\n                          +            term first-term {\\n                          +                from {\\n                          +                    protocol icmp;\\n                          +                }\\n                          +                then {\\n                          +                    reject;\\n                          +                }\\n                          +            }\\n                          +        }\\n                          +    }\\n\\n        Summary for edge01.bjm01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   5.752 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'block-icmp' -%}\\n        {%- set term_name = 'first-term' -%}\\n        {%- set my_term_cfg = salt.netacl.get_term_pillar(filter_name, term_name) -%}\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: {{ filter_name }}\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: {{ term_name }}\\n            - {{ my_term_cfg | json }}\\n\\n    Or directly referencing the pillar keys:\\n\\n    .. code-block:: yaml\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: block-icmp\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: first-term\\n            - merge_pillar: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    loaded = __salt__['netacl.load_term_config'](filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, test=test, commit=commit, debug=debug, **term_fields)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def term(name, filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Manage the configuration of a specific policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the CLI variables with the pillar. Default: ``False``.\\n\\n        The properties specified through the state arguments have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as\\n        above to select either a single value, either a list of values, but\\n        also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - [1000, 2000]\\n                - [3000, 4000]\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        ----------\\n                  ID: update_icmp_first_term\\n            Function: netacl.term\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:49:09.174179\\n            Duration: 5751.882 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit firewall]\\n                          +    family inet {\\n                          +        /*\\n                          +         ** $Id: update_icmp_first_term $\\n                          +         ** $Date: 2017/02/30 $\\n                          +         **\\n                          +         */\\n                          +        filter block-icmp {\\n                          +            term first-term {\\n                          +                from {\\n                          +                    protocol icmp;\\n                          +                }\\n                          +                then {\\n                          +                    reject;\\n                          +                }\\n                          +            }\\n                          +        }\\n                          +    }\\n\\n        Summary for edge01.bjm01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   5.752 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'block-icmp' -%}\\n        {%- set term_name = 'first-term' -%}\\n        {%- set my_term_cfg = salt.netacl.get_term_pillar(filter_name, term_name) -%}\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: {{ filter_name }}\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: {{ term_name }}\\n            - {{ my_term_cfg | json }}\\n\\n    Or directly referencing the pillar keys:\\n\\n    .. code-block:: yaml\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: block-icmp\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: first-term\\n            - merge_pillar: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    loaded = __salt__['netacl.load_term_config'](filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, test=test, commit=commit, debug=debug, **term_fields)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def term(name, filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Manage the configuration of a specific policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the CLI variables with the pillar. Default: ``False``.\\n\\n        The properties specified through the state arguments have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as\\n        above to select either a single value, either a list of values, but\\n        also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - [1000, 2000]\\n                - [3000, 4000]\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        ----------\\n                  ID: update_icmp_first_term\\n            Function: netacl.term\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:49:09.174179\\n            Duration: 5751.882 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit firewall]\\n                          +    family inet {\\n                          +        /*\\n                          +         ** $Id: update_icmp_first_term $\\n                          +         ** $Date: 2017/02/30 $\\n                          +         **\\n                          +         */\\n                          +        filter block-icmp {\\n                          +            term first-term {\\n                          +                from {\\n                          +                    protocol icmp;\\n                          +                }\\n                          +                then {\\n                          +                    reject;\\n                          +                }\\n                          +            }\\n                          +        }\\n                          +    }\\n\\n        Summary for edge01.bjm01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   5.752 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'block-icmp' -%}\\n        {%- set term_name = 'first-term' -%}\\n        {%- set my_term_cfg = salt.netacl.get_term_pillar(filter_name, term_name) -%}\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: {{ filter_name }}\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: {{ term_name }}\\n            - {{ my_term_cfg | json }}\\n\\n    Or directly referencing the pillar keys:\\n\\n    .. code-block:: yaml\\n\\n        update_icmp_first_term:\\n          netacl.term:\\n            - filter_name: block-icmp\\n            - filter_options:\\n                - not-interface-specific\\n            - term_name: first-term\\n            - merge_pillar: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    loaded = __salt__['netacl.load_term_config'](filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, test=test, commit=commit, debug=debug, **term_fields)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)"
        ]
    },
    {
        "func_name": "filter",
        "original": "def filter(name, filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    \"\"\"\n    Generate and load the configuration of a policy filter.\n\n    filter_name\n        The name of the policy filter.\n\n    filter_options\n        Additional filter options. These options are platform-specific.\n        See the complete list of options_.\n\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\n\n    terms\n        Dictionary of terms for this policy filter.\n        If not specified or empty, will try to load the configuration from the pillar,\n        unless ``merge_pillar`` is set as ``False``.\n\n    prepend: ``True``\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\n        at the beginning, while existing ones will preserve the position. To add the new terms\n        at the end of the list, set this argument to ``False``.\n\n    pillar_key: ``acl``\n        The key in the pillar containing the default attributes values. Default: ``acl``.\n\n    pillarenv\n        Query the master to generate fresh pillar data on the fly,\n        specifically from the requested pillar environment.\n\n    saltenv\n        Included only for compatibility with\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\n\n    merge_pillar: ``False``\n        Merge ``terms`` with the corresponding value from the pillar. Default: ``False``.\n\n        .. note::\n            By default this state does not merge, to avoid any unexpected behaviours.\n\n            The merge logic depends on the ``prepend`` argument.\n\n            The terms specified through the ``terms`` argument have higher priority\n            than the pillar.\n\n    only_lower_merge: ``False``\n        Specify if it should merge only the terms fields. Otherwise it will try\n        to merge also filters fields. Default: ``False``.\n        This option requires ``merge_pillar``, otherwise it is ignored.\n\n    revision_id\n        Add a comment in the filter config having the description for the changes applied.\n\n    revision_no\n        The revision count.\n\n    revision_date: ``True``\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\n\n    revision_date_format: ``%Y/%m/%d``\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\n        Default: ``False`` and will commit the changes on the device.\n\n    commit: ``True``\n        Commit? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw configuration loaded on the device.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt 'edge01.flw01' state.sls router.acl test=True\n\n    Output Example:\n\n    .. code-block:: text\n\n        edge01.flw01:\n        ----------\n                  ID: my-filter\n            Function: netacl.filter\n              Result: None\n             Comment: Testing mode: Configuration discarded.\n             Started: 12:24:40.598232\n            Duration: 2437.139 ms\n             Changes:\n                      ----------\n                      diff:\n                          ---\n                          +++\n                          @@ -1228,9 +1228,24 @@\n                          !\n                          +ipv4 access-list my-filter\n                          + 10 remark $Id: my-filter_state $\n                          + 20 remark $Revision: 5 $\n                          + 30 remark my-other-term\n                          + 40 permit tcp any range 5678 5680 any\n                          +!\n                          +!\n                      loaded:\n                          ! $Id: my-filter_state $\n                          ! $Revision: 5 $\n                          no ipv6 access-list my-filter\n                          ipv6 access-list my-filter\n                           remark $Id: my-filter_state $\n                           remark $Revision: 5 $\n                           remark my-other-term\n                           permit tcp any range 5678 5680 any\n                          exit\n\n        Summary for edge01.flw01\n        ------------\n        Succeeded: 1 (unchanged=1, changed=1)\n        Failed:    0\n        ------------\n        Total states run:     1\n        Total run time:   2.437 s\n\n    Pillar example:\n\n    .. code-block:: yaml\n\n        acl:\n          - my-filter:\n              options:\n                - inet6\n              terms:\n                - my-term:\n                    source_port: [1234, 1235]\n                    protocol:\n                      - tcp\n                      - udp\n                    source_address: 1.2.3.4\n                    action: reject\n                - my-other-term:\n                    source_port:\n                      - [5678, 5680]\n                    protocol: tcp\n                    action: accept\n\n    State SLS Example:\n\n    .. code-block:: jinja\n\n        {%- set filter_name = 'my-filter' -%}\n        {%- set my_filter_cfg = salt.netacl.get_filter_pillar(filter_name, pillar_key='firewall') -%}\n        my_first_filter_state:\n          netacl.filter:\n            - filter_name: {{ filter_name }}\n            - options: {{ my_filter_cfg['options'] | json }}\n            - terms: {{ my_filter_cfg['terms'] | json }}\n            - revision_date: false\n            - revision_no: 5\n            - debug: true\n\n    Or:\n\n    .. code-block:: yaml\n\n        my_first_filter_state:\n          netacl.filter:\n            - filter_name: my-filter\n            - merge_pillar: true\n            - pillar_key: firewall\n            - revision_date: false\n            - revision_no: 5\n            - debug: true\n\n    In the example above, as ``inet6`` has been specified in the ``filter_options``,\n    the configuration chunk referring to ``my-term`` has been ignored as it referred to\n    IPv4 only (from ``source_address`` field).\n\n    .. note::\n        The first method allows the user to eventually apply complex manipulation\n        and / or retrieve the data from external services before passing the\n        data to the state. The second one is more straightforward, for less\n        complex cases when loading the data directly from the pillar is sufficient.\n\n    .. note::\n        When passing retrieved pillar data into the state file, it is strongly\n        recommended to use the json serializer explicitly (`` | json``),\n        instead of relying on the default Python serializer.\n    \"\"\"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    loaded = __salt__['netacl.load_filter_config'](filter_name, filter_options=filter_options, terms=terms, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
        "mutated": [
            "def filter(name, filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        Dictionary of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge ``terms`` with the corresponding value from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The terms specified through the ``terms`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n        ----------\\n                  ID: my-filter\\n            Function: netacl.filter\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:24:40.598232\\n            Duration: 2437.139 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          ---\\n                          +++\\n                          @@ -1228,9 +1228,24 @@\\n                          !\\n                          +ipv4 access-list my-filter\\n                          + 10 remark $Id: my-filter_state $\\n                          + 20 remark $Revision: 5 $\\n                          + 30 remark my-other-term\\n                          + 40 permit tcp any range 5678 5680 any\\n                          +!\\n                          +!\\n                      loaded:\\n                          ! $Id: my-filter_state $\\n                          ! $Revision: 5 $\\n                          no ipv6 access-list my-filter\\n                          ipv6 access-list my-filter\\n                           remark $Id: my-filter_state $\\n                           remark $Revision: 5 $\\n                           remark my-other-term\\n                           permit tcp any range 5678 5680 any\\n                          exit\\n\\n        Summary for edge01.flw01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   2.437 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              options:\\n                - inet6\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n\\n    State SLS Example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'my-filter' -%}\\n        {%- set my_filter_cfg = salt.netacl.get_filter_pillar(filter_name, pillar_key='firewall') -%}\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: {{ filter_name }}\\n            - options: {{ my_filter_cfg['options'] | json }}\\n            - terms: {{ my_filter_cfg['terms'] | json }}\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: my-filter\\n            - merge_pillar: true\\n            - pillar_key: firewall\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    In the example above, as ``inet6`` has been specified in the ``filter_options``,\\n    the configuration chunk referring to ``my-term`` has been ignored as it referred to\\n    IPv4 only (from ``source_address`` field).\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    loaded = __salt__['netacl.load_filter_config'](filter_name, filter_options=filter_options, terms=terms, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def filter(name, filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        Dictionary of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge ``terms`` with the corresponding value from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The terms specified through the ``terms`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n        ----------\\n                  ID: my-filter\\n            Function: netacl.filter\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:24:40.598232\\n            Duration: 2437.139 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          ---\\n                          +++\\n                          @@ -1228,9 +1228,24 @@\\n                          !\\n                          +ipv4 access-list my-filter\\n                          + 10 remark $Id: my-filter_state $\\n                          + 20 remark $Revision: 5 $\\n                          + 30 remark my-other-term\\n                          + 40 permit tcp any range 5678 5680 any\\n                          +!\\n                          +!\\n                      loaded:\\n                          ! $Id: my-filter_state $\\n                          ! $Revision: 5 $\\n                          no ipv6 access-list my-filter\\n                          ipv6 access-list my-filter\\n                           remark $Id: my-filter_state $\\n                           remark $Revision: 5 $\\n                           remark my-other-term\\n                           permit tcp any range 5678 5680 any\\n                          exit\\n\\n        Summary for edge01.flw01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   2.437 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              options:\\n                - inet6\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n\\n    State SLS Example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'my-filter' -%}\\n        {%- set my_filter_cfg = salt.netacl.get_filter_pillar(filter_name, pillar_key='firewall') -%}\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: {{ filter_name }}\\n            - options: {{ my_filter_cfg['options'] | json }}\\n            - terms: {{ my_filter_cfg['terms'] | json }}\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: my-filter\\n            - merge_pillar: true\\n            - pillar_key: firewall\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    In the example above, as ``inet6`` has been specified in the ``filter_options``,\\n    the configuration chunk referring to ``my-term`` has been ignored as it referred to\\n    IPv4 only (from ``source_address`` field).\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    loaded = __salt__['netacl.load_filter_config'](filter_name, filter_options=filter_options, terms=terms, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def filter(name, filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        Dictionary of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge ``terms`` with the corresponding value from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The terms specified through the ``terms`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n        ----------\\n                  ID: my-filter\\n            Function: netacl.filter\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:24:40.598232\\n            Duration: 2437.139 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          ---\\n                          +++\\n                          @@ -1228,9 +1228,24 @@\\n                          !\\n                          +ipv4 access-list my-filter\\n                          + 10 remark $Id: my-filter_state $\\n                          + 20 remark $Revision: 5 $\\n                          + 30 remark my-other-term\\n                          + 40 permit tcp any range 5678 5680 any\\n                          +!\\n                          +!\\n                      loaded:\\n                          ! $Id: my-filter_state $\\n                          ! $Revision: 5 $\\n                          no ipv6 access-list my-filter\\n                          ipv6 access-list my-filter\\n                           remark $Id: my-filter_state $\\n                           remark $Revision: 5 $\\n                           remark my-other-term\\n                           permit tcp any range 5678 5680 any\\n                          exit\\n\\n        Summary for edge01.flw01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   2.437 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              options:\\n                - inet6\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n\\n    State SLS Example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'my-filter' -%}\\n        {%- set my_filter_cfg = salt.netacl.get_filter_pillar(filter_name, pillar_key='firewall') -%}\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: {{ filter_name }}\\n            - options: {{ my_filter_cfg['options'] | json }}\\n            - terms: {{ my_filter_cfg['terms'] | json }}\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: my-filter\\n            - merge_pillar: true\\n            - pillar_key: firewall\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    In the example above, as ``inet6`` has been specified in the ``filter_options``,\\n    the configuration chunk referring to ``my-term`` has been ignored as it referred to\\n    IPv4 only (from ``source_address`` field).\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    loaded = __salt__['netacl.load_filter_config'](filter_name, filter_options=filter_options, terms=terms, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def filter(name, filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        Dictionary of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge ``terms`` with the corresponding value from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The terms specified through the ``terms`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n        ----------\\n                  ID: my-filter\\n            Function: netacl.filter\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:24:40.598232\\n            Duration: 2437.139 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          ---\\n                          +++\\n                          @@ -1228,9 +1228,24 @@\\n                          !\\n                          +ipv4 access-list my-filter\\n                          + 10 remark $Id: my-filter_state $\\n                          + 20 remark $Revision: 5 $\\n                          + 30 remark my-other-term\\n                          + 40 permit tcp any range 5678 5680 any\\n                          +!\\n                          +!\\n                      loaded:\\n                          ! $Id: my-filter_state $\\n                          ! $Revision: 5 $\\n                          no ipv6 access-list my-filter\\n                          ipv6 access-list my-filter\\n                           remark $Id: my-filter_state $\\n                           remark $Revision: 5 $\\n                           remark my-other-term\\n                           permit tcp any range 5678 5680 any\\n                          exit\\n\\n        Summary for edge01.flw01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   2.437 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              options:\\n                - inet6\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n\\n    State SLS Example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'my-filter' -%}\\n        {%- set my_filter_cfg = salt.netacl.get_filter_pillar(filter_name, pillar_key='firewall') -%}\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: {{ filter_name }}\\n            - options: {{ my_filter_cfg['options'] | json }}\\n            - terms: {{ my_filter_cfg['terms'] | json }}\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: my-filter\\n            - merge_pillar: true\\n            - pillar_key: firewall\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    In the example above, as ``inet6`` has been specified in the ``filter_options``,\\n    the configuration chunk referring to ``my-term`` has been ignored as it referred to\\n    IPv4 only (from ``source_address`` field).\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    loaded = __salt__['netacl.load_filter_config'](filter_name, filter_options=filter_options, terms=terms, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def filter(name, filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        Dictionary of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge ``terms`` with the corresponding value from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The terms specified through the ``terms`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n        ----------\\n                  ID: my-filter\\n            Function: netacl.filter\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:24:40.598232\\n            Duration: 2437.139 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          ---\\n                          +++\\n                          @@ -1228,9 +1228,24 @@\\n                          !\\n                          +ipv4 access-list my-filter\\n                          + 10 remark $Id: my-filter_state $\\n                          + 20 remark $Revision: 5 $\\n                          + 30 remark my-other-term\\n                          + 40 permit tcp any range 5678 5680 any\\n                          +!\\n                          +!\\n                      loaded:\\n                          ! $Id: my-filter_state $\\n                          ! $Revision: 5 $\\n                          no ipv6 access-list my-filter\\n                          ipv6 access-list my-filter\\n                           remark $Id: my-filter_state $\\n                           remark $Revision: 5 $\\n                           remark my-other-term\\n                           permit tcp any range 5678 5680 any\\n                          exit\\n\\n        Summary for edge01.flw01\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   2.437 s\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              options:\\n                - inet6\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n\\n    State SLS Example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set filter_name = 'my-filter' -%}\\n        {%- set my_filter_cfg = salt.netacl.get_filter_pillar(filter_name, pillar_key='firewall') -%}\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: {{ filter_name }}\\n            - options: {{ my_filter_cfg['options'] | json }}\\n            - terms: {{ my_filter_cfg['terms'] | json }}\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        my_first_filter_state:\\n          netacl.filter:\\n            - filter_name: my-filter\\n            - merge_pillar: true\\n            - pillar_key: firewall\\n            - revision_date: false\\n            - revision_no: 5\\n            - debug: true\\n\\n    In the example above, as ``inet6`` has been specified in the ``filter_options``,\\n    the configuration chunk referring to ``my-term`` has been ignored as it referred to\\n    IPv4 only (from ``source_address`` field).\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    loaded = __salt__['netacl.load_filter_config'](filter_name, filter_options=filter_options, terms=terms, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)"
        ]
    },
    {
        "func_name": "managed",
        "original": "def managed(name, filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    \"\"\"\n    Manage the whole firewall configuration.\n\n    filters\n        Dictionary of filters for this policy.\n        If not specified or empty, will try to load the configuration from the pillar,\n        unless ``merge_pillar`` is set as ``False``.\n\n    prepend: ``True``\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\n        at the beginning, while existing ones will preserve the position. To add the new filters\n        at the end of the list, set this argument to ``False``.\n\n    pillar_key: ``acl``\n        The key in the pillar containing the default attributes values. Default: ``acl``.\n\n    pillarenv\n        Query the master to generate fresh pillar data on the fly,\n        specifically from the requested pillar environment.\n\n    saltenv\n        Included only for compatibility with\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\n\n    merge_pillar: ``False``\n        Merge the ``filters`` will the corresponding values from the pillar. Default: ``False``.\n\n        .. note::\n            By default this state does not merge, to avoid any unexpected behaviours.\n\n            The merge logic depends on the ``prepend`` argument.\n\n            The filters specified through the ``filters`` argument have higher priority\n            than the pillar.\n\n    only_lower_merge: ``False``\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\n        to merge everything at the policy level. Default: ``False``.\n        This option requires ``merge_pillar``, otherwise it is ignored.\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\n        Default: ``False`` and will commit the changes on the device.\n\n    revision_id\n        Add a comment in the policy config having the description for the changes applied.\n\n    revision_no\n        The revision count.\n\n    revision_date: ``True``\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\n\n    revision_date_format: ``%Y/%m/%d``\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\n\n    commit: ``True``\n        Commit? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw configuration loaded on the device.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt 'edge01.bjm01' state.sls router.acl test=True\n\n    Output Example:\n\n    .. code-block:: text\n\n        edge01.bjm01:\n        -------------\n                      ID: netacl_example\n                Function: netacl.managed\n                  Result: None\n                 Comment: Testing mode: Configuration discarded.\n                 Started: 12:03:24.807023\n                Duration: 5569.453 ms\n                 Changes:\n                          ----------\n                          diff:\n                              [edit firewall]\n                              +    family inet {\n                              +        /*\n                              +         ** $Id: netacl_example $\n                              +         ** $Date: 2017/07/03 $\n                              +         ** $Revision: 2 $\n                              +         **\n                              +         */\n                              +        filter my-filter {\n                              +            interface-specific;\n                              +            term my-term {\n                              +                from {\n                              +                    source-address {\n                              +                        1.2.3.4/32;\n                              +                    }\n                              +                    protocol [ tcp udp ];\n                              +                    source-port [ 1234 1235 ];\n                              +                }\n                              +                then {\n                              +                    reject;\n                              +                }\n                              +            }\n                              +            term my-other-term {\n                              +                from {\n                              +                    protocol tcp;\n                              +                    source-port 5678-5680;\n                              +                }\n                              +                then accept;\n                              +            }\n                              +        }\n                              +        /*\n                              +         ** $Id: netacl_example $\n                              +         ** $Date: 2017/07/03 $\n                              +         ** $Revision: 2 $\n                              +         **\n                              +         */\n                              +        filter block-icmp {\n                              +            interface-specific;\n                              +            term first-term {\n                              +                from {\n                              +                    protocol icmp;\n                              +                }\n                              +                then {\n                              +                    reject;\n                              +                }\n                              +            }\n                              +        }\n                              +    }\n                          loaded:\n                              firewall {\n                                  family inet {\n                                      replace:\n                                      /*\n                                      ** $Id: netacl_example $\n                                      ** $Date: 2017/07/03 $\n                                      ** $Revision: 2 $\n                                      **\n                                      */\n                                      filter my-filter {\n                                          interface-specific;\n                                          term my-term {\n                                              from {\n                                                  source-address {\n                                                      1.2.3.4/32;\n                                                  }\n                                                  protocol [ tcp udp ];\n                                                  source-port [ 1234 1235 ];\n                                              }\n                                              then {\n                                                  reject;\n                                              }\n                                          }\n                                          term my-other-term {\n                                              from {\n                                                  protocol tcp;\n                                                  source-port 5678-5680;\n                                              }\n                                              then accept;\n                                          }\n                                      }\n                                  }\n                              }\n                              firewall {\n                                  family inet {\n                                      replace:\n                                      /*\n                                      ** $Id: netacl_example $\n                                      ** $Date: 2017/07/03 $\n                                      ** $Revision: 2 $\n                                      **\n                                      */\n                                      filter block-icmp {\n                                          interface-specific;\n                                          term first-term {\n                                              from {\n                                                  protocol icmp;\n                                              }\n                                              then {\n                                                  reject;\n                                              }\n                                          }\n                                      }\n                                  }\n                              }\n\n            Summary for edge01.bjm01\n            ------------\n            Succeeded: 1 (unchanged=1, changed=1)\n            Failed:    0\n            ------------\n            Total states run:     1\n            Total run time:   5.569 s\n\n    The policy configuration has been loaded from the pillar, having the following structure:\n\n    .. code-block:: yaml\n\n        firewall:\n          - my-filter:\n              terms:\n                - my-term:\n                    source_port: [1234, 1235]\n                    protocol:\n                      - tcp\n                      - udp\n                    source_address: 1.2.3.4\n                    action: reject\n                - my-other-term:\n                    source_port:\n                      - [5678, 5680]\n                    protocol: tcp\n                    action: accept\n          - block-icmp:\n              terms:\n                - first-term:\n                    protocol:\n                      - icmp\n                    action: reject\n\n    Example SLS file:\n\n    .. code-block:: jinja\n\n        {%- set fw_filters = pillar.get('firewall', {}) -%}\n        netacl_example:\n          netacl.managed:\n            - filters: {{ fw_filters | json }}\n            - revision_no: 2\n            - debug: true\n\n    Or:\n\n    .. code-block:: yaml\n\n        netacl_example:\n          netacl.managed:\n            - pillar_key: firewall\n            - merge_pillar: true\n            - revision_no: 2\n            - debug: true\n\n    .. note::\n        The first method allows the user to eventually apply complex manipulation\n        and / or retrieve the data from external services before passing the\n        data to the state. The second one is more straightforward, for less\n        complex cases when loading the data directly from the pillar is sufficient.\n\n    .. note::\n        When passing retrieved pillar data into the state file, it is strongly\n        recommended to use the json serializer explicitly (`` | json``),\n        instead of relying on the default Python serializer.\n    \"\"\"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filters:\n        filters = []\n    loaded = __salt__['netacl.load_policy_config'](filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
        "mutated": [
            "def managed(name, filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n    \"\\n    Manage the whole firewall configuration.\\n\\n    filters\\n        Dictionary of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the ``filters`` will the corresponding values from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The filters specified through the ``filters`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        -------------\\n                      ID: netacl_example\\n                Function: netacl.managed\\n                  Result: None\\n                 Comment: Testing mode: Configuration discarded.\\n                 Started: 12:03:24.807023\\n                Duration: 5569.453 ms\\n                 Changes:\\n                          ----------\\n                          diff:\\n                              [edit firewall]\\n                              +    family inet {\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter my-filter {\\n                              +            interface-specific;\\n                              +            term my-term {\\n                              +                from {\\n                              +                    source-address {\\n                              +                        1.2.3.4/32;\\n                              +                    }\\n                              +                    protocol [ tcp udp ];\\n                              +                    source-port [ 1234 1235 ];\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +            term my-other-term {\\n                              +                from {\\n                              +                    protocol tcp;\\n                              +                    source-port 5678-5680;\\n                              +                }\\n                              +                then accept;\\n                              +            }\\n                              +        }\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter block-icmp {\\n                              +            interface-specific;\\n                              +            term first-term {\\n                              +                from {\\n                              +                    protocol icmp;\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +        }\\n                              +    }\\n                          loaded:\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter my-filter {\\n                                          interface-specific;\\n                                          term my-term {\\n                                              from {\\n                                                  source-address {\\n                                                      1.2.3.4/32;\\n                                                  }\\n                                                  protocol [ tcp udp ];\\n                                                  source-port [ 1234 1235 ];\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                          term my-other-term {\\n                                              from {\\n                                                  protocol tcp;\\n                                                  source-port 5678-5680;\\n                                              }\\n                                              then accept;\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter block-icmp {\\n                                          interface-specific;\\n                                          term first-term {\\n                                              from {\\n                                                  protocol icmp;\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n\\n            Summary for edge01.bjm01\\n            ------------\\n            Succeeded: 1 (unchanged=1, changed=1)\\n            Failed:    0\\n            ------------\\n            Total states run:     1\\n            Total run time:   5.569 s\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    Example SLS file:\\n\\n    .. code-block:: jinja\\n\\n        {%- set fw_filters = pillar.get('firewall', {}) -%}\\n        netacl_example:\\n          netacl.managed:\\n            - filters: {{ fw_filters | json }}\\n            - revision_no: 2\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        netacl_example:\\n          netacl.managed:\\n            - pillar_key: firewall\\n            - merge_pillar: true\\n            - revision_no: 2\\n            - debug: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filters:\n        filters = []\n    loaded = __salt__['netacl.load_policy_config'](filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def managed(name, filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Manage the whole firewall configuration.\\n\\n    filters\\n        Dictionary of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the ``filters`` will the corresponding values from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The filters specified through the ``filters`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        -------------\\n                      ID: netacl_example\\n                Function: netacl.managed\\n                  Result: None\\n                 Comment: Testing mode: Configuration discarded.\\n                 Started: 12:03:24.807023\\n                Duration: 5569.453 ms\\n                 Changes:\\n                          ----------\\n                          diff:\\n                              [edit firewall]\\n                              +    family inet {\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter my-filter {\\n                              +            interface-specific;\\n                              +            term my-term {\\n                              +                from {\\n                              +                    source-address {\\n                              +                        1.2.3.4/32;\\n                              +                    }\\n                              +                    protocol [ tcp udp ];\\n                              +                    source-port [ 1234 1235 ];\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +            term my-other-term {\\n                              +                from {\\n                              +                    protocol tcp;\\n                              +                    source-port 5678-5680;\\n                              +                }\\n                              +                then accept;\\n                              +            }\\n                              +        }\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter block-icmp {\\n                              +            interface-specific;\\n                              +            term first-term {\\n                              +                from {\\n                              +                    protocol icmp;\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +        }\\n                              +    }\\n                          loaded:\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter my-filter {\\n                                          interface-specific;\\n                                          term my-term {\\n                                              from {\\n                                                  source-address {\\n                                                      1.2.3.4/32;\\n                                                  }\\n                                                  protocol [ tcp udp ];\\n                                                  source-port [ 1234 1235 ];\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                          term my-other-term {\\n                                              from {\\n                                                  protocol tcp;\\n                                                  source-port 5678-5680;\\n                                              }\\n                                              then accept;\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter block-icmp {\\n                                          interface-specific;\\n                                          term first-term {\\n                                              from {\\n                                                  protocol icmp;\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n\\n            Summary for edge01.bjm01\\n            ------------\\n            Succeeded: 1 (unchanged=1, changed=1)\\n            Failed:    0\\n            ------------\\n            Total states run:     1\\n            Total run time:   5.569 s\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    Example SLS file:\\n\\n    .. code-block:: jinja\\n\\n        {%- set fw_filters = pillar.get('firewall', {}) -%}\\n        netacl_example:\\n          netacl.managed:\\n            - filters: {{ fw_filters | json }}\\n            - revision_no: 2\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        netacl_example:\\n          netacl.managed:\\n            - pillar_key: firewall\\n            - merge_pillar: true\\n            - revision_no: 2\\n            - debug: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filters:\n        filters = []\n    loaded = __salt__['netacl.load_policy_config'](filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def managed(name, filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Manage the whole firewall configuration.\\n\\n    filters\\n        Dictionary of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the ``filters`` will the corresponding values from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The filters specified through the ``filters`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        -------------\\n                      ID: netacl_example\\n                Function: netacl.managed\\n                  Result: None\\n                 Comment: Testing mode: Configuration discarded.\\n                 Started: 12:03:24.807023\\n                Duration: 5569.453 ms\\n                 Changes:\\n                          ----------\\n                          diff:\\n                              [edit firewall]\\n                              +    family inet {\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter my-filter {\\n                              +            interface-specific;\\n                              +            term my-term {\\n                              +                from {\\n                              +                    source-address {\\n                              +                        1.2.3.4/32;\\n                              +                    }\\n                              +                    protocol [ tcp udp ];\\n                              +                    source-port [ 1234 1235 ];\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +            term my-other-term {\\n                              +                from {\\n                              +                    protocol tcp;\\n                              +                    source-port 5678-5680;\\n                              +                }\\n                              +                then accept;\\n                              +            }\\n                              +        }\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter block-icmp {\\n                              +            interface-specific;\\n                              +            term first-term {\\n                              +                from {\\n                              +                    protocol icmp;\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +        }\\n                              +    }\\n                          loaded:\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter my-filter {\\n                                          interface-specific;\\n                                          term my-term {\\n                                              from {\\n                                                  source-address {\\n                                                      1.2.3.4/32;\\n                                                  }\\n                                                  protocol [ tcp udp ];\\n                                                  source-port [ 1234 1235 ];\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                          term my-other-term {\\n                                              from {\\n                                                  protocol tcp;\\n                                                  source-port 5678-5680;\\n                                              }\\n                                              then accept;\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter block-icmp {\\n                                          interface-specific;\\n                                          term first-term {\\n                                              from {\\n                                                  protocol icmp;\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n\\n            Summary for edge01.bjm01\\n            ------------\\n            Succeeded: 1 (unchanged=1, changed=1)\\n            Failed:    0\\n            ------------\\n            Total states run:     1\\n            Total run time:   5.569 s\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    Example SLS file:\\n\\n    .. code-block:: jinja\\n\\n        {%- set fw_filters = pillar.get('firewall', {}) -%}\\n        netacl_example:\\n          netacl.managed:\\n            - filters: {{ fw_filters | json }}\\n            - revision_no: 2\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        netacl_example:\\n          netacl.managed:\\n            - pillar_key: firewall\\n            - merge_pillar: true\\n            - revision_no: 2\\n            - debug: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filters:\n        filters = []\n    loaded = __salt__['netacl.load_policy_config'](filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def managed(name, filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Manage the whole firewall configuration.\\n\\n    filters\\n        Dictionary of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the ``filters`` will the corresponding values from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The filters specified through the ``filters`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        -------------\\n                      ID: netacl_example\\n                Function: netacl.managed\\n                  Result: None\\n                 Comment: Testing mode: Configuration discarded.\\n                 Started: 12:03:24.807023\\n                Duration: 5569.453 ms\\n                 Changes:\\n                          ----------\\n                          diff:\\n                              [edit firewall]\\n                              +    family inet {\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter my-filter {\\n                              +            interface-specific;\\n                              +            term my-term {\\n                              +                from {\\n                              +                    source-address {\\n                              +                        1.2.3.4/32;\\n                              +                    }\\n                              +                    protocol [ tcp udp ];\\n                              +                    source-port [ 1234 1235 ];\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +            term my-other-term {\\n                              +                from {\\n                              +                    protocol tcp;\\n                              +                    source-port 5678-5680;\\n                              +                }\\n                              +                then accept;\\n                              +            }\\n                              +        }\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter block-icmp {\\n                              +            interface-specific;\\n                              +            term first-term {\\n                              +                from {\\n                              +                    protocol icmp;\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +        }\\n                              +    }\\n                          loaded:\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter my-filter {\\n                                          interface-specific;\\n                                          term my-term {\\n                                              from {\\n                                                  source-address {\\n                                                      1.2.3.4/32;\\n                                                  }\\n                                                  protocol [ tcp udp ];\\n                                                  source-port [ 1234 1235 ];\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                          term my-other-term {\\n                                              from {\\n                                                  protocol tcp;\\n                                                  source-port 5678-5680;\\n                                              }\\n                                              then accept;\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter block-icmp {\\n                                          interface-specific;\\n                                          term first-term {\\n                                              from {\\n                                                  protocol icmp;\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n\\n            Summary for edge01.bjm01\\n            ------------\\n            Succeeded: 1 (unchanged=1, changed=1)\\n            Failed:    0\\n            ------------\\n            Total states run:     1\\n            Total run time:   5.569 s\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    Example SLS file:\\n\\n    .. code-block:: jinja\\n\\n        {%- set fw_filters = pillar.get('firewall', {}) -%}\\n        netacl_example:\\n          netacl.managed:\\n            - filters: {{ fw_filters | json }}\\n            - revision_no: 2\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        netacl_example:\\n          netacl.managed:\\n            - pillar_key: firewall\\n            - merge_pillar: true\\n            - revision_no: 2\\n            - debug: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filters:\n        filters = []\n    loaded = __salt__['netacl.load_policy_config'](filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)",
            "def managed(name, filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=False, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Manage the whole firewall configuration.\\n\\n    filters\\n        Dictionary of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``False``\\n        Merge the ``filters`` will the corresponding values from the pillar. Default: ``False``.\\n\\n        .. note::\\n            By default this state does not merge, to avoid any unexpected behaviours.\\n\\n            The merge logic depends on the ``prepend`` argument.\\n\\n            The filters specified through the ``filters`` argument have higher priority\\n            than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' state.sls router.acl test=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.bjm01:\\n        -------------\\n                      ID: netacl_example\\n                Function: netacl.managed\\n                  Result: None\\n                 Comment: Testing mode: Configuration discarded.\\n                 Started: 12:03:24.807023\\n                Duration: 5569.453 ms\\n                 Changes:\\n                          ----------\\n                          diff:\\n                              [edit firewall]\\n                              +    family inet {\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter my-filter {\\n                              +            interface-specific;\\n                              +            term my-term {\\n                              +                from {\\n                              +                    source-address {\\n                              +                        1.2.3.4/32;\\n                              +                    }\\n                              +                    protocol [ tcp udp ];\\n                              +                    source-port [ 1234 1235 ];\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +            term my-other-term {\\n                              +                from {\\n                              +                    protocol tcp;\\n                              +                    source-port 5678-5680;\\n                              +                }\\n                              +                then accept;\\n                              +            }\\n                              +        }\\n                              +        /*\\n                              +         ** $Id: netacl_example $\\n                              +         ** $Date: 2017/07/03 $\\n                              +         ** $Revision: 2 $\\n                              +         **\\n                              +         */\\n                              +        filter block-icmp {\\n                              +            interface-specific;\\n                              +            term first-term {\\n                              +                from {\\n                              +                    protocol icmp;\\n                              +                }\\n                              +                then {\\n                              +                    reject;\\n                              +                }\\n                              +            }\\n                              +        }\\n                              +    }\\n                          loaded:\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter my-filter {\\n                                          interface-specific;\\n                                          term my-term {\\n                                              from {\\n                                                  source-address {\\n                                                      1.2.3.4/32;\\n                                                  }\\n                                                  protocol [ tcp udp ];\\n                                                  source-port [ 1234 1235 ];\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                          term my-other-term {\\n                                              from {\\n                                                  protocol tcp;\\n                                                  source-port 5678-5680;\\n                                              }\\n                                              then accept;\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n                              firewall {\\n                                  family inet {\\n                                      replace:\\n                                      /*\\n                                      ** $Id: netacl_example $\\n                                      ** $Date: 2017/07/03 $\\n                                      ** $Revision: 2 $\\n                                      **\\n                                      */\\n                                      filter block-icmp {\\n                                          interface-specific;\\n                                          term first-term {\\n                                              from {\\n                                                  protocol icmp;\\n                                              }\\n                                              then {\\n                                                  reject;\\n                                              }\\n                                          }\\n                                      }\\n                                  }\\n                              }\\n\\n            Summary for edge01.bjm01\\n            ------------\\n            Succeeded: 1 (unchanged=1, changed=1)\\n            Failed:    0\\n            ------------\\n            Total states run:     1\\n            Total run time:   5.569 s\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        firewall:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port: [1234, 1235]\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n\\n    Example SLS file:\\n\\n    .. code-block:: jinja\\n\\n        {%- set fw_filters = pillar.get('firewall', {}) -%}\\n        netacl_example:\\n          netacl.managed:\\n            - filters: {{ fw_filters | json }}\\n            - revision_no: 2\\n            - debug: true\\n\\n    Or:\\n\\n    .. code-block:: yaml\\n\\n        netacl_example:\\n          netacl.managed:\\n            - pillar_key: firewall\\n            - merge_pillar: true\\n            - revision_no: 2\\n            - debug: true\\n\\n    .. note::\\n        The first method allows the user to eventually apply complex manipulation\\n        and / or retrieve the data from external services before passing the\\n        data to the state. The second one is more straightforward, for less\\n        complex cases when loading the data directly from the pillar is sufficient.\\n\\n    .. note::\\n        When passing retrieved pillar data into the state file, it is strongly\\n        recommended to use the json serializer explicitly (`` | json``),\\n        instead of relying on the default Python serializer.\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = __opts__['test'] or test\n    if not filters:\n        filters = []\n    loaded = __salt__['netacl.load_policy_config'](filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id if revision_id else name, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, test=test, commit=commit, debug=debug)\n    return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)"
        ]
    }
]