[
    {
        "func_name": "readfile",
        "original": "def readfile(filename):\n    with open(filename, 'r', encoding='utf-8') as ff:\n        return ff.read()",
        "mutated": [
            "def readfile(filename):\n    if False:\n        i = 10\n    with open(filename, 'r', encoding='utf-8') as ff:\n        return ff.read()",
            "def readfile(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(filename, 'r', encoding='utf-8') as ff:\n        return ff.read()",
            "def readfile(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(filename, 'r', encoding='utf-8') as ff:\n        return ff.read()",
            "def readfile(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(filename, 'r', encoding='utf-8') as ff:\n        return ff.read()",
            "def readfile(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(filename, 'r', encoding='utf-8') as ff:\n        return ff.read()"
        ]
    },
    {
        "func_name": "writefile",
        "original": "def writefile(fpath, content):\n    with open(fpath, 'w', encoding='utf-8') as ff:\n        ff.write(content)",
        "mutated": [
            "def writefile(fpath, content):\n    if False:\n        i = 10\n    with open(fpath, 'w', encoding='utf-8') as ff:\n        ff.write(content)",
            "def writefile(fpath, content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(fpath, 'w', encoding='utf-8') as ff:\n        ff.write(content)",
            "def writefile(fpath, content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(fpath, 'w', encoding='utf-8') as ff:\n        ff.write(content)",
            "def writefile(fpath, content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(fpath, 'w', encoding='utf-8') as ff:\n        ff.write(content)",
            "def writefile(fpath, content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(fpath, 'w', encoding='utf-8') as ff:\n        ff.write(content)"
        ]
    },
    {
        "func_name": "writejson",
        "original": "def writejson(a_path: str, a_dict: dict) -> None:\n    with open(a_path, 'w', encoding='utf-8') as output_file:\n        json.dump(a_dict, output_file, ensure_ascii=False, indent=2)",
        "mutated": [
            "def writejson(a_path: str, a_dict: dict) -> None:\n    if False:\n        i = 10\n    with open(a_path, 'w', encoding='utf-8') as output_file:\n        json.dump(a_dict, output_file, ensure_ascii=False, indent=2)",
            "def writejson(a_path: str, a_dict: dict) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(a_path, 'w', encoding='utf-8') as output_file:\n        json.dump(a_dict, output_file, ensure_ascii=False, indent=2)",
            "def writejson(a_path: str, a_dict: dict) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(a_path, 'w', encoding='utf-8') as output_file:\n        json.dump(a_dict, output_file, ensure_ascii=False, indent=2)",
            "def writejson(a_path: str, a_dict: dict) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(a_path, 'w', encoding='utf-8') as output_file:\n        json.dump(a_dict, output_file, ensure_ascii=False, indent=2)",
            "def writejson(a_path: str, a_dict: dict) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(a_path, 'w', encoding='utf-8') as output_file:\n        json.dump(a_dict, output_file, ensure_ascii=False, indent=2)"
        ]
    },
    {
        "func_name": "readjson",
        "original": "def readjson(a_path: str) -> dict:\n    with open(a_path, 'r', encoding='utf-8') as f:\n        return json.load(f)",
        "mutated": [
            "def readjson(a_path: str) -> dict:\n    if False:\n        i = 10\n    with open(a_path, 'r', encoding='utf-8') as f:\n        return json.load(f)",
            "def readjson(a_path: str) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(a_path, 'r', encoding='utf-8') as f:\n        return json.load(f)",
            "def readjson(a_path: str) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(a_path, 'r', encoding='utf-8') as f:\n        return json.load(f)",
            "def readjson(a_path: str) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(a_path, 'r', encoding='utf-8') as f:\n        return json.load(f)",
            "def readjson(a_path: str) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(a_path, 'r', encoding='utf-8') as f:\n        return json.load(f)"
        ]
    },
    {
        "func_name": "openfile",
        "original": "def openfile(a_path):\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This file doesn't exists: {a_path}\")\n    if 'Windows' in platform.system():\n        os.startfile(a_path)\n    elif 'Linux' in platform.system():\n        Popen(f'exo-open \"{a_path}\"', shell=True)",
        "mutated": [
            "def openfile(a_path):\n    if False:\n        i = 10\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This file doesn't exists: {a_path}\")\n    if 'Windows' in platform.system():\n        os.startfile(a_path)\n    elif 'Linux' in platform.system():\n        Popen(f'exo-open \"{a_path}\"', shell=True)",
            "def openfile(a_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This file doesn't exists: {a_path}\")\n    if 'Windows' in platform.system():\n        os.startfile(a_path)\n    elif 'Linux' in platform.system():\n        Popen(f'exo-open \"{a_path}\"', shell=True)",
            "def openfile(a_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This file doesn't exists: {a_path}\")\n    if 'Windows' in platform.system():\n        os.startfile(a_path)\n    elif 'Linux' in platform.system():\n        Popen(f'exo-open \"{a_path}\"', shell=True)",
            "def openfile(a_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This file doesn't exists: {a_path}\")\n    if 'Windows' in platform.system():\n        os.startfile(a_path)\n    elif 'Linux' in platform.system():\n        Popen(f'exo-open \"{a_path}\"', shell=True)",
            "def openfile(a_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This file doesn't exists: {a_path}\")\n    if 'Windows' in platform.system():\n        os.startfile(a_path)\n    elif 'Linux' in platform.system():\n        Popen(f'exo-open \"{a_path}\"', shell=True)"
        ]
    },
    {
        "func_name": "opendir",
        "original": "def opendir(a_path):\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This directory doesn't exists: {a_path}\")\n    try:\n        if 'Windows' in platform.system():\n            os.startfile(a_path)\n        elif 'Linux' in platform.system():\n            Popen(f'exo-open --launch FileManager --working-directory \"{a_path}\"', shell=True)\n    except Exception as e:\n        sg.Popen(f\"Error, can't open a file: '{e}'\")",
        "mutated": [
            "def opendir(a_path):\n    if False:\n        i = 10\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This directory doesn't exists: {a_path}\")\n    try:\n        if 'Windows' in platform.system():\n            os.startfile(a_path)\n        elif 'Linux' in platform.system():\n            Popen(f'exo-open --launch FileManager --working-directory \"{a_path}\"', shell=True)\n    except Exception as e:\n        sg.Popen(f\"Error, can't open a file: '{e}'\")",
            "def opendir(a_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This directory doesn't exists: {a_path}\")\n    try:\n        if 'Windows' in platform.system():\n            os.startfile(a_path)\n        elif 'Linux' in platform.system():\n            Popen(f'exo-open --launch FileManager --working-directory \"{a_path}\"', shell=True)\n    except Exception as e:\n        sg.Popen(f\"Error, can't open a file: '{e}'\")",
            "def opendir(a_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This directory doesn't exists: {a_path}\")\n    try:\n        if 'Windows' in platform.system():\n            os.startfile(a_path)\n        elif 'Linux' in platform.system():\n            Popen(f'exo-open --launch FileManager --working-directory \"{a_path}\"', shell=True)\n    except Exception as e:\n        sg.Popen(f\"Error, can't open a file: '{e}'\")",
            "def opendir(a_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This directory doesn't exists: {a_path}\")\n    try:\n        if 'Windows' in platform.system():\n            os.startfile(a_path)\n        elif 'Linux' in platform.system():\n            Popen(f'exo-open --launch FileManager --working-directory \"{a_path}\"', shell=True)\n    except Exception as e:\n        sg.Popen(f\"Error, can't open a file: '{e}'\")",
            "def opendir(a_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not os.path.exists(a_path):\n        return sg.Popup(f\"Error! This directory doesn't exists: {a_path}\")\n    try:\n        if 'Windows' in platform.system():\n            os.startfile(a_path)\n        elif 'Linux' in platform.system():\n            Popen(f'exo-open --launch FileManager --working-directory \"{a_path}\"', shell=True)\n    except Exception as e:\n        sg.Popen(f\"Error, can't open a file: '{e}'\")"
        ]
    },
    {
        "func_name": "load_configs",
        "original": "def load_configs():\n    return readjson(os.path.join(cd, 'app_configs.json'))",
        "mutated": [
            "def load_configs():\n    if False:\n        i = 10\n    return readjson(os.path.join(cd, 'app_configs.json'))",
            "def load_configs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return readjson(os.path.join(cd, 'app_configs.json'))",
            "def load_configs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return readjson(os.path.join(cd, 'app_configs.json'))",
            "def load_configs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return readjson(os.path.join(cd, 'app_configs.json'))",
            "def load_configs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return readjson(os.path.join(cd, 'app_configs.json'))"
        ]
    },
    {
        "func_name": "save_configs",
        "original": "def save_configs(a_config: dict):\n    writejson(os.path.join(cd, 'app_configs.json'), a_config)",
        "mutated": [
            "def save_configs(a_config: dict):\n    if False:\n        i = 10\n    writejson(os.path.join(cd, 'app_configs.json'), a_config)",
            "def save_configs(a_config: dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    writejson(os.path.join(cd, 'app_configs.json'), a_config)",
            "def save_configs(a_config: dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    writejson(os.path.join(cd, 'app_configs.json'), a_config)",
            "def save_configs(a_config: dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    writejson(os.path.join(cd, 'app_configs.json'), a_config)",
            "def save_configs(a_config: dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    writejson(os.path.join(cd, 'app_configs.json'), a_config)"
        ]
    },
    {
        "func_name": "wrapper",
        "original": "def wrapper(*args, **kwargs):\n    start = time.time()\n    res = f(*args, **kwargs)\n    end = time.time()\n    return res",
        "mutated": [
            "def wrapper(*args, **kwargs):\n    if False:\n        i = 10\n    start = time.time()\n    res = f(*args, **kwargs)\n    end = time.time()\n    return res",
            "def wrapper(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start = time.time()\n    res = f(*args, **kwargs)\n    end = time.time()\n    return res",
            "def wrapper(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start = time.time()\n    res = f(*args, **kwargs)\n    end = time.time()\n    return res",
            "def wrapper(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start = time.time()\n    res = f(*args, **kwargs)\n    end = time.time()\n    return res",
            "def wrapper(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start = time.time()\n    res = f(*args, **kwargs)\n    end = time.time()\n    return res"
        ]
    },
    {
        "func_name": "timeit",
        "original": "def timeit(f):\n\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = f(*args, **kwargs)\n        end = time.time()\n        return res\n    return wrapper",
        "mutated": [
            "def timeit(f):\n    if False:\n        i = 10\n\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = f(*args, **kwargs)\n        end = time.time()\n        return res\n    return wrapper",
            "def timeit(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = f(*args, **kwargs)\n        end = time.time()\n        return res\n    return wrapper",
            "def timeit(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = f(*args, **kwargs)\n        end = time.time()\n        return res\n    return wrapper",
            "def timeit(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = f(*args, **kwargs)\n        end = time.time()\n        return res\n    return wrapper",
            "def timeit(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = f(*args, **kwargs)\n        end = time.time()\n        return res\n    return wrapper"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, filename):\n    self.filename = filename\n    self.json_name = filename + '.json'\n    self.error_list = []\n    self.warning_list = []\n    self.info_list = []\n    self.debug_list = []\n    self.tick_amount = 1\n    self.names = self.messages_names = 'error warning info debug'.split(' ')",
        "mutated": [
            "def __init__(self, filename):\n    if False:\n        i = 10\n    self.filename = filename\n    self.json_name = filename + '.json'\n    self.error_list = []\n    self.warning_list = []\n    self.info_list = []\n    self.debug_list = []\n    self.tick_amount = 1\n    self.names = self.messages_names = 'error warning info debug'.split(' ')",
            "def __init__(self, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.filename = filename\n    self.json_name = filename + '.json'\n    self.error_list = []\n    self.warning_list = []\n    self.info_list = []\n    self.debug_list = []\n    self.tick_amount = 1\n    self.names = self.messages_names = 'error warning info debug'.split(' ')",
            "def __init__(self, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.filename = filename\n    self.json_name = filename + '.json'\n    self.error_list = []\n    self.warning_list = []\n    self.info_list = []\n    self.debug_list = []\n    self.tick_amount = 1\n    self.names = self.messages_names = 'error warning info debug'.split(' ')",
            "def __init__(self, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.filename = filename\n    self.json_name = filename + '.json'\n    self.error_list = []\n    self.warning_list = []\n    self.info_list = []\n    self.debug_list = []\n    self.tick_amount = 1\n    self.names = self.messages_names = 'error warning info debug'.split(' ')",
            "def __init__(self, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.filename = filename\n    self.json_name = filename + '.json'\n    self.error_list = []\n    self.warning_list = []\n    self.info_list = []\n    self.debug_list = []\n    self.tick_amount = 1\n    self.names = self.messages_names = 'error warning info debug'.split(' ')"
        ]
    },
    {
        "func_name": "tick",
        "original": "def tick(self):\n    self.tick_amount += 1\n    return self.tick_amount",
        "mutated": [
            "def tick(self):\n    if False:\n        i = 10\n    self.tick_amount += 1\n    return self.tick_amount",
            "def tick(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.tick_amount += 1\n    return self.tick_amount",
            "def tick(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.tick_amount += 1\n    return self.tick_amount",
            "def tick(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.tick_amount += 1\n    return self.tick_amount",
            "def tick(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.tick_amount += 1\n    return self.tick_amount"
        ]
    },
    {
        "func_name": "error",
        "original": "def error(self, m, metadata={}):\n    self.error_list.append([self.tick(), m, metadata])",
        "mutated": [
            "def error(self, m, metadata={}):\n    if False:\n        i = 10\n    self.error_list.append([self.tick(), m, metadata])",
            "def error(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.error_list.append([self.tick(), m, metadata])",
            "def error(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.error_list.append([self.tick(), m, metadata])",
            "def error(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.error_list.append([self.tick(), m, metadata])",
            "def error(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.error_list.append([self.tick(), m, metadata])"
        ]
    },
    {
        "func_name": "warning",
        "original": "def warning(self, m, metadata={}):\n    self.warning_list.append([self.tick(), m, metadata])",
        "mutated": [
            "def warning(self, m, metadata={}):\n    if False:\n        i = 10\n    self.warning_list.append([self.tick(), m, metadata])",
            "def warning(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.warning_list.append([self.tick(), m, metadata])",
            "def warning(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.warning_list.append([self.tick(), m, metadata])",
            "def warning(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.warning_list.append([self.tick(), m, metadata])",
            "def warning(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.warning_list.append([self.tick(), m, metadata])"
        ]
    },
    {
        "func_name": "info",
        "original": "def info(self, m, metadata={}):\n    self.info_list.append([self.tick(), m, metadata])",
        "mutated": [
            "def info(self, m, metadata={}):\n    if False:\n        i = 10\n    self.info_list.append([self.tick(), m, metadata])",
            "def info(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.info_list.append([self.tick(), m, metadata])",
            "def info(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.info_list.append([self.tick(), m, metadata])",
            "def info(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.info_list.append([self.tick(), m, metadata])",
            "def info(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.info_list.append([self.tick(), m, metadata])"
        ]
    },
    {
        "func_name": "debug",
        "original": "def debug(self, m, metadata={}):\n    self.debug_list.append([self.tick(), m, metadata])",
        "mutated": [
            "def debug(self, m, metadata={}):\n    if False:\n        i = 10\n    self.debug_list.append([self.tick(), m, metadata])",
            "def debug(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.debug_list.append([self.tick(), m, metadata])",
            "def debug(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.debug_list.append([self.tick(), m, metadata])",
            "def debug(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.debug_list.append([self.tick(), m, metadata])",
            "def debug(self, m, metadata={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.debug_list.append([self.tick(), m, metadata])"
        ]
    },
    {
        "func_name": "tolist",
        "original": "def tolist(self):\n    return zip([self.error_list, self.warning_list, self.info_list, self.debug_list], self.names)",
        "mutated": [
            "def tolist(self):\n    if False:\n        i = 10\n    return zip([self.error_list, self.warning_list, self.info_list, self.debug_list], self.names)",
            "def tolist(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return zip([self.error_list, self.warning_list, self.info_list, self.debug_list], self.names)",
            "def tolist(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return zip([self.error_list, self.warning_list, self.info_list, self.debug_list], self.names)",
            "def tolist(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return zip([self.error_list, self.warning_list, self.info_list, self.debug_list], self.names)",
            "def tolist(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return zip([self.error_list, self.warning_list, self.info_list, self.debug_list], self.names)"
        ]
    },
    {
        "func_name": "todict",
        "original": "def todict(self):\n    return {'error': self.error_list, 'warning': self.warning_list, 'info': self.info_list, 'debug': self.debug_list}",
        "mutated": [
            "def todict(self):\n    if False:\n        i = 10\n    return {'error': self.error_list, 'warning': self.warning_list, 'info': self.info_list, 'debug': self.debug_list}",
            "def todict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return {'error': self.error_list, 'warning': self.warning_list, 'info': self.info_list, 'debug': self.debug_list}",
            "def todict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return {'error': self.error_list, 'warning': self.warning_list, 'info': self.info_list, 'debug': self.debug_list}",
            "def todict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return {'error': self.error_list, 'warning': self.warning_list, 'info': self.info_list, 'debug': self.debug_list}",
            "def todict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return {'error': self.error_list, 'warning': self.warning_list, 'info': self.info_list, 'debug': self.debug_list}"
        ]
    },
    {
        "func_name": "save",
        "original": "@timeit\ndef save(self):\n    \"\"\"\n\t\t{\n\t\t\t'message_type' : message_type,\n\t\t\t'message_text' : m_text,\n\t\t\t'message_time' : m_time,\n\t\t\t'message_metadata' : m_metadata\n\t\t}\n\t\t\"\"\"\n    all_messages_list = []\n    for (messages, message_type) in self.tolist():\n        results_ = [{'message_type': message_type, 'message_text': m_text, 'message_time': m_time, 'message_metadata': m_metadata} for (m_time, m_text, m_metadata) in messages]\n        all_messages_list.extend(results_)\n    all_messages_list = sorted(all_messages_list, key=lambda x: x['message_time'])\n    writejson(self.json_name, all_messages_list)",
        "mutated": [
            "@timeit\ndef save(self):\n    if False:\n        i = 10\n    \"\\n\\t\\t{\\n\\t\\t\\t'message_type' : message_type,\\n\\t\\t\\t'message_text' : m_text,\\n\\t\\t\\t'message_time' : m_time,\\n\\t\\t\\t'message_metadata' : m_metadata\\n\\t\\t}\\n\\t\\t\"\n    all_messages_list = []\n    for (messages, message_type) in self.tolist():\n        results_ = [{'message_type': message_type, 'message_text': m_text, 'message_time': m_time, 'message_metadata': m_metadata} for (m_time, m_text, m_metadata) in messages]\n        all_messages_list.extend(results_)\n    all_messages_list = sorted(all_messages_list, key=lambda x: x['message_time'])\n    writejson(self.json_name, all_messages_list)",
            "@timeit\ndef save(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n\\t\\t{\\n\\t\\t\\t'message_type' : message_type,\\n\\t\\t\\t'message_text' : m_text,\\n\\t\\t\\t'message_time' : m_time,\\n\\t\\t\\t'message_metadata' : m_metadata\\n\\t\\t}\\n\\t\\t\"\n    all_messages_list = []\n    for (messages, message_type) in self.tolist():\n        results_ = [{'message_type': message_type, 'message_text': m_text, 'message_time': m_time, 'message_metadata': m_metadata} for (m_time, m_text, m_metadata) in messages]\n        all_messages_list.extend(results_)\n    all_messages_list = sorted(all_messages_list, key=lambda x: x['message_time'])\n    writejson(self.json_name, all_messages_list)",
            "@timeit\ndef save(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n\\t\\t{\\n\\t\\t\\t'message_type' : message_type,\\n\\t\\t\\t'message_text' : m_text,\\n\\t\\t\\t'message_time' : m_time,\\n\\t\\t\\t'message_metadata' : m_metadata\\n\\t\\t}\\n\\t\\t\"\n    all_messages_list = []\n    for (messages, message_type) in self.tolist():\n        results_ = [{'message_type': message_type, 'message_text': m_text, 'message_time': m_time, 'message_metadata': m_metadata} for (m_time, m_text, m_metadata) in messages]\n        all_messages_list.extend(results_)\n    all_messages_list = sorted(all_messages_list, key=lambda x: x['message_time'])\n    writejson(self.json_name, all_messages_list)",
            "@timeit\ndef save(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n\\t\\t{\\n\\t\\t\\t'message_type' : message_type,\\n\\t\\t\\t'message_text' : m_text,\\n\\t\\t\\t'message_time' : m_time,\\n\\t\\t\\t'message_metadata' : m_metadata\\n\\t\\t}\\n\\t\\t\"\n    all_messages_list = []\n    for (messages, message_type) in self.tolist():\n        results_ = [{'message_type': message_type, 'message_text': m_text, 'message_time': m_time, 'message_metadata': m_metadata} for (m_time, m_text, m_metadata) in messages]\n        all_messages_list.extend(results_)\n    all_messages_list = sorted(all_messages_list, key=lambda x: x['message_time'])\n    writejson(self.json_name, all_messages_list)",
            "@timeit\ndef save(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n\\t\\t{\\n\\t\\t\\t'message_type' : message_type,\\n\\t\\t\\t'message_text' : m_text,\\n\\t\\t\\t'message_time' : m_time,\\n\\t\\t\\t'message_metadata' : m_metadata\\n\\t\\t}\\n\\t\\t\"\n    all_messages_list = []\n    for (messages, message_type) in self.tolist():\n        results_ = [{'message_type': message_type, 'message_text': m_text, 'message_time': m_time, 'message_metadata': m_metadata} for (m_time, m_text, m_metadata) in messages]\n        all_messages_list.extend(results_)\n    all_messages_list = sorted(all_messages_list, key=lambda x: x['message_time'])\n    writejson(self.json_name, all_messages_list)"
        ]
    },
    {
        "func_name": "format_message",
        "original": "def format_message(message):\n    if kw['show_time']:\n        return str(message['message_time']) + ':' + message['message_text']\n    else:\n        return message['message_text']",
        "mutated": [
            "def format_message(message):\n    if False:\n        i = 10\n    if kw['show_time']:\n        return str(message['message_time']) + ':' + message['message_text']\n    else:\n        return message['message_text']",
            "def format_message(message):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if kw['show_time']:\n        return str(message['message_time']) + ':' + message['message_text']\n    else:\n        return message['message_text']",
            "def format_message(message):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if kw['show_time']:\n        return str(message['message_time']) + ':' + message['message_text']\n    else:\n        return message['message_text']",
            "def format_message(message):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if kw['show_time']:\n        return str(message['message_time']) + ':' + message['message_text']\n    else:\n        return message['message_text']",
            "def format_message(message):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if kw['show_time']:\n        return str(message['message_time']) + ':' + message['message_text']\n    else:\n        return message['message_text']"
        ]
    },
    {
        "func_name": "load",
        "original": "@timeit\ndef load(self, **kw):\n    \"\"\"\n\t\t\treturn dict with messages\n\t\t\t\n\t\t\tkw = {\n\t\t\t\tuse_psg_color : bool\n\t\t\t\tshow_time : bool\n\t\t\t}\n\t\t\"\"\"\n    all_messages_list = readjson(self.json_name)\n\n    def format_message(message):\n        if kw['show_time']:\n            return str(message['message_time']) + ':' + message['message_text']\n        else:\n            return message['message_text']\n    error_list = [i for i in all_messages_list if i['message_type'] == 'error']\n    warning_list = [i for i in all_messages_list if i['message_type'] == 'warning']\n    info_list = [i for i in all_messages_list if i['message_type'] == 'info']\n    debug_list = [i for i in all_messages_list if i['message_type'] == 'debug']\n    colors = {'warning': 'blue', 'info': 'black'}\n    warning_info_ = []\n    for message in sorted(warning_list + info_list, key=lambda x: x['message_time']):\n        if kw['use_psg_color']:\n            warning_info_.append([format_message(message), colors.get(message['message_type'])])\n        else:\n            warning_info_.append(format_message(message))\n    error_list = [format_message(i) for i in error_list]\n    warning_list = [format_message(i) for i in warning_list]\n    info_list = [format_message(i) for i in info_list]\n    debug_list = [format_message(i) for i in debug_list]\n    return (error_list, warning_list, info_list, debug_list, warning_info_)",
        "mutated": [
            "@timeit\ndef load(self, **kw):\n    if False:\n        i = 10\n    '\\n\\t\\t\\treturn dict with messages\\n\\t\\t\\t\\n\\t\\t\\tkw = {\\n\\t\\t\\t\\tuse_psg_color : bool\\n\\t\\t\\t\\tshow_time : bool\\n\\t\\t\\t}\\n\\t\\t'\n    all_messages_list = readjson(self.json_name)\n\n    def format_message(message):\n        if kw['show_time']:\n            return str(message['message_time']) + ':' + message['message_text']\n        else:\n            return message['message_text']\n    error_list = [i for i in all_messages_list if i['message_type'] == 'error']\n    warning_list = [i for i in all_messages_list if i['message_type'] == 'warning']\n    info_list = [i for i in all_messages_list if i['message_type'] == 'info']\n    debug_list = [i for i in all_messages_list if i['message_type'] == 'debug']\n    colors = {'warning': 'blue', 'info': 'black'}\n    warning_info_ = []\n    for message in sorted(warning_list + info_list, key=lambda x: x['message_time']):\n        if kw['use_psg_color']:\n            warning_info_.append([format_message(message), colors.get(message['message_type'])])\n        else:\n            warning_info_.append(format_message(message))\n    error_list = [format_message(i) for i in error_list]\n    warning_list = [format_message(i) for i in warning_list]\n    info_list = [format_message(i) for i in info_list]\n    debug_list = [format_message(i) for i in debug_list]\n    return (error_list, warning_list, info_list, debug_list, warning_info_)",
            "@timeit\ndef load(self, **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\\t\\treturn dict with messages\\n\\t\\t\\t\\n\\t\\t\\tkw = {\\n\\t\\t\\t\\tuse_psg_color : bool\\n\\t\\t\\t\\tshow_time : bool\\n\\t\\t\\t}\\n\\t\\t'\n    all_messages_list = readjson(self.json_name)\n\n    def format_message(message):\n        if kw['show_time']:\n            return str(message['message_time']) + ':' + message['message_text']\n        else:\n            return message['message_text']\n    error_list = [i for i in all_messages_list if i['message_type'] == 'error']\n    warning_list = [i for i in all_messages_list if i['message_type'] == 'warning']\n    info_list = [i for i in all_messages_list if i['message_type'] == 'info']\n    debug_list = [i for i in all_messages_list if i['message_type'] == 'debug']\n    colors = {'warning': 'blue', 'info': 'black'}\n    warning_info_ = []\n    for message in sorted(warning_list + info_list, key=lambda x: x['message_time']):\n        if kw['use_psg_color']:\n            warning_info_.append([format_message(message), colors.get(message['message_type'])])\n        else:\n            warning_info_.append(format_message(message))\n    error_list = [format_message(i) for i in error_list]\n    warning_list = [format_message(i) for i in warning_list]\n    info_list = [format_message(i) for i in info_list]\n    debug_list = [format_message(i) for i in debug_list]\n    return (error_list, warning_list, info_list, debug_list, warning_info_)",
            "@timeit\ndef load(self, **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\\t\\treturn dict with messages\\n\\t\\t\\t\\n\\t\\t\\tkw = {\\n\\t\\t\\t\\tuse_psg_color : bool\\n\\t\\t\\t\\tshow_time : bool\\n\\t\\t\\t}\\n\\t\\t'\n    all_messages_list = readjson(self.json_name)\n\n    def format_message(message):\n        if kw['show_time']:\n            return str(message['message_time']) + ':' + message['message_text']\n        else:\n            return message['message_text']\n    error_list = [i for i in all_messages_list if i['message_type'] == 'error']\n    warning_list = [i for i in all_messages_list if i['message_type'] == 'warning']\n    info_list = [i for i in all_messages_list if i['message_type'] == 'info']\n    debug_list = [i for i in all_messages_list if i['message_type'] == 'debug']\n    colors = {'warning': 'blue', 'info': 'black'}\n    warning_info_ = []\n    for message in sorted(warning_list + info_list, key=lambda x: x['message_time']):\n        if kw['use_psg_color']:\n            warning_info_.append([format_message(message), colors.get(message['message_type'])])\n        else:\n            warning_info_.append(format_message(message))\n    error_list = [format_message(i) for i in error_list]\n    warning_list = [format_message(i) for i in warning_list]\n    info_list = [format_message(i) for i in info_list]\n    debug_list = [format_message(i) for i in debug_list]\n    return (error_list, warning_list, info_list, debug_list, warning_info_)",
            "@timeit\ndef load(self, **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\\t\\treturn dict with messages\\n\\t\\t\\t\\n\\t\\t\\tkw = {\\n\\t\\t\\t\\tuse_psg_color : bool\\n\\t\\t\\t\\tshow_time : bool\\n\\t\\t\\t}\\n\\t\\t'\n    all_messages_list = readjson(self.json_name)\n\n    def format_message(message):\n        if kw['show_time']:\n            return str(message['message_time']) + ':' + message['message_text']\n        else:\n            return message['message_text']\n    error_list = [i for i in all_messages_list if i['message_type'] == 'error']\n    warning_list = [i for i in all_messages_list if i['message_type'] == 'warning']\n    info_list = [i for i in all_messages_list if i['message_type'] == 'info']\n    debug_list = [i for i in all_messages_list if i['message_type'] == 'debug']\n    colors = {'warning': 'blue', 'info': 'black'}\n    warning_info_ = []\n    for message in sorted(warning_list + info_list, key=lambda x: x['message_time']):\n        if kw['use_psg_color']:\n            warning_info_.append([format_message(message), colors.get(message['message_type'])])\n        else:\n            warning_info_.append(format_message(message))\n    error_list = [format_message(i) for i in error_list]\n    warning_list = [format_message(i) for i in warning_list]\n    info_list = [format_message(i) for i in info_list]\n    debug_list = [format_message(i) for i in debug_list]\n    return (error_list, warning_list, info_list, debug_list, warning_info_)",
            "@timeit\ndef load(self, **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\\t\\treturn dict with messages\\n\\t\\t\\t\\n\\t\\t\\tkw = {\\n\\t\\t\\t\\tuse_psg_color : bool\\n\\t\\t\\t\\tshow_time : bool\\n\\t\\t\\t}\\n\\t\\t'\n    all_messages_list = readjson(self.json_name)\n\n    def format_message(message):\n        if kw['show_time']:\n            return str(message['message_time']) + ':' + message['message_text']\n        else:\n            return message['message_text']\n    error_list = [i for i in all_messages_list if i['message_type'] == 'error']\n    warning_list = [i for i in all_messages_list if i['message_type'] == 'warning']\n    info_list = [i for i in all_messages_list if i['message_type'] == 'info']\n    debug_list = [i for i in all_messages_list if i['message_type'] == 'debug']\n    colors = {'warning': 'blue', 'info': 'black'}\n    warning_info_ = []\n    for message in sorted(warning_list + info_list, key=lambda x: x['message_time']):\n        if kw['use_psg_color']:\n            warning_info_.append([format_message(message), colors.get(message['message_type'])])\n        else:\n            warning_info_.append(format_message(message))\n    error_list = [format_message(i) for i in error_list]\n    warning_list = [format_message(i) for i in warning_list]\n    info_list = [format_message(i) for i in info_list]\n    debug_list = [format_message(i) for i in debug_list]\n    return (error_list, warning_list, info_list, debug_list, warning_info_)"
        ]
    },
    {
        "func_name": "load_to_listbox",
        "original": "@timeit\ndef load_to_listbox(self):\n    \"\"\"\n\t\tread .json\n\t\t\"\"\"\n    return sorted(readjson(self.json_name), key=lambda x: x['message_time'])",
        "mutated": [
            "@timeit\ndef load_to_listbox(self):\n    if False:\n        i = 10\n    '\\n\\t\\tread .json\\n\\t\\t'\n    return sorted(readjson(self.json_name), key=lambda x: x['message_time'])",
            "@timeit\ndef load_to_listbox(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\\tread .json\\n\\t\\t'\n    return sorted(readjson(self.json_name), key=lambda x: x['message_time'])",
            "@timeit\ndef load_to_listbox(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\\tread .json\\n\\t\\t'\n    return sorted(readjson(self.json_name), key=lambda x: x['message_time'])",
            "@timeit\ndef load_to_listbox(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\\tread .json\\n\\t\\t'\n    return sorted(readjson(self.json_name), key=lambda x: x['message_time'])",
            "@timeit\ndef load_to_listbox(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\\tread .json\\n\\t\\t'\n    return sorted(readjson(self.json_name), key=lambda x: x['message_time'])"
        ]
    },
    {
        "func_name": "compile_call_ref",
        "original": "@timeit\ndef compile_call_ref(output_filename='LoG_call_ref', **kw):\n    \"\"\" Compile a \"5_call_reference.md\" file\"\"\"\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, main_md_file='markdown input files/5_call_reference.md', insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[], output_name=CALL_REFERENCE_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
        "mutated": [
            "@timeit\ndef compile_call_ref(output_filename='LoG_call_ref', **kw):\n    if False:\n        i = 10\n    ' Compile a \"5_call_reference.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, main_md_file='markdown input files/5_call_reference.md', insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[], output_name=CALL_REFERENCE_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
            "@timeit\ndef compile_call_ref(output_filename='LoG_call_ref', **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Compile a \"5_call_reference.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, main_md_file='markdown input files/5_call_reference.md', insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[], output_name=CALL_REFERENCE_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
            "@timeit\ndef compile_call_ref(output_filename='LoG_call_ref', **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Compile a \"5_call_reference.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, main_md_file='markdown input files/5_call_reference.md', insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[], output_name=CALL_REFERENCE_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
            "@timeit\ndef compile_call_ref(output_filename='LoG_call_ref', **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Compile a \"5_call_reference.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, main_md_file='markdown input files/5_call_reference.md', insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[], output_name=CALL_REFERENCE_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
            "@timeit\ndef compile_call_ref(output_filename='LoG_call_ref', **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Compile a \"5_call_reference.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, main_md_file='markdown input files/5_call_reference.md', insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[], output_name=CALL_REFERENCE_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())"
        ]
    },
    {
        "func_name": "compile_readme",
        "original": "@timeit\ndef compile_readme(output_filename='LoG', **kw):\n    \"\"\" Compile a \"2_readme.md\" file\"\"\"\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[0, 1, 2, 3], output_name=README_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
        "mutated": [
            "@timeit\ndef compile_readme(output_filename='LoG', **kw):\n    if False:\n        i = 10\n    ' Compile a \"2_readme.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[0, 1, 2, 3], output_name=README_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
            "@timeit\ndef compile_readme(output_filename='LoG', **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Compile a \"2_readme.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[0, 1, 2, 3], output_name=README_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
            "@timeit\ndef compile_readme(output_filename='LoG', **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Compile a \"2_readme.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[0, 1, 2, 3], output_name=README_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
            "@timeit\ndef compile_readme(output_filename='LoG', **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Compile a \"2_readme.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[0, 1, 2, 3], output_name=README_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())",
            "@timeit\ndef compile_readme(output_filename='LoG', **kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Compile a \"2_readme.md\" file'\n    log_obj = BESTLOG(os.path.join(cd, output_filename))\n    main(logger=log_obj, insert_md_section_for__class_methods=insert_md_section_for__class_methods, remove_repeated_sections_classmethods=remove_repeated_sections_classmethods, files_to_include=[0, 1, 2, 3], output_name=README_OFILENAME, delete_html_comments=True)\n    log_obj.save()\n    return (log_obj.load(**kw), log_obj.load_to_listbox())"
        ]
    },
    {
        "func_name": "compile_all_stuff",
        "original": "def compile_all_stuff(**kw):\n    \"\"\"\n\t\tCompile a \"2_ and 5_\" .md filess\n\t\treturn output from them\n\t\"\"\"\n    return (compile_readme(**kw), compile_call_ref(**kw))",
        "mutated": [
            "def compile_all_stuff(**kw):\n    if False:\n        i = 10\n    '\\n\\t\\tCompile a \"2_ and 5_\" .md filess\\n\\t\\treturn output from them\\n\\t'\n    return (compile_readme(**kw), compile_call_ref(**kw))",
            "def compile_all_stuff(**kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\\tCompile a \"2_ and 5_\" .md filess\\n\\t\\treturn output from them\\n\\t'\n    return (compile_readme(**kw), compile_call_ref(**kw))",
            "def compile_all_stuff(**kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\\tCompile a \"2_ and 5_\" .md filess\\n\\t\\treturn output from them\\n\\t'\n    return (compile_readme(**kw), compile_call_ref(**kw))",
            "def compile_all_stuff(**kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\\tCompile a \"2_ and 5_\" .md filess\\n\\t\\treturn output from them\\n\\t'\n    return (compile_readme(**kw), compile_call_ref(**kw))",
            "def compile_all_stuff(**kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\\tCompile a \"2_ and 5_\" .md filess\\n\\t\\treturn output from them\\n\\t'\n    return (compile_readme(**kw), compile_call_ref(**kw))"
        ]
    },
    {
        "func_name": "md2psg",
        "original": "def md2psg(target_text):\n    \"\"\"\n\t\tib<space>color\n\t\ti italic\n\t\tb bold\n\t\tcolor = can be word   can be color\n\t\t\t\tred             #ff00111\n\t\t\t\tgreen\n\t\t\t\tblue\n\t\ti?b?\\\\s?\\\\w+?\n\n\n\t\tusage\n\t\t  *i*a**            italic\n\t\t  *b*a**            bold\n\t\t  *ib*a**           italic bold\n\t\t  *ib red*a**       italic bold red\n\t\t  *b green*a**      bold green\n\t\t\n\t\t'This was *I*special** message from *B*him**. And from *Igreen*this** to *Ired*this**'\n\t\"\"\"\n    font_norm = 'Mono 12 '\n    font_bold = 'Mono 12 italic'\n    font_italic = 'Mono 12 bold'\n    list_of_Ts = []\n    parts = [i for i in re.compile('(\\\\*I?B?[a-z]*?\\\\*[\\\\d\\\\D]*?\\\\*\\\\*)', flags=re.M | re.DOTALL).split(target_text) if i is not None]\n    for (index, text) in enumerate(parts):\n        if index % 2 == 0:\n            T_text = text\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), font=font_norm)\n        else:\n            T_parameters = {'font': font_norm}\n            my_format = text[1:].split('*')[0]\n            if 'I' in my_format:\n                T_parameters['font'] = font_italic\n            if 'B' in my_format:\n                T_parameters['font'] = font_bold\n            color_left = my_format.replace('I', '').replace('B', '')\n            if color_left:\n                T_parameters['text_color'] = color_left\n            T_text = '*'.join(text.split('*')[2:-2])\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), **T_parameters)\n        list_of_Ts.append(T)\n    return list_of_Ts",
        "mutated": [
            "def md2psg(target_text):\n    if False:\n        i = 10\n    \"\\n\\t\\tib<space>color\\n\\t\\ti italic\\n\\t\\tb bold\\n\\t\\tcolor = can be word   can be color\\n\\t\\t\\t\\tred             #ff00111\\n\\t\\t\\t\\tgreen\\n\\t\\t\\t\\tblue\\n\\t\\ti?b?\\\\s?\\\\w+?\\n\\n\\n\\t\\tusage\\n\\t\\t  *i*a**            italic\\n\\t\\t  *b*a**            bold\\n\\t\\t  *ib*a**           italic bold\\n\\t\\t  *ib red*a**       italic bold red\\n\\t\\t  *b green*a**      bold green\\n\\t\\t\\n\\t\\t'This was *I*special** message from *B*him**. And from *Igreen*this** to *Ired*this**'\\n\\t\"\n    font_norm = 'Mono 12 '\n    font_bold = 'Mono 12 italic'\n    font_italic = 'Mono 12 bold'\n    list_of_Ts = []\n    parts = [i for i in re.compile('(\\\\*I?B?[a-z]*?\\\\*[\\\\d\\\\D]*?\\\\*\\\\*)', flags=re.M | re.DOTALL).split(target_text) if i is not None]\n    for (index, text) in enumerate(parts):\n        if index % 2 == 0:\n            T_text = text\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), font=font_norm)\n        else:\n            T_parameters = {'font': font_norm}\n            my_format = text[1:].split('*')[0]\n            if 'I' in my_format:\n                T_parameters['font'] = font_italic\n            if 'B' in my_format:\n                T_parameters['font'] = font_bold\n            color_left = my_format.replace('I', '').replace('B', '')\n            if color_left:\n                T_parameters['text_color'] = color_left\n            T_text = '*'.join(text.split('*')[2:-2])\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), **T_parameters)\n        list_of_Ts.append(T)\n    return list_of_Ts",
            "def md2psg(target_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n\\t\\tib<space>color\\n\\t\\ti italic\\n\\t\\tb bold\\n\\t\\tcolor = can be word   can be color\\n\\t\\t\\t\\tred             #ff00111\\n\\t\\t\\t\\tgreen\\n\\t\\t\\t\\tblue\\n\\t\\ti?b?\\\\s?\\\\w+?\\n\\n\\n\\t\\tusage\\n\\t\\t  *i*a**            italic\\n\\t\\t  *b*a**            bold\\n\\t\\t  *ib*a**           italic bold\\n\\t\\t  *ib red*a**       italic bold red\\n\\t\\t  *b green*a**      bold green\\n\\t\\t\\n\\t\\t'This was *I*special** message from *B*him**. And from *Igreen*this** to *Ired*this**'\\n\\t\"\n    font_norm = 'Mono 12 '\n    font_bold = 'Mono 12 italic'\n    font_italic = 'Mono 12 bold'\n    list_of_Ts = []\n    parts = [i for i in re.compile('(\\\\*I?B?[a-z]*?\\\\*[\\\\d\\\\D]*?\\\\*\\\\*)', flags=re.M | re.DOTALL).split(target_text) if i is not None]\n    for (index, text) in enumerate(parts):\n        if index % 2 == 0:\n            T_text = text\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), font=font_norm)\n        else:\n            T_parameters = {'font': font_norm}\n            my_format = text[1:].split('*')[0]\n            if 'I' in my_format:\n                T_parameters['font'] = font_italic\n            if 'B' in my_format:\n                T_parameters['font'] = font_bold\n            color_left = my_format.replace('I', '').replace('B', '')\n            if color_left:\n                T_parameters['text_color'] = color_left\n            T_text = '*'.join(text.split('*')[2:-2])\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), **T_parameters)\n        list_of_Ts.append(T)\n    return list_of_Ts",
            "def md2psg(target_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n\\t\\tib<space>color\\n\\t\\ti italic\\n\\t\\tb bold\\n\\t\\tcolor = can be word   can be color\\n\\t\\t\\t\\tred             #ff00111\\n\\t\\t\\t\\tgreen\\n\\t\\t\\t\\tblue\\n\\t\\ti?b?\\\\s?\\\\w+?\\n\\n\\n\\t\\tusage\\n\\t\\t  *i*a**            italic\\n\\t\\t  *b*a**            bold\\n\\t\\t  *ib*a**           italic bold\\n\\t\\t  *ib red*a**       italic bold red\\n\\t\\t  *b green*a**      bold green\\n\\t\\t\\n\\t\\t'This was *I*special** message from *B*him**. And from *Igreen*this** to *Ired*this**'\\n\\t\"\n    font_norm = 'Mono 12 '\n    font_bold = 'Mono 12 italic'\n    font_italic = 'Mono 12 bold'\n    list_of_Ts = []\n    parts = [i for i in re.compile('(\\\\*I?B?[a-z]*?\\\\*[\\\\d\\\\D]*?\\\\*\\\\*)', flags=re.M | re.DOTALL).split(target_text) if i is not None]\n    for (index, text) in enumerate(parts):\n        if index % 2 == 0:\n            T_text = text\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), font=font_norm)\n        else:\n            T_parameters = {'font': font_norm}\n            my_format = text[1:].split('*')[0]\n            if 'I' in my_format:\n                T_parameters['font'] = font_italic\n            if 'B' in my_format:\n                T_parameters['font'] = font_bold\n            color_left = my_format.replace('I', '').replace('B', '')\n            if color_left:\n                T_parameters['text_color'] = color_left\n            T_text = '*'.join(text.split('*')[2:-2])\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), **T_parameters)\n        list_of_Ts.append(T)\n    return list_of_Ts",
            "def md2psg(target_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n\\t\\tib<space>color\\n\\t\\ti italic\\n\\t\\tb bold\\n\\t\\tcolor = can be word   can be color\\n\\t\\t\\t\\tred             #ff00111\\n\\t\\t\\t\\tgreen\\n\\t\\t\\t\\tblue\\n\\t\\ti?b?\\\\s?\\\\w+?\\n\\n\\n\\t\\tusage\\n\\t\\t  *i*a**            italic\\n\\t\\t  *b*a**            bold\\n\\t\\t  *ib*a**           italic bold\\n\\t\\t  *ib red*a**       italic bold red\\n\\t\\t  *b green*a**      bold green\\n\\t\\t\\n\\t\\t'This was *I*special** message from *B*him**. And from *Igreen*this** to *Ired*this**'\\n\\t\"\n    font_norm = 'Mono 12 '\n    font_bold = 'Mono 12 italic'\n    font_italic = 'Mono 12 bold'\n    list_of_Ts = []\n    parts = [i for i in re.compile('(\\\\*I?B?[a-z]*?\\\\*[\\\\d\\\\D]*?\\\\*\\\\*)', flags=re.M | re.DOTALL).split(target_text) if i is not None]\n    for (index, text) in enumerate(parts):\n        if index % 2 == 0:\n            T_text = text\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), font=font_norm)\n        else:\n            T_parameters = {'font': font_norm}\n            my_format = text[1:].split('*')[0]\n            if 'I' in my_format:\n                T_parameters['font'] = font_italic\n            if 'B' in my_format:\n                T_parameters['font'] = font_bold\n            color_left = my_format.replace('I', '').replace('B', '')\n            if color_left:\n                T_parameters['text_color'] = color_left\n            T_text = '*'.join(text.split('*')[2:-2])\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), **T_parameters)\n        list_of_Ts.append(T)\n    return list_of_Ts",
            "def md2psg(target_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n\\t\\tib<space>color\\n\\t\\ti italic\\n\\t\\tb bold\\n\\t\\tcolor = can be word   can be color\\n\\t\\t\\t\\tred             #ff00111\\n\\t\\t\\t\\tgreen\\n\\t\\t\\t\\tblue\\n\\t\\ti?b?\\\\s?\\\\w+?\\n\\n\\n\\t\\tusage\\n\\t\\t  *i*a**            italic\\n\\t\\t  *b*a**            bold\\n\\t\\t  *ib*a**           italic bold\\n\\t\\t  *ib red*a**       italic bold red\\n\\t\\t  *b green*a**      bold green\\n\\t\\t\\n\\t\\t'This was *I*special** message from *B*him**. And from *Igreen*this** to *Ired*this**'\\n\\t\"\n    font_norm = 'Mono 12 '\n    font_bold = 'Mono 12 italic'\n    font_italic = 'Mono 12 bold'\n    list_of_Ts = []\n    parts = [i for i in re.compile('(\\\\*I?B?[a-z]*?\\\\*[\\\\d\\\\D]*?\\\\*\\\\*)', flags=re.M | re.DOTALL).split(target_text) if i is not None]\n    for (index, text) in enumerate(parts):\n        if index % 2 == 0:\n            T_text = text\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), font=font_norm)\n        else:\n            T_parameters = {'font': font_norm}\n            my_format = text[1:].split('*')[0]\n            if 'I' in my_format:\n                T_parameters['font'] = font_italic\n            if 'B' in my_format:\n                T_parameters['font'] = font_bold\n            color_left = my_format.replace('I', '').replace('B', '')\n            if color_left:\n                T_parameters['text_color'] = color_left\n            T_text = '*'.join(text.split('*')[2:-2])\n            T = sg.T(T_text, size=(len(T_text), 1), pad=(0, 0), **T_parameters)\n        list_of_Ts.append(T)\n    return list_of_Ts"
        ]
    },
    {
        "func_name": "tabs",
        "original": "def tabs(*layouts):\n    return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])",
        "mutated": [
            "def tabs(*layouts):\n    if False:\n        i = 10\n    return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])",
            "def tabs(*layouts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])",
            "def tabs(*layouts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])",
            "def tabs(*layouts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])",
            "def tabs(*layouts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])"
        ]
    },
    {
        "func_name": "make_tab",
        "original": "def make_tab(word):\n\n    def tabs(*layouts):\n        return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n    return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]",
        "mutated": [
            "def make_tab(word):\n    if False:\n        i = 10\n\n    def tabs(*layouts):\n        return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n    return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]",
            "def make_tab(word):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def tabs(*layouts):\n        return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n    return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]",
            "def make_tab(word):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def tabs(*layouts):\n        return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n    return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]",
            "def make_tab(word):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def tabs(*layouts):\n        return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n    return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]",
            "def make_tab(word):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def tabs(*layouts):\n        return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n    return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]"
        ]
    },
    {
        "func_name": "next_star",
        "original": "def next_star():\n    middle = 100 / 2\n    for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n        yield i",
        "mutated": [
            "def next_star():\n    if False:\n        i = 10\n    middle = 100 / 2\n    for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n        yield i",
            "def next_star():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    middle = 100 / 2\n    for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n        yield i",
            "def next_star():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    middle = 100 / 2\n    for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n        yield i",
            "def next_star():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    middle = 100 / 2\n    for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n        yield i",
            "def next_star():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    middle = 100 / 2\n    for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n        yield i"
        ]
    },
    {
        "func_name": "empty_line",
        "original": "def empty_line(fontsize=12):\n    return [sg.T('', font='Mono ' + str(fontsize))]",
        "mutated": [
            "def empty_line(fontsize=12):\n    if False:\n        i = 10\n    return [sg.T('', font='Mono ' + str(fontsize))]",
            "def empty_line(fontsize=12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [sg.T('', font='Mono ' + str(fontsize))]",
            "def empty_line(fontsize=12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [sg.T('', font='Mono ' + str(fontsize))]",
            "def empty_line(fontsize=12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [sg.T('', font='Mono ' + str(fontsize))]",
            "def empty_line(fontsize=12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [sg.T('', font='Mono ' + str(fontsize))]"
        ]
    },
    {
        "func_name": "update_time_in_GUI",
        "original": "def update_time_in_GUI():\n    window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))",
        "mutated": [
            "def update_time_in_GUI():\n    if False:\n        i = 10\n    window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))",
            "def update_time_in_GUI():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))",
            "def update_time_in_GUI():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))",
            "def update_time_in_GUI():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))",
            "def update_time_in_GUI():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))"
        ]
    },
    {
        "func_name": "is_valid_regex_LogMessage",
        "original": "def is_valid_regex_LogMessage(msg: str):\n    nonlocal regex_str1, regex_str2\n    error1_found = False\n    if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n        error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n    error2_found = False\n    if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n        error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n    return not error1_found and (not error2_found)",
        "mutated": [
            "def is_valid_regex_LogMessage(msg: str):\n    if False:\n        i = 10\n    nonlocal regex_str1, regex_str2\n    error1_found = False\n    if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n        error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n    error2_found = False\n    if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n        error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n    return not error1_found and (not error2_found)",
            "def is_valid_regex_LogMessage(msg: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nonlocal regex_str1, regex_str2\n    error1_found = False\n    if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n        error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n    error2_found = False\n    if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n        error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n    return not error1_found and (not error2_found)",
            "def is_valid_regex_LogMessage(msg: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nonlocal regex_str1, regex_str2\n    error1_found = False\n    if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n        error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n    error2_found = False\n    if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n        error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n    return not error1_found and (not error2_found)",
            "def is_valid_regex_LogMessage(msg: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nonlocal regex_str1, regex_str2\n    error1_found = False\n    if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n        error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n    error2_found = False\n    if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n        error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n    return not error1_found and (not error2_found)",
            "def is_valid_regex_LogMessage(msg: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nonlocal regex_str1, regex_str2\n    error1_found = False\n    if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n        error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n    error2_found = False\n    if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n        error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n    return not error1_found and (not error2_found)"
        ]
    },
    {
        "func_name": "filter_log_messages",
        "original": "def filter_log_messages(messages):\n    if type(messages) is str:\n        return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n    raise TypeError",
        "mutated": [
            "def filter_log_messages(messages):\n    if False:\n        i = 10\n    if type(messages) is str:\n        return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n    raise TypeError",
            "def filter_log_messages(messages):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if type(messages) is str:\n        return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n    raise TypeError",
            "def filter_log_messages(messages):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if type(messages) is str:\n        return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n    raise TypeError",
            "def filter_log_messages(messages):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if type(messages) is str:\n        return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n    raise TypeError",
            "def filter_log_messages(messages):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if type(messages) is str:\n        return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n    raise TypeError"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, log_obj):\n    self.log_obj = log_obj\n    self.text = log_obj['message_text']",
        "mutated": [
            "def __init__(self, log_obj):\n    if False:\n        i = 10\n    self.log_obj = log_obj\n    self.text = log_obj['message_text']",
            "def __init__(self, log_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.log_obj = log_obj\n    self.text = log_obj['message_text']",
            "def __init__(self, log_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.log_obj = log_obj\n    self.text = log_obj['message_text']",
            "def __init__(self, log_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.log_obj = log_obj\n    self.text = log_obj['message_text']",
            "def __init__(self, log_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.log_obj = log_obj\n    self.text = log_obj['message_text']"
        ]
    },
    {
        "func_name": "__str__",
        "original": "def __str__(self):\n    return self.__repr__()",
        "mutated": [
            "def __str__(self):\n    if False:\n        i = 10\n    return self.__repr__()",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.__repr__()",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.__repr__()",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.__repr__()",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.__repr__()"
        ]
    },
    {
        "func_name": "__repr__",
        "original": "def __repr__(self):\n    \"\"\"qwe\"\"\"\n    text = self.log_obj['message_text']\n    metadata = self.log_obj['message_metadata']\n    lineno = ''\n    if 'lineno' in metadata.keys():\n        lineno = '(line:' + str(metadata['lineno']) + ') '\n    return f'{lineno} {text}'",
        "mutated": [
            "def __repr__(self):\n    if False:\n        i = 10\n    'qwe'\n    text = self.log_obj['message_text']\n    metadata = self.log_obj['message_metadata']\n    lineno = ''\n    if 'lineno' in metadata.keys():\n        lineno = '(line:' + str(metadata['lineno']) + ') '\n    return f'{lineno} {text}'",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'qwe'\n    text = self.log_obj['message_text']\n    metadata = self.log_obj['message_metadata']\n    lineno = ''\n    if 'lineno' in metadata.keys():\n        lineno = '(line:' + str(metadata['lineno']) + ') '\n    return f'{lineno} {text}'",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'qwe'\n    text = self.log_obj['message_text']\n    metadata = self.log_obj['message_metadata']\n    lineno = ''\n    if 'lineno' in metadata.keys():\n        lineno = '(line:' + str(metadata['lineno']) + ') '\n    return f'{lineno} {text}'",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'qwe'\n    text = self.log_obj['message_text']\n    metadata = self.log_obj['message_metadata']\n    lineno = ''\n    if 'lineno' in metadata.keys():\n        lineno = '(line:' + str(metadata['lineno']) + ') '\n    return f'{lineno} {text}'",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'qwe'\n    text = self.log_obj['message_text']\n    metadata = self.log_obj['message_metadata']\n    lineno = ''\n    if 'lineno' in metadata.keys():\n        lineno = '(line:' + str(metadata['lineno']) + ') '\n    return f'{lineno} {text}'"
        ]
    },
    {
        "func_name": "set_it",
        "original": "def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n    (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n    t_error = filter_log_messages(t_error)\n    t_warning = filter_log_messages(t_warning)\n    t_info = filter_log_messages(t_info)\n    t_debug = filter_log_messages(t_debug)\n    window[f'-{prefix}-error-'](t_error)\n    window[f'-{prefix}-warning-'](t_warning)\n    window[f'-{prefix}-info-'](t_info)\n    window[f'-{prefix}-debug-'](t_debug)\n    window[f'-{prefix}-warning_info-'].update('')\n    t_warning_info_obj = messages_obj[-1]\n    if values['use_psg_color']:\n        for (text, color) in t_warning_info_obj:\n            if not is_valid_regex_LogMessage(text):\n                continue\n            window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n    else:\n        window[f'-{prefix}-warning_info-'](t_warning_info_obj)",
        "mutated": [
            "def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n    if False:\n        i = 10\n    (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n    t_error = filter_log_messages(t_error)\n    t_warning = filter_log_messages(t_warning)\n    t_info = filter_log_messages(t_info)\n    t_debug = filter_log_messages(t_debug)\n    window[f'-{prefix}-error-'](t_error)\n    window[f'-{prefix}-warning-'](t_warning)\n    window[f'-{prefix}-info-'](t_info)\n    window[f'-{prefix}-debug-'](t_debug)\n    window[f'-{prefix}-warning_info-'].update('')\n    t_warning_info_obj = messages_obj[-1]\n    if values['use_psg_color']:\n        for (text, color) in t_warning_info_obj:\n            if not is_valid_regex_LogMessage(text):\n                continue\n            window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n    else:\n        window[f'-{prefix}-warning_info-'](t_warning_info_obj)",
            "def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n    t_error = filter_log_messages(t_error)\n    t_warning = filter_log_messages(t_warning)\n    t_info = filter_log_messages(t_info)\n    t_debug = filter_log_messages(t_debug)\n    window[f'-{prefix}-error-'](t_error)\n    window[f'-{prefix}-warning-'](t_warning)\n    window[f'-{prefix}-info-'](t_info)\n    window[f'-{prefix}-debug-'](t_debug)\n    window[f'-{prefix}-warning_info-'].update('')\n    t_warning_info_obj = messages_obj[-1]\n    if values['use_psg_color']:\n        for (text, color) in t_warning_info_obj:\n            if not is_valid_regex_LogMessage(text):\n                continue\n            window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n    else:\n        window[f'-{prefix}-warning_info-'](t_warning_info_obj)",
            "def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n    t_error = filter_log_messages(t_error)\n    t_warning = filter_log_messages(t_warning)\n    t_info = filter_log_messages(t_info)\n    t_debug = filter_log_messages(t_debug)\n    window[f'-{prefix}-error-'](t_error)\n    window[f'-{prefix}-warning-'](t_warning)\n    window[f'-{prefix}-info-'](t_info)\n    window[f'-{prefix}-debug-'](t_debug)\n    window[f'-{prefix}-warning_info-'].update('')\n    t_warning_info_obj = messages_obj[-1]\n    if values['use_psg_color']:\n        for (text, color) in t_warning_info_obj:\n            if not is_valid_regex_LogMessage(text):\n                continue\n            window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n    else:\n        window[f'-{prefix}-warning_info-'](t_warning_info_obj)",
            "def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n    t_error = filter_log_messages(t_error)\n    t_warning = filter_log_messages(t_warning)\n    t_info = filter_log_messages(t_info)\n    t_debug = filter_log_messages(t_debug)\n    window[f'-{prefix}-error-'](t_error)\n    window[f'-{prefix}-warning-'](t_warning)\n    window[f'-{prefix}-info-'](t_info)\n    window[f'-{prefix}-debug-'](t_debug)\n    window[f'-{prefix}-warning_info-'].update('')\n    t_warning_info_obj = messages_obj[-1]\n    if values['use_psg_color']:\n        for (text, color) in t_warning_info_obj:\n            if not is_valid_regex_LogMessage(text):\n                continue\n            window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n    else:\n        window[f'-{prefix}-warning_info-'](t_warning_info_obj)",
            "def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n    t_error = filter_log_messages(t_error)\n    t_warning = filter_log_messages(t_warning)\n    t_info = filter_log_messages(t_info)\n    t_debug = filter_log_messages(t_debug)\n    window[f'-{prefix}-error-'](t_error)\n    window[f'-{prefix}-warning-'](t_warning)\n    window[f'-{prefix}-info-'](t_info)\n    window[f'-{prefix}-debug-'](t_debug)\n    window[f'-{prefix}-warning_info-'].update('')\n    t_warning_info_obj = messages_obj[-1]\n    if values['use_psg_color']:\n        for (text, color) in t_warning_info_obj:\n            if not is_valid_regex_LogMessage(text):\n                continue\n            window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n    else:\n        window[f'-{prefix}-warning_info-'](t_warning_info_obj)"
        ]
    },
    {
        "func_name": "update_compilation_in_psg",
        "original": "def update_compilation_in_psg(values):\n    (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n    (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n    (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n    badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str1 = f'fix .:return:. in .({badNames}).'\n    badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str2 = f'empty md_table for .({badNames}).'\n\n    def is_valid_regex_LogMessage(msg: str):\n        nonlocal regex_str1, regex_str2\n        error1_found = False\n        if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n            error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n        error2_found = False\n        if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n            error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n        return not error1_found and (not error2_found)\n\n    def filter_log_messages(messages):\n        if type(messages) is str:\n            return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n        raise TypeError\n\n    class ParsingError(object):\n\n        def __init__(self, log_obj):\n            self.log_obj = log_obj\n            self.text = log_obj['message_text']\n\n        def __str__(self):\n            return self.__repr__()\n\n        def __repr__(self):\n            \"\"\"qwe\"\"\"\n            text = self.log_obj['message_text']\n            metadata = self.log_obj['message_metadata']\n            lineno = ''\n            if 'lineno' in metadata.keys():\n                lineno = '(line:' + str(metadata['lineno']) + ') '\n            return f'{lineno} {text}'\n    items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    window['-README-listbox-']([ParsingError(i) for i in items1])\n    window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n    def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n        (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n        t_error = filter_log_messages(t_error)\n        t_warning = filter_log_messages(t_warning)\n        t_info = filter_log_messages(t_info)\n        t_debug = filter_log_messages(t_debug)\n        window[f'-{prefix}-error-'](t_error)\n        window[f'-{prefix}-warning-'](t_warning)\n        window[f'-{prefix}-info-'](t_info)\n        window[f'-{prefix}-debug-'](t_debug)\n        window[f'-{prefix}-warning_info-'].update('')\n        t_warning_info_obj = messages_obj[-1]\n        if values['use_psg_color']:\n            for (text, color) in t_warning_info_obj:\n                if not is_valid_regex_LogMessage(text):\n                    continue\n                window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n        else:\n            window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n    set_it('README', result_readme_txt)\n    set_it('CALL_REF', result_call_ref_txt)\n    update_time_in_GUI()",
        "mutated": [
            "def update_compilation_in_psg(values):\n    if False:\n        i = 10\n    (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n    (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n    (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n    badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str1 = f'fix .:return:. in .({badNames}).'\n    badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str2 = f'empty md_table for .({badNames}).'\n\n    def is_valid_regex_LogMessage(msg: str):\n        nonlocal regex_str1, regex_str2\n        error1_found = False\n        if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n            error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n        error2_found = False\n        if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n            error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n        return not error1_found and (not error2_found)\n\n    def filter_log_messages(messages):\n        if type(messages) is str:\n            return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n        raise TypeError\n\n    class ParsingError(object):\n\n        def __init__(self, log_obj):\n            self.log_obj = log_obj\n            self.text = log_obj['message_text']\n\n        def __str__(self):\n            return self.__repr__()\n\n        def __repr__(self):\n            \"\"\"qwe\"\"\"\n            text = self.log_obj['message_text']\n            metadata = self.log_obj['message_metadata']\n            lineno = ''\n            if 'lineno' in metadata.keys():\n                lineno = '(line:' + str(metadata['lineno']) + ') '\n            return f'{lineno} {text}'\n    items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    window['-README-listbox-']([ParsingError(i) for i in items1])\n    window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n    def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n        (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n        t_error = filter_log_messages(t_error)\n        t_warning = filter_log_messages(t_warning)\n        t_info = filter_log_messages(t_info)\n        t_debug = filter_log_messages(t_debug)\n        window[f'-{prefix}-error-'](t_error)\n        window[f'-{prefix}-warning-'](t_warning)\n        window[f'-{prefix}-info-'](t_info)\n        window[f'-{prefix}-debug-'](t_debug)\n        window[f'-{prefix}-warning_info-'].update('')\n        t_warning_info_obj = messages_obj[-1]\n        if values['use_psg_color']:\n            for (text, color) in t_warning_info_obj:\n                if not is_valid_regex_LogMessage(text):\n                    continue\n                window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n        else:\n            window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n    set_it('README', result_readme_txt)\n    set_it('CALL_REF', result_call_ref_txt)\n    update_time_in_GUI()",
            "def update_compilation_in_psg(values):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n    (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n    (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n    badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str1 = f'fix .:return:. in .({badNames}).'\n    badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str2 = f'empty md_table for .({badNames}).'\n\n    def is_valid_regex_LogMessage(msg: str):\n        nonlocal regex_str1, regex_str2\n        error1_found = False\n        if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n            error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n        error2_found = False\n        if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n            error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n        return not error1_found and (not error2_found)\n\n    def filter_log_messages(messages):\n        if type(messages) is str:\n            return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n        raise TypeError\n\n    class ParsingError(object):\n\n        def __init__(self, log_obj):\n            self.log_obj = log_obj\n            self.text = log_obj['message_text']\n\n        def __str__(self):\n            return self.__repr__()\n\n        def __repr__(self):\n            \"\"\"qwe\"\"\"\n            text = self.log_obj['message_text']\n            metadata = self.log_obj['message_metadata']\n            lineno = ''\n            if 'lineno' in metadata.keys():\n                lineno = '(line:' + str(metadata['lineno']) + ') '\n            return f'{lineno} {text}'\n    items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    window['-README-listbox-']([ParsingError(i) for i in items1])\n    window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n    def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n        (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n        t_error = filter_log_messages(t_error)\n        t_warning = filter_log_messages(t_warning)\n        t_info = filter_log_messages(t_info)\n        t_debug = filter_log_messages(t_debug)\n        window[f'-{prefix}-error-'](t_error)\n        window[f'-{prefix}-warning-'](t_warning)\n        window[f'-{prefix}-info-'](t_info)\n        window[f'-{prefix}-debug-'](t_debug)\n        window[f'-{prefix}-warning_info-'].update('')\n        t_warning_info_obj = messages_obj[-1]\n        if values['use_psg_color']:\n            for (text, color) in t_warning_info_obj:\n                if not is_valid_regex_LogMessage(text):\n                    continue\n                window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n        else:\n            window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n    set_it('README', result_readme_txt)\n    set_it('CALL_REF', result_call_ref_txt)\n    update_time_in_GUI()",
            "def update_compilation_in_psg(values):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n    (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n    (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n    badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str1 = f'fix .:return:. in .({badNames}).'\n    badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str2 = f'empty md_table for .({badNames}).'\n\n    def is_valid_regex_LogMessage(msg: str):\n        nonlocal regex_str1, regex_str2\n        error1_found = False\n        if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n            error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n        error2_found = False\n        if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n            error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n        return not error1_found and (not error2_found)\n\n    def filter_log_messages(messages):\n        if type(messages) is str:\n            return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n        raise TypeError\n\n    class ParsingError(object):\n\n        def __init__(self, log_obj):\n            self.log_obj = log_obj\n            self.text = log_obj['message_text']\n\n        def __str__(self):\n            return self.__repr__()\n\n        def __repr__(self):\n            \"\"\"qwe\"\"\"\n            text = self.log_obj['message_text']\n            metadata = self.log_obj['message_metadata']\n            lineno = ''\n            if 'lineno' in metadata.keys():\n                lineno = '(line:' + str(metadata['lineno']) + ') '\n            return f'{lineno} {text}'\n    items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    window['-README-listbox-']([ParsingError(i) for i in items1])\n    window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n    def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n        (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n        t_error = filter_log_messages(t_error)\n        t_warning = filter_log_messages(t_warning)\n        t_info = filter_log_messages(t_info)\n        t_debug = filter_log_messages(t_debug)\n        window[f'-{prefix}-error-'](t_error)\n        window[f'-{prefix}-warning-'](t_warning)\n        window[f'-{prefix}-info-'](t_info)\n        window[f'-{prefix}-debug-'](t_debug)\n        window[f'-{prefix}-warning_info-'].update('')\n        t_warning_info_obj = messages_obj[-1]\n        if values['use_psg_color']:\n            for (text, color) in t_warning_info_obj:\n                if not is_valid_regex_LogMessage(text):\n                    continue\n                window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n        else:\n            window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n    set_it('README', result_readme_txt)\n    set_it('CALL_REF', result_call_ref_txt)\n    update_time_in_GUI()",
            "def update_compilation_in_psg(values):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n    (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n    (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n    badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str1 = f'fix .:return:. in .({badNames}).'\n    badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str2 = f'empty md_table for .({badNames}).'\n\n    def is_valid_regex_LogMessage(msg: str):\n        nonlocal regex_str1, regex_str2\n        error1_found = False\n        if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n            error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n        error2_found = False\n        if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n            error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n        return not error1_found and (not error2_found)\n\n    def filter_log_messages(messages):\n        if type(messages) is str:\n            return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n        raise TypeError\n\n    class ParsingError(object):\n\n        def __init__(self, log_obj):\n            self.log_obj = log_obj\n            self.text = log_obj['message_text']\n\n        def __str__(self):\n            return self.__repr__()\n\n        def __repr__(self):\n            \"\"\"qwe\"\"\"\n            text = self.log_obj['message_text']\n            metadata = self.log_obj['message_metadata']\n            lineno = ''\n            if 'lineno' in metadata.keys():\n                lineno = '(line:' + str(metadata['lineno']) + ') '\n            return f'{lineno} {text}'\n    items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    window['-README-listbox-']([ParsingError(i) for i in items1])\n    window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n    def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n        (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n        t_error = filter_log_messages(t_error)\n        t_warning = filter_log_messages(t_warning)\n        t_info = filter_log_messages(t_info)\n        t_debug = filter_log_messages(t_debug)\n        window[f'-{prefix}-error-'](t_error)\n        window[f'-{prefix}-warning-'](t_warning)\n        window[f'-{prefix}-info-'](t_info)\n        window[f'-{prefix}-debug-'](t_debug)\n        window[f'-{prefix}-warning_info-'].update('')\n        t_warning_info_obj = messages_obj[-1]\n        if values['use_psg_color']:\n            for (text, color) in t_warning_info_obj:\n                if not is_valid_regex_LogMessage(text):\n                    continue\n                window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n        else:\n            window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n    set_it('README', result_readme_txt)\n    set_it('CALL_REF', result_call_ref_txt)\n    update_time_in_GUI()",
            "def update_compilation_in_psg(values):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n    (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n    (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n    badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str1 = f'fix .:return:. in .({badNames}).'\n    badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n    badNames = '|'.join(badNames)\n    regex_str2 = f'empty md_table for .({badNames}).'\n\n    def is_valid_regex_LogMessage(msg: str):\n        nonlocal regex_str1, regex_str2\n        error1_found = False\n        if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n            error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n        error2_found = False\n        if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n            error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n        return not error1_found and (not error2_found)\n\n    def filter_log_messages(messages):\n        if type(messages) is str:\n            return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n        raise TypeError\n\n    class ParsingError(object):\n\n        def __init__(self, log_obj):\n            self.log_obj = log_obj\n            self.text = log_obj['message_text']\n\n        def __str__(self):\n            return self.__repr__()\n\n        def __repr__(self):\n            \"\"\"qwe\"\"\"\n            text = self.log_obj['message_text']\n            metadata = self.log_obj['message_metadata']\n            lineno = ''\n            if 'lineno' in metadata.keys():\n                lineno = '(line:' + str(metadata['lineno']) + ') '\n            return f'{lineno} {text}'\n    items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n    window['-README-listbox-']([ParsingError(i) for i in items1])\n    window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n    def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n        (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n        t_error = filter_log_messages(t_error)\n        t_warning = filter_log_messages(t_warning)\n        t_info = filter_log_messages(t_info)\n        t_debug = filter_log_messages(t_debug)\n        window[f'-{prefix}-error-'](t_error)\n        window[f'-{prefix}-warning-'](t_warning)\n        window[f'-{prefix}-info-'](t_info)\n        window[f'-{prefix}-debug-'](t_debug)\n        window[f'-{prefix}-warning_info-'].update('')\n        t_warning_info_obj = messages_obj[-1]\n        if values['use_psg_color']:\n            for (text, color) in t_warning_info_obj:\n                if not is_valid_regex_LogMessage(text):\n                    continue\n                window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n        else:\n            window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n    set_it('README', result_readme_txt)\n    set_it('CALL_REF', result_call_ref_txt)\n    update_time_in_GUI()"
        ]
    },
    {
        "func_name": "mini_GUI",
        "original": "def mini_GUI():\n    my_font = ('Helvetica', 12)\n    my_font2 = ('Helvetica', 12, 'bold')\n    my_font3 = ('Helvetica', 15, 'bold')\n    my_font4 = ('Mono', 18, 'bold')\n\n    def make_tab(word):\n\n        def tabs(*layouts):\n            return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n        return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]\n    settings_layout = [[sg.CB('Toggle progressbar', False, enable_events=True, key='toggle_progressbar')], [sg.Frame('Text editor', [[sg.Combo(['pycharm', 'subl'], default_value='subl', enable_events=True, key='_text_editor_combo_')]]), sg.Frame('Pycharm path:', [[sg.I('', size=(40, 1), enable_events=True, key='_PyCharm_path_')]])], [sg.Frame('\u2140\u2209 Filter \"empty tables\"', [[sg.T('This is for filtering stirng, like:')], [sg.T('Warning =======    We got empty md_table for \"EasyPrintClose\"', font='Mono 8')], [sg.CB('enable', True, key='checkbox_enable_empty_tables_filter', enable_events=True)], [sg.ML('PrintClose\\nEasyPrintClose\\nmain\\ntheme\\nRead', size=(30, 10), enable_events=True, key='_filter_empty_tables_ml_')]]), sg.Frame('\u2140\u2209 Filter \"tkinter class methods\"', [[sg.T('This is for filtering stirng, like:')], [sg.T(\"Please, fix ':return:' in 'SetFocus'                  IF you want to see 'return' row in 'signature table' \", font='Mono 8')], [sg.CB('enable', True, enable_events=True, key='checkbox_enable_filter_tkinter_class_methods')], [sg.ML('SetFocus\\nSetTooltip\\nUpdate\\n__init__\\nbind\\nexpand\\nset_cursor\\nset_size', size=(30, 10), enable_events=True, key='_filter_tkinter_class_methods_')]], visible=not True)]]\n    layout = [[sg.TabGroup([[sg.Tab('readme logs', make_tab('README')), sg.Tab('Call reference logs', make_tab('CALL_REF')), sg.Tab('General settings', settings_layout)]])]]\n    from time import sleep\n    from math import pi, sin\n    from itertools import count\n\n    def next_star():\n        middle = 100 / 2\n        for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n            yield i\n    psg_module_path = str(sg).split(\"' from '\")[1][:-2]\n    star_bar = sg.Col([[sg.ProgressBar(max_value=100, orientation='h', key='_star_bar1_', size=(50, 5), bar_color=('blue', 'yellow'))], [sg.ProgressBar(max_value=100, orientation='h', key='_star_bar2_', size=(50, 5), bar_color=('yellow', 'blue'))]])\n\n    def empty_line(fontsize=12):\n        return [sg.T('', font='Mono ' + str(fontsize))]\n    window = sg.Window('We are live! Again! --- ' + 'Completed making            {}, {}'.format(os.path.basename(README_OFILENAME), os.path.basename(CALL_REFERENCE_OFILENAME)), [[sg.T(size=(30, 1), key='-compile-time-'), star_bar], empty_line(), [*md2psg(f'The *Bmagenta*PySimpleGUI** module being processed is *Imagenta*\"{psg_module_path}\"**'), sg.B('< open (__init__.py)', key='open_init_file'), sg.B('< open (psg.py)', key='open_psg_file')], empty_line(), [sg.B('Run again (F1)', key='-run-'), sg.Col([[sg.CB('show time in logs (F2)', False, enable_events=True, key='show_time')], [sg.CB('Logs with Color (F3)', True, enable_events=True, key='use_psg_color')]]), sg.Col([empty_line(5), [sg.B('open \"db folder\"', key='-open_db_folder-')]]), sg.Frame('', [[sg.Col([[*md2psg('markdown outputFileName *I*FOR** *B*readme  **: '), sg.I(README_OFILENAME, key='README_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_readme'), sg.B('open in text editor', key='open file - readme')], [*md2psg('markdown outputFileName *I*FOR** *B*call ref**: '), sg.I(CALL_REFERENCE_OFILENAME, key='CALL_REF_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_calref'), sg.B('open in text editor', key='open file - calref')]])]], relief=sg.RELIEF_SUNKEN, border_width=4)], *layout], resizable=True, finalize=True, location=(0, 0), return_keyboard_events=True)\n\n    def update_time_in_GUI():\n        window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))\n\n    def update_compilation_in_psg(values):\n        (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n        (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n        (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n        badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str1 = f'fix .:return:. in .({badNames}).'\n        badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str2 = f'empty md_table for .({badNames}).'\n\n        def is_valid_regex_LogMessage(msg: str):\n            nonlocal regex_str1, regex_str2\n            error1_found = False\n            if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n                error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n            error2_found = False\n            if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n                error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n            return not error1_found and (not error2_found)\n\n        def filter_log_messages(messages):\n            if type(messages) is str:\n                return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n            raise TypeError\n\n        class ParsingError(object):\n\n            def __init__(self, log_obj):\n                self.log_obj = log_obj\n                self.text = log_obj['message_text']\n\n            def __str__(self):\n                return self.__repr__()\n\n            def __repr__(self):\n                \"\"\"qwe\"\"\"\n                text = self.log_obj['message_text']\n                metadata = self.log_obj['message_metadata']\n                lineno = ''\n                if 'lineno' in metadata.keys():\n                    lineno = '(line:' + str(metadata['lineno']) + ') '\n                return f'{lineno} {text}'\n        items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        window['-README-listbox-']([ParsingError(i) for i in items1])\n        window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n        def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n            (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n            t_error = filter_log_messages(t_error)\n            t_warning = filter_log_messages(t_warning)\n            t_info = filter_log_messages(t_info)\n            t_debug = filter_log_messages(t_debug)\n            window[f'-{prefix}-error-'](t_error)\n            window[f'-{prefix}-warning-'](t_warning)\n            window[f'-{prefix}-info-'](t_info)\n            window[f'-{prefix}-debug-'](t_debug)\n            window[f'-{prefix}-warning_info-'].update('')\n            t_warning_info_obj = messages_obj[-1]\n            if values['use_psg_color']:\n                for (text, color) in t_warning_info_obj:\n                    if not is_valid_regex_LogMessage(text):\n                        continue\n                    window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n            else:\n                window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n        set_it('README', result_readme_txt)\n        set_it('CALL_REF', result_call_ref_txt)\n        update_time_in_GUI()\n    values = window.read(timeout=0)[1]\n    update_compilation_in_psg(values)\n    p_values = values\n    window['_PyCharm_path_'](APP_CONFIGS['_PyCharm_path_'])\n    window['_text_editor_combo_'].update(set_to_index=APP_CONFIGS['_text_editor_combo_'])\n    window['toggle_progressbar'](APP_CONFIGS['toggle_progressbar'])\n    window['checkbox_enable_empty_tables_filter'](APP_CONFIGS['checkbox_enable_empty_tables_filter'])\n    window['_filter_empty_tables_ml_'](APP_CONFIGS['_filter_empty_tables_ml_'])\n    window['checkbox_enable_filter_tkinter_class_methods'](APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'])\n    window['_filter_tkinter_class_methods_'](APP_CONFIGS['_filter_tkinter_class_methods_'])\n    window['show_time'](APP_CONFIGS['show_time'])\n    window['use_psg_color'](APP_CONFIGS['use_psg_color'])\n    window['README_OFILE'](APP_CONFIGS['README_OFILE'])\n    window['CALL_REF_OFILE'](APP_CONFIGS['CALL_REF_OFILE'])\n    next_val_gen = next_star()\n    my_timeout = None\n    while True:\n        (event, values) = window(timeout=my_timeout)\n        if event in ('Exit', None):\n            APP_CONFIGS['_text_editor_combo_'] = 1 if window['_text_editor_combo_'].get() == 'subl' else 0\n            APP_CONFIGS['toggle_progressbar'] = p_values['toggle_progressbar']\n            APP_CONFIGS['checkbox_enable_empty_tables_filter'] = p_values['checkbox_enable_empty_tables_filter']\n            APP_CONFIGS['_filter_empty_tables_ml_'] = p_values['_filter_empty_tables_ml_']\n            APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'] = p_values['checkbox_enable_filter_tkinter_class_methods']\n            APP_CONFIGS['_filter_tkinter_class_methods_'] = p_values['_filter_tkinter_class_methods_']\n            APP_CONFIGS['show_time'] = p_values['show_time']\n            APP_CONFIGS['use_psg_color'] = p_values['use_psg_color']\n            APP_CONFIGS['README_OFILE'] = p_values['README_OFILE']\n            APP_CONFIGS['CALL_REF_OFILE'] = p_values['CALL_REF_OFILE']\n            save_configs(APP_CONFIGS)\n            break\n        p_values = values\n        if '__TIMEOUT__' in event:\n            if values['toggle_progressbar']:\n                window['_star_bar1_'].UpdateBar(next(next_val_gen))\n                window['_star_bar2_'].UpdateBar(next(next_val_gen))\n        if '__TIMEOUT__' not in event:\n            print('PSG event>', event)\n        if event == 'toggle_progressbar':\n            my_timeout = None if not values['toggle_progressbar'] else 100\n        if event == '-README-listbox-':\n            metadata = values['-README-listbox-'][0].log_obj['message_metadata']\n            print(f'metadata = {metadata}')\n        if event == '-CALL_REF-listbox-':\n            ParsingError_obj = values['-CALL_REF-listbox-'][0]\n            metadata = ParsingError_obj.log_obj['message_metadata']\n            if 'lineno' in metadata.keys():\n                lineno = metadata['lineno']\n                texteditor = values['_text_editor_combo_']\n                psg_module_path_SDK = psg_module_path.replace('__init__.py', 'PySimpleGUI.py')\n                if 'pycharm' == texteditor:\n                    texteditor = values['_PyCharm_path_']\n                    subprocess.Popen(f'\"{texteditor}\" --line {lineno} \"{psg_module_path_SDK}\"', shell=True)\n                elif 'subl' == texteditor:\n                    subprocess.Popen(f'{texteditor} \"{psg_module_path_SDK}:{lineno}\"', shell=True)\n        if event == '-run-' or 'F1' in event:\n            update_compilation_in_psg(values)\n        if event == '-open_db_folder-':\n            opendir(cd)\n        if event == 'open in explorer_readme':\n            opendir(os.path.dirname(os.path.join(cd, values['README_OFILE'])))\n        if event == 'open in explorer_calref':\n            opendir(os.path.dirname(os.path.join(cd, values['CALL_REF_OFILE'])))\n        if event == 'open file - readme':\n            openfile(os.path.join(cd, values['README_OFILE']))\n        if event == 'open file - calref':\n            openfile(os.path.join(cd, values['CALL_REF_OFILE']))\n        if event == 'open_init_file':\n            openfile(psg_module_path)\n        if event == 'open_psg_file':\n            openfile(psg_module_path.replace('__init__.py', 'PySimpleGUI.py'))\n        if 'F2' in event:\n            window['show_time'](not values['show_time'])\n        if 'F3' in event:\n            window['use_psg_color'](not values['use_psg_color'])\n    window.close()",
        "mutated": [
            "def mini_GUI():\n    if False:\n        i = 10\n    my_font = ('Helvetica', 12)\n    my_font2 = ('Helvetica', 12, 'bold')\n    my_font3 = ('Helvetica', 15, 'bold')\n    my_font4 = ('Mono', 18, 'bold')\n\n    def make_tab(word):\n\n        def tabs(*layouts):\n            return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n        return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]\n    settings_layout = [[sg.CB('Toggle progressbar', False, enable_events=True, key='toggle_progressbar')], [sg.Frame('Text editor', [[sg.Combo(['pycharm', 'subl'], default_value='subl', enable_events=True, key='_text_editor_combo_')]]), sg.Frame('Pycharm path:', [[sg.I('', size=(40, 1), enable_events=True, key='_PyCharm_path_')]])], [sg.Frame('\u2140\u2209 Filter \"empty tables\"', [[sg.T('This is for filtering stirng, like:')], [sg.T('Warning =======    We got empty md_table for \"EasyPrintClose\"', font='Mono 8')], [sg.CB('enable', True, key='checkbox_enable_empty_tables_filter', enable_events=True)], [sg.ML('PrintClose\\nEasyPrintClose\\nmain\\ntheme\\nRead', size=(30, 10), enable_events=True, key='_filter_empty_tables_ml_')]]), sg.Frame('\u2140\u2209 Filter \"tkinter class methods\"', [[sg.T('This is for filtering stirng, like:')], [sg.T(\"Please, fix ':return:' in 'SetFocus'                  IF you want to see 'return' row in 'signature table' \", font='Mono 8')], [sg.CB('enable', True, enable_events=True, key='checkbox_enable_filter_tkinter_class_methods')], [sg.ML('SetFocus\\nSetTooltip\\nUpdate\\n__init__\\nbind\\nexpand\\nset_cursor\\nset_size', size=(30, 10), enable_events=True, key='_filter_tkinter_class_methods_')]], visible=not True)]]\n    layout = [[sg.TabGroup([[sg.Tab('readme logs', make_tab('README')), sg.Tab('Call reference logs', make_tab('CALL_REF')), sg.Tab('General settings', settings_layout)]])]]\n    from time import sleep\n    from math import pi, sin\n    from itertools import count\n\n    def next_star():\n        middle = 100 / 2\n        for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n            yield i\n    psg_module_path = str(sg).split(\"' from '\")[1][:-2]\n    star_bar = sg.Col([[sg.ProgressBar(max_value=100, orientation='h', key='_star_bar1_', size=(50, 5), bar_color=('blue', 'yellow'))], [sg.ProgressBar(max_value=100, orientation='h', key='_star_bar2_', size=(50, 5), bar_color=('yellow', 'blue'))]])\n\n    def empty_line(fontsize=12):\n        return [sg.T('', font='Mono ' + str(fontsize))]\n    window = sg.Window('We are live! Again! --- ' + 'Completed making            {}, {}'.format(os.path.basename(README_OFILENAME), os.path.basename(CALL_REFERENCE_OFILENAME)), [[sg.T(size=(30, 1), key='-compile-time-'), star_bar], empty_line(), [*md2psg(f'The *Bmagenta*PySimpleGUI** module being processed is *Imagenta*\"{psg_module_path}\"**'), sg.B('< open (__init__.py)', key='open_init_file'), sg.B('< open (psg.py)', key='open_psg_file')], empty_line(), [sg.B('Run again (F1)', key='-run-'), sg.Col([[sg.CB('show time in logs (F2)', False, enable_events=True, key='show_time')], [sg.CB('Logs with Color (F3)', True, enable_events=True, key='use_psg_color')]]), sg.Col([empty_line(5), [sg.B('open \"db folder\"', key='-open_db_folder-')]]), sg.Frame('', [[sg.Col([[*md2psg('markdown outputFileName *I*FOR** *B*readme  **: '), sg.I(README_OFILENAME, key='README_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_readme'), sg.B('open in text editor', key='open file - readme')], [*md2psg('markdown outputFileName *I*FOR** *B*call ref**: '), sg.I(CALL_REFERENCE_OFILENAME, key='CALL_REF_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_calref'), sg.B('open in text editor', key='open file - calref')]])]], relief=sg.RELIEF_SUNKEN, border_width=4)], *layout], resizable=True, finalize=True, location=(0, 0), return_keyboard_events=True)\n\n    def update_time_in_GUI():\n        window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))\n\n    def update_compilation_in_psg(values):\n        (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n        (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n        (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n        badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str1 = f'fix .:return:. in .({badNames}).'\n        badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str2 = f'empty md_table for .({badNames}).'\n\n        def is_valid_regex_LogMessage(msg: str):\n            nonlocal regex_str1, regex_str2\n            error1_found = False\n            if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n                error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n            error2_found = False\n            if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n                error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n            return not error1_found and (not error2_found)\n\n        def filter_log_messages(messages):\n            if type(messages) is str:\n                return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n            raise TypeError\n\n        class ParsingError(object):\n\n            def __init__(self, log_obj):\n                self.log_obj = log_obj\n                self.text = log_obj['message_text']\n\n            def __str__(self):\n                return self.__repr__()\n\n            def __repr__(self):\n                \"\"\"qwe\"\"\"\n                text = self.log_obj['message_text']\n                metadata = self.log_obj['message_metadata']\n                lineno = ''\n                if 'lineno' in metadata.keys():\n                    lineno = '(line:' + str(metadata['lineno']) + ') '\n                return f'{lineno} {text}'\n        items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        window['-README-listbox-']([ParsingError(i) for i in items1])\n        window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n        def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n            (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n            t_error = filter_log_messages(t_error)\n            t_warning = filter_log_messages(t_warning)\n            t_info = filter_log_messages(t_info)\n            t_debug = filter_log_messages(t_debug)\n            window[f'-{prefix}-error-'](t_error)\n            window[f'-{prefix}-warning-'](t_warning)\n            window[f'-{prefix}-info-'](t_info)\n            window[f'-{prefix}-debug-'](t_debug)\n            window[f'-{prefix}-warning_info-'].update('')\n            t_warning_info_obj = messages_obj[-1]\n            if values['use_psg_color']:\n                for (text, color) in t_warning_info_obj:\n                    if not is_valid_regex_LogMessage(text):\n                        continue\n                    window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n            else:\n                window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n        set_it('README', result_readme_txt)\n        set_it('CALL_REF', result_call_ref_txt)\n        update_time_in_GUI()\n    values = window.read(timeout=0)[1]\n    update_compilation_in_psg(values)\n    p_values = values\n    window['_PyCharm_path_'](APP_CONFIGS['_PyCharm_path_'])\n    window['_text_editor_combo_'].update(set_to_index=APP_CONFIGS['_text_editor_combo_'])\n    window['toggle_progressbar'](APP_CONFIGS['toggle_progressbar'])\n    window['checkbox_enable_empty_tables_filter'](APP_CONFIGS['checkbox_enable_empty_tables_filter'])\n    window['_filter_empty_tables_ml_'](APP_CONFIGS['_filter_empty_tables_ml_'])\n    window['checkbox_enable_filter_tkinter_class_methods'](APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'])\n    window['_filter_tkinter_class_methods_'](APP_CONFIGS['_filter_tkinter_class_methods_'])\n    window['show_time'](APP_CONFIGS['show_time'])\n    window['use_psg_color'](APP_CONFIGS['use_psg_color'])\n    window['README_OFILE'](APP_CONFIGS['README_OFILE'])\n    window['CALL_REF_OFILE'](APP_CONFIGS['CALL_REF_OFILE'])\n    next_val_gen = next_star()\n    my_timeout = None\n    while True:\n        (event, values) = window(timeout=my_timeout)\n        if event in ('Exit', None):\n            APP_CONFIGS['_text_editor_combo_'] = 1 if window['_text_editor_combo_'].get() == 'subl' else 0\n            APP_CONFIGS['toggle_progressbar'] = p_values['toggle_progressbar']\n            APP_CONFIGS['checkbox_enable_empty_tables_filter'] = p_values['checkbox_enable_empty_tables_filter']\n            APP_CONFIGS['_filter_empty_tables_ml_'] = p_values['_filter_empty_tables_ml_']\n            APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'] = p_values['checkbox_enable_filter_tkinter_class_methods']\n            APP_CONFIGS['_filter_tkinter_class_methods_'] = p_values['_filter_tkinter_class_methods_']\n            APP_CONFIGS['show_time'] = p_values['show_time']\n            APP_CONFIGS['use_psg_color'] = p_values['use_psg_color']\n            APP_CONFIGS['README_OFILE'] = p_values['README_OFILE']\n            APP_CONFIGS['CALL_REF_OFILE'] = p_values['CALL_REF_OFILE']\n            save_configs(APP_CONFIGS)\n            break\n        p_values = values\n        if '__TIMEOUT__' in event:\n            if values['toggle_progressbar']:\n                window['_star_bar1_'].UpdateBar(next(next_val_gen))\n                window['_star_bar2_'].UpdateBar(next(next_val_gen))\n        if '__TIMEOUT__' not in event:\n            print('PSG event>', event)\n        if event == 'toggle_progressbar':\n            my_timeout = None if not values['toggle_progressbar'] else 100\n        if event == '-README-listbox-':\n            metadata = values['-README-listbox-'][0].log_obj['message_metadata']\n            print(f'metadata = {metadata}')\n        if event == '-CALL_REF-listbox-':\n            ParsingError_obj = values['-CALL_REF-listbox-'][0]\n            metadata = ParsingError_obj.log_obj['message_metadata']\n            if 'lineno' in metadata.keys():\n                lineno = metadata['lineno']\n                texteditor = values['_text_editor_combo_']\n                psg_module_path_SDK = psg_module_path.replace('__init__.py', 'PySimpleGUI.py')\n                if 'pycharm' == texteditor:\n                    texteditor = values['_PyCharm_path_']\n                    subprocess.Popen(f'\"{texteditor}\" --line {lineno} \"{psg_module_path_SDK}\"', shell=True)\n                elif 'subl' == texteditor:\n                    subprocess.Popen(f'{texteditor} \"{psg_module_path_SDK}:{lineno}\"', shell=True)\n        if event == '-run-' or 'F1' in event:\n            update_compilation_in_psg(values)\n        if event == '-open_db_folder-':\n            opendir(cd)\n        if event == 'open in explorer_readme':\n            opendir(os.path.dirname(os.path.join(cd, values['README_OFILE'])))\n        if event == 'open in explorer_calref':\n            opendir(os.path.dirname(os.path.join(cd, values['CALL_REF_OFILE'])))\n        if event == 'open file - readme':\n            openfile(os.path.join(cd, values['README_OFILE']))\n        if event == 'open file - calref':\n            openfile(os.path.join(cd, values['CALL_REF_OFILE']))\n        if event == 'open_init_file':\n            openfile(psg_module_path)\n        if event == 'open_psg_file':\n            openfile(psg_module_path.replace('__init__.py', 'PySimpleGUI.py'))\n        if 'F2' in event:\n            window['show_time'](not values['show_time'])\n        if 'F3' in event:\n            window['use_psg_color'](not values['use_psg_color'])\n    window.close()",
            "def mini_GUI():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    my_font = ('Helvetica', 12)\n    my_font2 = ('Helvetica', 12, 'bold')\n    my_font3 = ('Helvetica', 15, 'bold')\n    my_font4 = ('Mono', 18, 'bold')\n\n    def make_tab(word):\n\n        def tabs(*layouts):\n            return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n        return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]\n    settings_layout = [[sg.CB('Toggle progressbar', False, enable_events=True, key='toggle_progressbar')], [sg.Frame('Text editor', [[sg.Combo(['pycharm', 'subl'], default_value='subl', enable_events=True, key='_text_editor_combo_')]]), sg.Frame('Pycharm path:', [[sg.I('', size=(40, 1), enable_events=True, key='_PyCharm_path_')]])], [sg.Frame('\u2140\u2209 Filter \"empty tables\"', [[sg.T('This is for filtering stirng, like:')], [sg.T('Warning =======    We got empty md_table for \"EasyPrintClose\"', font='Mono 8')], [sg.CB('enable', True, key='checkbox_enable_empty_tables_filter', enable_events=True)], [sg.ML('PrintClose\\nEasyPrintClose\\nmain\\ntheme\\nRead', size=(30, 10), enable_events=True, key='_filter_empty_tables_ml_')]]), sg.Frame('\u2140\u2209 Filter \"tkinter class methods\"', [[sg.T('This is for filtering stirng, like:')], [sg.T(\"Please, fix ':return:' in 'SetFocus'                  IF you want to see 'return' row in 'signature table' \", font='Mono 8')], [sg.CB('enable', True, enable_events=True, key='checkbox_enable_filter_tkinter_class_methods')], [sg.ML('SetFocus\\nSetTooltip\\nUpdate\\n__init__\\nbind\\nexpand\\nset_cursor\\nset_size', size=(30, 10), enable_events=True, key='_filter_tkinter_class_methods_')]], visible=not True)]]\n    layout = [[sg.TabGroup([[sg.Tab('readme logs', make_tab('README')), sg.Tab('Call reference logs', make_tab('CALL_REF')), sg.Tab('General settings', settings_layout)]])]]\n    from time import sleep\n    from math import pi, sin\n    from itertools import count\n\n    def next_star():\n        middle = 100 / 2\n        for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n            yield i\n    psg_module_path = str(sg).split(\"' from '\")[1][:-2]\n    star_bar = sg.Col([[sg.ProgressBar(max_value=100, orientation='h', key='_star_bar1_', size=(50, 5), bar_color=('blue', 'yellow'))], [sg.ProgressBar(max_value=100, orientation='h', key='_star_bar2_', size=(50, 5), bar_color=('yellow', 'blue'))]])\n\n    def empty_line(fontsize=12):\n        return [sg.T('', font='Mono ' + str(fontsize))]\n    window = sg.Window('We are live! Again! --- ' + 'Completed making            {}, {}'.format(os.path.basename(README_OFILENAME), os.path.basename(CALL_REFERENCE_OFILENAME)), [[sg.T(size=(30, 1), key='-compile-time-'), star_bar], empty_line(), [*md2psg(f'The *Bmagenta*PySimpleGUI** module being processed is *Imagenta*\"{psg_module_path}\"**'), sg.B('< open (__init__.py)', key='open_init_file'), sg.B('< open (psg.py)', key='open_psg_file')], empty_line(), [sg.B('Run again (F1)', key='-run-'), sg.Col([[sg.CB('show time in logs (F2)', False, enable_events=True, key='show_time')], [sg.CB('Logs with Color (F3)', True, enable_events=True, key='use_psg_color')]]), sg.Col([empty_line(5), [sg.B('open \"db folder\"', key='-open_db_folder-')]]), sg.Frame('', [[sg.Col([[*md2psg('markdown outputFileName *I*FOR** *B*readme  **: '), sg.I(README_OFILENAME, key='README_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_readme'), sg.B('open in text editor', key='open file - readme')], [*md2psg('markdown outputFileName *I*FOR** *B*call ref**: '), sg.I(CALL_REFERENCE_OFILENAME, key='CALL_REF_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_calref'), sg.B('open in text editor', key='open file - calref')]])]], relief=sg.RELIEF_SUNKEN, border_width=4)], *layout], resizable=True, finalize=True, location=(0, 0), return_keyboard_events=True)\n\n    def update_time_in_GUI():\n        window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))\n\n    def update_compilation_in_psg(values):\n        (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n        (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n        (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n        badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str1 = f'fix .:return:. in .({badNames}).'\n        badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str2 = f'empty md_table for .({badNames}).'\n\n        def is_valid_regex_LogMessage(msg: str):\n            nonlocal regex_str1, regex_str2\n            error1_found = False\n            if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n                error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n            error2_found = False\n            if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n                error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n            return not error1_found and (not error2_found)\n\n        def filter_log_messages(messages):\n            if type(messages) is str:\n                return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n            raise TypeError\n\n        class ParsingError(object):\n\n            def __init__(self, log_obj):\n                self.log_obj = log_obj\n                self.text = log_obj['message_text']\n\n            def __str__(self):\n                return self.__repr__()\n\n            def __repr__(self):\n                \"\"\"qwe\"\"\"\n                text = self.log_obj['message_text']\n                metadata = self.log_obj['message_metadata']\n                lineno = ''\n                if 'lineno' in metadata.keys():\n                    lineno = '(line:' + str(metadata['lineno']) + ') '\n                return f'{lineno} {text}'\n        items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        window['-README-listbox-']([ParsingError(i) for i in items1])\n        window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n        def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n            (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n            t_error = filter_log_messages(t_error)\n            t_warning = filter_log_messages(t_warning)\n            t_info = filter_log_messages(t_info)\n            t_debug = filter_log_messages(t_debug)\n            window[f'-{prefix}-error-'](t_error)\n            window[f'-{prefix}-warning-'](t_warning)\n            window[f'-{prefix}-info-'](t_info)\n            window[f'-{prefix}-debug-'](t_debug)\n            window[f'-{prefix}-warning_info-'].update('')\n            t_warning_info_obj = messages_obj[-1]\n            if values['use_psg_color']:\n                for (text, color) in t_warning_info_obj:\n                    if not is_valid_regex_LogMessage(text):\n                        continue\n                    window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n            else:\n                window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n        set_it('README', result_readme_txt)\n        set_it('CALL_REF', result_call_ref_txt)\n        update_time_in_GUI()\n    values = window.read(timeout=0)[1]\n    update_compilation_in_psg(values)\n    p_values = values\n    window['_PyCharm_path_'](APP_CONFIGS['_PyCharm_path_'])\n    window['_text_editor_combo_'].update(set_to_index=APP_CONFIGS['_text_editor_combo_'])\n    window['toggle_progressbar'](APP_CONFIGS['toggle_progressbar'])\n    window['checkbox_enable_empty_tables_filter'](APP_CONFIGS['checkbox_enable_empty_tables_filter'])\n    window['_filter_empty_tables_ml_'](APP_CONFIGS['_filter_empty_tables_ml_'])\n    window['checkbox_enable_filter_tkinter_class_methods'](APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'])\n    window['_filter_tkinter_class_methods_'](APP_CONFIGS['_filter_tkinter_class_methods_'])\n    window['show_time'](APP_CONFIGS['show_time'])\n    window['use_psg_color'](APP_CONFIGS['use_psg_color'])\n    window['README_OFILE'](APP_CONFIGS['README_OFILE'])\n    window['CALL_REF_OFILE'](APP_CONFIGS['CALL_REF_OFILE'])\n    next_val_gen = next_star()\n    my_timeout = None\n    while True:\n        (event, values) = window(timeout=my_timeout)\n        if event in ('Exit', None):\n            APP_CONFIGS['_text_editor_combo_'] = 1 if window['_text_editor_combo_'].get() == 'subl' else 0\n            APP_CONFIGS['toggle_progressbar'] = p_values['toggle_progressbar']\n            APP_CONFIGS['checkbox_enable_empty_tables_filter'] = p_values['checkbox_enable_empty_tables_filter']\n            APP_CONFIGS['_filter_empty_tables_ml_'] = p_values['_filter_empty_tables_ml_']\n            APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'] = p_values['checkbox_enable_filter_tkinter_class_methods']\n            APP_CONFIGS['_filter_tkinter_class_methods_'] = p_values['_filter_tkinter_class_methods_']\n            APP_CONFIGS['show_time'] = p_values['show_time']\n            APP_CONFIGS['use_psg_color'] = p_values['use_psg_color']\n            APP_CONFIGS['README_OFILE'] = p_values['README_OFILE']\n            APP_CONFIGS['CALL_REF_OFILE'] = p_values['CALL_REF_OFILE']\n            save_configs(APP_CONFIGS)\n            break\n        p_values = values\n        if '__TIMEOUT__' in event:\n            if values['toggle_progressbar']:\n                window['_star_bar1_'].UpdateBar(next(next_val_gen))\n                window['_star_bar2_'].UpdateBar(next(next_val_gen))\n        if '__TIMEOUT__' not in event:\n            print('PSG event>', event)\n        if event == 'toggle_progressbar':\n            my_timeout = None if not values['toggle_progressbar'] else 100\n        if event == '-README-listbox-':\n            metadata = values['-README-listbox-'][0].log_obj['message_metadata']\n            print(f'metadata = {metadata}')\n        if event == '-CALL_REF-listbox-':\n            ParsingError_obj = values['-CALL_REF-listbox-'][0]\n            metadata = ParsingError_obj.log_obj['message_metadata']\n            if 'lineno' in metadata.keys():\n                lineno = metadata['lineno']\n                texteditor = values['_text_editor_combo_']\n                psg_module_path_SDK = psg_module_path.replace('__init__.py', 'PySimpleGUI.py')\n                if 'pycharm' == texteditor:\n                    texteditor = values['_PyCharm_path_']\n                    subprocess.Popen(f'\"{texteditor}\" --line {lineno} \"{psg_module_path_SDK}\"', shell=True)\n                elif 'subl' == texteditor:\n                    subprocess.Popen(f'{texteditor} \"{psg_module_path_SDK}:{lineno}\"', shell=True)\n        if event == '-run-' or 'F1' in event:\n            update_compilation_in_psg(values)\n        if event == '-open_db_folder-':\n            opendir(cd)\n        if event == 'open in explorer_readme':\n            opendir(os.path.dirname(os.path.join(cd, values['README_OFILE'])))\n        if event == 'open in explorer_calref':\n            opendir(os.path.dirname(os.path.join(cd, values['CALL_REF_OFILE'])))\n        if event == 'open file - readme':\n            openfile(os.path.join(cd, values['README_OFILE']))\n        if event == 'open file - calref':\n            openfile(os.path.join(cd, values['CALL_REF_OFILE']))\n        if event == 'open_init_file':\n            openfile(psg_module_path)\n        if event == 'open_psg_file':\n            openfile(psg_module_path.replace('__init__.py', 'PySimpleGUI.py'))\n        if 'F2' in event:\n            window['show_time'](not values['show_time'])\n        if 'F3' in event:\n            window['use_psg_color'](not values['use_psg_color'])\n    window.close()",
            "def mini_GUI():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    my_font = ('Helvetica', 12)\n    my_font2 = ('Helvetica', 12, 'bold')\n    my_font3 = ('Helvetica', 15, 'bold')\n    my_font4 = ('Mono', 18, 'bold')\n\n    def make_tab(word):\n\n        def tabs(*layouts):\n            return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n        return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]\n    settings_layout = [[sg.CB('Toggle progressbar', False, enable_events=True, key='toggle_progressbar')], [sg.Frame('Text editor', [[sg.Combo(['pycharm', 'subl'], default_value='subl', enable_events=True, key='_text_editor_combo_')]]), sg.Frame('Pycharm path:', [[sg.I('', size=(40, 1), enable_events=True, key='_PyCharm_path_')]])], [sg.Frame('\u2140\u2209 Filter \"empty tables\"', [[sg.T('This is for filtering stirng, like:')], [sg.T('Warning =======    We got empty md_table for \"EasyPrintClose\"', font='Mono 8')], [sg.CB('enable', True, key='checkbox_enable_empty_tables_filter', enable_events=True)], [sg.ML('PrintClose\\nEasyPrintClose\\nmain\\ntheme\\nRead', size=(30, 10), enable_events=True, key='_filter_empty_tables_ml_')]]), sg.Frame('\u2140\u2209 Filter \"tkinter class methods\"', [[sg.T('This is for filtering stirng, like:')], [sg.T(\"Please, fix ':return:' in 'SetFocus'                  IF you want to see 'return' row in 'signature table' \", font='Mono 8')], [sg.CB('enable', True, enable_events=True, key='checkbox_enable_filter_tkinter_class_methods')], [sg.ML('SetFocus\\nSetTooltip\\nUpdate\\n__init__\\nbind\\nexpand\\nset_cursor\\nset_size', size=(30, 10), enable_events=True, key='_filter_tkinter_class_methods_')]], visible=not True)]]\n    layout = [[sg.TabGroup([[sg.Tab('readme logs', make_tab('README')), sg.Tab('Call reference logs', make_tab('CALL_REF')), sg.Tab('General settings', settings_layout)]])]]\n    from time import sleep\n    from math import pi, sin\n    from itertools import count\n\n    def next_star():\n        middle = 100 / 2\n        for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n            yield i\n    psg_module_path = str(sg).split(\"' from '\")[1][:-2]\n    star_bar = sg.Col([[sg.ProgressBar(max_value=100, orientation='h', key='_star_bar1_', size=(50, 5), bar_color=('blue', 'yellow'))], [sg.ProgressBar(max_value=100, orientation='h', key='_star_bar2_', size=(50, 5), bar_color=('yellow', 'blue'))]])\n\n    def empty_line(fontsize=12):\n        return [sg.T('', font='Mono ' + str(fontsize))]\n    window = sg.Window('We are live! Again! --- ' + 'Completed making            {}, {}'.format(os.path.basename(README_OFILENAME), os.path.basename(CALL_REFERENCE_OFILENAME)), [[sg.T(size=(30, 1), key='-compile-time-'), star_bar], empty_line(), [*md2psg(f'The *Bmagenta*PySimpleGUI** module being processed is *Imagenta*\"{psg_module_path}\"**'), sg.B('< open (__init__.py)', key='open_init_file'), sg.B('< open (psg.py)', key='open_psg_file')], empty_line(), [sg.B('Run again (F1)', key='-run-'), sg.Col([[sg.CB('show time in logs (F2)', False, enable_events=True, key='show_time')], [sg.CB('Logs with Color (F3)', True, enable_events=True, key='use_psg_color')]]), sg.Col([empty_line(5), [sg.B('open \"db folder\"', key='-open_db_folder-')]]), sg.Frame('', [[sg.Col([[*md2psg('markdown outputFileName *I*FOR** *B*readme  **: '), sg.I(README_OFILENAME, key='README_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_readme'), sg.B('open in text editor', key='open file - readme')], [*md2psg('markdown outputFileName *I*FOR** *B*call ref**: '), sg.I(CALL_REFERENCE_OFILENAME, key='CALL_REF_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_calref'), sg.B('open in text editor', key='open file - calref')]])]], relief=sg.RELIEF_SUNKEN, border_width=4)], *layout], resizable=True, finalize=True, location=(0, 0), return_keyboard_events=True)\n\n    def update_time_in_GUI():\n        window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))\n\n    def update_compilation_in_psg(values):\n        (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n        (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n        (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n        badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str1 = f'fix .:return:. in .({badNames}).'\n        badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str2 = f'empty md_table for .({badNames}).'\n\n        def is_valid_regex_LogMessage(msg: str):\n            nonlocal regex_str1, regex_str2\n            error1_found = False\n            if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n                error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n            error2_found = False\n            if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n                error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n            return not error1_found and (not error2_found)\n\n        def filter_log_messages(messages):\n            if type(messages) is str:\n                return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n            raise TypeError\n\n        class ParsingError(object):\n\n            def __init__(self, log_obj):\n                self.log_obj = log_obj\n                self.text = log_obj['message_text']\n\n            def __str__(self):\n                return self.__repr__()\n\n            def __repr__(self):\n                \"\"\"qwe\"\"\"\n                text = self.log_obj['message_text']\n                metadata = self.log_obj['message_metadata']\n                lineno = ''\n                if 'lineno' in metadata.keys():\n                    lineno = '(line:' + str(metadata['lineno']) + ') '\n                return f'{lineno} {text}'\n        items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        window['-README-listbox-']([ParsingError(i) for i in items1])\n        window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n        def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n            (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n            t_error = filter_log_messages(t_error)\n            t_warning = filter_log_messages(t_warning)\n            t_info = filter_log_messages(t_info)\n            t_debug = filter_log_messages(t_debug)\n            window[f'-{prefix}-error-'](t_error)\n            window[f'-{prefix}-warning-'](t_warning)\n            window[f'-{prefix}-info-'](t_info)\n            window[f'-{prefix}-debug-'](t_debug)\n            window[f'-{prefix}-warning_info-'].update('')\n            t_warning_info_obj = messages_obj[-1]\n            if values['use_psg_color']:\n                for (text, color) in t_warning_info_obj:\n                    if not is_valid_regex_LogMessage(text):\n                        continue\n                    window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n            else:\n                window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n        set_it('README', result_readme_txt)\n        set_it('CALL_REF', result_call_ref_txt)\n        update_time_in_GUI()\n    values = window.read(timeout=0)[1]\n    update_compilation_in_psg(values)\n    p_values = values\n    window['_PyCharm_path_'](APP_CONFIGS['_PyCharm_path_'])\n    window['_text_editor_combo_'].update(set_to_index=APP_CONFIGS['_text_editor_combo_'])\n    window['toggle_progressbar'](APP_CONFIGS['toggle_progressbar'])\n    window['checkbox_enable_empty_tables_filter'](APP_CONFIGS['checkbox_enable_empty_tables_filter'])\n    window['_filter_empty_tables_ml_'](APP_CONFIGS['_filter_empty_tables_ml_'])\n    window['checkbox_enable_filter_tkinter_class_methods'](APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'])\n    window['_filter_tkinter_class_methods_'](APP_CONFIGS['_filter_tkinter_class_methods_'])\n    window['show_time'](APP_CONFIGS['show_time'])\n    window['use_psg_color'](APP_CONFIGS['use_psg_color'])\n    window['README_OFILE'](APP_CONFIGS['README_OFILE'])\n    window['CALL_REF_OFILE'](APP_CONFIGS['CALL_REF_OFILE'])\n    next_val_gen = next_star()\n    my_timeout = None\n    while True:\n        (event, values) = window(timeout=my_timeout)\n        if event in ('Exit', None):\n            APP_CONFIGS['_text_editor_combo_'] = 1 if window['_text_editor_combo_'].get() == 'subl' else 0\n            APP_CONFIGS['toggle_progressbar'] = p_values['toggle_progressbar']\n            APP_CONFIGS['checkbox_enable_empty_tables_filter'] = p_values['checkbox_enable_empty_tables_filter']\n            APP_CONFIGS['_filter_empty_tables_ml_'] = p_values['_filter_empty_tables_ml_']\n            APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'] = p_values['checkbox_enable_filter_tkinter_class_methods']\n            APP_CONFIGS['_filter_tkinter_class_methods_'] = p_values['_filter_tkinter_class_methods_']\n            APP_CONFIGS['show_time'] = p_values['show_time']\n            APP_CONFIGS['use_psg_color'] = p_values['use_psg_color']\n            APP_CONFIGS['README_OFILE'] = p_values['README_OFILE']\n            APP_CONFIGS['CALL_REF_OFILE'] = p_values['CALL_REF_OFILE']\n            save_configs(APP_CONFIGS)\n            break\n        p_values = values\n        if '__TIMEOUT__' in event:\n            if values['toggle_progressbar']:\n                window['_star_bar1_'].UpdateBar(next(next_val_gen))\n                window['_star_bar2_'].UpdateBar(next(next_val_gen))\n        if '__TIMEOUT__' not in event:\n            print('PSG event>', event)\n        if event == 'toggle_progressbar':\n            my_timeout = None if not values['toggle_progressbar'] else 100\n        if event == '-README-listbox-':\n            metadata = values['-README-listbox-'][0].log_obj['message_metadata']\n            print(f'metadata = {metadata}')\n        if event == '-CALL_REF-listbox-':\n            ParsingError_obj = values['-CALL_REF-listbox-'][0]\n            metadata = ParsingError_obj.log_obj['message_metadata']\n            if 'lineno' in metadata.keys():\n                lineno = metadata['lineno']\n                texteditor = values['_text_editor_combo_']\n                psg_module_path_SDK = psg_module_path.replace('__init__.py', 'PySimpleGUI.py')\n                if 'pycharm' == texteditor:\n                    texteditor = values['_PyCharm_path_']\n                    subprocess.Popen(f'\"{texteditor}\" --line {lineno} \"{psg_module_path_SDK}\"', shell=True)\n                elif 'subl' == texteditor:\n                    subprocess.Popen(f'{texteditor} \"{psg_module_path_SDK}:{lineno}\"', shell=True)\n        if event == '-run-' or 'F1' in event:\n            update_compilation_in_psg(values)\n        if event == '-open_db_folder-':\n            opendir(cd)\n        if event == 'open in explorer_readme':\n            opendir(os.path.dirname(os.path.join(cd, values['README_OFILE'])))\n        if event == 'open in explorer_calref':\n            opendir(os.path.dirname(os.path.join(cd, values['CALL_REF_OFILE'])))\n        if event == 'open file - readme':\n            openfile(os.path.join(cd, values['README_OFILE']))\n        if event == 'open file - calref':\n            openfile(os.path.join(cd, values['CALL_REF_OFILE']))\n        if event == 'open_init_file':\n            openfile(psg_module_path)\n        if event == 'open_psg_file':\n            openfile(psg_module_path.replace('__init__.py', 'PySimpleGUI.py'))\n        if 'F2' in event:\n            window['show_time'](not values['show_time'])\n        if 'F3' in event:\n            window['use_psg_color'](not values['use_psg_color'])\n    window.close()",
            "def mini_GUI():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    my_font = ('Helvetica', 12)\n    my_font2 = ('Helvetica', 12, 'bold')\n    my_font3 = ('Helvetica', 15, 'bold')\n    my_font4 = ('Mono', 18, 'bold')\n\n    def make_tab(word):\n\n        def tabs(*layouts):\n            return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n        return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]\n    settings_layout = [[sg.CB('Toggle progressbar', False, enable_events=True, key='toggle_progressbar')], [sg.Frame('Text editor', [[sg.Combo(['pycharm', 'subl'], default_value='subl', enable_events=True, key='_text_editor_combo_')]]), sg.Frame('Pycharm path:', [[sg.I('', size=(40, 1), enable_events=True, key='_PyCharm_path_')]])], [sg.Frame('\u2140\u2209 Filter \"empty tables\"', [[sg.T('This is for filtering stirng, like:')], [sg.T('Warning =======    We got empty md_table for \"EasyPrintClose\"', font='Mono 8')], [sg.CB('enable', True, key='checkbox_enable_empty_tables_filter', enable_events=True)], [sg.ML('PrintClose\\nEasyPrintClose\\nmain\\ntheme\\nRead', size=(30, 10), enable_events=True, key='_filter_empty_tables_ml_')]]), sg.Frame('\u2140\u2209 Filter \"tkinter class methods\"', [[sg.T('This is for filtering stirng, like:')], [sg.T(\"Please, fix ':return:' in 'SetFocus'                  IF you want to see 'return' row in 'signature table' \", font='Mono 8')], [sg.CB('enable', True, enable_events=True, key='checkbox_enable_filter_tkinter_class_methods')], [sg.ML('SetFocus\\nSetTooltip\\nUpdate\\n__init__\\nbind\\nexpand\\nset_cursor\\nset_size', size=(30, 10), enable_events=True, key='_filter_tkinter_class_methods_')]], visible=not True)]]\n    layout = [[sg.TabGroup([[sg.Tab('readme logs', make_tab('README')), sg.Tab('Call reference logs', make_tab('CALL_REF')), sg.Tab('General settings', settings_layout)]])]]\n    from time import sleep\n    from math import pi, sin\n    from itertools import count\n\n    def next_star():\n        middle = 100 / 2\n        for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n            yield i\n    psg_module_path = str(sg).split(\"' from '\")[1][:-2]\n    star_bar = sg.Col([[sg.ProgressBar(max_value=100, orientation='h', key='_star_bar1_', size=(50, 5), bar_color=('blue', 'yellow'))], [sg.ProgressBar(max_value=100, orientation='h', key='_star_bar2_', size=(50, 5), bar_color=('yellow', 'blue'))]])\n\n    def empty_line(fontsize=12):\n        return [sg.T('', font='Mono ' + str(fontsize))]\n    window = sg.Window('We are live! Again! --- ' + 'Completed making            {}, {}'.format(os.path.basename(README_OFILENAME), os.path.basename(CALL_REFERENCE_OFILENAME)), [[sg.T(size=(30, 1), key='-compile-time-'), star_bar], empty_line(), [*md2psg(f'The *Bmagenta*PySimpleGUI** module being processed is *Imagenta*\"{psg_module_path}\"**'), sg.B('< open (__init__.py)', key='open_init_file'), sg.B('< open (psg.py)', key='open_psg_file')], empty_line(), [sg.B('Run again (F1)', key='-run-'), sg.Col([[sg.CB('show time in logs (F2)', False, enable_events=True, key='show_time')], [sg.CB('Logs with Color (F3)', True, enable_events=True, key='use_psg_color')]]), sg.Col([empty_line(5), [sg.B('open \"db folder\"', key='-open_db_folder-')]]), sg.Frame('', [[sg.Col([[*md2psg('markdown outputFileName *I*FOR** *B*readme  **: '), sg.I(README_OFILENAME, key='README_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_readme'), sg.B('open in text editor', key='open file - readme')], [*md2psg('markdown outputFileName *I*FOR** *B*call ref**: '), sg.I(CALL_REFERENCE_OFILENAME, key='CALL_REF_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_calref'), sg.B('open in text editor', key='open file - calref')]])]], relief=sg.RELIEF_SUNKEN, border_width=4)], *layout], resizable=True, finalize=True, location=(0, 0), return_keyboard_events=True)\n\n    def update_time_in_GUI():\n        window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))\n\n    def update_compilation_in_psg(values):\n        (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n        (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n        (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n        badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str1 = f'fix .:return:. in .({badNames}).'\n        badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str2 = f'empty md_table for .({badNames}).'\n\n        def is_valid_regex_LogMessage(msg: str):\n            nonlocal regex_str1, regex_str2\n            error1_found = False\n            if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n                error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n            error2_found = False\n            if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n                error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n            return not error1_found and (not error2_found)\n\n        def filter_log_messages(messages):\n            if type(messages) is str:\n                return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n            raise TypeError\n\n        class ParsingError(object):\n\n            def __init__(self, log_obj):\n                self.log_obj = log_obj\n                self.text = log_obj['message_text']\n\n            def __str__(self):\n                return self.__repr__()\n\n            def __repr__(self):\n                \"\"\"qwe\"\"\"\n                text = self.log_obj['message_text']\n                metadata = self.log_obj['message_metadata']\n                lineno = ''\n                if 'lineno' in metadata.keys():\n                    lineno = '(line:' + str(metadata['lineno']) + ') '\n                return f'{lineno} {text}'\n        items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        window['-README-listbox-']([ParsingError(i) for i in items1])\n        window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n        def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n            (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n            t_error = filter_log_messages(t_error)\n            t_warning = filter_log_messages(t_warning)\n            t_info = filter_log_messages(t_info)\n            t_debug = filter_log_messages(t_debug)\n            window[f'-{prefix}-error-'](t_error)\n            window[f'-{prefix}-warning-'](t_warning)\n            window[f'-{prefix}-info-'](t_info)\n            window[f'-{prefix}-debug-'](t_debug)\n            window[f'-{prefix}-warning_info-'].update('')\n            t_warning_info_obj = messages_obj[-1]\n            if values['use_psg_color']:\n                for (text, color) in t_warning_info_obj:\n                    if not is_valid_regex_LogMessage(text):\n                        continue\n                    window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n            else:\n                window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n        set_it('README', result_readme_txt)\n        set_it('CALL_REF', result_call_ref_txt)\n        update_time_in_GUI()\n    values = window.read(timeout=0)[1]\n    update_compilation_in_psg(values)\n    p_values = values\n    window['_PyCharm_path_'](APP_CONFIGS['_PyCharm_path_'])\n    window['_text_editor_combo_'].update(set_to_index=APP_CONFIGS['_text_editor_combo_'])\n    window['toggle_progressbar'](APP_CONFIGS['toggle_progressbar'])\n    window['checkbox_enable_empty_tables_filter'](APP_CONFIGS['checkbox_enable_empty_tables_filter'])\n    window['_filter_empty_tables_ml_'](APP_CONFIGS['_filter_empty_tables_ml_'])\n    window['checkbox_enable_filter_tkinter_class_methods'](APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'])\n    window['_filter_tkinter_class_methods_'](APP_CONFIGS['_filter_tkinter_class_methods_'])\n    window['show_time'](APP_CONFIGS['show_time'])\n    window['use_psg_color'](APP_CONFIGS['use_psg_color'])\n    window['README_OFILE'](APP_CONFIGS['README_OFILE'])\n    window['CALL_REF_OFILE'](APP_CONFIGS['CALL_REF_OFILE'])\n    next_val_gen = next_star()\n    my_timeout = None\n    while True:\n        (event, values) = window(timeout=my_timeout)\n        if event in ('Exit', None):\n            APP_CONFIGS['_text_editor_combo_'] = 1 if window['_text_editor_combo_'].get() == 'subl' else 0\n            APP_CONFIGS['toggle_progressbar'] = p_values['toggle_progressbar']\n            APP_CONFIGS['checkbox_enable_empty_tables_filter'] = p_values['checkbox_enable_empty_tables_filter']\n            APP_CONFIGS['_filter_empty_tables_ml_'] = p_values['_filter_empty_tables_ml_']\n            APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'] = p_values['checkbox_enable_filter_tkinter_class_methods']\n            APP_CONFIGS['_filter_tkinter_class_methods_'] = p_values['_filter_tkinter_class_methods_']\n            APP_CONFIGS['show_time'] = p_values['show_time']\n            APP_CONFIGS['use_psg_color'] = p_values['use_psg_color']\n            APP_CONFIGS['README_OFILE'] = p_values['README_OFILE']\n            APP_CONFIGS['CALL_REF_OFILE'] = p_values['CALL_REF_OFILE']\n            save_configs(APP_CONFIGS)\n            break\n        p_values = values\n        if '__TIMEOUT__' in event:\n            if values['toggle_progressbar']:\n                window['_star_bar1_'].UpdateBar(next(next_val_gen))\n                window['_star_bar2_'].UpdateBar(next(next_val_gen))\n        if '__TIMEOUT__' not in event:\n            print('PSG event>', event)\n        if event == 'toggle_progressbar':\n            my_timeout = None if not values['toggle_progressbar'] else 100\n        if event == '-README-listbox-':\n            metadata = values['-README-listbox-'][0].log_obj['message_metadata']\n            print(f'metadata = {metadata}')\n        if event == '-CALL_REF-listbox-':\n            ParsingError_obj = values['-CALL_REF-listbox-'][0]\n            metadata = ParsingError_obj.log_obj['message_metadata']\n            if 'lineno' in metadata.keys():\n                lineno = metadata['lineno']\n                texteditor = values['_text_editor_combo_']\n                psg_module_path_SDK = psg_module_path.replace('__init__.py', 'PySimpleGUI.py')\n                if 'pycharm' == texteditor:\n                    texteditor = values['_PyCharm_path_']\n                    subprocess.Popen(f'\"{texteditor}\" --line {lineno} \"{psg_module_path_SDK}\"', shell=True)\n                elif 'subl' == texteditor:\n                    subprocess.Popen(f'{texteditor} \"{psg_module_path_SDK}:{lineno}\"', shell=True)\n        if event == '-run-' or 'F1' in event:\n            update_compilation_in_psg(values)\n        if event == '-open_db_folder-':\n            opendir(cd)\n        if event == 'open in explorer_readme':\n            opendir(os.path.dirname(os.path.join(cd, values['README_OFILE'])))\n        if event == 'open in explorer_calref':\n            opendir(os.path.dirname(os.path.join(cd, values['CALL_REF_OFILE'])))\n        if event == 'open file - readme':\n            openfile(os.path.join(cd, values['README_OFILE']))\n        if event == 'open file - calref':\n            openfile(os.path.join(cd, values['CALL_REF_OFILE']))\n        if event == 'open_init_file':\n            openfile(psg_module_path)\n        if event == 'open_psg_file':\n            openfile(psg_module_path.replace('__init__.py', 'PySimpleGUI.py'))\n        if 'F2' in event:\n            window['show_time'](not values['show_time'])\n        if 'F3' in event:\n            window['use_psg_color'](not values['use_psg_color'])\n    window.close()",
            "def mini_GUI():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    my_font = ('Helvetica', 12)\n    my_font2 = ('Helvetica', 12, 'bold')\n    my_font3 = ('Helvetica', 15, 'bold')\n    my_font4 = ('Mono', 18, 'bold')\n\n    def make_tab(word):\n\n        def tabs(*layouts):\n            return sg.TabGroup([[sg.Tab(title, lay, key=f'-tab-{word_}-{index}-') for (index, (title, word_, lay)) in enumerate(layouts)]])\n        return [[sg.Column(layout=[[sg.T('debug', font=my_font, text_color='grey')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-debug-')], [sg.T('error', font=my_font, text_color='red')], [sg.ML(size=(50 - 15, 15), key=f'-{word}-error-')]], pad=(0, 0)), sg.T('    '), sg.Column(layout=[[sg.T('warning', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-warning-')], [sg.T('info', font=my_font2)], [sg.ML(size=(70 - 12, 15), key=f'-{word}-info-')]], pad=(0, 0)), tabs(('Text', word, [[sg.T('warning info', font=my_font3)], [sg.ML(size=(110, 30), key=f'-{word}-warning_info-')]]), ('Listbox', word, [[sg.T('warning info listbox', font=my_font3)], [sg.Listbox([], size=(110, 30 - 1), key=f'-{word}-listbox-', enable_events=True, background_color='#ffccaa')]]))]]\n    settings_layout = [[sg.CB('Toggle progressbar', False, enable_events=True, key='toggle_progressbar')], [sg.Frame('Text editor', [[sg.Combo(['pycharm', 'subl'], default_value='subl', enable_events=True, key='_text_editor_combo_')]]), sg.Frame('Pycharm path:', [[sg.I('', size=(40, 1), enable_events=True, key='_PyCharm_path_')]])], [sg.Frame('\u2140\u2209 Filter \"empty tables\"', [[sg.T('This is for filtering stirng, like:')], [sg.T('Warning =======    We got empty md_table for \"EasyPrintClose\"', font='Mono 8')], [sg.CB('enable', True, key='checkbox_enable_empty_tables_filter', enable_events=True)], [sg.ML('PrintClose\\nEasyPrintClose\\nmain\\ntheme\\nRead', size=(30, 10), enable_events=True, key='_filter_empty_tables_ml_')]]), sg.Frame('\u2140\u2209 Filter \"tkinter class methods\"', [[sg.T('This is for filtering stirng, like:')], [sg.T(\"Please, fix ':return:' in 'SetFocus'                  IF you want to see 'return' row in 'signature table' \", font='Mono 8')], [sg.CB('enable', True, enable_events=True, key='checkbox_enable_filter_tkinter_class_methods')], [sg.ML('SetFocus\\nSetTooltip\\nUpdate\\n__init__\\nbind\\nexpand\\nset_cursor\\nset_size', size=(30, 10), enable_events=True, key='_filter_tkinter_class_methods_')]], visible=not True)]]\n    layout = [[sg.TabGroup([[sg.Tab('readme logs', make_tab('README')), sg.Tab('Call reference logs', make_tab('CALL_REF')), sg.Tab('General settings', settings_layout)]])]]\n    from time import sleep\n    from math import pi, sin\n    from itertools import count\n\n    def next_star():\n        middle = 100 / 2\n        for i in (int(sin(i * pi / middle) * middle + middle) for i in count()):\n            yield i\n    psg_module_path = str(sg).split(\"' from '\")[1][:-2]\n    star_bar = sg.Col([[sg.ProgressBar(max_value=100, orientation='h', key='_star_bar1_', size=(50, 5), bar_color=('blue', 'yellow'))], [sg.ProgressBar(max_value=100, orientation='h', key='_star_bar2_', size=(50, 5), bar_color=('yellow', 'blue'))]])\n\n    def empty_line(fontsize=12):\n        return [sg.T('', font='Mono ' + str(fontsize))]\n    window = sg.Window('We are live! Again! --- ' + 'Completed making            {}, {}'.format(os.path.basename(README_OFILENAME), os.path.basename(CALL_REFERENCE_OFILENAME)), [[sg.T(size=(30, 1), key='-compile-time-'), star_bar], empty_line(), [*md2psg(f'The *Bmagenta*PySimpleGUI** module being processed is *Imagenta*\"{psg_module_path}\"**'), sg.B('< open (__init__.py)', key='open_init_file'), sg.B('< open (psg.py)', key='open_psg_file')], empty_line(), [sg.B('Run again (F1)', key='-run-'), sg.Col([[sg.CB('show time in logs (F2)', False, enable_events=True, key='show_time')], [sg.CB('Logs with Color (F3)', True, enable_events=True, key='use_psg_color')]]), sg.Col([empty_line(5), [sg.B('open \"db folder\"', key='-open_db_folder-')]]), sg.Frame('', [[sg.Col([[*md2psg('markdown outputFileName *I*FOR** *B*readme  **: '), sg.I(README_OFILENAME, key='README_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_readme'), sg.B('open in text editor', key='open file - readme')], [*md2psg('markdown outputFileName *I*FOR** *B*call ref**: '), sg.I(CALL_REFERENCE_OFILENAME, key='CALL_REF_OFILE', size=(25, 1)), sg.B('open in explorer', key='open in explorer_calref'), sg.B('open in text editor', key='open file - calref')]])]], relief=sg.RELIEF_SUNKEN, border_width=4)], *layout], resizable=True, finalize=True, location=(0, 0), return_keyboard_events=True)\n\n    def update_time_in_GUI():\n        window['-compile-time-'](datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S.%f'))\n\n    def update_compilation_in_psg(values):\n        (result_readme__for_txt_n_listbox, result_call_ref__for_txt_n_listbox) = compile_all_stuff(use_psg_color=values['use_psg_color'], show_time=values['show_time'])\n        (result_readme_txt, result_readme_listbox_items) = result_readme__for_txt_n_listbox\n        (result_call_ref_txt, result_call_ref_listbox_items) = result_call_ref__for_txt_n_listbox\n        badNames = [i.strip() for i in values['_filter_tkinter_class_methods_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str1 = f'fix .:return:. in .({badNames}).'\n        badNames = [i for i in values['_filter_empty_tables_ml_'].split('\\n') if i.strip()]\n        badNames = '|'.join(badNames)\n        regex_str2 = f'empty md_table for .({badNames}).'\n\n        def is_valid_regex_LogMessage(msg: str):\n            nonlocal regex_str1, regex_str2\n            error1_found = False\n            if values['checkbox_enable_filter_tkinter_class_methods'] and ':return:' in msg:\n                error1_found = bool(re.search(regex_str1, msg, flags=re.M | re.DOTALL))\n            error2_found = False\n            if values['checkbox_enable_empty_tables_filter'] and 'empty md_table for' in msg:\n                error2_found = bool(re.search(regex_str2, msg, flags=re.M | re.DOTALL))\n            return not error1_found and (not error2_found)\n\n        def filter_log_messages(messages):\n            if type(messages) is str:\n                return '\\n'.join([msg for msg in messages.split('\\n') if is_valid_regex_LogMessage(msg)])\n            raise TypeError\n\n        class ParsingError(object):\n\n            def __init__(self, log_obj):\n                self.log_obj = log_obj\n                self.text = log_obj['message_text']\n\n            def __str__(self):\n                return self.__repr__()\n\n            def __repr__(self):\n                \"\"\"qwe\"\"\"\n                text = self.log_obj['message_text']\n                metadata = self.log_obj['message_metadata']\n                lineno = ''\n                if 'lineno' in metadata.keys():\n                    lineno = '(line:' + str(metadata['lineno']) + ') '\n                return f'{lineno} {text}'\n        items1 = [i for i in result_readme_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        items2 = [i for i in result_call_ref_listbox_items if is_valid_regex_LogMessage(i['message_text'])]\n        window['-README-listbox-']([ParsingError(i) for i in items1])\n        window['-CALL_REF-listbox-']([ParsingError(i) for i in items2])\n\n        def set_it(prefix='CALL_REF', messages_obj=result_call_ref_txt):\n            (t_error, t_warning, t_info, t_debug) = ['\\n'.join(i) for i in messages_obj[:4]]\n            t_error = filter_log_messages(t_error)\n            t_warning = filter_log_messages(t_warning)\n            t_info = filter_log_messages(t_info)\n            t_debug = filter_log_messages(t_debug)\n            window[f'-{prefix}-error-'](t_error)\n            window[f'-{prefix}-warning-'](t_warning)\n            window[f'-{prefix}-info-'](t_info)\n            window[f'-{prefix}-debug-'](t_debug)\n            window[f'-{prefix}-warning_info-'].update('')\n            t_warning_info_obj = messages_obj[-1]\n            if values['use_psg_color']:\n                for (text, color) in t_warning_info_obj:\n                    if not is_valid_regex_LogMessage(text):\n                        continue\n                    window[f'-{prefix}-warning_info-'].print(text, text_color=color)\n            else:\n                window[f'-{prefix}-warning_info-'](t_warning_info_obj)\n        set_it('README', result_readme_txt)\n        set_it('CALL_REF', result_call_ref_txt)\n        update_time_in_GUI()\n    values = window.read(timeout=0)[1]\n    update_compilation_in_psg(values)\n    p_values = values\n    window['_PyCharm_path_'](APP_CONFIGS['_PyCharm_path_'])\n    window['_text_editor_combo_'].update(set_to_index=APP_CONFIGS['_text_editor_combo_'])\n    window['toggle_progressbar'](APP_CONFIGS['toggle_progressbar'])\n    window['checkbox_enable_empty_tables_filter'](APP_CONFIGS['checkbox_enable_empty_tables_filter'])\n    window['_filter_empty_tables_ml_'](APP_CONFIGS['_filter_empty_tables_ml_'])\n    window['checkbox_enable_filter_tkinter_class_methods'](APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'])\n    window['_filter_tkinter_class_methods_'](APP_CONFIGS['_filter_tkinter_class_methods_'])\n    window['show_time'](APP_CONFIGS['show_time'])\n    window['use_psg_color'](APP_CONFIGS['use_psg_color'])\n    window['README_OFILE'](APP_CONFIGS['README_OFILE'])\n    window['CALL_REF_OFILE'](APP_CONFIGS['CALL_REF_OFILE'])\n    next_val_gen = next_star()\n    my_timeout = None\n    while True:\n        (event, values) = window(timeout=my_timeout)\n        if event in ('Exit', None):\n            APP_CONFIGS['_text_editor_combo_'] = 1 if window['_text_editor_combo_'].get() == 'subl' else 0\n            APP_CONFIGS['toggle_progressbar'] = p_values['toggle_progressbar']\n            APP_CONFIGS['checkbox_enable_empty_tables_filter'] = p_values['checkbox_enable_empty_tables_filter']\n            APP_CONFIGS['_filter_empty_tables_ml_'] = p_values['_filter_empty_tables_ml_']\n            APP_CONFIGS['checkbox_enable_filter_tkinter_class_methods'] = p_values['checkbox_enable_filter_tkinter_class_methods']\n            APP_CONFIGS['_filter_tkinter_class_methods_'] = p_values['_filter_tkinter_class_methods_']\n            APP_CONFIGS['show_time'] = p_values['show_time']\n            APP_CONFIGS['use_psg_color'] = p_values['use_psg_color']\n            APP_CONFIGS['README_OFILE'] = p_values['README_OFILE']\n            APP_CONFIGS['CALL_REF_OFILE'] = p_values['CALL_REF_OFILE']\n            save_configs(APP_CONFIGS)\n            break\n        p_values = values\n        if '__TIMEOUT__' in event:\n            if values['toggle_progressbar']:\n                window['_star_bar1_'].UpdateBar(next(next_val_gen))\n                window['_star_bar2_'].UpdateBar(next(next_val_gen))\n        if '__TIMEOUT__' not in event:\n            print('PSG event>', event)\n        if event == 'toggle_progressbar':\n            my_timeout = None if not values['toggle_progressbar'] else 100\n        if event == '-README-listbox-':\n            metadata = values['-README-listbox-'][0].log_obj['message_metadata']\n            print(f'metadata = {metadata}')\n        if event == '-CALL_REF-listbox-':\n            ParsingError_obj = values['-CALL_REF-listbox-'][0]\n            metadata = ParsingError_obj.log_obj['message_metadata']\n            if 'lineno' in metadata.keys():\n                lineno = metadata['lineno']\n                texteditor = values['_text_editor_combo_']\n                psg_module_path_SDK = psg_module_path.replace('__init__.py', 'PySimpleGUI.py')\n                if 'pycharm' == texteditor:\n                    texteditor = values['_PyCharm_path_']\n                    subprocess.Popen(f'\"{texteditor}\" --line {lineno} \"{psg_module_path_SDK}\"', shell=True)\n                elif 'subl' == texteditor:\n                    subprocess.Popen(f'{texteditor} \"{psg_module_path_SDK}:{lineno}\"', shell=True)\n        if event == '-run-' or 'F1' in event:\n            update_compilation_in_psg(values)\n        if event == '-open_db_folder-':\n            opendir(cd)\n        if event == 'open in explorer_readme':\n            opendir(os.path.dirname(os.path.join(cd, values['README_OFILE'])))\n        if event == 'open in explorer_calref':\n            opendir(os.path.dirname(os.path.join(cd, values['CALL_REF_OFILE'])))\n        if event == 'open file - readme':\n            openfile(os.path.join(cd, values['README_OFILE']))\n        if event == 'open file - calref':\n            openfile(os.path.join(cd, values['CALL_REF_OFILE']))\n        if event == 'open_init_file':\n            openfile(psg_module_path)\n        if event == 'open_psg_file':\n            openfile(psg_module_path.replace('__init__.py', 'PySimpleGUI.py'))\n        if 'F2' in event:\n            window['show_time'](not values['show_time'])\n        if 'F3' in event:\n            window['use_psg_color'](not values['use_psg_color'])\n    window.close()"
        ]
    }
]