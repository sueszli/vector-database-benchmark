from __future__ import annotations
import typing
from typing import Any
from typing import Callable
from typing import Iterable
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple as typing_Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import coercions
from . import roles
from .base import _NoArg
from .coercions import _document_text_coercion
from .elements import BindParameter
from .elements import BooleanClauseList
from .elements import Case
from .elements import Cast
from .elements import CollationClause
from .elements import CollectionAggregate
from .elements import ColumnClause
from .elements import ColumnElement
from .elements import Extract
from .elements import False_
from .elements import FunctionFilter
from .elements import Label
from .elements import Null
from .elements import Over
from .elements import TextClause
from .elements import True_
from .elements import TryCast
from .elements import Tuple
from .elements import TypeCoerce
from .elements import UnaryExpression
from .elements import WithinGroup
from .functions import FunctionElement
from ..util.typing import Literal
if typing.TYPE_CHECKING:
    from ._typing import _ColumnExpressionArgument
    from ._typing import _ColumnExpressionOrLiteralArgument
    from ._typing import _ColumnExpressionOrStrLabelArgument
    from ._typing import _TypeEngineArgument
    from .elements import BinaryExpression
    from .selectable import FromClause
    from .type_api import TypeEngine
_T = TypeVar('_T')

def all_(expr: _ColumnExpressionArgument[_T]) -> CollectionAggregate[bool]:
    if False:
        print('Hello World!')
    'Produce an ALL expression.\n\n    For dialects such as that of PostgreSQL, this operator applies\n    to usage of the :class:`_types.ARRAY` datatype, for that of\n    MySQL, it may apply to a subquery.  e.g.::\n\n        # renders on PostgreSQL:\n        # \'5 = ALL (somearray)\'\n        expr = 5 == all_(mytable.c.somearray)\n\n        # renders on MySQL:\n        # \'5 = ALL (SELECT value FROM table)\'\n        expr = 5 == all_(select(table.c.value))\n\n    Comparison to NULL may work using ``None``::\n\n        None == all_(mytable.c.somearray)\n\n    The any_() / all_() operators also feature a special "operand flipping"\n    behavior such that if any_() / all_() are used on the left side of a\n    comparison using a standalone operator such as ``==``, ``!=``, etc.\n    (not including operator methods such as\n    :meth:`_sql.ColumnOperators.is_`) the rendered expression is flipped::\n\n        # would render \'5 = ALL (column)`\n        all_(mytable.c.column) == 5\n\n    Or with ``None``, which note will not perform\n    the usual step of rendering "IS" as is normally the case for NULL::\n\n        # would render \'NULL = ALL(somearray)\'\n        all_(mytable.c.somearray) == None\n\n    .. versionchanged:: 1.4.26  repaired the use of any_() / all_()\n       comparing to NULL on the right side to be flipped to the left.\n\n    The column-level :meth:`_sql.ColumnElement.all_` method (not to be\n    confused with :class:`_types.ARRAY` level\n    :meth:`_types.ARRAY.Comparator.all`) is shorthand for\n    ``all_(col)``::\n\n        5 == mytable.c.somearray.all_()\n\n    .. seealso::\n\n        :meth:`_sql.ColumnOperators.all_`\n\n        :func:`_expression.any_`\n\n    '
    return CollectionAggregate._create_all(expr)

def and_(initial_clause: Union[Literal[True], _ColumnExpressionArgument[bool]], *clauses: _ColumnExpressionArgument[bool]) -> ColumnElement[bool]:
    if False:
        return 10
    'Produce a conjunction of expressions joined by ``AND``.\n\n    E.g.::\n\n        from sqlalchemy import and_\n\n        stmt = select(users_table).where(\n                        and_(\n                            users_table.c.name == \'wendy\',\n                            users_table.c.enrolled == True\n                        )\n                    )\n\n    The :func:`.and_` conjunction is also available using the\n    Python ``&`` operator (though note that compound expressions\n    need to be parenthesized in order to function with Python\n    operator precedence behavior)::\n\n        stmt = select(users_table).where(\n                        (users_table.c.name == \'wendy\') &\n                        (users_table.c.enrolled == True)\n                    )\n\n    The :func:`.and_` operation is also implicit in some cases;\n    the :meth:`_expression.Select.where`\n    method for example can be invoked multiple\n    times against a statement, which will have the effect of each\n    clause being combined using :func:`.and_`::\n\n        stmt = select(users_table).\\\n                where(users_table.c.name == \'wendy\').\\\n                where(users_table.c.enrolled == True)\n\n    The :func:`.and_` construct must be given at least one positional\n    argument in order to be valid; a :func:`.and_` construct with no\n    arguments is ambiguous.   To produce an "empty" or dynamically\n    generated :func:`.and_`  expression, from a given list of expressions,\n    a "default" element of :func:`_sql.true` (or just ``True``) should be\n    specified::\n\n        from sqlalchemy import true\n        criteria = and_(true(), *expressions)\n\n    The above expression will compile to SQL as the expression ``true``\n    or ``1 = 1``, depending on backend, if no other expressions are\n    present.  If expressions are present, then the :func:`_sql.true` value is\n    ignored as it does not affect the outcome of an AND expression that\n    has other elements.\n\n    .. deprecated:: 1.4  The :func:`.and_` element now requires that at\n       least one argument is passed; creating the :func:`.and_` construct\n       with no arguments is deprecated, and will emit a deprecation warning\n       while continuing to produce a blank SQL string.\n\n    .. seealso::\n\n        :func:`.or_`\n\n    '
    ...
if not TYPE_CHECKING:

    def and_(*clauses):
        if False:
            i = 10
            return i + 15
        'Produce a conjunction of expressions joined by ``AND``.\n\n        E.g.::\n\n            from sqlalchemy import and_\n\n            stmt = select(users_table).where(\n                            and_(\n                                users_table.c.name == \'wendy\',\n                                users_table.c.enrolled == True\n                            )\n                        )\n\n        The :func:`.and_` conjunction is also available using the\n        Python ``&`` operator (though note that compound expressions\n        need to be parenthesized in order to function with Python\n        operator precedence behavior)::\n\n            stmt = select(users_table).where(\n                            (users_table.c.name == \'wendy\') &\n                            (users_table.c.enrolled == True)\n                        )\n\n        The :func:`.and_` operation is also implicit in some cases;\n        the :meth:`_expression.Select.where`\n        method for example can be invoked multiple\n        times against a statement, which will have the effect of each\n        clause being combined using :func:`.and_`::\n\n            stmt = select(users_table).\\\n                    where(users_table.c.name == \'wendy\').\\\n                    where(users_table.c.enrolled == True)\n\n        The :func:`.and_` construct must be given at least one positional\n        argument in order to be valid; a :func:`.and_` construct with no\n        arguments is ambiguous.   To produce an "empty" or dynamically\n        generated :func:`.and_`  expression, from a given list of expressions,\n        a "default" element of :func:`_sql.true` (or just ``True``) should be\n        specified::\n\n            from sqlalchemy import true\n            criteria = and_(true(), *expressions)\n\n        The above expression will compile to SQL as the expression ``true``\n        or ``1 = 1``, depending on backend, if no other expressions are\n        present.  If expressions are present, then the :func:`_sql.true` value\n        is ignored as it does not affect the outcome of an AND expression that\n        has other elements.\n\n        .. deprecated:: 1.4  The :func:`.and_` element now requires that at\n          least one argument is passed; creating the :func:`.and_` construct\n          with no arguments is deprecated, and will emit a deprecation warning\n          while continuing to produce a blank SQL string.\n\n        .. seealso::\n\n            :func:`.or_`\n\n        '
        return BooleanClauseList.and_(*clauses)

def any_(expr: _ColumnExpressionArgument[_T]) -> CollectionAggregate[bool]:
    if False:
        i = 10
        return i + 15
    'Produce an ANY expression.\n\n    For dialects such as that of PostgreSQL, this operator applies\n    to usage of the :class:`_types.ARRAY` datatype, for that of\n    MySQL, it may apply to a subquery.  e.g.::\n\n        # renders on PostgreSQL:\n        # \'5 = ANY (somearray)\'\n        expr = 5 == any_(mytable.c.somearray)\n\n        # renders on MySQL:\n        # \'5 = ANY (SELECT value FROM table)\'\n        expr = 5 == any_(select(table.c.value))\n\n    Comparison to NULL may work using ``None`` or :func:`_sql.null`::\n\n        None == any_(mytable.c.somearray)\n\n    The any_() / all_() operators also feature a special "operand flipping"\n    behavior such that if any_() / all_() are used on the left side of a\n    comparison using a standalone operator such as ``==``, ``!=``, etc.\n    (not including operator methods such as\n    :meth:`_sql.ColumnOperators.is_`) the rendered expression is flipped::\n\n        # would render \'5 = ANY (column)`\n        any_(mytable.c.column) == 5\n\n    Or with ``None``, which note will not perform\n    the usual step of rendering "IS" as is normally the case for NULL::\n\n        # would render \'NULL = ANY(somearray)\'\n        any_(mytable.c.somearray) == None\n\n    .. versionchanged:: 1.4.26  repaired the use of any_() / all_()\n       comparing to NULL on the right side to be flipped to the left.\n\n    The column-level :meth:`_sql.ColumnElement.any_` method (not to be\n    confused with :class:`_types.ARRAY` level\n    :meth:`_types.ARRAY.Comparator.any`) is shorthand for\n    ``any_(col)``::\n\n        5 = mytable.c.somearray.any_()\n\n    .. seealso::\n\n        :meth:`_sql.ColumnOperators.any_`\n\n        :func:`_expression.all_`\n\n    '
    return CollectionAggregate._create_any(expr)

def asc(column: _ColumnExpressionOrStrLabelArgument[_T]) -> UnaryExpression[_T]:
    if False:
        for i in range(10):
            print('nop')
    'Produce an ascending ``ORDER BY`` clause element.\n\n    e.g.::\n\n        from sqlalchemy import asc\n        stmt = select(users_table).order_by(asc(users_table.c.name))\n\n    will produce SQL as::\n\n        SELECT id, name FROM user ORDER BY name ASC\n\n    The :func:`.asc` function is a standalone version of the\n    :meth:`_expression.ColumnElement.asc`\n    method available on all SQL expressions,\n    e.g.::\n\n\n        stmt = select(users_table).order_by(users_table.c.name.asc())\n\n    :param column: A :class:`_expression.ColumnElement` (e.g.\n     scalar SQL expression)\n     with which to apply the :func:`.asc` operation.\n\n    .. seealso::\n\n        :func:`.desc`\n\n        :func:`.nulls_first`\n\n        :func:`.nulls_last`\n\n        :meth:`_expression.Select.order_by`\n\n    '
    return UnaryExpression._create_asc(column)

def collate(expression: _ColumnExpressionArgument[str], collation: str) -> BinaryExpression[str]:
    if False:
        for i in range(10):
            print('nop')
    "Return the clause ``expression COLLATE collation``.\n\n    e.g.::\n\n        collate(mycolumn, 'utf8_bin')\n\n    produces::\n\n        mycolumn COLLATE utf8_bin\n\n    The collation expression is also quoted if it is a case sensitive\n    identifier, e.g. contains uppercase characters.\n\n    .. versionchanged:: 1.2 quoting is automatically applied to COLLATE\n       expressions if they are case sensitive.\n\n    "
    return CollationClause._create_collation_expression(expression, collation)

def between(expr: _ColumnExpressionOrLiteralArgument[_T], lower_bound: Any, upper_bound: Any, symmetric: bool=False) -> BinaryExpression[bool]:
    if False:
        return 10
    'Produce a ``BETWEEN`` predicate clause.\n\n    E.g.::\n\n        from sqlalchemy import between\n        stmt = select(users_table).where(between(users_table.c.id, 5, 7))\n\n    Would produce SQL resembling::\n\n        SELECT id, name FROM user WHERE id BETWEEN :id_1 AND :id_2\n\n    The :func:`.between` function is a standalone version of the\n    :meth:`_expression.ColumnElement.between` method available on all\n    SQL expressions, as in::\n\n        stmt = select(users_table).where(users_table.c.id.between(5, 7))\n\n    All arguments passed to :func:`.between`, including the left side\n    column expression, are coerced from Python scalar values if a\n    the value is not a :class:`_expression.ColumnElement` subclass.\n    For example,\n    three fixed values can be compared as in::\n\n        print(between(5, 3, 7))\n\n    Which would produce::\n\n        :param_1 BETWEEN :param_2 AND :param_3\n\n    :param expr: a column expression, typically a\n     :class:`_expression.ColumnElement`\n     instance or alternatively a Python scalar expression to be coerced\n     into a column expression, serving as the left side of the ``BETWEEN``\n     expression.\n\n    :param lower_bound: a column or Python scalar expression serving as the\n     lower bound of the right side of the ``BETWEEN`` expression.\n\n    :param upper_bound: a column or Python scalar expression serving as the\n     upper bound of the right side of the ``BETWEEN`` expression.\n\n    :param symmetric: if True, will render " BETWEEN SYMMETRIC ". Note\n     that not all databases support this syntax.\n\n    .. seealso::\n\n        :meth:`_expression.ColumnElement.between`\n\n    '
    col_expr = coercions.expect(roles.ExpressionElementRole, expr)
    return col_expr.between(lower_bound, upper_bound, symmetric=symmetric)

def outparam(key: str, type_: Optional[TypeEngine[_T]]=None) -> BindParameter[_T]:
    if False:
        return 10
    'Create an \'OUT\' parameter for usage in functions (stored procedures),\n    for databases which support them.\n\n    The ``outparam`` can be used like a regular function parameter.\n    The "output" value will be available from the\n    :class:`~sqlalchemy.engine.CursorResult` object via its ``out_parameters``\n    attribute, which returns a dictionary containing the values.\n\n    '
    return BindParameter(key, None, type_=type_, unique=False, isoutparam=True)

@overload
def not_(clause: BinaryExpression[_T]) -> BinaryExpression[_T]:
    if False:
        return 10
    ...

@overload
def not_(clause: _ColumnExpressionArgument[_T]) -> ColumnElement[_T]:
    if False:
        i = 10
        return i + 15
    ...

def not_(clause: _ColumnExpressionArgument[_T]) -> ColumnElement[_T]:
    if False:
        print('Hello World!')
    'Return a negation of the given clause, i.e. ``NOT(clause)``.\n\n    The ``~`` operator is also overloaded on all\n    :class:`_expression.ColumnElement` subclasses to produce the\n    same result.\n\n    '
    return coercions.expect(roles.ExpressionElementRole, clause).__invert__()

def bindparam(key: Optional[str], value: Any=_NoArg.NO_ARG, type_: Optional[_TypeEngineArgument[_T]]=None, unique: bool=False, required: Union[bool, Literal[_NoArg.NO_ARG]]=_NoArg.NO_ARG, quote: Optional[bool]=None, callable_: Optional[Callable[[], Any]]=None, expanding: bool=False, isoutparam: bool=False, literal_execute: bool=False) -> BindParameter[_T]:
    if False:
        return 10
    'Produce a "bound expression".\n\n    The return value is an instance of :class:`.BindParameter`; this\n    is a :class:`_expression.ColumnElement`\n    subclass which represents a so-called\n    "placeholder" value in a SQL expression, the value of which is\n    supplied at the point at which the statement in executed against a\n    database connection.\n\n    In SQLAlchemy, the :func:`.bindparam` construct has\n    the ability to carry along the actual value that will be ultimately\n    used at expression time.  In this way, it serves not just as\n    a "placeholder" for eventual population, but also as a means of\n    representing so-called "unsafe" values which should not be rendered\n    directly in a SQL statement, but rather should be passed along\n    to the :term:`DBAPI` as values which need to be correctly escaped\n    and potentially handled for type-safety.\n\n    When using :func:`.bindparam` explicitly, the use case is typically\n    one of traditional deferment of parameters; the :func:`.bindparam`\n    construct accepts a name which can then be referred to at execution\n    time::\n\n        from sqlalchemy import bindparam\n\n        stmt = select(users_table).\\\n                    where(users_table.c.name == bindparam(\'username\'))\n\n    The above statement, when rendered, will produce SQL similar to::\n\n        SELECT id, name FROM user WHERE name = :username\n\n    In order to populate the value of ``:username`` above, the value\n    would typically be applied at execution time to a method\n    like :meth:`_engine.Connection.execute`::\n\n        result = connection.execute(stmt, username=\'wendy\')\n\n    Explicit use of :func:`.bindparam` is also common when producing\n    UPDATE or DELETE statements that are to be invoked multiple times,\n    where the WHERE criterion of the statement is to change on each\n    invocation, such as::\n\n        stmt = (users_table.update().\n                where(user_table.c.name == bindparam(\'username\')).\n                values(fullname=bindparam(\'fullname\'))\n                )\n\n        connection.execute(\n            stmt, [{"username": "wendy", "fullname": "Wendy Smith"},\n                   {"username": "jack", "fullname": "Jack Jones"},\n                   ]\n        )\n\n    SQLAlchemy\'s Core expression system makes wide use of\n    :func:`.bindparam` in an implicit sense.   It is typical that Python\n    literal values passed to virtually all SQL expression functions are\n    coerced into fixed :func:`.bindparam` constructs.  For example, given\n    a comparison operation such as::\n\n        expr = users_table.c.name == \'Wendy\'\n\n    The above expression will produce a :class:`.BinaryExpression`\n    construct, where the left side is the :class:`_schema.Column` object\n    representing the ``name`` column, and the right side is a\n    :class:`.BindParameter` representing the literal value::\n\n        print(repr(expr.right))\n        BindParameter(\'%(4327771088 name)s\', \'Wendy\', type_=String())\n\n    The expression above will render SQL such as::\n\n        user.name = :name_1\n\n    Where the ``:name_1`` parameter name is an anonymous name.  The\n    actual string ``Wendy`` is not in the rendered string, but is carried\n    along where it is later used within statement execution.  If we\n    invoke a statement like the following::\n\n        stmt = select(users_table).where(users_table.c.name == \'Wendy\')\n        result = connection.execute(stmt)\n\n    We would see SQL logging output as::\n\n        SELECT "user".id, "user".name\n        FROM "user"\n        WHERE "user".name = %(name_1)s\n        {\'name_1\': \'Wendy\'}\n\n    Above, we see that ``Wendy`` is passed as a parameter to the database,\n    while the placeholder ``:name_1`` is rendered in the appropriate form\n    for the target database, in this case the PostgreSQL database.\n\n    Similarly, :func:`.bindparam` is invoked automatically when working\n    with :term:`CRUD` statements as far as the "VALUES" portion is\n    concerned.   The :func:`_expression.insert` construct produces an\n    ``INSERT`` expression which will, at statement execution time, generate\n    bound placeholders based on the arguments passed, as in::\n\n        stmt = users_table.insert()\n        result = connection.execute(stmt, name=\'Wendy\')\n\n    The above will produce SQL output as::\n\n        INSERT INTO "user" (name) VALUES (%(name)s)\n        {\'name\': \'Wendy\'}\n\n    The :class:`_expression.Insert` construct, at\n    compilation/execution time, rendered a single :func:`.bindparam`\n    mirroring the column name ``name`` as a result of the single ``name``\n    parameter we passed to the :meth:`_engine.Connection.execute` method.\n\n    :param key:\n      the key (e.g. the name) for this bind param.\n      Will be used in the generated\n      SQL statement for dialects that use named parameters.  This\n      value may be modified when part of a compilation operation,\n      if other :class:`BindParameter` objects exist with the same\n      key, or if its length is too long and truncation is\n      required.\n\n      If omitted, an "anonymous" name is generated for the bound parameter;\n      when given a value to bind, the end result is equivalent to calling upon\n      the :func:`.literal` function with a value to bind, particularly\n      if the :paramref:`.bindparam.unique` parameter is also provided.\n\n    :param value:\n      Initial value for this bind param.  Will be used at statement\n      execution time as the value for this parameter passed to the\n      DBAPI, if no other value is indicated to the statement execution\n      method for this particular parameter name.  Defaults to ``None``.\n\n    :param callable\\_:\n      A callable function that takes the place of "value".  The function\n      will be called at statement execution time to determine the\n      ultimate value.   Used for scenarios where the actual bind\n      value cannot be determined at the point at which the clause\n      construct is created, but embedded bind values are still desirable.\n\n    :param type\\_:\n      A :class:`.TypeEngine` class or instance representing an optional\n      datatype for this :func:`.bindparam`.  If not passed, a type\n      may be determined automatically for the bind, based on the given\n      value; for example, trivial Python types such as ``str``,\n      ``int``, ``bool``\n      may result in the :class:`.String`, :class:`.Integer` or\n      :class:`.Boolean` types being automatically selected.\n\n      The type of a :func:`.bindparam` is significant especially in that\n      the type will apply pre-processing to the value before it is\n      passed to the database.  For example, a :func:`.bindparam` which\n      refers to a datetime value, and is specified as holding the\n      :class:`.DateTime` type, may apply conversion needed to the\n      value (such as stringification on SQLite) before passing the value\n      to the database.\n\n    :param unique:\n      if True, the key name of this :class:`.BindParameter` will be\n      modified if another :class:`.BindParameter` of the same name\n      already has been located within the containing\n      expression.  This flag is used generally by the internals\n      when producing so-called "anonymous" bound expressions, it\n      isn\'t generally applicable to explicitly-named :func:`.bindparam`\n      constructs.\n\n    :param required:\n      If ``True``, a value is required at execution time.  If not passed,\n      it defaults to ``True`` if neither :paramref:`.bindparam.value`\n      or :paramref:`.bindparam.callable` were passed.  If either of these\n      parameters are present, then :paramref:`.bindparam.required`\n      defaults to ``False``.\n\n    :param quote:\n      True if this parameter name requires quoting and is not\n      currently known as a SQLAlchemy reserved word; this currently\n      only applies to the Oracle backend, where bound names must\n      sometimes be quoted.\n\n    :param isoutparam:\n      if True, the parameter should be treated like a stored procedure\n      "OUT" parameter.  This applies to backends such as Oracle which\n      support OUT parameters.\n\n    :param expanding:\n      if True, this parameter will be treated as an "expanding" parameter\n      at execution time; the parameter value is expected to be a sequence,\n      rather than a scalar value, and the string SQL statement will\n      be transformed on a per-execution basis to accommodate the sequence\n      with a variable number of parameter slots passed to the DBAPI.\n      This is to allow statement caching to be used in conjunction with\n      an IN clause.\n\n      .. seealso::\n\n        :meth:`.ColumnOperators.in_`\n\n        :ref:`baked_in` - with baked queries\n\n      .. note:: The "expanding" feature does not support "executemany"-\n         style parameter sets.\n\n      .. versionadded:: 1.2\n\n      .. versionchanged:: 1.3 the "expanding" bound parameter feature now\n         supports empty lists.\n\n    :param literal_execute:\n      if True, the bound parameter will be rendered in the compile phase\n      with a special "POSTCOMPILE" token, and the SQLAlchemy compiler will\n      render the final value of the parameter into the SQL statement at\n      statement execution time, omitting the value from the parameter\n      dictionary / list passed to DBAPI ``cursor.execute()``.  This\n      produces a similar effect as that of using the ``literal_binds``,\n      compilation flag,  however takes place as the statement is sent to\n      the DBAPI ``cursor.execute()`` method, rather than when the statement\n      is compiled.   The primary use of this\n      capability is for rendering LIMIT / OFFSET clauses for database\n      drivers that can\'t accommodate for bound parameters in these\n      contexts, while allowing SQL constructs to be cacheable at the\n      compilation level.\n\n      .. versionadded:: 1.4 Added "post compile" bound parameters\n\n        .. seealso::\n\n            :ref:`change_4808`.\n\n    .. seealso::\n\n        :ref:`tutorial_sending_parameters` - in the\n        :ref:`unified_tutorial`\n\n\n    '
    return BindParameter(key, value, type_, unique, required, quote, callable_, expanding, isoutparam, literal_execute)

def case(*whens: Union[typing_Tuple[_ColumnExpressionArgument[bool], Any], Mapping[Any, Any]], value: Optional[Any]=None, else_: Optional[Any]=None) -> Case[Any]:
    if False:
        i = 10
        return i + 15
    'Produce a ``CASE`` expression.\n\n    The ``CASE`` construct in SQL is a conditional object that\n    acts somewhat analogously to an "if/then" construct in other\n    languages.  It returns an instance of :class:`.Case`.\n\n    :func:`.case` in its usual form is passed a series of "when"\n    constructs, that is, a list of conditions and results as tuples::\n\n        from sqlalchemy import case\n\n        stmt = select(users_table).\\\n                    where(\n                        case(\n                            (users_table.c.name == \'wendy\', \'W\'),\n                            (users_table.c.name == \'jack\', \'J\'),\n                            else_=\'E\'\n                        )\n                    )\n\n    The above statement will produce SQL resembling::\n\n        SELECT id, name FROM user\n        WHERE CASE\n            WHEN (name = :name_1) THEN :param_1\n            WHEN (name = :name_2) THEN :param_2\n            ELSE :param_3\n        END\n\n    When simple equality expressions of several values against a single\n    parent column are needed, :func:`.case` also has a "shorthand" format\n    used via the\n    :paramref:`.case.value` parameter, which is passed a column\n    expression to be compared.  In this form, the :paramref:`.case.whens`\n    parameter is passed as a dictionary containing expressions to be\n    compared against keyed to result expressions.  The statement below is\n    equivalent to the preceding statement::\n\n        stmt = select(users_table).\\\n                    where(\n                        case(\n                            {"wendy": "W", "jack": "J"},\n                            value=users_table.c.name,\n                            else_=\'E\'\n                        )\n                    )\n\n    The values which are accepted as result values in\n    :paramref:`.case.whens` as well as with :paramref:`.case.else_` are\n    coerced from Python literals into :func:`.bindparam` constructs.\n    SQL expressions, e.g. :class:`_expression.ColumnElement` constructs,\n    are accepted\n    as well.  To coerce a literal string expression into a constant\n    expression rendered inline, use the :func:`_expression.literal_column`\n    construct,\n    as in::\n\n        from sqlalchemy import case, literal_column\n\n        case(\n            (\n                orderline.c.qty > 100,\n                literal_column("\'greaterthan100\'")\n            ),\n            (\n                orderline.c.qty > 10,\n                literal_column("\'greaterthan10\'")\n            ),\n            else_=literal_column("\'lessthan10\'")\n        )\n\n    The above will render the given constants without using bound\n    parameters for the result values (but still for the comparison\n    values), as in::\n\n        CASE\n            WHEN (orderline.qty > :qty_1) THEN \'greaterthan100\'\n            WHEN (orderline.qty > :qty_2) THEN \'greaterthan10\'\n            ELSE \'lessthan10\'\n        END\n\n    :param \\*whens: The criteria to be compared against,\n     :paramref:`.case.whens` accepts two different forms, based on\n     whether or not :paramref:`.case.value` is used.\n\n     .. versionchanged:: 1.4 the :func:`_sql.case`\n        function now accepts the series of WHEN conditions positionally\n\n     In the first form, it accepts multiple 2-tuples passed as positional\n     arguments; each 2-tuple consists of ``(<sql expression>, <value>)``,\n     where the SQL expression is a boolean expression and "value" is a\n     resulting value, e.g.::\n\n        case(\n            (users_table.c.name == \'wendy\', \'W\'),\n            (users_table.c.name == \'jack\', \'J\')\n        )\n\n     In the second form, it accepts a Python dictionary of comparison\n     values mapped to a resulting value; this form requires\n     :paramref:`.case.value` to be present, and values will be compared\n     using the ``==`` operator, e.g.::\n\n        case(\n            {"wendy": "W", "jack": "J"},\n            value=users_table.c.name\n        )\n\n    :param value: An optional SQL expression which will be used as a\n      fixed "comparison point" for candidate values within a dictionary\n      passed to :paramref:`.case.whens`.\n\n    :param else\\_: An optional SQL expression which will be the evaluated\n      result of the ``CASE`` construct if all expressions within\n      :paramref:`.case.whens` evaluate to false.  When omitted, most\n      databases will produce a result of NULL if none of the "when"\n      expressions evaluate to true.\n\n\n    '
    return Case(*whens, value=value, else_=else_)

def cast(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) -> Cast[_T]:
    if False:
        while True:
            i = 10
    'Produce a ``CAST`` expression.\n\n    :func:`.cast` returns an instance of :class:`.Cast`.\n\n    E.g.::\n\n        from sqlalchemy import cast, Numeric\n\n        stmt = select(cast(product_table.c.unit_price, Numeric(10, 4)))\n\n    The above statement will produce SQL resembling::\n\n        SELECT CAST(unit_price AS NUMERIC(10, 4)) FROM product\n\n    The :func:`.cast` function performs two distinct functions when\n    used.  The first is that it renders the ``CAST`` expression within\n    the resulting SQL string.  The second is that it associates the given\n    type (e.g. :class:`.TypeEngine` class or instance) with the column\n    expression on the Python side, which means the expression will take\n    on the expression operator behavior associated with that type,\n    as well as the bound-value handling and result-row-handling behavior\n    of the type.\n\n    An alternative to :func:`.cast` is the :func:`.type_coerce` function.\n    This function performs the second task of associating an expression\n    with a specific type, but does not render the ``CAST`` expression\n    in SQL.\n\n    :param expression: A SQL expression, such as a\n     :class:`_expression.ColumnElement`\n     expression or a Python string which will be coerced into a bound\n     literal value.\n\n    :param type\\_: A :class:`.TypeEngine` class or instance indicating\n     the type to which the ``CAST`` should apply.\n\n    .. seealso::\n\n        :ref:`tutorial_casts`\n\n        :func:`.try_cast` - an alternative to CAST that results in\n        NULLs when the cast fails, instead of raising an error.\n        Only supported by some dialects.\n\n        :func:`.type_coerce` - an alternative to CAST that coerces the type\n        on the Python side only, which is often sufficient to generate the\n        correct SQL and data coercion.\n\n\n    '
    return Cast(expression, type_)

def try_cast(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) -> TryCast[_T]:
    if False:
        for i in range(10):
            print('nop')
    'Produce a ``TRY_CAST`` expression for backends which support it;\n    this is a ``CAST`` which returns NULL for un-castable conversions.\n\n    In SQLAlchemy, this construct is supported **only** by the SQL Server\n    dialect, and will raise a :class:`.CompileError` if used on other\n    included backends.  However, third party backends may also support\n    this construct.\n\n    .. tip:: As :func:`_sql.try_cast` originates from the SQL Server dialect,\n       it\'s importable both from ``sqlalchemy.`` as well as from\n       ``sqlalchemy.dialects.mssql``.\n\n    :func:`_sql.try_cast` returns an instance of :class:`.TryCast` and\n    generally behaves similarly to the :class:`.Cast` construct;\n    at the SQL level, the difference between ``CAST`` and ``TRY_CAST``\n    is that ``TRY_CAST`` returns NULL for an un-castable expression,\n    such as attempting to cast a string ``"hi"`` to an integer value.\n\n    E.g.::\n\n        from sqlalchemy import select, try_cast, Numeric\n\n        stmt = select(\n            try_cast(product_table.c.unit_price, Numeric(10, 4))\n        )\n\n    The above would render on Microsoft SQL Server as::\n\n        SELECT TRY_CAST (product_table.unit_price AS NUMERIC(10, 4))\n        FROM product_table\n\n    .. versionadded:: 2.0.14  :func:`.try_cast` has been\n       generalized from the SQL Server dialect into a general use\n       construct that may be supported by additional dialects.\n\n    '
    return TryCast(expression, type_)

def column(text: str, type_: Optional[_TypeEngineArgument[_T]]=None, is_literal: bool=False, _selectable: Optional[FromClause]=None) -> ColumnClause[_T]:
    if False:
        i = 10
        return i + 15
    'Produce a :class:`.ColumnClause` object.\n\n    The :class:`.ColumnClause` is a lightweight analogue to the\n    :class:`_schema.Column` class.  The :func:`_expression.column`\n    function can\n    be invoked with just a name alone, as in::\n\n        from sqlalchemy import column\n\n        id, name = column("id"), column("name")\n        stmt = select(id, name).select_from("user")\n\n    The above statement would produce SQL like::\n\n        SELECT id, name FROM user\n\n    Once constructed, :func:`_expression.column`\n    may be used like any other SQL\n    expression element such as within :func:`_expression.select`\n    constructs::\n\n        from sqlalchemy.sql import column\n\n        id, name = column("id"), column("name")\n        stmt = select(id, name).select_from("user")\n\n    The text handled by :func:`_expression.column`\n    is assumed to be handled\n    like the name of a database column; if the string contains mixed case,\n    special characters, or matches a known reserved word on the target\n    backend, the column expression will render using the quoting\n    behavior determined by the backend.  To produce a textual SQL\n    expression that is rendered exactly without any quoting,\n    use :func:`_expression.literal_column` instead,\n    or pass ``True`` as the\n    value of :paramref:`_expression.column.is_literal`.   Additionally,\n    full SQL\n    statements are best handled using the :func:`_expression.text`\n    construct.\n\n    :func:`_expression.column` can be used in a table-like\n    fashion by combining it with the :func:`.table` function\n    (which is the lightweight analogue to :class:`_schema.Table`\n    ) to produce\n    a working table construct with minimal boilerplate::\n\n        from sqlalchemy import table, column, select\n\n        user = table("user",\n                column("id"),\n                column("name"),\n                column("description"),\n        )\n\n        stmt = select(user.c.description).where(user.c.name == \'wendy\')\n\n    A :func:`_expression.column` / :func:`.table`\n    construct like that illustrated\n    above can be created in an\n    ad-hoc fashion and is not associated with any\n    :class:`_schema.MetaData`, DDL, or events, unlike its\n    :class:`_schema.Table` counterpart.\n\n    :param text: the text of the element.\n\n    :param type: :class:`_types.TypeEngine` object which can associate\n      this :class:`.ColumnClause` with a type.\n\n    :param is_literal: if True, the :class:`.ColumnClause` is assumed to\n      be an exact expression that will be delivered to the output with no\n      quoting rules applied regardless of case sensitive settings. the\n      :func:`_expression.literal_column()` function essentially invokes\n      :func:`_expression.column` while passing ``is_literal=True``.\n\n    .. seealso::\n\n        :class:`_schema.Column`\n\n        :func:`_expression.literal_column`\n\n        :func:`.table`\n\n        :func:`_expression.text`\n\n        :ref:`tutorial_select_arbitrary_text`\n\n    '
    return ColumnClause(text, type_, is_literal, _selectable)

def desc(column: _ColumnExpressionOrStrLabelArgument[_T]) -> UnaryExpression[_T]:
    if False:
        i = 10
        return i + 15
    'Produce a descending ``ORDER BY`` clause element.\n\n    e.g.::\n\n        from sqlalchemy import desc\n\n        stmt = select(users_table).order_by(desc(users_table.c.name))\n\n    will produce SQL as::\n\n        SELECT id, name FROM user ORDER BY name DESC\n\n    The :func:`.desc` function is a standalone version of the\n    :meth:`_expression.ColumnElement.desc`\n    method available on all SQL expressions,\n    e.g.::\n\n\n        stmt = select(users_table).order_by(users_table.c.name.desc())\n\n    :param column: A :class:`_expression.ColumnElement` (e.g.\n     scalar SQL expression)\n     with which to apply the :func:`.desc` operation.\n\n    .. seealso::\n\n        :func:`.asc`\n\n        :func:`.nulls_first`\n\n        :func:`.nulls_last`\n\n        :meth:`_expression.Select.order_by`\n\n    '
    return UnaryExpression._create_desc(column)

def distinct(expr: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]:
    if False:
        for i in range(10):
            print('nop')
    'Produce an column-expression-level unary ``DISTINCT`` clause.\n\n    This applies the ``DISTINCT`` keyword to an individual column\n    expression, and is typically contained within an aggregate function,\n    as in::\n\n        from sqlalchemy import distinct, func\n        stmt = select(func.count(distinct(users_table.c.name)))\n\n    The above would produce an expression resembling::\n\n        SELECT COUNT(DISTINCT name) FROM user\n\n    The :func:`.distinct` function is also available as a column-level\n    method, e.g. :meth:`_expression.ColumnElement.distinct`, as in::\n\n        stmt = select(func.count(users_table.c.name.distinct()))\n\n    The :func:`.distinct` operator is different from the\n    :meth:`_expression.Select.distinct` method of\n    :class:`_expression.Select`,\n    which produces a ``SELECT`` statement\n    with ``DISTINCT`` applied to the result set as a whole,\n    e.g. a ``SELECT DISTINCT`` expression.  See that method for further\n    information.\n\n    .. seealso::\n\n        :meth:`_expression.ColumnElement.distinct`\n\n        :meth:`_expression.Select.distinct`\n\n        :data:`.func`\n\n    '
    return UnaryExpression._create_distinct(expr)

def bitwise_not(expr: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]:
    if False:
        for i in range(10):
            print('nop')
    'Produce a unary bitwise NOT clause, typically via the ``~`` operator.\n\n    Not to be confused with boolean negation :func:`_sql.not_`.\n\n    .. versionadded:: 2.0.2\n\n    .. seealso::\n\n        :ref:`operators_bitwise`\n\n\n    '
    return UnaryExpression._create_bitwise_not(expr)

def extract(field: str, expr: _ColumnExpressionArgument[Any]) -> Extract:
    if False:
        print('Hello World!')
    'Return a :class:`.Extract` construct.\n\n    This is typically available as :func:`.extract`\n    as well as ``func.extract`` from the\n    :data:`.func` namespace.\n\n    :param field: The field to extract.\n\n    :param expr: A column or Python scalar expression serving as the\n      right side of the ``EXTRACT`` expression.\n\n    E.g.::\n\n        from sqlalchemy import extract\n        from sqlalchemy import table, column\n\n        logged_table = table("user",\n                column("id"),\n                column("date_created"),\n        )\n\n        stmt = select(logged_table.c.id).where(\n            extract("YEAR", logged_table.c.date_created) == 2021\n        )\n\n    In the above example, the statement is used to select ids from the\n    database where the ``YEAR`` component matches a specific value.\n\n    Similarly, one can also select an extracted component::\n\n        stmt = select(\n            extract("YEAR", logged_table.c.date_created)\n        ).where(logged_table.c.id == 1)\n\n    The implementation of ``EXTRACT`` may vary across database backends.\n    Users are reminded to consult their database documentation.\n    '
    return Extract(field, expr)

def false() -> False_:
    if False:
        return 10
    'Return a :class:`.False_` construct.\n\n    E.g.:\n\n    .. sourcecode:: pycon+sql\n\n        >>> from sqlalchemy import false\n        >>> print(select(t.c.x).where(false()))\n        {printsql}SELECT x FROM t WHERE false\n\n    A backend which does not support true/false constants will render as\n    an expression against 1 or 0:\n\n    .. sourcecode:: pycon+sql\n\n        >>> print(select(t.c.x).where(false()))\n        {printsql}SELECT x FROM t WHERE 0 = 1\n\n    The :func:`.true` and :func:`.false` constants also feature\n    "short circuit" operation within an :func:`.and_` or :func:`.or_`\n    conjunction:\n\n    .. sourcecode:: pycon+sql\n\n        >>> print(select(t.c.x).where(or_(t.c.x > 5, true())))\n        {printsql}SELECT x FROM t WHERE true{stop}\n\n        >>> print(select(t.c.x).where(and_(t.c.x > 5, false())))\n        {printsql}SELECT x FROM t WHERE false{stop}\n\n    .. seealso::\n\n        :func:`.true`\n\n    '
    return False_._instance()

def funcfilter(func: FunctionElement[_T], *criterion: _ColumnExpressionArgument[bool]) -> FunctionFilter[_T]:
    if False:
        return 10
    'Produce a :class:`.FunctionFilter` object against a function.\n\n    Used against aggregate and window functions,\n    for database backends that support the "FILTER" clause.\n\n    E.g.::\n\n        from sqlalchemy import funcfilter\n        funcfilter(func.count(1), MyClass.name == \'some name\')\n\n    Would produce "COUNT(1) FILTER (WHERE myclass.name = \'some name\')".\n\n    This function is also available from the :data:`~.expression.func`\n    construct itself via the :meth:`.FunctionElement.filter` method.\n\n    .. seealso::\n\n        :ref:`tutorial_functions_within_group` - in the\n        :ref:`unified_tutorial`\n\n        :meth:`.FunctionElement.filter`\n\n    '
    return FunctionFilter(func, *criterion)

def label(name: str, element: _ColumnExpressionArgument[_T], type_: Optional[_TypeEngineArgument[_T]]=None) -> Label[_T]:
    if False:
        while True:
            i = 10
    'Return a :class:`Label` object for the\n    given :class:`_expression.ColumnElement`.\n\n    A label changes the name of an element in the columns clause of a\n    ``SELECT`` statement, typically via the ``AS`` SQL keyword.\n\n    This functionality is more conveniently available via the\n    :meth:`_expression.ColumnElement.label` method on\n    :class:`_expression.ColumnElement`.\n\n    :param name: label name\n\n    :param obj: a :class:`_expression.ColumnElement`.\n\n    '
    return Label(name, element, type_)

def null() -> Null:
    if False:
        return 10
    'Return a constant :class:`.Null` construct.'
    return Null._instance()

def nulls_first(column: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]:
    if False:
        print('Hello World!')
    'Produce the ``NULLS FIRST`` modifier for an ``ORDER BY`` expression.\n\n    :func:`.nulls_first` is intended to modify the expression produced\n    by :func:`.asc` or :func:`.desc`, and indicates how NULL values\n    should be handled when they are encountered during ordering::\n\n\n        from sqlalchemy import desc, nulls_first\n\n        stmt = select(users_table).order_by(\n            nulls_first(desc(users_table.c.name)))\n\n    The SQL expression from the above would resemble::\n\n        SELECT id, name FROM user ORDER BY name DESC NULLS FIRST\n\n    Like :func:`.asc` and :func:`.desc`, :func:`.nulls_first` is typically\n    invoked from the column expression itself using\n    :meth:`_expression.ColumnElement.nulls_first`,\n    rather than as its standalone\n    function version, as in::\n\n        stmt = select(users_table).order_by(\n            users_table.c.name.desc().nulls_first())\n\n    .. versionchanged:: 1.4 :func:`.nulls_first` is renamed from\n        :func:`.nullsfirst` in previous releases.\n        The previous name remains available for backwards compatibility.\n\n    .. seealso::\n\n        :func:`.asc`\n\n        :func:`.desc`\n\n        :func:`.nulls_last`\n\n        :meth:`_expression.Select.order_by`\n\n    '
    return UnaryExpression._create_nulls_first(column)

def nulls_last(column: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]:
    if False:
        while True:
            i = 10
    'Produce the ``NULLS LAST`` modifier for an ``ORDER BY`` expression.\n\n    :func:`.nulls_last` is intended to modify the expression produced\n    by :func:`.asc` or :func:`.desc`, and indicates how NULL values\n    should be handled when they are encountered during ordering::\n\n\n        from sqlalchemy import desc, nulls_last\n\n        stmt = select(users_table).order_by(\n            nulls_last(desc(users_table.c.name)))\n\n    The SQL expression from the above would resemble::\n\n        SELECT id, name FROM user ORDER BY name DESC NULLS LAST\n\n    Like :func:`.asc` and :func:`.desc`, :func:`.nulls_last` is typically\n    invoked from the column expression itself using\n    :meth:`_expression.ColumnElement.nulls_last`,\n    rather than as its standalone\n    function version, as in::\n\n        stmt = select(users_table).order_by(\n            users_table.c.name.desc().nulls_last())\n\n    .. versionchanged:: 1.4 :func:`.nulls_last` is renamed from\n        :func:`.nullslast` in previous releases.\n        The previous name remains available for backwards compatibility.\n\n    .. seealso::\n\n        :func:`.asc`\n\n        :func:`.desc`\n\n        :func:`.nulls_first`\n\n        :meth:`_expression.Select.order_by`\n\n    '
    return UnaryExpression._create_nulls_last(column)

def or_(initial_clause: Union[Literal[False], _ColumnExpressionArgument[bool]], *clauses: _ColumnExpressionArgument[bool]) -> ColumnElement[bool]:
    if False:
        i = 10
        return i + 15
    'Produce a conjunction of expressions joined by ``OR``.\n\n    E.g.::\n\n        from sqlalchemy import or_\n\n        stmt = select(users_table).where(\n                        or_(\n                            users_table.c.name == \'wendy\',\n                            users_table.c.name == \'jack\'\n                        )\n                    )\n\n    The :func:`.or_` conjunction is also available using the\n    Python ``|`` operator (though note that compound expressions\n    need to be parenthesized in order to function with Python\n    operator precedence behavior)::\n\n        stmt = select(users_table).where(\n                        (users_table.c.name == \'wendy\') |\n                        (users_table.c.name == \'jack\')\n                    )\n\n    The :func:`.or_` construct must be given at least one positional\n    argument in order to be valid; a :func:`.or_` construct with no\n    arguments is ambiguous.   To produce an "empty" or dynamically\n    generated :func:`.or_`  expression, from a given list of expressions,\n    a "default" element of :func:`_sql.false` (or just ``False``) should be\n    specified::\n\n        from sqlalchemy import false\n        or_criteria = or_(false(), *expressions)\n\n    The above expression will compile to SQL as the expression ``false``\n    or ``0 = 1``, depending on backend, if no other expressions are\n    present.  If expressions are present, then the :func:`_sql.false` value is\n    ignored as it does not affect the outcome of an OR expression which\n    has other elements.\n\n    .. deprecated:: 1.4  The :func:`.or_` element now requires that at\n       least one argument is passed; creating the :func:`.or_` construct\n       with no arguments is deprecated, and will emit a deprecation warning\n       while continuing to produce a blank SQL string.\n\n    .. seealso::\n\n        :func:`.and_`\n\n    '
    ...
if not TYPE_CHECKING:

    def or_(*clauses):
        if False:
            for i in range(10):
                print('nop')
        'Produce a conjunction of expressions joined by ``OR``.\n\n        E.g.::\n\n            from sqlalchemy import or_\n\n            stmt = select(users_table).where(\n                            or_(\n                                users_table.c.name == \'wendy\',\n                                users_table.c.name == \'jack\'\n                            )\n                        )\n\n        The :func:`.or_` conjunction is also available using the\n        Python ``|`` operator (though note that compound expressions\n        need to be parenthesized in order to function with Python\n        operator precedence behavior)::\n\n            stmt = select(users_table).where(\n                            (users_table.c.name == \'wendy\') |\n                            (users_table.c.name == \'jack\')\n                        )\n\n        The :func:`.or_` construct must be given at least one positional\n        argument in order to be valid; a :func:`.or_` construct with no\n        arguments is ambiguous.   To produce an "empty" or dynamically\n        generated :func:`.or_`  expression, from a given list of expressions,\n        a "default" element of :func:`_sql.false` (or just ``False``) should be\n        specified::\n\n            from sqlalchemy import false\n            or_criteria = or_(false(), *expressions)\n\n        The above expression will compile to SQL as the expression ``false``\n        or ``0 = 1``, depending on backend, if no other expressions are\n        present.  If expressions are present, then the :func:`_sql.false` value\n        is ignored as it does not affect the outcome of an OR expression which\n        has other elements.\n\n        .. deprecated:: 1.4  The :func:`.or_` element now requires that at\n           least one argument is passed; creating the :func:`.or_` construct\n           with no arguments is deprecated, and will emit a deprecation warning\n           while continuing to produce a blank SQL string.\n\n        .. seealso::\n\n            :func:`.and_`\n\n        '
        return BooleanClauseList.or_(*clauses)

def over(element: FunctionElement[_T], partition_by: Optional[Union[Iterable[_ColumnExpressionArgument[Any]], _ColumnExpressionArgument[Any]]]=None, order_by: Optional[Union[Iterable[_ColumnExpressionArgument[Any]], _ColumnExpressionArgument[Any]]]=None, range_: Optional[typing_Tuple[Optional[int], Optional[int]]]=None, rows: Optional[typing_Tuple[Optional[int], Optional[int]]]=None) -> Over[_T]:
    if False:
        i = 10
        return i + 15
    'Produce an :class:`.Over` object against a function.\n\n    Used against aggregate or so-called "window" functions,\n    for database backends that support window functions.\n\n    :func:`_expression.over` is usually called using\n    the :meth:`.FunctionElement.over` method, e.g.::\n\n        func.row_number().over(order_by=mytable.c.some_column)\n\n    Would produce::\n\n        ROW_NUMBER() OVER(ORDER BY some_column)\n\n    Ranges are also possible using the :paramref:`.expression.over.range_`\n    and :paramref:`.expression.over.rows` parameters.  These\n    mutually-exclusive parameters each accept a 2-tuple, which contains\n    a combination of integers and None::\n\n        func.row_number().over(\n            order_by=my_table.c.some_column, range_=(None, 0))\n\n    The above would produce::\n\n        ROW_NUMBER() OVER(ORDER BY some_column\n        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n\n    A value of ``None`` indicates "unbounded", a\n    value of zero indicates "current row", and negative / positive\n    integers indicate "preceding" and "following":\n\n    * RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING::\n\n        func.row_number().over(order_by=\'x\', range_=(-5, 10))\n\n    * ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW::\n\n        func.row_number().over(order_by=\'x\', rows=(None, 0))\n\n    * RANGE BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING::\n\n        func.row_number().over(order_by=\'x\', range_=(-2, None))\n\n    * RANGE BETWEEN 1 FOLLOWING AND 3 FOLLOWING::\n\n        func.row_number().over(order_by=\'x\', range_=(1, 3))\n\n    :param element: a :class:`.FunctionElement`, :class:`.WithinGroup`,\n     or other compatible construct.\n    :param partition_by: a column element or string, or a list\n     of such, that will be used as the PARTITION BY clause\n     of the OVER construct.\n    :param order_by: a column element or string, or a list\n     of such, that will be used as the ORDER BY clause\n     of the OVER construct.\n    :param range\\_: optional range clause for the window.  This is a\n     tuple value which can contain integer values or ``None``,\n     and will render a RANGE BETWEEN PRECEDING / FOLLOWING clause.\n\n    :param rows: optional rows clause for the window.  This is a tuple\n     value which can contain integer values or None, and will render\n     a ROWS BETWEEN PRECEDING / FOLLOWING clause.\n\n    This function is also available from the :data:`~.expression.func`\n    construct itself via the :meth:`.FunctionElement.over` method.\n\n    .. seealso::\n\n        :ref:`tutorial_window_functions` - in the :ref:`unified_tutorial`\n\n        :data:`.expression.func`\n\n        :func:`_expression.within_group`\n\n    '
    return Over(element, partition_by, order_by, range_, rows)

@_document_text_coercion('text', ':func:`.text`', ':paramref:`.text.text`')
def text(text: str) -> TextClause:
    if False:
        return 10
    'Construct a new :class:`_expression.TextClause` clause,\n    representing\n    a textual SQL string directly.\n\n    E.g.::\n\n        from sqlalchemy import text\n\n        t = text("SELECT * FROM users")\n        result = connection.execute(t)\n\n    The advantages :func:`_expression.text`\n    provides over a plain string are\n    backend-neutral support for bind parameters, per-statement\n    execution options, as well as\n    bind parameter and result-column typing behavior, allowing\n    SQLAlchemy type constructs to play a role when executing\n    a statement that is specified literally.  The construct can also\n    be provided with a ``.c`` collection of column elements, allowing\n    it to be embedded in other SQL expression constructs as a subquery.\n\n    Bind parameters are specified by name, using the format ``:name``.\n    E.g.::\n\n        t = text("SELECT * FROM users WHERE id=:user_id")\n        result = connection.execute(t, user_id=12)\n\n    For SQL statements where a colon is required verbatim, as within\n    an inline string, use a backslash to escape::\n\n        t = text(r"SELECT * FROM users WHERE name=\'\\:username\'")\n\n    The :class:`_expression.TextClause`\n    construct includes methods which can\n    provide information about the bound parameters as well as the column\n    values which would be returned from the textual statement, assuming\n    it\'s an executable SELECT type of statement.  The\n    :meth:`_expression.TextClause.bindparams`\n    method is used to provide bound\n    parameter detail, and :meth:`_expression.TextClause.columns`\n    method allows\n    specification of return columns including names and types::\n\n        t = text("SELECT * FROM users WHERE id=:user_id").\\\n                bindparams(user_id=7).\\\n                columns(id=Integer, name=String)\n\n        for id, name in connection.execute(t):\n            print(id, name)\n\n    The :func:`_expression.text` construct is used in cases when\n    a literal string SQL fragment is specified as part of a larger query,\n    such as for the WHERE clause of a SELECT statement::\n\n        s = select(users.c.id, users.c.name).where(text("id=:user_id"))\n        result = connection.execute(s, user_id=12)\n\n    :func:`_expression.text` is also used for the construction\n    of a full, standalone statement using plain text.\n    As such, SQLAlchemy refers\n    to it as an :class:`.Executable` object and may be used\n    like any other statement passed to an ``.execute()`` method.\n\n    :param text:\n      the text of the SQL statement to be created.  Use ``:<param>``\n      to specify bind parameters; they will be compiled to their\n      engine-specific format.\n\n    .. seealso::\n\n        :ref:`tutorial_select_arbitrary_text`\n\n    '
    return TextClause(text)

def true() -> True_:
    if False:
        for i in range(10):
            print('nop')
    'Return a constant :class:`.True_` construct.\n\n    E.g.:\n\n    .. sourcecode:: pycon+sql\n\n        >>> from sqlalchemy import true\n        >>> print(select(t.c.x).where(true()))\n        {printsql}SELECT x FROM t WHERE true\n\n    A backend which does not support true/false constants will render as\n    an expression against 1 or 0:\n\n    .. sourcecode:: pycon+sql\n\n        >>> print(select(t.c.x).where(true()))\n        {printsql}SELECT x FROM t WHERE 1 = 1\n\n    The :func:`.true` and :func:`.false` constants also feature\n    "short circuit" operation within an :func:`.and_` or :func:`.or_`\n    conjunction:\n\n    .. sourcecode:: pycon+sql\n\n        >>> print(select(t.c.x).where(or_(t.c.x > 5, true())))\n        {printsql}SELECT x FROM t WHERE true{stop}\n\n        >>> print(select(t.c.x).where(and_(t.c.x > 5, false())))\n        {printsql}SELECT x FROM t WHERE false{stop}\n\n    .. seealso::\n\n        :func:`.false`\n\n    '
    return True_._instance()

def tuple_(*clauses: _ColumnExpressionArgument[Any], types: Optional[Sequence[_TypeEngineArgument[Any]]]=None) -> Tuple:
    if False:
        for i in range(10):
            print('nop')
    'Return a :class:`.Tuple`.\n\n    Main usage is to produce a composite IN construct using\n    :meth:`.ColumnOperators.in_` ::\n\n        from sqlalchemy import tuple_\n\n        tuple_(table.c.col1, table.c.col2).in_(\n            [(1, 2), (5, 12), (10, 19)]\n        )\n\n    .. versionchanged:: 1.3.6 Added support for SQLite IN tuples.\n\n    .. warning::\n\n        The composite IN construct is not supported by all backends, and is\n        currently known to work on PostgreSQL, MySQL, and SQLite.\n        Unsupported backends will raise a subclass of\n        :class:`~sqlalchemy.exc.DBAPIError` when such an expression is\n        invoked.\n\n    '
    return Tuple(*clauses, types=types)

def type_coerce(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) -> TypeCoerce[_T]:
    if False:
        return 10
    'Associate a SQL expression with a particular type, without rendering\n    ``CAST``.\n\n    E.g.::\n\n        from sqlalchemy import type_coerce\n\n        stmt = select(type_coerce(log_table.date_string, StringDateTime()))\n\n    The above construct will produce a :class:`.TypeCoerce` object, which\n    does not modify the rendering in any way on the SQL side, with the\n    possible exception of a generated label if used in a columns clause\n    context:\n\n    .. sourcecode:: sql\n\n        SELECT date_string AS date_string FROM log\n\n    When result rows are fetched, the ``StringDateTime`` type processor\n    will be applied to result rows on behalf of the ``date_string`` column.\n\n    .. note:: the :func:`.type_coerce` construct does not render any\n       SQL syntax of its own, including that it does not imply\n       parenthesization.   Please use :meth:`.TypeCoerce.self_group`\n       if explicit parenthesization is required.\n\n    In order to provide a named label for the expression, use\n    :meth:`_expression.ColumnElement.label`::\n\n        stmt = select(\n            type_coerce(log_table.date_string, StringDateTime()).label(\'date\')\n        )\n\n\n    A type that features bound-value handling will also have that behavior\n    take effect when literal values or :func:`.bindparam` constructs are\n    passed to :func:`.type_coerce` as targets.\n    For example, if a type implements the\n    :meth:`.TypeEngine.bind_expression`\n    method or :meth:`.TypeEngine.bind_processor` method or equivalent,\n    these functions will take effect at statement compilation/execution\n    time when a literal value is passed, as in::\n\n        # bound-value handling of MyStringType will be applied to the\n        # literal value "some string"\n        stmt = select(type_coerce("some string", MyStringType))\n\n    When using :func:`.type_coerce` with composed expressions, note that\n    **parenthesis are not applied**.   If :func:`.type_coerce` is being\n    used in an operator context where the parenthesis normally present from\n    CAST are necessary, use the :meth:`.TypeCoerce.self_group` method:\n\n    .. sourcecode:: pycon+sql\n\n        >>> some_integer = column("someint", Integer)\n        >>> some_string = column("somestr", String)\n        >>> expr = type_coerce(some_integer + 5, String) + some_string\n        >>> print(expr)\n        {printsql}someint + :someint_1 || somestr{stop}\n        >>> expr = type_coerce(some_integer + 5, String).self_group() + some_string\n        >>> print(expr)\n        {printsql}(someint + :someint_1) || somestr{stop}\n\n    :param expression: A SQL expression, such as a\n     :class:`_expression.ColumnElement`\n     expression or a Python string which will be coerced into a bound\n     literal value.\n\n    :param type\\_: A :class:`.TypeEngine` class or instance indicating\n     the type to which the expression is coerced.\n\n    .. seealso::\n\n        :ref:`tutorial_casts`\n\n        :func:`.cast`\n\n    '
    return TypeCoerce(expression, type_)

def within_group(element: FunctionElement[_T], *order_by: _ColumnExpressionArgument[Any]) -> WithinGroup[_T]:
    if False:
        while True:
            i = 10
    'Produce a :class:`.WithinGroup` object against a function.\n\n    Used against so-called "ordered set aggregate" and "hypothetical\n    set aggregate" functions, including :class:`.percentile_cont`,\n    :class:`.rank`, :class:`.dense_rank`, etc.\n\n    :func:`_expression.within_group` is usually called using\n    the :meth:`.FunctionElement.within_group` method, e.g.::\n\n        from sqlalchemy import within_group\n        stmt = select(\n            department.c.id,\n            func.percentile_cont(0.5).within_group(\n                department.c.salary.desc()\n            )\n        )\n\n    The above statement would produce SQL similar to\n    ``SELECT department.id, percentile_cont(0.5)\n    WITHIN GROUP (ORDER BY department.salary DESC)``.\n\n    :param element: a :class:`.FunctionElement` construct, typically\n     generated by :data:`~.expression.func`.\n    :param \\*order_by: one or more column elements that will be used\n     as the ORDER BY clause of the WITHIN GROUP construct.\n\n    .. seealso::\n\n        :ref:`tutorial_functions_within_group` - in the\n        :ref:`unified_tutorial`\n\n        :data:`.expression.func`\n\n        :func:`_expression.over`\n\n    '
    return WithinGroup(element, *order_by)