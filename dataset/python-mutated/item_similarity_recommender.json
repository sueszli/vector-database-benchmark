[
    {
        "func_name": "create",
        "original": "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, nearest_items=None, similarity_type='jaccard', threshold=0.001, only_top_k=64, verbose=True, target_memory_usage=8 * 1024 * 1024 * 1024, **kwargs):\n    \"\"\"\n    Create a recommender that uses item-item similarities based on\n    users in common.\n\n    Parameters\n    ----------\n    observation_data : SFrame\n        The dataset to use for training the model. It must contain a column of\n        user ids and a column of item ids. Each row represents an observed\n        interaction between the user and the item.  The (user, item) pairs\n        are stored with the model so that they can later be excluded from\n        recommendations if desired. It can optionally contain a target ratings\n        column. All other columns are interpreted by the underlying model as\n        side features for the observations.\n\n        The user id and item id columns must be of type 'int' or 'str'. The\n        target column must be of type 'int' or 'float'.\n\n    user_id : string, optional\n        The name of the column in `observation_data` that corresponds to the\n        user id.\n\n    item_id : string, optional\n        The name of the column in `observation_data` that corresponds to the\n        item id.\n\n    target : string, optional\n        The `observation_data` can optionally contain a column of scores\n        representing ratings given by the users. If present, the name of this\n        column may be specified variables `target`.\n\n    user_data : SFrame, optional\n        Side information for the users.  This SFrame must have a column with\n        the same name as what is specified by the `user_id` input parameter.\n        `user_data` can provide any amount of additional user-specific\n        information. (NB: This argument is currently ignored by this model.)\n\n    item_data : SFrame, optional\n        Side information for the items.  This SFrame must have a column with\n        the same name as what is specified by the `item_id` input parameter.\n        `item_data` can provide any amount of additional item-specific\n        information. (NB: This argument is currently ignored by this model.)\n\n    similarity_type : {'jaccard', 'cosine', 'pearson'}, optional\n        Similarity metric to use. See ItemSimilarityRecommender for details.\n        Default: 'jaccard'.\n\n    threshold : float, optional\n        Predictions ignore items below this similarity value.\n        Default: 0.001.\n\n    only_top_k : int, optional\n        Number of similar items to store for each item. Default value is\n        64.  Decreasing this  decreases the amount of memory required for the\n        model, but may also decrease the accuracy.\n\n    nearest_items : SFrame, optional\n        A set of each item's nearest items. When provided, this overrides\n        the similarity computed above.\n        See Notes in the documentation for ItemSimilarityRecommender.\n        Default: None.\n\n    target_memory_usage : int, optional\n        The target memory usage for the processing buffers and lookup\n        tables.  The actual memory usage may be higher or lower than this,\n        but decreasing this decreases memory usage at the expense of\n        training time, and increasing this can dramatically speed up the\n        training time.  Default is 8GB = 8589934592.\n\n    seed_item_set_size : int, optional\n        For users that have not yet rated any items, or have only\n        rated uniquely occurring items with no similar item info,\n        the model seeds the user's item set with the average\n        ratings of the seed_item_set_size most popular items when\n        making predictions and recommendations.  If set to 0, then\n        recommendations based on either popularity (no target present)\n        or average item score (target present) are made in this case.\n\n    nearest_neighbors_interaction_proportion_threshold : (advanced) float\n        Any item that has was rated by more than this proportion of\n        users is  treated by doing a nearest neighbors search.  For\n        frequent items, this  is almost always faster, but it is slower\n        for infrequent items.  Furthermore, decreasing this causes more\n        items to be processed using the nearest neighbor path, which may\n        decrease memory requirements.\n\n    degree_approximation_threshold : (advanced) int, optional\n        Users with more than this many item interactions may be\n        approximated.  The approximation is done by a combination of\n        sampling and choosing the interactions likely to have the most\n        impact on the model.  Increasing this can increase the training time\n        and may or may not increase the quality of the model.  Default = 4096.\n\n    max_data_passes : (advanced) int, optional\n        The maximum number of passes through the data allowed in\n        building the similarity lookup tables.  If it is not possible to\n        build the recommender in this many passes (calculated before\n        that stage of training), then additional approximations are\n        applied; namely decreasing degree_approximation_threshold.  If\n        this is not possible, an error is raised.  To decrease the\n        number of passes required, increase target_memory_usage or\n        decrease nearest_neighbors_interaction_proportion_threshold.\n        Default = 1024.\n\n    Examples\n    --------\n    Given basic user-item observation data, an\n    :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender` is created:\n\n    >>> sf = turicreate.SFrame({'user_id': ['0', '0', '0', '1', '1', '2', '2', '2'],\n    ...                       'item_id': ['a', 'b', 'c', 'a', 'b', 'b', 'c', 'd']})\n    >>> m = turicreate.item_similarity_recommender.create(sf)\n    >>> recs = m.recommend()\n\n    When a target is available, one can specify the desired similarity. For\n    example we may choose to use a cosine similarity, and use it to make\n    predictions or recommendations.\n\n    >>> sf2 = turicreate.SFrame({'user_id': ['0', '0', '0', '1', '1', '2', '2', '2'],\n    ...                        'item_id': ['a', 'b', 'c', 'a', 'b', 'b', 'c', 'd'],\n    ...                        'rating': [1, 3, 2, 5, 4, 1, 4, 3]})\n    >>> m2 = turicreate.item_similarity_recommender.create(sf2, target=\"rating\",\n    ...                                                  similarity_type='cosine')\n    >>> m2.predict(sf)\n    >>> m2.recommend()\n\n    Notes\n    -----\n    Currently, :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender`\n    does not leverage the use of side features `user_data` and `item_data`.\n\n    **Incorporating pre-defined similar items**\n\n    For item similarity models, one may choose to provide user-specified\n    nearest neighbors graph using the keyword argument `nearest_items`. This is\n    an SFrame containing, for each item, the nearest items and the similarity\n    score between them. If provided, these item similarity scores are used for\n    recommendations. The SFrame must contain (at least) three columns:\n\n    * 'item_id': a column with the same name as that provided to the `item_id`\n      argument (which defaults to the string \"item_id\").\n    * 'similar': a column containing the nearest items for the given item id.\n      This should have the same type as the `item_id` column.\n    * 'score': a numeric score measuring how similar these two items are.\n\n    For example, suppose you first create an ItemSimilarityRecommender and use\n    :class:`~turicreate.recommender.ItemSimilarityRecommender.get_similar_items`:\n\n    >>> sf = turicreate.SFrame({'user_id': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\n    ...                       'item_id': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"]})\n    >>> m = turicreate.item_similarity_recommender.create(sf)\n    >>> nn = m.get_similar_items()\n    >>> m2 = turicreate.item_similarity_recommender.create(sf, nearest_items=nn)\n\n    With the above code, the item similarities computed for model `m` can be\n    used to create a new recommender object, `m2`. Note that we could have\n    created `nn` from some other means, but now use `m2` to make\n    recommendations via `m2.recommend()`.\n\n\n    See Also\n    --------\n    ItemSimilarityRecommender\n\n    \"\"\"\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.item_similarity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    if nearest_items is None:\n        nearest_items = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'similarity_type': similarity_type, 'threshold': threshold, 'target_memory_usage': float(target_memory_usage), 'max_item_neighborhood_size': only_top_k}\n    extra_data = {'nearest_items': nearest_items}\n    if kwargs:\n        try:\n            possible_args = set(_get_default_options()['name'])\n        except (RuntimeError, KeyError):\n            possible_args = set()\n        bad_arguments = set(kwargs.keys()).difference(possible_args)\n        if bad_arguments:\n            raise TypeError('Bad Keyword Arguments: ' + ', '.join(bad_arguments))\n        opts.update(kwargs)\n    extra_data = {'nearest_items': nearest_items}\n    opts.update(kwargs)\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return ItemSimilarityRecommender(model_proxy)",
        "mutated": [
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, nearest_items=None, similarity_type='jaccard', threshold=0.001, only_top_k=64, verbose=True, target_memory_usage=8 * 1024 * 1024 * 1024, **kwargs):\n    if False:\n        i = 10\n    '\\n    Create a recommender that uses item-item similarities based on\\n    users in common.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    similarity_type : {\\'jaccard\\', \\'cosine\\', \\'pearson\\'}, optional\\n        Similarity metric to use. See ItemSimilarityRecommender for details.\\n        Default: \\'jaccard\\'.\\n\\n    threshold : float, optional\\n        Predictions ignore items below this similarity value.\\n        Default: 0.001.\\n\\n    only_top_k : int, optional\\n        Number of similar items to store for each item. Default value is\\n        64.  Decreasing this  decreases the amount of memory required for the\\n        model, but may also decrease the accuracy.\\n\\n    nearest_items : SFrame, optional\\n        A set of each item\\'s nearest items. When provided, this overrides\\n        the similarity computed above.\\n        See Notes in the documentation for ItemSimilarityRecommender.\\n        Default: None.\\n\\n    target_memory_usage : int, optional\\n        The target memory usage for the processing buffers and lookup\\n        tables.  The actual memory usage may be higher or lower than this,\\n        but decreasing this decreases memory usage at the expense of\\n        training time, and increasing this can dramatically speed up the\\n        training time.  Default is 8GB = 8589934592.\\n\\n    seed_item_set_size : int, optional\\n        For users that have not yet rated any items, or have only\\n        rated uniquely occurring items with no similar item info,\\n        the model seeds the user\\'s item set with the average\\n        ratings of the seed_item_set_size most popular items when\\n        making predictions and recommendations.  If set to 0, then\\n        recommendations based on either popularity (no target present)\\n        or average item score (target present) are made in this case.\\n\\n    nearest_neighbors_interaction_proportion_threshold : (advanced) float\\n        Any item that has was rated by more than this proportion of\\n        users is  treated by doing a nearest neighbors search.  For\\n        frequent items, this  is almost always faster, but it is slower\\n        for infrequent items.  Furthermore, decreasing this causes more\\n        items to be processed using the nearest neighbor path, which may\\n        decrease memory requirements.\\n\\n    degree_approximation_threshold : (advanced) int, optional\\n        Users with more than this many item interactions may be\\n        approximated.  The approximation is done by a combination of\\n        sampling and choosing the interactions likely to have the most\\n        impact on the model.  Increasing this can increase the training time\\n        and may or may not increase the quality of the model.  Default = 4096.\\n\\n    max_data_passes : (advanced) int, optional\\n        The maximum number of passes through the data allowed in\\n        building the similarity lookup tables.  If it is not possible to\\n        build the recommender in this many passes (calculated before\\n        that stage of training), then additional approximations are\\n        applied; namely decreasing degree_approximation_threshold.  If\\n        this is not possible, an error is raised.  To decrease the\\n        number of passes required, increase target_memory_usage or\\n        decrease nearest_neighbors_interaction_proportion_threshold.\\n        Default = 1024.\\n\\n    Examples\\n    --------\\n    Given basic user-item observation data, an\\n    :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender` is created:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                       \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\']})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> recs = m.recommend()\\n\\n    When a target is available, one can specify the desired similarity. For\\n    example we may choose to use a cosine similarity, and use it to make\\n    predictions or recommendations.\\n\\n    >>> sf2 = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                        \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\'],\\n    ...                        \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf2, target=\"rating\",\\n    ...                                                  similarity_type=\\'cosine\\')\\n    >>> m2.predict(sf)\\n    >>> m2.recommend()\\n\\n    Notes\\n    -----\\n    Currently, :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender`\\n    does not leverage the use of side features `user_data` and `item_data`.\\n\\n    **Incorporating pre-defined similar items**\\n\\n    For item similarity models, one may choose to provide user-specified\\n    nearest neighbors graph using the keyword argument `nearest_items`. This is\\n    an SFrame containing, for each item, the nearest items and the similarity\\n    score between them. If provided, these item similarity scores are used for\\n    recommendations. The SFrame must contain (at least) three columns:\\n\\n    * \\'item_id\\': a column with the same name as that provided to the `item_id`\\n      argument (which defaults to the string \"item_id\").\\n    * \\'similar\\': a column containing the nearest items for the given item id.\\n      This should have the same type as the `item_id` column.\\n    * \\'score\\': a numeric score measuring how similar these two items are.\\n\\n    For example, suppose you first create an ItemSimilarityRecommender and use\\n    :class:`~turicreate.recommender.ItemSimilarityRecommender.get_similar_items`:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"]})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> nn = m.get_similar_items()\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf, nearest_items=nn)\\n\\n    With the above code, the item similarities computed for model `m` can be\\n    used to create a new recommender object, `m2`. Note that we could have\\n    created `nn` from some other means, but now use `m2` to make\\n    recommendations via `m2.recommend()`.\\n\\n\\n    See Also\\n    --------\\n    ItemSimilarityRecommender\\n\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.item_similarity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    if nearest_items is None:\n        nearest_items = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'similarity_type': similarity_type, 'threshold': threshold, 'target_memory_usage': float(target_memory_usage), 'max_item_neighborhood_size': only_top_k}\n    extra_data = {'nearest_items': nearest_items}\n    if kwargs:\n        try:\n            possible_args = set(_get_default_options()['name'])\n        except (RuntimeError, KeyError):\n            possible_args = set()\n        bad_arguments = set(kwargs.keys()).difference(possible_args)\n        if bad_arguments:\n            raise TypeError('Bad Keyword Arguments: ' + ', '.join(bad_arguments))\n        opts.update(kwargs)\n    extra_data = {'nearest_items': nearest_items}\n    opts.update(kwargs)\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return ItemSimilarityRecommender(model_proxy)",
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, nearest_items=None, similarity_type='jaccard', threshold=0.001, only_top_k=64, verbose=True, target_memory_usage=8 * 1024 * 1024 * 1024, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a recommender that uses item-item similarities based on\\n    users in common.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    similarity_type : {\\'jaccard\\', \\'cosine\\', \\'pearson\\'}, optional\\n        Similarity metric to use. See ItemSimilarityRecommender for details.\\n        Default: \\'jaccard\\'.\\n\\n    threshold : float, optional\\n        Predictions ignore items below this similarity value.\\n        Default: 0.001.\\n\\n    only_top_k : int, optional\\n        Number of similar items to store for each item. Default value is\\n        64.  Decreasing this  decreases the amount of memory required for the\\n        model, but may also decrease the accuracy.\\n\\n    nearest_items : SFrame, optional\\n        A set of each item\\'s nearest items. When provided, this overrides\\n        the similarity computed above.\\n        See Notes in the documentation for ItemSimilarityRecommender.\\n        Default: None.\\n\\n    target_memory_usage : int, optional\\n        The target memory usage for the processing buffers and lookup\\n        tables.  The actual memory usage may be higher or lower than this,\\n        but decreasing this decreases memory usage at the expense of\\n        training time, and increasing this can dramatically speed up the\\n        training time.  Default is 8GB = 8589934592.\\n\\n    seed_item_set_size : int, optional\\n        For users that have not yet rated any items, or have only\\n        rated uniquely occurring items with no similar item info,\\n        the model seeds the user\\'s item set with the average\\n        ratings of the seed_item_set_size most popular items when\\n        making predictions and recommendations.  If set to 0, then\\n        recommendations based on either popularity (no target present)\\n        or average item score (target present) are made in this case.\\n\\n    nearest_neighbors_interaction_proportion_threshold : (advanced) float\\n        Any item that has was rated by more than this proportion of\\n        users is  treated by doing a nearest neighbors search.  For\\n        frequent items, this  is almost always faster, but it is slower\\n        for infrequent items.  Furthermore, decreasing this causes more\\n        items to be processed using the nearest neighbor path, which may\\n        decrease memory requirements.\\n\\n    degree_approximation_threshold : (advanced) int, optional\\n        Users with more than this many item interactions may be\\n        approximated.  The approximation is done by a combination of\\n        sampling and choosing the interactions likely to have the most\\n        impact on the model.  Increasing this can increase the training time\\n        and may or may not increase the quality of the model.  Default = 4096.\\n\\n    max_data_passes : (advanced) int, optional\\n        The maximum number of passes through the data allowed in\\n        building the similarity lookup tables.  If it is not possible to\\n        build the recommender in this many passes (calculated before\\n        that stage of training), then additional approximations are\\n        applied; namely decreasing degree_approximation_threshold.  If\\n        this is not possible, an error is raised.  To decrease the\\n        number of passes required, increase target_memory_usage or\\n        decrease nearest_neighbors_interaction_proportion_threshold.\\n        Default = 1024.\\n\\n    Examples\\n    --------\\n    Given basic user-item observation data, an\\n    :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender` is created:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                       \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\']})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> recs = m.recommend()\\n\\n    When a target is available, one can specify the desired similarity. For\\n    example we may choose to use a cosine similarity, and use it to make\\n    predictions or recommendations.\\n\\n    >>> sf2 = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                        \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\'],\\n    ...                        \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf2, target=\"rating\",\\n    ...                                                  similarity_type=\\'cosine\\')\\n    >>> m2.predict(sf)\\n    >>> m2.recommend()\\n\\n    Notes\\n    -----\\n    Currently, :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender`\\n    does not leverage the use of side features `user_data` and `item_data`.\\n\\n    **Incorporating pre-defined similar items**\\n\\n    For item similarity models, one may choose to provide user-specified\\n    nearest neighbors graph using the keyword argument `nearest_items`. This is\\n    an SFrame containing, for each item, the nearest items and the similarity\\n    score between them. If provided, these item similarity scores are used for\\n    recommendations. The SFrame must contain (at least) three columns:\\n\\n    * \\'item_id\\': a column with the same name as that provided to the `item_id`\\n      argument (which defaults to the string \"item_id\").\\n    * \\'similar\\': a column containing the nearest items for the given item id.\\n      This should have the same type as the `item_id` column.\\n    * \\'score\\': a numeric score measuring how similar these two items are.\\n\\n    For example, suppose you first create an ItemSimilarityRecommender and use\\n    :class:`~turicreate.recommender.ItemSimilarityRecommender.get_similar_items`:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"]})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> nn = m.get_similar_items()\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf, nearest_items=nn)\\n\\n    With the above code, the item similarities computed for model `m` can be\\n    used to create a new recommender object, `m2`. Note that we could have\\n    created `nn` from some other means, but now use `m2` to make\\n    recommendations via `m2.recommend()`.\\n\\n\\n    See Also\\n    --------\\n    ItemSimilarityRecommender\\n\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.item_similarity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    if nearest_items is None:\n        nearest_items = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'similarity_type': similarity_type, 'threshold': threshold, 'target_memory_usage': float(target_memory_usage), 'max_item_neighborhood_size': only_top_k}\n    extra_data = {'nearest_items': nearest_items}\n    if kwargs:\n        try:\n            possible_args = set(_get_default_options()['name'])\n        except (RuntimeError, KeyError):\n            possible_args = set()\n        bad_arguments = set(kwargs.keys()).difference(possible_args)\n        if bad_arguments:\n            raise TypeError('Bad Keyword Arguments: ' + ', '.join(bad_arguments))\n        opts.update(kwargs)\n    extra_data = {'nearest_items': nearest_items}\n    opts.update(kwargs)\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return ItemSimilarityRecommender(model_proxy)",
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, nearest_items=None, similarity_type='jaccard', threshold=0.001, only_top_k=64, verbose=True, target_memory_usage=8 * 1024 * 1024 * 1024, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a recommender that uses item-item similarities based on\\n    users in common.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    similarity_type : {\\'jaccard\\', \\'cosine\\', \\'pearson\\'}, optional\\n        Similarity metric to use. See ItemSimilarityRecommender for details.\\n        Default: \\'jaccard\\'.\\n\\n    threshold : float, optional\\n        Predictions ignore items below this similarity value.\\n        Default: 0.001.\\n\\n    only_top_k : int, optional\\n        Number of similar items to store for each item. Default value is\\n        64.  Decreasing this  decreases the amount of memory required for the\\n        model, but may also decrease the accuracy.\\n\\n    nearest_items : SFrame, optional\\n        A set of each item\\'s nearest items. When provided, this overrides\\n        the similarity computed above.\\n        See Notes in the documentation for ItemSimilarityRecommender.\\n        Default: None.\\n\\n    target_memory_usage : int, optional\\n        The target memory usage for the processing buffers and lookup\\n        tables.  The actual memory usage may be higher or lower than this,\\n        but decreasing this decreases memory usage at the expense of\\n        training time, and increasing this can dramatically speed up the\\n        training time.  Default is 8GB = 8589934592.\\n\\n    seed_item_set_size : int, optional\\n        For users that have not yet rated any items, or have only\\n        rated uniquely occurring items with no similar item info,\\n        the model seeds the user\\'s item set with the average\\n        ratings of the seed_item_set_size most popular items when\\n        making predictions and recommendations.  If set to 0, then\\n        recommendations based on either popularity (no target present)\\n        or average item score (target present) are made in this case.\\n\\n    nearest_neighbors_interaction_proportion_threshold : (advanced) float\\n        Any item that has was rated by more than this proportion of\\n        users is  treated by doing a nearest neighbors search.  For\\n        frequent items, this  is almost always faster, but it is slower\\n        for infrequent items.  Furthermore, decreasing this causes more\\n        items to be processed using the nearest neighbor path, which may\\n        decrease memory requirements.\\n\\n    degree_approximation_threshold : (advanced) int, optional\\n        Users with more than this many item interactions may be\\n        approximated.  The approximation is done by a combination of\\n        sampling and choosing the interactions likely to have the most\\n        impact on the model.  Increasing this can increase the training time\\n        and may or may not increase the quality of the model.  Default = 4096.\\n\\n    max_data_passes : (advanced) int, optional\\n        The maximum number of passes through the data allowed in\\n        building the similarity lookup tables.  If it is not possible to\\n        build the recommender in this many passes (calculated before\\n        that stage of training), then additional approximations are\\n        applied; namely decreasing degree_approximation_threshold.  If\\n        this is not possible, an error is raised.  To decrease the\\n        number of passes required, increase target_memory_usage or\\n        decrease nearest_neighbors_interaction_proportion_threshold.\\n        Default = 1024.\\n\\n    Examples\\n    --------\\n    Given basic user-item observation data, an\\n    :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender` is created:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                       \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\']})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> recs = m.recommend()\\n\\n    When a target is available, one can specify the desired similarity. For\\n    example we may choose to use a cosine similarity, and use it to make\\n    predictions or recommendations.\\n\\n    >>> sf2 = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                        \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\'],\\n    ...                        \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf2, target=\"rating\",\\n    ...                                                  similarity_type=\\'cosine\\')\\n    >>> m2.predict(sf)\\n    >>> m2.recommend()\\n\\n    Notes\\n    -----\\n    Currently, :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender`\\n    does not leverage the use of side features `user_data` and `item_data`.\\n\\n    **Incorporating pre-defined similar items**\\n\\n    For item similarity models, one may choose to provide user-specified\\n    nearest neighbors graph using the keyword argument `nearest_items`. This is\\n    an SFrame containing, for each item, the nearest items and the similarity\\n    score between them. If provided, these item similarity scores are used for\\n    recommendations. The SFrame must contain (at least) three columns:\\n\\n    * \\'item_id\\': a column with the same name as that provided to the `item_id`\\n      argument (which defaults to the string \"item_id\").\\n    * \\'similar\\': a column containing the nearest items for the given item id.\\n      This should have the same type as the `item_id` column.\\n    * \\'score\\': a numeric score measuring how similar these two items are.\\n\\n    For example, suppose you first create an ItemSimilarityRecommender and use\\n    :class:`~turicreate.recommender.ItemSimilarityRecommender.get_similar_items`:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"]})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> nn = m.get_similar_items()\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf, nearest_items=nn)\\n\\n    With the above code, the item similarities computed for model `m` can be\\n    used to create a new recommender object, `m2`. Note that we could have\\n    created `nn` from some other means, but now use `m2` to make\\n    recommendations via `m2.recommend()`.\\n\\n\\n    See Also\\n    --------\\n    ItemSimilarityRecommender\\n\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.item_similarity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    if nearest_items is None:\n        nearest_items = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'similarity_type': similarity_type, 'threshold': threshold, 'target_memory_usage': float(target_memory_usage), 'max_item_neighborhood_size': only_top_k}\n    extra_data = {'nearest_items': nearest_items}\n    if kwargs:\n        try:\n            possible_args = set(_get_default_options()['name'])\n        except (RuntimeError, KeyError):\n            possible_args = set()\n        bad_arguments = set(kwargs.keys()).difference(possible_args)\n        if bad_arguments:\n            raise TypeError('Bad Keyword Arguments: ' + ', '.join(bad_arguments))\n        opts.update(kwargs)\n    extra_data = {'nearest_items': nearest_items}\n    opts.update(kwargs)\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return ItemSimilarityRecommender(model_proxy)",
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, nearest_items=None, similarity_type='jaccard', threshold=0.001, only_top_k=64, verbose=True, target_memory_usage=8 * 1024 * 1024 * 1024, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a recommender that uses item-item similarities based on\\n    users in common.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    similarity_type : {\\'jaccard\\', \\'cosine\\', \\'pearson\\'}, optional\\n        Similarity metric to use. See ItemSimilarityRecommender for details.\\n        Default: \\'jaccard\\'.\\n\\n    threshold : float, optional\\n        Predictions ignore items below this similarity value.\\n        Default: 0.001.\\n\\n    only_top_k : int, optional\\n        Number of similar items to store for each item. Default value is\\n        64.  Decreasing this  decreases the amount of memory required for the\\n        model, but may also decrease the accuracy.\\n\\n    nearest_items : SFrame, optional\\n        A set of each item\\'s nearest items. When provided, this overrides\\n        the similarity computed above.\\n        See Notes in the documentation for ItemSimilarityRecommender.\\n        Default: None.\\n\\n    target_memory_usage : int, optional\\n        The target memory usage for the processing buffers and lookup\\n        tables.  The actual memory usage may be higher or lower than this,\\n        but decreasing this decreases memory usage at the expense of\\n        training time, and increasing this can dramatically speed up the\\n        training time.  Default is 8GB = 8589934592.\\n\\n    seed_item_set_size : int, optional\\n        For users that have not yet rated any items, or have only\\n        rated uniquely occurring items with no similar item info,\\n        the model seeds the user\\'s item set with the average\\n        ratings of the seed_item_set_size most popular items when\\n        making predictions and recommendations.  If set to 0, then\\n        recommendations based on either popularity (no target present)\\n        or average item score (target present) are made in this case.\\n\\n    nearest_neighbors_interaction_proportion_threshold : (advanced) float\\n        Any item that has was rated by more than this proportion of\\n        users is  treated by doing a nearest neighbors search.  For\\n        frequent items, this  is almost always faster, but it is slower\\n        for infrequent items.  Furthermore, decreasing this causes more\\n        items to be processed using the nearest neighbor path, which may\\n        decrease memory requirements.\\n\\n    degree_approximation_threshold : (advanced) int, optional\\n        Users with more than this many item interactions may be\\n        approximated.  The approximation is done by a combination of\\n        sampling and choosing the interactions likely to have the most\\n        impact on the model.  Increasing this can increase the training time\\n        and may or may not increase the quality of the model.  Default = 4096.\\n\\n    max_data_passes : (advanced) int, optional\\n        The maximum number of passes through the data allowed in\\n        building the similarity lookup tables.  If it is not possible to\\n        build the recommender in this many passes (calculated before\\n        that stage of training), then additional approximations are\\n        applied; namely decreasing degree_approximation_threshold.  If\\n        this is not possible, an error is raised.  To decrease the\\n        number of passes required, increase target_memory_usage or\\n        decrease nearest_neighbors_interaction_proportion_threshold.\\n        Default = 1024.\\n\\n    Examples\\n    --------\\n    Given basic user-item observation data, an\\n    :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender` is created:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                       \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\']})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> recs = m.recommend()\\n\\n    When a target is available, one can specify the desired similarity. For\\n    example we may choose to use a cosine similarity, and use it to make\\n    predictions or recommendations.\\n\\n    >>> sf2 = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                        \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\'],\\n    ...                        \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf2, target=\"rating\",\\n    ...                                                  similarity_type=\\'cosine\\')\\n    >>> m2.predict(sf)\\n    >>> m2.recommend()\\n\\n    Notes\\n    -----\\n    Currently, :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender`\\n    does not leverage the use of side features `user_data` and `item_data`.\\n\\n    **Incorporating pre-defined similar items**\\n\\n    For item similarity models, one may choose to provide user-specified\\n    nearest neighbors graph using the keyword argument `nearest_items`. This is\\n    an SFrame containing, for each item, the nearest items and the similarity\\n    score between them. If provided, these item similarity scores are used for\\n    recommendations. The SFrame must contain (at least) three columns:\\n\\n    * \\'item_id\\': a column with the same name as that provided to the `item_id`\\n      argument (which defaults to the string \"item_id\").\\n    * \\'similar\\': a column containing the nearest items for the given item id.\\n      This should have the same type as the `item_id` column.\\n    * \\'score\\': a numeric score measuring how similar these two items are.\\n\\n    For example, suppose you first create an ItemSimilarityRecommender and use\\n    :class:`~turicreate.recommender.ItemSimilarityRecommender.get_similar_items`:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"]})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> nn = m.get_similar_items()\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf, nearest_items=nn)\\n\\n    With the above code, the item similarities computed for model `m` can be\\n    used to create a new recommender object, `m2`. Note that we could have\\n    created `nn` from some other means, but now use `m2` to make\\n    recommendations via `m2.recommend()`.\\n\\n\\n    See Also\\n    --------\\n    ItemSimilarityRecommender\\n\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.item_similarity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    if nearest_items is None:\n        nearest_items = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'similarity_type': similarity_type, 'threshold': threshold, 'target_memory_usage': float(target_memory_usage), 'max_item_neighborhood_size': only_top_k}\n    extra_data = {'nearest_items': nearest_items}\n    if kwargs:\n        try:\n            possible_args = set(_get_default_options()['name'])\n        except (RuntimeError, KeyError):\n            possible_args = set()\n        bad_arguments = set(kwargs.keys()).difference(possible_args)\n        if bad_arguments:\n            raise TypeError('Bad Keyword Arguments: ' + ', '.join(bad_arguments))\n        opts.update(kwargs)\n    extra_data = {'nearest_items': nearest_items}\n    opts.update(kwargs)\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return ItemSimilarityRecommender(model_proxy)",
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, nearest_items=None, similarity_type='jaccard', threshold=0.001, only_top_k=64, verbose=True, target_memory_usage=8 * 1024 * 1024 * 1024, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a recommender that uses item-item similarities based on\\n    users in common.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information. (NB: This argument is currently ignored by this model.)\\n\\n    similarity_type : {\\'jaccard\\', \\'cosine\\', \\'pearson\\'}, optional\\n        Similarity metric to use. See ItemSimilarityRecommender for details.\\n        Default: \\'jaccard\\'.\\n\\n    threshold : float, optional\\n        Predictions ignore items below this similarity value.\\n        Default: 0.001.\\n\\n    only_top_k : int, optional\\n        Number of similar items to store for each item. Default value is\\n        64.  Decreasing this  decreases the amount of memory required for the\\n        model, but may also decrease the accuracy.\\n\\n    nearest_items : SFrame, optional\\n        A set of each item\\'s nearest items. When provided, this overrides\\n        the similarity computed above.\\n        See Notes in the documentation for ItemSimilarityRecommender.\\n        Default: None.\\n\\n    target_memory_usage : int, optional\\n        The target memory usage for the processing buffers and lookup\\n        tables.  The actual memory usage may be higher or lower than this,\\n        but decreasing this decreases memory usage at the expense of\\n        training time, and increasing this can dramatically speed up the\\n        training time.  Default is 8GB = 8589934592.\\n\\n    seed_item_set_size : int, optional\\n        For users that have not yet rated any items, or have only\\n        rated uniquely occurring items with no similar item info,\\n        the model seeds the user\\'s item set with the average\\n        ratings of the seed_item_set_size most popular items when\\n        making predictions and recommendations.  If set to 0, then\\n        recommendations based on either popularity (no target present)\\n        or average item score (target present) are made in this case.\\n\\n    nearest_neighbors_interaction_proportion_threshold : (advanced) float\\n        Any item that has was rated by more than this proportion of\\n        users is  treated by doing a nearest neighbors search.  For\\n        frequent items, this  is almost always faster, but it is slower\\n        for infrequent items.  Furthermore, decreasing this causes more\\n        items to be processed using the nearest neighbor path, which may\\n        decrease memory requirements.\\n\\n    degree_approximation_threshold : (advanced) int, optional\\n        Users with more than this many item interactions may be\\n        approximated.  The approximation is done by a combination of\\n        sampling and choosing the interactions likely to have the most\\n        impact on the model.  Increasing this can increase the training time\\n        and may or may not increase the quality of the model.  Default = 4096.\\n\\n    max_data_passes : (advanced) int, optional\\n        The maximum number of passes through the data allowed in\\n        building the similarity lookup tables.  If it is not possible to\\n        build the recommender in this many passes (calculated before\\n        that stage of training), then additional approximations are\\n        applied; namely decreasing degree_approximation_threshold.  If\\n        this is not possible, an error is raised.  To decrease the\\n        number of passes required, increase target_memory_usage or\\n        decrease nearest_neighbors_interaction_proportion_threshold.\\n        Default = 1024.\\n\\n    Examples\\n    --------\\n    Given basic user-item observation data, an\\n    :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender` is created:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                       \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\']})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> recs = m.recommend()\\n\\n    When a target is available, one can specify the desired similarity. For\\n    example we may choose to use a cosine similarity, and use it to make\\n    predictions or recommendations.\\n\\n    >>> sf2 = turicreate.SFrame({\\'user_id\\': [\\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'2\\', \\'2\\', \\'2\\'],\\n    ...                        \\'item_id\\': [\\'a\\', \\'b\\', \\'c\\', \\'a\\', \\'b\\', \\'b\\', \\'c\\', \\'d\\'],\\n    ...                        \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf2, target=\"rating\",\\n    ...                                                  similarity_type=\\'cosine\\')\\n    >>> m2.predict(sf)\\n    >>> m2.recommend()\\n\\n    Notes\\n    -----\\n    Currently, :class:`~turicreate.recommender.item_similarity_recommender.ItemSimilarityRecommender`\\n    does not leverage the use of side features `user_data` and `item_data`.\\n\\n    **Incorporating pre-defined similar items**\\n\\n    For item similarity models, one may choose to provide user-specified\\n    nearest neighbors graph using the keyword argument `nearest_items`. This is\\n    an SFrame containing, for each item, the nearest items and the similarity\\n    score between them. If provided, these item similarity scores are used for\\n    recommendations. The SFrame must contain (at least) three columns:\\n\\n    * \\'item_id\\': a column with the same name as that provided to the `item_id`\\n      argument (which defaults to the string \"item_id\").\\n    * \\'similar\\': a column containing the nearest items for the given item id.\\n      This should have the same type as the `item_id` column.\\n    * \\'score\\': a numeric score measuring how similar these two items are.\\n\\n    For example, suppose you first create an ItemSimilarityRecommender and use\\n    :class:`~turicreate.recommender.ItemSimilarityRecommender.get_similar_items`:\\n\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"]})\\n    >>> m = turicreate.item_similarity_recommender.create(sf)\\n    >>> nn = m.get_similar_items()\\n    >>> m2 = turicreate.item_similarity_recommender.create(sf, nearest_items=nn)\\n\\n    With the above code, the item similarities computed for model `m` can be\\n    used to create a new recommender object, `m2`. Note that we could have\\n    created `nn` from some other means, but now use `m2` to make\\n    recommendations via `m2.recommend()`.\\n\\n\\n    See Also\\n    --------\\n    ItemSimilarityRecommender\\n\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.item_similarity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    if nearest_items is None:\n        nearest_items = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'similarity_type': similarity_type, 'threshold': threshold, 'target_memory_usage': float(target_memory_usage), 'max_item_neighborhood_size': only_top_k}\n    extra_data = {'nearest_items': nearest_items}\n    if kwargs:\n        try:\n            possible_args = set(_get_default_options()['name'])\n        except (RuntimeError, KeyError):\n            possible_args = set()\n        bad_arguments = set(kwargs.keys()).difference(possible_args)\n        if bad_arguments:\n            raise TypeError('Bad Keyword Arguments: ' + ', '.join(bad_arguments))\n        opts.update(kwargs)\n    extra_data = {'nearest_items': nearest_items}\n    opts.update(kwargs)\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return ItemSimilarityRecommender(model_proxy)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, model_proxy):\n    \"\"\"__init__(self)\"\"\"\n    self.__proxy__ = model_proxy",
        "mutated": [
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n    '__init__(self)'\n    self.__proxy__ = model_proxy",
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '__init__(self)'\n    self.__proxy__ = model_proxy",
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '__init__(self)'\n    self.__proxy__ = model_proxy",
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '__init__(self)'\n    self.__proxy__ = model_proxy",
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '__init__(self)'\n    self.__proxy__ = model_proxy"
        ]
    },
    {
        "func_name": "_native_name",
        "original": "@classmethod\ndef _native_name(cls):\n    return 'item_similarity'",
        "mutated": [
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n    return 'item_similarity'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'item_similarity'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'item_similarity'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'item_similarity'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'item_similarity'"
        ]
    }
]