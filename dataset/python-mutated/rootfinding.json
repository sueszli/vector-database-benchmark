[
    {
        "func_name": "brentq_expanding",
        "original": "def brentq_expanding(func, low=None, upp=None, args=(), xtol=1e-05, start_low=None, start_upp=None, increasing=None, max_it=100, maxiter_bq=100, factor=10, full_output=False):\n    \"\"\"find the root of a function in one variable by expanding and brentq\n\n    Assumes function ``func`` is monotonic.\n\n    Parameters\n    ----------\n    func : callable\n        function for which we find the root ``x`` such that ``func(x) = 0``\n    low : float or None\n        lower bound for brentq\n    upp : float or None\n        upper bound for brentq\n    args : tuple\n        optional additional arguments for ``func``\n    xtol : float\n        parameter x tolerance given to brentq\n    start_low : float (positive) or None\n        starting bound for expansion with increasing ``x``. It needs to be\n        positive. If None, then it is set to 1.\n    start_upp : float (negative) or None\n        starting bound for expansion with decreasing ``x``. It needs to be\n        negative. If None, then it is set to -1.\n    increasing : bool or None\n        If None, then the function is evaluated at the initial bounds to\n        determine wether the function is increasing or not. If increasing is\n        True (False), then it is assumed that the function is monotonically\n        increasing (decreasing).\n    max_it : int\n        maximum number of expansion steps.\n    maxiter_bq : int\n        maximum number of iterations of brentq.\n    factor : float\n        expansion factor for step of shifting the bounds interval, default is\n        10.\n    full_output : bool, optional\n        If full_output is False, the root is returned. If full_output is True,\n        the return value is (x, r), where x is the root, and r is a\n        RootResults object.\n\n\n    Returns\n    -------\n    x : float\n        root of the function, value at which ``func(x) = 0``.\n    info : RootResult (optional)\n        returned if ``full_output`` is True.\n        attributes:\n\n         - start_bounds : starting bounds for expansion stage\n         - brentq_bounds : bounds used with ``brentq``\n         - iterations_expand : number of iterations in expansion stage\n         - converged : True if brentq converged.\n         - flag : return status, 'converged' if brentq converged\n         - function_calls : number of function calls by ``brentq``\n         - iterations : number of iterations in ``brentq``\n\n\n    Notes\n    -----\n    If increasing is None, then whether the function is monotonically\n    increasing or decreasing is inferred from evaluating the function at the\n    initial bounds. This can fail if there is numerically no variation in the\n    data in this range. In this case, using different starting bounds or\n    directly specifying ``increasing`` can make it possible to move the\n    expansion in the right direction.\n\n    If\n\n    \"\"\"\n    (left, right) = (low, upp)\n    if upp is not None:\n        su = upp\n    elif start_upp is not None:\n        if start_upp < 0:\n            raise ValueError('start_upp needs to be positive')\n        su = start_upp\n    else:\n        su = 1.0\n    if low is not None:\n        sl = low\n    elif start_low is not None:\n        if start_low > 0:\n            raise ValueError('start_low needs to be negative')\n        sl = start_low\n    else:\n        sl = min(-1.0, su - 1.0)\n    if upp is None:\n        su = max(su, sl + 1.0)\n    if (low is None or upp is None) and increasing is None:\n        assert sl < su\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.max(np.abs(f_upp - f_low)) < 1e-15 and sl == -1 and (su == 1):\n            sl = 1e-08\n            f_low = func(sl, *args)\n            increasing = f_low < f_upp\n        delta = su - sl\n        if np.isnan(f_low):\n            for fraction in [0.25, 0.5, 0.75]:\n                sl_ = sl + fraction * delta\n                f_low = func(sl_, *args)\n                if not np.isnan(f_low):\n                    break\n            else:\n                raise ValueError('could not determine whether function is ' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        if np.isnan(f_upp):\n            for fraction in [0.25, 0.5, 0.75]:\n                su_ = su + fraction * delta\n                f_upp = func(su_, *args)\n                if not np.isnan(f_upp):\n                    break\n            else:\n                raise ValueError('could not determine whether function is' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        increasing = f_low < f_upp\n    if not increasing:\n        (sl, su) = (su, sl)\n        (left, right) = (right, left)\n    n_it = 0\n    if left is None and sl != 0:\n        left = sl\n        while func(left, *args) > 0:\n            right = left\n            left *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if right is None and su != 0:\n        right = su\n        while func(right, *args) < 0:\n            left = right\n            right *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if n_it >= max_it:\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.isnan(f_low) and np.isnan(f_upp):\n            raise ValueError('max_it reached' + '\\nthe function values at boths bounds are NaN' + '\\nchange the starting bounds, set bounds' + 'or increase max_it')\n    res = optimize.brentq(func, left, right, args=args, xtol=xtol, maxiter=maxiter_bq, full_output=full_output)\n    if full_output:\n        val = res[0]\n        info = Holder(root=res[1].root, iterations=res[1].iterations, function_calls=res[1].function_calls, converged=res[1].converged, flag=res[1].flag, iterations_expand=n_it, start_bounds=(sl, su), brentq_bounds=(left, right), increasing=increasing)\n        return (val, info)\n    else:\n        return res",
        "mutated": [
            "def brentq_expanding(func, low=None, upp=None, args=(), xtol=1e-05, start_low=None, start_upp=None, increasing=None, max_it=100, maxiter_bq=100, factor=10, full_output=False):\n    if False:\n        i = 10\n    \"find the root of a function in one variable by expanding and brentq\\n\\n    Assumes function ``func`` is monotonic.\\n\\n    Parameters\\n    ----------\\n    func : callable\\n        function for which we find the root ``x`` such that ``func(x) = 0``\\n    low : float or None\\n        lower bound for brentq\\n    upp : float or None\\n        upper bound for brentq\\n    args : tuple\\n        optional additional arguments for ``func``\\n    xtol : float\\n        parameter x tolerance given to brentq\\n    start_low : float (positive) or None\\n        starting bound for expansion with increasing ``x``. It needs to be\\n        positive. If None, then it is set to 1.\\n    start_upp : float (negative) or None\\n        starting bound for expansion with decreasing ``x``. It needs to be\\n        negative. If None, then it is set to -1.\\n    increasing : bool or None\\n        If None, then the function is evaluated at the initial bounds to\\n        determine wether the function is increasing or not. If increasing is\\n        True (False), then it is assumed that the function is monotonically\\n        increasing (decreasing).\\n    max_it : int\\n        maximum number of expansion steps.\\n    maxiter_bq : int\\n        maximum number of iterations of brentq.\\n    factor : float\\n        expansion factor for step of shifting the bounds interval, default is\\n        10.\\n    full_output : bool, optional\\n        If full_output is False, the root is returned. If full_output is True,\\n        the return value is (x, r), where x is the root, and r is a\\n        RootResults object.\\n\\n\\n    Returns\\n    -------\\n    x : float\\n        root of the function, value at which ``func(x) = 0``.\\n    info : RootResult (optional)\\n        returned if ``full_output`` is True.\\n        attributes:\\n\\n         - start_bounds : starting bounds for expansion stage\\n         - brentq_bounds : bounds used with ``brentq``\\n         - iterations_expand : number of iterations in expansion stage\\n         - converged : True if brentq converged.\\n         - flag : return status, 'converged' if brentq converged\\n         - function_calls : number of function calls by ``brentq``\\n         - iterations : number of iterations in ``brentq``\\n\\n\\n    Notes\\n    -----\\n    If increasing is None, then whether the function is monotonically\\n    increasing or decreasing is inferred from evaluating the function at the\\n    initial bounds. This can fail if there is numerically no variation in the\\n    data in this range. In this case, using different starting bounds or\\n    directly specifying ``increasing`` can make it possible to move the\\n    expansion in the right direction.\\n\\n    If\\n\\n    \"\n    (left, right) = (low, upp)\n    if upp is not None:\n        su = upp\n    elif start_upp is not None:\n        if start_upp < 0:\n            raise ValueError('start_upp needs to be positive')\n        su = start_upp\n    else:\n        su = 1.0\n    if low is not None:\n        sl = low\n    elif start_low is not None:\n        if start_low > 0:\n            raise ValueError('start_low needs to be negative')\n        sl = start_low\n    else:\n        sl = min(-1.0, su - 1.0)\n    if upp is None:\n        su = max(su, sl + 1.0)\n    if (low is None or upp is None) and increasing is None:\n        assert sl < su\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.max(np.abs(f_upp - f_low)) < 1e-15 and sl == -1 and (su == 1):\n            sl = 1e-08\n            f_low = func(sl, *args)\n            increasing = f_low < f_upp\n        delta = su - sl\n        if np.isnan(f_low):\n            for fraction in [0.25, 0.5, 0.75]:\n                sl_ = sl + fraction * delta\n                f_low = func(sl_, *args)\n                if not np.isnan(f_low):\n                    break\n            else:\n                raise ValueError('could not determine whether function is ' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        if np.isnan(f_upp):\n            for fraction in [0.25, 0.5, 0.75]:\n                su_ = su + fraction * delta\n                f_upp = func(su_, *args)\n                if not np.isnan(f_upp):\n                    break\n            else:\n                raise ValueError('could not determine whether function is' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        increasing = f_low < f_upp\n    if not increasing:\n        (sl, su) = (su, sl)\n        (left, right) = (right, left)\n    n_it = 0\n    if left is None and sl != 0:\n        left = sl\n        while func(left, *args) > 0:\n            right = left\n            left *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if right is None and su != 0:\n        right = su\n        while func(right, *args) < 0:\n            left = right\n            right *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if n_it >= max_it:\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.isnan(f_low) and np.isnan(f_upp):\n            raise ValueError('max_it reached' + '\\nthe function values at boths bounds are NaN' + '\\nchange the starting bounds, set bounds' + 'or increase max_it')\n    res = optimize.brentq(func, left, right, args=args, xtol=xtol, maxiter=maxiter_bq, full_output=full_output)\n    if full_output:\n        val = res[0]\n        info = Holder(root=res[1].root, iterations=res[1].iterations, function_calls=res[1].function_calls, converged=res[1].converged, flag=res[1].flag, iterations_expand=n_it, start_bounds=(sl, su), brentq_bounds=(left, right), increasing=increasing)\n        return (val, info)\n    else:\n        return res",
            "def brentq_expanding(func, low=None, upp=None, args=(), xtol=1e-05, start_low=None, start_upp=None, increasing=None, max_it=100, maxiter_bq=100, factor=10, full_output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"find the root of a function in one variable by expanding and brentq\\n\\n    Assumes function ``func`` is monotonic.\\n\\n    Parameters\\n    ----------\\n    func : callable\\n        function for which we find the root ``x`` such that ``func(x) = 0``\\n    low : float or None\\n        lower bound for brentq\\n    upp : float or None\\n        upper bound for brentq\\n    args : tuple\\n        optional additional arguments for ``func``\\n    xtol : float\\n        parameter x tolerance given to brentq\\n    start_low : float (positive) or None\\n        starting bound for expansion with increasing ``x``. It needs to be\\n        positive. If None, then it is set to 1.\\n    start_upp : float (negative) or None\\n        starting bound for expansion with decreasing ``x``. It needs to be\\n        negative. If None, then it is set to -1.\\n    increasing : bool or None\\n        If None, then the function is evaluated at the initial bounds to\\n        determine wether the function is increasing or not. If increasing is\\n        True (False), then it is assumed that the function is monotonically\\n        increasing (decreasing).\\n    max_it : int\\n        maximum number of expansion steps.\\n    maxiter_bq : int\\n        maximum number of iterations of brentq.\\n    factor : float\\n        expansion factor for step of shifting the bounds interval, default is\\n        10.\\n    full_output : bool, optional\\n        If full_output is False, the root is returned. If full_output is True,\\n        the return value is (x, r), where x is the root, and r is a\\n        RootResults object.\\n\\n\\n    Returns\\n    -------\\n    x : float\\n        root of the function, value at which ``func(x) = 0``.\\n    info : RootResult (optional)\\n        returned if ``full_output`` is True.\\n        attributes:\\n\\n         - start_bounds : starting bounds for expansion stage\\n         - brentq_bounds : bounds used with ``brentq``\\n         - iterations_expand : number of iterations in expansion stage\\n         - converged : True if brentq converged.\\n         - flag : return status, 'converged' if brentq converged\\n         - function_calls : number of function calls by ``brentq``\\n         - iterations : number of iterations in ``brentq``\\n\\n\\n    Notes\\n    -----\\n    If increasing is None, then whether the function is monotonically\\n    increasing or decreasing is inferred from evaluating the function at the\\n    initial bounds. This can fail if there is numerically no variation in the\\n    data in this range. In this case, using different starting bounds or\\n    directly specifying ``increasing`` can make it possible to move the\\n    expansion in the right direction.\\n\\n    If\\n\\n    \"\n    (left, right) = (low, upp)\n    if upp is not None:\n        su = upp\n    elif start_upp is not None:\n        if start_upp < 0:\n            raise ValueError('start_upp needs to be positive')\n        su = start_upp\n    else:\n        su = 1.0\n    if low is not None:\n        sl = low\n    elif start_low is not None:\n        if start_low > 0:\n            raise ValueError('start_low needs to be negative')\n        sl = start_low\n    else:\n        sl = min(-1.0, su - 1.0)\n    if upp is None:\n        su = max(su, sl + 1.0)\n    if (low is None or upp is None) and increasing is None:\n        assert sl < su\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.max(np.abs(f_upp - f_low)) < 1e-15 and sl == -1 and (su == 1):\n            sl = 1e-08\n            f_low = func(sl, *args)\n            increasing = f_low < f_upp\n        delta = su - sl\n        if np.isnan(f_low):\n            for fraction in [0.25, 0.5, 0.75]:\n                sl_ = sl + fraction * delta\n                f_low = func(sl_, *args)\n                if not np.isnan(f_low):\n                    break\n            else:\n                raise ValueError('could not determine whether function is ' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        if np.isnan(f_upp):\n            for fraction in [0.25, 0.5, 0.75]:\n                su_ = su + fraction * delta\n                f_upp = func(su_, *args)\n                if not np.isnan(f_upp):\n                    break\n            else:\n                raise ValueError('could not determine whether function is' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        increasing = f_low < f_upp\n    if not increasing:\n        (sl, su) = (su, sl)\n        (left, right) = (right, left)\n    n_it = 0\n    if left is None and sl != 0:\n        left = sl\n        while func(left, *args) > 0:\n            right = left\n            left *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if right is None and su != 0:\n        right = su\n        while func(right, *args) < 0:\n            left = right\n            right *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if n_it >= max_it:\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.isnan(f_low) and np.isnan(f_upp):\n            raise ValueError('max_it reached' + '\\nthe function values at boths bounds are NaN' + '\\nchange the starting bounds, set bounds' + 'or increase max_it')\n    res = optimize.brentq(func, left, right, args=args, xtol=xtol, maxiter=maxiter_bq, full_output=full_output)\n    if full_output:\n        val = res[0]\n        info = Holder(root=res[1].root, iterations=res[1].iterations, function_calls=res[1].function_calls, converged=res[1].converged, flag=res[1].flag, iterations_expand=n_it, start_bounds=(sl, su), brentq_bounds=(left, right), increasing=increasing)\n        return (val, info)\n    else:\n        return res",
            "def brentq_expanding(func, low=None, upp=None, args=(), xtol=1e-05, start_low=None, start_upp=None, increasing=None, max_it=100, maxiter_bq=100, factor=10, full_output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"find the root of a function in one variable by expanding and brentq\\n\\n    Assumes function ``func`` is monotonic.\\n\\n    Parameters\\n    ----------\\n    func : callable\\n        function for which we find the root ``x`` such that ``func(x) = 0``\\n    low : float or None\\n        lower bound for brentq\\n    upp : float or None\\n        upper bound for brentq\\n    args : tuple\\n        optional additional arguments for ``func``\\n    xtol : float\\n        parameter x tolerance given to brentq\\n    start_low : float (positive) or None\\n        starting bound for expansion with increasing ``x``. It needs to be\\n        positive. If None, then it is set to 1.\\n    start_upp : float (negative) or None\\n        starting bound for expansion with decreasing ``x``. It needs to be\\n        negative. If None, then it is set to -1.\\n    increasing : bool or None\\n        If None, then the function is evaluated at the initial bounds to\\n        determine wether the function is increasing or not. If increasing is\\n        True (False), then it is assumed that the function is monotonically\\n        increasing (decreasing).\\n    max_it : int\\n        maximum number of expansion steps.\\n    maxiter_bq : int\\n        maximum number of iterations of brentq.\\n    factor : float\\n        expansion factor for step of shifting the bounds interval, default is\\n        10.\\n    full_output : bool, optional\\n        If full_output is False, the root is returned. If full_output is True,\\n        the return value is (x, r), where x is the root, and r is a\\n        RootResults object.\\n\\n\\n    Returns\\n    -------\\n    x : float\\n        root of the function, value at which ``func(x) = 0``.\\n    info : RootResult (optional)\\n        returned if ``full_output`` is True.\\n        attributes:\\n\\n         - start_bounds : starting bounds for expansion stage\\n         - brentq_bounds : bounds used with ``brentq``\\n         - iterations_expand : number of iterations in expansion stage\\n         - converged : True if brentq converged.\\n         - flag : return status, 'converged' if brentq converged\\n         - function_calls : number of function calls by ``brentq``\\n         - iterations : number of iterations in ``brentq``\\n\\n\\n    Notes\\n    -----\\n    If increasing is None, then whether the function is monotonically\\n    increasing or decreasing is inferred from evaluating the function at the\\n    initial bounds. This can fail if there is numerically no variation in the\\n    data in this range. In this case, using different starting bounds or\\n    directly specifying ``increasing`` can make it possible to move the\\n    expansion in the right direction.\\n\\n    If\\n\\n    \"\n    (left, right) = (low, upp)\n    if upp is not None:\n        su = upp\n    elif start_upp is not None:\n        if start_upp < 0:\n            raise ValueError('start_upp needs to be positive')\n        su = start_upp\n    else:\n        su = 1.0\n    if low is not None:\n        sl = low\n    elif start_low is not None:\n        if start_low > 0:\n            raise ValueError('start_low needs to be negative')\n        sl = start_low\n    else:\n        sl = min(-1.0, su - 1.0)\n    if upp is None:\n        su = max(su, sl + 1.0)\n    if (low is None or upp is None) and increasing is None:\n        assert sl < su\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.max(np.abs(f_upp - f_low)) < 1e-15 and sl == -1 and (su == 1):\n            sl = 1e-08\n            f_low = func(sl, *args)\n            increasing = f_low < f_upp\n        delta = su - sl\n        if np.isnan(f_low):\n            for fraction in [0.25, 0.5, 0.75]:\n                sl_ = sl + fraction * delta\n                f_low = func(sl_, *args)\n                if not np.isnan(f_low):\n                    break\n            else:\n                raise ValueError('could not determine whether function is ' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        if np.isnan(f_upp):\n            for fraction in [0.25, 0.5, 0.75]:\n                su_ = su + fraction * delta\n                f_upp = func(su_, *args)\n                if not np.isnan(f_upp):\n                    break\n            else:\n                raise ValueError('could not determine whether function is' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        increasing = f_low < f_upp\n    if not increasing:\n        (sl, su) = (su, sl)\n        (left, right) = (right, left)\n    n_it = 0\n    if left is None and sl != 0:\n        left = sl\n        while func(left, *args) > 0:\n            right = left\n            left *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if right is None and su != 0:\n        right = su\n        while func(right, *args) < 0:\n            left = right\n            right *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if n_it >= max_it:\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.isnan(f_low) and np.isnan(f_upp):\n            raise ValueError('max_it reached' + '\\nthe function values at boths bounds are NaN' + '\\nchange the starting bounds, set bounds' + 'or increase max_it')\n    res = optimize.brentq(func, left, right, args=args, xtol=xtol, maxiter=maxiter_bq, full_output=full_output)\n    if full_output:\n        val = res[0]\n        info = Holder(root=res[1].root, iterations=res[1].iterations, function_calls=res[1].function_calls, converged=res[1].converged, flag=res[1].flag, iterations_expand=n_it, start_bounds=(sl, su), brentq_bounds=(left, right), increasing=increasing)\n        return (val, info)\n    else:\n        return res",
            "def brentq_expanding(func, low=None, upp=None, args=(), xtol=1e-05, start_low=None, start_upp=None, increasing=None, max_it=100, maxiter_bq=100, factor=10, full_output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"find the root of a function in one variable by expanding and brentq\\n\\n    Assumes function ``func`` is monotonic.\\n\\n    Parameters\\n    ----------\\n    func : callable\\n        function for which we find the root ``x`` such that ``func(x) = 0``\\n    low : float or None\\n        lower bound for brentq\\n    upp : float or None\\n        upper bound for brentq\\n    args : tuple\\n        optional additional arguments for ``func``\\n    xtol : float\\n        parameter x tolerance given to brentq\\n    start_low : float (positive) or None\\n        starting bound for expansion with increasing ``x``. It needs to be\\n        positive. If None, then it is set to 1.\\n    start_upp : float (negative) or None\\n        starting bound for expansion with decreasing ``x``. It needs to be\\n        negative. If None, then it is set to -1.\\n    increasing : bool or None\\n        If None, then the function is evaluated at the initial bounds to\\n        determine wether the function is increasing or not. If increasing is\\n        True (False), then it is assumed that the function is monotonically\\n        increasing (decreasing).\\n    max_it : int\\n        maximum number of expansion steps.\\n    maxiter_bq : int\\n        maximum number of iterations of brentq.\\n    factor : float\\n        expansion factor for step of shifting the bounds interval, default is\\n        10.\\n    full_output : bool, optional\\n        If full_output is False, the root is returned. If full_output is True,\\n        the return value is (x, r), where x is the root, and r is a\\n        RootResults object.\\n\\n\\n    Returns\\n    -------\\n    x : float\\n        root of the function, value at which ``func(x) = 0``.\\n    info : RootResult (optional)\\n        returned if ``full_output`` is True.\\n        attributes:\\n\\n         - start_bounds : starting bounds for expansion stage\\n         - brentq_bounds : bounds used with ``brentq``\\n         - iterations_expand : number of iterations in expansion stage\\n         - converged : True if brentq converged.\\n         - flag : return status, 'converged' if brentq converged\\n         - function_calls : number of function calls by ``brentq``\\n         - iterations : number of iterations in ``brentq``\\n\\n\\n    Notes\\n    -----\\n    If increasing is None, then whether the function is monotonically\\n    increasing or decreasing is inferred from evaluating the function at the\\n    initial bounds. This can fail if there is numerically no variation in the\\n    data in this range. In this case, using different starting bounds or\\n    directly specifying ``increasing`` can make it possible to move the\\n    expansion in the right direction.\\n\\n    If\\n\\n    \"\n    (left, right) = (low, upp)\n    if upp is not None:\n        su = upp\n    elif start_upp is not None:\n        if start_upp < 0:\n            raise ValueError('start_upp needs to be positive')\n        su = start_upp\n    else:\n        su = 1.0\n    if low is not None:\n        sl = low\n    elif start_low is not None:\n        if start_low > 0:\n            raise ValueError('start_low needs to be negative')\n        sl = start_low\n    else:\n        sl = min(-1.0, su - 1.0)\n    if upp is None:\n        su = max(su, sl + 1.0)\n    if (low is None or upp is None) and increasing is None:\n        assert sl < su\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.max(np.abs(f_upp - f_low)) < 1e-15 and sl == -1 and (su == 1):\n            sl = 1e-08\n            f_low = func(sl, *args)\n            increasing = f_low < f_upp\n        delta = su - sl\n        if np.isnan(f_low):\n            for fraction in [0.25, 0.5, 0.75]:\n                sl_ = sl + fraction * delta\n                f_low = func(sl_, *args)\n                if not np.isnan(f_low):\n                    break\n            else:\n                raise ValueError('could not determine whether function is ' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        if np.isnan(f_upp):\n            for fraction in [0.25, 0.5, 0.75]:\n                su_ = su + fraction * delta\n                f_upp = func(su_, *args)\n                if not np.isnan(f_upp):\n                    break\n            else:\n                raise ValueError('could not determine whether function is' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        increasing = f_low < f_upp\n    if not increasing:\n        (sl, su) = (su, sl)\n        (left, right) = (right, left)\n    n_it = 0\n    if left is None and sl != 0:\n        left = sl\n        while func(left, *args) > 0:\n            right = left\n            left *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if right is None and su != 0:\n        right = su\n        while func(right, *args) < 0:\n            left = right\n            right *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if n_it >= max_it:\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.isnan(f_low) and np.isnan(f_upp):\n            raise ValueError('max_it reached' + '\\nthe function values at boths bounds are NaN' + '\\nchange the starting bounds, set bounds' + 'or increase max_it')\n    res = optimize.brentq(func, left, right, args=args, xtol=xtol, maxiter=maxiter_bq, full_output=full_output)\n    if full_output:\n        val = res[0]\n        info = Holder(root=res[1].root, iterations=res[1].iterations, function_calls=res[1].function_calls, converged=res[1].converged, flag=res[1].flag, iterations_expand=n_it, start_bounds=(sl, su), brentq_bounds=(left, right), increasing=increasing)\n        return (val, info)\n    else:\n        return res",
            "def brentq_expanding(func, low=None, upp=None, args=(), xtol=1e-05, start_low=None, start_upp=None, increasing=None, max_it=100, maxiter_bq=100, factor=10, full_output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"find the root of a function in one variable by expanding and brentq\\n\\n    Assumes function ``func`` is monotonic.\\n\\n    Parameters\\n    ----------\\n    func : callable\\n        function for which we find the root ``x`` such that ``func(x) = 0``\\n    low : float or None\\n        lower bound for brentq\\n    upp : float or None\\n        upper bound for brentq\\n    args : tuple\\n        optional additional arguments for ``func``\\n    xtol : float\\n        parameter x tolerance given to brentq\\n    start_low : float (positive) or None\\n        starting bound for expansion with increasing ``x``. It needs to be\\n        positive. If None, then it is set to 1.\\n    start_upp : float (negative) or None\\n        starting bound for expansion with decreasing ``x``. It needs to be\\n        negative. If None, then it is set to -1.\\n    increasing : bool or None\\n        If None, then the function is evaluated at the initial bounds to\\n        determine wether the function is increasing or not. If increasing is\\n        True (False), then it is assumed that the function is monotonically\\n        increasing (decreasing).\\n    max_it : int\\n        maximum number of expansion steps.\\n    maxiter_bq : int\\n        maximum number of iterations of brentq.\\n    factor : float\\n        expansion factor for step of shifting the bounds interval, default is\\n        10.\\n    full_output : bool, optional\\n        If full_output is False, the root is returned. If full_output is True,\\n        the return value is (x, r), where x is the root, and r is a\\n        RootResults object.\\n\\n\\n    Returns\\n    -------\\n    x : float\\n        root of the function, value at which ``func(x) = 0``.\\n    info : RootResult (optional)\\n        returned if ``full_output`` is True.\\n        attributes:\\n\\n         - start_bounds : starting bounds for expansion stage\\n         - brentq_bounds : bounds used with ``brentq``\\n         - iterations_expand : number of iterations in expansion stage\\n         - converged : True if brentq converged.\\n         - flag : return status, 'converged' if brentq converged\\n         - function_calls : number of function calls by ``brentq``\\n         - iterations : number of iterations in ``brentq``\\n\\n\\n    Notes\\n    -----\\n    If increasing is None, then whether the function is monotonically\\n    increasing or decreasing is inferred from evaluating the function at the\\n    initial bounds. This can fail if there is numerically no variation in the\\n    data in this range. In this case, using different starting bounds or\\n    directly specifying ``increasing`` can make it possible to move the\\n    expansion in the right direction.\\n\\n    If\\n\\n    \"\n    (left, right) = (low, upp)\n    if upp is not None:\n        su = upp\n    elif start_upp is not None:\n        if start_upp < 0:\n            raise ValueError('start_upp needs to be positive')\n        su = start_upp\n    else:\n        su = 1.0\n    if low is not None:\n        sl = low\n    elif start_low is not None:\n        if start_low > 0:\n            raise ValueError('start_low needs to be negative')\n        sl = start_low\n    else:\n        sl = min(-1.0, su - 1.0)\n    if upp is None:\n        su = max(su, sl + 1.0)\n    if (low is None or upp is None) and increasing is None:\n        assert sl < su\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.max(np.abs(f_upp - f_low)) < 1e-15 and sl == -1 and (su == 1):\n            sl = 1e-08\n            f_low = func(sl, *args)\n            increasing = f_low < f_upp\n        delta = su - sl\n        if np.isnan(f_low):\n            for fraction in [0.25, 0.5, 0.75]:\n                sl_ = sl + fraction * delta\n                f_low = func(sl_, *args)\n                if not np.isnan(f_low):\n                    break\n            else:\n                raise ValueError('could not determine whether function is ' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        if np.isnan(f_upp):\n            for fraction in [0.25, 0.5, 0.75]:\n                su_ = su + fraction * delta\n                f_upp = func(su_, *args)\n                if not np.isnan(f_upp):\n                    break\n            else:\n                raise ValueError('could not determine whether function is' + 'increasing based on starting interval.' + '\\nspecify increasing or change starting ' + 'bounds')\n        increasing = f_low < f_upp\n    if not increasing:\n        (sl, su) = (su, sl)\n        (left, right) = (right, left)\n    n_it = 0\n    if left is None and sl != 0:\n        left = sl\n        while func(left, *args) > 0:\n            right = left\n            left *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if right is None and su != 0:\n        right = su\n        while func(right, *args) < 0:\n            left = right\n            right *= factor\n            if n_it >= max_it:\n                break\n            n_it += 1\n    if n_it >= max_it:\n        f_low = func(sl, *args)\n        f_upp = func(su, *args)\n        if np.isnan(f_low) and np.isnan(f_upp):\n            raise ValueError('max_it reached' + '\\nthe function values at boths bounds are NaN' + '\\nchange the starting bounds, set bounds' + 'or increase max_it')\n    res = optimize.brentq(func, left, right, args=args, xtol=xtol, maxiter=maxiter_bq, full_output=full_output)\n    if full_output:\n        val = res[0]\n        info = Holder(root=res[1].root, iterations=res[1].iterations, function_calls=res[1].function_calls, converged=res[1].converged, flag=res[1].flag, iterations_expand=n_it, start_bounds=(sl, su), brentq_bounds=(left, right), increasing=increasing)\n        return (val, info)\n    else:\n        return res"
        ]
    }
]