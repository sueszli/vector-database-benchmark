[
    {
        "func_name": "__init__",
        "original": "def __init__(self, y, x, groups=None, het=False, data=None, meta=None):\n    if groups is None:\n        raise ValueError('use OLS if there are no groups')\n    if data:\n        y = data[y]\n        x = [data[v] for v in x]\n        try:\n            groups = data[groups]\n        except [KeyError, ValueError]:\n            pass\n    self.endog = np.asarray(y)\n    self.exog = np.asarray(x)\n    if self.exog.ndim == 1:\n        self.exog = self.exog[:, None]\n    self.groups = np.asarray(groups)\n    self.het = het\n    self.groupsint = None\n    if np.issubdtype(self.groups.dtype, int):\n        self.unique = np.unique(self.groups)\n        if (self.unique == np.arange(len(self.unique))).all():\n            self.groupsint = self.groups\n    if self.groupsint is None:\n        (self.unique, self.groupsint) = np.unique(self.groups, return_inverse=True)\n    self.uniqueint = np.arange(len(self.unique))",
        "mutated": [
            "def __init__(self, y, x, groups=None, het=False, data=None, meta=None):\n    if False:\n        i = 10\n    if groups is None:\n        raise ValueError('use OLS if there are no groups')\n    if data:\n        y = data[y]\n        x = [data[v] for v in x]\n        try:\n            groups = data[groups]\n        except [KeyError, ValueError]:\n            pass\n    self.endog = np.asarray(y)\n    self.exog = np.asarray(x)\n    if self.exog.ndim == 1:\n        self.exog = self.exog[:, None]\n    self.groups = np.asarray(groups)\n    self.het = het\n    self.groupsint = None\n    if np.issubdtype(self.groups.dtype, int):\n        self.unique = np.unique(self.groups)\n        if (self.unique == np.arange(len(self.unique))).all():\n            self.groupsint = self.groups\n    if self.groupsint is None:\n        (self.unique, self.groupsint) = np.unique(self.groups, return_inverse=True)\n    self.uniqueint = np.arange(len(self.unique))",
            "def __init__(self, y, x, groups=None, het=False, data=None, meta=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if groups is None:\n        raise ValueError('use OLS if there are no groups')\n    if data:\n        y = data[y]\n        x = [data[v] for v in x]\n        try:\n            groups = data[groups]\n        except [KeyError, ValueError]:\n            pass\n    self.endog = np.asarray(y)\n    self.exog = np.asarray(x)\n    if self.exog.ndim == 1:\n        self.exog = self.exog[:, None]\n    self.groups = np.asarray(groups)\n    self.het = het\n    self.groupsint = None\n    if np.issubdtype(self.groups.dtype, int):\n        self.unique = np.unique(self.groups)\n        if (self.unique == np.arange(len(self.unique))).all():\n            self.groupsint = self.groups\n    if self.groupsint is None:\n        (self.unique, self.groupsint) = np.unique(self.groups, return_inverse=True)\n    self.uniqueint = np.arange(len(self.unique))",
            "def __init__(self, y, x, groups=None, het=False, data=None, meta=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if groups is None:\n        raise ValueError('use OLS if there are no groups')\n    if data:\n        y = data[y]\n        x = [data[v] for v in x]\n        try:\n            groups = data[groups]\n        except [KeyError, ValueError]:\n            pass\n    self.endog = np.asarray(y)\n    self.exog = np.asarray(x)\n    if self.exog.ndim == 1:\n        self.exog = self.exog[:, None]\n    self.groups = np.asarray(groups)\n    self.het = het\n    self.groupsint = None\n    if np.issubdtype(self.groups.dtype, int):\n        self.unique = np.unique(self.groups)\n        if (self.unique == np.arange(len(self.unique))).all():\n            self.groupsint = self.groups\n    if self.groupsint is None:\n        (self.unique, self.groupsint) = np.unique(self.groups, return_inverse=True)\n    self.uniqueint = np.arange(len(self.unique))",
            "def __init__(self, y, x, groups=None, het=False, data=None, meta=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if groups is None:\n        raise ValueError('use OLS if there are no groups')\n    if data:\n        y = data[y]\n        x = [data[v] for v in x]\n        try:\n            groups = data[groups]\n        except [KeyError, ValueError]:\n            pass\n    self.endog = np.asarray(y)\n    self.exog = np.asarray(x)\n    if self.exog.ndim == 1:\n        self.exog = self.exog[:, None]\n    self.groups = np.asarray(groups)\n    self.het = het\n    self.groupsint = None\n    if np.issubdtype(self.groups.dtype, int):\n        self.unique = np.unique(self.groups)\n        if (self.unique == np.arange(len(self.unique))).all():\n            self.groupsint = self.groups\n    if self.groupsint is None:\n        (self.unique, self.groupsint) = np.unique(self.groups, return_inverse=True)\n    self.uniqueint = np.arange(len(self.unique))",
            "def __init__(self, y, x, groups=None, het=False, data=None, meta=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if groups is None:\n        raise ValueError('use OLS if there are no groups')\n    if data:\n        y = data[y]\n        x = [data[v] for v in x]\n        try:\n            groups = data[groups]\n        except [KeyError, ValueError]:\n            pass\n    self.endog = np.asarray(y)\n    self.exog = np.asarray(x)\n    if self.exog.ndim == 1:\n        self.exog = self.exog[:, None]\n    self.groups = np.asarray(groups)\n    self.het = het\n    self.groupsint = None\n    if np.issubdtype(self.groups.dtype, int):\n        self.unique = np.unique(self.groups)\n        if (self.unique == np.arange(len(self.unique))).all():\n            self.groupsint = self.groups\n    if self.groupsint is None:\n        (self.unique, self.groupsint) = np.unique(self.groups, return_inverse=True)\n    self.uniqueint = np.arange(len(self.unique))"
        ]
    },
    {
        "func_name": "fitbygroups",
        "original": "def fitbygroups(self):\n    \"\"\"Fit OLS regression for each group separately.\n\n        Returns\n        -------\n        results are attached\n\n        olsbygroup : dictionary of result instance\n            the returned regression results for each group\n        sigmabygroup : array (ngroups,) (this should be called sigma2group ??? check)\n            mse_resid for each group\n        weights : array (nobs,)\n            standard deviation of group extended to the original observations. This can\n            be used as weights in WLS for group-wise heteroscedasticity.\n\n\n\n        \"\"\"\n    olsbygroup = {}\n    sigmabygroup = []\n    for (gi, group) in enumerate(self.unique):\n        groupmask = self.groupsint == gi\n        res = OLS(self.endog[groupmask], self.exog[groupmask]).fit()\n        olsbygroup[group] = res\n        sigmabygroup.append(res.mse_resid)\n    self.olsbygroup = olsbygroup\n    self.sigmabygroup = np.array(sigmabygroup)\n    self.weights = np.sqrt(self.sigmabygroup[self.groupsint])",
        "mutated": [
            "def fitbygroups(self):\n    if False:\n        i = 10\n    'Fit OLS regression for each group separately.\\n\\n        Returns\\n        -------\\n        results are attached\\n\\n        olsbygroup : dictionary of result instance\\n            the returned regression results for each group\\n        sigmabygroup : array (ngroups,) (this should be called sigma2group ??? check)\\n            mse_resid for each group\\n        weights : array (nobs,)\\n            standard deviation of group extended to the original observations. This can\\n            be used as weights in WLS for group-wise heteroscedasticity.\\n\\n\\n\\n        '\n    olsbygroup = {}\n    sigmabygroup = []\n    for (gi, group) in enumerate(self.unique):\n        groupmask = self.groupsint == gi\n        res = OLS(self.endog[groupmask], self.exog[groupmask]).fit()\n        olsbygroup[group] = res\n        sigmabygroup.append(res.mse_resid)\n    self.olsbygroup = olsbygroup\n    self.sigmabygroup = np.array(sigmabygroup)\n    self.weights = np.sqrt(self.sigmabygroup[self.groupsint])",
            "def fitbygroups(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fit OLS regression for each group separately.\\n\\n        Returns\\n        -------\\n        results are attached\\n\\n        olsbygroup : dictionary of result instance\\n            the returned regression results for each group\\n        sigmabygroup : array (ngroups,) (this should be called sigma2group ??? check)\\n            mse_resid for each group\\n        weights : array (nobs,)\\n            standard deviation of group extended to the original observations. This can\\n            be used as weights in WLS for group-wise heteroscedasticity.\\n\\n\\n\\n        '\n    olsbygroup = {}\n    sigmabygroup = []\n    for (gi, group) in enumerate(self.unique):\n        groupmask = self.groupsint == gi\n        res = OLS(self.endog[groupmask], self.exog[groupmask]).fit()\n        olsbygroup[group] = res\n        sigmabygroup.append(res.mse_resid)\n    self.olsbygroup = olsbygroup\n    self.sigmabygroup = np.array(sigmabygroup)\n    self.weights = np.sqrt(self.sigmabygroup[self.groupsint])",
            "def fitbygroups(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fit OLS regression for each group separately.\\n\\n        Returns\\n        -------\\n        results are attached\\n\\n        olsbygroup : dictionary of result instance\\n            the returned regression results for each group\\n        sigmabygroup : array (ngroups,) (this should be called sigma2group ??? check)\\n            mse_resid for each group\\n        weights : array (nobs,)\\n            standard deviation of group extended to the original observations. This can\\n            be used as weights in WLS for group-wise heteroscedasticity.\\n\\n\\n\\n        '\n    olsbygroup = {}\n    sigmabygroup = []\n    for (gi, group) in enumerate(self.unique):\n        groupmask = self.groupsint == gi\n        res = OLS(self.endog[groupmask], self.exog[groupmask]).fit()\n        olsbygroup[group] = res\n        sigmabygroup.append(res.mse_resid)\n    self.olsbygroup = olsbygroup\n    self.sigmabygroup = np.array(sigmabygroup)\n    self.weights = np.sqrt(self.sigmabygroup[self.groupsint])",
            "def fitbygroups(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fit OLS regression for each group separately.\\n\\n        Returns\\n        -------\\n        results are attached\\n\\n        olsbygroup : dictionary of result instance\\n            the returned regression results for each group\\n        sigmabygroup : array (ngroups,) (this should be called sigma2group ??? check)\\n            mse_resid for each group\\n        weights : array (nobs,)\\n            standard deviation of group extended to the original observations. This can\\n            be used as weights in WLS for group-wise heteroscedasticity.\\n\\n\\n\\n        '\n    olsbygroup = {}\n    sigmabygroup = []\n    for (gi, group) in enumerate(self.unique):\n        groupmask = self.groupsint == gi\n        res = OLS(self.endog[groupmask], self.exog[groupmask]).fit()\n        olsbygroup[group] = res\n        sigmabygroup.append(res.mse_resid)\n    self.olsbygroup = olsbygroup\n    self.sigmabygroup = np.array(sigmabygroup)\n    self.weights = np.sqrt(self.sigmabygroup[self.groupsint])",
            "def fitbygroups(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fit OLS regression for each group separately.\\n\\n        Returns\\n        -------\\n        results are attached\\n\\n        olsbygroup : dictionary of result instance\\n            the returned regression results for each group\\n        sigmabygroup : array (ngroups,) (this should be called sigma2group ??? check)\\n            mse_resid for each group\\n        weights : array (nobs,)\\n            standard deviation of group extended to the original observations. This can\\n            be used as weights in WLS for group-wise heteroscedasticity.\\n\\n\\n\\n        '\n    olsbygroup = {}\n    sigmabygroup = []\n    for (gi, group) in enumerate(self.unique):\n        groupmask = self.groupsint == gi\n        res = OLS(self.endog[groupmask], self.exog[groupmask]).fit()\n        olsbygroup[group] = res\n        sigmabygroup.append(res.mse_resid)\n    self.olsbygroup = olsbygroup\n    self.sigmabygroup = np.array(sigmabygroup)\n    self.weights = np.sqrt(self.sigmabygroup[self.groupsint])"
        ]
    },
    {
        "func_name": "fitjoint",
        "original": "def fitjoint(self):\n    \"\"\"fit a joint fixed effects model to all observations\n\n        The regression results are attached as `lsjoint`.\n\n        The contrasts for overall and pairwise tests for equality of coefficients are\n        attached as a dictionary `contrasts`. This also includes the contrasts for the test\n        that the coefficients of a level are zero. ::\n\n        >>> res.contrasts.keys()\n        [(0, 1), 1, 'all', 3, (1, 2), 2, (1, 3), (2, 3), (0, 3), (0, 2)]\n\n        The keys are based on the original names or labels of the groups.\n\n        TODO: keys can be numpy scalars and then the keys cannot be sorted\n\n\n\n        \"\"\"\n    if not hasattr(self, 'weights'):\n        self.fitbygroups()\n    groupdummy = (self.groupsint[:, None] == self.uniqueint).astype(int)\n    dummyexog = self.exog[:, None, :] * groupdummy[:, 1:, None]\n    exog = np.c_[self.exog, dummyexog.reshape(self.exog.shape[0], -1)]\n    if self.het:\n        weights = self.weights\n        res = WLS(self.endog, exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, exog).fit()\n    self.lsjoint = res\n    contrasts = {}\n    nvars = self.exog.shape[1]\n    nparams = exog.shape[1]\n    ndummies = nparams - nvars\n    contrasts['all'] = np.c_[np.zeros((ndummies, nvars)), np.eye(ndummies)]\n    for (groupind, group) in enumerate(self.unique[1:]):\n        groupind = groupind + 1\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * groupind:nvars * (groupind + 1)] = np.eye(nvars)\n        contrasts[group] = contr\n        contrasts[self.unique[0], group] = contr\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        if ind1 == 0:\n            continue\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        group = (g1, g2)\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * ind1:nvars * (ind1 + 1)] = np.eye(nvars)\n        contr[:, nvars * ind2:nvars * (ind2 + 1)] = -np.eye(nvars)\n        contrasts[group] = contr\n    self.contrasts = contrasts",
        "mutated": [
            "def fitjoint(self):\n    if False:\n        i = 10\n    \"fit a joint fixed effects model to all observations\\n\\n        The regression results are attached as `lsjoint`.\\n\\n        The contrasts for overall and pairwise tests for equality of coefficients are\\n        attached as a dictionary `contrasts`. This also includes the contrasts for the test\\n        that the coefficients of a level are zero. ::\\n\\n        >>> res.contrasts.keys()\\n        [(0, 1), 1, 'all', 3, (1, 2), 2, (1, 3), (2, 3), (0, 3), (0, 2)]\\n\\n        The keys are based on the original names or labels of the groups.\\n\\n        TODO: keys can be numpy scalars and then the keys cannot be sorted\\n\\n\\n\\n        \"\n    if not hasattr(self, 'weights'):\n        self.fitbygroups()\n    groupdummy = (self.groupsint[:, None] == self.uniqueint).astype(int)\n    dummyexog = self.exog[:, None, :] * groupdummy[:, 1:, None]\n    exog = np.c_[self.exog, dummyexog.reshape(self.exog.shape[0], -1)]\n    if self.het:\n        weights = self.weights\n        res = WLS(self.endog, exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, exog).fit()\n    self.lsjoint = res\n    contrasts = {}\n    nvars = self.exog.shape[1]\n    nparams = exog.shape[1]\n    ndummies = nparams - nvars\n    contrasts['all'] = np.c_[np.zeros((ndummies, nvars)), np.eye(ndummies)]\n    for (groupind, group) in enumerate(self.unique[1:]):\n        groupind = groupind + 1\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * groupind:nvars * (groupind + 1)] = np.eye(nvars)\n        contrasts[group] = contr\n        contrasts[self.unique[0], group] = contr\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        if ind1 == 0:\n            continue\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        group = (g1, g2)\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * ind1:nvars * (ind1 + 1)] = np.eye(nvars)\n        contr[:, nvars * ind2:nvars * (ind2 + 1)] = -np.eye(nvars)\n        contrasts[group] = contr\n    self.contrasts = contrasts",
            "def fitjoint(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"fit a joint fixed effects model to all observations\\n\\n        The regression results are attached as `lsjoint`.\\n\\n        The contrasts for overall and pairwise tests for equality of coefficients are\\n        attached as a dictionary `contrasts`. This also includes the contrasts for the test\\n        that the coefficients of a level are zero. ::\\n\\n        >>> res.contrasts.keys()\\n        [(0, 1), 1, 'all', 3, (1, 2), 2, (1, 3), (2, 3), (0, 3), (0, 2)]\\n\\n        The keys are based on the original names or labels of the groups.\\n\\n        TODO: keys can be numpy scalars and then the keys cannot be sorted\\n\\n\\n\\n        \"\n    if not hasattr(self, 'weights'):\n        self.fitbygroups()\n    groupdummy = (self.groupsint[:, None] == self.uniqueint).astype(int)\n    dummyexog = self.exog[:, None, :] * groupdummy[:, 1:, None]\n    exog = np.c_[self.exog, dummyexog.reshape(self.exog.shape[0], -1)]\n    if self.het:\n        weights = self.weights\n        res = WLS(self.endog, exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, exog).fit()\n    self.lsjoint = res\n    contrasts = {}\n    nvars = self.exog.shape[1]\n    nparams = exog.shape[1]\n    ndummies = nparams - nvars\n    contrasts['all'] = np.c_[np.zeros((ndummies, nvars)), np.eye(ndummies)]\n    for (groupind, group) in enumerate(self.unique[1:]):\n        groupind = groupind + 1\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * groupind:nvars * (groupind + 1)] = np.eye(nvars)\n        contrasts[group] = contr\n        contrasts[self.unique[0], group] = contr\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        if ind1 == 0:\n            continue\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        group = (g1, g2)\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * ind1:nvars * (ind1 + 1)] = np.eye(nvars)\n        contr[:, nvars * ind2:nvars * (ind2 + 1)] = -np.eye(nvars)\n        contrasts[group] = contr\n    self.contrasts = contrasts",
            "def fitjoint(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"fit a joint fixed effects model to all observations\\n\\n        The regression results are attached as `lsjoint`.\\n\\n        The contrasts for overall and pairwise tests for equality of coefficients are\\n        attached as a dictionary `contrasts`. This also includes the contrasts for the test\\n        that the coefficients of a level are zero. ::\\n\\n        >>> res.contrasts.keys()\\n        [(0, 1), 1, 'all', 3, (1, 2), 2, (1, 3), (2, 3), (0, 3), (0, 2)]\\n\\n        The keys are based on the original names or labels of the groups.\\n\\n        TODO: keys can be numpy scalars and then the keys cannot be sorted\\n\\n\\n\\n        \"\n    if not hasattr(self, 'weights'):\n        self.fitbygroups()\n    groupdummy = (self.groupsint[:, None] == self.uniqueint).astype(int)\n    dummyexog = self.exog[:, None, :] * groupdummy[:, 1:, None]\n    exog = np.c_[self.exog, dummyexog.reshape(self.exog.shape[0], -1)]\n    if self.het:\n        weights = self.weights\n        res = WLS(self.endog, exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, exog).fit()\n    self.lsjoint = res\n    contrasts = {}\n    nvars = self.exog.shape[1]\n    nparams = exog.shape[1]\n    ndummies = nparams - nvars\n    contrasts['all'] = np.c_[np.zeros((ndummies, nvars)), np.eye(ndummies)]\n    for (groupind, group) in enumerate(self.unique[1:]):\n        groupind = groupind + 1\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * groupind:nvars * (groupind + 1)] = np.eye(nvars)\n        contrasts[group] = contr\n        contrasts[self.unique[0], group] = contr\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        if ind1 == 0:\n            continue\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        group = (g1, g2)\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * ind1:nvars * (ind1 + 1)] = np.eye(nvars)\n        contr[:, nvars * ind2:nvars * (ind2 + 1)] = -np.eye(nvars)\n        contrasts[group] = contr\n    self.contrasts = contrasts",
            "def fitjoint(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"fit a joint fixed effects model to all observations\\n\\n        The regression results are attached as `lsjoint`.\\n\\n        The contrasts for overall and pairwise tests for equality of coefficients are\\n        attached as a dictionary `contrasts`. This also includes the contrasts for the test\\n        that the coefficients of a level are zero. ::\\n\\n        >>> res.contrasts.keys()\\n        [(0, 1), 1, 'all', 3, (1, 2), 2, (1, 3), (2, 3), (0, 3), (0, 2)]\\n\\n        The keys are based on the original names or labels of the groups.\\n\\n        TODO: keys can be numpy scalars and then the keys cannot be sorted\\n\\n\\n\\n        \"\n    if not hasattr(self, 'weights'):\n        self.fitbygroups()\n    groupdummy = (self.groupsint[:, None] == self.uniqueint).astype(int)\n    dummyexog = self.exog[:, None, :] * groupdummy[:, 1:, None]\n    exog = np.c_[self.exog, dummyexog.reshape(self.exog.shape[0], -1)]\n    if self.het:\n        weights = self.weights\n        res = WLS(self.endog, exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, exog).fit()\n    self.lsjoint = res\n    contrasts = {}\n    nvars = self.exog.shape[1]\n    nparams = exog.shape[1]\n    ndummies = nparams - nvars\n    contrasts['all'] = np.c_[np.zeros((ndummies, nvars)), np.eye(ndummies)]\n    for (groupind, group) in enumerate(self.unique[1:]):\n        groupind = groupind + 1\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * groupind:nvars * (groupind + 1)] = np.eye(nvars)\n        contrasts[group] = contr\n        contrasts[self.unique[0], group] = contr\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        if ind1 == 0:\n            continue\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        group = (g1, g2)\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * ind1:nvars * (ind1 + 1)] = np.eye(nvars)\n        contr[:, nvars * ind2:nvars * (ind2 + 1)] = -np.eye(nvars)\n        contrasts[group] = contr\n    self.contrasts = contrasts",
            "def fitjoint(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"fit a joint fixed effects model to all observations\\n\\n        The regression results are attached as `lsjoint`.\\n\\n        The contrasts for overall and pairwise tests for equality of coefficients are\\n        attached as a dictionary `contrasts`. This also includes the contrasts for the test\\n        that the coefficients of a level are zero. ::\\n\\n        >>> res.contrasts.keys()\\n        [(0, 1), 1, 'all', 3, (1, 2), 2, (1, 3), (2, 3), (0, 3), (0, 2)]\\n\\n        The keys are based on the original names or labels of the groups.\\n\\n        TODO: keys can be numpy scalars and then the keys cannot be sorted\\n\\n\\n\\n        \"\n    if not hasattr(self, 'weights'):\n        self.fitbygroups()\n    groupdummy = (self.groupsint[:, None] == self.uniqueint).astype(int)\n    dummyexog = self.exog[:, None, :] * groupdummy[:, 1:, None]\n    exog = np.c_[self.exog, dummyexog.reshape(self.exog.shape[0], -1)]\n    if self.het:\n        weights = self.weights\n        res = WLS(self.endog, exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, exog).fit()\n    self.lsjoint = res\n    contrasts = {}\n    nvars = self.exog.shape[1]\n    nparams = exog.shape[1]\n    ndummies = nparams - nvars\n    contrasts['all'] = np.c_[np.zeros((ndummies, nvars)), np.eye(ndummies)]\n    for (groupind, group) in enumerate(self.unique[1:]):\n        groupind = groupind + 1\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * groupind:nvars * (groupind + 1)] = np.eye(nvars)\n        contrasts[group] = contr\n        contrasts[self.unique[0], group] = contr\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        if ind1 == 0:\n            continue\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        group = (g1, g2)\n        contr = np.zeros((nvars, nparams))\n        contr[:, nvars * ind1:nvars * (ind1 + 1)] = np.eye(nvars)\n        contr[:, nvars * ind2:nvars * (ind2 + 1)] = -np.eye(nvars)\n        contrasts[group] = contr\n    self.contrasts = contrasts"
        ]
    },
    {
        "func_name": "fitpooled",
        "original": "def fitpooled(self):\n    \"\"\"fit the pooled model, which assumes there are no differences across groups\n        \"\"\"\n    if self.het:\n        if not hasattr(self, 'weights'):\n            self.fitbygroups()\n        weights = self.weights\n        res = WLS(self.endog, self.exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, self.exog).fit()\n    self.lspooled = res",
        "mutated": [
            "def fitpooled(self):\n    if False:\n        i = 10\n    'fit the pooled model, which assumes there are no differences across groups\\n        '\n    if self.het:\n        if not hasattr(self, 'weights'):\n            self.fitbygroups()\n        weights = self.weights\n        res = WLS(self.endog, self.exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, self.exog).fit()\n    self.lspooled = res",
            "def fitpooled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'fit the pooled model, which assumes there are no differences across groups\\n        '\n    if self.het:\n        if not hasattr(self, 'weights'):\n            self.fitbygroups()\n        weights = self.weights\n        res = WLS(self.endog, self.exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, self.exog).fit()\n    self.lspooled = res",
            "def fitpooled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'fit the pooled model, which assumes there are no differences across groups\\n        '\n    if self.het:\n        if not hasattr(self, 'weights'):\n            self.fitbygroups()\n        weights = self.weights\n        res = WLS(self.endog, self.exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, self.exog).fit()\n    self.lspooled = res",
            "def fitpooled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'fit the pooled model, which assumes there are no differences across groups\\n        '\n    if self.het:\n        if not hasattr(self, 'weights'):\n            self.fitbygroups()\n        weights = self.weights\n        res = WLS(self.endog, self.exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, self.exog).fit()\n    self.lspooled = res",
            "def fitpooled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'fit the pooled model, which assumes there are no differences across groups\\n        '\n    if self.het:\n        if not hasattr(self, 'weights'):\n            self.fitbygroups()\n        weights = self.weights\n        res = WLS(self.endog, self.exog, weights=weights).fit()\n    else:\n        res = OLS(self.endog, self.exog).fit()\n    self.lspooled = res"
        ]
    },
    {
        "func_name": "ftest_summary",
        "original": "def ftest_summary(self):\n    \"\"\"run all ftests on the joint model\n\n        Returns\n        -------\n        fres : str\n           a string that lists the results of all individual f-tests\n        summarytable : list of tuples\n           contains (pair, (fvalue, pvalue,df_denom, df_num)) for each f-test\n\n        Note\n        ----\n        This are the raw results and not formatted for nice printing.\n\n        \"\"\"\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    txt = []\n    summarytable = []\n    txt.append('F-test for equality of coefficients across groups')\n    fres = self.lsjoint.f_test(self.contrasts['all'])\n    txt.append(fres.__str__())\n    summarytable.append(('all', (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        txt.append('F-test for equality of coefficients between group %s and group %s' % (g1, g2))\n        group = (g1, g2)\n        fres = self.lsjoint.f_test(self.contrasts[group])\n        txt.append(fres.__str__())\n        summarytable.append((group, (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    self.summarytable = summarytable\n    return ('\\n'.join(txt), summarytable)",
        "mutated": [
            "def ftest_summary(self):\n    if False:\n        i = 10\n    'run all ftests on the joint model\\n\\n        Returns\\n        -------\\n        fres : str\\n           a string that lists the results of all individual f-tests\\n        summarytable : list of tuples\\n           contains (pair, (fvalue, pvalue,df_denom, df_num)) for each f-test\\n\\n        Note\\n        ----\\n        This are the raw results and not formatted for nice printing.\\n\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    txt = []\n    summarytable = []\n    txt.append('F-test for equality of coefficients across groups')\n    fres = self.lsjoint.f_test(self.contrasts['all'])\n    txt.append(fres.__str__())\n    summarytable.append(('all', (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        txt.append('F-test for equality of coefficients between group %s and group %s' % (g1, g2))\n        group = (g1, g2)\n        fres = self.lsjoint.f_test(self.contrasts[group])\n        txt.append(fres.__str__())\n        summarytable.append((group, (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    self.summarytable = summarytable\n    return ('\\n'.join(txt), summarytable)",
            "def ftest_summary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'run all ftests on the joint model\\n\\n        Returns\\n        -------\\n        fres : str\\n           a string that lists the results of all individual f-tests\\n        summarytable : list of tuples\\n           contains (pair, (fvalue, pvalue,df_denom, df_num)) for each f-test\\n\\n        Note\\n        ----\\n        This are the raw results and not formatted for nice printing.\\n\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    txt = []\n    summarytable = []\n    txt.append('F-test for equality of coefficients across groups')\n    fres = self.lsjoint.f_test(self.contrasts['all'])\n    txt.append(fres.__str__())\n    summarytable.append(('all', (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        txt.append('F-test for equality of coefficients between group %s and group %s' % (g1, g2))\n        group = (g1, g2)\n        fres = self.lsjoint.f_test(self.contrasts[group])\n        txt.append(fres.__str__())\n        summarytable.append((group, (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    self.summarytable = summarytable\n    return ('\\n'.join(txt), summarytable)",
            "def ftest_summary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'run all ftests on the joint model\\n\\n        Returns\\n        -------\\n        fres : str\\n           a string that lists the results of all individual f-tests\\n        summarytable : list of tuples\\n           contains (pair, (fvalue, pvalue,df_denom, df_num)) for each f-test\\n\\n        Note\\n        ----\\n        This are the raw results and not formatted for nice printing.\\n\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    txt = []\n    summarytable = []\n    txt.append('F-test for equality of coefficients across groups')\n    fres = self.lsjoint.f_test(self.contrasts['all'])\n    txt.append(fres.__str__())\n    summarytable.append(('all', (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        txt.append('F-test for equality of coefficients between group %s and group %s' % (g1, g2))\n        group = (g1, g2)\n        fres = self.lsjoint.f_test(self.contrasts[group])\n        txt.append(fres.__str__())\n        summarytable.append((group, (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    self.summarytable = summarytable\n    return ('\\n'.join(txt), summarytable)",
            "def ftest_summary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'run all ftests on the joint model\\n\\n        Returns\\n        -------\\n        fres : str\\n           a string that lists the results of all individual f-tests\\n        summarytable : list of tuples\\n           contains (pair, (fvalue, pvalue,df_denom, df_num)) for each f-test\\n\\n        Note\\n        ----\\n        This are the raw results and not formatted for nice printing.\\n\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    txt = []\n    summarytable = []\n    txt.append('F-test for equality of coefficients across groups')\n    fres = self.lsjoint.f_test(self.contrasts['all'])\n    txt.append(fres.__str__())\n    summarytable.append(('all', (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        txt.append('F-test for equality of coefficients between group %s and group %s' % (g1, g2))\n        group = (g1, g2)\n        fres = self.lsjoint.f_test(self.contrasts[group])\n        txt.append(fres.__str__())\n        summarytable.append((group, (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    self.summarytable = summarytable\n    return ('\\n'.join(txt), summarytable)",
            "def ftest_summary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'run all ftests on the joint model\\n\\n        Returns\\n        -------\\n        fres : str\\n           a string that lists the results of all individual f-tests\\n        summarytable : list of tuples\\n           contains (pair, (fvalue, pvalue,df_denom, df_num)) for each f-test\\n\\n        Note\\n        ----\\n        This are the raw results and not formatted for nice printing.\\n\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    txt = []\n    summarytable = []\n    txt.append('F-test for equality of coefficients across groups')\n    fres = self.lsjoint.f_test(self.contrasts['all'])\n    txt.append(fres.__str__())\n    summarytable.append(('all', (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    pairs = np.triu_indices(len(self.unique), 1)\n    for (ind1, ind2) in zip(*pairs):\n        g1 = self.unique[ind1]\n        g2 = self.unique[ind2]\n        txt.append('F-test for equality of coefficients between group %s and group %s' % (g1, g2))\n        group = (g1, g2)\n        fres = self.lsjoint.f_test(self.contrasts[group])\n        txt.append(fres.__str__())\n        summarytable.append((group, (fres.fvalue, fres.pvalue, fres.df_denom, fres.df_num)))\n    self.summarytable = summarytable\n    return ('\\n'.join(txt), summarytable)"
        ]
    },
    {
        "func_name": "print_summary",
        "original": "def print_summary(self, res):\n    \"\"\"printable string of summary\n\n        \"\"\"\n    groupind = res.groups\n    if hasattr(res, 'self.summarytable'):\n        summtable = self.summarytable\n    else:\n        (_, summtable) = res.ftest_summary()\n    txt = ''\n    templ = \"Table of F-tests for overall or pairwise equality of coefficients'\\n%(tab)s\\n\\n\\nNotes: p-values are not corrected for many tests\\n       (no Bonferroni correction)\\n       * : reject at 5%% uncorrected confidence level\\nNull hypothesis: all or pairwise coefficient are the same'\\nAlternative hypothesis: all coefficients are different'\\n\\n\\nComparison with stats.f_oneway\\n%(statsfow)s\\n\\n\\nLikelihood Ratio Test\\n%(lrtest)s\\nNull model: pooled all coefficients are the same across groups,'\\nAlternative model: all coefficients are allowed to be different'\\nnot verified but looks close to f-test result'\\n\\n\\nOLS parameters by group from individual, separate ols regressions'\\n%(olsbg)s\\nfor group in sorted(res.olsbygroup):\\n    r = res.olsbygroup[group]\\n    print group, r.params\\n\\n\\nCheck for heteroscedasticity, '\\nvariance and standard deviation for individual regressions'\\n%(grh)s\\nvariance    ', res.sigmabygroup\\nstandard dev', np.sqrt(res.sigmabygroup)\\n\"\n    from statsmodels.iolib import SimpleTable\n    resvals = {}\n    resvals['tab'] = str(SimpleTable([['%r' % (row[0],)] + list(row[1]) + ['*'] * (row[1][1] > 0.5).item() for row in summtable], headers=['pair', 'F-statistic', 'p-value', 'df_denom', 'df_num']))\n    resvals['statsfow'] = str(stats.f_oneway(*[res.endog[groupind == gr] for gr in res.unique]))\n    resvals['lrtest'] = str(SimpleTable([res.lr_test()], headers=['likelihood ratio', 'p-value', 'df']))\n    resvals['olsbg'] = str(SimpleTable([[group] + res.olsbygroup[group].params.tolist() for group in sorted(res.olsbygroup)]))\n    resvals['grh'] = str(SimpleTable(np.vstack([res.sigmabygroup, np.sqrt(res.sigmabygroup)]), headers=res.unique.tolist()))\n    return templ % resvals",
        "mutated": [
            "def print_summary(self, res):\n    if False:\n        i = 10\n    'printable string of summary\\n\\n        '\n    groupind = res.groups\n    if hasattr(res, 'self.summarytable'):\n        summtable = self.summarytable\n    else:\n        (_, summtable) = res.ftest_summary()\n    txt = ''\n    templ = \"Table of F-tests for overall or pairwise equality of coefficients'\\n%(tab)s\\n\\n\\nNotes: p-values are not corrected for many tests\\n       (no Bonferroni correction)\\n       * : reject at 5%% uncorrected confidence level\\nNull hypothesis: all or pairwise coefficient are the same'\\nAlternative hypothesis: all coefficients are different'\\n\\n\\nComparison with stats.f_oneway\\n%(statsfow)s\\n\\n\\nLikelihood Ratio Test\\n%(lrtest)s\\nNull model: pooled all coefficients are the same across groups,'\\nAlternative model: all coefficients are allowed to be different'\\nnot verified but looks close to f-test result'\\n\\n\\nOLS parameters by group from individual, separate ols regressions'\\n%(olsbg)s\\nfor group in sorted(res.olsbygroup):\\n    r = res.olsbygroup[group]\\n    print group, r.params\\n\\n\\nCheck for heteroscedasticity, '\\nvariance and standard deviation for individual regressions'\\n%(grh)s\\nvariance    ', res.sigmabygroup\\nstandard dev', np.sqrt(res.sigmabygroup)\\n\"\n    from statsmodels.iolib import SimpleTable\n    resvals = {}\n    resvals['tab'] = str(SimpleTable([['%r' % (row[0],)] + list(row[1]) + ['*'] * (row[1][1] > 0.5).item() for row in summtable], headers=['pair', 'F-statistic', 'p-value', 'df_denom', 'df_num']))\n    resvals['statsfow'] = str(stats.f_oneway(*[res.endog[groupind == gr] for gr in res.unique]))\n    resvals['lrtest'] = str(SimpleTable([res.lr_test()], headers=['likelihood ratio', 'p-value', 'df']))\n    resvals['olsbg'] = str(SimpleTable([[group] + res.olsbygroup[group].params.tolist() for group in sorted(res.olsbygroup)]))\n    resvals['grh'] = str(SimpleTable(np.vstack([res.sigmabygroup, np.sqrt(res.sigmabygroup)]), headers=res.unique.tolist()))\n    return templ % resvals",
            "def print_summary(self, res):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'printable string of summary\\n\\n        '\n    groupind = res.groups\n    if hasattr(res, 'self.summarytable'):\n        summtable = self.summarytable\n    else:\n        (_, summtable) = res.ftest_summary()\n    txt = ''\n    templ = \"Table of F-tests for overall or pairwise equality of coefficients'\\n%(tab)s\\n\\n\\nNotes: p-values are not corrected for many tests\\n       (no Bonferroni correction)\\n       * : reject at 5%% uncorrected confidence level\\nNull hypothesis: all or pairwise coefficient are the same'\\nAlternative hypothesis: all coefficients are different'\\n\\n\\nComparison with stats.f_oneway\\n%(statsfow)s\\n\\n\\nLikelihood Ratio Test\\n%(lrtest)s\\nNull model: pooled all coefficients are the same across groups,'\\nAlternative model: all coefficients are allowed to be different'\\nnot verified but looks close to f-test result'\\n\\n\\nOLS parameters by group from individual, separate ols regressions'\\n%(olsbg)s\\nfor group in sorted(res.olsbygroup):\\n    r = res.olsbygroup[group]\\n    print group, r.params\\n\\n\\nCheck for heteroscedasticity, '\\nvariance and standard deviation for individual regressions'\\n%(grh)s\\nvariance    ', res.sigmabygroup\\nstandard dev', np.sqrt(res.sigmabygroup)\\n\"\n    from statsmodels.iolib import SimpleTable\n    resvals = {}\n    resvals['tab'] = str(SimpleTable([['%r' % (row[0],)] + list(row[1]) + ['*'] * (row[1][1] > 0.5).item() for row in summtable], headers=['pair', 'F-statistic', 'p-value', 'df_denom', 'df_num']))\n    resvals['statsfow'] = str(stats.f_oneway(*[res.endog[groupind == gr] for gr in res.unique]))\n    resvals['lrtest'] = str(SimpleTable([res.lr_test()], headers=['likelihood ratio', 'p-value', 'df']))\n    resvals['olsbg'] = str(SimpleTable([[group] + res.olsbygroup[group].params.tolist() for group in sorted(res.olsbygroup)]))\n    resvals['grh'] = str(SimpleTable(np.vstack([res.sigmabygroup, np.sqrt(res.sigmabygroup)]), headers=res.unique.tolist()))\n    return templ % resvals",
            "def print_summary(self, res):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'printable string of summary\\n\\n        '\n    groupind = res.groups\n    if hasattr(res, 'self.summarytable'):\n        summtable = self.summarytable\n    else:\n        (_, summtable) = res.ftest_summary()\n    txt = ''\n    templ = \"Table of F-tests for overall or pairwise equality of coefficients'\\n%(tab)s\\n\\n\\nNotes: p-values are not corrected for many tests\\n       (no Bonferroni correction)\\n       * : reject at 5%% uncorrected confidence level\\nNull hypothesis: all or pairwise coefficient are the same'\\nAlternative hypothesis: all coefficients are different'\\n\\n\\nComparison with stats.f_oneway\\n%(statsfow)s\\n\\n\\nLikelihood Ratio Test\\n%(lrtest)s\\nNull model: pooled all coefficients are the same across groups,'\\nAlternative model: all coefficients are allowed to be different'\\nnot verified but looks close to f-test result'\\n\\n\\nOLS parameters by group from individual, separate ols regressions'\\n%(olsbg)s\\nfor group in sorted(res.olsbygroup):\\n    r = res.olsbygroup[group]\\n    print group, r.params\\n\\n\\nCheck for heteroscedasticity, '\\nvariance and standard deviation for individual regressions'\\n%(grh)s\\nvariance    ', res.sigmabygroup\\nstandard dev', np.sqrt(res.sigmabygroup)\\n\"\n    from statsmodels.iolib import SimpleTable\n    resvals = {}\n    resvals['tab'] = str(SimpleTable([['%r' % (row[0],)] + list(row[1]) + ['*'] * (row[1][1] > 0.5).item() for row in summtable], headers=['pair', 'F-statistic', 'p-value', 'df_denom', 'df_num']))\n    resvals['statsfow'] = str(stats.f_oneway(*[res.endog[groupind == gr] for gr in res.unique]))\n    resvals['lrtest'] = str(SimpleTable([res.lr_test()], headers=['likelihood ratio', 'p-value', 'df']))\n    resvals['olsbg'] = str(SimpleTable([[group] + res.olsbygroup[group].params.tolist() for group in sorted(res.olsbygroup)]))\n    resvals['grh'] = str(SimpleTable(np.vstack([res.sigmabygroup, np.sqrt(res.sigmabygroup)]), headers=res.unique.tolist()))\n    return templ % resvals",
            "def print_summary(self, res):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'printable string of summary\\n\\n        '\n    groupind = res.groups\n    if hasattr(res, 'self.summarytable'):\n        summtable = self.summarytable\n    else:\n        (_, summtable) = res.ftest_summary()\n    txt = ''\n    templ = \"Table of F-tests for overall or pairwise equality of coefficients'\\n%(tab)s\\n\\n\\nNotes: p-values are not corrected for many tests\\n       (no Bonferroni correction)\\n       * : reject at 5%% uncorrected confidence level\\nNull hypothesis: all or pairwise coefficient are the same'\\nAlternative hypothesis: all coefficients are different'\\n\\n\\nComparison with stats.f_oneway\\n%(statsfow)s\\n\\n\\nLikelihood Ratio Test\\n%(lrtest)s\\nNull model: pooled all coefficients are the same across groups,'\\nAlternative model: all coefficients are allowed to be different'\\nnot verified but looks close to f-test result'\\n\\n\\nOLS parameters by group from individual, separate ols regressions'\\n%(olsbg)s\\nfor group in sorted(res.olsbygroup):\\n    r = res.olsbygroup[group]\\n    print group, r.params\\n\\n\\nCheck for heteroscedasticity, '\\nvariance and standard deviation for individual regressions'\\n%(grh)s\\nvariance    ', res.sigmabygroup\\nstandard dev', np.sqrt(res.sigmabygroup)\\n\"\n    from statsmodels.iolib import SimpleTable\n    resvals = {}\n    resvals['tab'] = str(SimpleTable([['%r' % (row[0],)] + list(row[1]) + ['*'] * (row[1][1] > 0.5).item() for row in summtable], headers=['pair', 'F-statistic', 'p-value', 'df_denom', 'df_num']))\n    resvals['statsfow'] = str(stats.f_oneway(*[res.endog[groupind == gr] for gr in res.unique]))\n    resvals['lrtest'] = str(SimpleTable([res.lr_test()], headers=['likelihood ratio', 'p-value', 'df']))\n    resvals['olsbg'] = str(SimpleTable([[group] + res.olsbygroup[group].params.tolist() for group in sorted(res.olsbygroup)]))\n    resvals['grh'] = str(SimpleTable(np.vstack([res.sigmabygroup, np.sqrt(res.sigmabygroup)]), headers=res.unique.tolist()))\n    return templ % resvals",
            "def print_summary(self, res):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'printable string of summary\\n\\n        '\n    groupind = res.groups\n    if hasattr(res, 'self.summarytable'):\n        summtable = self.summarytable\n    else:\n        (_, summtable) = res.ftest_summary()\n    txt = ''\n    templ = \"Table of F-tests for overall or pairwise equality of coefficients'\\n%(tab)s\\n\\n\\nNotes: p-values are not corrected for many tests\\n       (no Bonferroni correction)\\n       * : reject at 5%% uncorrected confidence level\\nNull hypothesis: all or pairwise coefficient are the same'\\nAlternative hypothesis: all coefficients are different'\\n\\n\\nComparison with stats.f_oneway\\n%(statsfow)s\\n\\n\\nLikelihood Ratio Test\\n%(lrtest)s\\nNull model: pooled all coefficients are the same across groups,'\\nAlternative model: all coefficients are allowed to be different'\\nnot verified but looks close to f-test result'\\n\\n\\nOLS parameters by group from individual, separate ols regressions'\\n%(olsbg)s\\nfor group in sorted(res.olsbygroup):\\n    r = res.olsbygroup[group]\\n    print group, r.params\\n\\n\\nCheck for heteroscedasticity, '\\nvariance and standard deviation for individual regressions'\\n%(grh)s\\nvariance    ', res.sigmabygroup\\nstandard dev', np.sqrt(res.sigmabygroup)\\n\"\n    from statsmodels.iolib import SimpleTable\n    resvals = {}\n    resvals['tab'] = str(SimpleTable([['%r' % (row[0],)] + list(row[1]) + ['*'] * (row[1][1] > 0.5).item() for row in summtable], headers=['pair', 'F-statistic', 'p-value', 'df_denom', 'df_num']))\n    resvals['statsfow'] = str(stats.f_oneway(*[res.endog[groupind == gr] for gr in res.unique]))\n    resvals['lrtest'] = str(SimpleTable([res.lr_test()], headers=['likelihood ratio', 'p-value', 'df']))\n    resvals['olsbg'] = str(SimpleTable([[group] + res.olsbygroup[group].params.tolist() for group in sorted(res.olsbygroup)]))\n    resvals['grh'] = str(SimpleTable(np.vstack([res.sigmabygroup, np.sqrt(res.sigmabygroup)]), headers=res.unique.tolist()))\n    return templ % resvals"
        ]
    },
    {
        "func_name": "lr_test",
        "original": "def lr_test(self):\n    \"\"\"\n        generic likelihood ratio test between nested models\n\n            \\\\begin{align}\n            D & = -2(\\\\ln(\\\\text{likelihood for null model}) - \\\\ln(\\\\text{likelihood for alternative model})) \\\\\\\\\n            & = -2\\\\ln\\\\left( \\\\frac{\\\\text{likelihood for null model}}{\\\\text{likelihood for alternative model}} \\\\right).\n            \\\\end{align}\n\n        is distributed as chisquare with df equal to difference in number of parameters or equivalently\n        difference in residual degrees of freedom  (sign?)\n\n        TODO: put into separate function\n        \"\"\"\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    if not hasattr(self, 'lspooled'):\n        self.fitpooled()\n    loglikejoint = self.lsjoint.llf\n    loglikepooled = self.lspooled.llf\n    lrstat = -2 * (loglikepooled - loglikejoint)\n    lrdf = self.lspooled.df_resid - self.lsjoint.df_resid\n    lrpval = stats.chi2.sf(lrstat, lrdf)\n    return (lrstat, lrpval, lrdf)",
        "mutated": [
            "def lr_test(self):\n    if False:\n        i = 10\n    '\\n        generic likelihood ratio test between nested models\\n\\n            \\\\begin{align}\\n            D & = -2(\\\\ln(\\\\text{likelihood for null model}) - \\\\ln(\\\\text{likelihood for alternative model})) \\\\\\\\\\n            & = -2\\\\ln\\\\left( \\\\frac{\\\\text{likelihood for null model}}{\\\\text{likelihood for alternative model}} \\\\right).\\n            \\\\end{align}\\n\\n        is distributed as chisquare with df equal to difference in number of parameters or equivalently\\n        difference in residual degrees of freedom  (sign?)\\n\\n        TODO: put into separate function\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    if not hasattr(self, 'lspooled'):\n        self.fitpooled()\n    loglikejoint = self.lsjoint.llf\n    loglikepooled = self.lspooled.llf\n    lrstat = -2 * (loglikepooled - loglikejoint)\n    lrdf = self.lspooled.df_resid - self.lsjoint.df_resid\n    lrpval = stats.chi2.sf(lrstat, lrdf)\n    return (lrstat, lrpval, lrdf)",
            "def lr_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        generic likelihood ratio test between nested models\\n\\n            \\\\begin{align}\\n            D & = -2(\\\\ln(\\\\text{likelihood for null model}) - \\\\ln(\\\\text{likelihood for alternative model})) \\\\\\\\\\n            & = -2\\\\ln\\\\left( \\\\frac{\\\\text{likelihood for null model}}{\\\\text{likelihood for alternative model}} \\\\right).\\n            \\\\end{align}\\n\\n        is distributed as chisquare with df equal to difference in number of parameters or equivalently\\n        difference in residual degrees of freedom  (sign?)\\n\\n        TODO: put into separate function\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    if not hasattr(self, 'lspooled'):\n        self.fitpooled()\n    loglikejoint = self.lsjoint.llf\n    loglikepooled = self.lspooled.llf\n    lrstat = -2 * (loglikepooled - loglikejoint)\n    lrdf = self.lspooled.df_resid - self.lsjoint.df_resid\n    lrpval = stats.chi2.sf(lrstat, lrdf)\n    return (lrstat, lrpval, lrdf)",
            "def lr_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        generic likelihood ratio test between nested models\\n\\n            \\\\begin{align}\\n            D & = -2(\\\\ln(\\\\text{likelihood for null model}) - \\\\ln(\\\\text{likelihood for alternative model})) \\\\\\\\\\n            & = -2\\\\ln\\\\left( \\\\frac{\\\\text{likelihood for null model}}{\\\\text{likelihood for alternative model}} \\\\right).\\n            \\\\end{align}\\n\\n        is distributed as chisquare with df equal to difference in number of parameters or equivalently\\n        difference in residual degrees of freedom  (sign?)\\n\\n        TODO: put into separate function\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    if not hasattr(self, 'lspooled'):\n        self.fitpooled()\n    loglikejoint = self.lsjoint.llf\n    loglikepooled = self.lspooled.llf\n    lrstat = -2 * (loglikepooled - loglikejoint)\n    lrdf = self.lspooled.df_resid - self.lsjoint.df_resid\n    lrpval = stats.chi2.sf(lrstat, lrdf)\n    return (lrstat, lrpval, lrdf)",
            "def lr_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        generic likelihood ratio test between nested models\\n\\n            \\\\begin{align}\\n            D & = -2(\\\\ln(\\\\text{likelihood for null model}) - \\\\ln(\\\\text{likelihood for alternative model})) \\\\\\\\\\n            & = -2\\\\ln\\\\left( \\\\frac{\\\\text{likelihood for null model}}{\\\\text{likelihood for alternative model}} \\\\right).\\n            \\\\end{align}\\n\\n        is distributed as chisquare with df equal to difference in number of parameters or equivalently\\n        difference in residual degrees of freedom  (sign?)\\n\\n        TODO: put into separate function\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    if not hasattr(self, 'lspooled'):\n        self.fitpooled()\n    loglikejoint = self.lsjoint.llf\n    loglikepooled = self.lspooled.llf\n    lrstat = -2 * (loglikepooled - loglikejoint)\n    lrdf = self.lspooled.df_resid - self.lsjoint.df_resid\n    lrpval = stats.chi2.sf(lrstat, lrdf)\n    return (lrstat, lrpval, lrdf)",
            "def lr_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        generic likelihood ratio test between nested models\\n\\n            \\\\begin{align}\\n            D & = -2(\\\\ln(\\\\text{likelihood for null model}) - \\\\ln(\\\\text{likelihood for alternative model})) \\\\\\\\\\n            & = -2\\\\ln\\\\left( \\\\frac{\\\\text{likelihood for null model}}{\\\\text{likelihood for alternative model}} \\\\right).\\n            \\\\end{align}\\n\\n        is distributed as chisquare with df equal to difference in number of parameters or equivalently\\n        difference in residual degrees of freedom  (sign?)\\n\\n        TODO: put into separate function\\n        '\n    if not hasattr(self, 'lsjoint'):\n        self.fitjoint()\n    if not hasattr(self, 'lspooled'):\n        self.fitpooled()\n    loglikejoint = self.lsjoint.llf\n    loglikepooled = self.lspooled.llf\n    lrstat = -2 * (loglikepooled - loglikejoint)\n    lrdf = self.lspooled.df_resid - self.lsjoint.df_resid\n    lrpval = stats.chi2.sf(lrstat, lrdf)\n    return (lrstat, lrpval, lrdf)"
        ]
    }
]