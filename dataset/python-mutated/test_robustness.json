[
    {
        "func_name": "setUp",
        "original": "def setUp(self) -> None:\n    self.a = Variable(name='a')\n    self.b = Variable(name='b')\n    self.c = Variable(name='c')\n    self.x = Variable(2, name='x')\n    self.y = Variable(3, name='y')\n    self.z = Variable(2, name='z')\n    self.A = Variable((2, 2), name='A')\n    self.B = Variable((2, 2), name='B')\n    self.C = Variable((3, 2), name='C')",
        "mutated": [
            "def setUp(self) -> None:\n    if False:\n        i = 10\n    self.a = Variable(name='a')\n    self.b = Variable(name='b')\n    self.c = Variable(name='c')\n    self.x = Variable(2, name='x')\n    self.y = Variable(3, name='y')\n    self.z = Variable(2, name='z')\n    self.A = Variable((2, 2), name='A')\n    self.B = Variable((2, 2), name='B')\n    self.C = Variable((3, 2), name='C')",
            "def setUp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.a = Variable(name='a')\n    self.b = Variable(name='b')\n    self.c = Variable(name='c')\n    self.x = Variable(2, name='x')\n    self.y = Variable(3, name='y')\n    self.z = Variable(2, name='z')\n    self.A = Variable((2, 2), name='A')\n    self.B = Variable((2, 2), name='B')\n    self.C = Variable((3, 2), name='C')",
            "def setUp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.a = Variable(name='a')\n    self.b = Variable(name='b')\n    self.c = Variable(name='c')\n    self.x = Variable(2, name='x')\n    self.y = Variable(3, name='y')\n    self.z = Variable(2, name='z')\n    self.A = Variable((2, 2), name='A')\n    self.B = Variable((2, 2), name='B')\n    self.C = Variable((3, 2), name='C')",
            "def setUp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.a = Variable(name='a')\n    self.b = Variable(name='b')\n    self.c = Variable(name='c')\n    self.x = Variable(2, name='x')\n    self.y = Variable(3, name='y')\n    self.z = Variable(2, name='z')\n    self.A = Variable((2, 2), name='A')\n    self.B = Variable((2, 2), name='B')\n    self.C = Variable((3, 2), name='C')",
            "def setUp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.a = Variable(name='a')\n    self.b = Variable(name='b')\n    self.c = Variable(name='c')\n    self.x = Variable(2, name='x')\n    self.y = Variable(3, name='y')\n    self.z = Variable(2, name='z')\n    self.A = Variable((2, 2), name='A')\n    self.B = Variable((2, 2), name='B')\n    self.C = Variable((3, 2), name='C')"
        ]
    },
    {
        "func_name": "assertAlmostEqual",
        "original": "def assertAlmostEqual(self, a, b, interface=intf.DEFAULT_INTF) -> None:\n    try:\n        a = list(a)\n        b = list(b)\n        for i in range(len(a)):\n            self.assertAlmostEqual(a[i], b[i])\n    except Exception:\n        super(TestProblem, self).assertAlmostEqual(a, b, places=1)",
        "mutated": [
            "def assertAlmostEqual(self, a, b, interface=intf.DEFAULT_INTF) -> None:\n    if False:\n        i = 10\n    try:\n        a = list(a)\n        b = list(b)\n        for i in range(len(a)):\n            self.assertAlmostEqual(a[i], b[i])\n    except Exception:\n        super(TestProblem, self).assertAlmostEqual(a, b, places=1)",
            "def assertAlmostEqual(self, a, b, interface=intf.DEFAULT_INTF) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        a = list(a)\n        b = list(b)\n        for i in range(len(a)):\n            self.assertAlmostEqual(a[i], b[i])\n    except Exception:\n        super(TestProblem, self).assertAlmostEqual(a, b, places=1)",
            "def assertAlmostEqual(self, a, b, interface=intf.DEFAULT_INTF) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        a = list(a)\n        b = list(b)\n        for i in range(len(a)):\n            self.assertAlmostEqual(a[i], b[i])\n    except Exception:\n        super(TestProblem, self).assertAlmostEqual(a, b, places=1)",
            "def assertAlmostEqual(self, a, b, interface=intf.DEFAULT_INTF) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        a = list(a)\n        b = list(b)\n        for i in range(len(a)):\n            self.assertAlmostEqual(a[i], b[i])\n    except Exception:\n        super(TestProblem, self).assertAlmostEqual(a, b, places=1)",
            "def assertAlmostEqual(self, a, b, interface=intf.DEFAULT_INTF) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        a = list(a)\n        b = list(b)\n        for i in range(len(a)):\n            self.assertAlmostEqual(a[i], b[i])\n    except Exception:\n        super(TestProblem, self).assertAlmostEqual(a, b, places=1)"
        ]
    },
    {
        "func_name": "test_large_sum",
        "original": "def test_large_sum(self) -> None:\n    \"\"\"Test large number of variables summed.\n        \"\"\"\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.sum(x)), [x >= A])\n        result = p.solve()\n        answer = n * n * (n * n + 1) / 2 - n * n\n        print(result - answer)\n        self.assertAlmostEqual(result, answer)",
        "mutated": [
            "def test_large_sum(self) -> None:\n    if False:\n        i = 10\n    'Test large number of variables summed.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.sum(x)), [x >= A])\n        result = p.solve()\n        answer = n * n * (n * n + 1) / 2 - n * n\n        print(result - answer)\n        self.assertAlmostEqual(result, answer)",
            "def test_large_sum(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test large number of variables summed.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.sum(x)), [x >= A])\n        result = p.solve()\n        answer = n * n * (n * n + 1) / 2 - n * n\n        print(result - answer)\n        self.assertAlmostEqual(result, answer)",
            "def test_large_sum(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test large number of variables summed.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.sum(x)), [x >= A])\n        result = p.solve()\n        answer = n * n * (n * n + 1) / 2 - n * n\n        print(result - answer)\n        self.assertAlmostEqual(result, answer)",
            "def test_large_sum(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test large number of variables summed.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.sum(x)), [x >= A])\n        result = p.solve()\n        answer = n * n * (n * n + 1) / 2 - n * n\n        print(result - answer)\n        self.assertAlmostEqual(result, answer)",
            "def test_large_sum(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test large number of variables summed.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.sum(x)), [x >= A])\n        result = p.solve()\n        answer = n * n * (n * n + 1) / 2 - n * n\n        print(result - answer)\n        self.assertAlmostEqual(result, answer)"
        ]
    },
    {
        "func_name": "test_large_square",
        "original": "def test_large_square(self) -> None:\n    \"\"\"Test large number of variables squared.\n        \"\"\"\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.square(x[0, 0])), [x >= A])\n        result = p.solve()\n        self.assertAlmostEqual(result, 0)",
        "mutated": [
            "def test_large_square(self) -> None:\n    if False:\n        i = 10\n    'Test large number of variables squared.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.square(x[0, 0])), [x >= A])\n        result = p.solve()\n        self.assertAlmostEqual(result, 0)",
            "def test_large_square(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test large number of variables squared.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.square(x[0, 0])), [x >= A])\n        result = p.solve()\n        self.assertAlmostEqual(result, 0)",
            "def test_large_square(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test large number of variables squared.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.square(x[0, 0])), [x >= A])\n        result = p.solve()\n        self.assertAlmostEqual(result, 0)",
            "def test_large_square(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test large number of variables squared.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.square(x[0, 0])), [x >= A])\n        result = p.solve()\n        self.assertAlmostEqual(result, 0)",
            "def test_large_square(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test large number of variables squared.\\n        '\n    self.skipTest('Too slow.')\n    for n in [10, 20, 30, 40, 50]:\n        A = np.arange(n * n)\n        A = np.reshape(A, (n, n))\n        x = Variable((n, n))\n        p = Problem(cp.Minimize(at.square(x[0, 0])), [x >= A])\n        result = p.solve()\n        self.assertAlmostEqual(result, 0)"
        ]
    },
    {
        "func_name": "test_sdp",
        "original": "def test_sdp(self) -> None:\n    \"\"\"Test a problem with semidefinite cones.\n        \"\"\"\n    self.skipTest('Too slow.')\n    a = sp.rand(100, 100, 0.1, random_state=1)\n    a = a.todense()\n    X = Variable((100, 100))\n    obj = at.norm(X, 'nuc') + at.norm(X - a, 'fro')\n    p = Problem(cp.Minimize(obj))\n    p.solve(solver='SCS')",
        "mutated": [
            "def test_sdp(self) -> None:\n    if False:\n        i = 10\n    'Test a problem with semidefinite cones.\\n        '\n    self.skipTest('Too slow.')\n    a = sp.rand(100, 100, 0.1, random_state=1)\n    a = a.todense()\n    X = Variable((100, 100))\n    obj = at.norm(X, 'nuc') + at.norm(X - a, 'fro')\n    p = Problem(cp.Minimize(obj))\n    p.solve(solver='SCS')",
            "def test_sdp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test a problem with semidefinite cones.\\n        '\n    self.skipTest('Too slow.')\n    a = sp.rand(100, 100, 0.1, random_state=1)\n    a = a.todense()\n    X = Variable((100, 100))\n    obj = at.norm(X, 'nuc') + at.norm(X - a, 'fro')\n    p = Problem(cp.Minimize(obj))\n    p.solve(solver='SCS')",
            "def test_sdp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test a problem with semidefinite cones.\\n        '\n    self.skipTest('Too slow.')\n    a = sp.rand(100, 100, 0.1, random_state=1)\n    a = a.todense()\n    X = Variable((100, 100))\n    obj = at.norm(X, 'nuc') + at.norm(X - a, 'fro')\n    p = Problem(cp.Minimize(obj))\n    p.solve(solver='SCS')",
            "def test_sdp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test a problem with semidefinite cones.\\n        '\n    self.skipTest('Too slow.')\n    a = sp.rand(100, 100, 0.1, random_state=1)\n    a = a.todense()\n    X = Variable((100, 100))\n    obj = at.norm(X, 'nuc') + at.norm(X - a, 'fro')\n    p = Problem(cp.Minimize(obj))\n    p.solve(solver='SCS')",
            "def test_sdp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test a problem with semidefinite cones.\\n        '\n    self.skipTest('Too slow.')\n    a = sp.rand(100, 100, 0.1, random_state=1)\n    a = a.todense()\n    X = Variable((100, 100))\n    obj = at.norm(X, 'nuc') + at.norm(X - a, 'fro')\n    p = Problem(cp.Minimize(obj))\n    p.solve(solver='SCS')"
        ]
    },
    {
        "func_name": "test_large_sdp",
        "original": "def test_large_sdp(self) -> None:\n    \"\"\"Test for bug where large PSD caused integer overflow in cvxcore.\n        \"\"\"\n    self.skipTest('Too slow.')\n    SHAPE = (256, 256)\n    rows = SHAPE[0]\n    cols = SHAPE[1]\n    X = Variable(SHAPE)\n    Z = Variable((rows + cols, rows + cols))\n    prob = Problem(cp.Minimize(0.5 * at.trace(Z)), [X[0, 0] >= 1, Z[0:rows, rows:rows + cols] == X, Z >> 0, Z == Z.T])\n    prob.solve(solver='SCS', eps=1e-06)\n    self.assertAlmostEqual(prob.value, 1.0)",
        "mutated": [
            "def test_large_sdp(self) -> None:\n    if False:\n        i = 10\n    'Test for bug where large PSD caused integer overflow in cvxcore.\\n        '\n    self.skipTest('Too slow.')\n    SHAPE = (256, 256)\n    rows = SHAPE[0]\n    cols = SHAPE[1]\n    X = Variable(SHAPE)\n    Z = Variable((rows + cols, rows + cols))\n    prob = Problem(cp.Minimize(0.5 * at.trace(Z)), [X[0, 0] >= 1, Z[0:rows, rows:rows + cols] == X, Z >> 0, Z == Z.T])\n    prob.solve(solver='SCS', eps=1e-06)\n    self.assertAlmostEqual(prob.value, 1.0)",
            "def test_large_sdp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test for bug where large PSD caused integer overflow in cvxcore.\\n        '\n    self.skipTest('Too slow.')\n    SHAPE = (256, 256)\n    rows = SHAPE[0]\n    cols = SHAPE[1]\n    X = Variable(SHAPE)\n    Z = Variable((rows + cols, rows + cols))\n    prob = Problem(cp.Minimize(0.5 * at.trace(Z)), [X[0, 0] >= 1, Z[0:rows, rows:rows + cols] == X, Z >> 0, Z == Z.T])\n    prob.solve(solver='SCS', eps=1e-06)\n    self.assertAlmostEqual(prob.value, 1.0)",
            "def test_large_sdp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test for bug where large PSD caused integer overflow in cvxcore.\\n        '\n    self.skipTest('Too slow.')\n    SHAPE = (256, 256)\n    rows = SHAPE[0]\n    cols = SHAPE[1]\n    X = Variable(SHAPE)\n    Z = Variable((rows + cols, rows + cols))\n    prob = Problem(cp.Minimize(0.5 * at.trace(Z)), [X[0, 0] >= 1, Z[0:rows, rows:rows + cols] == X, Z >> 0, Z == Z.T])\n    prob.solve(solver='SCS', eps=1e-06)\n    self.assertAlmostEqual(prob.value, 1.0)",
            "def test_large_sdp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test for bug where large PSD caused integer overflow in cvxcore.\\n        '\n    self.skipTest('Too slow.')\n    SHAPE = (256, 256)\n    rows = SHAPE[0]\n    cols = SHAPE[1]\n    X = Variable(SHAPE)\n    Z = Variable((rows + cols, rows + cols))\n    prob = Problem(cp.Minimize(0.5 * at.trace(Z)), [X[0, 0] >= 1, Z[0:rows, rows:rows + cols] == X, Z >> 0, Z == Z.T])\n    prob.solve(solver='SCS', eps=1e-06)\n    self.assertAlmostEqual(prob.value, 1.0)",
            "def test_large_sdp(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test for bug where large PSD caused integer overflow in cvxcore.\\n        '\n    self.skipTest('Too slow.')\n    SHAPE = (256, 256)\n    rows = SHAPE[0]\n    cols = SHAPE[1]\n    X = Variable(SHAPE)\n    Z = Variable((rows + cols, rows + cols))\n    prob = Problem(cp.Minimize(0.5 * at.trace(Z)), [X[0, 0] >= 1, Z[0:rows, rows:rows + cols] == X, Z >> 0, Z == Z.T])\n    prob.solve(solver='SCS', eps=1e-06)\n    self.assertAlmostEqual(prob.value, 1.0)"
        ]
    }
]