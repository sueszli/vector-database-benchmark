[
    {
        "func_name": "cubic",
        "original": "def cubic(x):\n    \"\"\"cubic function used for calculate_weights_indices.\"\"\"\n    absx = torch.abs(x)\n    absx2 = absx ** 2\n    absx3 = absx ** 3\n    a = 1.5 * absx3 - 2.5 * absx2 + 1\n    b = (absx <= 1).type_as(absx)\n    c = -0.5 * absx3 + 2.5 * absx2 - 4 * absx + 2\n    return a * b + c * ((absx > 1) * (absx <= 2)).type_as(absx)",
        "mutated": [
            "def cubic(x):\n    if False:\n        i = 10\n    'cubic function used for calculate_weights_indices.'\n    absx = torch.abs(x)\n    absx2 = absx ** 2\n    absx3 = absx ** 3\n    a = 1.5 * absx3 - 2.5 * absx2 + 1\n    b = (absx <= 1).type_as(absx)\n    c = -0.5 * absx3 + 2.5 * absx2 - 4 * absx + 2\n    return a * b + c * ((absx > 1) * (absx <= 2)).type_as(absx)",
            "def cubic(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'cubic function used for calculate_weights_indices.'\n    absx = torch.abs(x)\n    absx2 = absx ** 2\n    absx3 = absx ** 3\n    a = 1.5 * absx3 - 2.5 * absx2 + 1\n    b = (absx <= 1).type_as(absx)\n    c = -0.5 * absx3 + 2.5 * absx2 - 4 * absx + 2\n    return a * b + c * ((absx > 1) * (absx <= 2)).type_as(absx)",
            "def cubic(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'cubic function used for calculate_weights_indices.'\n    absx = torch.abs(x)\n    absx2 = absx ** 2\n    absx3 = absx ** 3\n    a = 1.5 * absx3 - 2.5 * absx2 + 1\n    b = (absx <= 1).type_as(absx)\n    c = -0.5 * absx3 + 2.5 * absx2 - 4 * absx + 2\n    return a * b + c * ((absx > 1) * (absx <= 2)).type_as(absx)",
            "def cubic(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'cubic function used for calculate_weights_indices.'\n    absx = torch.abs(x)\n    absx2 = absx ** 2\n    absx3 = absx ** 3\n    a = 1.5 * absx3 - 2.5 * absx2 + 1\n    b = (absx <= 1).type_as(absx)\n    c = -0.5 * absx3 + 2.5 * absx2 - 4 * absx + 2\n    return a * b + c * ((absx > 1) * (absx <= 2)).type_as(absx)",
            "def cubic(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'cubic function used for calculate_weights_indices.'\n    absx = torch.abs(x)\n    absx2 = absx ** 2\n    absx3 = absx ** 3\n    a = 1.5 * absx3 - 2.5 * absx2 + 1\n    b = (absx <= 1).type_as(absx)\n    c = -0.5 * absx3 + 2.5 * absx2 - 4 * absx + 2\n    return a * b + c * ((absx > 1) * (absx <= 2)).type_as(absx)"
        ]
    },
    {
        "func_name": "calculate_weights_indices",
        "original": "def calculate_weights_indices(in_length, out_length, scale, kernel, kernel_width, antialiasing):\n    \"\"\"Calculate weights and indices, used for imresize function.\n    Args:\n        in_length (int): Input length.\n        out_length (int): Output length.\n        scale (float): Scale factor.\n        kernel_width (int): Kernel width.\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\n    \"\"\"\n    if scale < 1 and antialiasing:\n        kernel_width = kernel_width / scale\n    x = torch.linspace(1, out_length, out_length)\n    u = x / scale + 0.5 * (1 - 1 / scale)\n    left = torch.floor(u - kernel_width / 2)\n    p = math.ceil(kernel_width) + 2\n    indices = left.view(out_length, 1).expand(out_length, p) + torch.linspace(0, p - 1, p).view(1, p).expand(out_length, p)\n    distance_to_center = u.view(out_length, 1).expand(out_length, p) - indices\n    if scale < 1 and antialiasing:\n        weights = scale * cubic(distance_to_center * scale)\n    else:\n        weights = cubic(distance_to_center)\n    weights_sum = torch.sum(weights, 1).view(out_length, 1)\n    weights = weights / weights_sum.expand(out_length, p)\n    weights_zero_tmp = torch.sum(weights == 0, 0)\n    if not math.isclose(weights_zero_tmp[0], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 1, p - 2)\n        weights = weights.narrow(1, 1, p - 2)\n    if not math.isclose(weights_zero_tmp[-1], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 0, p - 2)\n        weights = weights.narrow(1, 0, p - 2)\n    weights = weights.contiguous()\n    indices = indices.contiguous()\n    sym_len_s = -indices.min() + 1\n    sym_len_e = indices.max() - in_length\n    indices = indices + sym_len_s - 1\n    return (weights, indices, int(sym_len_s), int(sym_len_e))",
        "mutated": [
            "def calculate_weights_indices(in_length, out_length, scale, kernel, kernel_width, antialiasing):\n    if False:\n        i = 10\n    'Calculate weights and indices, used for imresize function.\\n    Args:\\n        in_length (int): Input length.\\n        out_length (int): Output length.\\n        scale (float): Scale factor.\\n        kernel_width (int): Kernel width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n    '\n    if scale < 1 and antialiasing:\n        kernel_width = kernel_width / scale\n    x = torch.linspace(1, out_length, out_length)\n    u = x / scale + 0.5 * (1 - 1 / scale)\n    left = torch.floor(u - kernel_width / 2)\n    p = math.ceil(kernel_width) + 2\n    indices = left.view(out_length, 1).expand(out_length, p) + torch.linspace(0, p - 1, p).view(1, p).expand(out_length, p)\n    distance_to_center = u.view(out_length, 1).expand(out_length, p) - indices\n    if scale < 1 and antialiasing:\n        weights = scale * cubic(distance_to_center * scale)\n    else:\n        weights = cubic(distance_to_center)\n    weights_sum = torch.sum(weights, 1).view(out_length, 1)\n    weights = weights / weights_sum.expand(out_length, p)\n    weights_zero_tmp = torch.sum(weights == 0, 0)\n    if not math.isclose(weights_zero_tmp[0], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 1, p - 2)\n        weights = weights.narrow(1, 1, p - 2)\n    if not math.isclose(weights_zero_tmp[-1], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 0, p - 2)\n        weights = weights.narrow(1, 0, p - 2)\n    weights = weights.contiguous()\n    indices = indices.contiguous()\n    sym_len_s = -indices.min() + 1\n    sym_len_e = indices.max() - in_length\n    indices = indices + sym_len_s - 1\n    return (weights, indices, int(sym_len_s), int(sym_len_e))",
            "def calculate_weights_indices(in_length, out_length, scale, kernel, kernel_width, antialiasing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate weights and indices, used for imresize function.\\n    Args:\\n        in_length (int): Input length.\\n        out_length (int): Output length.\\n        scale (float): Scale factor.\\n        kernel_width (int): Kernel width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n    '\n    if scale < 1 and antialiasing:\n        kernel_width = kernel_width / scale\n    x = torch.linspace(1, out_length, out_length)\n    u = x / scale + 0.5 * (1 - 1 / scale)\n    left = torch.floor(u - kernel_width / 2)\n    p = math.ceil(kernel_width) + 2\n    indices = left.view(out_length, 1).expand(out_length, p) + torch.linspace(0, p - 1, p).view(1, p).expand(out_length, p)\n    distance_to_center = u.view(out_length, 1).expand(out_length, p) - indices\n    if scale < 1 and antialiasing:\n        weights = scale * cubic(distance_to_center * scale)\n    else:\n        weights = cubic(distance_to_center)\n    weights_sum = torch.sum(weights, 1).view(out_length, 1)\n    weights = weights / weights_sum.expand(out_length, p)\n    weights_zero_tmp = torch.sum(weights == 0, 0)\n    if not math.isclose(weights_zero_tmp[0], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 1, p - 2)\n        weights = weights.narrow(1, 1, p - 2)\n    if not math.isclose(weights_zero_tmp[-1], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 0, p - 2)\n        weights = weights.narrow(1, 0, p - 2)\n    weights = weights.contiguous()\n    indices = indices.contiguous()\n    sym_len_s = -indices.min() + 1\n    sym_len_e = indices.max() - in_length\n    indices = indices + sym_len_s - 1\n    return (weights, indices, int(sym_len_s), int(sym_len_e))",
            "def calculate_weights_indices(in_length, out_length, scale, kernel, kernel_width, antialiasing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate weights and indices, used for imresize function.\\n    Args:\\n        in_length (int): Input length.\\n        out_length (int): Output length.\\n        scale (float): Scale factor.\\n        kernel_width (int): Kernel width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n    '\n    if scale < 1 and antialiasing:\n        kernel_width = kernel_width / scale\n    x = torch.linspace(1, out_length, out_length)\n    u = x / scale + 0.5 * (1 - 1 / scale)\n    left = torch.floor(u - kernel_width / 2)\n    p = math.ceil(kernel_width) + 2\n    indices = left.view(out_length, 1).expand(out_length, p) + torch.linspace(0, p - 1, p).view(1, p).expand(out_length, p)\n    distance_to_center = u.view(out_length, 1).expand(out_length, p) - indices\n    if scale < 1 and antialiasing:\n        weights = scale * cubic(distance_to_center * scale)\n    else:\n        weights = cubic(distance_to_center)\n    weights_sum = torch.sum(weights, 1).view(out_length, 1)\n    weights = weights / weights_sum.expand(out_length, p)\n    weights_zero_tmp = torch.sum(weights == 0, 0)\n    if not math.isclose(weights_zero_tmp[0], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 1, p - 2)\n        weights = weights.narrow(1, 1, p - 2)\n    if not math.isclose(weights_zero_tmp[-1], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 0, p - 2)\n        weights = weights.narrow(1, 0, p - 2)\n    weights = weights.contiguous()\n    indices = indices.contiguous()\n    sym_len_s = -indices.min() + 1\n    sym_len_e = indices.max() - in_length\n    indices = indices + sym_len_s - 1\n    return (weights, indices, int(sym_len_s), int(sym_len_e))",
            "def calculate_weights_indices(in_length, out_length, scale, kernel, kernel_width, antialiasing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate weights and indices, used for imresize function.\\n    Args:\\n        in_length (int): Input length.\\n        out_length (int): Output length.\\n        scale (float): Scale factor.\\n        kernel_width (int): Kernel width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n    '\n    if scale < 1 and antialiasing:\n        kernel_width = kernel_width / scale\n    x = torch.linspace(1, out_length, out_length)\n    u = x / scale + 0.5 * (1 - 1 / scale)\n    left = torch.floor(u - kernel_width / 2)\n    p = math.ceil(kernel_width) + 2\n    indices = left.view(out_length, 1).expand(out_length, p) + torch.linspace(0, p - 1, p).view(1, p).expand(out_length, p)\n    distance_to_center = u.view(out_length, 1).expand(out_length, p) - indices\n    if scale < 1 and antialiasing:\n        weights = scale * cubic(distance_to_center * scale)\n    else:\n        weights = cubic(distance_to_center)\n    weights_sum = torch.sum(weights, 1).view(out_length, 1)\n    weights = weights / weights_sum.expand(out_length, p)\n    weights_zero_tmp = torch.sum(weights == 0, 0)\n    if not math.isclose(weights_zero_tmp[0], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 1, p - 2)\n        weights = weights.narrow(1, 1, p - 2)\n    if not math.isclose(weights_zero_tmp[-1], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 0, p - 2)\n        weights = weights.narrow(1, 0, p - 2)\n    weights = weights.contiguous()\n    indices = indices.contiguous()\n    sym_len_s = -indices.min() + 1\n    sym_len_e = indices.max() - in_length\n    indices = indices + sym_len_s - 1\n    return (weights, indices, int(sym_len_s), int(sym_len_e))",
            "def calculate_weights_indices(in_length, out_length, scale, kernel, kernel_width, antialiasing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate weights and indices, used for imresize function.\\n    Args:\\n        in_length (int): Input length.\\n        out_length (int): Output length.\\n        scale (float): Scale factor.\\n        kernel_width (int): Kernel width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n    '\n    if scale < 1 and antialiasing:\n        kernel_width = kernel_width / scale\n    x = torch.linspace(1, out_length, out_length)\n    u = x / scale + 0.5 * (1 - 1 / scale)\n    left = torch.floor(u - kernel_width / 2)\n    p = math.ceil(kernel_width) + 2\n    indices = left.view(out_length, 1).expand(out_length, p) + torch.linspace(0, p - 1, p).view(1, p).expand(out_length, p)\n    distance_to_center = u.view(out_length, 1).expand(out_length, p) - indices\n    if scale < 1 and antialiasing:\n        weights = scale * cubic(distance_to_center * scale)\n    else:\n        weights = cubic(distance_to_center)\n    weights_sum = torch.sum(weights, 1).view(out_length, 1)\n    weights = weights / weights_sum.expand(out_length, p)\n    weights_zero_tmp = torch.sum(weights == 0, 0)\n    if not math.isclose(weights_zero_tmp[0], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 1, p - 2)\n        weights = weights.narrow(1, 1, p - 2)\n    if not math.isclose(weights_zero_tmp[-1], 0, rel_tol=1e-06):\n        indices = indices.narrow(1, 0, p - 2)\n        weights = weights.narrow(1, 0, p - 2)\n    weights = weights.contiguous()\n    indices = indices.contiguous()\n    sym_len_s = -indices.min() + 1\n    sym_len_e = indices.max() - in_length\n    indices = indices + sym_len_s - 1\n    return (weights, indices, int(sym_len_s), int(sym_len_e))"
        ]
    },
    {
        "func_name": "imresize",
        "original": "@torch.no_grad()\ndef imresize(img, scale, antialiasing=True):\n    \"\"\"imresize function same as MATLAB.\n    It now only supports bicubic.\n    The same scale applies for both height and width.\n    Args:\n        img (Tensor | Numpy array):\n            Tensor: Input image with shape (c, h, w), [0, 1] range.\n            Numpy: Input image with shape (h, w, c), [0, 1] range.\n        scale (float): Scale factor. The same scale applies for both height\n            and width.\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\n            Default: True.\n    Returns:\n        Tensor: Output image with shape (c, h, w), [0, 1] range, w/o round.\n    \"\"\"\n    squeeze_flag = False\n    if type(img).__module__ == np.__name__:\n        numpy_type = True\n        if img.ndim == 2:\n            img = img[:, :, None]\n            squeeze_flag = True\n        img = torch.from_numpy(img.transpose(2, 0, 1)).float()\n    else:\n        numpy_type = False\n        if img.ndim == 2:\n            img = img.unsqueeze(0)\n            squeeze_flag = True\n    (in_c, in_h, in_w) = img.size()\n    (out_h, out_w) = (math.ceil(in_h * scale), math.ceil(in_w * scale))\n    kernel_width = 4\n    kernel = 'cubic'\n    (weights_h, indices_h, sym_len_hs, sym_len_he) = calculate_weights_indices(in_h, out_h, scale, kernel, kernel_width, antialiasing)\n    (weights_w, indices_w, sym_len_ws, sym_len_we) = calculate_weights_indices(in_w, out_w, scale, kernel, kernel_width, antialiasing)\n    img_aug = torch.FloatTensor(in_c, in_h + sym_len_hs + sym_len_he, in_w)\n    img_aug.narrow(1, sym_len_hs, in_h).copy_(img)\n    sym_patch = img[:, :sym_len_hs, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, 0, sym_len_hs).copy_(sym_patch_inv)\n    sym_patch = img[:, -sym_len_he:, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, sym_len_hs + in_h, sym_len_he).copy_(sym_patch_inv)\n    out_1 = torch.FloatTensor(in_c, out_h, in_w)\n    kernel_width = weights_h.size(1)\n    for i in range(out_h):\n        idx = int(indices_h[i][0])\n        for j in range(in_c):\n            out_1[j, i, :] = img_aug[j, idx:idx + kernel_width, :].transpose(0, 1).mv(weights_h[i])\n    out_1_aug = torch.FloatTensor(in_c, out_h, in_w + sym_len_ws + sym_len_we)\n    out_1_aug.narrow(2, sym_len_ws, in_w).copy_(out_1)\n    sym_patch = out_1[:, :, :sym_len_ws]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, 0, sym_len_ws).copy_(sym_patch_inv)\n    sym_patch = out_1[:, :, -sym_len_we:]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, sym_len_ws + in_w, sym_len_we).copy_(sym_patch_inv)\n    out_2 = torch.FloatTensor(in_c, out_h, out_w)\n    kernel_width = weights_w.size(1)\n    for i in range(out_w):\n        idx = int(indices_w[i][0])\n        for j in range(in_c):\n            out_2[j, :, i] = out_1_aug[j, :, idx:idx + kernel_width].mv(weights_w[i])\n    if squeeze_flag:\n        out_2 = out_2.squeeze(0)\n    if numpy_type:\n        out_2 = out_2.numpy()\n        if not squeeze_flag:\n            out_2 = out_2.transpose(1, 2, 0)\n    return out_2",
        "mutated": [
            "@torch.no_grad()\ndef imresize(img, scale, antialiasing=True):\n    if False:\n        i = 10\n    'imresize function same as MATLAB.\\n    It now only supports bicubic.\\n    The same scale applies for both height and width.\\n    Args:\\n        img (Tensor | Numpy array):\\n            Tensor: Input image with shape (c, h, w), [0, 1] range.\\n            Numpy: Input image with shape (h, w, c), [0, 1] range.\\n        scale (float): Scale factor. The same scale applies for both height\\n            and width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n            Default: True.\\n    Returns:\\n        Tensor: Output image with shape (c, h, w), [0, 1] range, w/o round.\\n    '\n    squeeze_flag = False\n    if type(img).__module__ == np.__name__:\n        numpy_type = True\n        if img.ndim == 2:\n            img = img[:, :, None]\n            squeeze_flag = True\n        img = torch.from_numpy(img.transpose(2, 0, 1)).float()\n    else:\n        numpy_type = False\n        if img.ndim == 2:\n            img = img.unsqueeze(0)\n            squeeze_flag = True\n    (in_c, in_h, in_w) = img.size()\n    (out_h, out_w) = (math.ceil(in_h * scale), math.ceil(in_w * scale))\n    kernel_width = 4\n    kernel = 'cubic'\n    (weights_h, indices_h, sym_len_hs, sym_len_he) = calculate_weights_indices(in_h, out_h, scale, kernel, kernel_width, antialiasing)\n    (weights_w, indices_w, sym_len_ws, sym_len_we) = calculate_weights_indices(in_w, out_w, scale, kernel, kernel_width, antialiasing)\n    img_aug = torch.FloatTensor(in_c, in_h + sym_len_hs + sym_len_he, in_w)\n    img_aug.narrow(1, sym_len_hs, in_h).copy_(img)\n    sym_patch = img[:, :sym_len_hs, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, 0, sym_len_hs).copy_(sym_patch_inv)\n    sym_patch = img[:, -sym_len_he:, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, sym_len_hs + in_h, sym_len_he).copy_(sym_patch_inv)\n    out_1 = torch.FloatTensor(in_c, out_h, in_w)\n    kernel_width = weights_h.size(1)\n    for i in range(out_h):\n        idx = int(indices_h[i][0])\n        for j in range(in_c):\n            out_1[j, i, :] = img_aug[j, idx:idx + kernel_width, :].transpose(0, 1).mv(weights_h[i])\n    out_1_aug = torch.FloatTensor(in_c, out_h, in_w + sym_len_ws + sym_len_we)\n    out_1_aug.narrow(2, sym_len_ws, in_w).copy_(out_1)\n    sym_patch = out_1[:, :, :sym_len_ws]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, 0, sym_len_ws).copy_(sym_patch_inv)\n    sym_patch = out_1[:, :, -sym_len_we:]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, sym_len_ws + in_w, sym_len_we).copy_(sym_patch_inv)\n    out_2 = torch.FloatTensor(in_c, out_h, out_w)\n    kernel_width = weights_w.size(1)\n    for i in range(out_w):\n        idx = int(indices_w[i][0])\n        for j in range(in_c):\n            out_2[j, :, i] = out_1_aug[j, :, idx:idx + kernel_width].mv(weights_w[i])\n    if squeeze_flag:\n        out_2 = out_2.squeeze(0)\n    if numpy_type:\n        out_2 = out_2.numpy()\n        if not squeeze_flag:\n            out_2 = out_2.transpose(1, 2, 0)\n    return out_2",
            "@torch.no_grad()\ndef imresize(img, scale, antialiasing=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'imresize function same as MATLAB.\\n    It now only supports bicubic.\\n    The same scale applies for both height and width.\\n    Args:\\n        img (Tensor | Numpy array):\\n            Tensor: Input image with shape (c, h, w), [0, 1] range.\\n            Numpy: Input image with shape (h, w, c), [0, 1] range.\\n        scale (float): Scale factor. The same scale applies for both height\\n            and width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n            Default: True.\\n    Returns:\\n        Tensor: Output image with shape (c, h, w), [0, 1] range, w/o round.\\n    '\n    squeeze_flag = False\n    if type(img).__module__ == np.__name__:\n        numpy_type = True\n        if img.ndim == 2:\n            img = img[:, :, None]\n            squeeze_flag = True\n        img = torch.from_numpy(img.transpose(2, 0, 1)).float()\n    else:\n        numpy_type = False\n        if img.ndim == 2:\n            img = img.unsqueeze(0)\n            squeeze_flag = True\n    (in_c, in_h, in_w) = img.size()\n    (out_h, out_w) = (math.ceil(in_h * scale), math.ceil(in_w * scale))\n    kernel_width = 4\n    kernel = 'cubic'\n    (weights_h, indices_h, sym_len_hs, sym_len_he) = calculate_weights_indices(in_h, out_h, scale, kernel, kernel_width, antialiasing)\n    (weights_w, indices_w, sym_len_ws, sym_len_we) = calculate_weights_indices(in_w, out_w, scale, kernel, kernel_width, antialiasing)\n    img_aug = torch.FloatTensor(in_c, in_h + sym_len_hs + sym_len_he, in_w)\n    img_aug.narrow(1, sym_len_hs, in_h).copy_(img)\n    sym_patch = img[:, :sym_len_hs, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, 0, sym_len_hs).copy_(sym_patch_inv)\n    sym_patch = img[:, -sym_len_he:, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, sym_len_hs + in_h, sym_len_he).copy_(sym_patch_inv)\n    out_1 = torch.FloatTensor(in_c, out_h, in_w)\n    kernel_width = weights_h.size(1)\n    for i in range(out_h):\n        idx = int(indices_h[i][0])\n        for j in range(in_c):\n            out_1[j, i, :] = img_aug[j, idx:idx + kernel_width, :].transpose(0, 1).mv(weights_h[i])\n    out_1_aug = torch.FloatTensor(in_c, out_h, in_w + sym_len_ws + sym_len_we)\n    out_1_aug.narrow(2, sym_len_ws, in_w).copy_(out_1)\n    sym_patch = out_1[:, :, :sym_len_ws]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, 0, sym_len_ws).copy_(sym_patch_inv)\n    sym_patch = out_1[:, :, -sym_len_we:]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, sym_len_ws + in_w, sym_len_we).copy_(sym_patch_inv)\n    out_2 = torch.FloatTensor(in_c, out_h, out_w)\n    kernel_width = weights_w.size(1)\n    for i in range(out_w):\n        idx = int(indices_w[i][0])\n        for j in range(in_c):\n            out_2[j, :, i] = out_1_aug[j, :, idx:idx + kernel_width].mv(weights_w[i])\n    if squeeze_flag:\n        out_2 = out_2.squeeze(0)\n    if numpy_type:\n        out_2 = out_2.numpy()\n        if not squeeze_flag:\n            out_2 = out_2.transpose(1, 2, 0)\n    return out_2",
            "@torch.no_grad()\ndef imresize(img, scale, antialiasing=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'imresize function same as MATLAB.\\n    It now only supports bicubic.\\n    The same scale applies for both height and width.\\n    Args:\\n        img (Tensor | Numpy array):\\n            Tensor: Input image with shape (c, h, w), [0, 1] range.\\n            Numpy: Input image with shape (h, w, c), [0, 1] range.\\n        scale (float): Scale factor. The same scale applies for both height\\n            and width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n            Default: True.\\n    Returns:\\n        Tensor: Output image with shape (c, h, w), [0, 1] range, w/o round.\\n    '\n    squeeze_flag = False\n    if type(img).__module__ == np.__name__:\n        numpy_type = True\n        if img.ndim == 2:\n            img = img[:, :, None]\n            squeeze_flag = True\n        img = torch.from_numpy(img.transpose(2, 0, 1)).float()\n    else:\n        numpy_type = False\n        if img.ndim == 2:\n            img = img.unsqueeze(0)\n            squeeze_flag = True\n    (in_c, in_h, in_w) = img.size()\n    (out_h, out_w) = (math.ceil(in_h * scale), math.ceil(in_w * scale))\n    kernel_width = 4\n    kernel = 'cubic'\n    (weights_h, indices_h, sym_len_hs, sym_len_he) = calculate_weights_indices(in_h, out_h, scale, kernel, kernel_width, antialiasing)\n    (weights_w, indices_w, sym_len_ws, sym_len_we) = calculate_weights_indices(in_w, out_w, scale, kernel, kernel_width, antialiasing)\n    img_aug = torch.FloatTensor(in_c, in_h + sym_len_hs + sym_len_he, in_w)\n    img_aug.narrow(1, sym_len_hs, in_h).copy_(img)\n    sym_patch = img[:, :sym_len_hs, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, 0, sym_len_hs).copy_(sym_patch_inv)\n    sym_patch = img[:, -sym_len_he:, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, sym_len_hs + in_h, sym_len_he).copy_(sym_patch_inv)\n    out_1 = torch.FloatTensor(in_c, out_h, in_w)\n    kernel_width = weights_h.size(1)\n    for i in range(out_h):\n        idx = int(indices_h[i][0])\n        for j in range(in_c):\n            out_1[j, i, :] = img_aug[j, idx:idx + kernel_width, :].transpose(0, 1).mv(weights_h[i])\n    out_1_aug = torch.FloatTensor(in_c, out_h, in_w + sym_len_ws + sym_len_we)\n    out_1_aug.narrow(2, sym_len_ws, in_w).copy_(out_1)\n    sym_patch = out_1[:, :, :sym_len_ws]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, 0, sym_len_ws).copy_(sym_patch_inv)\n    sym_patch = out_1[:, :, -sym_len_we:]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, sym_len_ws + in_w, sym_len_we).copy_(sym_patch_inv)\n    out_2 = torch.FloatTensor(in_c, out_h, out_w)\n    kernel_width = weights_w.size(1)\n    for i in range(out_w):\n        idx = int(indices_w[i][0])\n        for j in range(in_c):\n            out_2[j, :, i] = out_1_aug[j, :, idx:idx + kernel_width].mv(weights_w[i])\n    if squeeze_flag:\n        out_2 = out_2.squeeze(0)\n    if numpy_type:\n        out_2 = out_2.numpy()\n        if not squeeze_flag:\n            out_2 = out_2.transpose(1, 2, 0)\n    return out_2",
            "@torch.no_grad()\ndef imresize(img, scale, antialiasing=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'imresize function same as MATLAB.\\n    It now only supports bicubic.\\n    The same scale applies for both height and width.\\n    Args:\\n        img (Tensor | Numpy array):\\n            Tensor: Input image with shape (c, h, w), [0, 1] range.\\n            Numpy: Input image with shape (h, w, c), [0, 1] range.\\n        scale (float): Scale factor. The same scale applies for both height\\n            and width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n            Default: True.\\n    Returns:\\n        Tensor: Output image with shape (c, h, w), [0, 1] range, w/o round.\\n    '\n    squeeze_flag = False\n    if type(img).__module__ == np.__name__:\n        numpy_type = True\n        if img.ndim == 2:\n            img = img[:, :, None]\n            squeeze_flag = True\n        img = torch.from_numpy(img.transpose(2, 0, 1)).float()\n    else:\n        numpy_type = False\n        if img.ndim == 2:\n            img = img.unsqueeze(0)\n            squeeze_flag = True\n    (in_c, in_h, in_w) = img.size()\n    (out_h, out_w) = (math.ceil(in_h * scale), math.ceil(in_w * scale))\n    kernel_width = 4\n    kernel = 'cubic'\n    (weights_h, indices_h, sym_len_hs, sym_len_he) = calculate_weights_indices(in_h, out_h, scale, kernel, kernel_width, antialiasing)\n    (weights_w, indices_w, sym_len_ws, sym_len_we) = calculate_weights_indices(in_w, out_w, scale, kernel, kernel_width, antialiasing)\n    img_aug = torch.FloatTensor(in_c, in_h + sym_len_hs + sym_len_he, in_w)\n    img_aug.narrow(1, sym_len_hs, in_h).copy_(img)\n    sym_patch = img[:, :sym_len_hs, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, 0, sym_len_hs).copy_(sym_patch_inv)\n    sym_patch = img[:, -sym_len_he:, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, sym_len_hs + in_h, sym_len_he).copy_(sym_patch_inv)\n    out_1 = torch.FloatTensor(in_c, out_h, in_w)\n    kernel_width = weights_h.size(1)\n    for i in range(out_h):\n        idx = int(indices_h[i][0])\n        for j in range(in_c):\n            out_1[j, i, :] = img_aug[j, idx:idx + kernel_width, :].transpose(0, 1).mv(weights_h[i])\n    out_1_aug = torch.FloatTensor(in_c, out_h, in_w + sym_len_ws + sym_len_we)\n    out_1_aug.narrow(2, sym_len_ws, in_w).copy_(out_1)\n    sym_patch = out_1[:, :, :sym_len_ws]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, 0, sym_len_ws).copy_(sym_patch_inv)\n    sym_patch = out_1[:, :, -sym_len_we:]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, sym_len_ws + in_w, sym_len_we).copy_(sym_patch_inv)\n    out_2 = torch.FloatTensor(in_c, out_h, out_w)\n    kernel_width = weights_w.size(1)\n    for i in range(out_w):\n        idx = int(indices_w[i][0])\n        for j in range(in_c):\n            out_2[j, :, i] = out_1_aug[j, :, idx:idx + kernel_width].mv(weights_w[i])\n    if squeeze_flag:\n        out_2 = out_2.squeeze(0)\n    if numpy_type:\n        out_2 = out_2.numpy()\n        if not squeeze_flag:\n            out_2 = out_2.transpose(1, 2, 0)\n    return out_2",
            "@torch.no_grad()\ndef imresize(img, scale, antialiasing=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'imresize function same as MATLAB.\\n    It now only supports bicubic.\\n    The same scale applies for both height and width.\\n    Args:\\n        img (Tensor | Numpy array):\\n            Tensor: Input image with shape (c, h, w), [0, 1] range.\\n            Numpy: Input image with shape (h, w, c), [0, 1] range.\\n        scale (float): Scale factor. The same scale applies for both height\\n            and width.\\n        antialiasing (bool): Whether to apply anti-aliasing when downsampling.\\n            Default: True.\\n    Returns:\\n        Tensor: Output image with shape (c, h, w), [0, 1] range, w/o round.\\n    '\n    squeeze_flag = False\n    if type(img).__module__ == np.__name__:\n        numpy_type = True\n        if img.ndim == 2:\n            img = img[:, :, None]\n            squeeze_flag = True\n        img = torch.from_numpy(img.transpose(2, 0, 1)).float()\n    else:\n        numpy_type = False\n        if img.ndim == 2:\n            img = img.unsqueeze(0)\n            squeeze_flag = True\n    (in_c, in_h, in_w) = img.size()\n    (out_h, out_w) = (math.ceil(in_h * scale), math.ceil(in_w * scale))\n    kernel_width = 4\n    kernel = 'cubic'\n    (weights_h, indices_h, sym_len_hs, sym_len_he) = calculate_weights_indices(in_h, out_h, scale, kernel, kernel_width, antialiasing)\n    (weights_w, indices_w, sym_len_ws, sym_len_we) = calculate_weights_indices(in_w, out_w, scale, kernel, kernel_width, antialiasing)\n    img_aug = torch.FloatTensor(in_c, in_h + sym_len_hs + sym_len_he, in_w)\n    img_aug.narrow(1, sym_len_hs, in_h).copy_(img)\n    sym_patch = img[:, :sym_len_hs, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, 0, sym_len_hs).copy_(sym_patch_inv)\n    sym_patch = img[:, -sym_len_he:, :]\n    inv_idx = torch.arange(sym_patch.size(1) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(1, inv_idx)\n    img_aug.narrow(1, sym_len_hs + in_h, sym_len_he).copy_(sym_patch_inv)\n    out_1 = torch.FloatTensor(in_c, out_h, in_w)\n    kernel_width = weights_h.size(1)\n    for i in range(out_h):\n        idx = int(indices_h[i][0])\n        for j in range(in_c):\n            out_1[j, i, :] = img_aug[j, idx:idx + kernel_width, :].transpose(0, 1).mv(weights_h[i])\n    out_1_aug = torch.FloatTensor(in_c, out_h, in_w + sym_len_ws + sym_len_we)\n    out_1_aug.narrow(2, sym_len_ws, in_w).copy_(out_1)\n    sym_patch = out_1[:, :, :sym_len_ws]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, 0, sym_len_ws).copy_(sym_patch_inv)\n    sym_patch = out_1[:, :, -sym_len_we:]\n    inv_idx = torch.arange(sym_patch.size(2) - 1, -1, -1).long()\n    sym_patch_inv = sym_patch.index_select(2, inv_idx)\n    out_1_aug.narrow(2, sym_len_ws + in_w, sym_len_we).copy_(sym_patch_inv)\n    out_2 = torch.FloatTensor(in_c, out_h, out_w)\n    kernel_width = weights_w.size(1)\n    for i in range(out_w):\n        idx = int(indices_w[i][0])\n        for j in range(in_c):\n            out_2[j, :, i] = out_1_aug[j, :, idx:idx + kernel_width].mv(weights_w[i])\n    if squeeze_flag:\n        out_2 = out_2.squeeze(0)\n    if numpy_type:\n        out_2 = out_2.numpy()\n        if not squeeze_flag:\n            out_2 = out_2.transpose(1, 2, 0)\n    return out_2"
        ]
    }
]