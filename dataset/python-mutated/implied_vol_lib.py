"""Calculation of the Black-Scholes implied volatility via Newton's method."""
import enum
from tf_quant_finance.black_scholes import implied_vol_approximation as approx
from tf_quant_finance.black_scholes import implied_vol_newton_root as newton
from tf_quant_finance.black_scholes import implied_vol_utils as utils

@enum.unique
class ImpliedVolMethod(enum.Enum):
    """Implied volatility methods.

  * `FAST_APPROX`: A faster but approximate method.
  * `NEWTON`: Uses Newton root search to find an accurate value.
  """
    FAST_APPROX = 1
    NEWTON = 2

def implied_vol(*, prices, strikes, expiries, spots=None, forwards=None, discount_factors=None, is_call_options=None, method=ImpliedVolMethod.NEWTON, underlying_distribution=utils.UnderlyingDistribution.LOG_NORMAL, validate_args=False, dtype=None, name=None, **kwargs):
    if False:
        print('Hello World!')
    "Finds the implied volatilities of options under the Black Scholes model.\n\n  #### Examples\n  ```python\n  import numpy as np\n  import tf_quant_finance as tff\n  forwards = np.array([1.0, 1.0, 1.0, 1.0])\n  strikes = np.array([1.0, 2.0, 1.0, 0.5])\n  expiries = np.array([1.0, 2.0, 1.0, 3.0])\n  discount_factors = np.array([0.95, 0.9, 0.95, 0.8])\n  is_call_options = np.array([True, True, False, False])\n  volatilities = np.array([0.5, 0.3, 0.2, 1.0])\n  prices = tff.black_scholes.option_price(\n      volatilities=volatilities,\n      strikes=strikes,\n      expiries=expiries,\n      forwards=forwards,\n      discount_factors=discount_factors,\n      is_call_options=is_call_options)\n  implied_vols = tff.black_scholes.implied_vol(\n      prices=prices,\n      strikes=strikes,\n      expiries=expiries,\n      forwards=forwards,\n      discount_factors=discount_factors,\n      is_call_options=is_call_options)\n  # Expected output:\n  # [0.5, 0.3, 0.2, 1.0]\n\n  Args:\n    prices: A real `Tensor` of any shape. The prices of the options whose\n      implied vol is to be calculated.\n    strikes: A real `Tensor` of the same dtype as `prices` and a shape that\n      broadcasts with `prices`. The strikes of the options.\n    expiries: A real `Tensor` of the same dtype as `prices` and a shape that\n      broadcasts with `prices`. The expiry for each option. The units should be\n      such that `expiry * volatility**2` is dimensionless.\n    spots: A real `Tensor` of any shape that broadcasts to the shape of the\n      `prices`. The current spot price of the underlying. Either this argument\n      or the `forwards` (but not both) must be supplied.\n      Default value: None.\n    forwards: A real `Tensor` of any shape that broadcasts to the shape of\n      `prices`. The forwards to maturity. Either this argument or the `spots`\n      must be supplied but both must not be supplied.\n      Default value: None.\n    discount_factors: An optional real `Tensor` of same dtype as the `prices`.\n      If not None, these are the discount factors to expiry (i.e. e^(-rT)). If\n      None, no discounting is applied (i.e. it is assumed that the undiscounted\n      option prices are provided ). If `spots` is supplied and\n      `discount_factors` is not None then this is also used to compute the\n      forwards to expiry.\n      Default value: None, equivalent to discount factors = 1.\n    is_call_options: A boolean `Tensor` of a shape compatible with `prices`.\n      Indicates whether the option is a call (if True) or a put (if False). If\n      not supplied, call options are assumed.\n      Default value: None.\n    method: Enum value of ImpliedVolMethod to select the algorithm to use to\n      infer the implied volatility.\n      Default value: ImpliedVolMethod.NEWTON\n    underlying_distribution: Enum value of ImpliedVolUnderlyingDistribution to\n      select the distribution of the underlying.\n      Default value: UnderlyingDistribution.LOG_NORMAL\n    validate_args: A Python bool. If True, indicates that arguments should be\n      checked for correctness before performing the computation. The checks\n      performed are: (1) Forwards and strikes are positive. (2) The prices\n        satisfy the arbitrage bounds (i.e. for call options, checks the\n        inequality `max(F-K, 0) <= Price <= F` and for put options, checks that\n        `max(K-F, 0) <= Price <= K`.). (3) Checks that the prices are not too\n        close to the bounds. It is numerically unstable to compute the implied\n        vols from options too far in the money or out of the money.\n      Default value: False.\n    dtype: `tf.Dtype` to use when converting arguments to `Tensor`s. If not\n      supplied, the default TensorFlow conversion will take place. Note that\n      this argument does not do any casting for `Tensor`s or numpy arrays.\n      Default value: None.\n    name: (Optional) Python str. The name prefixed to the ops created by this\n      function. If not supplied, the default name 'implied_vol' is used.\n      Default value: None\n    **kwargs: Any other keyword arguments to be passed to the specific\n      implementation. (See black_scholes.implied_vol_approx and\n      black_scholes.implied_vol_newton for details).\n\n  Returns:\n    implied_vols: A `Tensor` of the same dtype as `prices` and shape as the\n      common broadcasted shape of `(prices, spots/forwards, strikes, expiries)`.\n      The implied volatilities as inferred by the chosen method.\n\n  Raises:\n    ValueError: If both `forwards` and `spots` are supplied or if neither is\n      supplied. Or, if `underlying_distribution` is\n      `UnderlyingDistribution.NORMAL` when `method` is `FAST_APPROX`.\n  "
    if method == ImpliedVolMethod.FAST_APPROX:
        if underlying_distribution is utils.UnderlyingDistribution.NORMAL:
            raise ValueError('Only LOG_NORMAL underlying distribution is supported for FAST_APPROX method.')
        return approx.implied_vol(prices=prices, strikes=strikes, expiries=expiries, spots=spots, forwards=forwards, discount_factors=discount_factors, is_call_options=is_call_options, validate_args=validate_args, dtype=dtype, name=name, **kwargs)
    if method == ImpliedVolMethod.NEWTON:
        return newton.implied_vol(prices=prices, strikes=strikes, expiries=expiries, spots=spots, forwards=forwards, discount_factors=discount_factors, is_call_options=is_call_options, underlying_distribution=underlying_distribution, validate_args=validate_args, dtype=dtype, name=name, **kwargs)[0]
    raise ValueError('Unknown implied vol method {}'.format(method))