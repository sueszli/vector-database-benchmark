[
    {
        "func_name": "__init__",
        "original": "def __init__(self, pre_anchor_topk=50, bbox_thr=0.6, gamma=2.0, alpha=0.5, init_cfg=None, **kwargs):\n    super().__init__(init_cfg=init_cfg, **kwargs)\n    self.pre_anchor_topk = pre_anchor_topk\n    self.bbox_thr = bbox_thr\n    self.gamma = gamma\n    self.alpha = alpha",
        "mutated": [
            "def __init__(self, pre_anchor_topk=50, bbox_thr=0.6, gamma=2.0, alpha=0.5, init_cfg=None, **kwargs):\n    if False:\n        i = 10\n    super().__init__(init_cfg=init_cfg, **kwargs)\n    self.pre_anchor_topk = pre_anchor_topk\n    self.bbox_thr = bbox_thr\n    self.gamma = gamma\n    self.alpha = alpha",
            "def __init__(self, pre_anchor_topk=50, bbox_thr=0.6, gamma=2.0, alpha=0.5, init_cfg=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(init_cfg=init_cfg, **kwargs)\n    self.pre_anchor_topk = pre_anchor_topk\n    self.bbox_thr = bbox_thr\n    self.gamma = gamma\n    self.alpha = alpha",
            "def __init__(self, pre_anchor_topk=50, bbox_thr=0.6, gamma=2.0, alpha=0.5, init_cfg=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(init_cfg=init_cfg, **kwargs)\n    self.pre_anchor_topk = pre_anchor_topk\n    self.bbox_thr = bbox_thr\n    self.gamma = gamma\n    self.alpha = alpha",
            "def __init__(self, pre_anchor_topk=50, bbox_thr=0.6, gamma=2.0, alpha=0.5, init_cfg=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(init_cfg=init_cfg, **kwargs)\n    self.pre_anchor_topk = pre_anchor_topk\n    self.bbox_thr = bbox_thr\n    self.gamma = gamma\n    self.alpha = alpha",
            "def __init__(self, pre_anchor_topk=50, bbox_thr=0.6, gamma=2.0, alpha=0.5, init_cfg=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(init_cfg=init_cfg, **kwargs)\n    self.pre_anchor_topk = pre_anchor_topk\n    self.bbox_thr = bbox_thr\n    self.gamma = gamma\n    self.alpha = alpha"
        ]
    },
    {
        "func_name": "loss",
        "original": "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    \"\"\"Calculate loss of FreeAnchor head.\n\n        Args:\n            cls_scores (list[torch.Tensor]): Classification scores of\n                different samples.\n            bbox_preds (list[torch.Tensor]): Box predictions of\n                different samples\n            dir_cls_preds (list[torch.Tensor]): Direction predictions of\n                different samples\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes.\n            gt_labels (list[torch.Tensor]): Ground truth labels.\n            input_metas (list[dict]): List of input meta information.\n            gt_bboxes_ignore (list[:obj:`BaseInstance3DBoxes`], optional):\n                Ground truth boxes that should be ignored. Defaults to None.\n\n        Returns:\n            dict[str, torch.Tensor]: Loss items.\n\n                - positive_bag_loss (torch.Tensor): Loss of positive samples.\n                - negative_bag_loss (torch.Tensor): Loss of negative samples.\n        \"\"\"\n    featmap_sizes = [featmap.size()[-2:] for featmap in cls_scores]\n    assert len(featmap_sizes) == self.anchor_generator.num_levels\n    anchor_list = self.get_anchors(featmap_sizes, input_metas)\n    anchors = [torch.cat(anchor) for anchor in anchor_list]\n    cls_scores = [cls_score.permute(0, 2, 3, 1).reshape(cls_score.size(0), -1, self.num_classes) for cls_score in cls_scores]\n    bbox_preds = [bbox_pred.permute(0, 2, 3, 1).reshape(bbox_pred.size(0), -1, self.box_code_size) for bbox_pred in bbox_preds]\n    dir_cls_preds = [dir_cls_pred.permute(0, 2, 3, 1).reshape(dir_cls_pred.size(0), -1, 2) for dir_cls_pred in dir_cls_preds]\n    cls_scores = torch.cat(cls_scores, dim=1)\n    bbox_preds = torch.cat(bbox_preds, dim=1)\n    dir_cls_preds = torch.cat(dir_cls_preds, dim=1)\n    cls_prob = torch.sigmoid(cls_scores)\n    box_prob = []\n    num_pos = 0\n    positive_losses = []\n    for (_, (anchors_, gt_labels_, gt_bboxes_, cls_prob_, bbox_preds_, dir_cls_preds_)) in enumerate(zip(anchors, gt_labels, gt_bboxes, cls_prob, bbox_preds, dir_cls_preds)):\n        gt_bboxes_ = gt_bboxes_.tensor.to(anchors_.device)\n        with torch.no_grad():\n            pred_boxes = self.bbox_coder.decode(anchors_, bbox_preds_)\n            object_box_iou = bbox_overlaps_nearest_3d(gt_bboxes_, pred_boxes)\n            t1 = self.bbox_thr\n            t2 = object_box_iou.max(dim=1, keepdim=True).values.clamp(min=t1 + 1e-06)\n            object_box_prob = ((object_box_iou - t1) / (t2 - t1)).clamp(min=0, max=1)\n            num_obj = gt_labels_.size(0)\n            indices = torch.stack([torch.arange(num_obj).type_as(gt_labels_), gt_labels_], dim=0)\n            object_cls_box_prob = torch.sparse_coo_tensor(indices, object_box_prob)\n            '\\n                from \"start\" to \"end\" implement:\\n                image_box_iou = torch.sparse.max(object_cls_box_prob,\\n                                                 dim=0).t()\\n\\n                '\n            box_cls_prob = torch.sparse.sum(object_cls_box_prob, dim=0).to_dense()\n            indices = torch.nonzero(box_cls_prob, as_tuple=False).t_()\n            if indices.numel() == 0:\n                image_box_prob = torch.zeros(anchors_.size(0), self.num_classes).type_as(object_box_prob)\n            else:\n                nonzero_box_prob = torch.where(gt_labels_.unsqueeze(dim=-1) == indices[0], object_box_prob[:, indices[1]], torch.tensor([0]).type_as(object_box_prob)).max(dim=0).values\n                image_box_prob = torch.sparse_coo_tensor(indices.flip([0]), nonzero_box_prob, size=(anchors_.size(0), self.num_classes)).to_dense()\n            box_prob.append(image_box_prob)\n        match_quality_matrix = bbox_overlaps_nearest_3d(gt_bboxes_, anchors_)\n        (_, matched) = torch.topk(match_quality_matrix, self.pre_anchor_topk, dim=1, sorted=False)\n        del match_quality_matrix\n        matched_cls_prob = torch.gather(cls_prob_[matched], 2, gt_labels_.view(-1, 1, 1).repeat(1, self.pre_anchor_topk, 1)).squeeze(2)\n        matched_anchors = anchors_[matched]\n        matched_object_targets = self.bbox_coder.encode(matched_anchors, gt_bboxes_.unsqueeze(dim=1).expand_as(matched_anchors))\n        loss_dir = None\n        if self.use_direction_classifier:\n            matched_dir_targets = get_direction_target(matched_anchors, matched_object_targets, self.dir_offset, self.dir_limit_offset, one_hot=False)\n            loss_dir = self.loss_dir(dir_cls_preds_[matched].transpose(-2, -1), matched_dir_targets, reduction_override='none')\n        if self.diff_rad_by_sin:\n            (bbox_preds_[matched], matched_object_targets) = self.add_sin_difference(bbox_preds_[matched], matched_object_targets)\n        bbox_weights = matched_anchors.new_ones(matched_anchors.size())\n        code_weight = self.train_cfg.get('code_weight', None)\n        if code_weight:\n            bbox_weights = bbox_weights * bbox_weights.new_tensor(code_weight)\n        loss_bbox = self.loss_bbox(bbox_preds_[matched], matched_object_targets, bbox_weights, reduction_override='none').sum(-1)\n        if loss_dir is not None:\n            loss_bbox += loss_dir\n        matched_box_prob = torch.exp(-loss_bbox)\n        num_pos += len(gt_bboxes_)\n        positive_losses.append(self.positive_bag_loss(matched_cls_prob, matched_box_prob))\n    positive_loss = torch.cat(positive_losses).sum() / max(1, num_pos)\n    box_prob = torch.stack(box_prob, dim=0)\n    negative_loss = self.negative_bag_loss(cls_prob, box_prob).sum() / max(1, num_pos * self.pre_anchor_topk)\n    losses = {'positive_bag_loss': positive_loss, 'negative_bag_loss': negative_loss}\n    return losses",
        "mutated": [
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n    'Calculate loss of FreeAnchor head.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Classification scores of\\n                different samples.\\n            bbox_preds (list[torch.Tensor]): Box predictions of\\n                different samples\\n            dir_cls_preds (list[torch.Tensor]): Direction predictions of\\n                different samples\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes.\\n            gt_labels (list[torch.Tensor]): Ground truth labels.\\n            input_metas (list[dict]): List of input meta information.\\n            gt_bboxes_ignore (list[:obj:`BaseInstance3DBoxes`], optional):\\n                Ground truth boxes that should be ignored. Defaults to None.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Loss items.\\n\\n                - positive_bag_loss (torch.Tensor): Loss of positive samples.\\n                - negative_bag_loss (torch.Tensor): Loss of negative samples.\\n        '\n    featmap_sizes = [featmap.size()[-2:] for featmap in cls_scores]\n    assert len(featmap_sizes) == self.anchor_generator.num_levels\n    anchor_list = self.get_anchors(featmap_sizes, input_metas)\n    anchors = [torch.cat(anchor) for anchor in anchor_list]\n    cls_scores = [cls_score.permute(0, 2, 3, 1).reshape(cls_score.size(0), -1, self.num_classes) for cls_score in cls_scores]\n    bbox_preds = [bbox_pred.permute(0, 2, 3, 1).reshape(bbox_pred.size(0), -1, self.box_code_size) for bbox_pred in bbox_preds]\n    dir_cls_preds = [dir_cls_pred.permute(0, 2, 3, 1).reshape(dir_cls_pred.size(0), -1, 2) for dir_cls_pred in dir_cls_preds]\n    cls_scores = torch.cat(cls_scores, dim=1)\n    bbox_preds = torch.cat(bbox_preds, dim=1)\n    dir_cls_preds = torch.cat(dir_cls_preds, dim=1)\n    cls_prob = torch.sigmoid(cls_scores)\n    box_prob = []\n    num_pos = 0\n    positive_losses = []\n    for (_, (anchors_, gt_labels_, gt_bboxes_, cls_prob_, bbox_preds_, dir_cls_preds_)) in enumerate(zip(anchors, gt_labels, gt_bboxes, cls_prob, bbox_preds, dir_cls_preds)):\n        gt_bboxes_ = gt_bboxes_.tensor.to(anchors_.device)\n        with torch.no_grad():\n            pred_boxes = self.bbox_coder.decode(anchors_, bbox_preds_)\n            object_box_iou = bbox_overlaps_nearest_3d(gt_bboxes_, pred_boxes)\n            t1 = self.bbox_thr\n            t2 = object_box_iou.max(dim=1, keepdim=True).values.clamp(min=t1 + 1e-06)\n            object_box_prob = ((object_box_iou - t1) / (t2 - t1)).clamp(min=0, max=1)\n            num_obj = gt_labels_.size(0)\n            indices = torch.stack([torch.arange(num_obj).type_as(gt_labels_), gt_labels_], dim=0)\n            object_cls_box_prob = torch.sparse_coo_tensor(indices, object_box_prob)\n            '\\n                from \"start\" to \"end\" implement:\\n                image_box_iou = torch.sparse.max(object_cls_box_prob,\\n                                                 dim=0).t()\\n\\n                '\n            box_cls_prob = torch.sparse.sum(object_cls_box_prob, dim=0).to_dense()\n            indices = torch.nonzero(box_cls_prob, as_tuple=False).t_()\n            if indices.numel() == 0:\n                image_box_prob = torch.zeros(anchors_.size(0), self.num_classes).type_as(object_box_prob)\n            else:\n                nonzero_box_prob = torch.where(gt_labels_.unsqueeze(dim=-1) == indices[0], object_box_prob[:, indices[1]], torch.tensor([0]).type_as(object_box_prob)).max(dim=0).values\n                image_box_prob = torch.sparse_coo_tensor(indices.flip([0]), nonzero_box_prob, size=(anchors_.size(0), self.num_classes)).to_dense()\n            box_prob.append(image_box_prob)\n        match_quality_matrix = bbox_overlaps_nearest_3d(gt_bboxes_, anchors_)\n        (_, matched) = torch.topk(match_quality_matrix, self.pre_anchor_topk, dim=1, sorted=False)\n        del match_quality_matrix\n        matched_cls_prob = torch.gather(cls_prob_[matched], 2, gt_labels_.view(-1, 1, 1).repeat(1, self.pre_anchor_topk, 1)).squeeze(2)\n        matched_anchors = anchors_[matched]\n        matched_object_targets = self.bbox_coder.encode(matched_anchors, gt_bboxes_.unsqueeze(dim=1).expand_as(matched_anchors))\n        loss_dir = None\n        if self.use_direction_classifier:\n            matched_dir_targets = get_direction_target(matched_anchors, matched_object_targets, self.dir_offset, self.dir_limit_offset, one_hot=False)\n            loss_dir = self.loss_dir(dir_cls_preds_[matched].transpose(-2, -1), matched_dir_targets, reduction_override='none')\n        if self.diff_rad_by_sin:\n            (bbox_preds_[matched], matched_object_targets) = self.add_sin_difference(bbox_preds_[matched], matched_object_targets)\n        bbox_weights = matched_anchors.new_ones(matched_anchors.size())\n        code_weight = self.train_cfg.get('code_weight', None)\n        if code_weight:\n            bbox_weights = bbox_weights * bbox_weights.new_tensor(code_weight)\n        loss_bbox = self.loss_bbox(bbox_preds_[matched], matched_object_targets, bbox_weights, reduction_override='none').sum(-1)\n        if loss_dir is not None:\n            loss_bbox += loss_dir\n        matched_box_prob = torch.exp(-loss_bbox)\n        num_pos += len(gt_bboxes_)\n        positive_losses.append(self.positive_bag_loss(matched_cls_prob, matched_box_prob))\n    positive_loss = torch.cat(positive_losses).sum() / max(1, num_pos)\n    box_prob = torch.stack(box_prob, dim=0)\n    negative_loss = self.negative_bag_loss(cls_prob, box_prob).sum() / max(1, num_pos * self.pre_anchor_topk)\n    losses = {'positive_bag_loss': positive_loss, 'negative_bag_loss': negative_loss}\n    return losses",
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate loss of FreeAnchor head.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Classification scores of\\n                different samples.\\n            bbox_preds (list[torch.Tensor]): Box predictions of\\n                different samples\\n            dir_cls_preds (list[torch.Tensor]): Direction predictions of\\n                different samples\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes.\\n            gt_labels (list[torch.Tensor]): Ground truth labels.\\n            input_metas (list[dict]): List of input meta information.\\n            gt_bboxes_ignore (list[:obj:`BaseInstance3DBoxes`], optional):\\n                Ground truth boxes that should be ignored. Defaults to None.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Loss items.\\n\\n                - positive_bag_loss (torch.Tensor): Loss of positive samples.\\n                - negative_bag_loss (torch.Tensor): Loss of negative samples.\\n        '\n    featmap_sizes = [featmap.size()[-2:] for featmap in cls_scores]\n    assert len(featmap_sizes) == self.anchor_generator.num_levels\n    anchor_list = self.get_anchors(featmap_sizes, input_metas)\n    anchors = [torch.cat(anchor) for anchor in anchor_list]\n    cls_scores = [cls_score.permute(0, 2, 3, 1).reshape(cls_score.size(0), -1, self.num_classes) for cls_score in cls_scores]\n    bbox_preds = [bbox_pred.permute(0, 2, 3, 1).reshape(bbox_pred.size(0), -1, self.box_code_size) for bbox_pred in bbox_preds]\n    dir_cls_preds = [dir_cls_pred.permute(0, 2, 3, 1).reshape(dir_cls_pred.size(0), -1, 2) for dir_cls_pred in dir_cls_preds]\n    cls_scores = torch.cat(cls_scores, dim=1)\n    bbox_preds = torch.cat(bbox_preds, dim=1)\n    dir_cls_preds = torch.cat(dir_cls_preds, dim=1)\n    cls_prob = torch.sigmoid(cls_scores)\n    box_prob = []\n    num_pos = 0\n    positive_losses = []\n    for (_, (anchors_, gt_labels_, gt_bboxes_, cls_prob_, bbox_preds_, dir_cls_preds_)) in enumerate(zip(anchors, gt_labels, gt_bboxes, cls_prob, bbox_preds, dir_cls_preds)):\n        gt_bboxes_ = gt_bboxes_.tensor.to(anchors_.device)\n        with torch.no_grad():\n            pred_boxes = self.bbox_coder.decode(anchors_, bbox_preds_)\n            object_box_iou = bbox_overlaps_nearest_3d(gt_bboxes_, pred_boxes)\n            t1 = self.bbox_thr\n            t2 = object_box_iou.max(dim=1, keepdim=True).values.clamp(min=t1 + 1e-06)\n            object_box_prob = ((object_box_iou - t1) / (t2 - t1)).clamp(min=0, max=1)\n            num_obj = gt_labels_.size(0)\n            indices = torch.stack([torch.arange(num_obj).type_as(gt_labels_), gt_labels_], dim=0)\n            object_cls_box_prob = torch.sparse_coo_tensor(indices, object_box_prob)\n            '\\n                from \"start\" to \"end\" implement:\\n                image_box_iou = torch.sparse.max(object_cls_box_prob,\\n                                                 dim=0).t()\\n\\n                '\n            box_cls_prob = torch.sparse.sum(object_cls_box_prob, dim=0).to_dense()\n            indices = torch.nonzero(box_cls_prob, as_tuple=False).t_()\n            if indices.numel() == 0:\n                image_box_prob = torch.zeros(anchors_.size(0), self.num_classes).type_as(object_box_prob)\n            else:\n                nonzero_box_prob = torch.where(gt_labels_.unsqueeze(dim=-1) == indices[0], object_box_prob[:, indices[1]], torch.tensor([0]).type_as(object_box_prob)).max(dim=0).values\n                image_box_prob = torch.sparse_coo_tensor(indices.flip([0]), nonzero_box_prob, size=(anchors_.size(0), self.num_classes)).to_dense()\n            box_prob.append(image_box_prob)\n        match_quality_matrix = bbox_overlaps_nearest_3d(gt_bboxes_, anchors_)\n        (_, matched) = torch.topk(match_quality_matrix, self.pre_anchor_topk, dim=1, sorted=False)\n        del match_quality_matrix\n        matched_cls_prob = torch.gather(cls_prob_[matched], 2, gt_labels_.view(-1, 1, 1).repeat(1, self.pre_anchor_topk, 1)).squeeze(2)\n        matched_anchors = anchors_[matched]\n        matched_object_targets = self.bbox_coder.encode(matched_anchors, gt_bboxes_.unsqueeze(dim=1).expand_as(matched_anchors))\n        loss_dir = None\n        if self.use_direction_classifier:\n            matched_dir_targets = get_direction_target(matched_anchors, matched_object_targets, self.dir_offset, self.dir_limit_offset, one_hot=False)\n            loss_dir = self.loss_dir(dir_cls_preds_[matched].transpose(-2, -1), matched_dir_targets, reduction_override='none')\n        if self.diff_rad_by_sin:\n            (bbox_preds_[matched], matched_object_targets) = self.add_sin_difference(bbox_preds_[matched], matched_object_targets)\n        bbox_weights = matched_anchors.new_ones(matched_anchors.size())\n        code_weight = self.train_cfg.get('code_weight', None)\n        if code_weight:\n            bbox_weights = bbox_weights * bbox_weights.new_tensor(code_weight)\n        loss_bbox = self.loss_bbox(bbox_preds_[matched], matched_object_targets, bbox_weights, reduction_override='none').sum(-1)\n        if loss_dir is not None:\n            loss_bbox += loss_dir\n        matched_box_prob = torch.exp(-loss_bbox)\n        num_pos += len(gt_bboxes_)\n        positive_losses.append(self.positive_bag_loss(matched_cls_prob, matched_box_prob))\n    positive_loss = torch.cat(positive_losses).sum() / max(1, num_pos)\n    box_prob = torch.stack(box_prob, dim=0)\n    negative_loss = self.negative_bag_loss(cls_prob, box_prob).sum() / max(1, num_pos * self.pre_anchor_topk)\n    losses = {'positive_bag_loss': positive_loss, 'negative_bag_loss': negative_loss}\n    return losses",
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate loss of FreeAnchor head.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Classification scores of\\n                different samples.\\n            bbox_preds (list[torch.Tensor]): Box predictions of\\n                different samples\\n            dir_cls_preds (list[torch.Tensor]): Direction predictions of\\n                different samples\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes.\\n            gt_labels (list[torch.Tensor]): Ground truth labels.\\n            input_metas (list[dict]): List of input meta information.\\n            gt_bboxes_ignore (list[:obj:`BaseInstance3DBoxes`], optional):\\n                Ground truth boxes that should be ignored. Defaults to None.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Loss items.\\n\\n                - positive_bag_loss (torch.Tensor): Loss of positive samples.\\n                - negative_bag_loss (torch.Tensor): Loss of negative samples.\\n        '\n    featmap_sizes = [featmap.size()[-2:] for featmap in cls_scores]\n    assert len(featmap_sizes) == self.anchor_generator.num_levels\n    anchor_list = self.get_anchors(featmap_sizes, input_metas)\n    anchors = [torch.cat(anchor) for anchor in anchor_list]\n    cls_scores = [cls_score.permute(0, 2, 3, 1).reshape(cls_score.size(0), -1, self.num_classes) for cls_score in cls_scores]\n    bbox_preds = [bbox_pred.permute(0, 2, 3, 1).reshape(bbox_pred.size(0), -1, self.box_code_size) for bbox_pred in bbox_preds]\n    dir_cls_preds = [dir_cls_pred.permute(0, 2, 3, 1).reshape(dir_cls_pred.size(0), -1, 2) for dir_cls_pred in dir_cls_preds]\n    cls_scores = torch.cat(cls_scores, dim=1)\n    bbox_preds = torch.cat(bbox_preds, dim=1)\n    dir_cls_preds = torch.cat(dir_cls_preds, dim=1)\n    cls_prob = torch.sigmoid(cls_scores)\n    box_prob = []\n    num_pos = 0\n    positive_losses = []\n    for (_, (anchors_, gt_labels_, gt_bboxes_, cls_prob_, bbox_preds_, dir_cls_preds_)) in enumerate(zip(anchors, gt_labels, gt_bboxes, cls_prob, bbox_preds, dir_cls_preds)):\n        gt_bboxes_ = gt_bboxes_.tensor.to(anchors_.device)\n        with torch.no_grad():\n            pred_boxes = self.bbox_coder.decode(anchors_, bbox_preds_)\n            object_box_iou = bbox_overlaps_nearest_3d(gt_bboxes_, pred_boxes)\n            t1 = self.bbox_thr\n            t2 = object_box_iou.max(dim=1, keepdim=True).values.clamp(min=t1 + 1e-06)\n            object_box_prob = ((object_box_iou - t1) / (t2 - t1)).clamp(min=0, max=1)\n            num_obj = gt_labels_.size(0)\n            indices = torch.stack([torch.arange(num_obj).type_as(gt_labels_), gt_labels_], dim=0)\n            object_cls_box_prob = torch.sparse_coo_tensor(indices, object_box_prob)\n            '\\n                from \"start\" to \"end\" implement:\\n                image_box_iou = torch.sparse.max(object_cls_box_prob,\\n                                                 dim=0).t()\\n\\n                '\n            box_cls_prob = torch.sparse.sum(object_cls_box_prob, dim=0).to_dense()\n            indices = torch.nonzero(box_cls_prob, as_tuple=False).t_()\n            if indices.numel() == 0:\n                image_box_prob = torch.zeros(anchors_.size(0), self.num_classes).type_as(object_box_prob)\n            else:\n                nonzero_box_prob = torch.where(gt_labels_.unsqueeze(dim=-1) == indices[0], object_box_prob[:, indices[1]], torch.tensor([0]).type_as(object_box_prob)).max(dim=0).values\n                image_box_prob = torch.sparse_coo_tensor(indices.flip([0]), nonzero_box_prob, size=(anchors_.size(0), self.num_classes)).to_dense()\n            box_prob.append(image_box_prob)\n        match_quality_matrix = bbox_overlaps_nearest_3d(gt_bboxes_, anchors_)\n        (_, matched) = torch.topk(match_quality_matrix, self.pre_anchor_topk, dim=1, sorted=False)\n        del match_quality_matrix\n        matched_cls_prob = torch.gather(cls_prob_[matched], 2, gt_labels_.view(-1, 1, 1).repeat(1, self.pre_anchor_topk, 1)).squeeze(2)\n        matched_anchors = anchors_[matched]\n        matched_object_targets = self.bbox_coder.encode(matched_anchors, gt_bboxes_.unsqueeze(dim=1).expand_as(matched_anchors))\n        loss_dir = None\n        if self.use_direction_classifier:\n            matched_dir_targets = get_direction_target(matched_anchors, matched_object_targets, self.dir_offset, self.dir_limit_offset, one_hot=False)\n            loss_dir = self.loss_dir(dir_cls_preds_[matched].transpose(-2, -1), matched_dir_targets, reduction_override='none')\n        if self.diff_rad_by_sin:\n            (bbox_preds_[matched], matched_object_targets) = self.add_sin_difference(bbox_preds_[matched], matched_object_targets)\n        bbox_weights = matched_anchors.new_ones(matched_anchors.size())\n        code_weight = self.train_cfg.get('code_weight', None)\n        if code_weight:\n            bbox_weights = bbox_weights * bbox_weights.new_tensor(code_weight)\n        loss_bbox = self.loss_bbox(bbox_preds_[matched], matched_object_targets, bbox_weights, reduction_override='none').sum(-1)\n        if loss_dir is not None:\n            loss_bbox += loss_dir\n        matched_box_prob = torch.exp(-loss_bbox)\n        num_pos += len(gt_bboxes_)\n        positive_losses.append(self.positive_bag_loss(matched_cls_prob, matched_box_prob))\n    positive_loss = torch.cat(positive_losses).sum() / max(1, num_pos)\n    box_prob = torch.stack(box_prob, dim=0)\n    negative_loss = self.negative_bag_loss(cls_prob, box_prob).sum() / max(1, num_pos * self.pre_anchor_topk)\n    losses = {'positive_bag_loss': positive_loss, 'negative_bag_loss': negative_loss}\n    return losses",
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate loss of FreeAnchor head.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Classification scores of\\n                different samples.\\n            bbox_preds (list[torch.Tensor]): Box predictions of\\n                different samples\\n            dir_cls_preds (list[torch.Tensor]): Direction predictions of\\n                different samples\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes.\\n            gt_labels (list[torch.Tensor]): Ground truth labels.\\n            input_metas (list[dict]): List of input meta information.\\n            gt_bboxes_ignore (list[:obj:`BaseInstance3DBoxes`], optional):\\n                Ground truth boxes that should be ignored. Defaults to None.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Loss items.\\n\\n                - positive_bag_loss (torch.Tensor): Loss of positive samples.\\n                - negative_bag_loss (torch.Tensor): Loss of negative samples.\\n        '\n    featmap_sizes = [featmap.size()[-2:] for featmap in cls_scores]\n    assert len(featmap_sizes) == self.anchor_generator.num_levels\n    anchor_list = self.get_anchors(featmap_sizes, input_metas)\n    anchors = [torch.cat(anchor) for anchor in anchor_list]\n    cls_scores = [cls_score.permute(0, 2, 3, 1).reshape(cls_score.size(0), -1, self.num_classes) for cls_score in cls_scores]\n    bbox_preds = [bbox_pred.permute(0, 2, 3, 1).reshape(bbox_pred.size(0), -1, self.box_code_size) for bbox_pred in bbox_preds]\n    dir_cls_preds = [dir_cls_pred.permute(0, 2, 3, 1).reshape(dir_cls_pred.size(0), -1, 2) for dir_cls_pred in dir_cls_preds]\n    cls_scores = torch.cat(cls_scores, dim=1)\n    bbox_preds = torch.cat(bbox_preds, dim=1)\n    dir_cls_preds = torch.cat(dir_cls_preds, dim=1)\n    cls_prob = torch.sigmoid(cls_scores)\n    box_prob = []\n    num_pos = 0\n    positive_losses = []\n    for (_, (anchors_, gt_labels_, gt_bboxes_, cls_prob_, bbox_preds_, dir_cls_preds_)) in enumerate(zip(anchors, gt_labels, gt_bboxes, cls_prob, bbox_preds, dir_cls_preds)):\n        gt_bboxes_ = gt_bboxes_.tensor.to(anchors_.device)\n        with torch.no_grad():\n            pred_boxes = self.bbox_coder.decode(anchors_, bbox_preds_)\n            object_box_iou = bbox_overlaps_nearest_3d(gt_bboxes_, pred_boxes)\n            t1 = self.bbox_thr\n            t2 = object_box_iou.max(dim=1, keepdim=True).values.clamp(min=t1 + 1e-06)\n            object_box_prob = ((object_box_iou - t1) / (t2 - t1)).clamp(min=0, max=1)\n            num_obj = gt_labels_.size(0)\n            indices = torch.stack([torch.arange(num_obj).type_as(gt_labels_), gt_labels_], dim=0)\n            object_cls_box_prob = torch.sparse_coo_tensor(indices, object_box_prob)\n            '\\n                from \"start\" to \"end\" implement:\\n                image_box_iou = torch.sparse.max(object_cls_box_prob,\\n                                                 dim=0).t()\\n\\n                '\n            box_cls_prob = torch.sparse.sum(object_cls_box_prob, dim=0).to_dense()\n            indices = torch.nonzero(box_cls_prob, as_tuple=False).t_()\n            if indices.numel() == 0:\n                image_box_prob = torch.zeros(anchors_.size(0), self.num_classes).type_as(object_box_prob)\n            else:\n                nonzero_box_prob = torch.where(gt_labels_.unsqueeze(dim=-1) == indices[0], object_box_prob[:, indices[1]], torch.tensor([0]).type_as(object_box_prob)).max(dim=0).values\n                image_box_prob = torch.sparse_coo_tensor(indices.flip([0]), nonzero_box_prob, size=(anchors_.size(0), self.num_classes)).to_dense()\n            box_prob.append(image_box_prob)\n        match_quality_matrix = bbox_overlaps_nearest_3d(gt_bboxes_, anchors_)\n        (_, matched) = torch.topk(match_quality_matrix, self.pre_anchor_topk, dim=1, sorted=False)\n        del match_quality_matrix\n        matched_cls_prob = torch.gather(cls_prob_[matched], 2, gt_labels_.view(-1, 1, 1).repeat(1, self.pre_anchor_topk, 1)).squeeze(2)\n        matched_anchors = anchors_[matched]\n        matched_object_targets = self.bbox_coder.encode(matched_anchors, gt_bboxes_.unsqueeze(dim=1).expand_as(matched_anchors))\n        loss_dir = None\n        if self.use_direction_classifier:\n            matched_dir_targets = get_direction_target(matched_anchors, matched_object_targets, self.dir_offset, self.dir_limit_offset, one_hot=False)\n            loss_dir = self.loss_dir(dir_cls_preds_[matched].transpose(-2, -1), matched_dir_targets, reduction_override='none')\n        if self.diff_rad_by_sin:\n            (bbox_preds_[matched], matched_object_targets) = self.add_sin_difference(bbox_preds_[matched], matched_object_targets)\n        bbox_weights = matched_anchors.new_ones(matched_anchors.size())\n        code_weight = self.train_cfg.get('code_weight', None)\n        if code_weight:\n            bbox_weights = bbox_weights * bbox_weights.new_tensor(code_weight)\n        loss_bbox = self.loss_bbox(bbox_preds_[matched], matched_object_targets, bbox_weights, reduction_override='none').sum(-1)\n        if loss_dir is not None:\n            loss_bbox += loss_dir\n        matched_box_prob = torch.exp(-loss_bbox)\n        num_pos += len(gt_bboxes_)\n        positive_losses.append(self.positive_bag_loss(matched_cls_prob, matched_box_prob))\n    positive_loss = torch.cat(positive_losses).sum() / max(1, num_pos)\n    box_prob = torch.stack(box_prob, dim=0)\n    negative_loss = self.negative_bag_loss(cls_prob, box_prob).sum() / max(1, num_pos * self.pre_anchor_topk)\n    losses = {'positive_bag_loss': positive_loss, 'negative_bag_loss': negative_loss}\n    return losses",
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate loss of FreeAnchor head.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Classification scores of\\n                different samples.\\n            bbox_preds (list[torch.Tensor]): Box predictions of\\n                different samples\\n            dir_cls_preds (list[torch.Tensor]): Direction predictions of\\n                different samples\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes.\\n            gt_labels (list[torch.Tensor]): Ground truth labels.\\n            input_metas (list[dict]): List of input meta information.\\n            gt_bboxes_ignore (list[:obj:`BaseInstance3DBoxes`], optional):\\n                Ground truth boxes that should be ignored. Defaults to None.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Loss items.\\n\\n                - positive_bag_loss (torch.Tensor): Loss of positive samples.\\n                - negative_bag_loss (torch.Tensor): Loss of negative samples.\\n        '\n    featmap_sizes = [featmap.size()[-2:] for featmap in cls_scores]\n    assert len(featmap_sizes) == self.anchor_generator.num_levels\n    anchor_list = self.get_anchors(featmap_sizes, input_metas)\n    anchors = [torch.cat(anchor) for anchor in anchor_list]\n    cls_scores = [cls_score.permute(0, 2, 3, 1).reshape(cls_score.size(0), -1, self.num_classes) for cls_score in cls_scores]\n    bbox_preds = [bbox_pred.permute(0, 2, 3, 1).reshape(bbox_pred.size(0), -1, self.box_code_size) for bbox_pred in bbox_preds]\n    dir_cls_preds = [dir_cls_pred.permute(0, 2, 3, 1).reshape(dir_cls_pred.size(0), -1, 2) for dir_cls_pred in dir_cls_preds]\n    cls_scores = torch.cat(cls_scores, dim=1)\n    bbox_preds = torch.cat(bbox_preds, dim=1)\n    dir_cls_preds = torch.cat(dir_cls_preds, dim=1)\n    cls_prob = torch.sigmoid(cls_scores)\n    box_prob = []\n    num_pos = 0\n    positive_losses = []\n    for (_, (anchors_, gt_labels_, gt_bboxes_, cls_prob_, bbox_preds_, dir_cls_preds_)) in enumerate(zip(anchors, gt_labels, gt_bboxes, cls_prob, bbox_preds, dir_cls_preds)):\n        gt_bboxes_ = gt_bboxes_.tensor.to(anchors_.device)\n        with torch.no_grad():\n            pred_boxes = self.bbox_coder.decode(anchors_, bbox_preds_)\n            object_box_iou = bbox_overlaps_nearest_3d(gt_bboxes_, pred_boxes)\n            t1 = self.bbox_thr\n            t2 = object_box_iou.max(dim=1, keepdim=True).values.clamp(min=t1 + 1e-06)\n            object_box_prob = ((object_box_iou - t1) / (t2 - t1)).clamp(min=0, max=1)\n            num_obj = gt_labels_.size(0)\n            indices = torch.stack([torch.arange(num_obj).type_as(gt_labels_), gt_labels_], dim=0)\n            object_cls_box_prob = torch.sparse_coo_tensor(indices, object_box_prob)\n            '\\n                from \"start\" to \"end\" implement:\\n                image_box_iou = torch.sparse.max(object_cls_box_prob,\\n                                                 dim=0).t()\\n\\n                '\n            box_cls_prob = torch.sparse.sum(object_cls_box_prob, dim=0).to_dense()\n            indices = torch.nonzero(box_cls_prob, as_tuple=False).t_()\n            if indices.numel() == 0:\n                image_box_prob = torch.zeros(anchors_.size(0), self.num_classes).type_as(object_box_prob)\n            else:\n                nonzero_box_prob = torch.where(gt_labels_.unsqueeze(dim=-1) == indices[0], object_box_prob[:, indices[1]], torch.tensor([0]).type_as(object_box_prob)).max(dim=0).values\n                image_box_prob = torch.sparse_coo_tensor(indices.flip([0]), nonzero_box_prob, size=(anchors_.size(0), self.num_classes)).to_dense()\n            box_prob.append(image_box_prob)\n        match_quality_matrix = bbox_overlaps_nearest_3d(gt_bboxes_, anchors_)\n        (_, matched) = torch.topk(match_quality_matrix, self.pre_anchor_topk, dim=1, sorted=False)\n        del match_quality_matrix\n        matched_cls_prob = torch.gather(cls_prob_[matched], 2, gt_labels_.view(-1, 1, 1).repeat(1, self.pre_anchor_topk, 1)).squeeze(2)\n        matched_anchors = anchors_[matched]\n        matched_object_targets = self.bbox_coder.encode(matched_anchors, gt_bboxes_.unsqueeze(dim=1).expand_as(matched_anchors))\n        loss_dir = None\n        if self.use_direction_classifier:\n            matched_dir_targets = get_direction_target(matched_anchors, matched_object_targets, self.dir_offset, self.dir_limit_offset, one_hot=False)\n            loss_dir = self.loss_dir(dir_cls_preds_[matched].transpose(-2, -1), matched_dir_targets, reduction_override='none')\n        if self.diff_rad_by_sin:\n            (bbox_preds_[matched], matched_object_targets) = self.add_sin_difference(bbox_preds_[matched], matched_object_targets)\n        bbox_weights = matched_anchors.new_ones(matched_anchors.size())\n        code_weight = self.train_cfg.get('code_weight', None)\n        if code_weight:\n            bbox_weights = bbox_weights * bbox_weights.new_tensor(code_weight)\n        loss_bbox = self.loss_bbox(bbox_preds_[matched], matched_object_targets, bbox_weights, reduction_override='none').sum(-1)\n        if loss_dir is not None:\n            loss_bbox += loss_dir\n        matched_box_prob = torch.exp(-loss_bbox)\n        num_pos += len(gt_bboxes_)\n        positive_losses.append(self.positive_bag_loss(matched_cls_prob, matched_box_prob))\n    positive_loss = torch.cat(positive_losses).sum() / max(1, num_pos)\n    box_prob = torch.stack(box_prob, dim=0)\n    negative_loss = self.negative_bag_loss(cls_prob, box_prob).sum() / max(1, num_pos * self.pre_anchor_topk)\n    losses = {'positive_bag_loss': positive_loss, 'negative_bag_loss': negative_loss}\n    return losses"
        ]
    },
    {
        "func_name": "positive_bag_loss",
        "original": "def positive_bag_loss(self, matched_cls_prob, matched_box_prob):\n    \"\"\"Generate positive bag loss.\n\n        Args:\n            matched_cls_prob (torch.Tensor): Classification probability\n                of matched positive samples.\n            matched_box_prob (torch.Tensor): Bounding box probability\n                of matched positive samples.\n\n        Returns:\n            torch.Tensor: Loss of positive samples.\n        \"\"\"\n    matched_prob = matched_cls_prob * matched_box_prob\n    weight = 1 / torch.clamp(1 - matched_prob, 1e-12, None)\n    weight /= weight.sum(dim=1).unsqueeze(dim=-1)\n    bag_prob = (weight * matched_prob).sum(dim=1)\n    bag_prob = bag_prob.clamp(0, 1)\n    return self.alpha * F.binary_cross_entropy(bag_prob, torch.ones_like(bag_prob), reduction='none')",
        "mutated": [
            "def positive_bag_loss(self, matched_cls_prob, matched_box_prob):\n    if False:\n        i = 10\n    'Generate positive bag loss.\\n\\n        Args:\\n            matched_cls_prob (torch.Tensor): Classification probability\\n                of matched positive samples.\\n            matched_box_prob (torch.Tensor): Bounding box probability\\n                of matched positive samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of positive samples.\\n        '\n    matched_prob = matched_cls_prob * matched_box_prob\n    weight = 1 / torch.clamp(1 - matched_prob, 1e-12, None)\n    weight /= weight.sum(dim=1).unsqueeze(dim=-1)\n    bag_prob = (weight * matched_prob).sum(dim=1)\n    bag_prob = bag_prob.clamp(0, 1)\n    return self.alpha * F.binary_cross_entropy(bag_prob, torch.ones_like(bag_prob), reduction='none')",
            "def positive_bag_loss(self, matched_cls_prob, matched_box_prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate positive bag loss.\\n\\n        Args:\\n            matched_cls_prob (torch.Tensor): Classification probability\\n                of matched positive samples.\\n            matched_box_prob (torch.Tensor): Bounding box probability\\n                of matched positive samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of positive samples.\\n        '\n    matched_prob = matched_cls_prob * matched_box_prob\n    weight = 1 / torch.clamp(1 - matched_prob, 1e-12, None)\n    weight /= weight.sum(dim=1).unsqueeze(dim=-1)\n    bag_prob = (weight * matched_prob).sum(dim=1)\n    bag_prob = bag_prob.clamp(0, 1)\n    return self.alpha * F.binary_cross_entropy(bag_prob, torch.ones_like(bag_prob), reduction='none')",
            "def positive_bag_loss(self, matched_cls_prob, matched_box_prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate positive bag loss.\\n\\n        Args:\\n            matched_cls_prob (torch.Tensor): Classification probability\\n                of matched positive samples.\\n            matched_box_prob (torch.Tensor): Bounding box probability\\n                of matched positive samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of positive samples.\\n        '\n    matched_prob = matched_cls_prob * matched_box_prob\n    weight = 1 / torch.clamp(1 - matched_prob, 1e-12, None)\n    weight /= weight.sum(dim=1).unsqueeze(dim=-1)\n    bag_prob = (weight * matched_prob).sum(dim=1)\n    bag_prob = bag_prob.clamp(0, 1)\n    return self.alpha * F.binary_cross_entropy(bag_prob, torch.ones_like(bag_prob), reduction='none')",
            "def positive_bag_loss(self, matched_cls_prob, matched_box_prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate positive bag loss.\\n\\n        Args:\\n            matched_cls_prob (torch.Tensor): Classification probability\\n                of matched positive samples.\\n            matched_box_prob (torch.Tensor): Bounding box probability\\n                of matched positive samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of positive samples.\\n        '\n    matched_prob = matched_cls_prob * matched_box_prob\n    weight = 1 / torch.clamp(1 - matched_prob, 1e-12, None)\n    weight /= weight.sum(dim=1).unsqueeze(dim=-1)\n    bag_prob = (weight * matched_prob).sum(dim=1)\n    bag_prob = bag_prob.clamp(0, 1)\n    return self.alpha * F.binary_cross_entropy(bag_prob, torch.ones_like(bag_prob), reduction='none')",
            "def positive_bag_loss(self, matched_cls_prob, matched_box_prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate positive bag loss.\\n\\n        Args:\\n            matched_cls_prob (torch.Tensor): Classification probability\\n                of matched positive samples.\\n            matched_box_prob (torch.Tensor): Bounding box probability\\n                of matched positive samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of positive samples.\\n        '\n    matched_prob = matched_cls_prob * matched_box_prob\n    weight = 1 / torch.clamp(1 - matched_prob, 1e-12, None)\n    weight /= weight.sum(dim=1).unsqueeze(dim=-1)\n    bag_prob = (weight * matched_prob).sum(dim=1)\n    bag_prob = bag_prob.clamp(0, 1)\n    return self.alpha * F.binary_cross_entropy(bag_prob, torch.ones_like(bag_prob), reduction='none')"
        ]
    },
    {
        "func_name": "negative_bag_loss",
        "original": "def negative_bag_loss(self, cls_prob, box_prob):\n    \"\"\"Generate negative bag loss.\n\n        Args:\n            cls_prob (torch.Tensor): Classification probability\n                of negative samples.\n            box_prob (torch.Tensor): Bounding box probability\n                of negative samples.\n\n        Returns:\n            torch.Tensor: Loss of negative samples.\n        \"\"\"\n    prob = cls_prob * (1 - box_prob)\n    prob = prob.clamp(0, 1)\n    negative_bag_loss = prob ** self.gamma * F.binary_cross_entropy(prob, torch.zeros_like(prob), reduction='none')\n    return (1 - self.alpha) * negative_bag_loss",
        "mutated": [
            "def negative_bag_loss(self, cls_prob, box_prob):\n    if False:\n        i = 10\n    'Generate negative bag loss.\\n\\n        Args:\\n            cls_prob (torch.Tensor): Classification probability\\n                of negative samples.\\n            box_prob (torch.Tensor): Bounding box probability\\n                of negative samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of negative samples.\\n        '\n    prob = cls_prob * (1 - box_prob)\n    prob = prob.clamp(0, 1)\n    negative_bag_loss = prob ** self.gamma * F.binary_cross_entropy(prob, torch.zeros_like(prob), reduction='none')\n    return (1 - self.alpha) * negative_bag_loss",
            "def negative_bag_loss(self, cls_prob, box_prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate negative bag loss.\\n\\n        Args:\\n            cls_prob (torch.Tensor): Classification probability\\n                of negative samples.\\n            box_prob (torch.Tensor): Bounding box probability\\n                of negative samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of negative samples.\\n        '\n    prob = cls_prob * (1 - box_prob)\n    prob = prob.clamp(0, 1)\n    negative_bag_loss = prob ** self.gamma * F.binary_cross_entropy(prob, torch.zeros_like(prob), reduction='none')\n    return (1 - self.alpha) * negative_bag_loss",
            "def negative_bag_loss(self, cls_prob, box_prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate negative bag loss.\\n\\n        Args:\\n            cls_prob (torch.Tensor): Classification probability\\n                of negative samples.\\n            box_prob (torch.Tensor): Bounding box probability\\n                of negative samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of negative samples.\\n        '\n    prob = cls_prob * (1 - box_prob)\n    prob = prob.clamp(0, 1)\n    negative_bag_loss = prob ** self.gamma * F.binary_cross_entropy(prob, torch.zeros_like(prob), reduction='none')\n    return (1 - self.alpha) * negative_bag_loss",
            "def negative_bag_loss(self, cls_prob, box_prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate negative bag loss.\\n\\n        Args:\\n            cls_prob (torch.Tensor): Classification probability\\n                of negative samples.\\n            box_prob (torch.Tensor): Bounding box probability\\n                of negative samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of negative samples.\\n        '\n    prob = cls_prob * (1 - box_prob)\n    prob = prob.clamp(0, 1)\n    negative_bag_loss = prob ** self.gamma * F.binary_cross_entropy(prob, torch.zeros_like(prob), reduction='none')\n    return (1 - self.alpha) * negative_bag_loss",
            "def negative_bag_loss(self, cls_prob, box_prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate negative bag loss.\\n\\n        Args:\\n            cls_prob (torch.Tensor): Classification probability\\n                of negative samples.\\n            box_prob (torch.Tensor): Bounding box probability\\n                of negative samples.\\n\\n        Returns:\\n            torch.Tensor: Loss of negative samples.\\n        '\n    prob = cls_prob * (1 - box_prob)\n    prob = prob.clamp(0, 1)\n    negative_bag_loss = prob ** self.gamma * F.binary_cross_entropy(prob, torch.zeros_like(prob), reduction='none')\n    return (1 - self.alpha) * negative_bag_loss"
        ]
    }
]