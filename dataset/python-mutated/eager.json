[
    {
        "func_name": "concat",
        "original": "def concat(items: Iterable[PolarsType], *, how: ConcatMethod='vertical', rechunk: bool=True, parallel: bool=True) -> PolarsType:\n    \"\"\"\n    Combine multiple DataFrames, LazyFrames, or Series into a single object.\n\n    Parameters\n    ----------\n    items\n        DataFrames, LazyFrames, or Series to concatenate.\n    how : {'vertical', 'vertical_relaxed', 'diagonal', 'diagonal_relaxed', 'horizontal', 'align'}\n        Series only support the `vertical` strategy.\n        LazyFrames do not support the `horizontal` strategy.\n\n        * vertical: Applies multiple `vstack` operations.\n        * vertical_relaxed: Same as `vertical`, but additionally coerces columns to\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\n        * diagonal: Finds a union between the column schemas and fills missing column\n          values with `null`.\n        * diagonal_relaxed: Same as `diagonal`, but additionally coerces columns to\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\n        * horizontal: Stacks Series from DataFrames horizontally and fills with `null`\n          if the lengths don't match.\n        * align: Combines frames horizontally, auto-determining the common key columns\n          and aligning rows using the same logic as `align_frames`; this behaviour is\n          patterned after a full outer join, but does not handle column-name collision.\n          (If you need more control, you should use a suitable join method instead).\n    rechunk\n        Make sure that the result data is in contiguous memory.\n    parallel\n        Only relevant for LazyFrames. This determines if the concatenated\n        lazy computations may be executed in parallel.\n\n    Examples\n    --------\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\n    >>> df2 = pl.DataFrame({\"a\": [2], \"b\": [4]})\n    >>> pl.concat([df1, df2])  # default is 'vertical' strategy\n    shape: (2, 2)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 a   \u2506 b   \u2502\n    \u2502 --- \u2506 --- \u2502\n    \u2502 i64 \u2506 i64 \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1   \u2506 3   \u2502\n    \u2502 2   \u2506 4   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\n    >>> df2 = pl.DataFrame({\"a\": [2.5], \"b\": [4]})\n    >>> pl.concat([df1, df2], how=\"vertical_relaxed\")  # 'a' coerced into f64\n    shape: (2, 2)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 a   \u2506 b   \u2502\n    \u2502 --- \u2506 --- \u2502\n    \u2502 f64 \u2506 i64 \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1.0 \u2506 3   \u2502\n    \u2502 2.5 \u2506 4   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n\n    >>> df_h1 = pl.DataFrame({\"l1\": [1, 2], \"l2\": [3, 4]})\n    >>> df_h2 = pl.DataFrame({\"r1\": [5, 6], \"r2\": [7, 8], \"r3\": [9, 10]})\n    >>> pl.concat([df_h1, df_h2], how=\"horizontal\")\n    shape: (2, 5)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 l1  \u2506 l2  \u2506 r1  \u2506 r2  \u2506 r3  \u2502\n    \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502\n    \u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1   \u2506 3   \u2506 5   \u2506 7   \u2506 9   \u2502\n    \u2502 2   \u2506 4   \u2506 6   \u2506 8   \u2506 10  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n\n    >>> df_d1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\n    >>> df_d2 = pl.DataFrame({\"a\": [2], \"c\": [4]})\n    >>> pl.concat([df_d1, df_d2], how=\"diagonal\")\n    shape: (2, 3)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 a   \u2506 b    \u2506 c    \u2502\n    \u2502 --- \u2506 ---  \u2506 ---  \u2502\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1   \u2506 3    \u2506 null \u2502\n    \u2502 2   \u2506 null \u2506 4    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    >>> df_a1 = pl.DataFrame({\"id\": [1, 2], \"x\": [3, 4]})\n    >>> df_a2 = pl.DataFrame({\"id\": [2, 3], \"y\": [5, 6]})\n    >>> df_a3 = pl.DataFrame({\"id\": [1, 3], \"z\": [7, 8]})\n    >>> pl.concat([df_a1, df_a2, df_a3], how=\"align\")\n    shape: (3, 4)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 id  \u2506 x    \u2506 y    \u2506 z    \u2502\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2506 i64  \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1   \u2506 3    \u2506 null \u2506 7    \u2502\n    \u2502 2   \u2506 4    \u2506 5    \u2506 null \u2502\n    \u2502 3   \u2506 null \u2506 6    \u2506 8    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    elems = list(items)\n    if not len(elems) > 0:\n        raise ValueError('cannot concat empty list')\n    elif len(elems) == 1 and isinstance(elems[0], (pl.DataFrame, pl.Series, pl.LazyFrame)):\n        return elems[0]\n    if how == 'align':\n        if not isinstance(elems[0], (pl.DataFrame, pl.LazyFrame)):\n            raise TypeError(f\"'align' strategy is not supported for {type(elems[0]).__name__!r}\")\n        all_columns = list(chain.from_iterable((e.columns for e in elems)))\n        key = {v: k for (k, v) in enumerate(ordered_unique(all_columns))}\n        common_cols = sorted(reduce(lambda x, y: set(x) & set(y), chain((e.columns for e in elems))), key=lambda k: key.get(k, 0))\n        lf: LazyFrame = reduce(lambda x, y: x.join(y, how='outer', on=common_cols, suffix=''), [df.lazy() for df in elems]).sort(by=common_cols)\n        eager = isinstance(elems[0], pl.DataFrame)\n        return lf.collect() if eager else lf\n    out: Series | DataFrame | LazyFrame | Expr\n    first = elems[0]\n    if isinstance(first, pl.DataFrame):\n        if how == 'vertical':\n            out = wrap_df(plr.concat_df(elems))\n        elif how == 'vertical_relaxed':\n            out = wrap_ldf(plr.concat_lf([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'diagonal':\n            out = wrap_df(plr.concat_df_diagonal(elems))\n        elif how == 'diagonal_relaxed':\n            out = wrap_ldf(plr.concat_lf_diagonal([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'horizontal':\n            out = wrap_df(plr.concat_df_horizontal(elems))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod)))\n            raise ValueError(f'DataFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.LazyFrame):\n        if how in ('vertical', 'vertical_relaxed'):\n            return wrap_ldf(plr.concat_lf(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        elif how in ('diagonal', 'diagonal_relaxed'):\n            return wrap_ldf(plr.concat_lf_diagonal(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod) if m != 'horizontal'))\n            raise ValueError(f'LazyFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.Series):\n        if how == 'vertical':\n            out = wrap_s(plr.concat_series(elems))\n        else:\n            raise ValueError(\"Series only supports 'vertical' concat strategy\")\n    elif isinstance(first, pl.Expr):\n        return wrap_expr(plr.concat_expr([e._pyexpr for e in elems], rechunk))\n    else:\n        raise TypeError(f'did not expect type: {type(first).__name__!r} in `concat`')\n    if rechunk:\n        return out.rechunk()\n    return out",
        "mutated": [
            "def concat(items: Iterable[PolarsType], *, how: ConcatMethod='vertical', rechunk: bool=True, parallel: bool=True) -> PolarsType:\n    if False:\n        i = 10\n    '\\n    Combine multiple DataFrames, LazyFrames, or Series into a single object.\\n\\n    Parameters\\n    ----------\\n    items\\n        DataFrames, LazyFrames, or Series to concatenate.\\n    how : {\\'vertical\\', \\'vertical_relaxed\\', \\'diagonal\\', \\'diagonal_relaxed\\', \\'horizontal\\', \\'align\\'}\\n        Series only support the `vertical` strategy.\\n        LazyFrames do not support the `horizontal` strategy.\\n\\n        * vertical: Applies multiple `vstack` operations.\\n        * vertical_relaxed: Same as `vertical`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * diagonal: Finds a union between the column schemas and fills missing column\\n          values with `null`.\\n        * diagonal_relaxed: Same as `diagonal`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * horizontal: Stacks Series from DataFrames horizontally and fills with `null`\\n          if the lengths don\\'t match.\\n        * align: Combines frames horizontally, auto-determining the common key columns\\n          and aligning rows using the same logic as `align_frames`; this behaviour is\\n          patterned after a full outer join, but does not handle column-name collision.\\n          (If you need more control, you should use a suitable join method instead).\\n    rechunk\\n        Make sure that the result data is in contiguous memory.\\n    parallel\\n        Only relevant for LazyFrames. This determines if the concatenated\\n        lazy computations may be executed in parallel.\\n\\n    Examples\\n    --------\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2], \"b\": [4]})\\n    >>> pl.concat([df1, df2])  # default is \\'vertical\\' strategy\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2502\\n    \u2502 2   \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2.5], \"b\": [4]})\\n    >>> pl.concat([df1, df2], how=\"vertical_relaxed\")  # \\'a\\' coerced into f64\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 f64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1.0 \u2506 3   \u2502\\n    \u2502 2.5 \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_h1 = pl.DataFrame({\"l1\": [1, 2], \"l2\": [3, 4]})\\n    >>> df_h2 = pl.DataFrame({\"r1\": [5, 6], \"r2\": [7, 8], \"r3\": [9, 10]})\\n    >>> pl.concat([df_h1, df_h2], how=\"horizontal\")\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 l1  \u2506 l2  \u2506 r1  \u2506 r2  \u2506 r3  \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 5   \u2506 7   \u2506 9   \u2502\\n    \u2502 2   \u2506 4   \u2506 6   \u2506 8   \u2506 10  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_d1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df_d2 = pl.DataFrame({\"a\": [2], \"c\": [4]})\\n    >>> pl.concat([df_d1, df_d2], how=\"diagonal\")\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2502\\n    \u2502 2   \u2506 null \u2506 4    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_a1 = pl.DataFrame({\"id\": [1, 2], \"x\": [3, 4]})\\n    >>> df_a2 = pl.DataFrame({\"id\": [2, 3], \"y\": [5, 6]})\\n    >>> df_a3 = pl.DataFrame({\"id\": [1, 3], \"z\": [7, 8]})\\n    >>> pl.concat([df_a1, df_a2, df_a3], how=\"align\")\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 id  \u2506 x    \u2506 y    \u2506 z    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2506 7    \u2502\\n    \u2502 2   \u2506 4    \u2506 5    \u2506 null \u2502\\n    \u2502 3   \u2506 null \u2506 6    \u2506 8    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    elems = list(items)\n    if not len(elems) > 0:\n        raise ValueError('cannot concat empty list')\n    elif len(elems) == 1 and isinstance(elems[0], (pl.DataFrame, pl.Series, pl.LazyFrame)):\n        return elems[0]\n    if how == 'align':\n        if not isinstance(elems[0], (pl.DataFrame, pl.LazyFrame)):\n            raise TypeError(f\"'align' strategy is not supported for {type(elems[0]).__name__!r}\")\n        all_columns = list(chain.from_iterable((e.columns for e in elems)))\n        key = {v: k for (k, v) in enumerate(ordered_unique(all_columns))}\n        common_cols = sorted(reduce(lambda x, y: set(x) & set(y), chain((e.columns for e in elems))), key=lambda k: key.get(k, 0))\n        lf: LazyFrame = reduce(lambda x, y: x.join(y, how='outer', on=common_cols, suffix=''), [df.lazy() for df in elems]).sort(by=common_cols)\n        eager = isinstance(elems[0], pl.DataFrame)\n        return lf.collect() if eager else lf\n    out: Series | DataFrame | LazyFrame | Expr\n    first = elems[0]\n    if isinstance(first, pl.DataFrame):\n        if how == 'vertical':\n            out = wrap_df(plr.concat_df(elems))\n        elif how == 'vertical_relaxed':\n            out = wrap_ldf(plr.concat_lf([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'diagonal':\n            out = wrap_df(plr.concat_df_diagonal(elems))\n        elif how == 'diagonal_relaxed':\n            out = wrap_ldf(plr.concat_lf_diagonal([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'horizontal':\n            out = wrap_df(plr.concat_df_horizontal(elems))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod)))\n            raise ValueError(f'DataFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.LazyFrame):\n        if how in ('vertical', 'vertical_relaxed'):\n            return wrap_ldf(plr.concat_lf(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        elif how in ('diagonal', 'diagonal_relaxed'):\n            return wrap_ldf(plr.concat_lf_diagonal(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod) if m != 'horizontal'))\n            raise ValueError(f'LazyFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.Series):\n        if how == 'vertical':\n            out = wrap_s(plr.concat_series(elems))\n        else:\n            raise ValueError(\"Series only supports 'vertical' concat strategy\")\n    elif isinstance(first, pl.Expr):\n        return wrap_expr(plr.concat_expr([e._pyexpr for e in elems], rechunk))\n    else:\n        raise TypeError(f'did not expect type: {type(first).__name__!r} in `concat`')\n    if rechunk:\n        return out.rechunk()\n    return out",
            "def concat(items: Iterable[PolarsType], *, how: ConcatMethod='vertical', rechunk: bool=True, parallel: bool=True) -> PolarsType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Combine multiple DataFrames, LazyFrames, or Series into a single object.\\n\\n    Parameters\\n    ----------\\n    items\\n        DataFrames, LazyFrames, or Series to concatenate.\\n    how : {\\'vertical\\', \\'vertical_relaxed\\', \\'diagonal\\', \\'diagonal_relaxed\\', \\'horizontal\\', \\'align\\'}\\n        Series only support the `vertical` strategy.\\n        LazyFrames do not support the `horizontal` strategy.\\n\\n        * vertical: Applies multiple `vstack` operations.\\n        * vertical_relaxed: Same as `vertical`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * diagonal: Finds a union between the column schemas and fills missing column\\n          values with `null`.\\n        * diagonal_relaxed: Same as `diagonal`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * horizontal: Stacks Series from DataFrames horizontally and fills with `null`\\n          if the lengths don\\'t match.\\n        * align: Combines frames horizontally, auto-determining the common key columns\\n          and aligning rows using the same logic as `align_frames`; this behaviour is\\n          patterned after a full outer join, but does not handle column-name collision.\\n          (If you need more control, you should use a suitable join method instead).\\n    rechunk\\n        Make sure that the result data is in contiguous memory.\\n    parallel\\n        Only relevant for LazyFrames. This determines if the concatenated\\n        lazy computations may be executed in parallel.\\n\\n    Examples\\n    --------\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2], \"b\": [4]})\\n    >>> pl.concat([df1, df2])  # default is \\'vertical\\' strategy\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2502\\n    \u2502 2   \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2.5], \"b\": [4]})\\n    >>> pl.concat([df1, df2], how=\"vertical_relaxed\")  # \\'a\\' coerced into f64\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 f64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1.0 \u2506 3   \u2502\\n    \u2502 2.5 \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_h1 = pl.DataFrame({\"l1\": [1, 2], \"l2\": [3, 4]})\\n    >>> df_h2 = pl.DataFrame({\"r1\": [5, 6], \"r2\": [7, 8], \"r3\": [9, 10]})\\n    >>> pl.concat([df_h1, df_h2], how=\"horizontal\")\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 l1  \u2506 l2  \u2506 r1  \u2506 r2  \u2506 r3  \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 5   \u2506 7   \u2506 9   \u2502\\n    \u2502 2   \u2506 4   \u2506 6   \u2506 8   \u2506 10  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_d1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df_d2 = pl.DataFrame({\"a\": [2], \"c\": [4]})\\n    >>> pl.concat([df_d1, df_d2], how=\"diagonal\")\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2502\\n    \u2502 2   \u2506 null \u2506 4    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_a1 = pl.DataFrame({\"id\": [1, 2], \"x\": [3, 4]})\\n    >>> df_a2 = pl.DataFrame({\"id\": [2, 3], \"y\": [5, 6]})\\n    >>> df_a3 = pl.DataFrame({\"id\": [1, 3], \"z\": [7, 8]})\\n    >>> pl.concat([df_a1, df_a2, df_a3], how=\"align\")\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 id  \u2506 x    \u2506 y    \u2506 z    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2506 7    \u2502\\n    \u2502 2   \u2506 4    \u2506 5    \u2506 null \u2502\\n    \u2502 3   \u2506 null \u2506 6    \u2506 8    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    elems = list(items)\n    if not len(elems) > 0:\n        raise ValueError('cannot concat empty list')\n    elif len(elems) == 1 and isinstance(elems[0], (pl.DataFrame, pl.Series, pl.LazyFrame)):\n        return elems[0]\n    if how == 'align':\n        if not isinstance(elems[0], (pl.DataFrame, pl.LazyFrame)):\n            raise TypeError(f\"'align' strategy is not supported for {type(elems[0]).__name__!r}\")\n        all_columns = list(chain.from_iterable((e.columns for e in elems)))\n        key = {v: k for (k, v) in enumerate(ordered_unique(all_columns))}\n        common_cols = sorted(reduce(lambda x, y: set(x) & set(y), chain((e.columns for e in elems))), key=lambda k: key.get(k, 0))\n        lf: LazyFrame = reduce(lambda x, y: x.join(y, how='outer', on=common_cols, suffix=''), [df.lazy() for df in elems]).sort(by=common_cols)\n        eager = isinstance(elems[0], pl.DataFrame)\n        return lf.collect() if eager else lf\n    out: Series | DataFrame | LazyFrame | Expr\n    first = elems[0]\n    if isinstance(first, pl.DataFrame):\n        if how == 'vertical':\n            out = wrap_df(plr.concat_df(elems))\n        elif how == 'vertical_relaxed':\n            out = wrap_ldf(plr.concat_lf([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'diagonal':\n            out = wrap_df(plr.concat_df_diagonal(elems))\n        elif how == 'diagonal_relaxed':\n            out = wrap_ldf(plr.concat_lf_diagonal([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'horizontal':\n            out = wrap_df(plr.concat_df_horizontal(elems))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod)))\n            raise ValueError(f'DataFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.LazyFrame):\n        if how in ('vertical', 'vertical_relaxed'):\n            return wrap_ldf(plr.concat_lf(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        elif how in ('diagonal', 'diagonal_relaxed'):\n            return wrap_ldf(plr.concat_lf_diagonal(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod) if m != 'horizontal'))\n            raise ValueError(f'LazyFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.Series):\n        if how == 'vertical':\n            out = wrap_s(plr.concat_series(elems))\n        else:\n            raise ValueError(\"Series only supports 'vertical' concat strategy\")\n    elif isinstance(first, pl.Expr):\n        return wrap_expr(plr.concat_expr([e._pyexpr for e in elems], rechunk))\n    else:\n        raise TypeError(f'did not expect type: {type(first).__name__!r} in `concat`')\n    if rechunk:\n        return out.rechunk()\n    return out",
            "def concat(items: Iterable[PolarsType], *, how: ConcatMethod='vertical', rechunk: bool=True, parallel: bool=True) -> PolarsType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Combine multiple DataFrames, LazyFrames, or Series into a single object.\\n\\n    Parameters\\n    ----------\\n    items\\n        DataFrames, LazyFrames, or Series to concatenate.\\n    how : {\\'vertical\\', \\'vertical_relaxed\\', \\'diagonal\\', \\'diagonal_relaxed\\', \\'horizontal\\', \\'align\\'}\\n        Series only support the `vertical` strategy.\\n        LazyFrames do not support the `horizontal` strategy.\\n\\n        * vertical: Applies multiple `vstack` operations.\\n        * vertical_relaxed: Same as `vertical`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * diagonal: Finds a union between the column schemas and fills missing column\\n          values with `null`.\\n        * diagonal_relaxed: Same as `diagonal`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * horizontal: Stacks Series from DataFrames horizontally and fills with `null`\\n          if the lengths don\\'t match.\\n        * align: Combines frames horizontally, auto-determining the common key columns\\n          and aligning rows using the same logic as `align_frames`; this behaviour is\\n          patterned after a full outer join, but does not handle column-name collision.\\n          (If you need more control, you should use a suitable join method instead).\\n    rechunk\\n        Make sure that the result data is in contiguous memory.\\n    parallel\\n        Only relevant for LazyFrames. This determines if the concatenated\\n        lazy computations may be executed in parallel.\\n\\n    Examples\\n    --------\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2], \"b\": [4]})\\n    >>> pl.concat([df1, df2])  # default is \\'vertical\\' strategy\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2502\\n    \u2502 2   \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2.5], \"b\": [4]})\\n    >>> pl.concat([df1, df2], how=\"vertical_relaxed\")  # \\'a\\' coerced into f64\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 f64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1.0 \u2506 3   \u2502\\n    \u2502 2.5 \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_h1 = pl.DataFrame({\"l1\": [1, 2], \"l2\": [3, 4]})\\n    >>> df_h2 = pl.DataFrame({\"r1\": [5, 6], \"r2\": [7, 8], \"r3\": [9, 10]})\\n    >>> pl.concat([df_h1, df_h2], how=\"horizontal\")\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 l1  \u2506 l2  \u2506 r1  \u2506 r2  \u2506 r3  \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 5   \u2506 7   \u2506 9   \u2502\\n    \u2502 2   \u2506 4   \u2506 6   \u2506 8   \u2506 10  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_d1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df_d2 = pl.DataFrame({\"a\": [2], \"c\": [4]})\\n    >>> pl.concat([df_d1, df_d2], how=\"diagonal\")\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2502\\n    \u2502 2   \u2506 null \u2506 4    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_a1 = pl.DataFrame({\"id\": [1, 2], \"x\": [3, 4]})\\n    >>> df_a2 = pl.DataFrame({\"id\": [2, 3], \"y\": [5, 6]})\\n    >>> df_a3 = pl.DataFrame({\"id\": [1, 3], \"z\": [7, 8]})\\n    >>> pl.concat([df_a1, df_a2, df_a3], how=\"align\")\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 id  \u2506 x    \u2506 y    \u2506 z    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2506 7    \u2502\\n    \u2502 2   \u2506 4    \u2506 5    \u2506 null \u2502\\n    \u2502 3   \u2506 null \u2506 6    \u2506 8    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    elems = list(items)\n    if not len(elems) > 0:\n        raise ValueError('cannot concat empty list')\n    elif len(elems) == 1 and isinstance(elems[0], (pl.DataFrame, pl.Series, pl.LazyFrame)):\n        return elems[0]\n    if how == 'align':\n        if not isinstance(elems[0], (pl.DataFrame, pl.LazyFrame)):\n            raise TypeError(f\"'align' strategy is not supported for {type(elems[0]).__name__!r}\")\n        all_columns = list(chain.from_iterable((e.columns for e in elems)))\n        key = {v: k for (k, v) in enumerate(ordered_unique(all_columns))}\n        common_cols = sorted(reduce(lambda x, y: set(x) & set(y), chain((e.columns for e in elems))), key=lambda k: key.get(k, 0))\n        lf: LazyFrame = reduce(lambda x, y: x.join(y, how='outer', on=common_cols, suffix=''), [df.lazy() for df in elems]).sort(by=common_cols)\n        eager = isinstance(elems[0], pl.DataFrame)\n        return lf.collect() if eager else lf\n    out: Series | DataFrame | LazyFrame | Expr\n    first = elems[0]\n    if isinstance(first, pl.DataFrame):\n        if how == 'vertical':\n            out = wrap_df(plr.concat_df(elems))\n        elif how == 'vertical_relaxed':\n            out = wrap_ldf(plr.concat_lf([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'diagonal':\n            out = wrap_df(plr.concat_df_diagonal(elems))\n        elif how == 'diagonal_relaxed':\n            out = wrap_ldf(plr.concat_lf_diagonal([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'horizontal':\n            out = wrap_df(plr.concat_df_horizontal(elems))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod)))\n            raise ValueError(f'DataFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.LazyFrame):\n        if how in ('vertical', 'vertical_relaxed'):\n            return wrap_ldf(plr.concat_lf(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        elif how in ('diagonal', 'diagonal_relaxed'):\n            return wrap_ldf(plr.concat_lf_diagonal(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod) if m != 'horizontal'))\n            raise ValueError(f'LazyFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.Series):\n        if how == 'vertical':\n            out = wrap_s(plr.concat_series(elems))\n        else:\n            raise ValueError(\"Series only supports 'vertical' concat strategy\")\n    elif isinstance(first, pl.Expr):\n        return wrap_expr(plr.concat_expr([e._pyexpr for e in elems], rechunk))\n    else:\n        raise TypeError(f'did not expect type: {type(first).__name__!r} in `concat`')\n    if rechunk:\n        return out.rechunk()\n    return out",
            "def concat(items: Iterable[PolarsType], *, how: ConcatMethod='vertical', rechunk: bool=True, parallel: bool=True) -> PolarsType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Combine multiple DataFrames, LazyFrames, or Series into a single object.\\n\\n    Parameters\\n    ----------\\n    items\\n        DataFrames, LazyFrames, or Series to concatenate.\\n    how : {\\'vertical\\', \\'vertical_relaxed\\', \\'diagonal\\', \\'diagonal_relaxed\\', \\'horizontal\\', \\'align\\'}\\n        Series only support the `vertical` strategy.\\n        LazyFrames do not support the `horizontal` strategy.\\n\\n        * vertical: Applies multiple `vstack` operations.\\n        * vertical_relaxed: Same as `vertical`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * diagonal: Finds a union between the column schemas and fills missing column\\n          values with `null`.\\n        * diagonal_relaxed: Same as `diagonal`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * horizontal: Stacks Series from DataFrames horizontally and fills with `null`\\n          if the lengths don\\'t match.\\n        * align: Combines frames horizontally, auto-determining the common key columns\\n          and aligning rows using the same logic as `align_frames`; this behaviour is\\n          patterned after a full outer join, but does not handle column-name collision.\\n          (If you need more control, you should use a suitable join method instead).\\n    rechunk\\n        Make sure that the result data is in contiguous memory.\\n    parallel\\n        Only relevant for LazyFrames. This determines if the concatenated\\n        lazy computations may be executed in parallel.\\n\\n    Examples\\n    --------\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2], \"b\": [4]})\\n    >>> pl.concat([df1, df2])  # default is \\'vertical\\' strategy\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2502\\n    \u2502 2   \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2.5], \"b\": [4]})\\n    >>> pl.concat([df1, df2], how=\"vertical_relaxed\")  # \\'a\\' coerced into f64\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 f64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1.0 \u2506 3   \u2502\\n    \u2502 2.5 \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_h1 = pl.DataFrame({\"l1\": [1, 2], \"l2\": [3, 4]})\\n    >>> df_h2 = pl.DataFrame({\"r1\": [5, 6], \"r2\": [7, 8], \"r3\": [9, 10]})\\n    >>> pl.concat([df_h1, df_h2], how=\"horizontal\")\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 l1  \u2506 l2  \u2506 r1  \u2506 r2  \u2506 r3  \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 5   \u2506 7   \u2506 9   \u2502\\n    \u2502 2   \u2506 4   \u2506 6   \u2506 8   \u2506 10  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_d1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df_d2 = pl.DataFrame({\"a\": [2], \"c\": [4]})\\n    >>> pl.concat([df_d1, df_d2], how=\"diagonal\")\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2502\\n    \u2502 2   \u2506 null \u2506 4    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_a1 = pl.DataFrame({\"id\": [1, 2], \"x\": [3, 4]})\\n    >>> df_a2 = pl.DataFrame({\"id\": [2, 3], \"y\": [5, 6]})\\n    >>> df_a3 = pl.DataFrame({\"id\": [1, 3], \"z\": [7, 8]})\\n    >>> pl.concat([df_a1, df_a2, df_a3], how=\"align\")\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 id  \u2506 x    \u2506 y    \u2506 z    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2506 7    \u2502\\n    \u2502 2   \u2506 4    \u2506 5    \u2506 null \u2502\\n    \u2502 3   \u2506 null \u2506 6    \u2506 8    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    elems = list(items)\n    if not len(elems) > 0:\n        raise ValueError('cannot concat empty list')\n    elif len(elems) == 1 and isinstance(elems[0], (pl.DataFrame, pl.Series, pl.LazyFrame)):\n        return elems[0]\n    if how == 'align':\n        if not isinstance(elems[0], (pl.DataFrame, pl.LazyFrame)):\n            raise TypeError(f\"'align' strategy is not supported for {type(elems[0]).__name__!r}\")\n        all_columns = list(chain.from_iterable((e.columns for e in elems)))\n        key = {v: k for (k, v) in enumerate(ordered_unique(all_columns))}\n        common_cols = sorted(reduce(lambda x, y: set(x) & set(y), chain((e.columns for e in elems))), key=lambda k: key.get(k, 0))\n        lf: LazyFrame = reduce(lambda x, y: x.join(y, how='outer', on=common_cols, suffix=''), [df.lazy() for df in elems]).sort(by=common_cols)\n        eager = isinstance(elems[0], pl.DataFrame)\n        return lf.collect() if eager else lf\n    out: Series | DataFrame | LazyFrame | Expr\n    first = elems[0]\n    if isinstance(first, pl.DataFrame):\n        if how == 'vertical':\n            out = wrap_df(plr.concat_df(elems))\n        elif how == 'vertical_relaxed':\n            out = wrap_ldf(plr.concat_lf([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'diagonal':\n            out = wrap_df(plr.concat_df_diagonal(elems))\n        elif how == 'diagonal_relaxed':\n            out = wrap_ldf(plr.concat_lf_diagonal([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'horizontal':\n            out = wrap_df(plr.concat_df_horizontal(elems))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod)))\n            raise ValueError(f'DataFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.LazyFrame):\n        if how in ('vertical', 'vertical_relaxed'):\n            return wrap_ldf(plr.concat_lf(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        elif how in ('diagonal', 'diagonal_relaxed'):\n            return wrap_ldf(plr.concat_lf_diagonal(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod) if m != 'horizontal'))\n            raise ValueError(f'LazyFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.Series):\n        if how == 'vertical':\n            out = wrap_s(plr.concat_series(elems))\n        else:\n            raise ValueError(\"Series only supports 'vertical' concat strategy\")\n    elif isinstance(first, pl.Expr):\n        return wrap_expr(plr.concat_expr([e._pyexpr for e in elems], rechunk))\n    else:\n        raise TypeError(f'did not expect type: {type(first).__name__!r} in `concat`')\n    if rechunk:\n        return out.rechunk()\n    return out",
            "def concat(items: Iterable[PolarsType], *, how: ConcatMethod='vertical', rechunk: bool=True, parallel: bool=True) -> PolarsType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Combine multiple DataFrames, LazyFrames, or Series into a single object.\\n\\n    Parameters\\n    ----------\\n    items\\n        DataFrames, LazyFrames, or Series to concatenate.\\n    how : {\\'vertical\\', \\'vertical_relaxed\\', \\'diagonal\\', \\'diagonal_relaxed\\', \\'horizontal\\', \\'align\\'}\\n        Series only support the `vertical` strategy.\\n        LazyFrames do not support the `horizontal` strategy.\\n\\n        * vertical: Applies multiple `vstack` operations.\\n        * vertical_relaxed: Same as `vertical`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * diagonal: Finds a union between the column schemas and fills missing column\\n          values with `null`.\\n        * diagonal_relaxed: Same as `diagonal`, but additionally coerces columns to\\n          their common supertype *if* they are mismatched (eg: Int32 \u2192 Int64).\\n        * horizontal: Stacks Series from DataFrames horizontally and fills with `null`\\n          if the lengths don\\'t match.\\n        * align: Combines frames horizontally, auto-determining the common key columns\\n          and aligning rows using the same logic as `align_frames`; this behaviour is\\n          patterned after a full outer join, but does not handle column-name collision.\\n          (If you need more control, you should use a suitable join method instead).\\n    rechunk\\n        Make sure that the result data is in contiguous memory.\\n    parallel\\n        Only relevant for LazyFrames. This determines if the concatenated\\n        lazy computations may be executed in parallel.\\n\\n    Examples\\n    --------\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2], \"b\": [4]})\\n    >>> pl.concat([df1, df2])  # default is \\'vertical\\' strategy\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2502\\n    \u2502 2   \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df2 = pl.DataFrame({\"a\": [2.5], \"b\": [4]})\\n    >>> pl.concat([df1, df2], how=\"vertical_relaxed\")  # \\'a\\' coerced into f64\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b   \u2502\\n    \u2502 --- \u2506 --- \u2502\\n    \u2502 f64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1.0 \u2506 3   \u2502\\n    \u2502 2.5 \u2506 4   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_h1 = pl.DataFrame({\"l1\": [1, 2], \"l2\": [3, 4]})\\n    >>> df_h2 = pl.DataFrame({\"r1\": [5, 6], \"r2\": [7, 8], \"r3\": [9, 10]})\\n    >>> pl.concat([df_h1, df_h2], how=\"horizontal\")\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 l1  \u2506 l2  \u2506 r1  \u2506 r2  \u2506 r3  \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 5   \u2506 7   \u2506 9   \u2502\\n    \u2502 2   \u2506 4   \u2506 6   \u2506 8   \u2506 10  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_d1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\\n    >>> df_d2 = pl.DataFrame({\"a\": [2], \"c\": [4]})\\n    >>> pl.concat([df_d1, df_d2], how=\"diagonal\")\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2502\\n    \u2502 2   \u2506 null \u2506 4    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    >>> df_a1 = pl.DataFrame({\"id\": [1, 2], \"x\": [3, 4]})\\n    >>> df_a2 = pl.DataFrame({\"id\": [2, 3], \"y\": [5, 6]})\\n    >>> df_a3 = pl.DataFrame({\"id\": [1, 3], \"z\": [7, 8]})\\n    >>> pl.concat([df_a1, df_a2, df_a3], how=\"align\")\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 id  \u2506 x    \u2506 y    \u2506 z    \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64  \u2506 i64  \u2506 i64  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3    \u2506 null \u2506 7    \u2502\\n    \u2502 2   \u2506 4    \u2506 5    \u2506 null \u2502\\n    \u2502 3   \u2506 null \u2506 6    \u2506 8    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    elems = list(items)\n    if not len(elems) > 0:\n        raise ValueError('cannot concat empty list')\n    elif len(elems) == 1 and isinstance(elems[0], (pl.DataFrame, pl.Series, pl.LazyFrame)):\n        return elems[0]\n    if how == 'align':\n        if not isinstance(elems[0], (pl.DataFrame, pl.LazyFrame)):\n            raise TypeError(f\"'align' strategy is not supported for {type(elems[0]).__name__!r}\")\n        all_columns = list(chain.from_iterable((e.columns for e in elems)))\n        key = {v: k for (k, v) in enumerate(ordered_unique(all_columns))}\n        common_cols = sorted(reduce(lambda x, y: set(x) & set(y), chain((e.columns for e in elems))), key=lambda k: key.get(k, 0))\n        lf: LazyFrame = reduce(lambda x, y: x.join(y, how='outer', on=common_cols, suffix=''), [df.lazy() for df in elems]).sort(by=common_cols)\n        eager = isinstance(elems[0], pl.DataFrame)\n        return lf.collect() if eager else lf\n    out: Series | DataFrame | LazyFrame | Expr\n    first = elems[0]\n    if isinstance(first, pl.DataFrame):\n        if how == 'vertical':\n            out = wrap_df(plr.concat_df(elems))\n        elif how == 'vertical_relaxed':\n            out = wrap_ldf(plr.concat_lf([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'diagonal':\n            out = wrap_df(plr.concat_df_diagonal(elems))\n        elif how == 'diagonal_relaxed':\n            out = wrap_ldf(plr.concat_lf_diagonal([df.lazy() for df in elems], rechunk=rechunk, parallel=parallel, to_supertypes=True)).collect(no_optimization=True)\n        elif how == 'horizontal':\n            out = wrap_df(plr.concat_df_horizontal(elems))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod)))\n            raise ValueError(f'DataFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.LazyFrame):\n        if how in ('vertical', 'vertical_relaxed'):\n            return wrap_ldf(plr.concat_lf(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        elif how in ('diagonal', 'diagonal_relaxed'):\n            return wrap_ldf(plr.concat_lf_diagonal(elems, rechunk=rechunk, parallel=parallel, to_supertypes=how.endswith('relaxed')))\n        else:\n            allowed = ', '.join((repr(m) for m in get_args(ConcatMethod) if m != 'horizontal'))\n            raise ValueError(f'LazyFrame `how` must be one of {{{allowed}}}, got {how!r}')\n    elif isinstance(first, pl.Series):\n        if how == 'vertical':\n            out = wrap_s(plr.concat_series(elems))\n        else:\n            raise ValueError(\"Series only supports 'vertical' concat strategy\")\n    elif isinstance(first, pl.Expr):\n        return wrap_expr(plr.concat_expr([e._pyexpr for e in elems], rechunk))\n    else:\n        raise TypeError(f'did not expect type: {type(first).__name__!r} in `concat`')\n    if rechunk:\n        return out.rechunk()\n    return out"
        ]
    },
    {
        "func_name": "align_frames",
        "original": "def align_frames(*frames: FrameType, on: str | Expr | Sequence[str] | Sequence[Expr] | Sequence[str | Expr], how: JoinStrategy='outer', select: str | Expr | Sequence[str | Expr] | None=None, descending: bool | Sequence[bool]=False) -> list[FrameType]:\n    \"\"\"\n    Align a sequence of frames using common values from one or more columns as a key.\n\n    Frames that do not contain the given key values have rows injected (with nulls\n    filling the non-key columns), and each resulting frame is sorted by the key.\n\n    The original column order of input frames is not changed unless `select` is\n    specified (in which case the final column order is determined from that). In the\n    case where duplicate key values exist, the alignment behaviour is determined by\n    the given alignment strategy specified in the `how` parameter (by default this\n    is a full outer join, but if your data is suitable you can get a large speedup\n    by setting `how=\"left\"` instead).\n\n    Note that this function does not result in a joined frame - you receive the same\n    number of frames back that you passed in, but each is now aligned by key and has\n    the same number of rows.\n\n    Parameters\n    ----------\n    frames\n        Sequence of DataFrames or LazyFrames.\n    on\n        One or more columns whose unique values will be used to align the frames.\n    select\n        Optional post-alignment column select to constrain and/or order\n        the columns returned from the newly aligned frames.\n    descending\n        Sort the alignment column values in descending order; can be a single\n        boolean or a list of booleans associated with each column in `on`.\n    how\n        By default the row alignment values are determined using a full outer join\n        strategy across all frames; if you know that the first frame contains all\n        required keys, you can set `how=\"left\"` for a large performance increase.\n\n    Examples\n    --------\n    >>> from datetime import date\n    >>> df1 = pl.DataFrame(\n    ...     {\n    ...         \"dt\": [date(2022, 9, 1), date(2022, 9, 2), date(2022, 9, 3)],\n    ...         \"x\": [3.5, 4.0, 1.0],\n    ...         \"y\": [10.0, 2.5, 1.5],\n    ...     }\n    ... )\n    >>> df2 = pl.DataFrame(\n    ...     {\n    ...         \"dt\": [date(2022, 9, 2), date(2022, 9, 3), date(2022, 9, 1)],\n    ...         \"x\": [8.0, 1.0, 3.5],\n    ...         \"y\": [1.5, 12.0, 5.0],\n    ...     }\n    ... )\n    >>> df3 = pl.DataFrame(\n    ...     {\n    ...         \"dt\": [date(2022, 9, 3), date(2022, 9, 2)],\n    ...         \"x\": [2.0, 5.0],\n    ...         \"y\": [2.5, 2.0],\n    ...     }\n    ... )  # doctest: +IGNORE_RESULT\n    >>> pl.Config.set_tbl_formatting(\"UTF8_FULL\")  # doctest: +IGNORE_RESULT\n    #\n    # df1                              df2                              df3\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (2, 3)\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y   \u2502\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 --- \u2502\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64 \u2502\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502\\\\  ,->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502\\\\  ,->\u2502 2022-09-03 \u2506 2.0 \u2506 2.5 \u2502\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502_/\\\\,->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502_/`-->\u2502 2022-09-02 \u2506 5.0 \u2506 2.0 \u2502\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  /\\\\  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502_/  `>\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502-//-\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ...\n\n    Align frames by the \"dt\" column:\n\n    >>> af1, af2, af3 = pl.align_frames(\n    ...     df1, df2, df3, on=\"dt\"\n    ... )  # doctest: +IGNORE_RESULT\n    #\n    # df1                              df2                              df3\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (3, 3)\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x    \u2506 y    \u2502\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 ---  \u2506 ---  \u2502\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64  \u2506 f64  \u2502\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502----->\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502----->\u2502 2022-09-01 \u2506 null \u2506 null \u2502\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502----->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502----->\u2502 2022-09-02 \u2506 5.0  \u2506 2.0  \u2502\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502----->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502----->\u2502 2022-09-03 \u2506 2.0  \u2506 2.5  \u2502\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ...\n\n    Align frames by \"dt\" using \"left\" alignment, but keep only cols \"x\" and \"y\":\n\n    >>> af1, af2, af3 = pl.align_frames(\n    ...     df1, df2, df3, on=\"dt\", select=[\"x\", \"y\"], how=\"left\"\n    ... )  # doctest: +IGNORE_RESULT\n    #\n    # af1                 af2                 af3\n    # shape: (3, 3)       shape: (3, 3)       shape: (3, 3)\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    # \u2502 x   \u2506 y    \u2502      \u2502 x   \u2506 y    \u2502      \u2502 x    \u2506 y    \u2502\n    # \u2502 --- \u2506 ---  \u2502      \u2502 --- \u2506 ---  \u2502      \u2502 ---  \u2506 ---  \u2502\n    # \u2502 f64 \u2506 f64  \u2502      \u2502 f64 \u2506 f64  \u2502      \u2502 f64  \u2506 f64  \u2502\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    # \u2502 3.5 \u2506 10.0 \u2502      \u2502 3.5 \u2506 5.0  \u2502      \u2502 null \u2506 null \u2502\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n    # \u2502 4.0 \u2506 2.5  \u2502      \u2502 8.0 \u2506 1.5  \u2502      \u2502 5.0  \u2506 2.0  \u2502\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n    # \u2502 1.0 \u2506 1.5  \u2502      \u2502 1.0 \u2506 12.0 \u2502      \u2502 2.0  \u2506 2.5  \u2502\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ...\n\n    Now data is aligned, and you can easily calculate the row-wise dot product:\n\n    >>> (af1 * af2 * af3).fill_null(0).select(pl.sum_horizontal(\"*\").alias(\"dot\"))\n    shape: (3, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 dot   \u2502\n    \u2502 ---   \u2502\n    \u2502 f64   \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 0.0   \u2502\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n    \u2502 167.5 \u2502\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n    \u2502 47.0  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    if not frames:\n        return []\n    elif len({type(f) for f in frames}) != 1:\n        raise TypeError('input frames must be of a consistent type (all LazyFrame or all DataFrame)')\n    on = [on] if isinstance(on, str) or not isinstance(on, Sequence) else on\n    align_on = [c.meta.output_name() if isinstance(c, pl.Expr) else c for c in on]\n    eager = isinstance(frames[0], pl.DataFrame)\n    if len(frames) < 250:\n        alignment_frame: LazyFrame = reduce(lambda x, y: x.lazy().join(y.lazy(), how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).collect(no_optimization=True).lazy()\n    else:\n        alignment_frame = reduce(lambda x, y: x.join(y, how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).lazy()\n    aligned_cols = set(alignment_frame.columns)\n    aligned_frames = []\n    for df in frames:\n        sfx = str(id(df))\n        df_cols = [F.col(f'{c}{sfx}').alias(c) if f'{c}{sfx}' in aligned_cols else F.col(c) for c in df.columns]\n        f = alignment_frame.select(*df_cols)\n        if select is not None:\n            f = f.select(select)\n        aligned_frames.append(f)\n    return cast(List[FrameType], F.collect_all(aligned_frames) if eager else aligned_frames)",
        "mutated": [
            "def align_frames(*frames: FrameType, on: str | Expr | Sequence[str] | Sequence[Expr] | Sequence[str | Expr], how: JoinStrategy='outer', select: str | Expr | Sequence[str | Expr] | None=None, descending: bool | Sequence[bool]=False) -> list[FrameType]:\n    if False:\n        i = 10\n    '\\n    Align a sequence of frames using common values from one or more columns as a key.\\n\\n    Frames that do not contain the given key values have rows injected (with nulls\\n    filling the non-key columns), and each resulting frame is sorted by the key.\\n\\n    The original column order of input frames is not changed unless `select` is\\n    specified (in which case the final column order is determined from that). In the\\n    case where duplicate key values exist, the alignment behaviour is determined by\\n    the given alignment strategy specified in the `how` parameter (by default this\\n    is a full outer join, but if your data is suitable you can get a large speedup\\n    by setting `how=\"left\"` instead).\\n\\n    Note that this function does not result in a joined frame - you receive the same\\n    number of frames back that you passed in, but each is now aligned by key and has\\n    the same number of rows.\\n\\n    Parameters\\n    ----------\\n    frames\\n        Sequence of DataFrames or LazyFrames.\\n    on\\n        One or more columns whose unique values will be used to align the frames.\\n    select\\n        Optional post-alignment column select to constrain and/or order\\n        the columns returned from the newly aligned frames.\\n    descending\\n        Sort the alignment column values in descending order; can be a single\\n        boolean or a list of booleans associated with each column in `on`.\\n    how\\n        By default the row alignment values are determined using a full outer join\\n        strategy across all frames; if you know that the first frame contains all\\n        required keys, you can set `how=\"left\"` for a large performance increase.\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df1 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 1), date(2022, 9, 2), date(2022, 9, 3)],\\n    ...         \"x\": [3.5, 4.0, 1.0],\\n    ...         \"y\": [10.0, 2.5, 1.5],\\n    ...     }\\n    ... )\\n    >>> df2 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 2), date(2022, 9, 3), date(2022, 9, 1)],\\n    ...         \"x\": [8.0, 1.0, 3.5],\\n    ...         \"y\": [1.5, 12.0, 5.0],\\n    ...     }\\n    ... )\\n    >>> df3 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 3), date(2022, 9, 2)],\\n    ...         \"x\": [2.0, 5.0],\\n    ...         \"y\": [2.5, 2.0],\\n    ...     }\\n    ... )  # doctest: +IGNORE_RESULT\\n    >>> pl.Config.set_tbl_formatting(\"UTF8_FULL\")  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (2, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y   \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 --- \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64 \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502\\\\  ,->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502\\\\  ,->\u2502 2022-09-03 \u2506 2.0 \u2506 2.5 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502_/\\\\,->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502_/`-->\u2502 2022-09-02 \u2506 5.0 \u2506 2.0 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  /\\\\  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502_/  `>\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502-//-\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by the \"dt\" column:\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x    \u2506 y    \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 ---  \u2506 ---  \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502----->\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502----->\u2502 2022-09-01 \u2506 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502----->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502----->\u2502 2022-09-02 \u2506 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502----->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502----->\u2502 2022-09-03 \u2506 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by \"dt\" using \"left\" alignment, but keep only cols \"x\" and \"y\":\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\", select=[\"x\", \"y\"], how=\"left\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # af1                 af2                 af3\\n    # shape: (3, 3)       shape: (3, 3)       shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 x   \u2506 y    \u2502      \u2502 x   \u2506 y    \u2502      \u2502 x    \u2506 y    \u2502\\n    # \u2502 --- \u2506 ---  \u2502      \u2502 --- \u2506 ---  \u2502      \u2502 ---  \u2506 ---  \u2502\\n    # \u2502 f64 \u2506 f64  \u2502      \u2502 f64 \u2506 f64  \u2502      \u2502 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 3.5 \u2506 10.0 \u2502      \u2502 3.5 \u2506 5.0  \u2502      \u2502 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 4.0 \u2506 2.5  \u2502      \u2502 8.0 \u2506 1.5  \u2502      \u2502 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 1.0 \u2506 1.5  \u2502      \u2502 1.0 \u2506 12.0 \u2502      \u2502 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Now data is aligned, and you can easily calculate the row-wise dot product:\\n\\n    >>> (af1 * af2 * af3).fill_null(0).select(pl.sum_horizontal(\"*\").alias(\"dot\"))\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dot   \u2502\\n    \u2502 ---   \u2502\\n    \u2502 f64   \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 0.0   \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 167.5 \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 47.0  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if not frames:\n        return []\n    elif len({type(f) for f in frames}) != 1:\n        raise TypeError('input frames must be of a consistent type (all LazyFrame or all DataFrame)')\n    on = [on] if isinstance(on, str) or not isinstance(on, Sequence) else on\n    align_on = [c.meta.output_name() if isinstance(c, pl.Expr) else c for c in on]\n    eager = isinstance(frames[0], pl.DataFrame)\n    if len(frames) < 250:\n        alignment_frame: LazyFrame = reduce(lambda x, y: x.lazy().join(y.lazy(), how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).collect(no_optimization=True).lazy()\n    else:\n        alignment_frame = reduce(lambda x, y: x.join(y, how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).lazy()\n    aligned_cols = set(alignment_frame.columns)\n    aligned_frames = []\n    for df in frames:\n        sfx = str(id(df))\n        df_cols = [F.col(f'{c}{sfx}').alias(c) if f'{c}{sfx}' in aligned_cols else F.col(c) for c in df.columns]\n        f = alignment_frame.select(*df_cols)\n        if select is not None:\n            f = f.select(select)\n        aligned_frames.append(f)\n    return cast(List[FrameType], F.collect_all(aligned_frames) if eager else aligned_frames)",
            "def align_frames(*frames: FrameType, on: str | Expr | Sequence[str] | Sequence[Expr] | Sequence[str | Expr], how: JoinStrategy='outer', select: str | Expr | Sequence[str | Expr] | None=None, descending: bool | Sequence[bool]=False) -> list[FrameType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Align a sequence of frames using common values from one or more columns as a key.\\n\\n    Frames that do not contain the given key values have rows injected (with nulls\\n    filling the non-key columns), and each resulting frame is sorted by the key.\\n\\n    The original column order of input frames is not changed unless `select` is\\n    specified (in which case the final column order is determined from that). In the\\n    case where duplicate key values exist, the alignment behaviour is determined by\\n    the given alignment strategy specified in the `how` parameter (by default this\\n    is a full outer join, but if your data is suitable you can get a large speedup\\n    by setting `how=\"left\"` instead).\\n\\n    Note that this function does not result in a joined frame - you receive the same\\n    number of frames back that you passed in, but each is now aligned by key and has\\n    the same number of rows.\\n\\n    Parameters\\n    ----------\\n    frames\\n        Sequence of DataFrames or LazyFrames.\\n    on\\n        One or more columns whose unique values will be used to align the frames.\\n    select\\n        Optional post-alignment column select to constrain and/or order\\n        the columns returned from the newly aligned frames.\\n    descending\\n        Sort the alignment column values in descending order; can be a single\\n        boolean or a list of booleans associated with each column in `on`.\\n    how\\n        By default the row alignment values are determined using a full outer join\\n        strategy across all frames; if you know that the first frame contains all\\n        required keys, you can set `how=\"left\"` for a large performance increase.\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df1 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 1), date(2022, 9, 2), date(2022, 9, 3)],\\n    ...         \"x\": [3.5, 4.0, 1.0],\\n    ...         \"y\": [10.0, 2.5, 1.5],\\n    ...     }\\n    ... )\\n    >>> df2 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 2), date(2022, 9, 3), date(2022, 9, 1)],\\n    ...         \"x\": [8.0, 1.0, 3.5],\\n    ...         \"y\": [1.5, 12.0, 5.0],\\n    ...     }\\n    ... )\\n    >>> df3 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 3), date(2022, 9, 2)],\\n    ...         \"x\": [2.0, 5.0],\\n    ...         \"y\": [2.5, 2.0],\\n    ...     }\\n    ... )  # doctest: +IGNORE_RESULT\\n    >>> pl.Config.set_tbl_formatting(\"UTF8_FULL\")  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (2, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y   \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 --- \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64 \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502\\\\  ,->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502\\\\  ,->\u2502 2022-09-03 \u2506 2.0 \u2506 2.5 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502_/\\\\,->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502_/`-->\u2502 2022-09-02 \u2506 5.0 \u2506 2.0 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  /\\\\  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502_/  `>\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502-//-\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by the \"dt\" column:\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x    \u2506 y    \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 ---  \u2506 ---  \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502----->\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502----->\u2502 2022-09-01 \u2506 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502----->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502----->\u2502 2022-09-02 \u2506 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502----->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502----->\u2502 2022-09-03 \u2506 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by \"dt\" using \"left\" alignment, but keep only cols \"x\" and \"y\":\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\", select=[\"x\", \"y\"], how=\"left\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # af1                 af2                 af3\\n    # shape: (3, 3)       shape: (3, 3)       shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 x   \u2506 y    \u2502      \u2502 x   \u2506 y    \u2502      \u2502 x    \u2506 y    \u2502\\n    # \u2502 --- \u2506 ---  \u2502      \u2502 --- \u2506 ---  \u2502      \u2502 ---  \u2506 ---  \u2502\\n    # \u2502 f64 \u2506 f64  \u2502      \u2502 f64 \u2506 f64  \u2502      \u2502 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 3.5 \u2506 10.0 \u2502      \u2502 3.5 \u2506 5.0  \u2502      \u2502 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 4.0 \u2506 2.5  \u2502      \u2502 8.0 \u2506 1.5  \u2502      \u2502 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 1.0 \u2506 1.5  \u2502      \u2502 1.0 \u2506 12.0 \u2502      \u2502 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Now data is aligned, and you can easily calculate the row-wise dot product:\\n\\n    >>> (af1 * af2 * af3).fill_null(0).select(pl.sum_horizontal(\"*\").alias(\"dot\"))\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dot   \u2502\\n    \u2502 ---   \u2502\\n    \u2502 f64   \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 0.0   \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 167.5 \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 47.0  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if not frames:\n        return []\n    elif len({type(f) for f in frames}) != 1:\n        raise TypeError('input frames must be of a consistent type (all LazyFrame or all DataFrame)')\n    on = [on] if isinstance(on, str) or not isinstance(on, Sequence) else on\n    align_on = [c.meta.output_name() if isinstance(c, pl.Expr) else c for c in on]\n    eager = isinstance(frames[0], pl.DataFrame)\n    if len(frames) < 250:\n        alignment_frame: LazyFrame = reduce(lambda x, y: x.lazy().join(y.lazy(), how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).collect(no_optimization=True).lazy()\n    else:\n        alignment_frame = reduce(lambda x, y: x.join(y, how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).lazy()\n    aligned_cols = set(alignment_frame.columns)\n    aligned_frames = []\n    for df in frames:\n        sfx = str(id(df))\n        df_cols = [F.col(f'{c}{sfx}').alias(c) if f'{c}{sfx}' in aligned_cols else F.col(c) for c in df.columns]\n        f = alignment_frame.select(*df_cols)\n        if select is not None:\n            f = f.select(select)\n        aligned_frames.append(f)\n    return cast(List[FrameType], F.collect_all(aligned_frames) if eager else aligned_frames)",
            "def align_frames(*frames: FrameType, on: str | Expr | Sequence[str] | Sequence[Expr] | Sequence[str | Expr], how: JoinStrategy='outer', select: str | Expr | Sequence[str | Expr] | None=None, descending: bool | Sequence[bool]=False) -> list[FrameType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Align a sequence of frames using common values from one or more columns as a key.\\n\\n    Frames that do not contain the given key values have rows injected (with nulls\\n    filling the non-key columns), and each resulting frame is sorted by the key.\\n\\n    The original column order of input frames is not changed unless `select` is\\n    specified (in which case the final column order is determined from that). In the\\n    case where duplicate key values exist, the alignment behaviour is determined by\\n    the given alignment strategy specified in the `how` parameter (by default this\\n    is a full outer join, but if your data is suitable you can get a large speedup\\n    by setting `how=\"left\"` instead).\\n\\n    Note that this function does not result in a joined frame - you receive the same\\n    number of frames back that you passed in, but each is now aligned by key and has\\n    the same number of rows.\\n\\n    Parameters\\n    ----------\\n    frames\\n        Sequence of DataFrames or LazyFrames.\\n    on\\n        One or more columns whose unique values will be used to align the frames.\\n    select\\n        Optional post-alignment column select to constrain and/or order\\n        the columns returned from the newly aligned frames.\\n    descending\\n        Sort the alignment column values in descending order; can be a single\\n        boolean or a list of booleans associated with each column in `on`.\\n    how\\n        By default the row alignment values are determined using a full outer join\\n        strategy across all frames; if you know that the first frame contains all\\n        required keys, you can set `how=\"left\"` for a large performance increase.\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df1 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 1), date(2022, 9, 2), date(2022, 9, 3)],\\n    ...         \"x\": [3.5, 4.0, 1.0],\\n    ...         \"y\": [10.0, 2.5, 1.5],\\n    ...     }\\n    ... )\\n    >>> df2 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 2), date(2022, 9, 3), date(2022, 9, 1)],\\n    ...         \"x\": [8.0, 1.0, 3.5],\\n    ...         \"y\": [1.5, 12.0, 5.0],\\n    ...     }\\n    ... )\\n    >>> df3 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 3), date(2022, 9, 2)],\\n    ...         \"x\": [2.0, 5.0],\\n    ...         \"y\": [2.5, 2.0],\\n    ...     }\\n    ... )  # doctest: +IGNORE_RESULT\\n    >>> pl.Config.set_tbl_formatting(\"UTF8_FULL\")  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (2, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y   \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 --- \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64 \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502\\\\  ,->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502\\\\  ,->\u2502 2022-09-03 \u2506 2.0 \u2506 2.5 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502_/\\\\,->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502_/`-->\u2502 2022-09-02 \u2506 5.0 \u2506 2.0 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  /\\\\  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502_/  `>\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502-//-\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by the \"dt\" column:\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x    \u2506 y    \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 ---  \u2506 ---  \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502----->\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502----->\u2502 2022-09-01 \u2506 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502----->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502----->\u2502 2022-09-02 \u2506 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502----->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502----->\u2502 2022-09-03 \u2506 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by \"dt\" using \"left\" alignment, but keep only cols \"x\" and \"y\":\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\", select=[\"x\", \"y\"], how=\"left\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # af1                 af2                 af3\\n    # shape: (3, 3)       shape: (3, 3)       shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 x   \u2506 y    \u2502      \u2502 x   \u2506 y    \u2502      \u2502 x    \u2506 y    \u2502\\n    # \u2502 --- \u2506 ---  \u2502      \u2502 --- \u2506 ---  \u2502      \u2502 ---  \u2506 ---  \u2502\\n    # \u2502 f64 \u2506 f64  \u2502      \u2502 f64 \u2506 f64  \u2502      \u2502 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 3.5 \u2506 10.0 \u2502      \u2502 3.5 \u2506 5.0  \u2502      \u2502 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 4.0 \u2506 2.5  \u2502      \u2502 8.0 \u2506 1.5  \u2502      \u2502 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 1.0 \u2506 1.5  \u2502      \u2502 1.0 \u2506 12.0 \u2502      \u2502 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Now data is aligned, and you can easily calculate the row-wise dot product:\\n\\n    >>> (af1 * af2 * af3).fill_null(0).select(pl.sum_horizontal(\"*\").alias(\"dot\"))\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dot   \u2502\\n    \u2502 ---   \u2502\\n    \u2502 f64   \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 0.0   \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 167.5 \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 47.0  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if not frames:\n        return []\n    elif len({type(f) for f in frames}) != 1:\n        raise TypeError('input frames must be of a consistent type (all LazyFrame or all DataFrame)')\n    on = [on] if isinstance(on, str) or not isinstance(on, Sequence) else on\n    align_on = [c.meta.output_name() if isinstance(c, pl.Expr) else c for c in on]\n    eager = isinstance(frames[0], pl.DataFrame)\n    if len(frames) < 250:\n        alignment_frame: LazyFrame = reduce(lambda x, y: x.lazy().join(y.lazy(), how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).collect(no_optimization=True).lazy()\n    else:\n        alignment_frame = reduce(lambda x, y: x.join(y, how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).lazy()\n    aligned_cols = set(alignment_frame.columns)\n    aligned_frames = []\n    for df in frames:\n        sfx = str(id(df))\n        df_cols = [F.col(f'{c}{sfx}').alias(c) if f'{c}{sfx}' in aligned_cols else F.col(c) for c in df.columns]\n        f = alignment_frame.select(*df_cols)\n        if select is not None:\n            f = f.select(select)\n        aligned_frames.append(f)\n    return cast(List[FrameType], F.collect_all(aligned_frames) if eager else aligned_frames)",
            "def align_frames(*frames: FrameType, on: str | Expr | Sequence[str] | Sequence[Expr] | Sequence[str | Expr], how: JoinStrategy='outer', select: str | Expr | Sequence[str | Expr] | None=None, descending: bool | Sequence[bool]=False) -> list[FrameType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Align a sequence of frames using common values from one or more columns as a key.\\n\\n    Frames that do not contain the given key values have rows injected (with nulls\\n    filling the non-key columns), and each resulting frame is sorted by the key.\\n\\n    The original column order of input frames is not changed unless `select` is\\n    specified (in which case the final column order is determined from that). In the\\n    case where duplicate key values exist, the alignment behaviour is determined by\\n    the given alignment strategy specified in the `how` parameter (by default this\\n    is a full outer join, but if your data is suitable you can get a large speedup\\n    by setting `how=\"left\"` instead).\\n\\n    Note that this function does not result in a joined frame - you receive the same\\n    number of frames back that you passed in, but each is now aligned by key and has\\n    the same number of rows.\\n\\n    Parameters\\n    ----------\\n    frames\\n        Sequence of DataFrames or LazyFrames.\\n    on\\n        One or more columns whose unique values will be used to align the frames.\\n    select\\n        Optional post-alignment column select to constrain and/or order\\n        the columns returned from the newly aligned frames.\\n    descending\\n        Sort the alignment column values in descending order; can be a single\\n        boolean or a list of booleans associated with each column in `on`.\\n    how\\n        By default the row alignment values are determined using a full outer join\\n        strategy across all frames; if you know that the first frame contains all\\n        required keys, you can set `how=\"left\"` for a large performance increase.\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df1 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 1), date(2022, 9, 2), date(2022, 9, 3)],\\n    ...         \"x\": [3.5, 4.0, 1.0],\\n    ...         \"y\": [10.0, 2.5, 1.5],\\n    ...     }\\n    ... )\\n    >>> df2 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 2), date(2022, 9, 3), date(2022, 9, 1)],\\n    ...         \"x\": [8.0, 1.0, 3.5],\\n    ...         \"y\": [1.5, 12.0, 5.0],\\n    ...     }\\n    ... )\\n    >>> df3 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 3), date(2022, 9, 2)],\\n    ...         \"x\": [2.0, 5.0],\\n    ...         \"y\": [2.5, 2.0],\\n    ...     }\\n    ... )  # doctest: +IGNORE_RESULT\\n    >>> pl.Config.set_tbl_formatting(\"UTF8_FULL\")  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (2, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y   \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 --- \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64 \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502\\\\  ,->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502\\\\  ,->\u2502 2022-09-03 \u2506 2.0 \u2506 2.5 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502_/\\\\,->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502_/`-->\u2502 2022-09-02 \u2506 5.0 \u2506 2.0 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  /\\\\  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502_/  `>\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502-//-\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by the \"dt\" column:\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x    \u2506 y    \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 ---  \u2506 ---  \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502----->\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502----->\u2502 2022-09-01 \u2506 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502----->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502----->\u2502 2022-09-02 \u2506 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502----->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502----->\u2502 2022-09-03 \u2506 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by \"dt\" using \"left\" alignment, but keep only cols \"x\" and \"y\":\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\", select=[\"x\", \"y\"], how=\"left\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # af1                 af2                 af3\\n    # shape: (3, 3)       shape: (3, 3)       shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 x   \u2506 y    \u2502      \u2502 x   \u2506 y    \u2502      \u2502 x    \u2506 y    \u2502\\n    # \u2502 --- \u2506 ---  \u2502      \u2502 --- \u2506 ---  \u2502      \u2502 ---  \u2506 ---  \u2502\\n    # \u2502 f64 \u2506 f64  \u2502      \u2502 f64 \u2506 f64  \u2502      \u2502 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 3.5 \u2506 10.0 \u2502      \u2502 3.5 \u2506 5.0  \u2502      \u2502 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 4.0 \u2506 2.5  \u2502      \u2502 8.0 \u2506 1.5  \u2502      \u2502 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 1.0 \u2506 1.5  \u2502      \u2502 1.0 \u2506 12.0 \u2502      \u2502 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Now data is aligned, and you can easily calculate the row-wise dot product:\\n\\n    >>> (af1 * af2 * af3).fill_null(0).select(pl.sum_horizontal(\"*\").alias(\"dot\"))\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dot   \u2502\\n    \u2502 ---   \u2502\\n    \u2502 f64   \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 0.0   \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 167.5 \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 47.0  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if not frames:\n        return []\n    elif len({type(f) for f in frames}) != 1:\n        raise TypeError('input frames must be of a consistent type (all LazyFrame or all DataFrame)')\n    on = [on] if isinstance(on, str) or not isinstance(on, Sequence) else on\n    align_on = [c.meta.output_name() if isinstance(c, pl.Expr) else c for c in on]\n    eager = isinstance(frames[0], pl.DataFrame)\n    if len(frames) < 250:\n        alignment_frame: LazyFrame = reduce(lambda x, y: x.lazy().join(y.lazy(), how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).collect(no_optimization=True).lazy()\n    else:\n        alignment_frame = reduce(lambda x, y: x.join(y, how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).lazy()\n    aligned_cols = set(alignment_frame.columns)\n    aligned_frames = []\n    for df in frames:\n        sfx = str(id(df))\n        df_cols = [F.col(f'{c}{sfx}').alias(c) if f'{c}{sfx}' in aligned_cols else F.col(c) for c in df.columns]\n        f = alignment_frame.select(*df_cols)\n        if select is not None:\n            f = f.select(select)\n        aligned_frames.append(f)\n    return cast(List[FrameType], F.collect_all(aligned_frames) if eager else aligned_frames)",
            "def align_frames(*frames: FrameType, on: str | Expr | Sequence[str] | Sequence[Expr] | Sequence[str | Expr], how: JoinStrategy='outer', select: str | Expr | Sequence[str | Expr] | None=None, descending: bool | Sequence[bool]=False) -> list[FrameType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Align a sequence of frames using common values from one or more columns as a key.\\n\\n    Frames that do not contain the given key values have rows injected (with nulls\\n    filling the non-key columns), and each resulting frame is sorted by the key.\\n\\n    The original column order of input frames is not changed unless `select` is\\n    specified (in which case the final column order is determined from that). In the\\n    case where duplicate key values exist, the alignment behaviour is determined by\\n    the given alignment strategy specified in the `how` parameter (by default this\\n    is a full outer join, but if your data is suitable you can get a large speedup\\n    by setting `how=\"left\"` instead).\\n\\n    Note that this function does not result in a joined frame - you receive the same\\n    number of frames back that you passed in, but each is now aligned by key and has\\n    the same number of rows.\\n\\n    Parameters\\n    ----------\\n    frames\\n        Sequence of DataFrames or LazyFrames.\\n    on\\n        One or more columns whose unique values will be used to align the frames.\\n    select\\n        Optional post-alignment column select to constrain and/or order\\n        the columns returned from the newly aligned frames.\\n    descending\\n        Sort the alignment column values in descending order; can be a single\\n        boolean or a list of booleans associated with each column in `on`.\\n    how\\n        By default the row alignment values are determined using a full outer join\\n        strategy across all frames; if you know that the first frame contains all\\n        required keys, you can set `how=\"left\"` for a large performance increase.\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df1 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 1), date(2022, 9, 2), date(2022, 9, 3)],\\n    ...         \"x\": [3.5, 4.0, 1.0],\\n    ...         \"y\": [10.0, 2.5, 1.5],\\n    ...     }\\n    ... )\\n    >>> df2 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 2), date(2022, 9, 3), date(2022, 9, 1)],\\n    ...         \"x\": [8.0, 1.0, 3.5],\\n    ...         \"y\": [1.5, 12.0, 5.0],\\n    ...     }\\n    ... )\\n    >>> df3 = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [date(2022, 9, 3), date(2022, 9, 2)],\\n    ...         \"x\": [2.0, 5.0],\\n    ...         \"y\": [2.5, 2.0],\\n    ...     }\\n    ... )  # doctest: +IGNORE_RESULT\\n    >>> pl.Config.set_tbl_formatting(\"UTF8_FULL\")  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (2, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y   \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 --- \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64 \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502\\\\  ,->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502\\\\  ,->\u2502 2022-09-03 \u2506 2.0 \u2506 2.5 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \\\\/   \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502_/\\\\,->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502_/`-->\u2502 2022-09-02 \u2506 5.0 \u2506 2.0 \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524  /\\\\  \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502_/  `>\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502-//-\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by the \"dt\" column:\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # df1                              df2                              df3\\n    # shape: (3, 3)                    shape: (3, 3)                    shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x   \u2506 y    \u2502      \u2502 dt         \u2506 x    \u2506 y    \u2502\\n    # \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 --- \u2506 ---  \u2502      \u2502 ---        \u2506 ---  \u2506 ---  \u2502\\n    # \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64 \u2506 f64  \u2502      \u2502 date       \u2506 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 2022-09-01 \u2506 3.5 \u2506 10.0 \u2502----->\u2502 2022-09-01 \u2506 3.5 \u2506 5.0  \u2502----->\u2502 2022-09-01 \u2506 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-02 \u2506 4.0 \u2506 2.5  \u2502----->\u2502 2022-09-02 \u2506 8.0 \u2506 1.5  \u2502----->\u2502 2022-09-02 \u2506 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 2022-09-03 \u2506 1.0 \u2506 1.5  \u2502----->\u2502 2022-09-03 \u2506 1.0 \u2506 12.0 \u2502----->\u2502 2022-09-03 \u2506 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Align frames by \"dt\" using \"left\" alignment, but keep only cols \"x\" and \"y\":\\n\\n    >>> af1, af2, af3 = pl.align_frames(\\n    ...     df1, df2, df3, on=\"dt\", select=[\"x\", \"y\"], how=\"left\"\\n    ... )  # doctest: +IGNORE_RESULT\\n    #\\n    # af1                 af2                 af3\\n    # shape: (3, 3)       shape: (3, 3)       shape: (3, 3)\\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    # \u2502 x   \u2506 y    \u2502      \u2502 x   \u2506 y    \u2502      \u2502 x    \u2506 y    \u2502\\n    # \u2502 --- \u2506 ---  \u2502      \u2502 --- \u2506 ---  \u2502      \u2502 ---  \u2506 ---  \u2502\\n    # \u2502 f64 \u2506 f64  \u2502      \u2502 f64 \u2506 f64  \u2502      \u2502 f64  \u2506 f64  \u2502\\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    # \u2502 3.5 \u2506 10.0 \u2502      \u2502 3.5 \u2506 5.0  \u2502      \u2502 null \u2506 null \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 4.0 \u2506 2.5  \u2502      \u2502 8.0 \u2506 1.5  \u2502      \u2502 5.0  \u2506 2.0  \u2502\\n    # \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524      \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    # \u2502 1.0 \u2506 1.5  \u2502      \u2502 1.0 \u2506 12.0 \u2502      \u2502 2.0  \u2506 2.5  \u2502\\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n    ...\\n\\n    Now data is aligned, and you can easily calculate the row-wise dot product:\\n\\n    >>> (af1 * af2 * af3).fill_null(0).select(pl.sum_horizontal(\"*\").alias(\"dot\"))\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dot   \u2502\\n    \u2502 ---   \u2502\\n    \u2502 f64   \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 0.0   \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 167.5 \u2502\\n    \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\\n    \u2502 47.0  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if not frames:\n        return []\n    elif len({type(f) for f in frames}) != 1:\n        raise TypeError('input frames must be of a consistent type (all LazyFrame or all DataFrame)')\n    on = [on] if isinstance(on, str) or not isinstance(on, Sequence) else on\n    align_on = [c.meta.output_name() if isinstance(c, pl.Expr) else c for c in on]\n    eager = isinstance(frames[0], pl.DataFrame)\n    if len(frames) < 250:\n        alignment_frame: LazyFrame = reduce(lambda x, y: x.lazy().join(y.lazy(), how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).collect(no_optimization=True).lazy()\n    else:\n        alignment_frame = reduce(lambda x, y: x.join(y, how=how, on=align_on, suffix=str(id(y))), frames).sort(by=align_on, descending=descending).lazy()\n    aligned_cols = set(alignment_frame.columns)\n    aligned_frames = []\n    for df in frames:\n        sfx = str(id(df))\n        df_cols = [F.col(f'{c}{sfx}').alias(c) if f'{c}{sfx}' in aligned_cols else F.col(c) for c in df.columns]\n        f = alignment_frame.select(*df_cols)\n        if select is not None:\n            f = f.select(select)\n        aligned_frames.append(f)\n    return cast(List[FrameType], F.collect_all(aligned_frames) if eager else aligned_frames)"
        ]
    }
]