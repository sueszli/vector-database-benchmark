[
    {
        "func_name": "eccentricity",
        "original": "def eccentricity(jd):\n    \"\"\"\n    Eccentricity of the Earth's orbit at the requested Julian Date.\n\n    Parameters\n    ----------\n    jd : scalar or array-like\n        Julian date at which to compute the eccentricity\n\n    Returns\n    -------\n    eccentricity : scalar or array\n        The eccentricity (or array of eccentricities)\n\n    References\n    ----------\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\n      Seidelmann (ed), University Science Books (1992).\n    \"\"\"\n    T = (jd - jd1950) / 36525.0\n    p = (-1.26e-07, -4.193e-05, 0.01673011)\n    return np.polyval(p, T)",
        "mutated": [
            "def eccentricity(jd):\n    if False:\n        i = 10\n    \"\\n    Eccentricity of the Earth's orbit at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the eccentricity\\n\\n    Returns\\n    -------\\n    eccentricity : scalar or array\\n        The eccentricity (or array of eccentricities)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (-1.26e-07, -4.193e-05, 0.01673011)\n    return np.polyval(p, T)",
            "def eccentricity(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Eccentricity of the Earth's orbit at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the eccentricity\\n\\n    Returns\\n    -------\\n    eccentricity : scalar or array\\n        The eccentricity (or array of eccentricities)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (-1.26e-07, -4.193e-05, 0.01673011)\n    return np.polyval(p, T)",
            "def eccentricity(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Eccentricity of the Earth's orbit at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the eccentricity\\n\\n    Returns\\n    -------\\n    eccentricity : scalar or array\\n        The eccentricity (or array of eccentricities)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (-1.26e-07, -4.193e-05, 0.01673011)\n    return np.polyval(p, T)",
            "def eccentricity(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Eccentricity of the Earth's orbit at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the eccentricity\\n\\n    Returns\\n    -------\\n    eccentricity : scalar or array\\n        The eccentricity (or array of eccentricities)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (-1.26e-07, -4.193e-05, 0.01673011)\n    return np.polyval(p, T)",
            "def eccentricity(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Eccentricity of the Earth's orbit at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the eccentricity\\n\\n    Returns\\n    -------\\n    eccentricity : scalar or array\\n        The eccentricity (or array of eccentricities)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (-1.26e-07, -4.193e-05, 0.01673011)\n    return np.polyval(p, T)"
        ]
    },
    {
        "func_name": "mean_lon_of_perigee",
        "original": "def mean_lon_of_perigee(jd):\n    \"\"\"\n    Computes the mean longitude of perigee of the Earth's orbit at the\n    requested Julian Date.\n\n    Parameters\n    ----------\n    jd : scalar or array-like\n        Julian date at which to compute the mean longitude of perigee\n\n    Returns\n    -------\n    mean_lon_of_perigee : scalar or array\n        Mean longitude of perigee in degrees (or array of mean longitudes)\n\n    References\n    ----------\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\n      Seidelmann (ed), University Science Books (1992).\n    \"\"\"\n    T = (jd - jd1950) / 36525.0\n    p = (0.012, 1.65, 6190.67, 1015489.951)\n    return np.polyval(p, T) / 3600.0",
        "mutated": [
            "def mean_lon_of_perigee(jd):\n    if False:\n        i = 10\n    \"\\n    Computes the mean longitude of perigee of the Earth's orbit at the\\n    requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the mean longitude of perigee\\n\\n    Returns\\n    -------\\n    mean_lon_of_perigee : scalar or array\\n        Mean longitude of perigee in degrees (or array of mean longitudes)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (0.012, 1.65, 6190.67, 1015489.951)\n    return np.polyval(p, T) / 3600.0",
            "def mean_lon_of_perigee(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Computes the mean longitude of perigee of the Earth's orbit at the\\n    requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the mean longitude of perigee\\n\\n    Returns\\n    -------\\n    mean_lon_of_perigee : scalar or array\\n        Mean longitude of perigee in degrees (or array of mean longitudes)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (0.012, 1.65, 6190.67, 1015489.951)\n    return np.polyval(p, T) / 3600.0",
            "def mean_lon_of_perigee(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Computes the mean longitude of perigee of the Earth's orbit at the\\n    requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the mean longitude of perigee\\n\\n    Returns\\n    -------\\n    mean_lon_of_perigee : scalar or array\\n        Mean longitude of perigee in degrees (or array of mean longitudes)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (0.012, 1.65, 6190.67, 1015489.951)\n    return np.polyval(p, T) / 3600.0",
            "def mean_lon_of_perigee(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Computes the mean longitude of perigee of the Earth's orbit at the\\n    requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the mean longitude of perigee\\n\\n    Returns\\n    -------\\n    mean_lon_of_perigee : scalar or array\\n        Mean longitude of perigee in degrees (or array of mean longitudes)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (0.012, 1.65, 6190.67, 1015489.951)\n    return np.polyval(p, T) / 3600.0",
            "def mean_lon_of_perigee(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Computes the mean longitude of perigee of the Earth's orbit at the\\n    requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date at which to compute the mean longitude of perigee\\n\\n    Returns\\n    -------\\n    mean_lon_of_perigee : scalar or array\\n        Mean longitude of perigee in degrees (or array of mean longitudes)\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    \"\n    T = (jd - jd1950) / 36525.0\n    p = (0.012, 1.65, 6190.67, 1015489.951)\n    return np.polyval(p, T) / 3600.0"
        ]
    },
    {
        "func_name": "obliquity",
        "original": "def obliquity(jd, algorithm=2006):\n    \"\"\"\n    Computes the obliquity of the Earth at the requested Julian Date.\n\n    Parameters\n    ----------\n    jd : scalar or array-like\n        Julian date (TT) at which to compute the obliquity\n    algorithm : int\n        Year of algorithm based on IAU adoption. Can be 2006, 2000 or 1980.\n        The IAU 2006 algorithm is based on Hilton et al. 2006.\n        The IAU 1980 algorithm is based on the Explanatory Supplement to the\n        Astronomical Almanac (1992).\n        The IAU 2000 algorithm starts with the IAU 1980 algorithm and applies a\n        precession-rate correction from the IAU 2000 precession model.\n\n    Returns\n    -------\n    obliquity : scalar or array\n        Mean obliquity in degrees (or array of obliquities)\n\n    References\n    ----------\n    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\n    * Capitaine, N., et al., 2003, Astron.Astrophys. 400, 1145-1154\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\n      Seidelmann (ed), University Science Books (1992).\n    \"\"\"\n    if algorithm == 2006:\n        return np.rad2deg(erfa.obl06(jd, 0))\n    elif algorithm == 2000:\n        return np.rad2deg(erfa.obl80(jd, 0) + erfa.pr00(jd, 0)[1])\n    elif algorithm == 1980:\n        return np.rad2deg(erfa.obl80(jd, 0))\n    else:\n        raise ValueError('invalid algorithm year for computing obliquity')",
        "mutated": [
            "def obliquity(jd, algorithm=2006):\n    if False:\n        i = 10\n    '\\n    Computes the obliquity of the Earth at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date (TT) at which to compute the obliquity\\n    algorithm : int\\n        Year of algorithm based on IAU adoption. Can be 2006, 2000 or 1980.\\n        The IAU 2006 algorithm is based on Hilton et al. 2006.\\n        The IAU 1980 algorithm is based on the Explanatory Supplement to the\\n        Astronomical Almanac (1992).\\n        The IAU 2000 algorithm starts with the IAU 1980 algorithm and applies a\\n        precession-rate correction from the IAU 2000 precession model.\\n\\n    Returns\\n    -------\\n    obliquity : scalar or array\\n        Mean obliquity in degrees (or array of obliquities)\\n\\n    References\\n    ----------\\n    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    * Capitaine, N., et al., 2003, Astron.Astrophys. 400, 1145-1154\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    if algorithm == 2006:\n        return np.rad2deg(erfa.obl06(jd, 0))\n    elif algorithm == 2000:\n        return np.rad2deg(erfa.obl80(jd, 0) + erfa.pr00(jd, 0)[1])\n    elif algorithm == 1980:\n        return np.rad2deg(erfa.obl80(jd, 0))\n    else:\n        raise ValueError('invalid algorithm year for computing obliquity')",
            "def obliquity(jd, algorithm=2006):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the obliquity of the Earth at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date (TT) at which to compute the obliquity\\n    algorithm : int\\n        Year of algorithm based on IAU adoption. Can be 2006, 2000 or 1980.\\n        The IAU 2006 algorithm is based on Hilton et al. 2006.\\n        The IAU 1980 algorithm is based on the Explanatory Supplement to the\\n        Astronomical Almanac (1992).\\n        The IAU 2000 algorithm starts with the IAU 1980 algorithm and applies a\\n        precession-rate correction from the IAU 2000 precession model.\\n\\n    Returns\\n    -------\\n    obliquity : scalar or array\\n        Mean obliquity in degrees (or array of obliquities)\\n\\n    References\\n    ----------\\n    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    * Capitaine, N., et al., 2003, Astron.Astrophys. 400, 1145-1154\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    if algorithm == 2006:\n        return np.rad2deg(erfa.obl06(jd, 0))\n    elif algorithm == 2000:\n        return np.rad2deg(erfa.obl80(jd, 0) + erfa.pr00(jd, 0)[1])\n    elif algorithm == 1980:\n        return np.rad2deg(erfa.obl80(jd, 0))\n    else:\n        raise ValueError('invalid algorithm year for computing obliquity')",
            "def obliquity(jd, algorithm=2006):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the obliquity of the Earth at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date (TT) at which to compute the obliquity\\n    algorithm : int\\n        Year of algorithm based on IAU adoption. Can be 2006, 2000 or 1980.\\n        The IAU 2006 algorithm is based on Hilton et al. 2006.\\n        The IAU 1980 algorithm is based on the Explanatory Supplement to the\\n        Astronomical Almanac (1992).\\n        The IAU 2000 algorithm starts with the IAU 1980 algorithm and applies a\\n        precession-rate correction from the IAU 2000 precession model.\\n\\n    Returns\\n    -------\\n    obliquity : scalar or array\\n        Mean obliquity in degrees (or array of obliquities)\\n\\n    References\\n    ----------\\n    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    * Capitaine, N., et al., 2003, Astron.Astrophys. 400, 1145-1154\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    if algorithm == 2006:\n        return np.rad2deg(erfa.obl06(jd, 0))\n    elif algorithm == 2000:\n        return np.rad2deg(erfa.obl80(jd, 0) + erfa.pr00(jd, 0)[1])\n    elif algorithm == 1980:\n        return np.rad2deg(erfa.obl80(jd, 0))\n    else:\n        raise ValueError('invalid algorithm year for computing obliquity')",
            "def obliquity(jd, algorithm=2006):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the obliquity of the Earth at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date (TT) at which to compute the obliquity\\n    algorithm : int\\n        Year of algorithm based on IAU adoption. Can be 2006, 2000 or 1980.\\n        The IAU 2006 algorithm is based on Hilton et al. 2006.\\n        The IAU 1980 algorithm is based on the Explanatory Supplement to the\\n        Astronomical Almanac (1992).\\n        The IAU 2000 algorithm starts with the IAU 1980 algorithm and applies a\\n        precession-rate correction from the IAU 2000 precession model.\\n\\n    Returns\\n    -------\\n    obliquity : scalar or array\\n        Mean obliquity in degrees (or array of obliquities)\\n\\n    References\\n    ----------\\n    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    * Capitaine, N., et al., 2003, Astron.Astrophys. 400, 1145-1154\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    if algorithm == 2006:\n        return np.rad2deg(erfa.obl06(jd, 0))\n    elif algorithm == 2000:\n        return np.rad2deg(erfa.obl80(jd, 0) + erfa.pr00(jd, 0)[1])\n    elif algorithm == 1980:\n        return np.rad2deg(erfa.obl80(jd, 0))\n    else:\n        raise ValueError('invalid algorithm year for computing obliquity')",
            "def obliquity(jd, algorithm=2006):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the obliquity of the Earth at the requested Julian Date.\\n\\n    Parameters\\n    ----------\\n    jd : scalar or array-like\\n        Julian date (TT) at which to compute the obliquity\\n    algorithm : int\\n        Year of algorithm based on IAU adoption. Can be 2006, 2000 or 1980.\\n        The IAU 2006 algorithm is based on Hilton et al. 2006.\\n        The IAU 1980 algorithm is based on the Explanatory Supplement to the\\n        Astronomical Almanac (1992).\\n        The IAU 2000 algorithm starts with the IAU 1980 algorithm and applies a\\n        precession-rate correction from the IAU 2000 precession model.\\n\\n    Returns\\n    -------\\n    obliquity : scalar or array\\n        Mean obliquity in degrees (or array of obliquities)\\n\\n    References\\n    ----------\\n    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    * Capitaine, N., et al., 2003, Astron.Astrophys. 400, 1145-1154\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    if algorithm == 2006:\n        return np.rad2deg(erfa.obl06(jd, 0))\n    elif algorithm == 2000:\n        return np.rad2deg(erfa.obl80(jd, 0) + erfa.pr00(jd, 0)[1])\n    elif algorithm == 1980:\n        return np.rad2deg(erfa.obl80(jd, 0))\n    else:\n        raise ValueError('invalid algorithm year for computing obliquity')"
        ]
    },
    {
        "func_name": "precession_matrix_Capitaine",
        "original": "def precession_matrix_Capitaine(fromepoch, toepoch):\n    \"\"\"\n    Computes the precession matrix from one Julian epoch to another, per IAU 2006.\n\n    Parameters\n    ----------\n    fromepoch : `~astropy.time.Time`\n        The epoch to precess from.\n    toepoch : `~astropy.time.Time`\n        The epoch to precess to.\n\n    Returns\n    -------\n    pmatrix : 3x3 array\n        Precession matrix to get from ``fromepoch`` to ``toepoch``\n\n    References\n    ----------\n    Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\n    \"\"\"\n    fromepoch_to_J2000 = matrix_transpose(erfa.bp06(*get_jd12(fromepoch, 'tt'))[1])\n    J2000_to_toepoch = erfa.bp06(*get_jd12(toepoch, 'tt'))[1]\n    return J2000_to_toepoch @ fromepoch_to_J2000",
        "mutated": [
            "def precession_matrix_Capitaine(fromepoch, toepoch):\n    if False:\n        i = 10\n    '\\n    Computes the precession matrix from one Julian epoch to another, per IAU 2006.\\n\\n    Parameters\\n    ----------\\n    fromepoch : `~astropy.time.Time`\\n        The epoch to precess from.\\n    toepoch : `~astropy.time.Time`\\n        The epoch to precess to.\\n\\n    Returns\\n    -------\\n    pmatrix : 3x3 array\\n        Precession matrix to get from ``fromepoch`` to ``toepoch``\\n\\n    References\\n    ----------\\n    Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    '\n    fromepoch_to_J2000 = matrix_transpose(erfa.bp06(*get_jd12(fromepoch, 'tt'))[1])\n    J2000_to_toepoch = erfa.bp06(*get_jd12(toepoch, 'tt'))[1]\n    return J2000_to_toepoch @ fromepoch_to_J2000",
            "def precession_matrix_Capitaine(fromepoch, toepoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the precession matrix from one Julian epoch to another, per IAU 2006.\\n\\n    Parameters\\n    ----------\\n    fromepoch : `~astropy.time.Time`\\n        The epoch to precess from.\\n    toepoch : `~astropy.time.Time`\\n        The epoch to precess to.\\n\\n    Returns\\n    -------\\n    pmatrix : 3x3 array\\n        Precession matrix to get from ``fromepoch`` to ``toepoch``\\n\\n    References\\n    ----------\\n    Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    '\n    fromepoch_to_J2000 = matrix_transpose(erfa.bp06(*get_jd12(fromepoch, 'tt'))[1])\n    J2000_to_toepoch = erfa.bp06(*get_jd12(toepoch, 'tt'))[1]\n    return J2000_to_toepoch @ fromepoch_to_J2000",
            "def precession_matrix_Capitaine(fromepoch, toepoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the precession matrix from one Julian epoch to another, per IAU 2006.\\n\\n    Parameters\\n    ----------\\n    fromepoch : `~astropy.time.Time`\\n        The epoch to precess from.\\n    toepoch : `~astropy.time.Time`\\n        The epoch to precess to.\\n\\n    Returns\\n    -------\\n    pmatrix : 3x3 array\\n        Precession matrix to get from ``fromepoch`` to ``toepoch``\\n\\n    References\\n    ----------\\n    Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    '\n    fromepoch_to_J2000 = matrix_transpose(erfa.bp06(*get_jd12(fromepoch, 'tt'))[1])\n    J2000_to_toepoch = erfa.bp06(*get_jd12(toepoch, 'tt'))[1]\n    return J2000_to_toepoch @ fromepoch_to_J2000",
            "def precession_matrix_Capitaine(fromepoch, toepoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the precession matrix from one Julian epoch to another, per IAU 2006.\\n\\n    Parameters\\n    ----------\\n    fromepoch : `~astropy.time.Time`\\n        The epoch to precess from.\\n    toepoch : `~astropy.time.Time`\\n        The epoch to precess to.\\n\\n    Returns\\n    -------\\n    pmatrix : 3x3 array\\n        Precession matrix to get from ``fromepoch`` to ``toepoch``\\n\\n    References\\n    ----------\\n    Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    '\n    fromepoch_to_J2000 = matrix_transpose(erfa.bp06(*get_jd12(fromepoch, 'tt'))[1])\n    J2000_to_toepoch = erfa.bp06(*get_jd12(toepoch, 'tt'))[1]\n    return J2000_to_toepoch @ fromepoch_to_J2000",
            "def precession_matrix_Capitaine(fromepoch, toepoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the precession matrix from one Julian epoch to another, per IAU 2006.\\n\\n    Parameters\\n    ----------\\n    fromepoch : `~astropy.time.Time`\\n        The epoch to precess from.\\n    toepoch : `~astropy.time.Time`\\n        The epoch to precess to.\\n\\n    Returns\\n    -------\\n    pmatrix : 3x3 array\\n        Precession matrix to get from ``fromepoch`` to ``toepoch``\\n\\n    References\\n    ----------\\n    Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351\\n    '\n    fromepoch_to_J2000 = matrix_transpose(erfa.bp06(*get_jd12(fromepoch, 'tt'))[1])\n    J2000_to_toepoch = erfa.bp06(*get_jd12(toepoch, 'tt'))[1]\n    return J2000_to_toepoch @ fromepoch_to_J2000"
        ]
    },
    {
        "func_name": "_precession_matrix_besselian",
        "original": "def _precession_matrix_besselian(epoch1, epoch2):\n    \"\"\"\n    Computes the precession matrix from one Besselian epoch to another using\n    Newcomb's method.\n\n    ``epoch1`` and ``epoch2`` are in Besselian year numbers.\n    \"\"\"\n    t1 = (epoch1 - 1850.0) / 1000.0\n    t2 = (epoch2 - 1850.0) / 1000.0\n    dt = t2 - t1\n    zeta1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    zeta2 = 30.24 - 0.27 * t1\n    zeta3 = 17.995\n    pzeta = (zeta3, zeta2, zeta1, 0)\n    zeta = np.polyval(pzeta, dt) / 3600\n    z1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    z2 = 109.48 + 0.39 * t1\n    z3 = 18.325\n    pz = (z3, z2, z1, 0)\n    z = np.polyval(pz, dt) / 3600\n    theta1 = 20051.12 - 85.29 * t1 - 0.37 * t1 * t1\n    theta2 = -42.65 - 0.37 * t1\n    theta3 = -41.8\n    ptheta = (theta3, theta2, theta1, 0)\n    theta = np.polyval(ptheta, dt) / 3600\n    return rotation_matrix(-z, 'z') @ rotation_matrix(theta, 'y') @ rotation_matrix(-zeta, 'z')",
        "mutated": [
            "def _precession_matrix_besselian(epoch1, epoch2):\n    if False:\n        i = 10\n    \"\\n    Computes the precession matrix from one Besselian epoch to another using\\n    Newcomb's method.\\n\\n    ``epoch1`` and ``epoch2`` are in Besselian year numbers.\\n    \"\n    t1 = (epoch1 - 1850.0) / 1000.0\n    t2 = (epoch2 - 1850.0) / 1000.0\n    dt = t2 - t1\n    zeta1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    zeta2 = 30.24 - 0.27 * t1\n    zeta3 = 17.995\n    pzeta = (zeta3, zeta2, zeta1, 0)\n    zeta = np.polyval(pzeta, dt) / 3600\n    z1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    z2 = 109.48 + 0.39 * t1\n    z3 = 18.325\n    pz = (z3, z2, z1, 0)\n    z = np.polyval(pz, dt) / 3600\n    theta1 = 20051.12 - 85.29 * t1 - 0.37 * t1 * t1\n    theta2 = -42.65 - 0.37 * t1\n    theta3 = -41.8\n    ptheta = (theta3, theta2, theta1, 0)\n    theta = np.polyval(ptheta, dt) / 3600\n    return rotation_matrix(-z, 'z') @ rotation_matrix(theta, 'y') @ rotation_matrix(-zeta, 'z')",
            "def _precession_matrix_besselian(epoch1, epoch2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Computes the precession matrix from one Besselian epoch to another using\\n    Newcomb's method.\\n\\n    ``epoch1`` and ``epoch2`` are in Besselian year numbers.\\n    \"\n    t1 = (epoch1 - 1850.0) / 1000.0\n    t2 = (epoch2 - 1850.0) / 1000.0\n    dt = t2 - t1\n    zeta1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    zeta2 = 30.24 - 0.27 * t1\n    zeta3 = 17.995\n    pzeta = (zeta3, zeta2, zeta1, 0)\n    zeta = np.polyval(pzeta, dt) / 3600\n    z1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    z2 = 109.48 + 0.39 * t1\n    z3 = 18.325\n    pz = (z3, z2, z1, 0)\n    z = np.polyval(pz, dt) / 3600\n    theta1 = 20051.12 - 85.29 * t1 - 0.37 * t1 * t1\n    theta2 = -42.65 - 0.37 * t1\n    theta3 = -41.8\n    ptheta = (theta3, theta2, theta1, 0)\n    theta = np.polyval(ptheta, dt) / 3600\n    return rotation_matrix(-z, 'z') @ rotation_matrix(theta, 'y') @ rotation_matrix(-zeta, 'z')",
            "def _precession_matrix_besselian(epoch1, epoch2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Computes the precession matrix from one Besselian epoch to another using\\n    Newcomb's method.\\n\\n    ``epoch1`` and ``epoch2`` are in Besselian year numbers.\\n    \"\n    t1 = (epoch1 - 1850.0) / 1000.0\n    t2 = (epoch2 - 1850.0) / 1000.0\n    dt = t2 - t1\n    zeta1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    zeta2 = 30.24 - 0.27 * t1\n    zeta3 = 17.995\n    pzeta = (zeta3, zeta2, zeta1, 0)\n    zeta = np.polyval(pzeta, dt) / 3600\n    z1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    z2 = 109.48 + 0.39 * t1\n    z3 = 18.325\n    pz = (z3, z2, z1, 0)\n    z = np.polyval(pz, dt) / 3600\n    theta1 = 20051.12 - 85.29 * t1 - 0.37 * t1 * t1\n    theta2 = -42.65 - 0.37 * t1\n    theta3 = -41.8\n    ptheta = (theta3, theta2, theta1, 0)\n    theta = np.polyval(ptheta, dt) / 3600\n    return rotation_matrix(-z, 'z') @ rotation_matrix(theta, 'y') @ rotation_matrix(-zeta, 'z')",
            "def _precession_matrix_besselian(epoch1, epoch2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Computes the precession matrix from one Besselian epoch to another using\\n    Newcomb's method.\\n\\n    ``epoch1`` and ``epoch2`` are in Besselian year numbers.\\n    \"\n    t1 = (epoch1 - 1850.0) / 1000.0\n    t2 = (epoch2 - 1850.0) / 1000.0\n    dt = t2 - t1\n    zeta1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    zeta2 = 30.24 - 0.27 * t1\n    zeta3 = 17.995\n    pzeta = (zeta3, zeta2, zeta1, 0)\n    zeta = np.polyval(pzeta, dt) / 3600\n    z1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    z2 = 109.48 + 0.39 * t1\n    z3 = 18.325\n    pz = (z3, z2, z1, 0)\n    z = np.polyval(pz, dt) / 3600\n    theta1 = 20051.12 - 85.29 * t1 - 0.37 * t1 * t1\n    theta2 = -42.65 - 0.37 * t1\n    theta3 = -41.8\n    ptheta = (theta3, theta2, theta1, 0)\n    theta = np.polyval(ptheta, dt) / 3600\n    return rotation_matrix(-z, 'z') @ rotation_matrix(theta, 'y') @ rotation_matrix(-zeta, 'z')",
            "def _precession_matrix_besselian(epoch1, epoch2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Computes the precession matrix from one Besselian epoch to another using\\n    Newcomb's method.\\n\\n    ``epoch1`` and ``epoch2`` are in Besselian year numbers.\\n    \"\n    t1 = (epoch1 - 1850.0) / 1000.0\n    t2 = (epoch2 - 1850.0) / 1000.0\n    dt = t2 - t1\n    zeta1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    zeta2 = 30.24 - 0.27 * t1\n    zeta3 = 17.995\n    pzeta = (zeta3, zeta2, zeta1, 0)\n    zeta = np.polyval(pzeta, dt) / 3600\n    z1 = 23035.545 + t1 * 139.72 + 0.06 * t1 * t1\n    z2 = 109.48 + 0.39 * t1\n    z3 = 18.325\n    pz = (z3, z2, z1, 0)\n    z = np.polyval(pz, dt) / 3600\n    theta1 = 20051.12 - 85.29 * t1 - 0.37 * t1 * t1\n    theta2 = -42.65 - 0.37 * t1\n    theta3 = -41.8\n    ptheta = (theta3, theta2, theta1, 0)\n    theta = np.polyval(ptheta, dt) / 3600\n    return rotation_matrix(-z, 'z') @ rotation_matrix(theta, 'y') @ rotation_matrix(-zeta, 'z')"
        ]
    },
    {
        "func_name": "nutation_components2000B",
        "original": "def nutation_components2000B(jd):\n    \"\"\"\n    Computes nutation components following the IAU 2000B specification.\n\n    Parameters\n    ----------\n    jd : scalar\n        Julian date (TT) at which to compute the nutation components\n\n    Returns\n    -------\n    eps : float\n        epsilon in radians\n    dpsi : float\n        dpsi in radians\n    deps : float\n        depsilon in raidans\n    \"\"\"\n    (dpsi, deps, epsa, _, _, _, _, _) = erfa.pn00b(jd, 0)\n    return (epsa, dpsi, deps)",
        "mutated": [
            "def nutation_components2000B(jd):\n    if False:\n        i = 10\n    '\\n    Computes nutation components following the IAU 2000B specification.\\n\\n    Parameters\\n    ----------\\n    jd : scalar\\n        Julian date (TT) at which to compute the nutation components\\n\\n    Returns\\n    -------\\n    eps : float\\n        epsilon in radians\\n    dpsi : float\\n        dpsi in radians\\n    deps : float\\n        depsilon in raidans\\n    '\n    (dpsi, deps, epsa, _, _, _, _, _) = erfa.pn00b(jd, 0)\n    return (epsa, dpsi, deps)",
            "def nutation_components2000B(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes nutation components following the IAU 2000B specification.\\n\\n    Parameters\\n    ----------\\n    jd : scalar\\n        Julian date (TT) at which to compute the nutation components\\n\\n    Returns\\n    -------\\n    eps : float\\n        epsilon in radians\\n    dpsi : float\\n        dpsi in radians\\n    deps : float\\n        depsilon in raidans\\n    '\n    (dpsi, deps, epsa, _, _, _, _, _) = erfa.pn00b(jd, 0)\n    return (epsa, dpsi, deps)",
            "def nutation_components2000B(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes nutation components following the IAU 2000B specification.\\n\\n    Parameters\\n    ----------\\n    jd : scalar\\n        Julian date (TT) at which to compute the nutation components\\n\\n    Returns\\n    -------\\n    eps : float\\n        epsilon in radians\\n    dpsi : float\\n        dpsi in radians\\n    deps : float\\n        depsilon in raidans\\n    '\n    (dpsi, deps, epsa, _, _, _, _, _) = erfa.pn00b(jd, 0)\n    return (epsa, dpsi, deps)",
            "def nutation_components2000B(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes nutation components following the IAU 2000B specification.\\n\\n    Parameters\\n    ----------\\n    jd : scalar\\n        Julian date (TT) at which to compute the nutation components\\n\\n    Returns\\n    -------\\n    eps : float\\n        epsilon in radians\\n    dpsi : float\\n        dpsi in radians\\n    deps : float\\n        depsilon in raidans\\n    '\n    (dpsi, deps, epsa, _, _, _, _, _) = erfa.pn00b(jd, 0)\n    return (epsa, dpsi, deps)",
            "def nutation_components2000B(jd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes nutation components following the IAU 2000B specification.\\n\\n    Parameters\\n    ----------\\n    jd : scalar\\n        Julian date (TT) at which to compute the nutation components\\n\\n    Returns\\n    -------\\n    eps : float\\n        epsilon in radians\\n    dpsi : float\\n        dpsi in radians\\n    deps : float\\n        depsilon in raidans\\n    '\n    (dpsi, deps, epsa, _, _, _, _, _) = erfa.pn00b(jd, 0)\n    return (epsa, dpsi, deps)"
        ]
    },
    {
        "func_name": "nutation_matrix",
        "original": "def nutation_matrix(epoch):\n    \"\"\"\n    Nutation matrix generated from nutation components, IAU 2000B model.\n\n    Matrix converts from mean coordinate to true coordinate as\n    r_true = M * r_mean\n\n    Parameters\n    ----------\n    epoch : `~astropy.time.Time`\n        The epoch at which to compute the nutation matrix\n\n    Returns\n    -------\n    nmatrix : 3x3 array\n        Nutation matrix for the specified epoch\n\n    References\n    ----------\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\n      Seidelmann (ed), University Science Books (1992).\n    \"\"\"\n    return erfa.num00b(*get_jd12(epoch, 'tt'))",
        "mutated": [
            "def nutation_matrix(epoch):\n    if False:\n        i = 10\n    '\\n    Nutation matrix generated from nutation components, IAU 2000B model.\\n\\n    Matrix converts from mean coordinate to true coordinate as\\n    r_true = M * r_mean\\n\\n    Parameters\\n    ----------\\n    epoch : `~astropy.time.Time`\\n        The epoch at which to compute the nutation matrix\\n\\n    Returns\\n    -------\\n    nmatrix : 3x3 array\\n        Nutation matrix for the specified epoch\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    return erfa.num00b(*get_jd12(epoch, 'tt'))",
            "def nutation_matrix(epoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Nutation matrix generated from nutation components, IAU 2000B model.\\n\\n    Matrix converts from mean coordinate to true coordinate as\\n    r_true = M * r_mean\\n\\n    Parameters\\n    ----------\\n    epoch : `~astropy.time.Time`\\n        The epoch at which to compute the nutation matrix\\n\\n    Returns\\n    -------\\n    nmatrix : 3x3 array\\n        Nutation matrix for the specified epoch\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    return erfa.num00b(*get_jd12(epoch, 'tt'))",
            "def nutation_matrix(epoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Nutation matrix generated from nutation components, IAU 2000B model.\\n\\n    Matrix converts from mean coordinate to true coordinate as\\n    r_true = M * r_mean\\n\\n    Parameters\\n    ----------\\n    epoch : `~astropy.time.Time`\\n        The epoch at which to compute the nutation matrix\\n\\n    Returns\\n    -------\\n    nmatrix : 3x3 array\\n        Nutation matrix for the specified epoch\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    return erfa.num00b(*get_jd12(epoch, 'tt'))",
            "def nutation_matrix(epoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Nutation matrix generated from nutation components, IAU 2000B model.\\n\\n    Matrix converts from mean coordinate to true coordinate as\\n    r_true = M * r_mean\\n\\n    Parameters\\n    ----------\\n    epoch : `~astropy.time.Time`\\n        The epoch at which to compute the nutation matrix\\n\\n    Returns\\n    -------\\n    nmatrix : 3x3 array\\n        Nutation matrix for the specified epoch\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    return erfa.num00b(*get_jd12(epoch, 'tt'))",
            "def nutation_matrix(epoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Nutation matrix generated from nutation components, IAU 2000B model.\\n\\n    Matrix converts from mean coordinate to true coordinate as\\n    r_true = M * r_mean\\n\\n    Parameters\\n    ----------\\n    epoch : `~astropy.time.Time`\\n        The epoch at which to compute the nutation matrix\\n\\n    Returns\\n    -------\\n    nmatrix : 3x3 array\\n        Nutation matrix for the specified epoch\\n\\n    References\\n    ----------\\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\\n      Seidelmann (ed), University Science Books (1992).\\n    '\n    return erfa.num00b(*get_jd12(epoch, 'tt'))"
        ]
    }
]