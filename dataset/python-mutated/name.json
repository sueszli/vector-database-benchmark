[
    {
        "func_name": "__init__",
        "original": "def __init__(self, expr: Expr):\n    self._from_pyexpr = expr._from_pyexpr\n    self._pyexpr = expr._pyexpr",
        "mutated": [
            "def __init__(self, expr: Expr):\n    if False:\n        i = 10\n    self._from_pyexpr = expr._from_pyexpr\n    self._pyexpr = expr._pyexpr",
            "def __init__(self, expr: Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._from_pyexpr = expr._from_pyexpr\n    self._pyexpr = expr._pyexpr",
            "def __init__(self, expr: Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._from_pyexpr = expr._from_pyexpr\n    self._pyexpr = expr._pyexpr",
            "def __init__(self, expr: Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._from_pyexpr = expr._from_pyexpr\n    self._pyexpr = expr._pyexpr",
            "def __init__(self, expr: Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._from_pyexpr = expr._from_pyexpr\n    self._pyexpr = expr._pyexpr"
        ]
    },
    {
        "func_name": "keep",
        "original": "def keep(self) -> Expr:\n    \"\"\"\n        Keep the original root name of the expression.\n\n        Notes\n        -----\n        Due to implementation constraints, this method can only be called as the last\n        expression in a chain.\n\n        See Also\n        --------\n        alias\n        map\n\n        Examples\n        --------\n        Prevent errors due to potential duplicate column names.\n\n        >>> df = pl.DataFrame(\n        ...     {\n        ...         \"a\": [1, 2],\n        ...         \"b\": [3, 4],\n        ...     }\n        ... )\n        >>> df.select((pl.lit(10) / pl.all()).name.keep())\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 a    \u2506 b        \u2502\n        \u2502 ---  \u2506 ---      \u2502\n        \u2502 f64  \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 10.0 \u2506 3.333333 \u2502\n        \u2502 5.0  \u2506 2.5      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        Undo an alias operation.\n\n        >>> df.with_columns((pl.col(\"a\") * 9).alias(\"c\").name.keep())\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 a   \u2506 b   \u2502\n        \u2502 --- \u2506 --- \u2502\n        \u2502 i64 \u2506 i64 \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 9   \u2506 3   \u2502\n        \u2502 18  \u2506 4   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n\n        \"\"\"\n    return self._from_pyexpr(self._pyexpr.name_keep())",
        "mutated": [
            "def keep(self) -> Expr:\n    if False:\n        i = 10\n    '\\n        Keep the original root name of the expression.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        alias\\n        map\\n\\n        Examples\\n        --------\\n        Prevent errors due to potential duplicate column names.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2],\\n        ...         \"b\": [3, 4],\\n        ...     }\\n        ... )\\n        >>> df.select((pl.lit(10) / pl.all()).name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a    \u2506 b        \u2502\\n        \u2502 ---  \u2506 ---      \u2502\\n        \u2502 f64  \u2506 f64      \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 10.0 \u2506 3.333333 \u2502\\n        \u2502 5.0  \u2506 2.5      \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        Undo an alias operation.\\n\\n        >>> df.with_columns((pl.col(\"a\") * 9).alias(\"c\").name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2502\\n        \u2502 --- \u2506 --- \u2502\\n        \u2502 i64 \u2506 i64 \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 9   \u2506 3   \u2502\\n        \u2502 18  \u2506 4   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_keep())",
            "def keep(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Keep the original root name of the expression.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        alias\\n        map\\n\\n        Examples\\n        --------\\n        Prevent errors due to potential duplicate column names.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2],\\n        ...         \"b\": [3, 4],\\n        ...     }\\n        ... )\\n        >>> df.select((pl.lit(10) / pl.all()).name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a    \u2506 b        \u2502\\n        \u2502 ---  \u2506 ---      \u2502\\n        \u2502 f64  \u2506 f64      \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 10.0 \u2506 3.333333 \u2502\\n        \u2502 5.0  \u2506 2.5      \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        Undo an alias operation.\\n\\n        >>> df.with_columns((pl.col(\"a\") * 9).alias(\"c\").name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2502\\n        \u2502 --- \u2506 --- \u2502\\n        \u2502 i64 \u2506 i64 \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 9   \u2506 3   \u2502\\n        \u2502 18  \u2506 4   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_keep())",
            "def keep(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Keep the original root name of the expression.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        alias\\n        map\\n\\n        Examples\\n        --------\\n        Prevent errors due to potential duplicate column names.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2],\\n        ...         \"b\": [3, 4],\\n        ...     }\\n        ... )\\n        >>> df.select((pl.lit(10) / pl.all()).name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a    \u2506 b        \u2502\\n        \u2502 ---  \u2506 ---      \u2502\\n        \u2502 f64  \u2506 f64      \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 10.0 \u2506 3.333333 \u2502\\n        \u2502 5.0  \u2506 2.5      \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        Undo an alias operation.\\n\\n        >>> df.with_columns((pl.col(\"a\") * 9).alias(\"c\").name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2502\\n        \u2502 --- \u2506 --- \u2502\\n        \u2502 i64 \u2506 i64 \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 9   \u2506 3   \u2502\\n        \u2502 18  \u2506 4   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_keep())",
            "def keep(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Keep the original root name of the expression.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        alias\\n        map\\n\\n        Examples\\n        --------\\n        Prevent errors due to potential duplicate column names.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2],\\n        ...         \"b\": [3, 4],\\n        ...     }\\n        ... )\\n        >>> df.select((pl.lit(10) / pl.all()).name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a    \u2506 b        \u2502\\n        \u2502 ---  \u2506 ---      \u2502\\n        \u2502 f64  \u2506 f64      \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 10.0 \u2506 3.333333 \u2502\\n        \u2502 5.0  \u2506 2.5      \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        Undo an alias operation.\\n\\n        >>> df.with_columns((pl.col(\"a\") * 9).alias(\"c\").name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2502\\n        \u2502 --- \u2506 --- \u2502\\n        \u2502 i64 \u2506 i64 \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 9   \u2506 3   \u2502\\n        \u2502 18  \u2506 4   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_keep())",
            "def keep(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Keep the original root name of the expression.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        alias\\n        map\\n\\n        Examples\\n        --------\\n        Prevent errors due to potential duplicate column names.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2],\\n        ...         \"b\": [3, 4],\\n        ...     }\\n        ... )\\n        >>> df.select((pl.lit(10) / pl.all()).name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a    \u2506 b        \u2502\\n        \u2502 ---  \u2506 ---      \u2502\\n        \u2502 f64  \u2506 f64      \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 10.0 \u2506 3.333333 \u2502\\n        \u2502 5.0  \u2506 2.5      \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        Undo an alias operation.\\n\\n        >>> df.with_columns((pl.col(\"a\") * 9).alias(\"c\").name.keep())\\n        shape: (2, 2)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2502\\n        \u2502 --- \u2506 --- \u2502\\n        \u2502 i64 \u2506 i64 \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 9   \u2506 3   \u2502\\n        \u2502 18  \u2506 4   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_keep())"
        ]
    },
    {
        "func_name": "map",
        "original": "def map(self, function: Callable[[str], str]) -> Expr:\n    \"\"\"\n        Rename the output of an expression by mapping a function over the root name.\n\n        Parameters\n        ----------\n        function\n            Function that maps a root name to a new name.\n\n        See Also\n        --------\n        keep\n        prefix\n        suffix\n\n        Examples\n        --------\n        Remove a common suffix and convert to lower case.\n\n        >>> df = pl.DataFrame(\n        ...     {\n        ...         \"A_reverse\": [3, 2, 1],\n        ...         \"B_reverse\": [\"z\", \"y\", \"x\"],\n        ...     }\n        ... )\n        >>> df.with_columns(\n        ...     pl.all().reverse().name.map(lambda c: c.rstrip(\"_reverse\").lower())\n        ... )\n        shape: (3, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 A_reverse \u2506 B_reverse \u2506 a   \u2506 b   \u2502\n        \u2502 ---       \u2506 ---       \u2506 --- \u2506 --- \u2502\n        \u2502 i64       \u2506 str       \u2506 i64 \u2506 str \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 3         \u2506 z         \u2506 1   \u2506 x   \u2502\n        \u2502 2         \u2506 y         \u2506 2   \u2506 y   \u2502\n        \u2502 1         \u2506 x         \u2506 3   \u2506 z   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n\n        \"\"\"\n    return self._from_pyexpr(self._pyexpr.name_map(function))",
        "mutated": [
            "def map(self, function: Callable[[str], str]) -> Expr:\n    if False:\n        i = 10\n    '\\n        Rename the output of an expression by mapping a function over the root name.\\n\\n        Parameters\\n        ----------\\n        function\\n            Function that maps a root name to a new name.\\n\\n        See Also\\n        --------\\n        keep\\n        prefix\\n        suffix\\n\\n        Examples\\n        --------\\n        Remove a common suffix and convert to lower case.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"A_reverse\": [3, 2, 1],\\n        ...         \"B_reverse\": [\"z\", \"y\", \"x\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(\\n        ...     pl.all().reverse().name.map(lambda c: c.rstrip(\"_reverse\").lower())\\n        ... )\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 A_reverse \u2506 B_reverse \u2506 a   \u2506 b   \u2502\\n        \u2502 ---       \u2506 ---       \u2506 --- \u2506 --- \u2502\\n        \u2502 i64       \u2506 str       \u2506 i64 \u2506 str \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 3         \u2506 z         \u2506 1   \u2506 x   \u2502\\n        \u2502 2         \u2506 y         \u2506 2   \u2506 y   \u2502\\n        \u2502 1         \u2506 x         \u2506 3   \u2506 z   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_map(function))",
            "def map(self, function: Callable[[str], str]) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Rename the output of an expression by mapping a function over the root name.\\n\\n        Parameters\\n        ----------\\n        function\\n            Function that maps a root name to a new name.\\n\\n        See Also\\n        --------\\n        keep\\n        prefix\\n        suffix\\n\\n        Examples\\n        --------\\n        Remove a common suffix and convert to lower case.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"A_reverse\": [3, 2, 1],\\n        ...         \"B_reverse\": [\"z\", \"y\", \"x\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(\\n        ...     pl.all().reverse().name.map(lambda c: c.rstrip(\"_reverse\").lower())\\n        ... )\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 A_reverse \u2506 B_reverse \u2506 a   \u2506 b   \u2502\\n        \u2502 ---       \u2506 ---       \u2506 --- \u2506 --- \u2502\\n        \u2502 i64       \u2506 str       \u2506 i64 \u2506 str \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 3         \u2506 z         \u2506 1   \u2506 x   \u2502\\n        \u2502 2         \u2506 y         \u2506 2   \u2506 y   \u2502\\n        \u2502 1         \u2506 x         \u2506 3   \u2506 z   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_map(function))",
            "def map(self, function: Callable[[str], str]) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Rename the output of an expression by mapping a function over the root name.\\n\\n        Parameters\\n        ----------\\n        function\\n            Function that maps a root name to a new name.\\n\\n        See Also\\n        --------\\n        keep\\n        prefix\\n        suffix\\n\\n        Examples\\n        --------\\n        Remove a common suffix and convert to lower case.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"A_reverse\": [3, 2, 1],\\n        ...         \"B_reverse\": [\"z\", \"y\", \"x\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(\\n        ...     pl.all().reverse().name.map(lambda c: c.rstrip(\"_reverse\").lower())\\n        ... )\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 A_reverse \u2506 B_reverse \u2506 a   \u2506 b   \u2502\\n        \u2502 ---       \u2506 ---       \u2506 --- \u2506 --- \u2502\\n        \u2502 i64       \u2506 str       \u2506 i64 \u2506 str \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 3         \u2506 z         \u2506 1   \u2506 x   \u2502\\n        \u2502 2         \u2506 y         \u2506 2   \u2506 y   \u2502\\n        \u2502 1         \u2506 x         \u2506 3   \u2506 z   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_map(function))",
            "def map(self, function: Callable[[str], str]) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Rename the output of an expression by mapping a function over the root name.\\n\\n        Parameters\\n        ----------\\n        function\\n            Function that maps a root name to a new name.\\n\\n        See Also\\n        --------\\n        keep\\n        prefix\\n        suffix\\n\\n        Examples\\n        --------\\n        Remove a common suffix and convert to lower case.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"A_reverse\": [3, 2, 1],\\n        ...         \"B_reverse\": [\"z\", \"y\", \"x\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(\\n        ...     pl.all().reverse().name.map(lambda c: c.rstrip(\"_reverse\").lower())\\n        ... )\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 A_reverse \u2506 B_reverse \u2506 a   \u2506 b   \u2502\\n        \u2502 ---       \u2506 ---       \u2506 --- \u2506 --- \u2502\\n        \u2502 i64       \u2506 str       \u2506 i64 \u2506 str \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 3         \u2506 z         \u2506 1   \u2506 x   \u2502\\n        \u2502 2         \u2506 y         \u2506 2   \u2506 y   \u2502\\n        \u2502 1         \u2506 x         \u2506 3   \u2506 z   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_map(function))",
            "def map(self, function: Callable[[str], str]) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Rename the output of an expression by mapping a function over the root name.\\n\\n        Parameters\\n        ----------\\n        function\\n            Function that maps a root name to a new name.\\n\\n        See Also\\n        --------\\n        keep\\n        prefix\\n        suffix\\n\\n        Examples\\n        --------\\n        Remove a common suffix and convert to lower case.\\n\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"A_reverse\": [3, 2, 1],\\n        ...         \"B_reverse\": [\"z\", \"y\", \"x\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(\\n        ...     pl.all().reverse().name.map(lambda c: c.rstrip(\"_reverse\").lower())\\n        ... )\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 A_reverse \u2506 B_reverse \u2506 a   \u2506 b   \u2502\\n        \u2502 ---       \u2506 ---       \u2506 --- \u2506 --- \u2502\\n        \u2502 i64       \u2506 str       \u2506 i64 \u2506 str \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 3         \u2506 z         \u2506 1   \u2506 x   \u2502\\n        \u2502 2         \u2506 y         \u2506 2   \u2506 y   \u2502\\n        \u2502 1         \u2506 x         \u2506 3   \u2506 z   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_map(function))"
        ]
    },
    {
        "func_name": "prefix",
        "original": "def prefix(self, prefix: str) -> Expr:\n    \"\"\"\n        Add a prefix to the root column name of the expression.\n\n        Parameters\n        ----------\n        prefix\n            Prefix to add to the root column name.\n\n        Notes\n        -----\n        This will undo any previous renaming operations on the expression.\n\n        Due to implementation constraints, this method can only be called as the last\n        expression in a chain.\n\n        See Also\n        --------\n        suffix\n\n        Examples\n        --------\n        >>> df = pl.DataFrame(\n        ...     {\n        ...         \"a\": [1, 2, 3],\n        ...         \"b\": [\"x\", \"y\", \"z\"],\n        ...     }\n        ... )\n        >>> df.with_columns(pl.all().reverse().name.prefix(\"reverse_\"))\n        shape: (3, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 a   \u2506 b   \u2506 reverse_a \u2506 reverse_b \u2502\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        \"\"\"\n    return self._from_pyexpr(self._pyexpr.name_prefix(prefix))",
        "mutated": [
            "def prefix(self, prefix: str) -> Expr:\n    if False:\n        i = 10\n    '\\n        Add a prefix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        prefix\\n            Prefix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        suffix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.prefix(\"reverse_\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 reverse_a \u2506 reverse_b \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_prefix(prefix))",
            "def prefix(self, prefix: str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Add a prefix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        prefix\\n            Prefix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        suffix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.prefix(\"reverse_\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 reverse_a \u2506 reverse_b \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_prefix(prefix))",
            "def prefix(self, prefix: str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Add a prefix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        prefix\\n            Prefix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        suffix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.prefix(\"reverse_\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 reverse_a \u2506 reverse_b \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_prefix(prefix))",
            "def prefix(self, prefix: str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Add a prefix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        prefix\\n            Prefix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        suffix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.prefix(\"reverse_\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 reverse_a \u2506 reverse_b \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_prefix(prefix))",
            "def prefix(self, prefix: str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Add a prefix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        prefix\\n            Prefix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        suffix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.prefix(\"reverse_\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 reverse_a \u2506 reverse_b \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_prefix(prefix))"
        ]
    },
    {
        "func_name": "suffix",
        "original": "def suffix(self, suffix: str) -> Expr:\n    \"\"\"\n        Add a suffix to the root column name of the expression.\n\n        Parameters\n        ----------\n        suffix\n            Suffix to add to the root column name.\n\n        Notes\n        -----\n        This will undo any previous renaming operations on the expression.\n\n        Due to implementation constraints, this method can only be called as the last\n        expression in a chain.\n\n        See Also\n        --------\n        prefix\n\n        Examples\n        --------\n        >>> df = pl.DataFrame(\n        ...     {\n        ...         \"a\": [1, 2, 3],\n        ...         \"b\": [\"x\", \"y\", \"z\"],\n        ...     }\n        ... )\n        >>> df.with_columns(pl.all().reverse().name.suffix(\"_reverse\"))\n        shape: (3, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 a   \u2506 b   \u2506 a_reverse \u2506 b_reverse \u2502\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        \"\"\"\n    return self._from_pyexpr(self._pyexpr.name_suffix(suffix))",
        "mutated": [
            "def suffix(self, suffix: str) -> Expr:\n    if False:\n        i = 10\n    '\\n        Add a suffix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        suffix\\n            Suffix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.suffix(\"_reverse\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 a_reverse \u2506 b_reverse \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_suffix(suffix))",
            "def suffix(self, suffix: str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Add a suffix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        suffix\\n            Suffix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.suffix(\"_reverse\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 a_reverse \u2506 b_reverse \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_suffix(suffix))",
            "def suffix(self, suffix: str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Add a suffix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        suffix\\n            Suffix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.suffix(\"_reverse\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 a_reverse \u2506 b_reverse \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_suffix(suffix))",
            "def suffix(self, suffix: str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Add a suffix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        suffix\\n            Suffix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.suffix(\"_reverse\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 a_reverse \u2506 b_reverse \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_suffix(suffix))",
            "def suffix(self, suffix: str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Add a suffix to the root column name of the expression.\\n\\n        Parameters\\n        ----------\\n        suffix\\n            Suffix to add to the root column name.\\n\\n        Notes\\n        -----\\n        This will undo any previous renaming operations on the expression.\\n\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"a\": [1, 2, 3],\\n        ...         \"b\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().reverse().name.suffix(\"_reverse\"))\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 a   \u2506 b   \u2506 a_reverse \u2506 b_reverse \u2502\\n        \u2502 --- \u2506 --- \u2506 ---       \u2506 ---       \u2502\\n        \u2502 i64 \u2506 str \u2506 i64       \u2506 str       \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1   \u2506 x   \u2506 3         \u2506 z         \u2502\\n        \u2502 2   \u2506 y   \u2506 2         \u2506 y         \u2502\\n        \u2502 3   \u2506 z   \u2506 1         \u2506 x         \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_suffix(suffix))"
        ]
    },
    {
        "func_name": "to_lowercase",
        "original": "def to_lowercase(self) -> Expr:\n    \"\"\"\n        Make the root column name lowercase.\n\n        Notes\n        -----\n        Due to implementation constraints, this method can only be called as the last\n        expression in a chain.\n\n        See Also\n        --------\n        prefix\n        suffix\n        to_uppercase\n\n        Examples\n        --------\n        >>> df = pl.DataFrame(\n        ...     {\n        ...         \"ColX\": [1, 2, 3],\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\n        ...     }\n        ... )\n        >>> df.with_columns(pl.all().name.to_lowercase())\n        shape: (3, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ColX \u2506 ColY \u2506 colx \u2506 coly \u2502\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        \"\"\"\n    return self._from_pyexpr(self._pyexpr.name_to_lowercase())",
        "mutated": [
            "def to_lowercase(self) -> Expr:\n    if False:\n        i = 10\n    '\\n        Make the root column name lowercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_uppercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_lowercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 colx \u2506 coly \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_lowercase())",
            "def to_lowercase(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Make the root column name lowercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_uppercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_lowercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 colx \u2506 coly \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_lowercase())",
            "def to_lowercase(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Make the root column name lowercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_uppercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_lowercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 colx \u2506 coly \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_lowercase())",
            "def to_lowercase(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Make the root column name lowercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_uppercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_lowercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 colx \u2506 coly \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_lowercase())",
            "def to_lowercase(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Make the root column name lowercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_uppercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_lowercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 colx \u2506 coly \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_lowercase())"
        ]
    },
    {
        "func_name": "to_uppercase",
        "original": "def to_uppercase(self) -> Expr:\n    \"\"\"\n        Make the root column name uppercase.\n\n        Notes\n        -----\n        Due to implementation constraints, this method can only be called as the last\n        expression in a chain.\n\n        See Also\n        --------\n        prefix\n        suffix\n        to_lowercase\n\n        Examples\n        --------\n        >>> df = pl.DataFrame(\n        ...     {\n        ...         \"ColX\": [1, 2, 3],\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\n        ...     }\n        ... )\n        >>> df.with_columns(pl.all().name.to_uppercase())\n        shape: (3, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ColX \u2506 ColY \u2506 COLX \u2506 COLY \u2502\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        \"\"\"\n    return self._from_pyexpr(self._pyexpr.name_to_uppercase())",
        "mutated": [
            "def to_uppercase(self) -> Expr:\n    if False:\n        i = 10\n    '\\n        Make the root column name uppercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_lowercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_uppercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 COLX \u2506 COLY \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_uppercase())",
            "def to_uppercase(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Make the root column name uppercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_lowercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_uppercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 COLX \u2506 COLY \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_uppercase())",
            "def to_uppercase(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Make the root column name uppercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_lowercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_uppercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 COLX \u2506 COLY \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_uppercase())",
            "def to_uppercase(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Make the root column name uppercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_lowercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_uppercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 COLX \u2506 COLY \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_uppercase())",
            "def to_uppercase(self) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Make the root column name uppercase.\\n\\n        Notes\\n        -----\\n        Due to implementation constraints, this method can only be called as the last\\n        expression in a chain.\\n\\n        See Also\\n        --------\\n        prefix\\n        suffix\\n        to_lowercase\\n\\n        Examples\\n        --------\\n        >>> df = pl.DataFrame(\\n        ...     {\\n        ...         \"ColX\": [1, 2, 3],\\n        ...         \"ColY\": [\"x\", \"y\", \"z\"],\\n        ...     }\\n        ... )\\n        >>> df.with_columns(pl.all().name.to_uppercase())\\n        shape: (3, 4)\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u2502 ColX \u2506 ColY \u2506 COLX \u2506 COLY \u2502\\n        \u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\\n        \u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n        \u2502 1    \u2506 x    \u2506 1    \u2506 x    \u2502\\n        \u2502 2    \u2506 y    \u2506 2    \u2506 y    \u2502\\n        \u2502 3    \u2506 z    \u2506 3    \u2506 z    \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    return self._from_pyexpr(self._pyexpr.name_to_uppercase())"
        ]
    }
]