[
    {
        "func_name": "__init__",
        "original": "def __init__(self, data: list):\n    super().__init__()\n    self.data = data",
        "mutated": [
            "def __init__(self, data: list):\n    if False:\n        i = 10\n    super().__init__()\n    self.data = data",
            "def __init__(self, data: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    self.data = data",
            "def __init__(self, data: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    self.data = data",
            "def __init__(self, data: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    self.data = data",
            "def __init__(self, data: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    self.data = data"
        ]
    },
    {
        "func_name": "__len__",
        "original": "def __len__(self):\n    return len(self.data)",
        "mutated": [
            "def __len__(self):\n    if False:\n        i = 10\n    return len(self.data)",
            "def __len__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return len(self.data)",
            "def __len__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return len(self.data)",
            "def __len__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return len(self.data)",
            "def __len__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return len(self.data)"
        ]
    },
    {
        "func_name": "__getitem__",
        "original": "def __getitem__(self, index):\n    return self.data[index]",
        "mutated": [
            "def __getitem__(self, index):\n    if False:\n        i = 10\n    return self.data[index]",
            "def __getitem__(self, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.data[index]",
            "def __getitem__(self, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.data[index]",
            "def __getitem__(self, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.data[index]",
            "def __getitem__(self, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.data[index]"
        ]
    },
    {
        "func_name": "thread_filter",
        "original": "def thread_filter(thread: list[ExportMessageNode]) -> bool:\n    if any((m.deleted or m.synthetic for m in thread)):\n        return False\n    if top_k is not None:\n        for (i, m) in enumerate(thread):\n            if m.role == 'assistant':\n                if m.rank is None:\n                    if i > 0 and len(thread[i - 1].replies) > 1:\n                        return False\n                elif m.rank >= top_k:\n                    return False\n    return True",
        "mutated": [
            "def thread_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n    if any((m.deleted or m.synthetic for m in thread)):\n        return False\n    if top_k is not None:\n        for (i, m) in enumerate(thread):\n            if m.role == 'assistant':\n                if m.rank is None:\n                    if i > 0 and len(thread[i - 1].replies) > 1:\n                        return False\n                elif m.rank >= top_k:\n                    return False\n    return True",
            "def thread_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if any((m.deleted or m.synthetic for m in thread)):\n        return False\n    if top_k is not None:\n        for (i, m) in enumerate(thread):\n            if m.role == 'assistant':\n                if m.rank is None:\n                    if i > 0 and len(thread[i - 1].replies) > 1:\n                        return False\n                elif m.rank >= top_k:\n                    return False\n    return True",
            "def thread_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if any((m.deleted or m.synthetic for m in thread)):\n        return False\n    if top_k is not None:\n        for (i, m) in enumerate(thread):\n            if m.role == 'assistant':\n                if m.rank is None:\n                    if i > 0 and len(thread[i - 1].replies) > 1:\n                        return False\n                elif m.rank >= top_k:\n                    return False\n    return True",
            "def thread_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if any((m.deleted or m.synthetic for m in thread)):\n        return False\n    if top_k is not None:\n        for (i, m) in enumerate(thread):\n            if m.role == 'assistant':\n                if m.rank is None:\n                    if i > 0 and len(thread[i - 1].replies) > 1:\n                        return False\n                elif m.rank >= top_k:\n                    return False\n    return True",
            "def thread_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if any((m.deleted or m.synthetic for m in thread)):\n        return False\n    if top_k is not None:\n        for (i, m) in enumerate(thread):\n            if m.role == 'assistant':\n                if m.rank is None:\n                    if i > 0 and len(thread[i - 1].replies) > 1:\n                        return False\n                elif m.rank >= top_k:\n                    return False\n    return True"
        ]
    },
    {
        "func_name": "leaf_filter",
        "original": "def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n    if mode == 'sft':\n        return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n    elif mode == 'rm':\n        if thread[-1].replies is None:\n            return False\n        return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n    elif mode == 'rl':\n        return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n    raise RuntimeError()",
        "mutated": [
            "def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n    if mode == 'sft':\n        return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n    elif mode == 'rm':\n        if thread[-1].replies is None:\n            return False\n        return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n    elif mode == 'rl':\n        return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n    raise RuntimeError()",
            "def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if mode == 'sft':\n        return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n    elif mode == 'rm':\n        if thread[-1].replies is None:\n            return False\n        return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n    elif mode == 'rl':\n        return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n    raise RuntimeError()",
            "def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if mode == 'sft':\n        return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n    elif mode == 'rm':\n        if thread[-1].replies is None:\n            return False\n        return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n    elif mode == 'rl':\n        return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n    raise RuntimeError()",
            "def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if mode == 'sft':\n        return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n    elif mode == 'rm':\n        if thread[-1].replies is None:\n            return False\n        return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n    elif mode == 'rl':\n        return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n    raise RuntimeError()",
            "def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if mode == 'sft':\n        return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n    elif mode == 'rm':\n        if thread[-1].replies is None:\n            return False\n        return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n    elif mode == 'rl':\n        return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n    raise RuntimeError()"
        ]
    },
    {
        "func_name": "process_thread",
        "original": "def process_thread(thread: list[ExportMessageNode]):\n    if mode == 'sft':\n        assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n        conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n        return DatasetEntrySft(conversation=conversation)\n    elif mode == 'rm':\n        prefix = [m.text for m in thread]\n        replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n        replies = sorted(replies, key=lambda r: r.rank)\n        replies = [r.text for r in replies]\n        return (prefix, replies)\n    elif mode == 'rl':\n        return ([m.text for m in thread],)\n    raise RuntimeError()",
        "mutated": [
            "def process_thread(thread: list[ExportMessageNode]):\n    if False:\n        i = 10\n    if mode == 'sft':\n        assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n        conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n        return DatasetEntrySft(conversation=conversation)\n    elif mode == 'rm':\n        prefix = [m.text for m in thread]\n        replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n        replies = sorted(replies, key=lambda r: r.rank)\n        replies = [r.text for r in replies]\n        return (prefix, replies)\n    elif mode == 'rl':\n        return ([m.text for m in thread],)\n    raise RuntimeError()",
            "def process_thread(thread: list[ExportMessageNode]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if mode == 'sft':\n        assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n        conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n        return DatasetEntrySft(conversation=conversation)\n    elif mode == 'rm':\n        prefix = [m.text for m in thread]\n        replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n        replies = sorted(replies, key=lambda r: r.rank)\n        replies = [r.text for r in replies]\n        return (prefix, replies)\n    elif mode == 'rl':\n        return ([m.text for m in thread],)\n    raise RuntimeError()",
            "def process_thread(thread: list[ExportMessageNode]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if mode == 'sft':\n        assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n        conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n        return DatasetEntrySft(conversation=conversation)\n    elif mode == 'rm':\n        prefix = [m.text for m in thread]\n        replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n        replies = sorted(replies, key=lambda r: r.rank)\n        replies = [r.text for r in replies]\n        return (prefix, replies)\n    elif mode == 'rl':\n        return ([m.text for m in thread],)\n    raise RuntimeError()",
            "def process_thread(thread: list[ExportMessageNode]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if mode == 'sft':\n        assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n        conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n        return DatasetEntrySft(conversation=conversation)\n    elif mode == 'rm':\n        prefix = [m.text for m in thread]\n        replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n        replies = sorted(replies, key=lambda r: r.rank)\n        replies = [r.text for r in replies]\n        return (prefix, replies)\n    elif mode == 'rl':\n        return ([m.text for m in thread],)\n    raise RuntimeError()",
            "def process_thread(thread: list[ExportMessageNode]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if mode == 'sft':\n        assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n        conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n        return DatasetEntrySft(conversation=conversation)\n    elif mode == 'rm':\n        prefix = [m.text for m in thread]\n        replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n        replies = sorted(replies, key=lambda r: r.rank)\n        replies = [r.text for r in replies]\n        return (prefix, replies)\n    elif mode == 'rl':\n        return ([m.text for m in thread],)\n    raise RuntimeError()"
        ]
    },
    {
        "func_name": "flatten",
        "original": "def flatten(ds: ListDataset) -> ListDataset:\n    return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])",
        "mutated": [
            "def flatten(ds: ListDataset) -> ListDataset:\n    if False:\n        i = 10\n    return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])",
            "def flatten(ds: ListDataset) -> ListDataset:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])",
            "def flatten(ds: ListDataset) -> ListDataset:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])",
            "def flatten(ds: ListDataset) -> ListDataset:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])",
            "def flatten(ds: ListDataset) -> ListDataset:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])"
        ]
    },
    {
        "func_name": "load_oasst_export",
        "original": "def load_oasst_export(input_file_path: Optional[str | Path]=None, hf_dataset_name: Optional[str]='OpenAssistant/oasst1', val_split: float=0.2, lang: str='en', top_k: Optional[int]=None, manual_seed: int=287631038922, data_path: str | Path=None, mode: Literal['sft', 'rm', 'rl']='sft') -> tuple[ListDataset, ListDataset]:\n    if mode not in ('sft', 'rm', 'rl'):\n        raise ValueError(f'Unknown dataset mode: {mode}')\n    lang_codes: list[str] = lang.split(',')\n    generator = Generator()\n    generator.manual_seed(manual_seed)\n    tree_iter: Iterable[ExportMessageTree] = None\n    if input_file_path:\n        if not isinstance(input_file_path, Path):\n            input_file_path = Path(input_file_path)\n        if not input_file_path.is_absolute() and data_path:\n            if not isinstance(data_path, Path):\n                data_path = Path(data_path)\n            input_file_path = data_path / input_file_path\n        tree_iter = read_message_trees(input_file_path)\n    elif hf_dataset_name:\n        tree_iter = read_dataset_message_trees(hf_dataset_name, split='train+validation')\n    else:\n        raise RuntimeError('Either `input_file_path` or `hf_dataset_name` must be specified.')\n    threads_per_tree = []\n    for tree in tree_iter:\n        if tree.tree_state != 'ready_for_export' or not tree.prompt.review_result or tree.prompt.lang not in lang_codes:\n            continue\n        if mode in ('sft', 'rm'):\n            if tree.tree_state != 'ready_for_export':\n                continue\n        elif mode == 'rl':\n            if tree.tree_state not in ('ready_for_export', 'prompt_lottery_waiting'):\n                continue\n        threads: list[list[ExportMessageNode]] = []\n\n        def thread_filter(thread: list[ExportMessageNode]) -> bool:\n            if any((m.deleted or m.synthetic for m in thread)):\n                return False\n            if top_k is not None:\n                for (i, m) in enumerate(thread):\n                    if m.role == 'assistant':\n                        if m.rank is None:\n                            if i > 0 and len(thread[i - 1].replies) > 1:\n                                return False\n                        elif m.rank >= top_k:\n                            return False\n            return True\n\n        def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n            if mode == 'sft':\n                return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n            elif mode == 'rm':\n                if thread[-1].replies is None:\n                    return False\n                return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n            elif mode == 'rl':\n                return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n            raise RuntimeError()\n        visit_threads_depth_first(tree.prompt, visitor=threads.append, predicate=leaf_filter)\n        if mode == 'sft':\n            for t in threads:\n                if t[-1].role == 'prompter':\n                    t.pop()\n        threads_per_tree.append(threads)\n\n    def process_thread(thread: list[ExportMessageNode]):\n        if mode == 'sft':\n            assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n            conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n            return DatasetEntrySft(conversation=conversation)\n        elif mode == 'rm':\n            prefix = [m.text for m in thread]\n            replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n            replies = sorted(replies, key=lambda r: r.rank)\n            replies = [r.text for r in replies]\n            return (prefix, replies)\n        elif mode == 'rl':\n            return ([m.text for m in thread],)\n        raise RuntimeError()\n    trees = ListDataset(threads_per_tree)\n    splits = random_split(trees, lengths=[1.0 - val_split, val_split], generator=generator)\n\n    def flatten(ds: ListDataset) -> ListDataset:\n        return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])\n    train = flatten(splits[0])\n    val = flatten(splits[1])\n    if input_file_path:\n        print(f'OASST JSONL file {str(input_file_path)}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    else:\n        print(f'OASST HF dataset {hf_dataset_name}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    return (train, val)",
        "mutated": [
            "def load_oasst_export(input_file_path: Optional[str | Path]=None, hf_dataset_name: Optional[str]='OpenAssistant/oasst1', val_split: float=0.2, lang: str='en', top_k: Optional[int]=None, manual_seed: int=287631038922, data_path: str | Path=None, mode: Literal['sft', 'rm', 'rl']='sft') -> tuple[ListDataset, ListDataset]:\n    if False:\n        i = 10\n    if mode not in ('sft', 'rm', 'rl'):\n        raise ValueError(f'Unknown dataset mode: {mode}')\n    lang_codes: list[str] = lang.split(',')\n    generator = Generator()\n    generator.manual_seed(manual_seed)\n    tree_iter: Iterable[ExportMessageTree] = None\n    if input_file_path:\n        if not isinstance(input_file_path, Path):\n            input_file_path = Path(input_file_path)\n        if not input_file_path.is_absolute() and data_path:\n            if not isinstance(data_path, Path):\n                data_path = Path(data_path)\n            input_file_path = data_path / input_file_path\n        tree_iter = read_message_trees(input_file_path)\n    elif hf_dataset_name:\n        tree_iter = read_dataset_message_trees(hf_dataset_name, split='train+validation')\n    else:\n        raise RuntimeError('Either `input_file_path` or `hf_dataset_name` must be specified.')\n    threads_per_tree = []\n    for tree in tree_iter:\n        if tree.tree_state != 'ready_for_export' or not tree.prompt.review_result or tree.prompt.lang not in lang_codes:\n            continue\n        if mode in ('sft', 'rm'):\n            if tree.tree_state != 'ready_for_export':\n                continue\n        elif mode == 'rl':\n            if tree.tree_state not in ('ready_for_export', 'prompt_lottery_waiting'):\n                continue\n        threads: list[list[ExportMessageNode]] = []\n\n        def thread_filter(thread: list[ExportMessageNode]) -> bool:\n            if any((m.deleted or m.synthetic for m in thread)):\n                return False\n            if top_k is not None:\n                for (i, m) in enumerate(thread):\n                    if m.role == 'assistant':\n                        if m.rank is None:\n                            if i > 0 and len(thread[i - 1].replies) > 1:\n                                return False\n                        elif m.rank >= top_k:\n                            return False\n            return True\n\n        def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n            if mode == 'sft':\n                return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n            elif mode == 'rm':\n                if thread[-1].replies is None:\n                    return False\n                return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n            elif mode == 'rl':\n                return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n            raise RuntimeError()\n        visit_threads_depth_first(tree.prompt, visitor=threads.append, predicate=leaf_filter)\n        if mode == 'sft':\n            for t in threads:\n                if t[-1].role == 'prompter':\n                    t.pop()\n        threads_per_tree.append(threads)\n\n    def process_thread(thread: list[ExportMessageNode]):\n        if mode == 'sft':\n            assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n            conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n            return DatasetEntrySft(conversation=conversation)\n        elif mode == 'rm':\n            prefix = [m.text for m in thread]\n            replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n            replies = sorted(replies, key=lambda r: r.rank)\n            replies = [r.text for r in replies]\n            return (prefix, replies)\n        elif mode == 'rl':\n            return ([m.text for m in thread],)\n        raise RuntimeError()\n    trees = ListDataset(threads_per_tree)\n    splits = random_split(trees, lengths=[1.0 - val_split, val_split], generator=generator)\n\n    def flatten(ds: ListDataset) -> ListDataset:\n        return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])\n    train = flatten(splits[0])\n    val = flatten(splits[1])\n    if input_file_path:\n        print(f'OASST JSONL file {str(input_file_path)}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    else:\n        print(f'OASST HF dataset {hf_dataset_name}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    return (train, val)",
            "def load_oasst_export(input_file_path: Optional[str | Path]=None, hf_dataset_name: Optional[str]='OpenAssistant/oasst1', val_split: float=0.2, lang: str='en', top_k: Optional[int]=None, manual_seed: int=287631038922, data_path: str | Path=None, mode: Literal['sft', 'rm', 'rl']='sft') -> tuple[ListDataset, ListDataset]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if mode not in ('sft', 'rm', 'rl'):\n        raise ValueError(f'Unknown dataset mode: {mode}')\n    lang_codes: list[str] = lang.split(',')\n    generator = Generator()\n    generator.manual_seed(manual_seed)\n    tree_iter: Iterable[ExportMessageTree] = None\n    if input_file_path:\n        if not isinstance(input_file_path, Path):\n            input_file_path = Path(input_file_path)\n        if not input_file_path.is_absolute() and data_path:\n            if not isinstance(data_path, Path):\n                data_path = Path(data_path)\n            input_file_path = data_path / input_file_path\n        tree_iter = read_message_trees(input_file_path)\n    elif hf_dataset_name:\n        tree_iter = read_dataset_message_trees(hf_dataset_name, split='train+validation')\n    else:\n        raise RuntimeError('Either `input_file_path` or `hf_dataset_name` must be specified.')\n    threads_per_tree = []\n    for tree in tree_iter:\n        if tree.tree_state != 'ready_for_export' or not tree.prompt.review_result or tree.prompt.lang not in lang_codes:\n            continue\n        if mode in ('sft', 'rm'):\n            if tree.tree_state != 'ready_for_export':\n                continue\n        elif mode == 'rl':\n            if tree.tree_state not in ('ready_for_export', 'prompt_lottery_waiting'):\n                continue\n        threads: list[list[ExportMessageNode]] = []\n\n        def thread_filter(thread: list[ExportMessageNode]) -> bool:\n            if any((m.deleted or m.synthetic for m in thread)):\n                return False\n            if top_k is not None:\n                for (i, m) in enumerate(thread):\n                    if m.role == 'assistant':\n                        if m.rank is None:\n                            if i > 0 and len(thread[i - 1].replies) > 1:\n                                return False\n                        elif m.rank >= top_k:\n                            return False\n            return True\n\n        def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n            if mode == 'sft':\n                return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n            elif mode == 'rm':\n                if thread[-1].replies is None:\n                    return False\n                return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n            elif mode == 'rl':\n                return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n            raise RuntimeError()\n        visit_threads_depth_first(tree.prompt, visitor=threads.append, predicate=leaf_filter)\n        if mode == 'sft':\n            for t in threads:\n                if t[-1].role == 'prompter':\n                    t.pop()\n        threads_per_tree.append(threads)\n\n    def process_thread(thread: list[ExportMessageNode]):\n        if mode == 'sft':\n            assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n            conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n            return DatasetEntrySft(conversation=conversation)\n        elif mode == 'rm':\n            prefix = [m.text for m in thread]\n            replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n            replies = sorted(replies, key=lambda r: r.rank)\n            replies = [r.text for r in replies]\n            return (prefix, replies)\n        elif mode == 'rl':\n            return ([m.text for m in thread],)\n        raise RuntimeError()\n    trees = ListDataset(threads_per_tree)\n    splits = random_split(trees, lengths=[1.0 - val_split, val_split], generator=generator)\n\n    def flatten(ds: ListDataset) -> ListDataset:\n        return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])\n    train = flatten(splits[0])\n    val = flatten(splits[1])\n    if input_file_path:\n        print(f'OASST JSONL file {str(input_file_path)}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    else:\n        print(f'OASST HF dataset {hf_dataset_name}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    return (train, val)",
            "def load_oasst_export(input_file_path: Optional[str | Path]=None, hf_dataset_name: Optional[str]='OpenAssistant/oasst1', val_split: float=0.2, lang: str='en', top_k: Optional[int]=None, manual_seed: int=287631038922, data_path: str | Path=None, mode: Literal['sft', 'rm', 'rl']='sft') -> tuple[ListDataset, ListDataset]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if mode not in ('sft', 'rm', 'rl'):\n        raise ValueError(f'Unknown dataset mode: {mode}')\n    lang_codes: list[str] = lang.split(',')\n    generator = Generator()\n    generator.manual_seed(manual_seed)\n    tree_iter: Iterable[ExportMessageTree] = None\n    if input_file_path:\n        if not isinstance(input_file_path, Path):\n            input_file_path = Path(input_file_path)\n        if not input_file_path.is_absolute() and data_path:\n            if not isinstance(data_path, Path):\n                data_path = Path(data_path)\n            input_file_path = data_path / input_file_path\n        tree_iter = read_message_trees(input_file_path)\n    elif hf_dataset_name:\n        tree_iter = read_dataset_message_trees(hf_dataset_name, split='train+validation')\n    else:\n        raise RuntimeError('Either `input_file_path` or `hf_dataset_name` must be specified.')\n    threads_per_tree = []\n    for tree in tree_iter:\n        if tree.tree_state != 'ready_for_export' or not tree.prompt.review_result or tree.prompt.lang not in lang_codes:\n            continue\n        if mode in ('sft', 'rm'):\n            if tree.tree_state != 'ready_for_export':\n                continue\n        elif mode == 'rl':\n            if tree.tree_state not in ('ready_for_export', 'prompt_lottery_waiting'):\n                continue\n        threads: list[list[ExportMessageNode]] = []\n\n        def thread_filter(thread: list[ExportMessageNode]) -> bool:\n            if any((m.deleted or m.synthetic for m in thread)):\n                return False\n            if top_k is not None:\n                for (i, m) in enumerate(thread):\n                    if m.role == 'assistant':\n                        if m.rank is None:\n                            if i > 0 and len(thread[i - 1].replies) > 1:\n                                return False\n                        elif m.rank >= top_k:\n                            return False\n            return True\n\n        def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n            if mode == 'sft':\n                return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n            elif mode == 'rm':\n                if thread[-1].replies is None:\n                    return False\n                return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n            elif mode == 'rl':\n                return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n            raise RuntimeError()\n        visit_threads_depth_first(tree.prompt, visitor=threads.append, predicate=leaf_filter)\n        if mode == 'sft':\n            for t in threads:\n                if t[-1].role == 'prompter':\n                    t.pop()\n        threads_per_tree.append(threads)\n\n    def process_thread(thread: list[ExportMessageNode]):\n        if mode == 'sft':\n            assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n            conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n            return DatasetEntrySft(conversation=conversation)\n        elif mode == 'rm':\n            prefix = [m.text for m in thread]\n            replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n            replies = sorted(replies, key=lambda r: r.rank)\n            replies = [r.text for r in replies]\n            return (prefix, replies)\n        elif mode == 'rl':\n            return ([m.text for m in thread],)\n        raise RuntimeError()\n    trees = ListDataset(threads_per_tree)\n    splits = random_split(trees, lengths=[1.0 - val_split, val_split], generator=generator)\n\n    def flatten(ds: ListDataset) -> ListDataset:\n        return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])\n    train = flatten(splits[0])\n    val = flatten(splits[1])\n    if input_file_path:\n        print(f'OASST JSONL file {str(input_file_path)}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    else:\n        print(f'OASST HF dataset {hf_dataset_name}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    return (train, val)",
            "def load_oasst_export(input_file_path: Optional[str | Path]=None, hf_dataset_name: Optional[str]='OpenAssistant/oasst1', val_split: float=0.2, lang: str='en', top_k: Optional[int]=None, manual_seed: int=287631038922, data_path: str | Path=None, mode: Literal['sft', 'rm', 'rl']='sft') -> tuple[ListDataset, ListDataset]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if mode not in ('sft', 'rm', 'rl'):\n        raise ValueError(f'Unknown dataset mode: {mode}')\n    lang_codes: list[str] = lang.split(',')\n    generator = Generator()\n    generator.manual_seed(manual_seed)\n    tree_iter: Iterable[ExportMessageTree] = None\n    if input_file_path:\n        if not isinstance(input_file_path, Path):\n            input_file_path = Path(input_file_path)\n        if not input_file_path.is_absolute() and data_path:\n            if not isinstance(data_path, Path):\n                data_path = Path(data_path)\n            input_file_path = data_path / input_file_path\n        tree_iter = read_message_trees(input_file_path)\n    elif hf_dataset_name:\n        tree_iter = read_dataset_message_trees(hf_dataset_name, split='train+validation')\n    else:\n        raise RuntimeError('Either `input_file_path` or `hf_dataset_name` must be specified.')\n    threads_per_tree = []\n    for tree in tree_iter:\n        if tree.tree_state != 'ready_for_export' or not tree.prompt.review_result or tree.prompt.lang not in lang_codes:\n            continue\n        if mode in ('sft', 'rm'):\n            if tree.tree_state != 'ready_for_export':\n                continue\n        elif mode == 'rl':\n            if tree.tree_state not in ('ready_for_export', 'prompt_lottery_waiting'):\n                continue\n        threads: list[list[ExportMessageNode]] = []\n\n        def thread_filter(thread: list[ExportMessageNode]) -> bool:\n            if any((m.deleted or m.synthetic for m in thread)):\n                return False\n            if top_k is not None:\n                for (i, m) in enumerate(thread):\n                    if m.role == 'assistant':\n                        if m.rank is None:\n                            if i > 0 and len(thread[i - 1].replies) > 1:\n                                return False\n                        elif m.rank >= top_k:\n                            return False\n            return True\n\n        def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n            if mode == 'sft':\n                return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n            elif mode == 'rm':\n                if thread[-1].replies is None:\n                    return False\n                return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n            elif mode == 'rl':\n                return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n            raise RuntimeError()\n        visit_threads_depth_first(tree.prompt, visitor=threads.append, predicate=leaf_filter)\n        if mode == 'sft':\n            for t in threads:\n                if t[-1].role == 'prompter':\n                    t.pop()\n        threads_per_tree.append(threads)\n\n    def process_thread(thread: list[ExportMessageNode]):\n        if mode == 'sft':\n            assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n            conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n            return DatasetEntrySft(conversation=conversation)\n        elif mode == 'rm':\n            prefix = [m.text for m in thread]\n            replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n            replies = sorted(replies, key=lambda r: r.rank)\n            replies = [r.text for r in replies]\n            return (prefix, replies)\n        elif mode == 'rl':\n            return ([m.text for m in thread],)\n        raise RuntimeError()\n    trees = ListDataset(threads_per_tree)\n    splits = random_split(trees, lengths=[1.0 - val_split, val_split], generator=generator)\n\n    def flatten(ds: ListDataset) -> ListDataset:\n        return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])\n    train = flatten(splits[0])\n    val = flatten(splits[1])\n    if input_file_path:\n        print(f'OASST JSONL file {str(input_file_path)}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    else:\n        print(f'OASST HF dataset {hf_dataset_name}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    return (train, val)",
            "def load_oasst_export(input_file_path: Optional[str | Path]=None, hf_dataset_name: Optional[str]='OpenAssistant/oasst1', val_split: float=0.2, lang: str='en', top_k: Optional[int]=None, manual_seed: int=287631038922, data_path: str | Path=None, mode: Literal['sft', 'rm', 'rl']='sft') -> tuple[ListDataset, ListDataset]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if mode not in ('sft', 'rm', 'rl'):\n        raise ValueError(f'Unknown dataset mode: {mode}')\n    lang_codes: list[str] = lang.split(',')\n    generator = Generator()\n    generator.manual_seed(manual_seed)\n    tree_iter: Iterable[ExportMessageTree] = None\n    if input_file_path:\n        if not isinstance(input_file_path, Path):\n            input_file_path = Path(input_file_path)\n        if not input_file_path.is_absolute() and data_path:\n            if not isinstance(data_path, Path):\n                data_path = Path(data_path)\n            input_file_path = data_path / input_file_path\n        tree_iter = read_message_trees(input_file_path)\n    elif hf_dataset_name:\n        tree_iter = read_dataset_message_trees(hf_dataset_name, split='train+validation')\n    else:\n        raise RuntimeError('Either `input_file_path` or `hf_dataset_name` must be specified.')\n    threads_per_tree = []\n    for tree in tree_iter:\n        if tree.tree_state != 'ready_for_export' or not tree.prompt.review_result or tree.prompt.lang not in lang_codes:\n            continue\n        if mode in ('sft', 'rm'):\n            if tree.tree_state != 'ready_for_export':\n                continue\n        elif mode == 'rl':\n            if tree.tree_state not in ('ready_for_export', 'prompt_lottery_waiting'):\n                continue\n        threads: list[list[ExportMessageNode]] = []\n\n        def thread_filter(thread: list[ExportMessageNode]) -> bool:\n            if any((m.deleted or m.synthetic for m in thread)):\n                return False\n            if top_k is not None:\n                for (i, m) in enumerate(thread):\n                    if m.role == 'assistant':\n                        if m.rank is None:\n                            if i > 0 and len(thread[i - 1].replies) > 1:\n                                return False\n                        elif m.rank >= top_k:\n                            return False\n            return True\n\n        def leaf_filter(thread: list[ExportMessageNode]) -> bool:\n            if mode == 'sft':\n                return len(thread) > 1 and (not thread[-1].replies) and (thread[-1].role == 'assistant' or thread[-2].replies[0] == thread[-1]) and thread_filter(thread)\n            elif mode == 'rm':\n                if thread[-1].replies is None:\n                    return False\n                return thread[-1].role == 'prompter' and len([r for r in thread[-1].replies if r.rank is not None]) > 1 and thread_filter(thread)\n            elif mode == 'rl':\n                return thread[-1].role == 'prompter' and (not any((m.deleted or m.synthetic for m in thread)))\n            raise RuntimeError()\n        visit_threads_depth_first(tree.prompt, visitor=threads.append, predicate=leaf_filter)\n        if mode == 'sft':\n            for t in threads:\n                if t[-1].role == 'prompter':\n                    t.pop()\n        threads_per_tree.append(threads)\n\n    def process_thread(thread: list[ExportMessageNode]):\n        if mode == 'sft':\n            assert all((m.role == 'prompter' for m in thread[0::2])) and all((m.role == 'assistant' for m in thread[1::2]))\n            conversation: list[Utterance] = [Utterance(text=m.text, role=Role.prompter if m.role == 'prompter' else Role.assistant, lang=m.lang, quality=m.get_label_value('quality'), humor=m.get_label_value('humor'), creativity=m.get_label_value('creativity')) for m in thread]\n            return DatasetEntrySft(conversation=conversation)\n        elif mode == 'rm':\n            prefix = [m.text for m in thread]\n            replies = [r for r in thread[-1].replies if r.role == 'assistant' and r.rank is not None]\n            replies = sorted(replies, key=lambda r: r.rank)\n            replies = [r.text for r in replies]\n            return (prefix, replies)\n        elif mode == 'rl':\n            return ([m.text for m in thread],)\n        raise RuntimeError()\n    trees = ListDataset(threads_per_tree)\n    splits = random_split(trees, lengths=[1.0 - val_split, val_split], generator=generator)\n\n    def flatten(ds: ListDataset) -> ListDataset:\n        return ListDataset([process_thread(thread) for tree_threads in ds for thread in tree_threads])\n    train = flatten(splits[0])\n    val = flatten(splits[1])\n    if input_file_path:\n        print(f'OASST JSONL file {str(input_file_path)}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    else:\n        print(f'OASST HF dataset {hf_dataset_name}: len(train)={len(train)!r}, len(val)={len(val)!r}')\n    return (train, val)"
        ]
    }
]