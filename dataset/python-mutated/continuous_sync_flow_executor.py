"""SyncFlowExecutor that will run continuously until stop is called."""
import logging
import time
from concurrent.futures.thread import ThreadPoolExecutor
from dataclasses import dataclass
from typing import Callable, Optional
from samcli.lib.sync.exceptions import SyncFlowException
from samcli.lib.sync.sync_flow import SyncFlow
from samcli.lib.sync.sync_flow_executor import SyncFlowExecutor, SyncFlowFuture, SyncFlowTask, default_exception_handler
LOG = logging.getLogger(__name__)

@dataclass(frozen=True, eq=True)
class DelayedSyncFlowTask(SyncFlowTask):
    """Data struct for individual SyncFlow execution tasks"""
    queue_time: float
    wait_time: float

class ContinuousSyncFlowExecutor(SyncFlowExecutor):
    """SyncFlowExecutor that continuously runs and executes SyncFlows.
    Call stop() to stop the executor"""
    _stop_flag: bool

    def __init__(self) -> None:
        if False:
            return 10
        super().__init__()
        self._stop_flag = False

    def stop(self, should_stop=True) -> None:
        if False:
            print('Hello World!')
        'Stop executor after all current SyncFlows are finished.'
        with self._flow_queue_lock:
            self._stop_flag = should_stop
            if should_stop:
                self._flow_queue.queue.clear()

    def should_stop(self) -> bool:
        if False:
            i = 10
            return i + 15
        '\n        Returns\n        -------\n        bool\n            Should executor stop execution on the next available time.\n        '
        return self._stop_flag

    def _can_exit(self):
        if False:
            print('Hello World!')
        return self.should_stop() and super()._can_exit()

    def _submit_sync_flow_task(self, executor: ThreadPoolExecutor, sync_flow_task: SyncFlowTask) -> Optional[SyncFlowFuture]:
        if False:
            i = 10
            return i + 15
        'Submit SyncFlowTask to be executed by ThreadPoolExecutor\n        and return its future\n        Adds additional time checks for DelayedSyncFlowTask\n\n        Parameters\n        ----------\n        executor : ThreadPoolExecutor\n            THreadPoolExecutor to be used for execution\n        sync_flow_task : SyncFlowTask\n            SyncFlowTask to be executed.\n\n        Returns\n        -------\n        Optional[SyncFlowFuture]\n            Returns SyncFlowFuture generated by the SyncFlowTask.\n            Can be None if the task cannot be executed yet.\n        '
        if isinstance(sync_flow_task, DelayedSyncFlowTask) and sync_flow_task.wait_time + sync_flow_task.queue_time > time.time():
            return None
        return super()._submit_sync_flow_task(executor, sync_flow_task)

    def _add_sync_flow_task(self, task: SyncFlowTask) -> None:
        if False:
            while True:
                i = 10
        'Add SyncFlowTask to the queue\n        Skips if the executor is in the state of being shut down.\n\n        Parameters\n        ----------\n        task : SyncFlowTask\n            SyncFlowTask to be added.\n        '
        if self.should_stop():
            LOG.debug('%s is skipped from queueing as executor is in the process of stopping.', task.sync_flow.log_prefix)
            return
        super()._add_sync_flow_task(task)

    def add_delayed_sync_flow(self, sync_flow: SyncFlow, dedup: bool=True, wait_time: float=0) -> None:
        if False:
            for i in range(10):
                print('nop')
        'Add a SyncFlow to queue to be executed\n        Locks will be set with LockDistributor\n\n        Parameters\n        ----------\n        sync_flow : SyncFlow\n            SyncFlow to be executed\n        dedup : bool\n            SyncFlow will not be added if this flag is True and has a duplicate in the queue\n        wait_time : float\n            Minimum number of seconds before SyncFlow executes\n        '
        self._add_sync_flow_task(DelayedSyncFlowTask(sync_flow, dedup, time.time(), wait_time))

    def execute(self, exception_handler: Optional[Callable[[SyncFlowException], None]]=default_exception_handler) -> None:
        if False:
            print('Hello World!')
        'Blocking continuous execution of the SyncFlows\n\n        Parameters\n        ----------\n        exception_handler : Optional[Callable[[Exception], None]], optional\n            Function to be called if an exception is raised during the execution of a SyncFlow,\n            by default default_exception_handler.__func__\n        '
        super().execute(exception_handler=exception_handler)
        self.stop(should_stop=False)