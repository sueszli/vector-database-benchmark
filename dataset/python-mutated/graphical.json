[
    {
        "func_name": "is_graphical",
        "original": "@nx._dispatch(graphs=None)\ndef is_graphical(sequence, method='eg'):\n    \"\"\"Returns True if sequence is a valid degree sequence.\n\n    A degree sequence is valid if some graph can realize it.\n\n    Parameters\n    ----------\n    sequence : list or iterable container\n        A sequence of integer node degrees\n\n    method : \"eg\" | \"hh\"  (default: 'eg')\n        The method used to validate the degree sequence.\n        \"eg\" corresponds to the Erd\u0151s-Gallai algorithm\n        [EG1960]_, [choudum1986]_, and\n        \"hh\" to the Havel-Hakimi algorithm\n        [havel1955]_, [hakimi1962]_, [CL1996]_.\n\n    Returns\n    -------\n    valid : bool\n        True if the sequence is a valid degree sequence and False if not.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> sequence = (d for n, d in G.degree())\n    >>> nx.is_graphical(sequence)\n    True\n\n    To test a non-graphical sequence:\n    >>> sequence_list = [d for n, d in G.degree()]\n    >>> sequence_list[-1] += 1\n    >>> nx.is_graphical(sequence_list)\n    False\n\n    References\n    ----------\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\n    .. [choudum1986] S.A. Choudum. \"A simple proof of the Erd\u0151s-Gallai theorem on\n       graph sequences.\" Bulletin of the Australian Mathematical Society, 33,\n       pp 67-70, 1986. https://doi.org/10.1017/S0004972700002872\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\n       Casopis Pest. Mat. 80, 477-480, 1955.\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\n       Chapman and Hall/CRC, 1996.\n    \"\"\"\n    if method == 'eg':\n        valid = is_valid_degree_sequence_erdos_gallai(list(sequence))\n    elif method == 'hh':\n        valid = is_valid_degree_sequence_havel_hakimi(list(sequence))\n    else:\n        msg = \"`method` must be 'eg' or 'hh'\"\n        raise nx.NetworkXException(msg)\n    return valid",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef is_graphical(sequence, method='eg'):\n    if False:\n        i = 10\n    'Returns True if sequence is a valid degree sequence.\\n\\n    A degree sequence is valid if some graph can realize it.\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    method : \"eg\" | \"hh\"  (default: \\'eg\\')\\n        The method used to validate the degree sequence.\\n        \"eg\" corresponds to the Erd\u0151s-Gallai algorithm\\n        [EG1960]_, [choudum1986]_, and\\n        \"hh\" to the Havel-Hakimi algorithm\\n        [havel1955]_, [hakimi1962]_, [CL1996]_.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if the sequence is a valid degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> sequence = (d for n, d in G.degree())\\n    >>> nx.is_graphical(sequence)\\n    True\\n\\n    To test a non-graphical sequence:\\n    >>> sequence_list = [d for n, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_graphical(sequence_list)\\n    False\\n\\n    References\\n    ----------\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    .. [choudum1986] S.A. Choudum. \"A simple proof of the Erd\u0151s-Gallai theorem on\\n       graph sequences.\" Bulletin of the Australian Mathematical Society, 33,\\n       pp 67-70, 1986. https://doi.org/10.1017/S0004972700002872\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    if method == 'eg':\n        valid = is_valid_degree_sequence_erdos_gallai(list(sequence))\n    elif method == 'hh':\n        valid = is_valid_degree_sequence_havel_hakimi(list(sequence))\n    else:\n        msg = \"`method` must be 'eg' or 'hh'\"\n        raise nx.NetworkXException(msg)\n    return valid",
            "@nx._dispatch(graphs=None)\ndef is_graphical(sequence, method='eg'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if sequence is a valid degree sequence.\\n\\n    A degree sequence is valid if some graph can realize it.\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    method : \"eg\" | \"hh\"  (default: \\'eg\\')\\n        The method used to validate the degree sequence.\\n        \"eg\" corresponds to the Erd\u0151s-Gallai algorithm\\n        [EG1960]_, [choudum1986]_, and\\n        \"hh\" to the Havel-Hakimi algorithm\\n        [havel1955]_, [hakimi1962]_, [CL1996]_.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if the sequence is a valid degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> sequence = (d for n, d in G.degree())\\n    >>> nx.is_graphical(sequence)\\n    True\\n\\n    To test a non-graphical sequence:\\n    >>> sequence_list = [d for n, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_graphical(sequence_list)\\n    False\\n\\n    References\\n    ----------\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    .. [choudum1986] S.A. Choudum. \"A simple proof of the Erd\u0151s-Gallai theorem on\\n       graph sequences.\" Bulletin of the Australian Mathematical Society, 33,\\n       pp 67-70, 1986. https://doi.org/10.1017/S0004972700002872\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    if method == 'eg':\n        valid = is_valid_degree_sequence_erdos_gallai(list(sequence))\n    elif method == 'hh':\n        valid = is_valid_degree_sequence_havel_hakimi(list(sequence))\n    else:\n        msg = \"`method` must be 'eg' or 'hh'\"\n        raise nx.NetworkXException(msg)\n    return valid",
            "@nx._dispatch(graphs=None)\ndef is_graphical(sequence, method='eg'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if sequence is a valid degree sequence.\\n\\n    A degree sequence is valid if some graph can realize it.\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    method : \"eg\" | \"hh\"  (default: \\'eg\\')\\n        The method used to validate the degree sequence.\\n        \"eg\" corresponds to the Erd\u0151s-Gallai algorithm\\n        [EG1960]_, [choudum1986]_, and\\n        \"hh\" to the Havel-Hakimi algorithm\\n        [havel1955]_, [hakimi1962]_, [CL1996]_.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if the sequence is a valid degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> sequence = (d for n, d in G.degree())\\n    >>> nx.is_graphical(sequence)\\n    True\\n\\n    To test a non-graphical sequence:\\n    >>> sequence_list = [d for n, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_graphical(sequence_list)\\n    False\\n\\n    References\\n    ----------\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    .. [choudum1986] S.A. Choudum. \"A simple proof of the Erd\u0151s-Gallai theorem on\\n       graph sequences.\" Bulletin of the Australian Mathematical Society, 33,\\n       pp 67-70, 1986. https://doi.org/10.1017/S0004972700002872\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    if method == 'eg':\n        valid = is_valid_degree_sequence_erdos_gallai(list(sequence))\n    elif method == 'hh':\n        valid = is_valid_degree_sequence_havel_hakimi(list(sequence))\n    else:\n        msg = \"`method` must be 'eg' or 'hh'\"\n        raise nx.NetworkXException(msg)\n    return valid",
            "@nx._dispatch(graphs=None)\ndef is_graphical(sequence, method='eg'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if sequence is a valid degree sequence.\\n\\n    A degree sequence is valid if some graph can realize it.\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    method : \"eg\" | \"hh\"  (default: \\'eg\\')\\n        The method used to validate the degree sequence.\\n        \"eg\" corresponds to the Erd\u0151s-Gallai algorithm\\n        [EG1960]_, [choudum1986]_, and\\n        \"hh\" to the Havel-Hakimi algorithm\\n        [havel1955]_, [hakimi1962]_, [CL1996]_.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if the sequence is a valid degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> sequence = (d for n, d in G.degree())\\n    >>> nx.is_graphical(sequence)\\n    True\\n\\n    To test a non-graphical sequence:\\n    >>> sequence_list = [d for n, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_graphical(sequence_list)\\n    False\\n\\n    References\\n    ----------\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    .. [choudum1986] S.A. Choudum. \"A simple proof of the Erd\u0151s-Gallai theorem on\\n       graph sequences.\" Bulletin of the Australian Mathematical Society, 33,\\n       pp 67-70, 1986. https://doi.org/10.1017/S0004972700002872\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    if method == 'eg':\n        valid = is_valid_degree_sequence_erdos_gallai(list(sequence))\n    elif method == 'hh':\n        valid = is_valid_degree_sequence_havel_hakimi(list(sequence))\n    else:\n        msg = \"`method` must be 'eg' or 'hh'\"\n        raise nx.NetworkXException(msg)\n    return valid",
            "@nx._dispatch(graphs=None)\ndef is_graphical(sequence, method='eg'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if sequence is a valid degree sequence.\\n\\n    A degree sequence is valid if some graph can realize it.\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    method : \"eg\" | \"hh\"  (default: \\'eg\\')\\n        The method used to validate the degree sequence.\\n        \"eg\" corresponds to the Erd\u0151s-Gallai algorithm\\n        [EG1960]_, [choudum1986]_, and\\n        \"hh\" to the Havel-Hakimi algorithm\\n        [havel1955]_, [hakimi1962]_, [CL1996]_.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if the sequence is a valid degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> sequence = (d for n, d in G.degree())\\n    >>> nx.is_graphical(sequence)\\n    True\\n\\n    To test a non-graphical sequence:\\n    >>> sequence_list = [d for n, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_graphical(sequence_list)\\n    False\\n\\n    References\\n    ----------\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    .. [choudum1986] S.A. Choudum. \"A simple proof of the Erd\u0151s-Gallai theorem on\\n       graph sequences.\" Bulletin of the Australian Mathematical Society, 33,\\n       pp 67-70, 1986. https://doi.org/10.1017/S0004972700002872\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    if method == 'eg':\n        valid = is_valid_degree_sequence_erdos_gallai(list(sequence))\n    elif method == 'hh':\n        valid = is_valid_degree_sequence_havel_hakimi(list(sequence))\n    else:\n        msg = \"`method` must be 'eg' or 'hh'\"\n        raise nx.NetworkXException(msg)\n    return valid"
        ]
    },
    {
        "func_name": "_basic_graphical_tests",
        "original": "def _basic_graphical_tests(deg_sequence):\n    deg_sequence = nx.utils.make_list_of_ints(deg_sequence)\n    p = len(deg_sequence)\n    num_degs = [0] * p\n    (dmax, dmin, dsum, n) = (0, p, 0, 0)\n    for d in deg_sequence:\n        if d < 0 or d >= p:\n            raise nx.NetworkXUnfeasible\n        elif d > 0:\n            (dmax, dmin, dsum, n) = (max(dmax, d), min(dmin, d), dsum + d, n + 1)\n            num_degs[d] += 1\n    if dsum % 2 or dsum > n * (n - 1):\n        raise nx.NetworkXUnfeasible\n    return (dmax, dmin, dsum, n, num_degs)",
        "mutated": [
            "def _basic_graphical_tests(deg_sequence):\n    if False:\n        i = 10\n    deg_sequence = nx.utils.make_list_of_ints(deg_sequence)\n    p = len(deg_sequence)\n    num_degs = [0] * p\n    (dmax, dmin, dsum, n) = (0, p, 0, 0)\n    for d in deg_sequence:\n        if d < 0 or d >= p:\n            raise nx.NetworkXUnfeasible\n        elif d > 0:\n            (dmax, dmin, dsum, n) = (max(dmax, d), min(dmin, d), dsum + d, n + 1)\n            num_degs[d] += 1\n    if dsum % 2 or dsum > n * (n - 1):\n        raise nx.NetworkXUnfeasible\n    return (dmax, dmin, dsum, n, num_degs)",
            "def _basic_graphical_tests(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    deg_sequence = nx.utils.make_list_of_ints(deg_sequence)\n    p = len(deg_sequence)\n    num_degs = [0] * p\n    (dmax, dmin, dsum, n) = (0, p, 0, 0)\n    for d in deg_sequence:\n        if d < 0 or d >= p:\n            raise nx.NetworkXUnfeasible\n        elif d > 0:\n            (dmax, dmin, dsum, n) = (max(dmax, d), min(dmin, d), dsum + d, n + 1)\n            num_degs[d] += 1\n    if dsum % 2 or dsum > n * (n - 1):\n        raise nx.NetworkXUnfeasible\n    return (dmax, dmin, dsum, n, num_degs)",
            "def _basic_graphical_tests(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    deg_sequence = nx.utils.make_list_of_ints(deg_sequence)\n    p = len(deg_sequence)\n    num_degs = [0] * p\n    (dmax, dmin, dsum, n) = (0, p, 0, 0)\n    for d in deg_sequence:\n        if d < 0 or d >= p:\n            raise nx.NetworkXUnfeasible\n        elif d > 0:\n            (dmax, dmin, dsum, n) = (max(dmax, d), min(dmin, d), dsum + d, n + 1)\n            num_degs[d] += 1\n    if dsum % 2 or dsum > n * (n - 1):\n        raise nx.NetworkXUnfeasible\n    return (dmax, dmin, dsum, n, num_degs)",
            "def _basic_graphical_tests(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    deg_sequence = nx.utils.make_list_of_ints(deg_sequence)\n    p = len(deg_sequence)\n    num_degs = [0] * p\n    (dmax, dmin, dsum, n) = (0, p, 0, 0)\n    for d in deg_sequence:\n        if d < 0 or d >= p:\n            raise nx.NetworkXUnfeasible\n        elif d > 0:\n            (dmax, dmin, dsum, n) = (max(dmax, d), min(dmin, d), dsum + d, n + 1)\n            num_degs[d] += 1\n    if dsum % 2 or dsum > n * (n - 1):\n        raise nx.NetworkXUnfeasible\n    return (dmax, dmin, dsum, n, num_degs)",
            "def _basic_graphical_tests(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    deg_sequence = nx.utils.make_list_of_ints(deg_sequence)\n    p = len(deg_sequence)\n    num_degs = [0] * p\n    (dmax, dmin, dsum, n) = (0, p, 0, 0)\n    for d in deg_sequence:\n        if d < 0 or d >= p:\n            raise nx.NetworkXUnfeasible\n        elif d > 0:\n            (dmax, dmin, dsum, n) = (max(dmax, d), min(dmin, d), dsum + d, n + 1)\n            num_degs[d] += 1\n    if dsum % 2 or dsum > n * (n - 1):\n        raise nx.NetworkXUnfeasible\n    return (dmax, dmin, dsum, n, num_degs)"
        ]
    },
    {
        "func_name": "is_valid_degree_sequence_havel_hakimi",
        "original": "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_havel_hakimi(deg_sequence):\n    \"\"\"Returns True if deg_sequence can be realized by a simple graph.\n\n    The validation proceeds using the Havel-Hakimi theorem\n    [havel1955]_, [hakimi1962]_, [CL1996]_.\n    Worst-case run time is $O(s)$ where $s$ is the sum of the sequence.\n\n    Parameters\n    ----------\n    deg_sequence : list\n        A list of integers where each element specifies the degree of a node\n        in a graph.\n\n    Returns\n    -------\n    valid : bool\n        True if deg_sequence is graphical and False if not.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n    >>> sequence = (d for _, d in G.degree())\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence)\n    True\n\n    To test a non-valid sequence:\n    >>> sequence_list = [d for _, d in G.degree()]\n    >>> sequence_list[-1] += 1\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\n    False\n\n    Notes\n    -----\n    The ZZ condition says that for the sequence d if\n\n    .. math::\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\n\n    then d is graphical.  This was shown in Theorem 6 in [1]_.\n\n    References\n    ----------\n    .. [1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\n       Casopis Pest. Mat. 80, 477-480, 1955.\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\n       Chapman and Hall/CRC, 1996.\n    \"\"\"\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    modstubs = [0] * (dmax + 1)\n    while n > 0:\n        while num_degs[dmax] == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            return False\n        (num_degs[dmax], n) = (num_degs[dmax] - 1, n - 1)\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while num_degs[k] == 0:\n                k -= 1\n            (num_degs[k], n) = (num_degs[k] - 1, n - 1)\n            if k > 1:\n                modstubs[mslen] = k - 1\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            (num_degs[stub], n) = (num_degs[stub] + 1, n + 1)\n    return True",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_havel_hakimi(deg_sequence):\n    if False:\n        i = 10\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation proceeds using the Havel-Hakimi theorem\\n    [havel1955]_, [hakimi1962]_, [CL1996]_.\\n    Worst-case run time is $O(s)$ where $s$ is the sum of the sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers where each element specifies the degree of a node\\n        in a graph.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [1]_.\\n\\n    References\\n    ----------\\n    .. [1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    modstubs = [0] * (dmax + 1)\n    while n > 0:\n        while num_degs[dmax] == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            return False\n        (num_degs[dmax], n) = (num_degs[dmax] - 1, n - 1)\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while num_degs[k] == 0:\n                k -= 1\n            (num_degs[k], n) = (num_degs[k] - 1, n - 1)\n            if k > 1:\n                modstubs[mslen] = k - 1\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            (num_degs[stub], n) = (num_degs[stub] + 1, n + 1)\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_havel_hakimi(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation proceeds using the Havel-Hakimi theorem\\n    [havel1955]_, [hakimi1962]_, [CL1996]_.\\n    Worst-case run time is $O(s)$ where $s$ is the sum of the sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers where each element specifies the degree of a node\\n        in a graph.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [1]_.\\n\\n    References\\n    ----------\\n    .. [1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    modstubs = [0] * (dmax + 1)\n    while n > 0:\n        while num_degs[dmax] == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            return False\n        (num_degs[dmax], n) = (num_degs[dmax] - 1, n - 1)\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while num_degs[k] == 0:\n                k -= 1\n            (num_degs[k], n) = (num_degs[k] - 1, n - 1)\n            if k > 1:\n                modstubs[mslen] = k - 1\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            (num_degs[stub], n) = (num_degs[stub] + 1, n + 1)\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_havel_hakimi(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation proceeds using the Havel-Hakimi theorem\\n    [havel1955]_, [hakimi1962]_, [CL1996]_.\\n    Worst-case run time is $O(s)$ where $s$ is the sum of the sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers where each element specifies the degree of a node\\n        in a graph.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [1]_.\\n\\n    References\\n    ----------\\n    .. [1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    modstubs = [0] * (dmax + 1)\n    while n > 0:\n        while num_degs[dmax] == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            return False\n        (num_degs[dmax], n) = (num_degs[dmax] - 1, n - 1)\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while num_degs[k] == 0:\n                k -= 1\n            (num_degs[k], n) = (num_degs[k] - 1, n - 1)\n            if k > 1:\n                modstubs[mslen] = k - 1\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            (num_degs[stub], n) = (num_degs[stub] + 1, n + 1)\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_havel_hakimi(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation proceeds using the Havel-Hakimi theorem\\n    [havel1955]_, [hakimi1962]_, [CL1996]_.\\n    Worst-case run time is $O(s)$ where $s$ is the sum of the sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers where each element specifies the degree of a node\\n        in a graph.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [1]_.\\n\\n    References\\n    ----------\\n    .. [1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    modstubs = [0] * (dmax + 1)\n    while n > 0:\n        while num_degs[dmax] == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            return False\n        (num_degs[dmax], n) = (num_degs[dmax] - 1, n - 1)\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while num_degs[k] == 0:\n                k -= 1\n            (num_degs[k], n) = (num_degs[k] - 1, n - 1)\n            if k > 1:\n                modstubs[mslen] = k - 1\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            (num_degs[stub], n) = (num_degs[stub] + 1, n + 1)\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_havel_hakimi(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation proceeds using the Havel-Hakimi theorem\\n    [havel1955]_, [hakimi1962]_, [CL1996]_.\\n    Worst-case run time is $O(s)$ where $s$ is the sum of the sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers where each element specifies the degree of a node\\n        in a graph.\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [1]_.\\n\\n    References\\n    ----------\\n    .. [1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\\n       Casopis Pest. Mat. 80, 477-480, 1955.\\n    .. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\\n    .. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\\n       Chapman and Hall/CRC, 1996.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    modstubs = [0] * (dmax + 1)\n    while n > 0:\n        while num_degs[dmax] == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            return False\n        (num_degs[dmax], n) = (num_degs[dmax] - 1, n - 1)\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while num_degs[k] == 0:\n                k -= 1\n            (num_degs[k], n) = (num_degs[k] - 1, n - 1)\n            if k > 1:\n                modstubs[mslen] = k - 1\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            (num_degs[stub], n) = (num_degs[stub] + 1, n + 1)\n    return True"
        ]
    },
    {
        "func_name": "is_valid_degree_sequence_erdos_gallai",
        "original": "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_erdos_gallai(deg_sequence):\n    \"\"\"Returns True if deg_sequence can be realized by a simple graph.\n\n    The validation is done using the Erd\u0151s-Gallai theorem [EG1960]_.\n\n    Parameters\n    ----------\n    deg_sequence : list\n        A list of integers\n\n    Returns\n    -------\n    valid : bool\n        True if deg_sequence is graphical and False if not.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n    >>> sequence = (d for _, d in G.degree())\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence)\n    True\n\n    To test a non-valid sequence:\n    >>> sequence_list = [d for _, d in G.degree()]\n    >>> sequence_list[-1] += 1\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\n    False\n\n    Notes\n    -----\n\n    This implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\n    Worst-case run time is $O(n)$ where $n$ is the length of the sequence.\n\n    Specifically, a sequence d is graphical if and only if the\n    sum of the sequence is even and for all strong indices k in the sequence,\n\n     .. math::\n\n       \\\\sum_{i=1}^{k} d_i \\\\leq k(k-1) + \\\\sum_{j=k+1}^{n} \\\\min(d_i,k)\n             = k(n-1) - ( k \\\\sum_{j=0}^{k-1} n_j - \\\\sum_{j=0}^{k-1} j n_j )\n\n    A strong index k is any index where d_k >= k and the value n_j is the\n    number of occurrences of j in d.  The maximal strong index is called the\n    Durfee index.\n\n    This particular rearrangement comes from the proof of Theorem 3 in [2]_.\n\n    The ZZ condition says that for the sequence d if\n\n    .. math::\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\n\n    then d is graphical.  This was shown in Theorem 6 in [2]_.\n\n    References\n    ----------\n    .. [1] A. Tripathi and S. Vijay. \"A note on a theorem of Erd\u0151s & Gallai\",\n       Discrete Mathematics, 265, pp. 417-420 (2003).\n    .. [2] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\n    \"\"\"\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    (k, sum_deg, sum_nj, sum_jnj) = (0, 0, 0, 0)\n    for dk in range(dmax, dmin - 1, -1):\n        if dk < k + 1:\n            return True\n        if num_degs[dk] > 0:\n            run_size = num_degs[dk]\n            if dk < k + run_size:\n                run_size = dk - k\n            sum_deg += run_size * dk\n            for v in range(run_size):\n                sum_nj += num_degs[k + v]\n                sum_jnj += (k + v) * num_degs[k + v]\n            k += run_size\n            if sum_deg > k * (n - 1) - k * sum_nj + sum_jnj:\n                return False\n    return True",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_erdos_gallai(deg_sequence):\n    if False:\n        i = 10\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation is done using the Erd\u0151s-Gallai theorem [EG1960]_.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n\\n    This implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\\n    Worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    Specifically, a sequence d is graphical if and only if the\\n    sum of the sequence is even and for all strong indices k in the sequence,\\n\\n     .. math::\\n\\n       \\\\sum_{i=1}^{k} d_i \\\\leq k(k-1) + \\\\sum_{j=k+1}^{n} \\\\min(d_i,k)\\n             = k(n-1) - ( k \\\\sum_{j=0}^{k-1} n_j - \\\\sum_{j=0}^{k-1} j n_j )\\n\\n    A strong index k is any index where d_k >= k and the value n_j is the\\n    number of occurrences of j in d.  The maximal strong index is called the\\n    Durfee index.\\n\\n    This particular rearrangement comes from the proof of Theorem 3 in [2]_.\\n\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [2]_.\\n\\n    References\\n    ----------\\n    .. [1] A. Tripathi and S. Vijay. \"A note on a theorem of Erd\u0151s & Gallai\",\\n       Discrete Mathematics, 265, pp. 417-420 (2003).\\n    .. [2] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    (k, sum_deg, sum_nj, sum_jnj) = (0, 0, 0, 0)\n    for dk in range(dmax, dmin - 1, -1):\n        if dk < k + 1:\n            return True\n        if num_degs[dk] > 0:\n            run_size = num_degs[dk]\n            if dk < k + run_size:\n                run_size = dk - k\n            sum_deg += run_size * dk\n            for v in range(run_size):\n                sum_nj += num_degs[k + v]\n                sum_jnj += (k + v) * num_degs[k + v]\n            k += run_size\n            if sum_deg > k * (n - 1) - k * sum_nj + sum_jnj:\n                return False\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_erdos_gallai(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation is done using the Erd\u0151s-Gallai theorem [EG1960]_.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n\\n    This implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\\n    Worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    Specifically, a sequence d is graphical if and only if the\\n    sum of the sequence is even and for all strong indices k in the sequence,\\n\\n     .. math::\\n\\n       \\\\sum_{i=1}^{k} d_i \\\\leq k(k-1) + \\\\sum_{j=k+1}^{n} \\\\min(d_i,k)\\n             = k(n-1) - ( k \\\\sum_{j=0}^{k-1} n_j - \\\\sum_{j=0}^{k-1} j n_j )\\n\\n    A strong index k is any index where d_k >= k and the value n_j is the\\n    number of occurrences of j in d.  The maximal strong index is called the\\n    Durfee index.\\n\\n    This particular rearrangement comes from the proof of Theorem 3 in [2]_.\\n\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [2]_.\\n\\n    References\\n    ----------\\n    .. [1] A. Tripathi and S. Vijay. \"A note on a theorem of Erd\u0151s & Gallai\",\\n       Discrete Mathematics, 265, pp. 417-420 (2003).\\n    .. [2] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    (k, sum_deg, sum_nj, sum_jnj) = (0, 0, 0, 0)\n    for dk in range(dmax, dmin - 1, -1):\n        if dk < k + 1:\n            return True\n        if num_degs[dk] > 0:\n            run_size = num_degs[dk]\n            if dk < k + run_size:\n                run_size = dk - k\n            sum_deg += run_size * dk\n            for v in range(run_size):\n                sum_nj += num_degs[k + v]\n                sum_jnj += (k + v) * num_degs[k + v]\n            k += run_size\n            if sum_deg > k * (n - 1) - k * sum_nj + sum_jnj:\n                return False\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_erdos_gallai(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation is done using the Erd\u0151s-Gallai theorem [EG1960]_.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n\\n    This implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\\n    Worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    Specifically, a sequence d is graphical if and only if the\\n    sum of the sequence is even and for all strong indices k in the sequence,\\n\\n     .. math::\\n\\n       \\\\sum_{i=1}^{k} d_i \\\\leq k(k-1) + \\\\sum_{j=k+1}^{n} \\\\min(d_i,k)\\n             = k(n-1) - ( k \\\\sum_{j=0}^{k-1} n_j - \\\\sum_{j=0}^{k-1} j n_j )\\n\\n    A strong index k is any index where d_k >= k and the value n_j is the\\n    number of occurrences of j in d.  The maximal strong index is called the\\n    Durfee index.\\n\\n    This particular rearrangement comes from the proof of Theorem 3 in [2]_.\\n\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [2]_.\\n\\n    References\\n    ----------\\n    .. [1] A. Tripathi and S. Vijay. \"A note on a theorem of Erd\u0151s & Gallai\",\\n       Discrete Mathematics, 265, pp. 417-420 (2003).\\n    .. [2] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    (k, sum_deg, sum_nj, sum_jnj) = (0, 0, 0, 0)\n    for dk in range(dmax, dmin - 1, -1):\n        if dk < k + 1:\n            return True\n        if num_degs[dk] > 0:\n            run_size = num_degs[dk]\n            if dk < k + run_size:\n                run_size = dk - k\n            sum_deg += run_size * dk\n            for v in range(run_size):\n                sum_nj += num_degs[k + v]\n                sum_jnj += (k + v) * num_degs[k + v]\n            k += run_size\n            if sum_deg > k * (n - 1) - k * sum_nj + sum_jnj:\n                return False\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_erdos_gallai(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation is done using the Erd\u0151s-Gallai theorem [EG1960]_.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n\\n    This implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\\n    Worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    Specifically, a sequence d is graphical if and only if the\\n    sum of the sequence is even and for all strong indices k in the sequence,\\n\\n     .. math::\\n\\n       \\\\sum_{i=1}^{k} d_i \\\\leq k(k-1) + \\\\sum_{j=k+1}^{n} \\\\min(d_i,k)\\n             = k(n-1) - ( k \\\\sum_{j=0}^{k-1} n_j - \\\\sum_{j=0}^{k-1} j n_j )\\n\\n    A strong index k is any index where d_k >= k and the value n_j is the\\n    number of occurrences of j in d.  The maximal strong index is called the\\n    Durfee index.\\n\\n    This particular rearrangement comes from the proof of Theorem 3 in [2]_.\\n\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [2]_.\\n\\n    References\\n    ----------\\n    .. [1] A. Tripathi and S. Vijay. \"A note on a theorem of Erd\u0151s & Gallai\",\\n       Discrete Mathematics, 265, pp. 417-420 (2003).\\n    .. [2] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    (k, sum_deg, sum_nj, sum_jnj) = (0, 0, 0, 0)\n    for dk in range(dmax, dmin - 1, -1):\n        if dk < k + 1:\n            return True\n        if num_degs[dk] > 0:\n            run_size = num_degs[dk]\n            if dk < k + run_size:\n                run_size = dk - k\n            sum_deg += run_size * dk\n            for v in range(run_size):\n                sum_nj += num_degs[k + v]\n                sum_jnj += (k + v) * num_degs[k + v]\n            k += run_size\n            if sum_deg > k * (n - 1) - k * sum_nj + sum_jnj:\n                return False\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_valid_degree_sequence_erdos_gallai(deg_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if deg_sequence can be realized by a simple graph.\\n\\n    The validation is done using the Erd\u0151s-Gallai theorem [EG1960]_.\\n\\n    Parameters\\n    ----------\\n    deg_sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is graphical and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence)\\n    True\\n\\n    To test a non-valid sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n\\n    This implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\\n    Worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    Specifically, a sequence d is graphical if and only if the\\n    sum of the sequence is even and for all strong indices k in the sequence,\\n\\n     .. math::\\n\\n       \\\\sum_{i=1}^{k} d_i \\\\leq k(k-1) + \\\\sum_{j=k+1}^{n} \\\\min(d_i,k)\\n             = k(n-1) - ( k \\\\sum_{j=0}^{k-1} n_j - \\\\sum_{j=0}^{k-1} j n_j )\\n\\n    A strong index k is any index where d_k >= k and the value n_j is the\\n    number of occurrences of j in d.  The maximal strong index is called the\\n    Durfee index.\\n\\n    This particular rearrangement comes from the proof of Theorem 3 in [2]_.\\n\\n    The ZZ condition says that for the sequence d if\\n\\n    .. math::\\n        |d| >= \\\\frac{(\\\\max(d) + \\\\min(d) + 1)^2}{4*\\\\min(d)}\\n\\n    then d is graphical.  This was shown in Theorem 6 in [2]_.\\n\\n    References\\n    ----------\\n    .. [1] A. Tripathi and S. Vijay. \"A note on a theorem of Erd\u0151s & Gallai\",\\n       Discrete Mathematics, 265, pp. 417-420 (2003).\\n    .. [2] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\\n       of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\\n    .. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\\n    '\n    try:\n        (dmax, dmin, dsum, n, num_degs) = _basic_graphical_tests(deg_sequence)\n    except nx.NetworkXUnfeasible:\n        return False\n    if n == 0 or 4 * dmin * n >= (dmax + dmin + 1) * (dmax + dmin + 1):\n        return True\n    (k, sum_deg, sum_nj, sum_jnj) = (0, 0, 0, 0)\n    for dk in range(dmax, dmin - 1, -1):\n        if dk < k + 1:\n            return True\n        if num_degs[dk] > 0:\n            run_size = num_degs[dk]\n            if dk < k + run_size:\n                run_size = dk - k\n            sum_deg += run_size * dk\n            for v in range(run_size):\n                sum_nj += num_degs[k + v]\n                sum_jnj += (k + v) * num_degs[k + v]\n            k += run_size\n            if sum_deg > k * (n - 1) - k * sum_nj + sum_jnj:\n                return False\n    return True"
        ]
    },
    {
        "func_name": "is_multigraphical",
        "original": "@nx._dispatch(graphs=None)\ndef is_multigraphical(sequence):\n    \"\"\"Returns True if some multigraph can realize the sequence.\n\n    Parameters\n    ----------\n    sequence : list\n        A list of integers\n\n    Returns\n    -------\n    valid : bool\n        True if deg_sequence is a multigraphic degree sequence and False if not.\n\n    Examples\n    --------\n    >>> G = nx.MultiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n    >>> sequence = (d for _, d in G.degree())\n    >>> nx.is_multigraphical(sequence)\n    True\n\n    To test a non-multigraphical sequence:\n    >>> sequence_list = [d for _, d in G.degree()]\n    >>> sequence_list[-1] += 1\n    >>> nx.is_multigraphical(sequence_list)\n    False\n\n    Notes\n    -----\n    The worst-case run time is $O(n)$ where $n$ is the length of the sequence.\n\n    References\n    ----------\n    .. [1] S. L. Hakimi. \"On the realizability of a set of integers as\n       degrees of the vertices of a linear graph\", J. SIAM, 10, pp. 496-506\n       (1962).\n    \"\"\"\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    (dsum, dmax) = (0, 0)\n    for d in deg_sequence:\n        if d < 0:\n            return False\n        (dsum, dmax) = (dsum + d, max(dmax, d))\n    if dsum % 2 or dsum < 2 * dmax:\n        return False\n    return True",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef is_multigraphical(sequence):\n    if False:\n        i = 10\n    'Returns True if some multigraph can realize the sequence.\\n\\n    Parameters\\n    ----------\\n    sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is a multigraphic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.MultiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_multigraphical(sequence)\\n    True\\n\\n    To test a non-multigraphical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_multigraphical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] S. L. Hakimi. \"On the realizability of a set of integers as\\n       degrees of the vertices of a linear graph\", J. SIAM, 10, pp. 496-506\\n       (1962).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    (dsum, dmax) = (0, 0)\n    for d in deg_sequence:\n        if d < 0:\n            return False\n        (dsum, dmax) = (dsum + d, max(dmax, d))\n    if dsum % 2 or dsum < 2 * dmax:\n        return False\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_multigraphical(sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if some multigraph can realize the sequence.\\n\\n    Parameters\\n    ----------\\n    sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is a multigraphic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.MultiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_multigraphical(sequence)\\n    True\\n\\n    To test a non-multigraphical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_multigraphical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] S. L. Hakimi. \"On the realizability of a set of integers as\\n       degrees of the vertices of a linear graph\", J. SIAM, 10, pp. 496-506\\n       (1962).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    (dsum, dmax) = (0, 0)\n    for d in deg_sequence:\n        if d < 0:\n            return False\n        (dsum, dmax) = (dsum + d, max(dmax, d))\n    if dsum % 2 or dsum < 2 * dmax:\n        return False\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_multigraphical(sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if some multigraph can realize the sequence.\\n\\n    Parameters\\n    ----------\\n    sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is a multigraphic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.MultiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_multigraphical(sequence)\\n    True\\n\\n    To test a non-multigraphical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_multigraphical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] S. L. Hakimi. \"On the realizability of a set of integers as\\n       degrees of the vertices of a linear graph\", J. SIAM, 10, pp. 496-506\\n       (1962).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    (dsum, dmax) = (0, 0)\n    for d in deg_sequence:\n        if d < 0:\n            return False\n        (dsum, dmax) = (dsum + d, max(dmax, d))\n    if dsum % 2 or dsum < 2 * dmax:\n        return False\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_multigraphical(sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if some multigraph can realize the sequence.\\n\\n    Parameters\\n    ----------\\n    sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is a multigraphic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.MultiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_multigraphical(sequence)\\n    True\\n\\n    To test a non-multigraphical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_multigraphical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] S. L. Hakimi. \"On the realizability of a set of integers as\\n       degrees of the vertices of a linear graph\", J. SIAM, 10, pp. 496-506\\n       (1962).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    (dsum, dmax) = (0, 0)\n    for d in deg_sequence:\n        if d < 0:\n            return False\n        (dsum, dmax) = (dsum + d, max(dmax, d))\n    if dsum % 2 or dsum < 2 * dmax:\n        return False\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_multigraphical(sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if some multigraph can realize the sequence.\\n\\n    Parameters\\n    ----------\\n    sequence : list\\n        A list of integers\\n\\n    Returns\\n    -------\\n    valid : bool\\n        True if deg_sequence is a multigraphic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.MultiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_multigraphical(sequence)\\n    True\\n\\n    To test a non-multigraphical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_multigraphical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where $n$ is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] S. L. Hakimi. \"On the realizability of a set of integers as\\n       degrees of the vertices of a linear graph\", J. SIAM, 10, pp. 496-506\\n       (1962).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    (dsum, dmax) = (0, 0)\n    for d in deg_sequence:\n        if d < 0:\n            return False\n        (dsum, dmax) = (dsum + d, max(dmax, d))\n    if dsum % 2 or dsum < 2 * dmax:\n        return False\n    return True"
        ]
    },
    {
        "func_name": "is_pseudographical",
        "original": "@nx._dispatch(graphs=None)\ndef is_pseudographical(sequence):\n    \"\"\"Returns True if some pseudograph can realize the sequence.\n\n    Every nonnegative integer sequence with an even sum is pseudographical\n    (see [1]_).\n\n    Parameters\n    ----------\n    sequence : list or iterable container\n        A sequence of integer node degrees\n\n    Returns\n    -------\n    valid : bool\n      True if the sequence is a pseudographic degree sequence and False if not.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n    >>> sequence = (d for _, d in G.degree())\n    >>> nx.is_pseudographical(sequence)\n    True\n\n    To test a non-pseudographical sequence:\n    >>> sequence_list = [d for _, d in G.degree()]\n    >>> sequence_list[-1] += 1\n    >>> nx.is_pseudographical(sequence_list)\n    False\n\n    Notes\n    -----\n    The worst-case run time is $O(n)$ where n is the length of the sequence.\n\n    References\n    ----------\n    .. [1] F. Boesch and F. Harary. \"Line removal algorithms for graphs\n       and their degree lists\", IEEE Trans. Circuits and Systems, CAS-23(12),\n       pp. 778-782 (1976).\n    \"\"\"\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    return sum(deg_sequence) % 2 == 0 and min(deg_sequence) >= 0",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef is_pseudographical(sequence):\n    if False:\n        i = 10\n    'Returns True if some pseudograph can realize the sequence.\\n\\n    Every nonnegative integer sequence with an even sum is pseudographical\\n    (see [1]_).\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if the sequence is a pseudographic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_pseudographical(sequence)\\n    True\\n\\n    To test a non-pseudographical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_pseudographical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where n is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] F. Boesch and F. Harary. \"Line removal algorithms for graphs\\n       and their degree lists\", IEEE Trans. Circuits and Systems, CAS-23(12),\\n       pp. 778-782 (1976).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    return sum(deg_sequence) % 2 == 0 and min(deg_sequence) >= 0",
            "@nx._dispatch(graphs=None)\ndef is_pseudographical(sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if some pseudograph can realize the sequence.\\n\\n    Every nonnegative integer sequence with an even sum is pseudographical\\n    (see [1]_).\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if the sequence is a pseudographic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_pseudographical(sequence)\\n    True\\n\\n    To test a non-pseudographical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_pseudographical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where n is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] F. Boesch and F. Harary. \"Line removal algorithms for graphs\\n       and their degree lists\", IEEE Trans. Circuits and Systems, CAS-23(12),\\n       pp. 778-782 (1976).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    return sum(deg_sequence) % 2 == 0 and min(deg_sequence) >= 0",
            "@nx._dispatch(graphs=None)\ndef is_pseudographical(sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if some pseudograph can realize the sequence.\\n\\n    Every nonnegative integer sequence with an even sum is pseudographical\\n    (see [1]_).\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if the sequence is a pseudographic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_pseudographical(sequence)\\n    True\\n\\n    To test a non-pseudographical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_pseudographical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where n is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] F. Boesch and F. Harary. \"Line removal algorithms for graphs\\n       and their degree lists\", IEEE Trans. Circuits and Systems, CAS-23(12),\\n       pp. 778-782 (1976).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    return sum(deg_sequence) % 2 == 0 and min(deg_sequence) >= 0",
            "@nx._dispatch(graphs=None)\ndef is_pseudographical(sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if some pseudograph can realize the sequence.\\n\\n    Every nonnegative integer sequence with an even sum is pseudographical\\n    (see [1]_).\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if the sequence is a pseudographic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_pseudographical(sequence)\\n    True\\n\\n    To test a non-pseudographical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_pseudographical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where n is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] F. Boesch and F. Harary. \"Line removal algorithms for graphs\\n       and their degree lists\", IEEE Trans. Circuits and Systems, CAS-23(12),\\n       pp. 778-782 (1976).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    return sum(deg_sequence) % 2 == 0 and min(deg_sequence) >= 0",
            "@nx._dispatch(graphs=None)\ndef is_pseudographical(sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if some pseudograph can realize the sequence.\\n\\n    Every nonnegative integer sequence with an even sum is pseudographical\\n    (see [1]_).\\n\\n    Parameters\\n    ----------\\n    sequence : list or iterable container\\n        A sequence of integer node degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if the sequence is a pseudographic degree sequence and False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> sequence = (d for _, d in G.degree())\\n    >>> nx.is_pseudographical(sequence)\\n    True\\n\\n    To test a non-pseudographical sequence:\\n    >>> sequence_list = [d for _, d in G.degree()]\\n    >>> sequence_list[-1] += 1\\n    >>> nx.is_pseudographical(sequence_list)\\n    False\\n\\n    Notes\\n    -----\\n    The worst-case run time is $O(n)$ where n is the length of the sequence.\\n\\n    References\\n    ----------\\n    .. [1] F. Boesch and F. Harary. \"Line removal algorithms for graphs\\n       and their degree lists\", IEEE Trans. Circuits and Systems, CAS-23(12),\\n       pp. 778-782 (1976).\\n    '\n    try:\n        deg_sequence = nx.utils.make_list_of_ints(sequence)\n    except nx.NetworkXError:\n        return False\n    return sum(deg_sequence) % 2 == 0 and min(deg_sequence) >= 0"
        ]
    },
    {
        "func_name": "is_digraphical",
        "original": "@nx._dispatch(graphs=None)\ndef is_digraphical(in_sequence, out_sequence):\n    \"\"\"Returns True if some directed graph can realize the in- and out-degree\n    sequences.\n\n    Parameters\n    ----------\n    in_sequence : list or iterable container\n        A sequence of integer node in-degrees\n\n    out_sequence : list or iterable container\n        A sequence of integer node out-degrees\n\n    Returns\n    -------\n    valid : bool\n      True if in and out-sequences are digraphic False if not.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n    >>> in_seq = (d for n, d in G.in_degree())\n    >>> out_seq = (d for n, d in G.out_degree())\n    >>> nx.is_digraphical(in_seq, out_seq)\n    True\n\n    To test a non-digraphical scenario:\n    >>> in_seq_list = [d for n, d in G.in_degree()]\n    >>> in_seq_list[-1] += 1\n    >>> nx.is_digraphical(in_seq_list, out_seq)\n    False\n\n    Notes\n    -----\n    This algorithm is from Kleitman and Wang [1]_.\n    The worst case runtime is $O(s \\\\times \\\\log n)$ where $s$ and $n$ are the\n    sum and length of the sequences respectively.\n\n    References\n    ----------\n    .. [1] D.J. Kleitman and D.L. Wang\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\n       and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)\n    \"\"\"\n    try:\n        in_deg_sequence = nx.utils.make_list_of_ints(in_sequence)\n        out_deg_sequence = nx.utils.make_list_of_ints(out_sequence)\n    except nx.NetworkXError:\n        return False\n    (sumin, sumout, nin, nout) = (0, 0, len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    maxin = 0\n    if maxn == 0:\n        return True\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            return False\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg))\n        elif out_deg > 0:\n            zeroheap.append(-1 * out_deg)\n    if sumin != sumout:\n        return False\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            return False\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0]):\n                stubout = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin) = heapq.heappop(stubheap)\n            if stubout == 0:\n                return False\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, stub[0])\n        if freeout < 0:\n            heapq.heappush(zeroheap, freeout)\n    return True",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef is_digraphical(in_sequence, out_sequence):\n    if False:\n        i = 10\n    'Returns True if some directed graph can realize the in- and out-degree\\n    sequences.\\n\\n    Parameters\\n    ----------\\n    in_sequence : list or iterable container\\n        A sequence of integer node in-degrees\\n\\n    out_sequence : list or iterable container\\n        A sequence of integer node out-degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if in and out-sequences are digraphic False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> in_seq = (d for n, d in G.in_degree())\\n    >>> out_seq = (d for n, d in G.out_degree())\\n    >>> nx.is_digraphical(in_seq, out_seq)\\n    True\\n\\n    To test a non-digraphical scenario:\\n    >>> in_seq_list = [d for n, d in G.in_degree()]\\n    >>> in_seq_list[-1] += 1\\n    >>> nx.is_digraphical(in_seq_list, out_seq)\\n    False\\n\\n    Notes\\n    -----\\n    This algorithm is from Kleitman and Wang [1]_.\\n    The worst case runtime is $O(s \\\\times \\\\log n)$ where $s$ and $n$ are the\\n    sum and length of the sequences respectively.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    try:\n        in_deg_sequence = nx.utils.make_list_of_ints(in_sequence)\n        out_deg_sequence = nx.utils.make_list_of_ints(out_sequence)\n    except nx.NetworkXError:\n        return False\n    (sumin, sumout, nin, nout) = (0, 0, len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    maxin = 0\n    if maxn == 0:\n        return True\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            return False\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg))\n        elif out_deg > 0:\n            zeroheap.append(-1 * out_deg)\n    if sumin != sumout:\n        return False\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            return False\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0]):\n                stubout = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin) = heapq.heappop(stubheap)\n            if stubout == 0:\n                return False\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, stub[0])\n        if freeout < 0:\n            heapq.heappush(zeroheap, freeout)\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_digraphical(in_sequence, out_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if some directed graph can realize the in- and out-degree\\n    sequences.\\n\\n    Parameters\\n    ----------\\n    in_sequence : list or iterable container\\n        A sequence of integer node in-degrees\\n\\n    out_sequence : list or iterable container\\n        A sequence of integer node out-degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if in and out-sequences are digraphic False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> in_seq = (d for n, d in G.in_degree())\\n    >>> out_seq = (d for n, d in G.out_degree())\\n    >>> nx.is_digraphical(in_seq, out_seq)\\n    True\\n\\n    To test a non-digraphical scenario:\\n    >>> in_seq_list = [d for n, d in G.in_degree()]\\n    >>> in_seq_list[-1] += 1\\n    >>> nx.is_digraphical(in_seq_list, out_seq)\\n    False\\n\\n    Notes\\n    -----\\n    This algorithm is from Kleitman and Wang [1]_.\\n    The worst case runtime is $O(s \\\\times \\\\log n)$ where $s$ and $n$ are the\\n    sum and length of the sequences respectively.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    try:\n        in_deg_sequence = nx.utils.make_list_of_ints(in_sequence)\n        out_deg_sequence = nx.utils.make_list_of_ints(out_sequence)\n    except nx.NetworkXError:\n        return False\n    (sumin, sumout, nin, nout) = (0, 0, len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    maxin = 0\n    if maxn == 0:\n        return True\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            return False\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg))\n        elif out_deg > 0:\n            zeroheap.append(-1 * out_deg)\n    if sumin != sumout:\n        return False\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            return False\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0]):\n                stubout = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin) = heapq.heappop(stubheap)\n            if stubout == 0:\n                return False\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, stub[0])\n        if freeout < 0:\n            heapq.heappush(zeroheap, freeout)\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_digraphical(in_sequence, out_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if some directed graph can realize the in- and out-degree\\n    sequences.\\n\\n    Parameters\\n    ----------\\n    in_sequence : list or iterable container\\n        A sequence of integer node in-degrees\\n\\n    out_sequence : list or iterable container\\n        A sequence of integer node out-degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if in and out-sequences are digraphic False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> in_seq = (d for n, d in G.in_degree())\\n    >>> out_seq = (d for n, d in G.out_degree())\\n    >>> nx.is_digraphical(in_seq, out_seq)\\n    True\\n\\n    To test a non-digraphical scenario:\\n    >>> in_seq_list = [d for n, d in G.in_degree()]\\n    >>> in_seq_list[-1] += 1\\n    >>> nx.is_digraphical(in_seq_list, out_seq)\\n    False\\n\\n    Notes\\n    -----\\n    This algorithm is from Kleitman and Wang [1]_.\\n    The worst case runtime is $O(s \\\\times \\\\log n)$ where $s$ and $n$ are the\\n    sum and length of the sequences respectively.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    try:\n        in_deg_sequence = nx.utils.make_list_of_ints(in_sequence)\n        out_deg_sequence = nx.utils.make_list_of_ints(out_sequence)\n    except nx.NetworkXError:\n        return False\n    (sumin, sumout, nin, nout) = (0, 0, len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    maxin = 0\n    if maxn == 0:\n        return True\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            return False\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg))\n        elif out_deg > 0:\n            zeroheap.append(-1 * out_deg)\n    if sumin != sumout:\n        return False\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            return False\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0]):\n                stubout = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin) = heapq.heappop(stubheap)\n            if stubout == 0:\n                return False\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, stub[0])\n        if freeout < 0:\n            heapq.heappush(zeroheap, freeout)\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_digraphical(in_sequence, out_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if some directed graph can realize the in- and out-degree\\n    sequences.\\n\\n    Parameters\\n    ----------\\n    in_sequence : list or iterable container\\n        A sequence of integer node in-degrees\\n\\n    out_sequence : list or iterable container\\n        A sequence of integer node out-degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if in and out-sequences are digraphic False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> in_seq = (d for n, d in G.in_degree())\\n    >>> out_seq = (d for n, d in G.out_degree())\\n    >>> nx.is_digraphical(in_seq, out_seq)\\n    True\\n\\n    To test a non-digraphical scenario:\\n    >>> in_seq_list = [d for n, d in G.in_degree()]\\n    >>> in_seq_list[-1] += 1\\n    >>> nx.is_digraphical(in_seq_list, out_seq)\\n    False\\n\\n    Notes\\n    -----\\n    This algorithm is from Kleitman and Wang [1]_.\\n    The worst case runtime is $O(s \\\\times \\\\log n)$ where $s$ and $n$ are the\\n    sum and length of the sequences respectively.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    try:\n        in_deg_sequence = nx.utils.make_list_of_ints(in_sequence)\n        out_deg_sequence = nx.utils.make_list_of_ints(out_sequence)\n    except nx.NetworkXError:\n        return False\n    (sumin, sumout, nin, nout) = (0, 0, len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    maxin = 0\n    if maxn == 0:\n        return True\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            return False\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg))\n        elif out_deg > 0:\n            zeroheap.append(-1 * out_deg)\n    if sumin != sumout:\n        return False\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            return False\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0]):\n                stubout = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin) = heapq.heappop(stubheap)\n            if stubout == 0:\n                return False\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, stub[0])\n        if freeout < 0:\n            heapq.heappush(zeroheap, freeout)\n    return True",
            "@nx._dispatch(graphs=None)\ndef is_digraphical(in_sequence, out_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if some directed graph can realize the in- and out-degree\\n    sequences.\\n\\n    Parameters\\n    ----------\\n    in_sequence : list or iterable container\\n        A sequence of integer node in-degrees\\n\\n    out_sequence : list or iterable container\\n        A sequence of integer node out-degrees\\n\\n    Returns\\n    -------\\n    valid : bool\\n      True if in and out-sequences are digraphic False if not.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\\n    >>> in_seq = (d for n, d in G.in_degree())\\n    >>> out_seq = (d for n, d in G.out_degree())\\n    >>> nx.is_digraphical(in_seq, out_seq)\\n    True\\n\\n    To test a non-digraphical scenario:\\n    >>> in_seq_list = [d for n, d in G.in_degree()]\\n    >>> in_seq_list[-1] += 1\\n    >>> nx.is_digraphical(in_seq_list, out_seq)\\n    False\\n\\n    Notes\\n    -----\\n    This algorithm is from Kleitman and Wang [1]_.\\n    The worst case runtime is $O(s \\\\times \\\\log n)$ where $s$ and $n$ are the\\n    sum and length of the sequences respectively.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    try:\n        in_deg_sequence = nx.utils.make_list_of_ints(in_sequence)\n        out_deg_sequence = nx.utils.make_list_of_ints(out_sequence)\n    except nx.NetworkXError:\n        return False\n    (sumin, sumout, nin, nout) = (0, 0, len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    maxin = 0\n    if maxn == 0:\n        return True\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            return False\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg))\n        elif out_deg > 0:\n            zeroheap.append(-1 * out_deg)\n    if sumin != sumout:\n        return False\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            return False\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0]):\n                stubout = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin) = heapq.heappop(stubheap)\n            if stubout == 0:\n                return False\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, stub[0])\n        if freeout < 0:\n            heapq.heappush(zeroheap, freeout)\n    return True"
        ]
    }
]