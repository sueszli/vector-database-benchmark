[
    {
        "func_name": "_aggregate_at_state",
        "original": "def _aggregate_at_state(joint_policies, state, player):\n    \"\"\"Returns {action: prob} for `player` in `state` for all joint policies.\n\n  Args:\n    joint_policies: List of joint policies.\n    state: Openspiel State\n    player: Current Player\n\n  Returns:\n    {action: prob} for `player` in `state` for all joint policies.\n  \"\"\"\n    return [joint_policy[player].action_probabilities(state, player_id=player) for joint_policy in joint_policies]",
        "mutated": [
            "def _aggregate_at_state(joint_policies, state, player):\n    if False:\n        i = 10\n    'Returns {action: prob} for `player` in `state` for all joint policies.\\n\\n  Args:\\n    joint_policies: List of joint policies.\\n    state: Openspiel State\\n    player: Current Player\\n\\n  Returns:\\n    {action: prob} for `player` in `state` for all joint policies.\\n  '\n    return [joint_policy[player].action_probabilities(state, player_id=player) for joint_policy in joint_policies]",
            "def _aggregate_at_state(joint_policies, state, player):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns {action: prob} for `player` in `state` for all joint policies.\\n\\n  Args:\\n    joint_policies: List of joint policies.\\n    state: Openspiel State\\n    player: Current Player\\n\\n  Returns:\\n    {action: prob} for `player` in `state` for all joint policies.\\n  '\n    return [joint_policy[player].action_probabilities(state, player_id=player) for joint_policy in joint_policies]",
            "def _aggregate_at_state(joint_policies, state, player):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns {action: prob} for `player` in `state` for all joint policies.\\n\\n  Args:\\n    joint_policies: List of joint policies.\\n    state: Openspiel State\\n    player: Current Player\\n\\n  Returns:\\n    {action: prob} for `player` in `state` for all joint policies.\\n  '\n    return [joint_policy[player].action_probabilities(state, player_id=player) for joint_policy in joint_policies]",
            "def _aggregate_at_state(joint_policies, state, player):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns {action: prob} for `player` in `state` for all joint policies.\\n\\n  Args:\\n    joint_policies: List of joint policies.\\n    state: Openspiel State\\n    player: Current Player\\n\\n  Returns:\\n    {action: prob} for `player` in `state` for all joint policies.\\n  '\n    return [joint_policy[player].action_probabilities(state, player_id=player) for joint_policy in joint_policies]",
            "def _aggregate_at_state(joint_policies, state, player):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns {action: prob} for `player` in `state` for all joint policies.\\n\\n  Args:\\n    joint_policies: List of joint policies.\\n    state: Openspiel State\\n    player: Current Player\\n\\n  Returns:\\n    {action: prob} for `player` in `state` for all joint policies.\\n  '\n    return [joint_policy[player].action_probabilities(state, player_id=player) for joint_policy in joint_policies]"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, game, policies_as_dict):\n    \"\"\"Constructs a policy function.\n\n    Arguments:\n      game: OpenSpiel game.\n      policies_as_dict: A list of `num_players` policy objects {action: prob}.\n    \"\"\"\n    self._game = game\n    self._game_type = game.get_type()\n    self._policies_as_dict = policies_as_dict",
        "mutated": [
            "def __init__(self, game, policies_as_dict):\n    if False:\n        i = 10\n    'Constructs a policy function.\\n\\n    Arguments:\\n      game: OpenSpiel game.\\n      policies_as_dict: A list of `num_players` policy objects {action: prob}.\\n    '\n    self._game = game\n    self._game_type = game.get_type()\n    self._policies_as_dict = policies_as_dict",
            "def __init__(self, game, policies_as_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Constructs a policy function.\\n\\n    Arguments:\\n      game: OpenSpiel game.\\n      policies_as_dict: A list of `num_players` policy objects {action: prob}.\\n    '\n    self._game = game\n    self._game_type = game.get_type()\n    self._policies_as_dict = policies_as_dict",
            "def __init__(self, game, policies_as_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Constructs a policy function.\\n\\n    Arguments:\\n      game: OpenSpiel game.\\n      policies_as_dict: A list of `num_players` policy objects {action: prob}.\\n    '\n    self._game = game\n    self._game_type = game.get_type()\n    self._policies_as_dict = policies_as_dict",
            "def __init__(self, game, policies_as_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Constructs a policy function.\\n\\n    Arguments:\\n      game: OpenSpiel game.\\n      policies_as_dict: A list of `num_players` policy objects {action: prob}.\\n    '\n    self._game = game\n    self._game_type = game.get_type()\n    self._policies_as_dict = policies_as_dict",
            "def __init__(self, game, policies_as_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Constructs a policy function.\\n\\n    Arguments:\\n      game: OpenSpiel game.\\n      policies_as_dict: A list of `num_players` policy objects {action: prob}.\\n    '\n    self._game = game\n    self._game_type = game.get_type()\n    self._policies_as_dict = policies_as_dict"
        ]
    },
    {
        "func_name": "_state_key",
        "original": "def _state_key(self, state, player_id=None):\n    \"\"\"Returns the key to use to look up this (state, player_id) pair.\"\"\"\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player_id)\n    else:\n        return str(state)",
        "mutated": [
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n    'Returns the key to use to look up this (state, player_id) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player_id)\n    else:\n        return str(state)",
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the key to use to look up this (state, player_id) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player_id)\n    else:\n        return str(state)",
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the key to use to look up this (state, player_id) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player_id)\n    else:\n        return str(state)",
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the key to use to look up this (state, player_id) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player_id)\n    else:\n        return str(state)",
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the key to use to look up this (state, player_id) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player_id)\n    else:\n        return str(state)"
        ]
    },
    {
        "func_name": "policies",
        "original": "@property\ndef policies(self):\n    return self._policies_as_dict",
        "mutated": [
            "@property\ndef policies(self):\n    if False:\n        i = 10\n    return self._policies_as_dict",
            "@property\ndef policies(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self._policies_as_dict",
            "@property\ndef policies(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self._policies_as_dict",
            "@property\ndef policies(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self._policies_as_dict",
            "@property\ndef policies(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self._policies_as_dict"
        ]
    },
    {
        "func_name": "action_probabilities",
        "original": "def action_probabilities(self, state, player_id=None):\n    \"\"\"Returns the policy for a player in a state.\n\n    Args:\n      state: A `pyspiel.State` object.\n      player_id: Optional, the player id for whom we want an action. Optional\n        unless this is a simultaneous state at which multiple players can act.\n\n    Returns:\n      A `dict` of `{action: probability}` for the specified player in the\n      supplied state.\n    \"\"\"\n    state_key = self._state_key(state, player_id=player_id)\n    if player_id is None:\n        player_id = state.current_player()\n    return self._policies_as_dict[player_id][state_key]",
        "mutated": [
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultaneous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    state_key = self._state_key(state, player_id=player_id)\n    if player_id is None:\n        player_id = state.current_player()\n    return self._policies_as_dict[player_id][state_key]",
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultaneous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    state_key = self._state_key(state, player_id=player_id)\n    if player_id is None:\n        player_id = state.current_player()\n    return self._policies_as_dict[player_id][state_key]",
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultaneous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    state_key = self._state_key(state, player_id=player_id)\n    if player_id is None:\n        player_id = state.current_player()\n    return self._policies_as_dict[player_id][state_key]",
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultaneous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    state_key = self._state_key(state, player_id=player_id)\n    if player_id is None:\n        player_id = state.current_player()\n    return self._policies_as_dict[player_id][state_key]",
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultaneous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    state_key = self._state_key(state, player_id=player_id)\n    if player_id is None:\n        player_id = state.current_player()\n    return self._policies_as_dict[player_id][state_key]"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, game, epsilon=1e-40):\n    self._game = game\n    self._game_type = game.get_type()\n    self._num_players = self._game.num_players()\n    self._joint_policies = None\n    self._policy = {}\n    self._epsilon = epsilon",
        "mutated": [
            "def __init__(self, game, epsilon=1e-40):\n    if False:\n        i = 10\n    self._game = game\n    self._game_type = game.get_type()\n    self._num_players = self._game.num_players()\n    self._joint_policies = None\n    self._policy = {}\n    self._epsilon = epsilon",
            "def __init__(self, game, epsilon=1e-40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._game = game\n    self._game_type = game.get_type()\n    self._num_players = self._game.num_players()\n    self._joint_policies = None\n    self._policy = {}\n    self._epsilon = epsilon",
            "def __init__(self, game, epsilon=1e-40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._game = game\n    self._game_type = game.get_type()\n    self._num_players = self._game.num_players()\n    self._joint_policies = None\n    self._policy = {}\n    self._epsilon = epsilon",
            "def __init__(self, game, epsilon=1e-40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._game = game\n    self._game_type = game.get_type()\n    self._num_players = self._game.num_players()\n    self._joint_policies = None\n    self._policy = {}\n    self._epsilon = epsilon",
            "def __init__(self, game, epsilon=1e-40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._game = game\n    self._game_type = game.get_type()\n    self._num_players = self._game.num_players()\n    self._joint_policies = None\n    self._policy = {}\n    self._epsilon = epsilon"
        ]
    },
    {
        "func_name": "_state_key",
        "original": "def _state_key(self, state, player_id=None):\n    \"\"\"Returns the key to use to look up this (state, player) pair.\"\"\"\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation()\n        else:\n            return state.observation(player_id)\n    else:\n        return str(state)",
        "mutated": [
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n    'Returns the key to use to look up this (state, player) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation()\n        else:\n            return state.observation(player_id)\n    else:\n        return str(state)",
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the key to use to look up this (state, player) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation()\n        else:\n            return state.observation(player_id)\n    else:\n        return str(state)",
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the key to use to look up this (state, player) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation()\n        else:\n            return state.observation(player_id)\n    else:\n        return str(state)",
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the key to use to look up this (state, player) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation()\n        else:\n            return state.observation(player_id)\n    else:\n        return str(state)",
            "def _state_key(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the key to use to look up this (state, player) pair.'\n    if self._game_type.provides_information_state_string:\n        if player_id is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player_id)\n    elif self._game_type.provides_observation_string:\n        if player_id is None:\n            return state.observation()\n        else:\n            return state.observation(player_id)\n    else:\n        return str(state)"
        ]
    },
    {
        "func_name": "aggregate",
        "original": "def aggregate(self, pids, joint_policies, weights):\n    \"\"\"Computes the weighted-mixture of the joint policies.\n\n    Let P of shape [num_players] be the joint policy, and W some weights.\n    Let N be the number of policies (i.e. len(policies)).\n    We return the policy P' such that for all state `s`:\n\n    P[s] ~ \\\\sum_{i=0}^{N-1} (policies[i][player(s)](s) * weights[i] *\n                             reach_prob(s, policies[i]))\n\n    Arguments:\n      pids: Spiel player ids of the players the strategies belong to.\n      joint_policies: List of list of policies (One list per joint strategy)\n      weights: List of weights to attach to each joint strategy.\n\n    Returns:\n      A _DictPolicy, a callable object representing the policy.\n    \"\"\"\n    aggr_policies = []\n    self._joint_policies = joint_policies\n    for pid in pids:\n        aggr_policies.append(self._sub_aggregate(pid, weights))\n    return _DictPolicy(self._game, aggr_policies)",
        "mutated": [
            "def aggregate(self, pids, joint_policies, weights):\n    if False:\n        i = 10\n    \"Computes the weighted-mixture of the joint policies.\\n\\n    Let P of shape [num_players] be the joint policy, and W some weights.\\n    Let N be the number of policies (i.e. len(policies)).\\n    We return the policy P' such that for all state `s`:\\n\\n    P[s] ~ \\\\sum_{i=0}^{N-1} (policies[i][player(s)](s) * weights[i] *\\n                             reach_prob(s, policies[i]))\\n\\n    Arguments:\\n      pids: Spiel player ids of the players the strategies belong to.\\n      joint_policies: List of list of policies (One list per joint strategy)\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    \"\n    aggr_policies = []\n    self._joint_policies = joint_policies\n    for pid in pids:\n        aggr_policies.append(self._sub_aggregate(pid, weights))\n    return _DictPolicy(self._game, aggr_policies)",
            "def aggregate(self, pids, joint_policies, weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Computes the weighted-mixture of the joint policies.\\n\\n    Let P of shape [num_players] be the joint policy, and W some weights.\\n    Let N be the number of policies (i.e. len(policies)).\\n    We return the policy P' such that for all state `s`:\\n\\n    P[s] ~ \\\\sum_{i=0}^{N-1} (policies[i][player(s)](s) * weights[i] *\\n                             reach_prob(s, policies[i]))\\n\\n    Arguments:\\n      pids: Spiel player ids of the players the strategies belong to.\\n      joint_policies: List of list of policies (One list per joint strategy)\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    \"\n    aggr_policies = []\n    self._joint_policies = joint_policies\n    for pid in pids:\n        aggr_policies.append(self._sub_aggregate(pid, weights))\n    return _DictPolicy(self._game, aggr_policies)",
            "def aggregate(self, pids, joint_policies, weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Computes the weighted-mixture of the joint policies.\\n\\n    Let P of shape [num_players] be the joint policy, and W some weights.\\n    Let N be the number of policies (i.e. len(policies)).\\n    We return the policy P' such that for all state `s`:\\n\\n    P[s] ~ \\\\sum_{i=0}^{N-1} (policies[i][player(s)](s) * weights[i] *\\n                             reach_prob(s, policies[i]))\\n\\n    Arguments:\\n      pids: Spiel player ids of the players the strategies belong to.\\n      joint_policies: List of list of policies (One list per joint strategy)\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    \"\n    aggr_policies = []\n    self._joint_policies = joint_policies\n    for pid in pids:\n        aggr_policies.append(self._sub_aggregate(pid, weights))\n    return _DictPolicy(self._game, aggr_policies)",
            "def aggregate(self, pids, joint_policies, weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Computes the weighted-mixture of the joint policies.\\n\\n    Let P of shape [num_players] be the joint policy, and W some weights.\\n    Let N be the number of policies (i.e. len(policies)).\\n    We return the policy P' such that for all state `s`:\\n\\n    P[s] ~ \\\\sum_{i=0}^{N-1} (policies[i][player(s)](s) * weights[i] *\\n                             reach_prob(s, policies[i]))\\n\\n    Arguments:\\n      pids: Spiel player ids of the players the strategies belong to.\\n      joint_policies: List of list of policies (One list per joint strategy)\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    \"\n    aggr_policies = []\n    self._joint_policies = joint_policies\n    for pid in pids:\n        aggr_policies.append(self._sub_aggregate(pid, weights))\n    return _DictPolicy(self._game, aggr_policies)",
            "def aggregate(self, pids, joint_policies, weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Computes the weighted-mixture of the joint policies.\\n\\n    Let P of shape [num_players] be the joint policy, and W some weights.\\n    Let N be the number of policies (i.e. len(policies)).\\n    We return the policy P' such that for all state `s`:\\n\\n    P[s] ~ \\\\sum_{i=0}^{N-1} (policies[i][player(s)](s) * weights[i] *\\n                             reach_prob(s, policies[i]))\\n\\n    Arguments:\\n      pids: Spiel player ids of the players the strategies belong to.\\n      joint_policies: List of list of policies (One list per joint strategy)\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    \"\n    aggr_policies = []\n    self._joint_policies = joint_policies\n    for pid in pids:\n        aggr_policies.append(self._sub_aggregate(pid, weights))\n    return _DictPolicy(self._game, aggr_policies)"
        ]
    },
    {
        "func_name": "_sub_aggregate",
        "original": "def _sub_aggregate(self, pid, weights):\n    \"\"\"Aggregate the list of policies for one player.\n\n    Arguments:\n      pid: Spiel player id of the player the strategies belong to.\n      weights: List of weights to attach to each joint strategy.\n\n    Returns:\n      A _DictPolicy, a callable object representing the policy.\n    \"\"\"\n    self._policy = {}\n    state = self._game.new_initial_state()\n    self._rec_aggregate(pid, state, copy.deepcopy(weights))\n    for key in self._policy:\n        (actions, probabilities) = zip(*self._policy[key].items())\n        new_probs = [prob + self._epsilon for prob in probabilities]\n        denom = sum(new_probs)\n        for i in range(len(actions)):\n            self._policy[key][actions[i]] = new_probs[i] / denom\n    return self._policy",
        "mutated": [
            "def _sub_aggregate(self, pid, weights):\n    if False:\n        i = 10\n    'Aggregate the list of policies for one player.\\n\\n    Arguments:\\n      pid: Spiel player id of the player the strategies belong to.\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    '\n    self._policy = {}\n    state = self._game.new_initial_state()\n    self._rec_aggregate(pid, state, copy.deepcopy(weights))\n    for key in self._policy:\n        (actions, probabilities) = zip(*self._policy[key].items())\n        new_probs = [prob + self._epsilon for prob in probabilities]\n        denom = sum(new_probs)\n        for i in range(len(actions)):\n            self._policy[key][actions[i]] = new_probs[i] / denom\n    return self._policy",
            "def _sub_aggregate(self, pid, weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Aggregate the list of policies for one player.\\n\\n    Arguments:\\n      pid: Spiel player id of the player the strategies belong to.\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    '\n    self._policy = {}\n    state = self._game.new_initial_state()\n    self._rec_aggregate(pid, state, copy.deepcopy(weights))\n    for key in self._policy:\n        (actions, probabilities) = zip(*self._policy[key].items())\n        new_probs = [prob + self._epsilon for prob in probabilities]\n        denom = sum(new_probs)\n        for i in range(len(actions)):\n            self._policy[key][actions[i]] = new_probs[i] / denom\n    return self._policy",
            "def _sub_aggregate(self, pid, weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Aggregate the list of policies for one player.\\n\\n    Arguments:\\n      pid: Spiel player id of the player the strategies belong to.\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    '\n    self._policy = {}\n    state = self._game.new_initial_state()\n    self._rec_aggregate(pid, state, copy.deepcopy(weights))\n    for key in self._policy:\n        (actions, probabilities) = zip(*self._policy[key].items())\n        new_probs = [prob + self._epsilon for prob in probabilities]\n        denom = sum(new_probs)\n        for i in range(len(actions)):\n            self._policy[key][actions[i]] = new_probs[i] / denom\n    return self._policy",
            "def _sub_aggregate(self, pid, weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Aggregate the list of policies for one player.\\n\\n    Arguments:\\n      pid: Spiel player id of the player the strategies belong to.\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    '\n    self._policy = {}\n    state = self._game.new_initial_state()\n    self._rec_aggregate(pid, state, copy.deepcopy(weights))\n    for key in self._policy:\n        (actions, probabilities) = zip(*self._policy[key].items())\n        new_probs = [prob + self._epsilon for prob in probabilities]\n        denom = sum(new_probs)\n        for i in range(len(actions)):\n            self._policy[key][actions[i]] = new_probs[i] / denom\n    return self._policy",
            "def _sub_aggregate(self, pid, weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Aggregate the list of policies for one player.\\n\\n    Arguments:\\n      pid: Spiel player id of the player the strategies belong to.\\n      weights: List of weights to attach to each joint strategy.\\n\\n    Returns:\\n      A _DictPolicy, a callable object representing the policy.\\n    '\n    self._policy = {}\n    state = self._game.new_initial_state()\n    self._rec_aggregate(pid, state, copy.deepcopy(weights))\n    for key in self._policy:\n        (actions, probabilities) = zip(*self._policy[key].items())\n        new_probs = [prob + self._epsilon for prob in probabilities]\n        denom = sum(new_probs)\n        for i in range(len(actions)):\n            self._policy[key][actions[i]] = new_probs[i] / denom\n    return self._policy"
        ]
    },
    {
        "func_name": "_rec_aggregate",
        "original": "def _rec_aggregate(self, pid, state, my_reaches):\n    \"\"\"Recursively traverse game tree to compute aggregate policy.\"\"\"\n    if state.is_terminal():\n        return\n    if state.is_simultaneous_node():\n        policies = _aggregate_at_state(self._joint_policies, state, pid)\n        state_key = self._state_key(state, pid)\n        self._policy[state_key] = {}\n        used_moves = state.legal_actions(pid)\n        for uid in used_moves:\n            new_reaches = copy.deepcopy(my_reaches)\n            for i in range(len(policies)):\n                new_reaches[i] *= policies[i].get(uid, 0)\n                if uid in self._policy[state_key].keys():\n                    self._policy[state_key][uid] += new_reaches[i]\n                else:\n                    self._policy[state_key][uid] = new_reaches[i]\n        num_players = self._game.num_players()\n        all_other_used_moves = []\n        for player in range(num_players):\n            if player != pid:\n                all_other_used_moves.append(state.legal_actions(player))\n        other_joint_actions = itertools.product(*all_other_used_moves)\n        for other_joint_action in other_joint_actions:\n            for uid in used_moves:\n                new_reaches = copy.deepcopy(my_reaches)\n                for i in range(len(policies)):\n                    new_reaches[i] *= policies[i].get(uid, 0)\n                joint_action = list(other_joint_action[:pid] + (uid,) + other_joint_action[pid:])\n                new_state = state.clone()\n                new_state.apply_actions(joint_action)\n                self._rec_aggregate(pid, new_state, new_reaches)\n        return\n    if state.is_chance_node():\n        for action in state.legal_actions():\n            new_state = state.child(action)\n            self._rec_aggregate(pid, new_state, my_reaches)\n        return\n    current_player = state.current_player()\n    state_key = self._state_key(state, current_player)\n    action_probabilities_list = _aggregate_at_state(self._joint_policies, state, current_player)\n    if pid == current_player:\n        if state_key not in self._policy:\n            self._policy[state_key] = {}\n    for action in state.legal_actions():\n        new_reaches = copy.deepcopy(my_reaches)\n        if pid == current_player:\n            for (idx, state_action_probs) in enumerate(action_probabilities_list):\n                new_reaches[idx] *= state_action_probs.get(action, 0)\n                if action in self._policy[state_key].keys():\n                    self._policy[state_key][action] += new_reaches[idx]\n                else:\n                    self._policy[state_key][action] = new_reaches[idx]\n        self._rec_aggregate(pid, state.child(action), new_reaches)",
        "mutated": [
            "def _rec_aggregate(self, pid, state, my_reaches):\n    if False:\n        i = 10\n    'Recursively traverse game tree to compute aggregate policy.'\n    if state.is_terminal():\n        return\n    if state.is_simultaneous_node():\n        policies = _aggregate_at_state(self._joint_policies, state, pid)\n        state_key = self._state_key(state, pid)\n        self._policy[state_key] = {}\n        used_moves = state.legal_actions(pid)\n        for uid in used_moves:\n            new_reaches = copy.deepcopy(my_reaches)\n            for i in range(len(policies)):\n                new_reaches[i] *= policies[i].get(uid, 0)\n                if uid in self._policy[state_key].keys():\n                    self._policy[state_key][uid] += new_reaches[i]\n                else:\n                    self._policy[state_key][uid] = new_reaches[i]\n        num_players = self._game.num_players()\n        all_other_used_moves = []\n        for player in range(num_players):\n            if player != pid:\n                all_other_used_moves.append(state.legal_actions(player))\n        other_joint_actions = itertools.product(*all_other_used_moves)\n        for other_joint_action in other_joint_actions:\n            for uid in used_moves:\n                new_reaches = copy.deepcopy(my_reaches)\n                for i in range(len(policies)):\n                    new_reaches[i] *= policies[i].get(uid, 0)\n                joint_action = list(other_joint_action[:pid] + (uid,) + other_joint_action[pid:])\n                new_state = state.clone()\n                new_state.apply_actions(joint_action)\n                self._rec_aggregate(pid, new_state, new_reaches)\n        return\n    if state.is_chance_node():\n        for action in state.legal_actions():\n            new_state = state.child(action)\n            self._rec_aggregate(pid, new_state, my_reaches)\n        return\n    current_player = state.current_player()\n    state_key = self._state_key(state, current_player)\n    action_probabilities_list = _aggregate_at_state(self._joint_policies, state, current_player)\n    if pid == current_player:\n        if state_key not in self._policy:\n            self._policy[state_key] = {}\n    for action in state.legal_actions():\n        new_reaches = copy.deepcopy(my_reaches)\n        if pid == current_player:\n            for (idx, state_action_probs) in enumerate(action_probabilities_list):\n                new_reaches[idx] *= state_action_probs.get(action, 0)\n                if action in self._policy[state_key].keys():\n                    self._policy[state_key][action] += new_reaches[idx]\n                else:\n                    self._policy[state_key][action] = new_reaches[idx]\n        self._rec_aggregate(pid, state.child(action), new_reaches)",
            "def _rec_aggregate(self, pid, state, my_reaches):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Recursively traverse game tree to compute aggregate policy.'\n    if state.is_terminal():\n        return\n    if state.is_simultaneous_node():\n        policies = _aggregate_at_state(self._joint_policies, state, pid)\n        state_key = self._state_key(state, pid)\n        self._policy[state_key] = {}\n        used_moves = state.legal_actions(pid)\n        for uid in used_moves:\n            new_reaches = copy.deepcopy(my_reaches)\n            for i in range(len(policies)):\n                new_reaches[i] *= policies[i].get(uid, 0)\n                if uid in self._policy[state_key].keys():\n                    self._policy[state_key][uid] += new_reaches[i]\n                else:\n                    self._policy[state_key][uid] = new_reaches[i]\n        num_players = self._game.num_players()\n        all_other_used_moves = []\n        for player in range(num_players):\n            if player != pid:\n                all_other_used_moves.append(state.legal_actions(player))\n        other_joint_actions = itertools.product(*all_other_used_moves)\n        for other_joint_action in other_joint_actions:\n            for uid in used_moves:\n                new_reaches = copy.deepcopy(my_reaches)\n                for i in range(len(policies)):\n                    new_reaches[i] *= policies[i].get(uid, 0)\n                joint_action = list(other_joint_action[:pid] + (uid,) + other_joint_action[pid:])\n                new_state = state.clone()\n                new_state.apply_actions(joint_action)\n                self._rec_aggregate(pid, new_state, new_reaches)\n        return\n    if state.is_chance_node():\n        for action in state.legal_actions():\n            new_state = state.child(action)\n            self._rec_aggregate(pid, new_state, my_reaches)\n        return\n    current_player = state.current_player()\n    state_key = self._state_key(state, current_player)\n    action_probabilities_list = _aggregate_at_state(self._joint_policies, state, current_player)\n    if pid == current_player:\n        if state_key not in self._policy:\n            self._policy[state_key] = {}\n    for action in state.legal_actions():\n        new_reaches = copy.deepcopy(my_reaches)\n        if pid == current_player:\n            for (idx, state_action_probs) in enumerate(action_probabilities_list):\n                new_reaches[idx] *= state_action_probs.get(action, 0)\n                if action in self._policy[state_key].keys():\n                    self._policy[state_key][action] += new_reaches[idx]\n                else:\n                    self._policy[state_key][action] = new_reaches[idx]\n        self._rec_aggregate(pid, state.child(action), new_reaches)",
            "def _rec_aggregate(self, pid, state, my_reaches):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Recursively traverse game tree to compute aggregate policy.'\n    if state.is_terminal():\n        return\n    if state.is_simultaneous_node():\n        policies = _aggregate_at_state(self._joint_policies, state, pid)\n        state_key = self._state_key(state, pid)\n        self._policy[state_key] = {}\n        used_moves = state.legal_actions(pid)\n        for uid in used_moves:\n            new_reaches = copy.deepcopy(my_reaches)\n            for i in range(len(policies)):\n                new_reaches[i] *= policies[i].get(uid, 0)\n                if uid in self._policy[state_key].keys():\n                    self._policy[state_key][uid] += new_reaches[i]\n                else:\n                    self._policy[state_key][uid] = new_reaches[i]\n        num_players = self._game.num_players()\n        all_other_used_moves = []\n        for player in range(num_players):\n            if player != pid:\n                all_other_used_moves.append(state.legal_actions(player))\n        other_joint_actions = itertools.product(*all_other_used_moves)\n        for other_joint_action in other_joint_actions:\n            for uid in used_moves:\n                new_reaches = copy.deepcopy(my_reaches)\n                for i in range(len(policies)):\n                    new_reaches[i] *= policies[i].get(uid, 0)\n                joint_action = list(other_joint_action[:pid] + (uid,) + other_joint_action[pid:])\n                new_state = state.clone()\n                new_state.apply_actions(joint_action)\n                self._rec_aggregate(pid, new_state, new_reaches)\n        return\n    if state.is_chance_node():\n        for action in state.legal_actions():\n            new_state = state.child(action)\n            self._rec_aggregate(pid, new_state, my_reaches)\n        return\n    current_player = state.current_player()\n    state_key = self._state_key(state, current_player)\n    action_probabilities_list = _aggregate_at_state(self._joint_policies, state, current_player)\n    if pid == current_player:\n        if state_key not in self._policy:\n            self._policy[state_key] = {}\n    for action in state.legal_actions():\n        new_reaches = copy.deepcopy(my_reaches)\n        if pid == current_player:\n            for (idx, state_action_probs) in enumerate(action_probabilities_list):\n                new_reaches[idx] *= state_action_probs.get(action, 0)\n                if action in self._policy[state_key].keys():\n                    self._policy[state_key][action] += new_reaches[idx]\n                else:\n                    self._policy[state_key][action] = new_reaches[idx]\n        self._rec_aggregate(pid, state.child(action), new_reaches)",
            "def _rec_aggregate(self, pid, state, my_reaches):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Recursively traverse game tree to compute aggregate policy.'\n    if state.is_terminal():\n        return\n    if state.is_simultaneous_node():\n        policies = _aggregate_at_state(self._joint_policies, state, pid)\n        state_key = self._state_key(state, pid)\n        self._policy[state_key] = {}\n        used_moves = state.legal_actions(pid)\n        for uid in used_moves:\n            new_reaches = copy.deepcopy(my_reaches)\n            for i in range(len(policies)):\n                new_reaches[i] *= policies[i].get(uid, 0)\n                if uid in self._policy[state_key].keys():\n                    self._policy[state_key][uid] += new_reaches[i]\n                else:\n                    self._policy[state_key][uid] = new_reaches[i]\n        num_players = self._game.num_players()\n        all_other_used_moves = []\n        for player in range(num_players):\n            if player != pid:\n                all_other_used_moves.append(state.legal_actions(player))\n        other_joint_actions = itertools.product(*all_other_used_moves)\n        for other_joint_action in other_joint_actions:\n            for uid in used_moves:\n                new_reaches = copy.deepcopy(my_reaches)\n                for i in range(len(policies)):\n                    new_reaches[i] *= policies[i].get(uid, 0)\n                joint_action = list(other_joint_action[:pid] + (uid,) + other_joint_action[pid:])\n                new_state = state.clone()\n                new_state.apply_actions(joint_action)\n                self._rec_aggregate(pid, new_state, new_reaches)\n        return\n    if state.is_chance_node():\n        for action in state.legal_actions():\n            new_state = state.child(action)\n            self._rec_aggregate(pid, new_state, my_reaches)\n        return\n    current_player = state.current_player()\n    state_key = self._state_key(state, current_player)\n    action_probabilities_list = _aggregate_at_state(self._joint_policies, state, current_player)\n    if pid == current_player:\n        if state_key not in self._policy:\n            self._policy[state_key] = {}\n    for action in state.legal_actions():\n        new_reaches = copy.deepcopy(my_reaches)\n        if pid == current_player:\n            for (idx, state_action_probs) in enumerate(action_probabilities_list):\n                new_reaches[idx] *= state_action_probs.get(action, 0)\n                if action in self._policy[state_key].keys():\n                    self._policy[state_key][action] += new_reaches[idx]\n                else:\n                    self._policy[state_key][action] = new_reaches[idx]\n        self._rec_aggregate(pid, state.child(action), new_reaches)",
            "def _rec_aggregate(self, pid, state, my_reaches):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Recursively traverse game tree to compute aggregate policy.'\n    if state.is_terminal():\n        return\n    if state.is_simultaneous_node():\n        policies = _aggregate_at_state(self._joint_policies, state, pid)\n        state_key = self._state_key(state, pid)\n        self._policy[state_key] = {}\n        used_moves = state.legal_actions(pid)\n        for uid in used_moves:\n            new_reaches = copy.deepcopy(my_reaches)\n            for i in range(len(policies)):\n                new_reaches[i] *= policies[i].get(uid, 0)\n                if uid in self._policy[state_key].keys():\n                    self._policy[state_key][uid] += new_reaches[i]\n                else:\n                    self._policy[state_key][uid] = new_reaches[i]\n        num_players = self._game.num_players()\n        all_other_used_moves = []\n        for player in range(num_players):\n            if player != pid:\n                all_other_used_moves.append(state.legal_actions(player))\n        other_joint_actions = itertools.product(*all_other_used_moves)\n        for other_joint_action in other_joint_actions:\n            for uid in used_moves:\n                new_reaches = copy.deepcopy(my_reaches)\n                for i in range(len(policies)):\n                    new_reaches[i] *= policies[i].get(uid, 0)\n                joint_action = list(other_joint_action[:pid] + (uid,) + other_joint_action[pid:])\n                new_state = state.clone()\n                new_state.apply_actions(joint_action)\n                self._rec_aggregate(pid, new_state, new_reaches)\n        return\n    if state.is_chance_node():\n        for action in state.legal_actions():\n            new_state = state.child(action)\n            self._rec_aggregate(pid, new_state, my_reaches)\n        return\n    current_player = state.current_player()\n    state_key = self._state_key(state, current_player)\n    action_probabilities_list = _aggregate_at_state(self._joint_policies, state, current_player)\n    if pid == current_player:\n        if state_key not in self._policy:\n            self._policy[state_key] = {}\n    for action in state.legal_actions():\n        new_reaches = copy.deepcopy(my_reaches)\n        if pid == current_player:\n            for (idx, state_action_probs) in enumerate(action_probabilities_list):\n                new_reaches[idx] *= state_action_probs.get(action, 0)\n                if action in self._policy[state_key].keys():\n                    self._policy[state_key][action] += new_reaches[idx]\n                else:\n                    self._policy[state_key][action] = new_reaches[idx]\n        self._rec_aggregate(pid, state.child(action), new_reaches)"
        ]
    }
]