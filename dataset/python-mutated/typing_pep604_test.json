[
    {
        "func_name": "test_fix_pep604_types_noop",
        "original": "@pytest.mark.parametrize(('s', 'version'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', (3, 9), id='<3.10 Union'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', (3, 9), id='<3.10 Optional'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 9), id='<3.9 not in a type annotation context'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 10), id='3.10+ not in a type annotation context'), pytest.param('from typing import Union\\ndef f() -> Union[()]: ...\\n', (3, 10), id='3.10+ empty Union'), pytest.param('from typing import Optional\\ndef f() -> Optional[\"str\"]: ...\\n', (3, 10), id='3.10+ Optional of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[int, \"str\"]: ...\\n', (3, 10), id='3.10+ Union of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[1:2]: ...\\n', (3, 10), id='invalid Union slicing')))\ndef test_fix_pep604_types_noop(s, version):\n    assert _fix_plugins(s, settings=Settings(min_version=version)) == s",
        "mutated": [
            "@pytest.mark.parametrize(('s', 'version'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', (3, 9), id='<3.10 Union'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', (3, 9), id='<3.10 Optional'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 9), id='<3.9 not in a type annotation context'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 10), id='3.10+ not in a type annotation context'), pytest.param('from typing import Union\\ndef f() -> Union[()]: ...\\n', (3, 10), id='3.10+ empty Union'), pytest.param('from typing import Optional\\ndef f() -> Optional[\"str\"]: ...\\n', (3, 10), id='3.10+ Optional of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[int, \"str\"]: ...\\n', (3, 10), id='3.10+ Union of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[1:2]: ...\\n', (3, 10), id='invalid Union slicing')))\ndef test_fix_pep604_types_noop(s, version):\n    if False:\n        i = 10\n    assert _fix_plugins(s, settings=Settings(min_version=version)) == s",
            "@pytest.mark.parametrize(('s', 'version'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', (3, 9), id='<3.10 Union'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', (3, 9), id='<3.10 Optional'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 9), id='<3.9 not in a type annotation context'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 10), id='3.10+ not in a type annotation context'), pytest.param('from typing import Union\\ndef f() -> Union[()]: ...\\n', (3, 10), id='3.10+ empty Union'), pytest.param('from typing import Optional\\ndef f() -> Optional[\"str\"]: ...\\n', (3, 10), id='3.10+ Optional of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[int, \"str\"]: ...\\n', (3, 10), id='3.10+ Union of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[1:2]: ...\\n', (3, 10), id='invalid Union slicing')))\ndef test_fix_pep604_types_noop(s, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert _fix_plugins(s, settings=Settings(min_version=version)) == s",
            "@pytest.mark.parametrize(('s', 'version'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', (3, 9), id='<3.10 Union'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', (3, 9), id='<3.10 Optional'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 9), id='<3.9 not in a type annotation context'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 10), id='3.10+ not in a type annotation context'), pytest.param('from typing import Union\\ndef f() -> Union[()]: ...\\n', (3, 10), id='3.10+ empty Union'), pytest.param('from typing import Optional\\ndef f() -> Optional[\"str\"]: ...\\n', (3, 10), id='3.10+ Optional of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[int, \"str\"]: ...\\n', (3, 10), id='3.10+ Union of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[1:2]: ...\\n', (3, 10), id='invalid Union slicing')))\ndef test_fix_pep604_types_noop(s, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert _fix_plugins(s, settings=Settings(min_version=version)) == s",
            "@pytest.mark.parametrize(('s', 'version'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', (3, 9), id='<3.10 Union'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', (3, 9), id='<3.10 Optional'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 9), id='<3.9 not in a type annotation context'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 10), id='3.10+ not in a type annotation context'), pytest.param('from typing import Union\\ndef f() -> Union[()]: ...\\n', (3, 10), id='3.10+ empty Union'), pytest.param('from typing import Optional\\ndef f() -> Optional[\"str\"]: ...\\n', (3, 10), id='3.10+ Optional of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[int, \"str\"]: ...\\n', (3, 10), id='3.10+ Union of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[1:2]: ...\\n', (3, 10), id='invalid Union slicing')))\ndef test_fix_pep604_types_noop(s, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert _fix_plugins(s, settings=Settings(min_version=version)) == s",
            "@pytest.mark.parametrize(('s', 'version'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', (3, 9), id='<3.10 Union'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', (3, 9), id='<3.10 Optional'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 9), id='<3.9 not in a type annotation context'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\nSomeAlias = Union[int, str]\\n', (3, 10), id='3.10+ not in a type annotation context'), pytest.param('from typing import Union\\ndef f() -> Union[()]: ...\\n', (3, 10), id='3.10+ empty Union'), pytest.param('from typing import Optional\\ndef f() -> Optional[\"str\"]: ...\\n', (3, 10), id='3.10+ Optional of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[int, \"str\"]: ...\\n', (3, 10), id='3.10+ Union of forward reference'), pytest.param('from typing import Union\\ndef f() -> Union[1:2]: ...\\n', (3, 10), id='invalid Union slicing')))\ndef test_fix_pep604_types_noop(s, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert _fix_plugins(s, settings=Settings(min_version=version)) == s"
        ]
    },
    {
        "func_name": "test_noop_keep_runtime_typing",
        "original": "def test_noop_keep_runtime_typing():\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    assert _fix_plugins(s, settings=Settings(keep_runtime_typing=True)) == s",
        "mutated": [
            "def test_noop_keep_runtime_typing():\n    if False:\n        i = 10\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    assert _fix_plugins(s, settings=Settings(keep_runtime_typing=True)) == s",
            "def test_noop_keep_runtime_typing():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    assert _fix_plugins(s, settings=Settings(keep_runtime_typing=True)) == s",
            "def test_noop_keep_runtime_typing():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    assert _fix_plugins(s, settings=Settings(keep_runtime_typing=True)) == s",
            "def test_noop_keep_runtime_typing():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    assert _fix_plugins(s, settings=Settings(keep_runtime_typing=True)) == s",
            "def test_noop_keep_runtime_typing():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    assert _fix_plugins(s, settings=Settings(keep_runtime_typing=True)) == s"
        ]
    },
    {
        "func_name": "test_keep_runtime_typing_ignored_in_py310",
        "original": "def test_keep_runtime_typing_ignored_in_py310():\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    expected = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n'\n    settings = Settings(min_version=(3, 10), keep_runtime_typing=True)\n    assert _fix_plugins(s, settings=settings) == expected",
        "mutated": [
            "def test_keep_runtime_typing_ignored_in_py310():\n    if False:\n        i = 10\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    expected = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n'\n    settings = Settings(min_version=(3, 10), keep_runtime_typing=True)\n    assert _fix_plugins(s, settings=settings) == expected",
            "def test_keep_runtime_typing_ignored_in_py310():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    expected = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n'\n    settings = Settings(min_version=(3, 10), keep_runtime_typing=True)\n    assert _fix_plugins(s, settings=settings) == expected",
            "def test_keep_runtime_typing_ignored_in_py310():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    expected = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n'\n    settings = Settings(min_version=(3, 10), keep_runtime_typing=True)\n    assert _fix_plugins(s, settings=settings) == expected",
            "def test_keep_runtime_typing_ignored_in_py310():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    expected = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n'\n    settings = Settings(min_version=(3, 10), keep_runtime_typing=True)\n    assert _fix_plugins(s, settings=settings) == expected",
            "def test_keep_runtime_typing_ignored_in_py310():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n'\n    expected = 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n'\n    settings = Settings(min_version=(3, 10), keep_runtime_typing=True)\n    assert _fix_plugins(s, settings=settings) == expected"
        ]
    },
    {
        "func_name": "test_fix_pep604_types",
        "original": "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', 'from typing import Union\\nx: int | str\\n', id='Union rewrite'), pytest.param('x: typing.Union[int]\\n', 'x: int\\n', id='Union of only one value'), pytest.param('x: typing.Union[Foo[str, int], str]\\n', 'x: Foo[str, int] | str\\n', id='Union containing a value with brackets'), pytest.param('x: typing.Union[typing.List[str], str]\\n', 'x: list[str] | str\\n', id='Union containing pep585 rewritten type'), pytest.param('x: typing.Union[int, str,]\\n', 'x: int | str\\n', id='Union trailing comma'), pytest.param('x: typing.Union[(int, str)]\\n', 'x: int | str\\n', id='Union, parenthesized tuple'), pytest.param('x: typing.Union[\\n    int,\\n    str\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines'), pytest.param('x: typing.Union[\\n    int,\\n    str,\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines with trailing commas'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', 'from typing import Optional\\nx: str | None\\n', id='Optional rewrite'), pytest.param('x: typing.Optional[\\n    ComplicatedLongType[int]\\n]\\n', 'x: None | (\\n    ComplicatedLongType[int]\\n)\\n', id='Optional rewrite multi-line'), pytest.param('from __future__ import annotations\\nfrom typing import Optional\\nx: Optional[\"str\"]\\n', 'from __future__ import annotations\\nfrom typing import Optional\\nx: str | None\\n', id='Optional rewrite with forward reference'), pytest.param('from typing import Union, Sequence\\ndef f(x: Union[Union[A, B], Sequence[Union[C, D]]]): pass\\n', 'from typing import Union\\nfrom collections.abc import Sequence\\ndef f(x: A | B | Sequence[C | D]): pass\\n', id='nested unions'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x})\"]\\n', id='union, 3.12: ignore close brace in fstring'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x}(\"]\\n', id='union, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x}(\"] | None\\n', id='optional, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x})\"] | None\\n', id='optional, 3.12: ignore close brace in fstring')))\ndef test_fix_pep604_types(s, expected):\n    assert _fix_plugins(s, settings=Settings(min_version=(3, 10))) == expected",
        "mutated": [
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', 'from typing import Union\\nx: int | str\\n', id='Union rewrite'), pytest.param('x: typing.Union[int]\\n', 'x: int\\n', id='Union of only one value'), pytest.param('x: typing.Union[Foo[str, int], str]\\n', 'x: Foo[str, int] | str\\n', id='Union containing a value with brackets'), pytest.param('x: typing.Union[typing.List[str], str]\\n', 'x: list[str] | str\\n', id='Union containing pep585 rewritten type'), pytest.param('x: typing.Union[int, str,]\\n', 'x: int | str\\n', id='Union trailing comma'), pytest.param('x: typing.Union[(int, str)]\\n', 'x: int | str\\n', id='Union, parenthesized tuple'), pytest.param('x: typing.Union[\\n    int,\\n    str\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines'), pytest.param('x: typing.Union[\\n    int,\\n    str,\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines with trailing commas'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', 'from typing import Optional\\nx: str | None\\n', id='Optional rewrite'), pytest.param('x: typing.Optional[\\n    ComplicatedLongType[int]\\n]\\n', 'x: None | (\\n    ComplicatedLongType[int]\\n)\\n', id='Optional rewrite multi-line'), pytest.param('from __future__ import annotations\\nfrom typing import Optional\\nx: Optional[\"str\"]\\n', 'from __future__ import annotations\\nfrom typing import Optional\\nx: str | None\\n', id='Optional rewrite with forward reference'), pytest.param('from typing import Union, Sequence\\ndef f(x: Union[Union[A, B], Sequence[Union[C, D]]]): pass\\n', 'from typing import Union\\nfrom collections.abc import Sequence\\ndef f(x: A | B | Sequence[C | D]): pass\\n', id='nested unions'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x})\"]\\n', id='union, 3.12: ignore close brace in fstring'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x}(\"]\\n', id='union, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x}(\"] | None\\n', id='optional, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x})\"] | None\\n', id='optional, 3.12: ignore close brace in fstring')))\ndef test_fix_pep604_types(s, expected):\n    if False:\n        i = 10\n    assert _fix_plugins(s, settings=Settings(min_version=(3, 10))) == expected",
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', 'from typing import Union\\nx: int | str\\n', id='Union rewrite'), pytest.param('x: typing.Union[int]\\n', 'x: int\\n', id='Union of only one value'), pytest.param('x: typing.Union[Foo[str, int], str]\\n', 'x: Foo[str, int] | str\\n', id='Union containing a value with brackets'), pytest.param('x: typing.Union[typing.List[str], str]\\n', 'x: list[str] | str\\n', id='Union containing pep585 rewritten type'), pytest.param('x: typing.Union[int, str,]\\n', 'x: int | str\\n', id='Union trailing comma'), pytest.param('x: typing.Union[(int, str)]\\n', 'x: int | str\\n', id='Union, parenthesized tuple'), pytest.param('x: typing.Union[\\n    int,\\n    str\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines'), pytest.param('x: typing.Union[\\n    int,\\n    str,\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines with trailing commas'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', 'from typing import Optional\\nx: str | None\\n', id='Optional rewrite'), pytest.param('x: typing.Optional[\\n    ComplicatedLongType[int]\\n]\\n', 'x: None | (\\n    ComplicatedLongType[int]\\n)\\n', id='Optional rewrite multi-line'), pytest.param('from __future__ import annotations\\nfrom typing import Optional\\nx: Optional[\"str\"]\\n', 'from __future__ import annotations\\nfrom typing import Optional\\nx: str | None\\n', id='Optional rewrite with forward reference'), pytest.param('from typing import Union, Sequence\\ndef f(x: Union[Union[A, B], Sequence[Union[C, D]]]): pass\\n', 'from typing import Union\\nfrom collections.abc import Sequence\\ndef f(x: A | B | Sequence[C | D]): pass\\n', id='nested unions'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x})\"]\\n', id='union, 3.12: ignore close brace in fstring'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x}(\"]\\n', id='union, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x}(\"] | None\\n', id='optional, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x})\"] | None\\n', id='optional, 3.12: ignore close brace in fstring')))\ndef test_fix_pep604_types(s, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert _fix_plugins(s, settings=Settings(min_version=(3, 10))) == expected",
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', 'from typing import Union\\nx: int | str\\n', id='Union rewrite'), pytest.param('x: typing.Union[int]\\n', 'x: int\\n', id='Union of only one value'), pytest.param('x: typing.Union[Foo[str, int], str]\\n', 'x: Foo[str, int] | str\\n', id='Union containing a value with brackets'), pytest.param('x: typing.Union[typing.List[str], str]\\n', 'x: list[str] | str\\n', id='Union containing pep585 rewritten type'), pytest.param('x: typing.Union[int, str,]\\n', 'x: int | str\\n', id='Union trailing comma'), pytest.param('x: typing.Union[(int, str)]\\n', 'x: int | str\\n', id='Union, parenthesized tuple'), pytest.param('x: typing.Union[\\n    int,\\n    str\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines'), pytest.param('x: typing.Union[\\n    int,\\n    str,\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines with trailing commas'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', 'from typing import Optional\\nx: str | None\\n', id='Optional rewrite'), pytest.param('x: typing.Optional[\\n    ComplicatedLongType[int]\\n]\\n', 'x: None | (\\n    ComplicatedLongType[int]\\n)\\n', id='Optional rewrite multi-line'), pytest.param('from __future__ import annotations\\nfrom typing import Optional\\nx: Optional[\"str\"]\\n', 'from __future__ import annotations\\nfrom typing import Optional\\nx: str | None\\n', id='Optional rewrite with forward reference'), pytest.param('from typing import Union, Sequence\\ndef f(x: Union[Union[A, B], Sequence[Union[C, D]]]): pass\\n', 'from typing import Union\\nfrom collections.abc import Sequence\\ndef f(x: A | B | Sequence[C | D]): pass\\n', id='nested unions'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x})\"]\\n', id='union, 3.12: ignore close brace in fstring'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x}(\"]\\n', id='union, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x}(\"] | None\\n', id='optional, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x})\"] | None\\n', id='optional, 3.12: ignore close brace in fstring')))\ndef test_fix_pep604_types(s, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert _fix_plugins(s, settings=Settings(min_version=(3, 10))) == expected",
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', 'from typing import Union\\nx: int | str\\n', id='Union rewrite'), pytest.param('x: typing.Union[int]\\n', 'x: int\\n', id='Union of only one value'), pytest.param('x: typing.Union[Foo[str, int], str]\\n', 'x: Foo[str, int] | str\\n', id='Union containing a value with brackets'), pytest.param('x: typing.Union[typing.List[str], str]\\n', 'x: list[str] | str\\n', id='Union containing pep585 rewritten type'), pytest.param('x: typing.Union[int, str,]\\n', 'x: int | str\\n', id='Union trailing comma'), pytest.param('x: typing.Union[(int, str)]\\n', 'x: int | str\\n', id='Union, parenthesized tuple'), pytest.param('x: typing.Union[\\n    int,\\n    str\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines'), pytest.param('x: typing.Union[\\n    int,\\n    str,\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines with trailing commas'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', 'from typing import Optional\\nx: str | None\\n', id='Optional rewrite'), pytest.param('x: typing.Optional[\\n    ComplicatedLongType[int]\\n]\\n', 'x: None | (\\n    ComplicatedLongType[int]\\n)\\n', id='Optional rewrite multi-line'), pytest.param('from __future__ import annotations\\nfrom typing import Optional\\nx: Optional[\"str\"]\\n', 'from __future__ import annotations\\nfrom typing import Optional\\nx: str | None\\n', id='Optional rewrite with forward reference'), pytest.param('from typing import Union, Sequence\\ndef f(x: Union[Union[A, B], Sequence[Union[C, D]]]): pass\\n', 'from typing import Union\\nfrom collections.abc import Sequence\\ndef f(x: A | B | Sequence[C | D]): pass\\n', id='nested unions'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x})\"]\\n', id='union, 3.12: ignore close brace in fstring'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x}(\"]\\n', id='union, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x}(\"] | None\\n', id='optional, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x})\"] | None\\n', id='optional, 3.12: ignore close brace in fstring')))\ndef test_fix_pep604_types(s, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert _fix_plugins(s, settings=Settings(min_version=(3, 10))) == expected",
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from typing import Union\\nx: Union[int, str]\\n', 'from typing import Union\\nx: int | str\\n', id='Union rewrite'), pytest.param('x: typing.Union[int]\\n', 'x: int\\n', id='Union of only one value'), pytest.param('x: typing.Union[Foo[str, int], str]\\n', 'x: Foo[str, int] | str\\n', id='Union containing a value with brackets'), pytest.param('x: typing.Union[typing.List[str], str]\\n', 'x: list[str] | str\\n', id='Union containing pep585 rewritten type'), pytest.param('x: typing.Union[int, str,]\\n', 'x: int | str\\n', id='Union trailing comma'), pytest.param('x: typing.Union[(int, str)]\\n', 'x: int | str\\n', id='Union, parenthesized tuple'), pytest.param('x: typing.Union[\\n    int,\\n    str\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines'), pytest.param('x: typing.Union[\\n    int,\\n    str,\\n]\\n', 'x: (\\n    int |\\n    str\\n)\\n', id='Union multiple lines with trailing commas'), pytest.param('from typing import Optional\\nx: Optional[str]\\n', 'from typing import Optional\\nx: str | None\\n', id='Optional rewrite'), pytest.param('x: typing.Optional[\\n    ComplicatedLongType[int]\\n]\\n', 'x: None | (\\n    ComplicatedLongType[int]\\n)\\n', id='Optional rewrite multi-line'), pytest.param('from __future__ import annotations\\nfrom typing import Optional\\nx: Optional[\"str\"]\\n', 'from __future__ import annotations\\nfrom typing import Optional\\nx: str | None\\n', id='Optional rewrite with forward reference'), pytest.param('from typing import Union, Sequence\\ndef f(x: Union[Union[A, B], Sequence[Union[C, D]]]): pass\\n', 'from typing import Union\\nfrom collections.abc import Sequence\\ndef f(x: A | B | Sequence[C | D]): pass\\n', id='nested unions'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x})\"]\\n', id='union, 3.12: ignore close brace in fstring'), pytest.param('from typing import Annotated, Union\\nx: Union[str, Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Union\\nx: str | Annotated[int, f\"{x}(\"]\\n', id='union, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x}(\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x}(\"] | None\\n', id='optional, 3.12: ignore open brace in fstring'), pytest.param('from typing import Annotated, Optional\\nx: Optional[Annotated[int, f\"{x})\"]]\\n', 'from typing import Annotated, Optional\\nx: Annotated[int, f\"{x})\"] | None\\n', id='optional, 3.12: ignore close brace in fstring')))\ndef test_fix_pep604_types(s, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert _fix_plugins(s, settings=Settings(min_version=(3, 10))) == expected"
        ]
    },
    {
        "func_name": "test_fix_generic_types_future_annotations",
        "original": "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from __future__ import annotations\\nfrom typing import Union\\nx: Union[int, str]\\n', 'from __future__ import annotations\\nfrom typing import Union\\nx: int | str\\n', id='variable annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n', id='argument annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f() -> Union[int, str]: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f() -> int | str: ...\\n', id='return annotations')))\ndef test_fix_generic_types_future_annotations(s, expected):\n    assert _fix_plugins(s, settings=Settings()) == expected",
        "mutated": [
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from __future__ import annotations\\nfrom typing import Union\\nx: Union[int, str]\\n', 'from __future__ import annotations\\nfrom typing import Union\\nx: int | str\\n', id='variable annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n', id='argument annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f() -> Union[int, str]: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f() -> int | str: ...\\n', id='return annotations')))\ndef test_fix_generic_types_future_annotations(s, expected):\n    if False:\n        i = 10\n    assert _fix_plugins(s, settings=Settings()) == expected",
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from __future__ import annotations\\nfrom typing import Union\\nx: Union[int, str]\\n', 'from __future__ import annotations\\nfrom typing import Union\\nx: int | str\\n', id='variable annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n', id='argument annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f() -> Union[int, str]: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f() -> int | str: ...\\n', id='return annotations')))\ndef test_fix_generic_types_future_annotations(s, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert _fix_plugins(s, settings=Settings()) == expected",
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from __future__ import annotations\\nfrom typing import Union\\nx: Union[int, str]\\n', 'from __future__ import annotations\\nfrom typing import Union\\nx: int | str\\n', id='variable annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n', id='argument annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f() -> Union[int, str]: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f() -> int | str: ...\\n', id='return annotations')))\ndef test_fix_generic_types_future_annotations(s, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert _fix_plugins(s, settings=Settings()) == expected",
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from __future__ import annotations\\nfrom typing import Union\\nx: Union[int, str]\\n', 'from __future__ import annotations\\nfrom typing import Union\\nx: int | str\\n', id='variable annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n', id='argument annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f() -> Union[int, str]: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f() -> int | str: ...\\n', id='return annotations')))\ndef test_fix_generic_types_future_annotations(s, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert _fix_plugins(s, settings=Settings()) == expected",
            "@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from __future__ import annotations\\nfrom typing import Union\\nx: Union[int, str]\\n', 'from __future__ import annotations\\nfrom typing import Union\\nx: int | str\\n', id='variable annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f(x: Union[int, str]) -> None: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f(x: int | str) -> None: ...\\n', id='argument annotations'), pytest.param('from __future__ import annotations\\nfrom typing import Union\\ndef f() -> Union[int, str]: ...\\n', 'from __future__ import annotations\\nfrom typing import Union\\ndef f() -> int | str: ...\\n', id='return annotations')))\ndef test_fix_generic_types_future_annotations(s, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert _fix_plugins(s, settings=Settings()) == expected"
        ]
    }
]