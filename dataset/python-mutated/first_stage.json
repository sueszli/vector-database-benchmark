[
    {
        "func_name": "run_first_stage",
        "original": "def run_first_stage(image, net, scale, threshold, device='cuda'):\n    \"\"\"Run P-Net, generate bounding boxes, and do NMS.\n\n    Arguments:\n        image: an instance of PIL.Image.\n        net: an instance of pytorch's nn.Module, P-Net.\n        scale: a float number,\n            scale width and height of the image by this number.\n        threshold: a float number,\n            threshold on the probability of a face when generating\n            bounding boxes from predictions of the net.\n\n    Returns:\n        a float numpy array of shape [n_boxes, 9],\n            bounding boxes with scores and offsets (4 + 1 + 4).\n    \"\"\"\n    (width, height) = image.size\n    (sw, sh) = (math.ceil(width * scale), math.ceil(height * scale))\n    img = image.resize((sw, sh), Image.BILINEAR)\n    img = np.asarray(img, 'float32')\n    img = Variable(torch.FloatTensor(_preprocess(img)), volatile=True).to(device)\n    output = net(img)\n    probs = output[1].cpu().data.numpy()[0, 1, :, :]\n    offsets = output[0].cpu().data.numpy()\n    boxes = _generate_bboxes(probs, offsets, scale, threshold)\n    if len(boxes) == 0:\n        return None\n    keep = nms(boxes[:, 0:5], overlap_threshold=0.5)\n    return boxes[keep]",
        "mutated": [
            "def run_first_stage(image, net, scale, threshold, device='cuda'):\n    if False:\n        i = 10\n    \"Run P-Net, generate bounding boxes, and do NMS.\\n\\n    Arguments:\\n        image: an instance of PIL.Image.\\n        net: an instance of pytorch's nn.Module, P-Net.\\n        scale: a float number,\\n            scale width and height of the image by this number.\\n        threshold: a float number,\\n            threshold on the probability of a face when generating\\n            bounding boxes from predictions of the net.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9],\\n            bounding boxes with scores and offsets (4 + 1 + 4).\\n    \"\n    (width, height) = image.size\n    (sw, sh) = (math.ceil(width * scale), math.ceil(height * scale))\n    img = image.resize((sw, sh), Image.BILINEAR)\n    img = np.asarray(img, 'float32')\n    img = Variable(torch.FloatTensor(_preprocess(img)), volatile=True).to(device)\n    output = net(img)\n    probs = output[1].cpu().data.numpy()[0, 1, :, :]\n    offsets = output[0].cpu().data.numpy()\n    boxes = _generate_bboxes(probs, offsets, scale, threshold)\n    if len(boxes) == 0:\n        return None\n    keep = nms(boxes[:, 0:5], overlap_threshold=0.5)\n    return boxes[keep]",
            "def run_first_stage(image, net, scale, threshold, device='cuda'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Run P-Net, generate bounding boxes, and do NMS.\\n\\n    Arguments:\\n        image: an instance of PIL.Image.\\n        net: an instance of pytorch's nn.Module, P-Net.\\n        scale: a float number,\\n            scale width and height of the image by this number.\\n        threshold: a float number,\\n            threshold on the probability of a face when generating\\n            bounding boxes from predictions of the net.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9],\\n            bounding boxes with scores and offsets (4 + 1 + 4).\\n    \"\n    (width, height) = image.size\n    (sw, sh) = (math.ceil(width * scale), math.ceil(height * scale))\n    img = image.resize((sw, sh), Image.BILINEAR)\n    img = np.asarray(img, 'float32')\n    img = Variable(torch.FloatTensor(_preprocess(img)), volatile=True).to(device)\n    output = net(img)\n    probs = output[1].cpu().data.numpy()[0, 1, :, :]\n    offsets = output[0].cpu().data.numpy()\n    boxes = _generate_bboxes(probs, offsets, scale, threshold)\n    if len(boxes) == 0:\n        return None\n    keep = nms(boxes[:, 0:5], overlap_threshold=0.5)\n    return boxes[keep]",
            "def run_first_stage(image, net, scale, threshold, device='cuda'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Run P-Net, generate bounding boxes, and do NMS.\\n\\n    Arguments:\\n        image: an instance of PIL.Image.\\n        net: an instance of pytorch's nn.Module, P-Net.\\n        scale: a float number,\\n            scale width and height of the image by this number.\\n        threshold: a float number,\\n            threshold on the probability of a face when generating\\n            bounding boxes from predictions of the net.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9],\\n            bounding boxes with scores and offsets (4 + 1 + 4).\\n    \"\n    (width, height) = image.size\n    (sw, sh) = (math.ceil(width * scale), math.ceil(height * scale))\n    img = image.resize((sw, sh), Image.BILINEAR)\n    img = np.asarray(img, 'float32')\n    img = Variable(torch.FloatTensor(_preprocess(img)), volatile=True).to(device)\n    output = net(img)\n    probs = output[1].cpu().data.numpy()[0, 1, :, :]\n    offsets = output[0].cpu().data.numpy()\n    boxes = _generate_bboxes(probs, offsets, scale, threshold)\n    if len(boxes) == 0:\n        return None\n    keep = nms(boxes[:, 0:5], overlap_threshold=0.5)\n    return boxes[keep]",
            "def run_first_stage(image, net, scale, threshold, device='cuda'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Run P-Net, generate bounding boxes, and do NMS.\\n\\n    Arguments:\\n        image: an instance of PIL.Image.\\n        net: an instance of pytorch's nn.Module, P-Net.\\n        scale: a float number,\\n            scale width and height of the image by this number.\\n        threshold: a float number,\\n            threshold on the probability of a face when generating\\n            bounding boxes from predictions of the net.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9],\\n            bounding boxes with scores and offsets (4 + 1 + 4).\\n    \"\n    (width, height) = image.size\n    (sw, sh) = (math.ceil(width * scale), math.ceil(height * scale))\n    img = image.resize((sw, sh), Image.BILINEAR)\n    img = np.asarray(img, 'float32')\n    img = Variable(torch.FloatTensor(_preprocess(img)), volatile=True).to(device)\n    output = net(img)\n    probs = output[1].cpu().data.numpy()[0, 1, :, :]\n    offsets = output[0].cpu().data.numpy()\n    boxes = _generate_bboxes(probs, offsets, scale, threshold)\n    if len(boxes) == 0:\n        return None\n    keep = nms(boxes[:, 0:5], overlap_threshold=0.5)\n    return boxes[keep]",
            "def run_first_stage(image, net, scale, threshold, device='cuda'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Run P-Net, generate bounding boxes, and do NMS.\\n\\n    Arguments:\\n        image: an instance of PIL.Image.\\n        net: an instance of pytorch's nn.Module, P-Net.\\n        scale: a float number,\\n            scale width and height of the image by this number.\\n        threshold: a float number,\\n            threshold on the probability of a face when generating\\n            bounding boxes from predictions of the net.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9],\\n            bounding boxes with scores and offsets (4 + 1 + 4).\\n    \"\n    (width, height) = image.size\n    (sw, sh) = (math.ceil(width * scale), math.ceil(height * scale))\n    img = image.resize((sw, sh), Image.BILINEAR)\n    img = np.asarray(img, 'float32')\n    img = Variable(torch.FloatTensor(_preprocess(img)), volatile=True).to(device)\n    output = net(img)\n    probs = output[1].cpu().data.numpy()[0, 1, :, :]\n    offsets = output[0].cpu().data.numpy()\n    boxes = _generate_bboxes(probs, offsets, scale, threshold)\n    if len(boxes) == 0:\n        return None\n    keep = nms(boxes[:, 0:5], overlap_threshold=0.5)\n    return boxes[keep]"
        ]
    },
    {
        "func_name": "_generate_bboxes",
        "original": "def _generate_bboxes(probs, offsets, scale, threshold):\n    \"\"\"Generate bounding boxes at places\n    where there is probably a face.\n\n    Arguments:\n        probs: a float numpy array of shape [n, m].\n        offsets: a float numpy array of shape [1, 4, n, m].\n        scale: a float number,\n            width and height of the image were scaled by this number.\n        threshold: a float number.\n\n    Returns:\n        a float numpy array of shape [n_boxes, 9]\n    \"\"\"\n    stride = 2\n    cell_size = 12\n    inds = np.where(probs > threshold)\n    if inds[0].size == 0:\n        return np.array([])\n    (tx1, ty1, tx2, ty2) = [offsets[0, i, inds[0], inds[1]] for i in range(4)]\n    offsets = np.array([tx1, ty1, tx2, ty2])\n    score = probs[inds[0], inds[1]]\n    bounding_boxes = np.vstack([np.round((stride * inds[1] + 1.0) / scale), np.round((stride * inds[0] + 1.0) / scale), np.round((stride * inds[1] + 1.0 + cell_size) / scale), np.round((stride * inds[0] + 1.0 + cell_size) / scale), score, offsets])\n    return bounding_boxes.T",
        "mutated": [
            "def _generate_bboxes(probs, offsets, scale, threshold):\n    if False:\n        i = 10\n    'Generate bounding boxes at places\\n    where there is probably a face.\\n\\n    Arguments:\\n        probs: a float numpy array of shape [n, m].\\n        offsets: a float numpy array of shape [1, 4, n, m].\\n        scale: a float number,\\n            width and height of the image were scaled by this number.\\n        threshold: a float number.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9]\\n    '\n    stride = 2\n    cell_size = 12\n    inds = np.where(probs > threshold)\n    if inds[0].size == 0:\n        return np.array([])\n    (tx1, ty1, tx2, ty2) = [offsets[0, i, inds[0], inds[1]] for i in range(4)]\n    offsets = np.array([tx1, ty1, tx2, ty2])\n    score = probs[inds[0], inds[1]]\n    bounding_boxes = np.vstack([np.round((stride * inds[1] + 1.0) / scale), np.round((stride * inds[0] + 1.0) / scale), np.round((stride * inds[1] + 1.0 + cell_size) / scale), np.round((stride * inds[0] + 1.0 + cell_size) / scale), score, offsets])\n    return bounding_boxes.T",
            "def _generate_bboxes(probs, offsets, scale, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate bounding boxes at places\\n    where there is probably a face.\\n\\n    Arguments:\\n        probs: a float numpy array of shape [n, m].\\n        offsets: a float numpy array of shape [1, 4, n, m].\\n        scale: a float number,\\n            width and height of the image were scaled by this number.\\n        threshold: a float number.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9]\\n    '\n    stride = 2\n    cell_size = 12\n    inds = np.where(probs > threshold)\n    if inds[0].size == 0:\n        return np.array([])\n    (tx1, ty1, tx2, ty2) = [offsets[0, i, inds[0], inds[1]] for i in range(4)]\n    offsets = np.array([tx1, ty1, tx2, ty2])\n    score = probs[inds[0], inds[1]]\n    bounding_boxes = np.vstack([np.round((stride * inds[1] + 1.0) / scale), np.round((stride * inds[0] + 1.0) / scale), np.round((stride * inds[1] + 1.0 + cell_size) / scale), np.round((stride * inds[0] + 1.0 + cell_size) / scale), score, offsets])\n    return bounding_boxes.T",
            "def _generate_bboxes(probs, offsets, scale, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate bounding boxes at places\\n    where there is probably a face.\\n\\n    Arguments:\\n        probs: a float numpy array of shape [n, m].\\n        offsets: a float numpy array of shape [1, 4, n, m].\\n        scale: a float number,\\n            width and height of the image were scaled by this number.\\n        threshold: a float number.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9]\\n    '\n    stride = 2\n    cell_size = 12\n    inds = np.where(probs > threshold)\n    if inds[0].size == 0:\n        return np.array([])\n    (tx1, ty1, tx2, ty2) = [offsets[0, i, inds[0], inds[1]] for i in range(4)]\n    offsets = np.array([tx1, ty1, tx2, ty2])\n    score = probs[inds[0], inds[1]]\n    bounding_boxes = np.vstack([np.round((stride * inds[1] + 1.0) / scale), np.round((stride * inds[0] + 1.0) / scale), np.round((stride * inds[1] + 1.0 + cell_size) / scale), np.round((stride * inds[0] + 1.0 + cell_size) / scale), score, offsets])\n    return bounding_boxes.T",
            "def _generate_bboxes(probs, offsets, scale, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate bounding boxes at places\\n    where there is probably a face.\\n\\n    Arguments:\\n        probs: a float numpy array of shape [n, m].\\n        offsets: a float numpy array of shape [1, 4, n, m].\\n        scale: a float number,\\n            width and height of the image were scaled by this number.\\n        threshold: a float number.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9]\\n    '\n    stride = 2\n    cell_size = 12\n    inds = np.where(probs > threshold)\n    if inds[0].size == 0:\n        return np.array([])\n    (tx1, ty1, tx2, ty2) = [offsets[0, i, inds[0], inds[1]] for i in range(4)]\n    offsets = np.array([tx1, ty1, tx2, ty2])\n    score = probs[inds[0], inds[1]]\n    bounding_boxes = np.vstack([np.round((stride * inds[1] + 1.0) / scale), np.round((stride * inds[0] + 1.0) / scale), np.round((stride * inds[1] + 1.0 + cell_size) / scale), np.round((stride * inds[0] + 1.0 + cell_size) / scale), score, offsets])\n    return bounding_boxes.T",
            "def _generate_bboxes(probs, offsets, scale, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate bounding boxes at places\\n    where there is probably a face.\\n\\n    Arguments:\\n        probs: a float numpy array of shape [n, m].\\n        offsets: a float numpy array of shape [1, 4, n, m].\\n        scale: a float number,\\n            width and height of the image were scaled by this number.\\n        threshold: a float number.\\n\\n    Returns:\\n        a float numpy array of shape [n_boxes, 9]\\n    '\n    stride = 2\n    cell_size = 12\n    inds = np.where(probs > threshold)\n    if inds[0].size == 0:\n        return np.array([])\n    (tx1, ty1, tx2, ty2) = [offsets[0, i, inds[0], inds[1]] for i in range(4)]\n    offsets = np.array([tx1, ty1, tx2, ty2])\n    score = probs[inds[0], inds[1]]\n    bounding_boxes = np.vstack([np.round((stride * inds[1] + 1.0) / scale), np.round((stride * inds[0] + 1.0) / scale), np.round((stride * inds[1] + 1.0 + cell_size) / scale), np.round((stride * inds[0] + 1.0 + cell_size) / scale), score, offsets])\n    return bounding_boxes.T"
        ]
    }
]