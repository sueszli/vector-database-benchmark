[
    {
        "func_name": "gen_identify_duplicates",
        "original": "def gen_identify_duplicates(sheet):\n    \"\"\"\n    Takes a sheet, and returns a generator yielding a tuple for each row\n    encountered. The tuple's structure is `(row_object, is_dupe)`, where\n    is_dupe is True/False.\n\n    See note in Usage section above regarding how duplicates are determined.\n    \"\"\"\n    keyCols = sheet.keyCols\n    cols_to_check = None\n    if len(keyCols) == 0:\n        vd.warning('No key cols specified. Using all columns.')\n        cols_to_check = sheet.visibleCols\n    else:\n        cols_to_check = sheet.keyCols\n    seen = set()\n    for r in sheet.rows:\n        vals = tuple((col.getValue(r) for col in cols_to_check))\n        is_dupe = vals in seen\n        if not is_dupe:\n            seen.add(vals)\n        yield (r, is_dupe)",
        "mutated": [
            "def gen_identify_duplicates(sheet):\n    if False:\n        i = 10\n    \"\\n    Takes a sheet, and returns a generator yielding a tuple for each row\\n    encountered. The tuple's structure is `(row_object, is_dupe)`, where\\n    is_dupe is True/False.\\n\\n    See note in Usage section above regarding how duplicates are determined.\\n    \"\n    keyCols = sheet.keyCols\n    cols_to_check = None\n    if len(keyCols) == 0:\n        vd.warning('No key cols specified. Using all columns.')\n        cols_to_check = sheet.visibleCols\n    else:\n        cols_to_check = sheet.keyCols\n    seen = set()\n    for r in sheet.rows:\n        vals = tuple((col.getValue(r) for col in cols_to_check))\n        is_dupe = vals in seen\n        if not is_dupe:\n            seen.add(vals)\n        yield (r, is_dupe)",
            "def gen_identify_duplicates(sheet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Takes a sheet, and returns a generator yielding a tuple for each row\\n    encountered. The tuple's structure is `(row_object, is_dupe)`, where\\n    is_dupe is True/False.\\n\\n    See note in Usage section above regarding how duplicates are determined.\\n    \"\n    keyCols = sheet.keyCols\n    cols_to_check = None\n    if len(keyCols) == 0:\n        vd.warning('No key cols specified. Using all columns.')\n        cols_to_check = sheet.visibleCols\n    else:\n        cols_to_check = sheet.keyCols\n    seen = set()\n    for r in sheet.rows:\n        vals = tuple((col.getValue(r) for col in cols_to_check))\n        is_dupe = vals in seen\n        if not is_dupe:\n            seen.add(vals)\n        yield (r, is_dupe)",
            "def gen_identify_duplicates(sheet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Takes a sheet, and returns a generator yielding a tuple for each row\\n    encountered. The tuple's structure is `(row_object, is_dupe)`, where\\n    is_dupe is True/False.\\n\\n    See note in Usage section above regarding how duplicates are determined.\\n    \"\n    keyCols = sheet.keyCols\n    cols_to_check = None\n    if len(keyCols) == 0:\n        vd.warning('No key cols specified. Using all columns.')\n        cols_to_check = sheet.visibleCols\n    else:\n        cols_to_check = sheet.keyCols\n    seen = set()\n    for r in sheet.rows:\n        vals = tuple((col.getValue(r) for col in cols_to_check))\n        is_dupe = vals in seen\n        if not is_dupe:\n            seen.add(vals)\n        yield (r, is_dupe)",
            "def gen_identify_duplicates(sheet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Takes a sheet, and returns a generator yielding a tuple for each row\\n    encountered. The tuple's structure is `(row_object, is_dupe)`, where\\n    is_dupe is True/False.\\n\\n    See note in Usage section above regarding how duplicates are determined.\\n    \"\n    keyCols = sheet.keyCols\n    cols_to_check = None\n    if len(keyCols) == 0:\n        vd.warning('No key cols specified. Using all columns.')\n        cols_to_check = sheet.visibleCols\n    else:\n        cols_to_check = sheet.keyCols\n    seen = set()\n    for r in sheet.rows:\n        vals = tuple((col.getValue(r) for col in cols_to_check))\n        is_dupe = vals in seen\n        if not is_dupe:\n            seen.add(vals)\n        yield (r, is_dupe)",
            "def gen_identify_duplicates(sheet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Takes a sheet, and returns a generator yielding a tuple for each row\\n    encountered. The tuple's structure is `(row_object, is_dupe)`, where\\n    is_dupe is True/False.\\n\\n    See note in Usage section above regarding how duplicates are determined.\\n    \"\n    keyCols = sheet.keyCols\n    cols_to_check = None\n    if len(keyCols) == 0:\n        vd.warning('No key cols specified. Using all columns.')\n        cols_to_check = sheet.visibleCols\n    else:\n        cols_to_check = sheet.keyCols\n    seen = set()\n    for r in sheet.rows:\n        vals = tuple((col.getValue(r) for col in cols_to_check))\n        is_dupe = vals in seen\n        if not is_dupe:\n            seen.add(vals)\n        yield (r, is_dupe)"
        ]
    },
    {
        "func_name": "select_duplicate_rows",
        "original": "@Sheet.api\n@asyncthread\ndef select_duplicate_rows(sheet, duplicates=True):\n    \"\"\"\n    Given a sheet, sets the selection status in VisiData to `selected` for each\n    row that is a duplicate of a prior row.\n\n    If `duplicates = False`, then the behavior is reversed; sets the selection\n    status to `selected` for each row that is *not* a duplicate.\n    \"\"\"\n    before = len(sheet.selectedRows)\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='selecting', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if is_dupe == duplicates:\n            sheet.selectRow(row)\n    sel_count = len(sheet.selectedRows) - before\n    more_str = ' more' if before > 0 else ''\n    vd.status(f'selected {sel_count}{more_str} {sheet.rowtype}')",
        "mutated": [
            "@Sheet.api\n@asyncthread\ndef select_duplicate_rows(sheet, duplicates=True):\n    if False:\n        i = 10\n    '\\n    Given a sheet, sets the selection status in VisiData to `selected` for each\\n    row that is a duplicate of a prior row.\\n\\n    If `duplicates = False`, then the behavior is reversed; sets the selection\\n    status to `selected` for each row that is *not* a duplicate.\\n    '\n    before = len(sheet.selectedRows)\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='selecting', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if is_dupe == duplicates:\n            sheet.selectRow(row)\n    sel_count = len(sheet.selectedRows) - before\n    more_str = ' more' if before > 0 else ''\n    vd.status(f'selected {sel_count}{more_str} {sheet.rowtype}')",
            "@Sheet.api\n@asyncthread\ndef select_duplicate_rows(sheet, duplicates=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given a sheet, sets the selection status in VisiData to `selected` for each\\n    row that is a duplicate of a prior row.\\n\\n    If `duplicates = False`, then the behavior is reversed; sets the selection\\n    status to `selected` for each row that is *not* a duplicate.\\n    '\n    before = len(sheet.selectedRows)\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='selecting', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if is_dupe == duplicates:\n            sheet.selectRow(row)\n    sel_count = len(sheet.selectedRows) - before\n    more_str = ' more' if before > 0 else ''\n    vd.status(f'selected {sel_count}{more_str} {sheet.rowtype}')",
            "@Sheet.api\n@asyncthread\ndef select_duplicate_rows(sheet, duplicates=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given a sheet, sets the selection status in VisiData to `selected` for each\\n    row that is a duplicate of a prior row.\\n\\n    If `duplicates = False`, then the behavior is reversed; sets the selection\\n    status to `selected` for each row that is *not* a duplicate.\\n    '\n    before = len(sheet.selectedRows)\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='selecting', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if is_dupe == duplicates:\n            sheet.selectRow(row)\n    sel_count = len(sheet.selectedRows) - before\n    more_str = ' more' if before > 0 else ''\n    vd.status(f'selected {sel_count}{more_str} {sheet.rowtype}')",
            "@Sheet.api\n@asyncthread\ndef select_duplicate_rows(sheet, duplicates=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given a sheet, sets the selection status in VisiData to `selected` for each\\n    row that is a duplicate of a prior row.\\n\\n    If `duplicates = False`, then the behavior is reversed; sets the selection\\n    status to `selected` for each row that is *not* a duplicate.\\n    '\n    before = len(sheet.selectedRows)\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='selecting', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if is_dupe == duplicates:\n            sheet.selectRow(row)\n    sel_count = len(sheet.selectedRows) - before\n    more_str = ' more' if before > 0 else ''\n    vd.status(f'selected {sel_count}{more_str} {sheet.rowtype}')",
            "@Sheet.api\n@asyncthread\ndef select_duplicate_rows(sheet, duplicates=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given a sheet, sets the selection status in VisiData to `selected` for each\\n    row that is a duplicate of a prior row.\\n\\n    If `duplicates = False`, then the behavior is reversed; sets the selection\\n    status to `selected` for each row that is *not* a duplicate.\\n    '\n    before = len(sheet.selectedRows)\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='selecting', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if is_dupe == duplicates:\n            sheet.selectRow(row)\n    sel_count = len(sheet.selectedRows) - before\n    more_str = ' more' if before > 0 else ''\n    vd.status(f'selected {sel_count}{more_str} {sheet.rowtype}')"
        ]
    },
    {
        "func_name": "_reload",
        "original": "@asyncthread\ndef _reload(self=vs):\n    self.rows = []\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if not is_dupe:\n            self.addRow(row)",
        "mutated": [
            "@asyncthread\ndef _reload(self=vs):\n    if False:\n        i = 10\n    self.rows = []\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if not is_dupe:\n            self.addRow(row)",
            "@asyncthread\ndef _reload(self=vs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.rows = []\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if not is_dupe:\n            self.addRow(row)",
            "@asyncthread\ndef _reload(self=vs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.rows = []\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if not is_dupe:\n            self.addRow(row)",
            "@asyncthread\ndef _reload(self=vs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.rows = []\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if not is_dupe:\n            self.addRow(row)",
            "@asyncthread\ndef _reload(self=vs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.rows = []\n    gen = gen_identify_duplicates(sheet)\n    prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n    for (row, is_dupe) in prog:\n        if not is_dupe:\n            self.addRow(row)"
        ]
    },
    {
        "func_name": "dedupe_rows",
        "original": "@Sheet.api\ndef dedupe_rows(sheet):\n    \"\"\"\n    Given a sheet, pushes a new sheet in which only non-duplicate rows are\n    included.\n    \"\"\"\n    vs = copy(sheet)\n    vs.name += '_deduped'\n\n    @asyncthread\n    def _reload(self=vs):\n        self.rows = []\n        gen = gen_identify_duplicates(sheet)\n        prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n        for (row, is_dupe) in prog:\n            if not is_dupe:\n                self.addRow(row)\n    vs.reload = _reload\n    return vs",
        "mutated": [
            "@Sheet.api\ndef dedupe_rows(sheet):\n    if False:\n        i = 10\n    '\\n    Given a sheet, pushes a new sheet in which only non-duplicate rows are\\n    included.\\n    '\n    vs = copy(sheet)\n    vs.name += '_deduped'\n\n    @asyncthread\n    def _reload(self=vs):\n        self.rows = []\n        gen = gen_identify_duplicates(sheet)\n        prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n        for (row, is_dupe) in prog:\n            if not is_dupe:\n                self.addRow(row)\n    vs.reload = _reload\n    return vs",
            "@Sheet.api\ndef dedupe_rows(sheet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given a sheet, pushes a new sheet in which only non-duplicate rows are\\n    included.\\n    '\n    vs = copy(sheet)\n    vs.name += '_deduped'\n\n    @asyncthread\n    def _reload(self=vs):\n        self.rows = []\n        gen = gen_identify_duplicates(sheet)\n        prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n        for (row, is_dupe) in prog:\n            if not is_dupe:\n                self.addRow(row)\n    vs.reload = _reload\n    return vs",
            "@Sheet.api\ndef dedupe_rows(sheet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given a sheet, pushes a new sheet in which only non-duplicate rows are\\n    included.\\n    '\n    vs = copy(sheet)\n    vs.name += '_deduped'\n\n    @asyncthread\n    def _reload(self=vs):\n        self.rows = []\n        gen = gen_identify_duplicates(sheet)\n        prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n        for (row, is_dupe) in prog:\n            if not is_dupe:\n                self.addRow(row)\n    vs.reload = _reload\n    return vs",
            "@Sheet.api\ndef dedupe_rows(sheet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given a sheet, pushes a new sheet in which only non-duplicate rows are\\n    included.\\n    '\n    vs = copy(sheet)\n    vs.name += '_deduped'\n\n    @asyncthread\n    def _reload(self=vs):\n        self.rows = []\n        gen = gen_identify_duplicates(sheet)\n        prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n        for (row, is_dupe) in prog:\n            if not is_dupe:\n                self.addRow(row)\n    vs.reload = _reload\n    return vs",
            "@Sheet.api\ndef dedupe_rows(sheet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given a sheet, pushes a new sheet in which only non-duplicate rows are\\n    included.\\n    '\n    vs = copy(sheet)\n    vs.name += '_deduped'\n\n    @asyncthread\n    def _reload(self=vs):\n        self.rows = []\n        gen = gen_identify_duplicates(sheet)\n        prog = Progress(gen, gerund='deduplicating', total=sheet.nRows)\n        for (row, is_dupe) in prog:\n            if not is_dupe:\n                self.addRow(row)\n    vs.reload = _reload\n    return vs"
        ]
    }
]