[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.baidu = 'http://zhidao.baidu.com/search?'\n    self.api = 'https://api-spe-ttl.ixigua.com/xxxxxxx={}'.format(int(time.time() * 1000))",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.baidu = 'http://zhidao.baidu.com/search?'\n    self.api = 'https://api-spe-ttl.ixigua.com/xxxxxxx={}'.format(int(time.time() * 1000))",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.baidu = 'http://zhidao.baidu.com/search?'\n    self.api = 'https://api-spe-ttl.ixigua.com/xxxxxxx={}'.format(int(time.time() * 1000))",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.baidu = 'http://zhidao.baidu.com/search?'\n    self.api = 'https://api-spe-ttl.ixigua.com/xxxxxxx={}'.format(int(time.time() * 1000))",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.baidu = 'http://zhidao.baidu.com/search?'\n    self.api = 'https://api-spe-ttl.ixigua.com/xxxxxxx={}'.format(int(time.time() * 1000))",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.baidu = 'http://zhidao.baidu.com/search?'\n    self.api = 'https://api-spe-ttl.ixigua.com/xxxxxxx={}'.format(int(time.time() * 1000))"
        ]
    },
    {
        "func_name": "get_question",
        "original": "def get_question(self):\n    to = True\n    while to:\n        list_dir = os.listdir('./')\n        if 'question.txt' not in list_dir:\n            fw = open('question.txt', 'w')\n            fw.write('\u767e\u4e07\u82f1\u96c4\u5c1a\u672a\u51fa\u9898\u8bf7\u7a0d\u540e!')\n            fw.close()\n        go = True\n        while go:\n            req = requests.get(self.api, verify=False)\n            req.encoding = 'utf-8'\n            html = req.text\n            print(html)\n            if '*' in html:\n                question_start = html.index('*')\n                try:\n                    question_end = html.index('\uff1f')\n                except:\n                    question_end = html.index('?')\n                question = html[question_start:question_end][2:]\n                if question != None:\n                    fr = open('question.txt', 'r')\n                    text = fr.readline()\n                    fr.close()\n                    if text != question:\n                        print(question)\n                        go = False\n                        with open('question.txt', 'w') as f:\n                            f.write(question)\n                    else:\n                        time.sleep(1)\n                else:\n                    to = False\n            else:\n                to = False\n        temp = re.findall('[\\\\u4e00-\\\\u9fa5a-zA-Z0-9\\\\+\\\\-\\\\*/]', html[question_end + 1:])\n        b_index = []\n        print(temp)\n        for (index, each) in enumerate(temp):\n            if each == 'B':\n                b_index.append(index)\n            elif each == 'P' and len(temp) - index <= 3:\n                b_index.append(index)\n                break\n        if len(b_index) == 4:\n            a = ''.join(temp[b_index[0] + 1:b_index[1]])\n            b = ''.join(temp[b_index[1] + 1:b_index[2]])\n            c = ''.join(temp[b_index[2] + 1:b_index[3]])\n            alternative_answers = [a, b, c]\n            if '\u4e0b\u5217' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4e0b\u5217', '')\n            elif '\u4ee5\u4e0b' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4ee5\u4e0b', '')\n        else:\n            alternative_answers = []\n        self.search(question, alternative_answers)\n        time.sleep(1)",
        "mutated": [
            "def get_question(self):\n    if False:\n        i = 10\n    to = True\n    while to:\n        list_dir = os.listdir('./')\n        if 'question.txt' not in list_dir:\n            fw = open('question.txt', 'w')\n            fw.write('\u767e\u4e07\u82f1\u96c4\u5c1a\u672a\u51fa\u9898\u8bf7\u7a0d\u540e!')\n            fw.close()\n        go = True\n        while go:\n            req = requests.get(self.api, verify=False)\n            req.encoding = 'utf-8'\n            html = req.text\n            print(html)\n            if '*' in html:\n                question_start = html.index('*')\n                try:\n                    question_end = html.index('\uff1f')\n                except:\n                    question_end = html.index('?')\n                question = html[question_start:question_end][2:]\n                if question != None:\n                    fr = open('question.txt', 'r')\n                    text = fr.readline()\n                    fr.close()\n                    if text != question:\n                        print(question)\n                        go = False\n                        with open('question.txt', 'w') as f:\n                            f.write(question)\n                    else:\n                        time.sleep(1)\n                else:\n                    to = False\n            else:\n                to = False\n        temp = re.findall('[\\\\u4e00-\\\\u9fa5a-zA-Z0-9\\\\+\\\\-\\\\*/]', html[question_end + 1:])\n        b_index = []\n        print(temp)\n        for (index, each) in enumerate(temp):\n            if each == 'B':\n                b_index.append(index)\n            elif each == 'P' and len(temp) - index <= 3:\n                b_index.append(index)\n                break\n        if len(b_index) == 4:\n            a = ''.join(temp[b_index[0] + 1:b_index[1]])\n            b = ''.join(temp[b_index[1] + 1:b_index[2]])\n            c = ''.join(temp[b_index[2] + 1:b_index[3]])\n            alternative_answers = [a, b, c]\n            if '\u4e0b\u5217' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4e0b\u5217', '')\n            elif '\u4ee5\u4e0b' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4ee5\u4e0b', '')\n        else:\n            alternative_answers = []\n        self.search(question, alternative_answers)\n        time.sleep(1)",
            "def get_question(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    to = True\n    while to:\n        list_dir = os.listdir('./')\n        if 'question.txt' not in list_dir:\n            fw = open('question.txt', 'w')\n            fw.write('\u767e\u4e07\u82f1\u96c4\u5c1a\u672a\u51fa\u9898\u8bf7\u7a0d\u540e!')\n            fw.close()\n        go = True\n        while go:\n            req = requests.get(self.api, verify=False)\n            req.encoding = 'utf-8'\n            html = req.text\n            print(html)\n            if '*' in html:\n                question_start = html.index('*')\n                try:\n                    question_end = html.index('\uff1f')\n                except:\n                    question_end = html.index('?')\n                question = html[question_start:question_end][2:]\n                if question != None:\n                    fr = open('question.txt', 'r')\n                    text = fr.readline()\n                    fr.close()\n                    if text != question:\n                        print(question)\n                        go = False\n                        with open('question.txt', 'w') as f:\n                            f.write(question)\n                    else:\n                        time.sleep(1)\n                else:\n                    to = False\n            else:\n                to = False\n        temp = re.findall('[\\\\u4e00-\\\\u9fa5a-zA-Z0-9\\\\+\\\\-\\\\*/]', html[question_end + 1:])\n        b_index = []\n        print(temp)\n        for (index, each) in enumerate(temp):\n            if each == 'B':\n                b_index.append(index)\n            elif each == 'P' and len(temp) - index <= 3:\n                b_index.append(index)\n                break\n        if len(b_index) == 4:\n            a = ''.join(temp[b_index[0] + 1:b_index[1]])\n            b = ''.join(temp[b_index[1] + 1:b_index[2]])\n            c = ''.join(temp[b_index[2] + 1:b_index[3]])\n            alternative_answers = [a, b, c]\n            if '\u4e0b\u5217' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4e0b\u5217', '')\n            elif '\u4ee5\u4e0b' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4ee5\u4e0b', '')\n        else:\n            alternative_answers = []\n        self.search(question, alternative_answers)\n        time.sleep(1)",
            "def get_question(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    to = True\n    while to:\n        list_dir = os.listdir('./')\n        if 'question.txt' not in list_dir:\n            fw = open('question.txt', 'w')\n            fw.write('\u767e\u4e07\u82f1\u96c4\u5c1a\u672a\u51fa\u9898\u8bf7\u7a0d\u540e!')\n            fw.close()\n        go = True\n        while go:\n            req = requests.get(self.api, verify=False)\n            req.encoding = 'utf-8'\n            html = req.text\n            print(html)\n            if '*' in html:\n                question_start = html.index('*')\n                try:\n                    question_end = html.index('\uff1f')\n                except:\n                    question_end = html.index('?')\n                question = html[question_start:question_end][2:]\n                if question != None:\n                    fr = open('question.txt', 'r')\n                    text = fr.readline()\n                    fr.close()\n                    if text != question:\n                        print(question)\n                        go = False\n                        with open('question.txt', 'w') as f:\n                            f.write(question)\n                    else:\n                        time.sleep(1)\n                else:\n                    to = False\n            else:\n                to = False\n        temp = re.findall('[\\\\u4e00-\\\\u9fa5a-zA-Z0-9\\\\+\\\\-\\\\*/]', html[question_end + 1:])\n        b_index = []\n        print(temp)\n        for (index, each) in enumerate(temp):\n            if each == 'B':\n                b_index.append(index)\n            elif each == 'P' and len(temp) - index <= 3:\n                b_index.append(index)\n                break\n        if len(b_index) == 4:\n            a = ''.join(temp[b_index[0] + 1:b_index[1]])\n            b = ''.join(temp[b_index[1] + 1:b_index[2]])\n            c = ''.join(temp[b_index[2] + 1:b_index[3]])\n            alternative_answers = [a, b, c]\n            if '\u4e0b\u5217' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4e0b\u5217', '')\n            elif '\u4ee5\u4e0b' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4ee5\u4e0b', '')\n        else:\n            alternative_answers = []\n        self.search(question, alternative_answers)\n        time.sleep(1)",
            "def get_question(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    to = True\n    while to:\n        list_dir = os.listdir('./')\n        if 'question.txt' not in list_dir:\n            fw = open('question.txt', 'w')\n            fw.write('\u767e\u4e07\u82f1\u96c4\u5c1a\u672a\u51fa\u9898\u8bf7\u7a0d\u540e!')\n            fw.close()\n        go = True\n        while go:\n            req = requests.get(self.api, verify=False)\n            req.encoding = 'utf-8'\n            html = req.text\n            print(html)\n            if '*' in html:\n                question_start = html.index('*')\n                try:\n                    question_end = html.index('\uff1f')\n                except:\n                    question_end = html.index('?')\n                question = html[question_start:question_end][2:]\n                if question != None:\n                    fr = open('question.txt', 'r')\n                    text = fr.readline()\n                    fr.close()\n                    if text != question:\n                        print(question)\n                        go = False\n                        with open('question.txt', 'w') as f:\n                            f.write(question)\n                    else:\n                        time.sleep(1)\n                else:\n                    to = False\n            else:\n                to = False\n        temp = re.findall('[\\\\u4e00-\\\\u9fa5a-zA-Z0-9\\\\+\\\\-\\\\*/]', html[question_end + 1:])\n        b_index = []\n        print(temp)\n        for (index, each) in enumerate(temp):\n            if each == 'B':\n                b_index.append(index)\n            elif each == 'P' and len(temp) - index <= 3:\n                b_index.append(index)\n                break\n        if len(b_index) == 4:\n            a = ''.join(temp[b_index[0] + 1:b_index[1]])\n            b = ''.join(temp[b_index[1] + 1:b_index[2]])\n            c = ''.join(temp[b_index[2] + 1:b_index[3]])\n            alternative_answers = [a, b, c]\n            if '\u4e0b\u5217' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4e0b\u5217', '')\n            elif '\u4ee5\u4e0b' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4ee5\u4e0b', '')\n        else:\n            alternative_answers = []\n        self.search(question, alternative_answers)\n        time.sleep(1)",
            "def get_question(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    to = True\n    while to:\n        list_dir = os.listdir('./')\n        if 'question.txt' not in list_dir:\n            fw = open('question.txt', 'w')\n            fw.write('\u767e\u4e07\u82f1\u96c4\u5c1a\u672a\u51fa\u9898\u8bf7\u7a0d\u540e!')\n            fw.close()\n        go = True\n        while go:\n            req = requests.get(self.api, verify=False)\n            req.encoding = 'utf-8'\n            html = req.text\n            print(html)\n            if '*' in html:\n                question_start = html.index('*')\n                try:\n                    question_end = html.index('\uff1f')\n                except:\n                    question_end = html.index('?')\n                question = html[question_start:question_end][2:]\n                if question != None:\n                    fr = open('question.txt', 'r')\n                    text = fr.readline()\n                    fr.close()\n                    if text != question:\n                        print(question)\n                        go = False\n                        with open('question.txt', 'w') as f:\n                            f.write(question)\n                    else:\n                        time.sleep(1)\n                else:\n                    to = False\n            else:\n                to = False\n        temp = re.findall('[\\\\u4e00-\\\\u9fa5a-zA-Z0-9\\\\+\\\\-\\\\*/]', html[question_end + 1:])\n        b_index = []\n        print(temp)\n        for (index, each) in enumerate(temp):\n            if each == 'B':\n                b_index.append(index)\n            elif each == 'P' and len(temp) - index <= 3:\n                b_index.append(index)\n                break\n        if len(b_index) == 4:\n            a = ''.join(temp[b_index[0] + 1:b_index[1]])\n            b = ''.join(temp[b_index[1] + 1:b_index[2]])\n            c = ''.join(temp[b_index[2] + 1:b_index[3]])\n            alternative_answers = [a, b, c]\n            if '\u4e0b\u5217' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4e0b\u5217', '')\n            elif '\u4ee5\u4e0b' in question:\n                question = a + ' ' + b + ' ' + c + ' ' + question.replace('\u4ee5\u4e0b', '')\n        else:\n            alternative_answers = []\n        self.search(question, alternative_answers)\n        time.sleep(1)"
        ]
    },
    {
        "func_name": "search",
        "original": "def search(self, question, alternative_answers):\n    print(question)\n    print(alternative_answers)\n    infos = {'word': question}\n    url = self.baidu + 'lm=0&rn=10&pn=0&fr=search&ie=gbk&' + urllib.parse.urlencode(infos, encoding='GB2312')\n    print(url)\n    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36'}\n    sess = requests.Session()\n    req = sess.get(url=url, headers=headers, verify=False)\n    req.encoding = 'gbk'\n    bf = BeautifulSoup(req.text, 'lxml')\n    answers = bf.find_all('dd', class_='dd answer')\n    for answer in answers:\n        print(answer.text)\n    recommend = ''\n    if alternative_answers != []:\n        best = []\n        print('\\n')\n        for answer in answers:\n            for each_answer in alternative_answers:\n                if each_answer in answer.text:\n                    best.append(each_answer)\n                    print(each_answer, end=' ')\n                    print('\\n')\n                    break\n        statistics = {}\n        for each in best:\n            if each not in statistics.keys():\n                statistics[each] = 1\n            else:\n                statistics[each] += 1\n        errors = ['\u6ca1\u6709', '\u4e0d\u662f', '\u4e0d\u5bf9', '\u4e0d\u6b63\u786e', '\u9519\u8bef', '\u4e0d\u5305\u62ec', '\u4e0d\u5305\u542b', '\u4e0d\u5728', '\u9519']\n        error_list = list(map(lambda x: x in question, errors))\n        print(error_list)\n        if sum(error_list) >= 1:\n            for each_answer in alternative_answers:\n                if each_answer not in statistics.items():\n                    recommend = each_answer\n                    print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n                    break\n        elif statistics != {}:\n            recommend = sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0]\n            print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n    with open('file.txt', 'w') as f:\n        f.write('\u95ee\u9898\uff1a' + question)\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if alternative_answers != []:\n            f.write('\u9009\u9879\uff1a')\n            for i in range(len(alternative_answers)):\n                f.write(alternative_answers[i])\n                f.write('  ')\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        f.write('\u53c2\u8003\u7b54\u6848\uff1a\\n')\n        for answer in answers:\n            f.write(answer.text)\n            f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if recommend != '':\n            f.write('\u6700\u7ec8\u7b54\u6848\u8bf7\u81ea\u884c\u659f\u914c\uff01\\t')\n            f.write('\u63a8\u8350\u7b54\u6848\uff1a' + sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0])",
        "mutated": [
            "def search(self, question, alternative_answers):\n    if False:\n        i = 10\n    print(question)\n    print(alternative_answers)\n    infos = {'word': question}\n    url = self.baidu + 'lm=0&rn=10&pn=0&fr=search&ie=gbk&' + urllib.parse.urlencode(infos, encoding='GB2312')\n    print(url)\n    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36'}\n    sess = requests.Session()\n    req = sess.get(url=url, headers=headers, verify=False)\n    req.encoding = 'gbk'\n    bf = BeautifulSoup(req.text, 'lxml')\n    answers = bf.find_all('dd', class_='dd answer')\n    for answer in answers:\n        print(answer.text)\n    recommend = ''\n    if alternative_answers != []:\n        best = []\n        print('\\n')\n        for answer in answers:\n            for each_answer in alternative_answers:\n                if each_answer in answer.text:\n                    best.append(each_answer)\n                    print(each_answer, end=' ')\n                    print('\\n')\n                    break\n        statistics = {}\n        for each in best:\n            if each not in statistics.keys():\n                statistics[each] = 1\n            else:\n                statistics[each] += 1\n        errors = ['\u6ca1\u6709', '\u4e0d\u662f', '\u4e0d\u5bf9', '\u4e0d\u6b63\u786e', '\u9519\u8bef', '\u4e0d\u5305\u62ec', '\u4e0d\u5305\u542b', '\u4e0d\u5728', '\u9519']\n        error_list = list(map(lambda x: x in question, errors))\n        print(error_list)\n        if sum(error_list) >= 1:\n            for each_answer in alternative_answers:\n                if each_answer not in statistics.items():\n                    recommend = each_answer\n                    print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n                    break\n        elif statistics != {}:\n            recommend = sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0]\n            print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n    with open('file.txt', 'w') as f:\n        f.write('\u95ee\u9898\uff1a' + question)\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if alternative_answers != []:\n            f.write('\u9009\u9879\uff1a')\n            for i in range(len(alternative_answers)):\n                f.write(alternative_answers[i])\n                f.write('  ')\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        f.write('\u53c2\u8003\u7b54\u6848\uff1a\\n')\n        for answer in answers:\n            f.write(answer.text)\n            f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if recommend != '':\n            f.write('\u6700\u7ec8\u7b54\u6848\u8bf7\u81ea\u884c\u659f\u914c\uff01\\t')\n            f.write('\u63a8\u8350\u7b54\u6848\uff1a' + sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0])",
            "def search(self, question, alternative_answers):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print(question)\n    print(alternative_answers)\n    infos = {'word': question}\n    url = self.baidu + 'lm=0&rn=10&pn=0&fr=search&ie=gbk&' + urllib.parse.urlencode(infos, encoding='GB2312')\n    print(url)\n    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36'}\n    sess = requests.Session()\n    req = sess.get(url=url, headers=headers, verify=False)\n    req.encoding = 'gbk'\n    bf = BeautifulSoup(req.text, 'lxml')\n    answers = bf.find_all('dd', class_='dd answer')\n    for answer in answers:\n        print(answer.text)\n    recommend = ''\n    if alternative_answers != []:\n        best = []\n        print('\\n')\n        for answer in answers:\n            for each_answer in alternative_answers:\n                if each_answer in answer.text:\n                    best.append(each_answer)\n                    print(each_answer, end=' ')\n                    print('\\n')\n                    break\n        statistics = {}\n        for each in best:\n            if each not in statistics.keys():\n                statistics[each] = 1\n            else:\n                statistics[each] += 1\n        errors = ['\u6ca1\u6709', '\u4e0d\u662f', '\u4e0d\u5bf9', '\u4e0d\u6b63\u786e', '\u9519\u8bef', '\u4e0d\u5305\u62ec', '\u4e0d\u5305\u542b', '\u4e0d\u5728', '\u9519']\n        error_list = list(map(lambda x: x in question, errors))\n        print(error_list)\n        if sum(error_list) >= 1:\n            for each_answer in alternative_answers:\n                if each_answer not in statistics.items():\n                    recommend = each_answer\n                    print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n                    break\n        elif statistics != {}:\n            recommend = sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0]\n            print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n    with open('file.txt', 'w') as f:\n        f.write('\u95ee\u9898\uff1a' + question)\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if alternative_answers != []:\n            f.write('\u9009\u9879\uff1a')\n            for i in range(len(alternative_answers)):\n                f.write(alternative_answers[i])\n                f.write('  ')\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        f.write('\u53c2\u8003\u7b54\u6848\uff1a\\n')\n        for answer in answers:\n            f.write(answer.text)\n            f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if recommend != '':\n            f.write('\u6700\u7ec8\u7b54\u6848\u8bf7\u81ea\u884c\u659f\u914c\uff01\\t')\n            f.write('\u63a8\u8350\u7b54\u6848\uff1a' + sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0])",
            "def search(self, question, alternative_answers):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print(question)\n    print(alternative_answers)\n    infos = {'word': question}\n    url = self.baidu + 'lm=0&rn=10&pn=0&fr=search&ie=gbk&' + urllib.parse.urlencode(infos, encoding='GB2312')\n    print(url)\n    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36'}\n    sess = requests.Session()\n    req = sess.get(url=url, headers=headers, verify=False)\n    req.encoding = 'gbk'\n    bf = BeautifulSoup(req.text, 'lxml')\n    answers = bf.find_all('dd', class_='dd answer')\n    for answer in answers:\n        print(answer.text)\n    recommend = ''\n    if alternative_answers != []:\n        best = []\n        print('\\n')\n        for answer in answers:\n            for each_answer in alternative_answers:\n                if each_answer in answer.text:\n                    best.append(each_answer)\n                    print(each_answer, end=' ')\n                    print('\\n')\n                    break\n        statistics = {}\n        for each in best:\n            if each not in statistics.keys():\n                statistics[each] = 1\n            else:\n                statistics[each] += 1\n        errors = ['\u6ca1\u6709', '\u4e0d\u662f', '\u4e0d\u5bf9', '\u4e0d\u6b63\u786e', '\u9519\u8bef', '\u4e0d\u5305\u62ec', '\u4e0d\u5305\u542b', '\u4e0d\u5728', '\u9519']\n        error_list = list(map(lambda x: x in question, errors))\n        print(error_list)\n        if sum(error_list) >= 1:\n            for each_answer in alternative_answers:\n                if each_answer not in statistics.items():\n                    recommend = each_answer\n                    print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n                    break\n        elif statistics != {}:\n            recommend = sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0]\n            print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n    with open('file.txt', 'w') as f:\n        f.write('\u95ee\u9898\uff1a' + question)\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if alternative_answers != []:\n            f.write('\u9009\u9879\uff1a')\n            for i in range(len(alternative_answers)):\n                f.write(alternative_answers[i])\n                f.write('  ')\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        f.write('\u53c2\u8003\u7b54\u6848\uff1a\\n')\n        for answer in answers:\n            f.write(answer.text)\n            f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if recommend != '':\n            f.write('\u6700\u7ec8\u7b54\u6848\u8bf7\u81ea\u884c\u659f\u914c\uff01\\t')\n            f.write('\u63a8\u8350\u7b54\u6848\uff1a' + sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0])",
            "def search(self, question, alternative_answers):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print(question)\n    print(alternative_answers)\n    infos = {'word': question}\n    url = self.baidu + 'lm=0&rn=10&pn=0&fr=search&ie=gbk&' + urllib.parse.urlencode(infos, encoding='GB2312')\n    print(url)\n    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36'}\n    sess = requests.Session()\n    req = sess.get(url=url, headers=headers, verify=False)\n    req.encoding = 'gbk'\n    bf = BeautifulSoup(req.text, 'lxml')\n    answers = bf.find_all('dd', class_='dd answer')\n    for answer in answers:\n        print(answer.text)\n    recommend = ''\n    if alternative_answers != []:\n        best = []\n        print('\\n')\n        for answer in answers:\n            for each_answer in alternative_answers:\n                if each_answer in answer.text:\n                    best.append(each_answer)\n                    print(each_answer, end=' ')\n                    print('\\n')\n                    break\n        statistics = {}\n        for each in best:\n            if each not in statistics.keys():\n                statistics[each] = 1\n            else:\n                statistics[each] += 1\n        errors = ['\u6ca1\u6709', '\u4e0d\u662f', '\u4e0d\u5bf9', '\u4e0d\u6b63\u786e', '\u9519\u8bef', '\u4e0d\u5305\u62ec', '\u4e0d\u5305\u542b', '\u4e0d\u5728', '\u9519']\n        error_list = list(map(lambda x: x in question, errors))\n        print(error_list)\n        if sum(error_list) >= 1:\n            for each_answer in alternative_answers:\n                if each_answer not in statistics.items():\n                    recommend = each_answer\n                    print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n                    break\n        elif statistics != {}:\n            recommend = sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0]\n            print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n    with open('file.txt', 'w') as f:\n        f.write('\u95ee\u9898\uff1a' + question)\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if alternative_answers != []:\n            f.write('\u9009\u9879\uff1a')\n            for i in range(len(alternative_answers)):\n                f.write(alternative_answers[i])\n                f.write('  ')\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        f.write('\u53c2\u8003\u7b54\u6848\uff1a\\n')\n        for answer in answers:\n            f.write(answer.text)\n            f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if recommend != '':\n            f.write('\u6700\u7ec8\u7b54\u6848\u8bf7\u81ea\u884c\u659f\u914c\uff01\\t')\n            f.write('\u63a8\u8350\u7b54\u6848\uff1a' + sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0])",
            "def search(self, question, alternative_answers):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print(question)\n    print(alternative_answers)\n    infos = {'word': question}\n    url = self.baidu + 'lm=0&rn=10&pn=0&fr=search&ie=gbk&' + urllib.parse.urlencode(infos, encoding='GB2312')\n    print(url)\n    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36'}\n    sess = requests.Session()\n    req = sess.get(url=url, headers=headers, verify=False)\n    req.encoding = 'gbk'\n    bf = BeautifulSoup(req.text, 'lxml')\n    answers = bf.find_all('dd', class_='dd answer')\n    for answer in answers:\n        print(answer.text)\n    recommend = ''\n    if alternative_answers != []:\n        best = []\n        print('\\n')\n        for answer in answers:\n            for each_answer in alternative_answers:\n                if each_answer in answer.text:\n                    best.append(each_answer)\n                    print(each_answer, end=' ')\n                    print('\\n')\n                    break\n        statistics = {}\n        for each in best:\n            if each not in statistics.keys():\n                statistics[each] = 1\n            else:\n                statistics[each] += 1\n        errors = ['\u6ca1\u6709', '\u4e0d\u662f', '\u4e0d\u5bf9', '\u4e0d\u6b63\u786e', '\u9519\u8bef', '\u4e0d\u5305\u62ec', '\u4e0d\u5305\u542b', '\u4e0d\u5728', '\u9519']\n        error_list = list(map(lambda x: x in question, errors))\n        print(error_list)\n        if sum(error_list) >= 1:\n            for each_answer in alternative_answers:\n                if each_answer not in statistics.items():\n                    recommend = each_answer\n                    print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n                    break\n        elif statistics != {}:\n            recommend = sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0]\n            print('\u63a8\u8350\u7b54\u6848\uff1a', recommend)\n    with open('file.txt', 'w') as f:\n        f.write('\u95ee\u9898\uff1a' + question)\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if alternative_answers != []:\n            f.write('\u9009\u9879\uff1a')\n            for i in range(len(alternative_answers)):\n                f.write(alternative_answers[i])\n                f.write('  ')\n        f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        f.write('\u53c2\u8003\u7b54\u6848\uff1a\\n')\n        for answer in answers:\n            f.write(answer.text)\n            f.write('\\n')\n        f.write('*' * 50)\n        f.write('\\n')\n        if recommend != '':\n            f.write('\u6700\u7ec8\u7b54\u6848\u8bf7\u81ea\u884c\u659f\u914c\uff01\\t')\n            f.write('\u63a8\u8350\u7b54\u6848\uff1a' + sorted(statistics.items(), key=lambda e: e[1], reverse=True)[0][0])"
        ]
    }
]