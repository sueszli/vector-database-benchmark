"""
    Agent Communication Protocol

    Specification of the API protocol for communication with an agent.  # noqa: E501

    The version of the OpenAPI document: v0.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""
import re
from typing import Any, Awaitable, List, Optional, Union, overload
from pydantic import Field, StrictBytes, StrictStr, validate_arguments
from typing_extensions import Annotated
from agbenchmark.agent_protocol_client.api_client import ApiClient
from agbenchmark.agent_protocol_client.api_response import ApiResponse
from agbenchmark.agent_protocol_client.exceptions import ApiTypeError, ApiValueError
from agbenchmark.agent_protocol_client.models.artifact import Artifact
from agbenchmark.agent_protocol_client.models.step import Step
from agbenchmark.agent_protocol_client.models.step_request_body import StepRequestBody
from agbenchmark.agent_protocol_client.models.task import Task
from agbenchmark.agent_protocol_client.models.task_request_body import TaskRequestBody

class AgentApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if False:
            while True:
                i = 10
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @overload
    async def create_agent_task(self, task_request_body: Optional[TaskRequestBody]=None, **kwargs) -> Task:
        ...

    @overload
    def create_agent_task(self, task_request_body: Optional[TaskRequestBody]=None, async_req: Optional[bool]=True, **kwargs) -> Task:
        if False:
            print('Hello World!')
        ...

    @validate_arguments
    def create_agent_task(self, task_request_body: Optional[TaskRequestBody]=None, async_req: Optional[bool]=None, **kwargs) -> Union[Task, Awaitable[Task]]:
        if False:
            i = 10
            return i + 15
        'Creates a task for the agent.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.create_agent_task(task_request_body, async_req=True)\n        >>> result = thread.get()\n\n        :param task_request_body:\n        :type task_request_body: TaskRequestBody\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: Task\n        '
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the create_agent_task_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.create_agent_task_with_http_info(task_request_body, **kwargs)

    @validate_arguments
    def create_agent_task_with_http_info(self, task_request_body: Optional[TaskRequestBody]=None, **kwargs) -> ApiResponse:
        if False:
            for i in range(10):
                print('nop')
        'Creates a task for the agent.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.create_agent_task_with_http_info(task_request_body, async_req=True)\n        >>> result = thread.get()\n\n        :param task_request_body:\n        :type task_request_body: TaskRequestBody\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(Task, status_code(int), headers(HTTPHeaderDict))\n        '
        _params = locals()
        _all_params = ['task_request_body']
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method create_agent_task" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        _body_params = None
        if _params['task_request_body'] is not None:
            _body_params = _params['task_request_body']
        _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        _content_types_list = _params.get('_content_type', self.api_client.select_header_content_type(['application/json']))
        if _content_types_list:
            _header_params['Content-Type'] = _content_types_list
        _auth_settings = []
        _response_types_map = {'200': 'Task'}
        return self.api_client.call_api('/agent/tasks', 'POST', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))

    @overload
    async def download_agent_task_artifact(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], artifact_id: Annotated[StrictStr, Field(..., description='ID of the artifact')], **kwargs) -> bytearray:
        ...

    @overload
    def download_agent_task_artifact(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], artifact_id: Annotated[StrictStr, Field(..., description='ID of the artifact')], async_req: Optional[bool]=True, **kwargs) -> bytearray:
        if False:
            i = 10
            return i + 15
        ...

    @validate_arguments
    def download_agent_task_artifact(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], artifact_id: Annotated[StrictStr, Field(..., description='ID of the artifact')], async_req: Optional[bool]=None, **kwargs) -> Union[bytearray, Awaitable[bytearray]]:
        if False:
            print('Hello World!')
        'Download a specified artifact.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.download_agent_task_artifact(task_id, artifact_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param artifact_id: ID of the artifact (required)\n        :type artifact_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: bytearray\n        '
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the download_agent_task_artifact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.download_agent_task_artifact_with_http_info(task_id, artifact_id, **kwargs)

    @validate_arguments
    def download_agent_task_artifact_with_http_info(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], artifact_id: Annotated[StrictStr, Field(..., description='ID of the artifact')], **kwargs) -> ApiResponse:
        if False:
            i = 10
            return i + 15
        'Download a specified artifact.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.download_agent_task_artifact_with_http_info(task_id, artifact_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param artifact_id: ID of the artifact (required)\n        :type artifact_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))\n        '
        _params = locals()
        _all_params = ['task_id', 'artifact_id']
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method download_agent_task_artifact" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        if _params['task_id']:
            _path_params['task_id'] = _params['task_id']
        if _params['artifact_id']:
            _path_params['artifact_id'] = _params['artifact_id']
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        _body_params = None
        _header_params['Accept'] = self.api_client.select_header_accept(['application/octet-stream'])
        _auth_settings = []
        _response_types_map = {'200': 'bytearray'}
        return self.api_client.call_api('/agent/tasks/{task_id}/artifacts/{artifact_id}', 'GET', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))

    @overload
    async def execute_agent_task_step(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], step_request_body: Optional[StepRequestBody]=None, **kwargs) -> Step:
        ...

    @overload
    def execute_agent_task_step(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], step_request_body: Optional[StepRequestBody]=None, async_req: Optional[bool]=True, **kwargs) -> Step:
        if False:
            i = 10
            return i + 15
        ...

    @validate_arguments
    def execute_agent_task_step(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], step_request_body: Optional[StepRequestBody]=None, async_req: Optional[bool]=None, **kwargs) -> Union[Step, Awaitable[Step]]:
        if False:
            i = 10
            return i + 15
        'Execute a step in the specified agent task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.execute_agent_task_step(task_id, step_request_body, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param step_request_body:\n        :type step_request_body: StepRequestBody\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: Step\n        '
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the execute_agent_task_step_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.execute_agent_task_step_with_http_info(task_id, step_request_body, **kwargs)

    @validate_arguments
    def execute_agent_task_step_with_http_info(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], step_request_body: Optional[StepRequestBody]=None, **kwargs) -> ApiResponse:
        if False:
            for i in range(10):
                print('nop')
        'Execute a step in the specified agent task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.execute_agent_task_step_with_http_info(task_id, step_request_body, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param step_request_body:\n        :type step_request_body: StepRequestBody\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(Step, status_code(int), headers(HTTPHeaderDict))\n        '
        _params = locals()
        _all_params = ['task_id', 'step_request_body']
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method execute_agent_task_step" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        if _params['task_id']:
            _path_params['task_id'] = _params['task_id']
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        _body_params = None
        if _params['step_request_body'] is not None:
            _body_params = _params['step_request_body']
        _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        _content_types_list = _params.get('_content_type', self.api_client.select_header_content_type(['application/json']))
        if _content_types_list:
            _header_params['Content-Type'] = _content_types_list
        _auth_settings = []
        _response_types_map = {'200': 'Step'}
        return self.api_client.call_api('/agent/tasks/{task_id}/steps', 'POST', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))

    @overload
    async def get_agent_task(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], **kwargs) -> Task:
        ...

    @overload
    def get_agent_task(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], async_req: Optional[bool]=True, **kwargs) -> Task:
        if False:
            while True:
                i = 10
        ...

    @validate_arguments
    def get_agent_task(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], async_req: Optional[bool]=None, **kwargs) -> Union[Task, Awaitable[Task]]:
        if False:
            while True:
                i = 10
        'Get details about a specified agent task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_agent_task(task_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: Task\n        '
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the get_agent_task_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.get_agent_task_with_http_info(task_id, **kwargs)

    @validate_arguments
    def get_agent_task_with_http_info(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], **kwargs) -> ApiResponse:
        if False:
            print('Hello World!')
        'Get details about a specified agent task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_agent_task_with_http_info(task_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(Task, status_code(int), headers(HTTPHeaderDict))\n        '
        _params = locals()
        _all_params = ['task_id']
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method get_agent_task" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        if _params['task_id']:
            _path_params['task_id'] = _params['task_id']
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        _body_params = None
        _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        _auth_settings = []
        _response_types_map = {'200': 'Task'}
        return self.api_client.call_api('/agent/tasks/{task_id}', 'GET', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))

    @overload
    async def get_agent_task_step(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], step_id: Annotated[StrictStr, Field(..., description='ID of the step')], **kwargs) -> Step:
        ...

    @overload
    def get_agent_task_step(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], step_id: Annotated[StrictStr, Field(..., description='ID of the step')], async_req: Optional[bool]=True, **kwargs) -> Step:
        if False:
            print('Hello World!')
        ...

    @validate_arguments
    def get_agent_task_step(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], step_id: Annotated[StrictStr, Field(..., description='ID of the step')], async_req: Optional[bool]=None, **kwargs) -> Union[Step, Awaitable[Step]]:
        if False:
            for i in range(10):
                print('nop')
        'Get details about a specified task step.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_agent_task_step(task_id, step_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param step_id: ID of the step (required)\n        :type step_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: Step\n        '
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the get_agent_task_step_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.get_agent_task_step_with_http_info(task_id, step_id, **kwargs)

    @validate_arguments
    def get_agent_task_step_with_http_info(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], step_id: Annotated[StrictStr, Field(..., description='ID of the step')], **kwargs) -> ApiResponse:
        if False:
            i = 10
            return i + 15
        'Get details about a specified task step.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_agent_task_step_with_http_info(task_id, step_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param step_id: ID of the step (required)\n        :type step_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(Step, status_code(int), headers(HTTPHeaderDict))\n        '
        _params = locals()
        _all_params = ['task_id', 'step_id']
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method get_agent_task_step" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        if _params['task_id']:
            _path_params['task_id'] = _params['task_id']
        if _params['step_id']:
            _path_params['step_id'] = _params['step_id']
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        _body_params = None
        _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        _auth_settings = []
        _response_types_map = {'200': 'Step'}
        return self.api_client.call_api('/agent/tasks/{task_id}/steps/{step_id}', 'GET', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))

    @overload
    async def list_agent_task_artifacts(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], **kwargs) -> Any:
        ...

    @overload
    def list_agent_task_artifacts(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], async_req: Optional[bool]=True, **kwargs) -> Any:
        if False:
            i = 10
            return i + 15
        ...

    @validate_arguments
    def list_agent_task_artifacts(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], async_req: Optional[bool]=None, **kwargs) -> Union[Any, Awaitable[Any]]:
        if False:
            for i in range(10):
                print('nop')
        'List all artifacts that have been created for the given task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.list_agent_task_artifacts(task_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: List[Artifact]\n        '
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the list_agent_task_artifacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.list_agent_task_artifacts_with_http_info(task_id, **kwargs)

    @validate_arguments
    def list_agent_task_artifacts_with_http_info(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], **kwargs) -> ApiResponse:
        if False:
            return 10
        'List all artifacts that have been created for the given task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.list_agent_task_artifacts_with_http_info(task_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(List[Artifact], status_code(int), headers(HTTPHeaderDict))\n        '
        _params = locals()
        _all_params = ['task_id']
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method list_agent_task_artifacts" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        if _params['task_id']:
            _path_params['task_id'] = _params['task_id']
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        _body_params = None
        _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        _auth_settings = []
        _response_types_map = {'200': 'Artifacts'}
        return self.api_client.call_api('/agent/tasks/{task_id}/artifacts', 'GET', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))

    @overload
    async def list_agent_task_steps(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], **kwargs) -> List[str]:
        ...

    @overload
    def list_agent_task_steps(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], async_req: Optional[bool]=True, **kwargs) -> List[str]:
        if False:
            print('Hello World!')
        ...

    @validate_arguments
    def list_agent_task_steps(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], async_req: Optional[bool]=None, **kwargs) -> Union[List[str], Awaitable[List[str]]]:
        if False:
            while True:
                i = 10
        'List all steps for the specified task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.list_agent_task_steps(task_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: List[str]\n        '
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the list_agent_task_steps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.list_agent_task_steps_with_http_info(task_id, **kwargs)

    @validate_arguments
    def list_agent_task_steps_with_http_info(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], **kwargs) -> ApiResponse:
        if False:
            for i in range(10):
                print('nop')
        'List all steps for the specified task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.list_agent_task_steps_with_http_info(task_id, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(List[str], status_code(int), headers(HTTPHeaderDict))\n        '
        _params = locals()
        _all_params = ['task_id']
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method list_agent_task_steps" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        if _params['task_id']:
            _path_params['task_id'] = _params['task_id']
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        _body_params = None
        _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        _auth_settings = []
        _response_types_map = {'200': 'List[str]'}
        return self.api_client.call_api('/agent/tasks/{task_id}/steps', 'GET', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))

    @overload
    async def list_agent_tasks_ids(self, **kwargs) -> List[str]:
        ...

    @overload
    def list_agent_tasks_ids(self, async_req: Optional[bool]=True, **kwargs) -> List[str]:
        if False:
            i = 10
            return i + 15
        ...

    @validate_arguments
    def list_agent_tasks_ids(self, async_req: Optional[bool]=None, **kwargs) -> Union[List[str], Awaitable[List[str]]]:
        if False:
            for i in range(10):
                print('nop')
        'List all tasks that have been created for the agent.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.list_agent_tasks_ids(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: List[str]\n        '
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the list_agent_tasks_ids_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.list_agent_tasks_ids_with_http_info(**kwargs)

    @validate_arguments
    def list_agent_tasks_ids_with_http_info(self, **kwargs) -> ApiResponse:
        if False:
            return 10
        'List all tasks that have been created for the agent.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.list_agent_tasks_ids_with_http_info(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(List[str], status_code(int), headers(HTTPHeaderDict))\n        '
        _params = locals()
        _all_params = []
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method list_agent_tasks_ids" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        _body_params = None
        _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        _auth_settings = []
        _response_types_map = {'200': 'List[str]'}
        return self.api_client.call_api('/agent/tasks', 'GET', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))

    @overload
    async def upload_agent_task_artifacts(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], file: Annotated[Union[StrictBytes, StrictStr], Field(..., description='File to upload.')], relative_path: Annotated[Optional[StrictStr], Field(description="Relative path of the artifact in the agent's workspace.")]=None, **kwargs) -> Artifact:
        ...

    @overload
    def upload_agent_task_artifacts(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], file: Annotated[Union[StrictBytes, StrictStr], Field(..., description='File to upload.')], relative_path: Annotated[Optional[StrictStr], Field(description="Relative path of the artifact in the agent's workspace.")]=None, async_req: Optional[bool]=True, **kwargs) -> Artifact:
        if False:
            return 10
        ...

    @validate_arguments
    def upload_agent_task_artifacts(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], file: Annotated[Union[StrictBytes, StrictStr], Field(..., description='File to upload.')], relative_path: Annotated[Optional[StrictStr], Field(description="Relative path of the artifact in the agent's workspace.")]=None, async_req: Optional[bool]=None, **kwargs) -> Union[Artifact, Awaitable[Artifact]]:
        if False:
            while True:
                i = 10
        "Upload an artifact for the specified task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.upload_agent_task_artifacts(task_id, file, relative_path, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param file: File to upload. (required)\n        :type file: bytearray\n        :param relative_path: Relative path of the artifact in the agent's workspace.\n        :type relative_path: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: Artifact\n        "
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError('Error! Please call the upload_agent_task_artifacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data')
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.upload_agent_task_artifacts_with_http_info(task_id, file, relative_path, **kwargs)

    @validate_arguments
    def upload_agent_task_artifacts_with_http_info(self, task_id: Annotated[StrictStr, Field(..., description='ID of the task')], file: Annotated[Union[StrictBytes, StrictStr], Field(..., description='File to upload.')], relative_path: Annotated[Optional[StrictStr], Field(description="Relative path of the artifact in the agent's workspace.")]=None, **kwargs) -> ApiResponse:
        if False:
            print('Hello World!')
        "Upload an artifact for the specified task.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.upload_agent_task_artifacts_with_http_info(task_id, file, relative_path, async_req=True)\n        >>> result = thread.get()\n\n        :param task_id: ID of the task (required)\n        :type task_id: str\n        :param file: File to upload. (required)\n        :type file: bytearray\n        :param relative_path: Relative path of the artifact in the agent's workspace.\n        :type relative_path: str\n        :param async_req: Whether to execute the request asynchronously.\n        :type async_req: bool, optional\n        :param _preload_content: if False, the ApiResponse.data will\n                                 be set to none and raw_data will store the\n                                 HTTP response body without reading/decoding.\n                                 Default is True.\n        :type _preload_content: bool, optional\n        :param _return_http_data_only: response data instead of ApiResponse\n                                       object with status code, headers, etc\n        :type _return_http_data_only: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auth: dict, optional\n        :type _content_type: string, optional: force content-type for the request\n        :return: Returns the result object.\n                 If the method is called asynchronously,\n                 returns the request thread.\n        :rtype: tuple(Artifact, status_code(int), headers(HTTPHeaderDict))\n        "
        _params = locals()
        _all_params = ['task_id', 'file', 'relative_path']
        _all_params.extend(['async_req', '_return_http_data_only', '_preload_content', '_request_timeout', '_request_auth', '_content_type', '_headers'])
        for (_key, _val) in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError("Got an unexpected keyword argument '%s' to method upload_agent_task_artifacts" % _key)
            _params[_key] = _val
        del _params['kwargs']
        _collection_formats = {}
        _path_params = {}
        if _params['task_id']:
            _path_params['task_id'] = _params['task_id']
        _query_params = []
        _header_params = dict(_params.get('_headers', {}))
        _form_params = []
        _files = {}
        if _params['file']:
            _files['file'] = _params['file']
        if _params['relative_path']:
            _form_params.append(('relative_path', _params['relative_path']))
        _body_params = None
        _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        _content_types_list = _params.get('_content_type', self.api_client.select_header_content_type(['multipart/form-data']))
        if _content_types_list:
            _header_params['Content-Type'] = _content_types_list
        _auth_settings = []
        _response_types_map = {'200': 'Artifact'}
        return self.api_client.call_api('/agent/tasks/{task_id}/artifacts', 'POST', _path_params, _query_params, _header_params, body=_body_params, post_params=_form_params, files=_files, response_types_map=_response_types_map, auth_settings=_auth_settings, async_req=_params.get('async_req'), _return_http_data_only=_params.get('_return_http_data_only'), _preload_content=_params.get('_preload_content', True), _request_timeout=_params.get('_request_timeout'), collection_formats=_collection_formats, _request_auth=_params.get('_request_auth'))