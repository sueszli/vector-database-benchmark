[
    {
        "func_name": "when",
        "original": "@deprecate_renamed_parameter('expr', 'condition', version='0.18.9')\ndef when(condition: IntoExpr) -> pl.When:\n    \"\"\"\n    Start a `when-then-otherwise` expression.\n\n    Expression similar to an `if-else` statement in Python. Always initiated by a\n    `pl.when(<condition>).then(<value if condition>)`. Optionally followed by chaining\n    one or more `.when(<condition>).then(<value>)` statements.\n\n    Chained `when, thens` should be read as Python `if, elif, ... elif` blocks, not as\n    `if, if, ... if`, i.e. the first condition that evaluates to True will be picked.\n\n    If none of the conditions are `True`, an optional `.otherwise(<value if all\n    statements are false>)` can be appended at the end. If not appended, and none\n    of the conditions are `True`, `None` will be returned.\n\n    Parameters\n    ----------\n    condition\n        The condition for applying the subsequent statement.\n        Accepts a boolean expression. String input is parsed as a column name.\n\n    Warnings\n    --------\n    Polars computes all expressions passed to `when-then-otherwise` in parallel and\n    filters afterwards. This means each expression must be valid on its own, regardless\n    of the conditions in the `when-then-otherwise` chain.\n\n    Examples\n    --------\n    Below we add a column with the value 1, where column \"foo\" > 2 and the value -1\n    where it isn't.\n\n    >>> df = pl.DataFrame({\"foo\": [1, 3, 4], \"bar\": [3, 4, 0]})\n    >>> df.with_columns(\n    ...     pl.when(pl.col(\"foo\") > 2)\n    ...     .then(pl.lit(1))\n    ...     .otherwise(pl.lit(-1))\n    ...     .alias(\"val\")\n    ... )\n    shape: (3, 3)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 foo \u2506 bar \u2506 val \u2502\n    \u2502 --- \u2506 --- \u2506 --- \u2502\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1   \u2506 3   \u2506 -1  \u2502\n    \u2502 3   \u2506 4   \u2506 1   \u2502\n    \u2502 4   \u2506 0   \u2506 1   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Or with multiple `when, thens` chained:\n\n    >>> df.with_columns(\n    ...     pl.when(pl.col(\"foo\") > 2)\n    ...     .then(1)\n    ...     .when(pl.col(\"bar\") > 2)\n    ...     .then(4)\n    ...     .otherwise(-1)\n    ...     .alias(\"val\")\n    ... )\n    shape: (3, 3)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 foo \u2506 bar \u2506 val \u2502\n    \u2502 --- \u2506 --- \u2506 --- \u2502\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1   \u2506 3   \u2506 4   \u2502\n    \u2502 3   \u2506 4   \u2506 1   \u2502\n    \u2502 4   \u2506 0   \u2506 1   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Note how in the example above for the second row in the DataFrame,\n    where `foo=3` and `bar=4`, the first `when` evaluates to `True`, and therefore\n    the second `when`, which is also `True`, is not evaluated.\n\n    The `otherwise` at the end is optional. If left out, any rows where none\n    of the `when` expressions evaluate to True, are set to `null`:\n\n    >>> df.with_columns(pl.when(pl.col(\"foo\") > 2).then(pl.lit(1)).alias(\"val\"))\n    shape: (3, 3)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 foo \u2506 bar \u2506 val  \u2502\n    \u2502 --- \u2506 --- \u2506 ---  \u2502\n    \u2502 i64 \u2506 i64 \u2506 i32  \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1   \u2506 3   \u2506 null \u2502\n    \u2502 3   \u2506 4   \u2506 1    \u2502\n    \u2502 4   \u2506 0   \u2506 1    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    condition_pyexpr = parse_as_expression(condition)\n    return pl.When(plr.when(condition_pyexpr))",
        "mutated": [
            "@deprecate_renamed_parameter('expr', 'condition', version='0.18.9')\ndef when(condition: IntoExpr) -> pl.When:\n    if False:\n        i = 10\n    '\\n    Start a `when-then-otherwise` expression.\\n\\n    Expression similar to an `if-else` statement in Python. Always initiated by a\\n    `pl.when(<condition>).then(<value if condition>)`. Optionally followed by chaining\\n    one or more `.when(<condition>).then(<value>)` statements.\\n\\n    Chained `when, thens` should be read as Python `if, elif, ... elif` blocks, not as\\n    `if, if, ... if`, i.e. the first condition that evaluates to True will be picked.\\n\\n    If none of the conditions are `True`, an optional `.otherwise(<value if all\\n    statements are false>)` can be appended at the end. If not appended, and none\\n    of the conditions are `True`, `None` will be returned.\\n\\n    Parameters\\n    ----------\\n    condition\\n        The condition for applying the subsequent statement.\\n        Accepts a boolean expression. String input is parsed as a column name.\\n\\n    Warnings\\n    --------\\n    Polars computes all expressions passed to `when-then-otherwise` in parallel and\\n    filters afterwards. This means each expression must be valid on its own, regardless\\n    of the conditions in the `when-then-otherwise` chain.\\n\\n    Examples\\n    --------\\n    Below we add a column with the value 1, where column \"foo\" > 2 and the value -1\\n    where it isn\\'t.\\n\\n    >>> df = pl.DataFrame({\"foo\": [1, 3, 4], \"bar\": [3, 4, 0]})\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(pl.lit(1))\\n    ...     .otherwise(pl.lit(-1))\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 -1  \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Or with multiple `when, thens` chained:\\n\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(1)\\n    ...     .when(pl.col(\"bar\") > 2)\\n    ...     .then(4)\\n    ...     .otherwise(-1)\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 4   \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Note how in the example above for the second row in the DataFrame,\\n    where `foo=3` and `bar=4`, the first `when` evaluates to `True`, and therefore\\n    the second `when`, which is also `True`, is not evaluated.\\n\\n    The `otherwise` at the end is optional. If left out, any rows where none\\n    of the `when` expressions evaluate to True, are set to `null`:\\n\\n    >>> df.with_columns(pl.when(pl.col(\"foo\") > 2).then(pl.lit(1)).alias(\"val\"))\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val  \u2502\\n    \u2502 --- \u2506 --- \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 null \u2502\\n    \u2502 3   \u2506 4   \u2506 1    \u2502\\n    \u2502 4   \u2506 0   \u2506 1    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    condition_pyexpr = parse_as_expression(condition)\n    return pl.When(plr.when(condition_pyexpr))",
            "@deprecate_renamed_parameter('expr', 'condition', version='0.18.9')\ndef when(condition: IntoExpr) -> pl.When:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Start a `when-then-otherwise` expression.\\n\\n    Expression similar to an `if-else` statement in Python. Always initiated by a\\n    `pl.when(<condition>).then(<value if condition>)`. Optionally followed by chaining\\n    one or more `.when(<condition>).then(<value>)` statements.\\n\\n    Chained `when, thens` should be read as Python `if, elif, ... elif` blocks, not as\\n    `if, if, ... if`, i.e. the first condition that evaluates to True will be picked.\\n\\n    If none of the conditions are `True`, an optional `.otherwise(<value if all\\n    statements are false>)` can be appended at the end. If not appended, and none\\n    of the conditions are `True`, `None` will be returned.\\n\\n    Parameters\\n    ----------\\n    condition\\n        The condition for applying the subsequent statement.\\n        Accepts a boolean expression. String input is parsed as a column name.\\n\\n    Warnings\\n    --------\\n    Polars computes all expressions passed to `when-then-otherwise` in parallel and\\n    filters afterwards. This means each expression must be valid on its own, regardless\\n    of the conditions in the `when-then-otherwise` chain.\\n\\n    Examples\\n    --------\\n    Below we add a column with the value 1, where column \"foo\" > 2 and the value -1\\n    where it isn\\'t.\\n\\n    >>> df = pl.DataFrame({\"foo\": [1, 3, 4], \"bar\": [3, 4, 0]})\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(pl.lit(1))\\n    ...     .otherwise(pl.lit(-1))\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 -1  \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Or with multiple `when, thens` chained:\\n\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(1)\\n    ...     .when(pl.col(\"bar\") > 2)\\n    ...     .then(4)\\n    ...     .otherwise(-1)\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 4   \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Note how in the example above for the second row in the DataFrame,\\n    where `foo=3` and `bar=4`, the first `when` evaluates to `True`, and therefore\\n    the second `when`, which is also `True`, is not evaluated.\\n\\n    The `otherwise` at the end is optional. If left out, any rows where none\\n    of the `when` expressions evaluate to True, are set to `null`:\\n\\n    >>> df.with_columns(pl.when(pl.col(\"foo\") > 2).then(pl.lit(1)).alias(\"val\"))\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val  \u2502\\n    \u2502 --- \u2506 --- \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 null \u2502\\n    \u2502 3   \u2506 4   \u2506 1    \u2502\\n    \u2502 4   \u2506 0   \u2506 1    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    condition_pyexpr = parse_as_expression(condition)\n    return pl.When(plr.when(condition_pyexpr))",
            "@deprecate_renamed_parameter('expr', 'condition', version='0.18.9')\ndef when(condition: IntoExpr) -> pl.When:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Start a `when-then-otherwise` expression.\\n\\n    Expression similar to an `if-else` statement in Python. Always initiated by a\\n    `pl.when(<condition>).then(<value if condition>)`. Optionally followed by chaining\\n    one or more `.when(<condition>).then(<value>)` statements.\\n\\n    Chained `when, thens` should be read as Python `if, elif, ... elif` blocks, not as\\n    `if, if, ... if`, i.e. the first condition that evaluates to True will be picked.\\n\\n    If none of the conditions are `True`, an optional `.otherwise(<value if all\\n    statements are false>)` can be appended at the end. If not appended, and none\\n    of the conditions are `True`, `None` will be returned.\\n\\n    Parameters\\n    ----------\\n    condition\\n        The condition for applying the subsequent statement.\\n        Accepts a boolean expression. String input is parsed as a column name.\\n\\n    Warnings\\n    --------\\n    Polars computes all expressions passed to `when-then-otherwise` in parallel and\\n    filters afterwards. This means each expression must be valid on its own, regardless\\n    of the conditions in the `when-then-otherwise` chain.\\n\\n    Examples\\n    --------\\n    Below we add a column with the value 1, where column \"foo\" > 2 and the value -1\\n    where it isn\\'t.\\n\\n    >>> df = pl.DataFrame({\"foo\": [1, 3, 4], \"bar\": [3, 4, 0]})\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(pl.lit(1))\\n    ...     .otherwise(pl.lit(-1))\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 -1  \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Or with multiple `when, thens` chained:\\n\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(1)\\n    ...     .when(pl.col(\"bar\") > 2)\\n    ...     .then(4)\\n    ...     .otherwise(-1)\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 4   \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Note how in the example above for the second row in the DataFrame,\\n    where `foo=3` and `bar=4`, the first `when` evaluates to `True`, and therefore\\n    the second `when`, which is also `True`, is not evaluated.\\n\\n    The `otherwise` at the end is optional. If left out, any rows where none\\n    of the `when` expressions evaluate to True, are set to `null`:\\n\\n    >>> df.with_columns(pl.when(pl.col(\"foo\") > 2).then(pl.lit(1)).alias(\"val\"))\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val  \u2502\\n    \u2502 --- \u2506 --- \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 null \u2502\\n    \u2502 3   \u2506 4   \u2506 1    \u2502\\n    \u2502 4   \u2506 0   \u2506 1    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    condition_pyexpr = parse_as_expression(condition)\n    return pl.When(plr.when(condition_pyexpr))",
            "@deprecate_renamed_parameter('expr', 'condition', version='0.18.9')\ndef when(condition: IntoExpr) -> pl.When:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Start a `when-then-otherwise` expression.\\n\\n    Expression similar to an `if-else` statement in Python. Always initiated by a\\n    `pl.when(<condition>).then(<value if condition>)`. Optionally followed by chaining\\n    one or more `.when(<condition>).then(<value>)` statements.\\n\\n    Chained `when, thens` should be read as Python `if, elif, ... elif` blocks, not as\\n    `if, if, ... if`, i.e. the first condition that evaluates to True will be picked.\\n\\n    If none of the conditions are `True`, an optional `.otherwise(<value if all\\n    statements are false>)` can be appended at the end. If not appended, and none\\n    of the conditions are `True`, `None` will be returned.\\n\\n    Parameters\\n    ----------\\n    condition\\n        The condition for applying the subsequent statement.\\n        Accepts a boolean expression. String input is parsed as a column name.\\n\\n    Warnings\\n    --------\\n    Polars computes all expressions passed to `when-then-otherwise` in parallel and\\n    filters afterwards. This means each expression must be valid on its own, regardless\\n    of the conditions in the `when-then-otherwise` chain.\\n\\n    Examples\\n    --------\\n    Below we add a column with the value 1, where column \"foo\" > 2 and the value -1\\n    where it isn\\'t.\\n\\n    >>> df = pl.DataFrame({\"foo\": [1, 3, 4], \"bar\": [3, 4, 0]})\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(pl.lit(1))\\n    ...     .otherwise(pl.lit(-1))\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 -1  \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Or with multiple `when, thens` chained:\\n\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(1)\\n    ...     .when(pl.col(\"bar\") > 2)\\n    ...     .then(4)\\n    ...     .otherwise(-1)\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 4   \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Note how in the example above for the second row in the DataFrame,\\n    where `foo=3` and `bar=4`, the first `when` evaluates to `True`, and therefore\\n    the second `when`, which is also `True`, is not evaluated.\\n\\n    The `otherwise` at the end is optional. If left out, any rows where none\\n    of the `when` expressions evaluate to True, are set to `null`:\\n\\n    >>> df.with_columns(pl.when(pl.col(\"foo\") > 2).then(pl.lit(1)).alias(\"val\"))\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val  \u2502\\n    \u2502 --- \u2506 --- \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 null \u2502\\n    \u2502 3   \u2506 4   \u2506 1    \u2502\\n    \u2502 4   \u2506 0   \u2506 1    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    condition_pyexpr = parse_as_expression(condition)\n    return pl.When(plr.when(condition_pyexpr))",
            "@deprecate_renamed_parameter('expr', 'condition', version='0.18.9')\ndef when(condition: IntoExpr) -> pl.When:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Start a `when-then-otherwise` expression.\\n\\n    Expression similar to an `if-else` statement in Python. Always initiated by a\\n    `pl.when(<condition>).then(<value if condition>)`. Optionally followed by chaining\\n    one or more `.when(<condition>).then(<value>)` statements.\\n\\n    Chained `when, thens` should be read as Python `if, elif, ... elif` blocks, not as\\n    `if, if, ... if`, i.e. the first condition that evaluates to True will be picked.\\n\\n    If none of the conditions are `True`, an optional `.otherwise(<value if all\\n    statements are false>)` can be appended at the end. If not appended, and none\\n    of the conditions are `True`, `None` will be returned.\\n\\n    Parameters\\n    ----------\\n    condition\\n        The condition for applying the subsequent statement.\\n        Accepts a boolean expression. String input is parsed as a column name.\\n\\n    Warnings\\n    --------\\n    Polars computes all expressions passed to `when-then-otherwise` in parallel and\\n    filters afterwards. This means each expression must be valid on its own, regardless\\n    of the conditions in the `when-then-otherwise` chain.\\n\\n    Examples\\n    --------\\n    Below we add a column with the value 1, where column \"foo\" > 2 and the value -1\\n    where it isn\\'t.\\n\\n    >>> df = pl.DataFrame({\"foo\": [1, 3, 4], \"bar\": [3, 4, 0]})\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(pl.lit(1))\\n    ...     .otherwise(pl.lit(-1))\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 -1  \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Or with multiple `when, thens` chained:\\n\\n    >>> df.with_columns(\\n    ...     pl.when(pl.col(\"foo\") > 2)\\n    ...     .then(1)\\n    ...     .when(pl.col(\"bar\") > 2)\\n    ...     .then(4)\\n    ...     .otherwise(-1)\\n    ...     .alias(\"val\")\\n    ... )\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val \u2502\\n    \u2502 --- \u2506 --- \u2506 --- \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 4   \u2502\\n    \u2502 3   \u2506 4   \u2506 1   \u2502\\n    \u2502 4   \u2506 0   \u2506 1   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Note how in the example above for the second row in the DataFrame,\\n    where `foo=3` and `bar=4`, the first `when` evaluates to `True`, and therefore\\n    the second `when`, which is also `True`, is not evaluated.\\n\\n    The `otherwise` at the end is optional. If left out, any rows where none\\n    of the `when` expressions evaluate to True, are set to `null`:\\n\\n    >>> df.with_columns(pl.when(pl.col(\"foo\") > 2).then(pl.lit(1)).alias(\"val\"))\\n    shape: (3, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 foo \u2506 bar \u2506 val  \u2502\\n    \u2502 --- \u2506 --- \u2506 ---  \u2502\\n    \u2502 i64 \u2506 i64 \u2506 i32  \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 3   \u2506 null \u2502\\n    \u2502 3   \u2506 4   \u2506 1    \u2502\\n    \u2502 4   \u2506 0   \u2506 1    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    condition_pyexpr = parse_as_expression(condition)\n    return pl.When(plr.when(condition_pyexpr))"
        ]
    }
]