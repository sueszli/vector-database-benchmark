[
    {
        "func_name": "_create_us_counties_df",
        "original": "def _create_us_counties_df(st_to_state_name_dict, state_to_st_dict):\n    abs_dir_path = os.path.realpath(_plotly_geo.__file__)\n    abs_plotly_geo_path = os.path.dirname(abs_dir_path)\n    abs_package_data_dir_path = os.path.join(abs_plotly_geo_path, 'package_data')\n    shape_pre2010 = 'gz_2010_us_050_00_500k.shp'\n    shape_pre2010 = os.path.join(abs_package_data_dir_path, shape_pre2010)\n    df_shape_pre2010 = gp.read_file(shape_pre2010)\n    df_shape_pre2010['FIPS'] = df_shape_pre2010['STATE'] + df_shape_pre2010['COUNTY']\n    df_shape_pre2010['FIPS'] = pd.to_numeric(df_shape_pre2010['FIPS'])\n    states_path = 'cb_2016_us_state_500k.shp'\n    states_path = os.path.join(abs_package_data_dir_path, states_path)\n    df_state = gp.read_file(states_path)\n    df_state = df_state[['STATEFP', 'NAME', 'geometry']]\n    df_state = df_state.rename(columns={'NAME': 'STATE_NAME'})\n    filenames = ['cb_2016_us_county_500k.dbf', 'cb_2016_us_county_500k.shp', 'cb_2016_us_county_500k.shx']\n    for j in range(len(filenames)):\n        filenames[j] = os.path.join(abs_package_data_dir_path, filenames[j])\n    dbf = io.open(filenames[0], 'rb')\n    shp = io.open(filenames[1], 'rb')\n    shx = io.open(filenames[2], 'rb')\n    r = shapefile.Reader(shp=shp, shx=shx, dbf=dbf)\n    (attributes, geometry) = ([], [])\n    field_names = [field[0] for field in r.fields[1:]]\n    for row in r.shapeRecords():\n        geometry.append(shapely.geometry.shape(row.shape.__geo_interface__))\n        attributes.append(dict(zip(field_names, row.record)))\n    gdf = gp.GeoDataFrame(data=attributes, geometry=geometry)\n    gdf['FIPS'] = gdf['STATEFP'] + gdf['COUNTYFP']\n    gdf['FIPS'] = pd.to_numeric(gdf['FIPS'])\n    f = 46113\n    singlerow = pd.DataFrame([[st_to_state_name_dict['SD'], 'SD', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '46', 'Shannon']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 51515\n    singlerow = pd.DataFrame([[st_to_state_name_dict['VA'], 'VA', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '51', 'Bedford City']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 2270\n    singlerow = pd.DataFrame([[st_to_state_name_dict['AK'], 'AK', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '02', 'Wade Hampton']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    row_2198 = gdf[gdf['FIPS'] == 2198]\n    row_2198.index = [max(gdf.index) + 1]\n    row_2198.loc[row_2198.index[0], 'FIPS'] = 2201\n    row_2198.loc[row_2198.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2198], sort=True)\n    row_2105 = gdf[gdf['FIPS'] == 2105]\n    row_2105.index = [max(gdf.index) + 1]\n    row_2105.loc[row_2105.index[0], 'FIPS'] = 2232\n    row_2105.loc[row_2105.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2105], sort=True)\n    gdf = gdf.rename(columns={'NAME': 'COUNTY_NAME'})\n    gdf_reduced = gdf[['FIPS', 'STATEFP', 'COUNTY_NAME', 'geometry']]\n    gdf_statefp = gdf_reduced.merge(df_state[['STATEFP', 'STATE_NAME']], on='STATEFP')\n    ST = []\n    for n in gdf_statefp['STATE_NAME']:\n        ST.append(state_to_st_dict[n])\n    gdf_statefp['ST'] = ST\n    return (gdf_statefp, df_state)",
        "mutated": [
            "def _create_us_counties_df(st_to_state_name_dict, state_to_st_dict):\n    if False:\n        i = 10\n    abs_dir_path = os.path.realpath(_plotly_geo.__file__)\n    abs_plotly_geo_path = os.path.dirname(abs_dir_path)\n    abs_package_data_dir_path = os.path.join(abs_plotly_geo_path, 'package_data')\n    shape_pre2010 = 'gz_2010_us_050_00_500k.shp'\n    shape_pre2010 = os.path.join(abs_package_data_dir_path, shape_pre2010)\n    df_shape_pre2010 = gp.read_file(shape_pre2010)\n    df_shape_pre2010['FIPS'] = df_shape_pre2010['STATE'] + df_shape_pre2010['COUNTY']\n    df_shape_pre2010['FIPS'] = pd.to_numeric(df_shape_pre2010['FIPS'])\n    states_path = 'cb_2016_us_state_500k.shp'\n    states_path = os.path.join(abs_package_data_dir_path, states_path)\n    df_state = gp.read_file(states_path)\n    df_state = df_state[['STATEFP', 'NAME', 'geometry']]\n    df_state = df_state.rename(columns={'NAME': 'STATE_NAME'})\n    filenames = ['cb_2016_us_county_500k.dbf', 'cb_2016_us_county_500k.shp', 'cb_2016_us_county_500k.shx']\n    for j in range(len(filenames)):\n        filenames[j] = os.path.join(abs_package_data_dir_path, filenames[j])\n    dbf = io.open(filenames[0], 'rb')\n    shp = io.open(filenames[1], 'rb')\n    shx = io.open(filenames[2], 'rb')\n    r = shapefile.Reader(shp=shp, shx=shx, dbf=dbf)\n    (attributes, geometry) = ([], [])\n    field_names = [field[0] for field in r.fields[1:]]\n    for row in r.shapeRecords():\n        geometry.append(shapely.geometry.shape(row.shape.__geo_interface__))\n        attributes.append(dict(zip(field_names, row.record)))\n    gdf = gp.GeoDataFrame(data=attributes, geometry=geometry)\n    gdf['FIPS'] = gdf['STATEFP'] + gdf['COUNTYFP']\n    gdf['FIPS'] = pd.to_numeric(gdf['FIPS'])\n    f = 46113\n    singlerow = pd.DataFrame([[st_to_state_name_dict['SD'], 'SD', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '46', 'Shannon']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 51515\n    singlerow = pd.DataFrame([[st_to_state_name_dict['VA'], 'VA', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '51', 'Bedford City']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 2270\n    singlerow = pd.DataFrame([[st_to_state_name_dict['AK'], 'AK', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '02', 'Wade Hampton']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    row_2198 = gdf[gdf['FIPS'] == 2198]\n    row_2198.index = [max(gdf.index) + 1]\n    row_2198.loc[row_2198.index[0], 'FIPS'] = 2201\n    row_2198.loc[row_2198.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2198], sort=True)\n    row_2105 = gdf[gdf['FIPS'] == 2105]\n    row_2105.index = [max(gdf.index) + 1]\n    row_2105.loc[row_2105.index[0], 'FIPS'] = 2232\n    row_2105.loc[row_2105.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2105], sort=True)\n    gdf = gdf.rename(columns={'NAME': 'COUNTY_NAME'})\n    gdf_reduced = gdf[['FIPS', 'STATEFP', 'COUNTY_NAME', 'geometry']]\n    gdf_statefp = gdf_reduced.merge(df_state[['STATEFP', 'STATE_NAME']], on='STATEFP')\n    ST = []\n    for n in gdf_statefp['STATE_NAME']:\n        ST.append(state_to_st_dict[n])\n    gdf_statefp['ST'] = ST\n    return (gdf_statefp, df_state)",
            "def _create_us_counties_df(st_to_state_name_dict, state_to_st_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    abs_dir_path = os.path.realpath(_plotly_geo.__file__)\n    abs_plotly_geo_path = os.path.dirname(abs_dir_path)\n    abs_package_data_dir_path = os.path.join(abs_plotly_geo_path, 'package_data')\n    shape_pre2010 = 'gz_2010_us_050_00_500k.shp'\n    shape_pre2010 = os.path.join(abs_package_data_dir_path, shape_pre2010)\n    df_shape_pre2010 = gp.read_file(shape_pre2010)\n    df_shape_pre2010['FIPS'] = df_shape_pre2010['STATE'] + df_shape_pre2010['COUNTY']\n    df_shape_pre2010['FIPS'] = pd.to_numeric(df_shape_pre2010['FIPS'])\n    states_path = 'cb_2016_us_state_500k.shp'\n    states_path = os.path.join(abs_package_data_dir_path, states_path)\n    df_state = gp.read_file(states_path)\n    df_state = df_state[['STATEFP', 'NAME', 'geometry']]\n    df_state = df_state.rename(columns={'NAME': 'STATE_NAME'})\n    filenames = ['cb_2016_us_county_500k.dbf', 'cb_2016_us_county_500k.shp', 'cb_2016_us_county_500k.shx']\n    for j in range(len(filenames)):\n        filenames[j] = os.path.join(abs_package_data_dir_path, filenames[j])\n    dbf = io.open(filenames[0], 'rb')\n    shp = io.open(filenames[1], 'rb')\n    shx = io.open(filenames[2], 'rb')\n    r = shapefile.Reader(shp=shp, shx=shx, dbf=dbf)\n    (attributes, geometry) = ([], [])\n    field_names = [field[0] for field in r.fields[1:]]\n    for row in r.shapeRecords():\n        geometry.append(shapely.geometry.shape(row.shape.__geo_interface__))\n        attributes.append(dict(zip(field_names, row.record)))\n    gdf = gp.GeoDataFrame(data=attributes, geometry=geometry)\n    gdf['FIPS'] = gdf['STATEFP'] + gdf['COUNTYFP']\n    gdf['FIPS'] = pd.to_numeric(gdf['FIPS'])\n    f = 46113\n    singlerow = pd.DataFrame([[st_to_state_name_dict['SD'], 'SD', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '46', 'Shannon']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 51515\n    singlerow = pd.DataFrame([[st_to_state_name_dict['VA'], 'VA', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '51', 'Bedford City']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 2270\n    singlerow = pd.DataFrame([[st_to_state_name_dict['AK'], 'AK', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '02', 'Wade Hampton']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    row_2198 = gdf[gdf['FIPS'] == 2198]\n    row_2198.index = [max(gdf.index) + 1]\n    row_2198.loc[row_2198.index[0], 'FIPS'] = 2201\n    row_2198.loc[row_2198.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2198], sort=True)\n    row_2105 = gdf[gdf['FIPS'] == 2105]\n    row_2105.index = [max(gdf.index) + 1]\n    row_2105.loc[row_2105.index[0], 'FIPS'] = 2232\n    row_2105.loc[row_2105.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2105], sort=True)\n    gdf = gdf.rename(columns={'NAME': 'COUNTY_NAME'})\n    gdf_reduced = gdf[['FIPS', 'STATEFP', 'COUNTY_NAME', 'geometry']]\n    gdf_statefp = gdf_reduced.merge(df_state[['STATEFP', 'STATE_NAME']], on='STATEFP')\n    ST = []\n    for n in gdf_statefp['STATE_NAME']:\n        ST.append(state_to_st_dict[n])\n    gdf_statefp['ST'] = ST\n    return (gdf_statefp, df_state)",
            "def _create_us_counties_df(st_to_state_name_dict, state_to_st_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    abs_dir_path = os.path.realpath(_plotly_geo.__file__)\n    abs_plotly_geo_path = os.path.dirname(abs_dir_path)\n    abs_package_data_dir_path = os.path.join(abs_plotly_geo_path, 'package_data')\n    shape_pre2010 = 'gz_2010_us_050_00_500k.shp'\n    shape_pre2010 = os.path.join(abs_package_data_dir_path, shape_pre2010)\n    df_shape_pre2010 = gp.read_file(shape_pre2010)\n    df_shape_pre2010['FIPS'] = df_shape_pre2010['STATE'] + df_shape_pre2010['COUNTY']\n    df_shape_pre2010['FIPS'] = pd.to_numeric(df_shape_pre2010['FIPS'])\n    states_path = 'cb_2016_us_state_500k.shp'\n    states_path = os.path.join(abs_package_data_dir_path, states_path)\n    df_state = gp.read_file(states_path)\n    df_state = df_state[['STATEFP', 'NAME', 'geometry']]\n    df_state = df_state.rename(columns={'NAME': 'STATE_NAME'})\n    filenames = ['cb_2016_us_county_500k.dbf', 'cb_2016_us_county_500k.shp', 'cb_2016_us_county_500k.shx']\n    for j in range(len(filenames)):\n        filenames[j] = os.path.join(abs_package_data_dir_path, filenames[j])\n    dbf = io.open(filenames[0], 'rb')\n    shp = io.open(filenames[1], 'rb')\n    shx = io.open(filenames[2], 'rb')\n    r = shapefile.Reader(shp=shp, shx=shx, dbf=dbf)\n    (attributes, geometry) = ([], [])\n    field_names = [field[0] for field in r.fields[1:]]\n    for row in r.shapeRecords():\n        geometry.append(shapely.geometry.shape(row.shape.__geo_interface__))\n        attributes.append(dict(zip(field_names, row.record)))\n    gdf = gp.GeoDataFrame(data=attributes, geometry=geometry)\n    gdf['FIPS'] = gdf['STATEFP'] + gdf['COUNTYFP']\n    gdf['FIPS'] = pd.to_numeric(gdf['FIPS'])\n    f = 46113\n    singlerow = pd.DataFrame([[st_to_state_name_dict['SD'], 'SD', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '46', 'Shannon']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 51515\n    singlerow = pd.DataFrame([[st_to_state_name_dict['VA'], 'VA', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '51', 'Bedford City']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 2270\n    singlerow = pd.DataFrame([[st_to_state_name_dict['AK'], 'AK', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '02', 'Wade Hampton']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    row_2198 = gdf[gdf['FIPS'] == 2198]\n    row_2198.index = [max(gdf.index) + 1]\n    row_2198.loc[row_2198.index[0], 'FIPS'] = 2201\n    row_2198.loc[row_2198.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2198], sort=True)\n    row_2105 = gdf[gdf['FIPS'] == 2105]\n    row_2105.index = [max(gdf.index) + 1]\n    row_2105.loc[row_2105.index[0], 'FIPS'] = 2232\n    row_2105.loc[row_2105.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2105], sort=True)\n    gdf = gdf.rename(columns={'NAME': 'COUNTY_NAME'})\n    gdf_reduced = gdf[['FIPS', 'STATEFP', 'COUNTY_NAME', 'geometry']]\n    gdf_statefp = gdf_reduced.merge(df_state[['STATEFP', 'STATE_NAME']], on='STATEFP')\n    ST = []\n    for n in gdf_statefp['STATE_NAME']:\n        ST.append(state_to_st_dict[n])\n    gdf_statefp['ST'] = ST\n    return (gdf_statefp, df_state)",
            "def _create_us_counties_df(st_to_state_name_dict, state_to_st_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    abs_dir_path = os.path.realpath(_plotly_geo.__file__)\n    abs_plotly_geo_path = os.path.dirname(abs_dir_path)\n    abs_package_data_dir_path = os.path.join(abs_plotly_geo_path, 'package_data')\n    shape_pre2010 = 'gz_2010_us_050_00_500k.shp'\n    shape_pre2010 = os.path.join(abs_package_data_dir_path, shape_pre2010)\n    df_shape_pre2010 = gp.read_file(shape_pre2010)\n    df_shape_pre2010['FIPS'] = df_shape_pre2010['STATE'] + df_shape_pre2010['COUNTY']\n    df_shape_pre2010['FIPS'] = pd.to_numeric(df_shape_pre2010['FIPS'])\n    states_path = 'cb_2016_us_state_500k.shp'\n    states_path = os.path.join(abs_package_data_dir_path, states_path)\n    df_state = gp.read_file(states_path)\n    df_state = df_state[['STATEFP', 'NAME', 'geometry']]\n    df_state = df_state.rename(columns={'NAME': 'STATE_NAME'})\n    filenames = ['cb_2016_us_county_500k.dbf', 'cb_2016_us_county_500k.shp', 'cb_2016_us_county_500k.shx']\n    for j in range(len(filenames)):\n        filenames[j] = os.path.join(abs_package_data_dir_path, filenames[j])\n    dbf = io.open(filenames[0], 'rb')\n    shp = io.open(filenames[1], 'rb')\n    shx = io.open(filenames[2], 'rb')\n    r = shapefile.Reader(shp=shp, shx=shx, dbf=dbf)\n    (attributes, geometry) = ([], [])\n    field_names = [field[0] for field in r.fields[1:]]\n    for row in r.shapeRecords():\n        geometry.append(shapely.geometry.shape(row.shape.__geo_interface__))\n        attributes.append(dict(zip(field_names, row.record)))\n    gdf = gp.GeoDataFrame(data=attributes, geometry=geometry)\n    gdf['FIPS'] = gdf['STATEFP'] + gdf['COUNTYFP']\n    gdf['FIPS'] = pd.to_numeric(gdf['FIPS'])\n    f = 46113\n    singlerow = pd.DataFrame([[st_to_state_name_dict['SD'], 'SD', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '46', 'Shannon']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 51515\n    singlerow = pd.DataFrame([[st_to_state_name_dict['VA'], 'VA', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '51', 'Bedford City']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 2270\n    singlerow = pd.DataFrame([[st_to_state_name_dict['AK'], 'AK', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '02', 'Wade Hampton']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    row_2198 = gdf[gdf['FIPS'] == 2198]\n    row_2198.index = [max(gdf.index) + 1]\n    row_2198.loc[row_2198.index[0], 'FIPS'] = 2201\n    row_2198.loc[row_2198.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2198], sort=True)\n    row_2105 = gdf[gdf['FIPS'] == 2105]\n    row_2105.index = [max(gdf.index) + 1]\n    row_2105.loc[row_2105.index[0], 'FIPS'] = 2232\n    row_2105.loc[row_2105.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2105], sort=True)\n    gdf = gdf.rename(columns={'NAME': 'COUNTY_NAME'})\n    gdf_reduced = gdf[['FIPS', 'STATEFP', 'COUNTY_NAME', 'geometry']]\n    gdf_statefp = gdf_reduced.merge(df_state[['STATEFP', 'STATE_NAME']], on='STATEFP')\n    ST = []\n    for n in gdf_statefp['STATE_NAME']:\n        ST.append(state_to_st_dict[n])\n    gdf_statefp['ST'] = ST\n    return (gdf_statefp, df_state)",
            "def _create_us_counties_df(st_to_state_name_dict, state_to_st_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    abs_dir_path = os.path.realpath(_plotly_geo.__file__)\n    abs_plotly_geo_path = os.path.dirname(abs_dir_path)\n    abs_package_data_dir_path = os.path.join(abs_plotly_geo_path, 'package_data')\n    shape_pre2010 = 'gz_2010_us_050_00_500k.shp'\n    shape_pre2010 = os.path.join(abs_package_data_dir_path, shape_pre2010)\n    df_shape_pre2010 = gp.read_file(shape_pre2010)\n    df_shape_pre2010['FIPS'] = df_shape_pre2010['STATE'] + df_shape_pre2010['COUNTY']\n    df_shape_pre2010['FIPS'] = pd.to_numeric(df_shape_pre2010['FIPS'])\n    states_path = 'cb_2016_us_state_500k.shp'\n    states_path = os.path.join(abs_package_data_dir_path, states_path)\n    df_state = gp.read_file(states_path)\n    df_state = df_state[['STATEFP', 'NAME', 'geometry']]\n    df_state = df_state.rename(columns={'NAME': 'STATE_NAME'})\n    filenames = ['cb_2016_us_county_500k.dbf', 'cb_2016_us_county_500k.shp', 'cb_2016_us_county_500k.shx']\n    for j in range(len(filenames)):\n        filenames[j] = os.path.join(abs_package_data_dir_path, filenames[j])\n    dbf = io.open(filenames[0], 'rb')\n    shp = io.open(filenames[1], 'rb')\n    shx = io.open(filenames[2], 'rb')\n    r = shapefile.Reader(shp=shp, shx=shx, dbf=dbf)\n    (attributes, geometry) = ([], [])\n    field_names = [field[0] for field in r.fields[1:]]\n    for row in r.shapeRecords():\n        geometry.append(shapely.geometry.shape(row.shape.__geo_interface__))\n        attributes.append(dict(zip(field_names, row.record)))\n    gdf = gp.GeoDataFrame(data=attributes, geometry=geometry)\n    gdf['FIPS'] = gdf['STATEFP'] + gdf['COUNTYFP']\n    gdf['FIPS'] = pd.to_numeric(gdf['FIPS'])\n    f = 46113\n    singlerow = pd.DataFrame([[st_to_state_name_dict['SD'], 'SD', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '46', 'Shannon']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 51515\n    singlerow = pd.DataFrame([[st_to_state_name_dict['VA'], 'VA', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '51', 'Bedford City']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    f = 2270\n    singlerow = pd.DataFrame([[st_to_state_name_dict['AK'], 'AK', df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['geometry'].iloc[0], df_shape_pre2010[df_shape_pre2010['FIPS'] == f]['FIPS'].iloc[0], '02', 'Wade Hampton']], columns=['State', 'ST', 'geometry', 'FIPS', 'STATEFP', 'NAME'], index=[max(gdf.index) + 1])\n    gdf = pd.concat([gdf, singlerow], sort=True)\n    row_2198 = gdf[gdf['FIPS'] == 2198]\n    row_2198.index = [max(gdf.index) + 1]\n    row_2198.loc[row_2198.index[0], 'FIPS'] = 2201\n    row_2198.loc[row_2198.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2198], sort=True)\n    row_2105 = gdf[gdf['FIPS'] == 2105]\n    row_2105.index = [max(gdf.index) + 1]\n    row_2105.loc[row_2105.index[0], 'FIPS'] = 2232\n    row_2105.loc[row_2105.index[0], 'STATEFP'] = '02'\n    gdf = pd.concat([gdf, row_2105], sort=True)\n    gdf = gdf.rename(columns={'NAME': 'COUNTY_NAME'})\n    gdf_reduced = gdf[['FIPS', 'STATEFP', 'COUNTY_NAME', 'geometry']]\n    gdf_statefp = gdf_reduced.merge(df_state[['STATEFP', 'STATE_NAME']], on='STATEFP')\n    ST = []\n    for n in gdf_statefp['STATE_NAME']:\n        ST.append(state_to_st_dict[n])\n    gdf_statefp['ST'] = ST\n    return (gdf_statefp, df_state)"
        ]
    },
    {
        "func_name": "_human_format",
        "original": "def _human_format(number):\n    units = ['', 'K', 'M', 'G', 'T', 'P']\n    k = 1000.0\n    magnitude = int(floor(log(number, k)))\n    return '%.2f%s' % (number / k ** magnitude, units[magnitude])",
        "mutated": [
            "def _human_format(number):\n    if False:\n        i = 10\n    units = ['', 'K', 'M', 'G', 'T', 'P']\n    k = 1000.0\n    magnitude = int(floor(log(number, k)))\n    return '%.2f%s' % (number / k ** magnitude, units[magnitude])",
            "def _human_format(number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    units = ['', 'K', 'M', 'G', 'T', 'P']\n    k = 1000.0\n    magnitude = int(floor(log(number, k)))\n    return '%.2f%s' % (number / k ** magnitude, units[magnitude])",
            "def _human_format(number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    units = ['', 'K', 'M', 'G', 'T', 'P']\n    k = 1000.0\n    magnitude = int(floor(log(number, k)))\n    return '%.2f%s' % (number / k ** magnitude, units[magnitude])",
            "def _human_format(number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    units = ['', 'K', 'M', 'G', 'T', 'P']\n    k = 1000.0\n    magnitude = int(floor(log(number, k)))\n    return '%.2f%s' % (number / k ** magnitude, units[magnitude])",
            "def _human_format(number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    units = ['', 'K', 'M', 'G', 'T', 'P']\n    k = 1000.0\n    magnitude = int(floor(log(number, k)))\n    return '%.2f%s' % (number / k ** magnitude, units[magnitude])"
        ]
    },
    {
        "func_name": "_intervals_as_labels",
        "original": "def _intervals_as_labels(array_of_intervals, round_legend_values, exponent_format):\n    \"\"\"\n    Transform an number interval to a clean string for legend\n\n    Example: [-inf, 30] to '< 30'\n    \"\"\"\n    infs = [float('-inf'), float('inf')]\n    string_intervals = []\n    for interval in array_of_intervals:\n        if round_legend_values:\n            rnd_interval = [int(interval[i]) if interval[i] not in infs else interval[i] for i in range(2)]\n        else:\n            rnd_interval = [round(interval[0], 2), round(interval[1], 2)]\n        num0 = rnd_interval[0]\n        num1 = rnd_interval[1]\n        if exponent_format:\n            if num0 not in infs:\n                num0 = _human_format(num0)\n            if num1 not in infs:\n                num1 = _human_format(num1)\n        else:\n            if num0 not in infs:\n                num0 = '{:,}'.format(num0)\n            if num1 not in infs:\n                num1 = '{:,}'.format(num1)\n        if num0 == float('-inf'):\n            as_str = '< {}'.format(num1)\n        elif num1 == float('inf'):\n            as_str = '> {}'.format(num0)\n        else:\n            as_str = '{} - {}'.format(num0, num1)\n        string_intervals.append(as_str)\n    return string_intervals",
        "mutated": [
            "def _intervals_as_labels(array_of_intervals, round_legend_values, exponent_format):\n    if False:\n        i = 10\n    \"\\n    Transform an number interval to a clean string for legend\\n\\n    Example: [-inf, 30] to '< 30'\\n    \"\n    infs = [float('-inf'), float('inf')]\n    string_intervals = []\n    for interval in array_of_intervals:\n        if round_legend_values:\n            rnd_interval = [int(interval[i]) if interval[i] not in infs else interval[i] for i in range(2)]\n        else:\n            rnd_interval = [round(interval[0], 2), round(interval[1], 2)]\n        num0 = rnd_interval[0]\n        num1 = rnd_interval[1]\n        if exponent_format:\n            if num0 not in infs:\n                num0 = _human_format(num0)\n            if num1 not in infs:\n                num1 = _human_format(num1)\n        else:\n            if num0 not in infs:\n                num0 = '{:,}'.format(num0)\n            if num1 not in infs:\n                num1 = '{:,}'.format(num1)\n        if num0 == float('-inf'):\n            as_str = '< {}'.format(num1)\n        elif num1 == float('inf'):\n            as_str = '> {}'.format(num0)\n        else:\n            as_str = '{} - {}'.format(num0, num1)\n        string_intervals.append(as_str)\n    return string_intervals",
            "def _intervals_as_labels(array_of_intervals, round_legend_values, exponent_format):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Transform an number interval to a clean string for legend\\n\\n    Example: [-inf, 30] to '< 30'\\n    \"\n    infs = [float('-inf'), float('inf')]\n    string_intervals = []\n    for interval in array_of_intervals:\n        if round_legend_values:\n            rnd_interval = [int(interval[i]) if interval[i] not in infs else interval[i] for i in range(2)]\n        else:\n            rnd_interval = [round(interval[0], 2), round(interval[1], 2)]\n        num0 = rnd_interval[0]\n        num1 = rnd_interval[1]\n        if exponent_format:\n            if num0 not in infs:\n                num0 = _human_format(num0)\n            if num1 not in infs:\n                num1 = _human_format(num1)\n        else:\n            if num0 not in infs:\n                num0 = '{:,}'.format(num0)\n            if num1 not in infs:\n                num1 = '{:,}'.format(num1)\n        if num0 == float('-inf'):\n            as_str = '< {}'.format(num1)\n        elif num1 == float('inf'):\n            as_str = '> {}'.format(num0)\n        else:\n            as_str = '{} - {}'.format(num0, num1)\n        string_intervals.append(as_str)\n    return string_intervals",
            "def _intervals_as_labels(array_of_intervals, round_legend_values, exponent_format):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Transform an number interval to a clean string for legend\\n\\n    Example: [-inf, 30] to '< 30'\\n    \"\n    infs = [float('-inf'), float('inf')]\n    string_intervals = []\n    for interval in array_of_intervals:\n        if round_legend_values:\n            rnd_interval = [int(interval[i]) if interval[i] not in infs else interval[i] for i in range(2)]\n        else:\n            rnd_interval = [round(interval[0], 2), round(interval[1], 2)]\n        num0 = rnd_interval[0]\n        num1 = rnd_interval[1]\n        if exponent_format:\n            if num0 not in infs:\n                num0 = _human_format(num0)\n            if num1 not in infs:\n                num1 = _human_format(num1)\n        else:\n            if num0 not in infs:\n                num0 = '{:,}'.format(num0)\n            if num1 not in infs:\n                num1 = '{:,}'.format(num1)\n        if num0 == float('-inf'):\n            as_str = '< {}'.format(num1)\n        elif num1 == float('inf'):\n            as_str = '> {}'.format(num0)\n        else:\n            as_str = '{} - {}'.format(num0, num1)\n        string_intervals.append(as_str)\n    return string_intervals",
            "def _intervals_as_labels(array_of_intervals, round_legend_values, exponent_format):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Transform an number interval to a clean string for legend\\n\\n    Example: [-inf, 30] to '< 30'\\n    \"\n    infs = [float('-inf'), float('inf')]\n    string_intervals = []\n    for interval in array_of_intervals:\n        if round_legend_values:\n            rnd_interval = [int(interval[i]) if interval[i] not in infs else interval[i] for i in range(2)]\n        else:\n            rnd_interval = [round(interval[0], 2), round(interval[1], 2)]\n        num0 = rnd_interval[0]\n        num1 = rnd_interval[1]\n        if exponent_format:\n            if num0 not in infs:\n                num0 = _human_format(num0)\n            if num1 not in infs:\n                num1 = _human_format(num1)\n        else:\n            if num0 not in infs:\n                num0 = '{:,}'.format(num0)\n            if num1 not in infs:\n                num1 = '{:,}'.format(num1)\n        if num0 == float('-inf'):\n            as_str = '< {}'.format(num1)\n        elif num1 == float('inf'):\n            as_str = '> {}'.format(num0)\n        else:\n            as_str = '{} - {}'.format(num0, num1)\n        string_intervals.append(as_str)\n    return string_intervals",
            "def _intervals_as_labels(array_of_intervals, round_legend_values, exponent_format):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Transform an number interval to a clean string for legend\\n\\n    Example: [-inf, 30] to '< 30'\\n    \"\n    infs = [float('-inf'), float('inf')]\n    string_intervals = []\n    for interval in array_of_intervals:\n        if round_legend_values:\n            rnd_interval = [int(interval[i]) if interval[i] not in infs else interval[i] for i in range(2)]\n        else:\n            rnd_interval = [round(interval[0], 2), round(interval[1], 2)]\n        num0 = rnd_interval[0]\n        num1 = rnd_interval[1]\n        if exponent_format:\n            if num0 not in infs:\n                num0 = _human_format(num0)\n            if num1 not in infs:\n                num1 = _human_format(num1)\n        else:\n            if num0 not in infs:\n                num0 = '{:,}'.format(num0)\n            if num1 not in infs:\n                num1 = '{:,}'.format(num1)\n        if num0 == float('-inf'):\n            as_str = '< {}'.format(num1)\n        elif num1 == float('inf'):\n            as_str = '> {}'.format(num0)\n        else:\n            as_str = '{} - {}'.format(num0, num1)\n        string_intervals.append(as_str)\n    return string_intervals"
        ]
    },
    {
        "func_name": "_calculations",
        "original": "def _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map):\n    padded_f = str(f).zfill(5)\n    if fips_polygon_map[f].type == 'Polygon':\n        x = fips_polygon_map[f].simplify(simplify_county).exterior.xy[0].tolist()\n        y = fips_polygon_map[f].simplify(simplify_county).exterior.xy[1].tolist()\n        (x_c, y_c) = fips_polygon_map[f].centroid.xy\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        t_c = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        x_centroids.append(x_c[0])\n        y_centroids.append(y_c[0])\n        centroid_text.append(t_c)\n        x_traces[level] = x_traces[level] + x + [np.nan]\n        y_traces[level] = y_traces[level] + y + [np.nan]\n    elif fips_polygon_map[f].type == 'MultiPolygon':\n        x = [poly.simplify(simplify_county).exterior.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y = [poly.simplify(simplify_county).exterior.xy[1].tolist() for poly in fips_polygon_map[f]]\n        x_c = [poly.centroid.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y_c = [poly.centroid.xy[1].tolist() for poly in fips_polygon_map[f]]\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        text = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        t_c = [text for poly in fips_polygon_map[f]]\n        x_centroids = x_c + x_centroids\n        y_centroids = y_c + y_centroids\n        centroid_text = t_c + centroid_text\n        for x_y_idx in range(len(x)):\n            x_traces[level] = x_traces[level] + x[x_y_idx] + [np.nan]\n            y_traces[level] = y_traces[level] + y[x_y_idx] + [np.nan]\n    return (x_traces, y_traces, x_centroids, y_centroids, centroid_text)",
        "mutated": [
            "def _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map):\n    if False:\n        i = 10\n    padded_f = str(f).zfill(5)\n    if fips_polygon_map[f].type == 'Polygon':\n        x = fips_polygon_map[f].simplify(simplify_county).exterior.xy[0].tolist()\n        y = fips_polygon_map[f].simplify(simplify_county).exterior.xy[1].tolist()\n        (x_c, y_c) = fips_polygon_map[f].centroid.xy\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        t_c = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        x_centroids.append(x_c[0])\n        y_centroids.append(y_c[0])\n        centroid_text.append(t_c)\n        x_traces[level] = x_traces[level] + x + [np.nan]\n        y_traces[level] = y_traces[level] + y + [np.nan]\n    elif fips_polygon_map[f].type == 'MultiPolygon':\n        x = [poly.simplify(simplify_county).exterior.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y = [poly.simplify(simplify_county).exterior.xy[1].tolist() for poly in fips_polygon_map[f]]\n        x_c = [poly.centroid.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y_c = [poly.centroid.xy[1].tolist() for poly in fips_polygon_map[f]]\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        text = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        t_c = [text for poly in fips_polygon_map[f]]\n        x_centroids = x_c + x_centroids\n        y_centroids = y_c + y_centroids\n        centroid_text = t_c + centroid_text\n        for x_y_idx in range(len(x)):\n            x_traces[level] = x_traces[level] + x[x_y_idx] + [np.nan]\n            y_traces[level] = y_traces[level] + y[x_y_idx] + [np.nan]\n    return (x_traces, y_traces, x_centroids, y_centroids, centroid_text)",
            "def _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    padded_f = str(f).zfill(5)\n    if fips_polygon_map[f].type == 'Polygon':\n        x = fips_polygon_map[f].simplify(simplify_county).exterior.xy[0].tolist()\n        y = fips_polygon_map[f].simplify(simplify_county).exterior.xy[1].tolist()\n        (x_c, y_c) = fips_polygon_map[f].centroid.xy\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        t_c = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        x_centroids.append(x_c[0])\n        y_centroids.append(y_c[0])\n        centroid_text.append(t_c)\n        x_traces[level] = x_traces[level] + x + [np.nan]\n        y_traces[level] = y_traces[level] + y + [np.nan]\n    elif fips_polygon_map[f].type == 'MultiPolygon':\n        x = [poly.simplify(simplify_county).exterior.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y = [poly.simplify(simplify_county).exterior.xy[1].tolist() for poly in fips_polygon_map[f]]\n        x_c = [poly.centroid.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y_c = [poly.centroid.xy[1].tolist() for poly in fips_polygon_map[f]]\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        text = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        t_c = [text for poly in fips_polygon_map[f]]\n        x_centroids = x_c + x_centroids\n        y_centroids = y_c + y_centroids\n        centroid_text = t_c + centroid_text\n        for x_y_idx in range(len(x)):\n            x_traces[level] = x_traces[level] + x[x_y_idx] + [np.nan]\n            y_traces[level] = y_traces[level] + y[x_y_idx] + [np.nan]\n    return (x_traces, y_traces, x_centroids, y_centroids, centroid_text)",
            "def _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    padded_f = str(f).zfill(5)\n    if fips_polygon_map[f].type == 'Polygon':\n        x = fips_polygon_map[f].simplify(simplify_county).exterior.xy[0].tolist()\n        y = fips_polygon_map[f].simplify(simplify_county).exterior.xy[1].tolist()\n        (x_c, y_c) = fips_polygon_map[f].centroid.xy\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        t_c = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        x_centroids.append(x_c[0])\n        y_centroids.append(y_c[0])\n        centroid_text.append(t_c)\n        x_traces[level] = x_traces[level] + x + [np.nan]\n        y_traces[level] = y_traces[level] + y + [np.nan]\n    elif fips_polygon_map[f].type == 'MultiPolygon':\n        x = [poly.simplify(simplify_county).exterior.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y = [poly.simplify(simplify_county).exterior.xy[1].tolist() for poly in fips_polygon_map[f]]\n        x_c = [poly.centroid.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y_c = [poly.centroid.xy[1].tolist() for poly in fips_polygon_map[f]]\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        text = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        t_c = [text for poly in fips_polygon_map[f]]\n        x_centroids = x_c + x_centroids\n        y_centroids = y_c + y_centroids\n        centroid_text = t_c + centroid_text\n        for x_y_idx in range(len(x)):\n            x_traces[level] = x_traces[level] + x[x_y_idx] + [np.nan]\n            y_traces[level] = y_traces[level] + y[x_y_idx] + [np.nan]\n    return (x_traces, y_traces, x_centroids, y_centroids, centroid_text)",
            "def _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    padded_f = str(f).zfill(5)\n    if fips_polygon_map[f].type == 'Polygon':\n        x = fips_polygon_map[f].simplify(simplify_county).exterior.xy[0].tolist()\n        y = fips_polygon_map[f].simplify(simplify_county).exterior.xy[1].tolist()\n        (x_c, y_c) = fips_polygon_map[f].centroid.xy\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        t_c = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        x_centroids.append(x_c[0])\n        y_centroids.append(y_c[0])\n        centroid_text.append(t_c)\n        x_traces[level] = x_traces[level] + x + [np.nan]\n        y_traces[level] = y_traces[level] + y + [np.nan]\n    elif fips_polygon_map[f].type == 'MultiPolygon':\n        x = [poly.simplify(simplify_county).exterior.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y = [poly.simplify(simplify_county).exterior.xy[1].tolist() for poly in fips_polygon_map[f]]\n        x_c = [poly.centroid.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y_c = [poly.centroid.xy[1].tolist() for poly in fips_polygon_map[f]]\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        text = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        t_c = [text for poly in fips_polygon_map[f]]\n        x_centroids = x_c + x_centroids\n        y_centroids = y_c + y_centroids\n        centroid_text = t_c + centroid_text\n        for x_y_idx in range(len(x)):\n            x_traces[level] = x_traces[level] + x[x_y_idx] + [np.nan]\n            y_traces[level] = y_traces[level] + y[x_y_idx] + [np.nan]\n    return (x_traces, y_traces, x_centroids, y_centroids, centroid_text)",
            "def _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    padded_f = str(f).zfill(5)\n    if fips_polygon_map[f].type == 'Polygon':\n        x = fips_polygon_map[f].simplify(simplify_county).exterior.xy[0].tolist()\n        y = fips_polygon_map[f].simplify(simplify_county).exterior.xy[1].tolist()\n        (x_c, y_c) = fips_polygon_map[f].centroid.xy\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        t_c = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        x_centroids.append(x_c[0])\n        y_centroids.append(y_c[0])\n        centroid_text.append(t_c)\n        x_traces[level] = x_traces[level] + x + [np.nan]\n        y_traces[level] = y_traces[level] + y + [np.nan]\n    elif fips_polygon_map[f].type == 'MultiPolygon':\n        x = [poly.simplify(simplify_county).exterior.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y = [poly.simplify(simplify_county).exterior.xy[1].tolist() for poly in fips_polygon_map[f]]\n        x_c = [poly.centroid.xy[0].tolist() for poly in fips_polygon_map[f]]\n        y_c = [poly.centroid.xy[1].tolist() for poly in fips_polygon_map[f]]\n        county_name_str = str(df[df['FIPS'] == f]['COUNTY_NAME'].iloc[0])\n        state_name_str = str(df[df['FIPS'] == f]['STATE_NAME'].iloc[0])\n        text = 'County: ' + county_name_str + '<br>' + 'State: ' + state_name_str + '<br>' + 'FIPS: ' + padded_f + '<br>Value: ' + str(values[index])\n        t_c = [text for poly in fips_polygon_map[f]]\n        x_centroids = x_c + x_centroids\n        y_centroids = y_c + y_centroids\n        centroid_text = t_c + centroid_text\n        for x_y_idx in range(len(x)):\n            x_traces[level] = x_traces[level] + x[x_y_idx] + [np.nan]\n            y_traces[level] = y_traces[level] + y[x_y_idx] + [np.nan]\n    return (x_traces, y_traces, x_centroids, y_centroids, centroid_text)"
        ]
    },
    {
        "func_name": "create_choropleth",
        "original": "def create_choropleth(fips, values, scope=['usa'], binning_endpoints=None, colorscale=None, order=None, simplify_county=0.02, simplify_state=0.02, asp=None, show_hover=True, show_state_data=True, state_outline=None, county_outline=None, centroid_marker=None, round_legend_values=False, exponent_format=False, legend_title='', **layout_options):\n    \"\"\"\n    **deprecated**, use instead\n    :func:`plotly.express.choropleth` with custom GeoJSON.\n\n    This function also requires `shapely`, `geopandas` and `plotly-geo` to be installed.\n\n    Returns figure for county choropleth. Uses data from package_data.\n\n    :param (list) fips: list of FIPS values which correspond to the con\n        catination of state and county ids. An example is '01001'.\n    :param (list) values: list of numbers/strings which correspond to the\n        fips list. These are the values that will determine how the counties\n        are colored.\n    :param (list) scope: list of states and/or states abbreviations. Fits\n        all states in the camera tightly. Selecting ['usa'] is the equivalent\n        of appending all 50 states into your scope list. Selecting only 'usa'\n        does not include 'Alaska', 'Puerto Rico', 'American Samoa',\n        'Commonwealth of the Northern Mariana Islands', 'Guam',\n        'United States Virgin Islands'. These must be added manually to the\n        list.\n        Default = ['usa']\n    :param (list) binning_endpoints: ascending numbers which implicitly define\n        real number intervals which are used as bins. The colorscale used must\n        have the same number of colors as the number of bins and this will\n        result in a categorical colormap.\n    :param (list) colorscale: a list of colors with length equal to the\n        number of categories of colors. The length must match either all\n        unique numbers in the 'values' list or if endpoints is being used, the\n        number of categories created by the endpoints.\n\n        For example, if binning_endpoints = [4, 6, 8], then there are 4 bins:\n        [-inf, 4), [4, 6), [6, 8), [8, inf)\n    :param (list) order: a list of the unique categories (numbers/bins) in any\n        desired order. This is helpful if you want to order string values to\n        a chosen colorscale.\n    :param (float) simplify_county: determines the simplification factor\n        for the counties. The larger the number, the fewer vertices and edges\n        each polygon has. See\n        http://toblerity.org/shapely/manual.html#object.simplify for more\n        information.\n        Default = 0.02\n    :param (float) simplify_state: simplifies the state outline polygon.\n        See http://toblerity.org/shapely/manual.html#object.simplify for more\n        information.\n        Default = 0.02\n    :param (float) asp: the width-to-height aspect ratio for the camera.\n        Default = 2.5\n    :param (bool) show_hover: show county hover and centroid info\n    :param (bool) show_state_data: reveals state boundary lines\n    :param (dict) state_outline: dict of attributes of the state outline\n        including width and color. See\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\n        params\n    :param (dict) county_outline: dict of attributes of the county outline\n        including width and color. See\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\n        params\n    :param (dict) centroid_marker: dict of attributes of the centroid marker.\n        The centroid markers are invisible by default and appear visible on\n        selection. See https://plot.ly/python/reference/#scatter-marker for\n        all valid params\n    :param (bool) round_legend_values: automatically round the numbers that\n        appear in the legend to the nearest integer.\n        Default = False\n    :param (bool) exponent_format: if set to True, puts numbers in the K, M,\n        B number format. For example 4000.0 becomes 4.0K\n        Default = False\n    :param (str) legend_title: title that appears above the legend\n    :param **layout_options: a **kwargs argument for all layout parameters\n\n\n    Example 1: Florida::\n\n        import plotly.plotly as py\n        import plotly.figure_factory as ff\n\n        import numpy as np\n        import pandas as pd\n\n        df_sample = pd.read_csv(\n            'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv'\n        )\n        df_sample_r = df_sample[df_sample['STNAME'] == 'Florida']\n\n        values = df_sample_r['TOT_POP'].tolist()\n        fips = df_sample_r['FIPS'].tolist()\n\n        binning_endpoints = list(np.mgrid[min(values):max(values):4j])\n        colorscale = [\"#030512\",\"#1d1d3b\",\"#323268\",\"#3d4b94\",\"#3e6ab0\",\n                    \"#4989bc\",\"#60a7c7\",\"#85c5d3\",\"#b7e0e4\",\"#eafcfd\"]\n        fig = ff.create_choropleth(\n            fips=fips, values=values, scope=['Florida'], show_state_data=True,\n            colorscale=colorscale, binning_endpoints=binning_endpoints,\n            round_legend_values=True, plot_bgcolor='rgb(229,229,229)',\n            paper_bgcolor='rgb(229,229,229)', legend_title='Florida Population',\n            county_outline={'color': 'rgb(255,255,255)', 'width': 0.5},\n            exponent_format=True,\n        )\n\n    Example 2: New England::\n\n        import plotly.figure_factory as ff\n\n        import pandas as pd\n\n        NE_states = ['Connecticut', 'Maine', 'Massachusetts',\n                    'New Hampshire', 'Rhode Island']\n        df_sample = pd.read_csv(\n            'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv'\n        )\n        df_sample_r = df_sample[df_sample['STNAME'].isin(NE_states)]\n        colorscale = ['rgb(68.0, 1.0, 84.0)',\n        'rgb(66.0, 64.0, 134.0)',\n        'rgb(38.0, 130.0, 142.0)',\n        'rgb(63.0, 188.0, 115.0)',\n        'rgb(216.0, 226.0, 25.0)']\n\n        values = df_sample_r['TOT_POP'].tolist()\n        fips = df_sample_r['FIPS'].tolist()\n        fig = ff.create_choropleth(\n            fips=fips, values=values, scope=NE_states, show_state_data=True\n        )\n        fig.show()\n\n    Example 3: California and Surrounding States::\n\n        import plotly.figure_factory as ff\n\n        import pandas as pd\n\n        df_sample = pd.read_csv(\n            'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv'\n        )\n        df_sample_r = df_sample[df_sample['STNAME'] == 'California']\n\n        values = df_sample_r['TOT_POP'].tolist()\n        fips = df_sample_r['FIPS'].tolist()\n\n        colorscale = [\n            'rgb(193, 193, 193)',\n            'rgb(239,239,239)',\n            'rgb(195, 196, 222)',\n            'rgb(144,148,194)',\n            'rgb(101,104,168)',\n            'rgb(65, 53, 132)'\n        ]\n\n        fig = ff.create_choropleth(\n            fips=fips, values=values, colorscale=colorscale,\n            scope=['CA', 'AZ', 'Nevada', 'Oregon', ' Idaho'],\n            binning_endpoints=[14348, 63983, 134827, 426762, 2081313],\n            county_outline={'color': 'rgb(255,255,255)', 'width': 0.5},\n            legend_title='California Counties',\n            title='California and Nearby States'\n        )\n        fig.show()\n\n    Example 4: USA::\n\n        import plotly.figure_factory as ff\n\n        import numpy as np\n        import pandas as pd\n\n        df_sample = pd.read_csv(\n            'https://raw.githubusercontent.com/plotly/datasets/master/laucnty16.csv'\n        )\n        df_sample['State FIPS Code'] = df_sample['State FIPS Code'].apply(\n            lambda x: str(x).zfill(2)\n        )\n        df_sample['County FIPS Code'] = df_sample['County FIPS Code'].apply(\n            lambda x: str(x).zfill(3)\n        )\n        df_sample['FIPS'] = (\n            df_sample['State FIPS Code'] + df_sample['County FIPS Code']\n        )\n\n        binning_endpoints = list(np.linspace(1, 12, len(colorscale) - 1))\n        colorscale = [\"#f7fbff\", \"#ebf3fb\", \"#deebf7\", \"#d2e3f3\", \"#c6dbef\",\n                    \"#b3d2e9\", \"#9ecae1\", \"#85bcdb\", \"#6baed6\", \"#57a0ce\",\n                    \"#4292c6\", \"#3082be\", \"#2171b5\", \"#1361a9\", \"#08519c\",\n                    \"#0b4083\",\"#08306b\"]\n        fips = df_sample['FIPS']\n        values = df_sample['Unemployment Rate (%)']\n        fig = ff.create_choropleth(\n            fips=fips, values=values, scope=['usa'],\n            binning_endpoints=binning_endpoints, colorscale=colorscale,\n            show_hover=True, centroid_marker={'opacity': 0},\n            asp=2.9, title='USA by Unemployment %',\n            legend_title='Unemployment %'\n        )\n        fig.show()\n    \"\"\"\n    if not _plotly_geo:\n        raise ValueError('\\nThe create_choropleth figure factory requires the plotly-geo package.\\nInstall using pip with:\\n\\n$ pip install plotly-geo\\n\\nOr, install using conda with\\n\\n$ conda install -c plotly plotly-geo\\n')\n    if not gp or not shapefile or (not shapely):\n        raise ImportError('geopandas, pyshp and shapely must be installed for this figure factory.\\n\\nRun the following commands to install the correct versions of the following modules:\\n\\n```\\n$ pip install geopandas==0.3.0\\n$ pip install pyshp==1.2.10\\n$ pip install shapely==1.6.3\\n```\\nIf you are using Windows, follow this post to properly install geopandas and dependencies:http://geoffboeing.com/2014/09/using-geopandas-windows/\\n\\nIf you are using Anaconda, do not use PIP to install the packages above. Instead use conda to install them:\\n\\n```\\n$ conda install plotly\\n$ conda install geopandas\\n```')\n    (df, df_state) = _create_us_counties_df(st_to_state_name_dict, state_to_st_dict)\n    fips_polygon_map = dict(zip(df['FIPS'].tolist(), df['geometry'].tolist()))\n    if not state_outline:\n        state_outline = {'color': 'rgb(240, 240, 240)', 'width': 1}\n    if not county_outline:\n        county_outline = {'color': 'rgb(0, 0, 0)', 'width': 0}\n    if not centroid_marker:\n        centroid_marker = {'size': 3, 'color': 'white', 'opacity': 1}\n    if 'opacity' not in centroid_marker:\n        centroid_marker.update({'opacity': 1})\n    if len(fips) != len(values):\n        raise PlotlyError('fips and values must be the same length')\n    if isinstance(fips, pd.core.series.Series):\n        fips = fips.tolist()\n    if isinstance(values, pd.core.series.Series):\n        values = values.tolist()\n    fips = map(lambda x: int(x), fips)\n    if binning_endpoints:\n        intervals = utils.endpts_to_intervals(binning_endpoints)\n        LEVELS = _intervals_as_labels(intervals, round_legend_values, exponent_format)\n    elif not order:\n        LEVELS = sorted(list(set(values)))\n    else:\n        same_sets = sorted(list(set(values))) == set(order)\n        no_duplicates = not any((order.count(x) > 1 for x in order))\n        if same_sets and no_duplicates:\n            LEVELS = order\n        else:\n            raise PlotlyError('if you are using a custom order of unique values from your color column, you must: have all the unique values in your order and have no duplicate items')\n    if not colorscale:\n        colorscale = []\n        viridis_colors = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES['Viridis'])\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.hex_to_rgb)\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.label_rgb)\n        viri_len = len(viridis_colors) + 1\n        viri_intervals = utils.endpts_to_intervals(list(np.linspace(0, 1, viri_len)))[1:-1]\n        for L in np.linspace(0, 1, len(LEVELS)):\n            for (idx, inter) in enumerate(viri_intervals):\n                if L == 0:\n                    break\n                elif inter[0] < L <= inter[1]:\n                    break\n            intermed = (L - viri_intervals[idx][0]) / (viri_intervals[idx][1] - viri_intervals[idx][0])\n            float_color = clrs.find_intermediate_color(viridis_colors[idx], viridis_colors[idx], intermed, colortype='rgb')\n            float_color = clrs.unlabel_rgb(float_color)\n            float_color = clrs.unconvert_from_RGB_255(float_color)\n            int_rgb = clrs.convert_to_RGB_255(float_color)\n            int_rgb = clrs.label_rgb(int_rgb)\n            colorscale.append(int_rgb)\n    if len(colorscale) < len(LEVELS):\n        raise PlotlyError(\"You have {} LEVELS. Your number of colors in 'colorscale' must be at least the number of LEVELS: {}. If you are using 'binning_endpoints' then 'colorscale' must have at least len(binning_endpoints) + 2 colors\".format(len(LEVELS), min(LEVELS, LEVELS[:20])))\n    color_lookup = dict(zip(LEVELS, colorscale))\n    x_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    y_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    if isinstance(scope, str):\n        raise PlotlyError(\"'scope' must be a list/tuple/sequence\")\n    scope_names = []\n    extra_states = ['Alaska', 'Commonwealth of the Northern Mariana Islands', 'Puerto Rico', 'Guam', 'United States Virgin Islands', 'American Samoa']\n    for state in scope:\n        if state.lower() == 'usa':\n            scope_names = df['STATE_NAME'].unique()\n            scope_names = list(scope_names)\n            for ex_st in extra_states:\n                try:\n                    scope_names.remove(ex_st)\n                except ValueError:\n                    pass\n        else:\n            if state in st_to_state_name_dict.keys():\n                state = st_to_state_name_dict[state]\n            scope_names.append(state)\n    df_state = df_state[df_state['STATE_NAME'].isin(scope_names)]\n    plot_data = []\n    x_centroids = []\n    y_centroids = []\n    centroid_text = []\n    fips_not_in_shapefile = []\n    if not binning_endpoints:\n        for (index, f) in enumerate(fips):\n            level = values[index]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    else:\n        for (index, f) in enumerate(fips):\n            for (j, inter) in enumerate(intervals):\n                if inter[0] < values[index] <= inter[1]:\n                    break\n            level = LEVELS[j]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    if len(fips_not_in_shapefile) > 0:\n        msg = 'Unrecognized FIPS Values\\n\\nWhoops! It looks like you are trying to pass at least one FIPS value that is not in our shapefile of FIPS and data for the counties. Your choropleth will still show up but these counties cannot be shown.\\nUnrecognized FIPS are: {}'.format(fips_not_in_shapefile)\n        warnings.warn(msg)\n    x_states = []\n    y_states = []\n    for (index, row) in df_state.iterrows():\n        if df_state['geometry'][index].type == 'Polygon':\n            x = row.geometry.simplify(simplify_state).exterior.xy[0].tolist()\n            y = row.geometry.simplify(simplify_state).exterior.xy[1].tolist()\n            x_states = x_states + x\n            y_states = y_states + y\n        elif df_state['geometry'][index].type == 'MultiPolygon':\n            x = [poly.simplify(simplify_state).exterior.xy[0].tolist() for poly in df_state['geometry'][index]]\n            y = [poly.simplify(simplify_state).exterior.xy[1].tolist() for poly in df_state['geometry'][index]]\n            for segment in range(len(x)):\n                x_states = x_states + x[segment]\n                y_states = y_states + y[segment]\n                x_states.append(np.nan)\n                y_states.append(np.nan)\n        x_states.append(np.nan)\n        y_states.append(np.nan)\n    for lev in LEVELS:\n        county_data = dict(type='scatter', mode='lines', x=x_traces[lev], y=y_traces[lev], line=county_outline, fill='toself', fillcolor=color_lookup[lev], name=lev, hoverinfo='none')\n        plot_data.append(county_data)\n    if show_hover:\n        hover_points = dict(type='scatter', showlegend=False, legendgroup='centroids', x=x_centroids, y=y_centroids, text=centroid_text, name='US Counties', mode='markers', marker={'color': 'white', 'opacity': 0}, hoverinfo='text')\n        centroids_on_select = dict(selected=dict(marker=centroid_marker), unselected=dict(marker=dict(opacity=0)))\n        hover_points.update(centroids_on_select)\n        plot_data.append(hover_points)\n    if show_state_data:\n        state_data = dict(type='scatter', legendgroup='States', line=state_outline, x=x_states, y=y_states, hoverinfo='text', showlegend=False, mode='lines')\n        plot_data.append(state_data)\n    DEFAULT_LAYOUT = dict(hovermode='closest', xaxis=dict(autorange=False, range=USA_XRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), yaxis=dict(autorange=False, range=USA_YRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), margin=dict(t=40, b=20, r=20, l=20), width=900, height=450, dragmode='select', legend=dict(traceorder='reversed', xanchor='right', yanchor='top', x=1, y=1), annotations=[])\n    fig = dict(data=plot_data, layout=DEFAULT_LAYOUT)\n    fig['layout'].update(layout_options)\n    fig['layout']['annotations'].append(dict(x=1, y=1.05, xref='paper', yref='paper', xanchor='right', showarrow=False, text='<b>' + legend_title + '</b>'))\n    if len(scope) == 1 and scope[0].lower() == 'usa':\n        xaxis_range_low = -125.0\n        xaxis_range_high = -55.0\n        yaxis_range_low = 25.0\n        yaxis_range_high = 49.0\n    else:\n        xaxis_range_low = float('inf')\n        xaxis_range_high = float('-inf')\n        yaxis_range_low = float('inf')\n        yaxis_range_high = float('-inf')\n        for trace in fig['data']:\n            if all((isinstance(n, Number) for n in trace['x'])):\n                calc_x_min = min(trace['x'] or [float('inf')])\n                calc_x_max = max(trace['x'] or [float('-inf')])\n                if calc_x_min < xaxis_range_low:\n                    xaxis_range_low = calc_x_min\n                if calc_x_max > xaxis_range_high:\n                    xaxis_range_high = calc_x_max\n            if all((isinstance(n, Number) for n in trace['y'])):\n                calc_y_min = min(trace['y'] or [float('inf')])\n                calc_y_max = max(trace['y'] or [float('-inf')])\n                if calc_y_min < yaxis_range_low:\n                    yaxis_range_low = calc_y_min\n                if calc_y_max > yaxis_range_high:\n                    yaxis_range_high = calc_y_max\n    fig['layout']['xaxis']['range'] = [xaxis_range_low, xaxis_range_high]\n    fig['layout']['yaxis']['range'] = [yaxis_range_low, yaxis_range_high]\n    if asp is None:\n        usa_x_range = USA_XRANGE[1] - USA_XRANGE[0]\n        usa_y_range = USA_YRANGE[1] - USA_YRANGE[0]\n        asp = usa_x_range / usa_y_range\n    width = float(fig['layout']['xaxis']['range'][1] - fig['layout']['xaxis']['range'][0])\n    height = float(fig['layout']['yaxis']['range'][1] - fig['layout']['yaxis']['range'][0])\n    center = (sum(fig['layout']['xaxis']['range']) / 2.0, sum(fig['layout']['yaxis']['range']) / 2.0)\n    if height / width > 1 / asp:\n        new_width = asp * height\n        fig['layout']['xaxis']['range'][0] = center[0] - new_width * 0.5\n        fig['layout']['xaxis']['range'][1] = center[0] + new_width * 0.5\n    else:\n        new_height = 1 / asp * width\n        fig['layout']['yaxis']['range'][0] = center[1] - new_height * 0.5\n        fig['layout']['yaxis']['range'][1] = center[1] + new_height * 0.5\n    return go.Figure(fig)",
        "mutated": [
            "def create_choropleth(fips, values, scope=['usa'], binning_endpoints=None, colorscale=None, order=None, simplify_county=0.02, simplify_state=0.02, asp=None, show_hover=True, show_state_data=True, state_outline=None, county_outline=None, centroid_marker=None, round_legend_values=False, exponent_format=False, legend_title='', **layout_options):\n    if False:\n        i = 10\n    '\\n    **deprecated**, use instead\\n    :func:`plotly.express.choropleth` with custom GeoJSON.\\n\\n    This function also requires `shapely`, `geopandas` and `plotly-geo` to be installed.\\n\\n    Returns figure for county choropleth. Uses data from package_data.\\n\\n    :param (list) fips: list of FIPS values which correspond to the con\\n        catination of state and county ids. An example is \\'01001\\'.\\n    :param (list) values: list of numbers/strings which correspond to the\\n        fips list. These are the values that will determine how the counties\\n        are colored.\\n    :param (list) scope: list of states and/or states abbreviations. Fits\\n        all states in the camera tightly. Selecting [\\'usa\\'] is the equivalent\\n        of appending all 50 states into your scope list. Selecting only \\'usa\\'\\n        does not include \\'Alaska\\', \\'Puerto Rico\\', \\'American Samoa\\',\\n        \\'Commonwealth of the Northern Mariana Islands\\', \\'Guam\\',\\n        \\'United States Virgin Islands\\'. These must be added manually to the\\n        list.\\n        Default = [\\'usa\\']\\n    :param (list) binning_endpoints: ascending numbers which implicitly define\\n        real number intervals which are used as bins. The colorscale used must\\n        have the same number of colors as the number of bins and this will\\n        result in a categorical colormap.\\n    :param (list) colorscale: a list of colors with length equal to the\\n        number of categories of colors. The length must match either all\\n        unique numbers in the \\'values\\' list or if endpoints is being used, the\\n        number of categories created by the endpoints.\\n\\n        For example, if binning_endpoints = [4, 6, 8], then there are 4 bins:\\n        [-inf, 4), [4, 6), [6, 8), [8, inf)\\n    :param (list) order: a list of the unique categories (numbers/bins) in any\\n        desired order. This is helpful if you want to order string values to\\n        a chosen colorscale.\\n    :param (float) simplify_county: determines the simplification factor\\n        for the counties. The larger the number, the fewer vertices and edges\\n        each polygon has. See\\n        http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) simplify_state: simplifies the state outline polygon.\\n        See http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) asp: the width-to-height aspect ratio for the camera.\\n        Default = 2.5\\n    :param (bool) show_hover: show county hover and centroid info\\n    :param (bool) show_state_data: reveals state boundary lines\\n    :param (dict) state_outline: dict of attributes of the state outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) county_outline: dict of attributes of the county outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) centroid_marker: dict of attributes of the centroid marker.\\n        The centroid markers are invisible by default and appear visible on\\n        selection. See https://plot.ly/python/reference/#scatter-marker for\\n        all valid params\\n    :param (bool) round_legend_values: automatically round the numbers that\\n        appear in the legend to the nearest integer.\\n        Default = False\\n    :param (bool) exponent_format: if set to True, puts numbers in the K, M,\\n        B number format. For example 4000.0 becomes 4.0K\\n        Default = False\\n    :param (str) legend_title: title that appears above the legend\\n    :param **layout_options: a **kwargs argument for all layout parameters\\n\\n\\n    Example 1: Florida::\\n\\n        import plotly.plotly as py\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'Florida\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        binning_endpoints = list(np.mgrid[min(values):max(values):4j])\\n        colorscale = [\"#030512\",\"#1d1d3b\",\"#323268\",\"#3d4b94\",\"#3e6ab0\",\\n                    \"#4989bc\",\"#60a7c7\",\"#85c5d3\",\"#b7e0e4\",\"#eafcfd\"]\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'Florida\\'], show_state_data=True,\\n            colorscale=colorscale, binning_endpoints=binning_endpoints,\\n            round_legend_values=True, plot_bgcolor=\\'rgb(229,229,229)\\',\\n            paper_bgcolor=\\'rgb(229,229,229)\\', legend_title=\\'Florida Population\\',\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            exponent_format=True,\\n        )\\n\\n    Example 2: New England::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        NE_states = [\\'Connecticut\\', \\'Maine\\', \\'Massachusetts\\',\\n                    \\'New Hampshire\\', \\'Rhode Island\\']\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'].isin(NE_states)]\\n        colorscale = [\\'rgb(68.0, 1.0, 84.0)\\',\\n        \\'rgb(66.0, 64.0, 134.0)\\',\\n        \\'rgb(38.0, 130.0, 142.0)\\',\\n        \\'rgb(63.0, 188.0, 115.0)\\',\\n        \\'rgb(216.0, 226.0, 25.0)\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=NE_states, show_state_data=True\\n        )\\n        fig.show()\\n\\n    Example 3: California and Surrounding States::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'California\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        colorscale = [\\n            \\'rgb(193, 193, 193)\\',\\n            \\'rgb(239,239,239)\\',\\n            \\'rgb(195, 196, 222)\\',\\n            \\'rgb(144,148,194)\\',\\n            \\'rgb(101,104,168)\\',\\n            \\'rgb(65, 53, 132)\\'\\n        ]\\n\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, colorscale=colorscale,\\n            scope=[\\'CA\\', \\'AZ\\', \\'Nevada\\', \\'Oregon\\', \\' Idaho\\'],\\n            binning_endpoints=[14348, 63983, 134827, 426762, 2081313],\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            legend_title=\\'California Counties\\',\\n            title=\\'California and Nearby States\\'\\n        )\\n        fig.show()\\n\\n    Example 4: USA::\\n\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/laucnty16.csv\\'\\n        )\\n        df_sample[\\'State FIPS Code\\'] = df_sample[\\'State FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(2)\\n        )\\n        df_sample[\\'County FIPS Code\\'] = df_sample[\\'County FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(3)\\n        )\\n        df_sample[\\'FIPS\\'] = (\\n            df_sample[\\'State FIPS Code\\'] + df_sample[\\'County FIPS Code\\']\\n        )\\n\\n        binning_endpoints = list(np.linspace(1, 12, len(colorscale) - 1))\\n        colorscale = [\"#f7fbff\", \"#ebf3fb\", \"#deebf7\", \"#d2e3f3\", \"#c6dbef\",\\n                    \"#b3d2e9\", \"#9ecae1\", \"#85bcdb\", \"#6baed6\", \"#57a0ce\",\\n                    \"#4292c6\", \"#3082be\", \"#2171b5\", \"#1361a9\", \"#08519c\",\\n                    \"#0b4083\",\"#08306b\"]\\n        fips = df_sample[\\'FIPS\\']\\n        values = df_sample[\\'Unemployment Rate (%)\\']\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'usa\\'],\\n            binning_endpoints=binning_endpoints, colorscale=colorscale,\\n            show_hover=True, centroid_marker={\\'opacity\\': 0},\\n            asp=2.9, title=\\'USA by Unemployment %\\',\\n            legend_title=\\'Unemployment %\\'\\n        )\\n        fig.show()\\n    '\n    if not _plotly_geo:\n        raise ValueError('\\nThe create_choropleth figure factory requires the plotly-geo package.\\nInstall using pip with:\\n\\n$ pip install plotly-geo\\n\\nOr, install using conda with\\n\\n$ conda install -c plotly plotly-geo\\n')\n    if not gp or not shapefile or (not shapely):\n        raise ImportError('geopandas, pyshp and shapely must be installed for this figure factory.\\n\\nRun the following commands to install the correct versions of the following modules:\\n\\n```\\n$ pip install geopandas==0.3.0\\n$ pip install pyshp==1.2.10\\n$ pip install shapely==1.6.3\\n```\\nIf you are using Windows, follow this post to properly install geopandas and dependencies:http://geoffboeing.com/2014/09/using-geopandas-windows/\\n\\nIf you are using Anaconda, do not use PIP to install the packages above. Instead use conda to install them:\\n\\n```\\n$ conda install plotly\\n$ conda install geopandas\\n```')\n    (df, df_state) = _create_us_counties_df(st_to_state_name_dict, state_to_st_dict)\n    fips_polygon_map = dict(zip(df['FIPS'].tolist(), df['geometry'].tolist()))\n    if not state_outline:\n        state_outline = {'color': 'rgb(240, 240, 240)', 'width': 1}\n    if not county_outline:\n        county_outline = {'color': 'rgb(0, 0, 0)', 'width': 0}\n    if not centroid_marker:\n        centroid_marker = {'size': 3, 'color': 'white', 'opacity': 1}\n    if 'opacity' not in centroid_marker:\n        centroid_marker.update({'opacity': 1})\n    if len(fips) != len(values):\n        raise PlotlyError('fips and values must be the same length')\n    if isinstance(fips, pd.core.series.Series):\n        fips = fips.tolist()\n    if isinstance(values, pd.core.series.Series):\n        values = values.tolist()\n    fips = map(lambda x: int(x), fips)\n    if binning_endpoints:\n        intervals = utils.endpts_to_intervals(binning_endpoints)\n        LEVELS = _intervals_as_labels(intervals, round_legend_values, exponent_format)\n    elif not order:\n        LEVELS = sorted(list(set(values)))\n    else:\n        same_sets = sorted(list(set(values))) == set(order)\n        no_duplicates = not any((order.count(x) > 1 for x in order))\n        if same_sets and no_duplicates:\n            LEVELS = order\n        else:\n            raise PlotlyError('if you are using a custom order of unique values from your color column, you must: have all the unique values in your order and have no duplicate items')\n    if not colorscale:\n        colorscale = []\n        viridis_colors = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES['Viridis'])\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.hex_to_rgb)\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.label_rgb)\n        viri_len = len(viridis_colors) + 1\n        viri_intervals = utils.endpts_to_intervals(list(np.linspace(0, 1, viri_len)))[1:-1]\n        for L in np.linspace(0, 1, len(LEVELS)):\n            for (idx, inter) in enumerate(viri_intervals):\n                if L == 0:\n                    break\n                elif inter[0] < L <= inter[1]:\n                    break\n            intermed = (L - viri_intervals[idx][0]) / (viri_intervals[idx][1] - viri_intervals[idx][0])\n            float_color = clrs.find_intermediate_color(viridis_colors[idx], viridis_colors[idx], intermed, colortype='rgb')\n            float_color = clrs.unlabel_rgb(float_color)\n            float_color = clrs.unconvert_from_RGB_255(float_color)\n            int_rgb = clrs.convert_to_RGB_255(float_color)\n            int_rgb = clrs.label_rgb(int_rgb)\n            colorscale.append(int_rgb)\n    if len(colorscale) < len(LEVELS):\n        raise PlotlyError(\"You have {} LEVELS. Your number of colors in 'colorscale' must be at least the number of LEVELS: {}. If you are using 'binning_endpoints' then 'colorscale' must have at least len(binning_endpoints) + 2 colors\".format(len(LEVELS), min(LEVELS, LEVELS[:20])))\n    color_lookup = dict(zip(LEVELS, colorscale))\n    x_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    y_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    if isinstance(scope, str):\n        raise PlotlyError(\"'scope' must be a list/tuple/sequence\")\n    scope_names = []\n    extra_states = ['Alaska', 'Commonwealth of the Northern Mariana Islands', 'Puerto Rico', 'Guam', 'United States Virgin Islands', 'American Samoa']\n    for state in scope:\n        if state.lower() == 'usa':\n            scope_names = df['STATE_NAME'].unique()\n            scope_names = list(scope_names)\n            for ex_st in extra_states:\n                try:\n                    scope_names.remove(ex_st)\n                except ValueError:\n                    pass\n        else:\n            if state in st_to_state_name_dict.keys():\n                state = st_to_state_name_dict[state]\n            scope_names.append(state)\n    df_state = df_state[df_state['STATE_NAME'].isin(scope_names)]\n    plot_data = []\n    x_centroids = []\n    y_centroids = []\n    centroid_text = []\n    fips_not_in_shapefile = []\n    if not binning_endpoints:\n        for (index, f) in enumerate(fips):\n            level = values[index]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    else:\n        for (index, f) in enumerate(fips):\n            for (j, inter) in enumerate(intervals):\n                if inter[0] < values[index] <= inter[1]:\n                    break\n            level = LEVELS[j]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    if len(fips_not_in_shapefile) > 0:\n        msg = 'Unrecognized FIPS Values\\n\\nWhoops! It looks like you are trying to pass at least one FIPS value that is not in our shapefile of FIPS and data for the counties. Your choropleth will still show up but these counties cannot be shown.\\nUnrecognized FIPS are: {}'.format(fips_not_in_shapefile)\n        warnings.warn(msg)\n    x_states = []\n    y_states = []\n    for (index, row) in df_state.iterrows():\n        if df_state['geometry'][index].type == 'Polygon':\n            x = row.geometry.simplify(simplify_state).exterior.xy[0].tolist()\n            y = row.geometry.simplify(simplify_state).exterior.xy[1].tolist()\n            x_states = x_states + x\n            y_states = y_states + y\n        elif df_state['geometry'][index].type == 'MultiPolygon':\n            x = [poly.simplify(simplify_state).exterior.xy[0].tolist() for poly in df_state['geometry'][index]]\n            y = [poly.simplify(simplify_state).exterior.xy[1].tolist() for poly in df_state['geometry'][index]]\n            for segment in range(len(x)):\n                x_states = x_states + x[segment]\n                y_states = y_states + y[segment]\n                x_states.append(np.nan)\n                y_states.append(np.nan)\n        x_states.append(np.nan)\n        y_states.append(np.nan)\n    for lev in LEVELS:\n        county_data = dict(type='scatter', mode='lines', x=x_traces[lev], y=y_traces[lev], line=county_outline, fill='toself', fillcolor=color_lookup[lev], name=lev, hoverinfo='none')\n        plot_data.append(county_data)\n    if show_hover:\n        hover_points = dict(type='scatter', showlegend=False, legendgroup='centroids', x=x_centroids, y=y_centroids, text=centroid_text, name='US Counties', mode='markers', marker={'color': 'white', 'opacity': 0}, hoverinfo='text')\n        centroids_on_select = dict(selected=dict(marker=centroid_marker), unselected=dict(marker=dict(opacity=0)))\n        hover_points.update(centroids_on_select)\n        plot_data.append(hover_points)\n    if show_state_data:\n        state_data = dict(type='scatter', legendgroup='States', line=state_outline, x=x_states, y=y_states, hoverinfo='text', showlegend=False, mode='lines')\n        plot_data.append(state_data)\n    DEFAULT_LAYOUT = dict(hovermode='closest', xaxis=dict(autorange=False, range=USA_XRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), yaxis=dict(autorange=False, range=USA_YRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), margin=dict(t=40, b=20, r=20, l=20), width=900, height=450, dragmode='select', legend=dict(traceorder='reversed', xanchor='right', yanchor='top', x=1, y=1), annotations=[])\n    fig = dict(data=plot_data, layout=DEFAULT_LAYOUT)\n    fig['layout'].update(layout_options)\n    fig['layout']['annotations'].append(dict(x=1, y=1.05, xref='paper', yref='paper', xanchor='right', showarrow=False, text='<b>' + legend_title + '</b>'))\n    if len(scope) == 1 and scope[0].lower() == 'usa':\n        xaxis_range_low = -125.0\n        xaxis_range_high = -55.0\n        yaxis_range_low = 25.0\n        yaxis_range_high = 49.0\n    else:\n        xaxis_range_low = float('inf')\n        xaxis_range_high = float('-inf')\n        yaxis_range_low = float('inf')\n        yaxis_range_high = float('-inf')\n        for trace in fig['data']:\n            if all((isinstance(n, Number) for n in trace['x'])):\n                calc_x_min = min(trace['x'] or [float('inf')])\n                calc_x_max = max(trace['x'] or [float('-inf')])\n                if calc_x_min < xaxis_range_low:\n                    xaxis_range_low = calc_x_min\n                if calc_x_max > xaxis_range_high:\n                    xaxis_range_high = calc_x_max\n            if all((isinstance(n, Number) for n in trace['y'])):\n                calc_y_min = min(trace['y'] or [float('inf')])\n                calc_y_max = max(trace['y'] or [float('-inf')])\n                if calc_y_min < yaxis_range_low:\n                    yaxis_range_low = calc_y_min\n                if calc_y_max > yaxis_range_high:\n                    yaxis_range_high = calc_y_max\n    fig['layout']['xaxis']['range'] = [xaxis_range_low, xaxis_range_high]\n    fig['layout']['yaxis']['range'] = [yaxis_range_low, yaxis_range_high]\n    if asp is None:\n        usa_x_range = USA_XRANGE[1] - USA_XRANGE[0]\n        usa_y_range = USA_YRANGE[1] - USA_YRANGE[0]\n        asp = usa_x_range / usa_y_range\n    width = float(fig['layout']['xaxis']['range'][1] - fig['layout']['xaxis']['range'][0])\n    height = float(fig['layout']['yaxis']['range'][1] - fig['layout']['yaxis']['range'][0])\n    center = (sum(fig['layout']['xaxis']['range']) / 2.0, sum(fig['layout']['yaxis']['range']) / 2.0)\n    if height / width > 1 / asp:\n        new_width = asp * height\n        fig['layout']['xaxis']['range'][0] = center[0] - new_width * 0.5\n        fig['layout']['xaxis']['range'][1] = center[0] + new_width * 0.5\n    else:\n        new_height = 1 / asp * width\n        fig['layout']['yaxis']['range'][0] = center[1] - new_height * 0.5\n        fig['layout']['yaxis']['range'][1] = center[1] + new_height * 0.5\n    return go.Figure(fig)",
            "def create_choropleth(fips, values, scope=['usa'], binning_endpoints=None, colorscale=None, order=None, simplify_county=0.02, simplify_state=0.02, asp=None, show_hover=True, show_state_data=True, state_outline=None, county_outline=None, centroid_marker=None, round_legend_values=False, exponent_format=False, legend_title='', **layout_options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    **deprecated**, use instead\\n    :func:`plotly.express.choropleth` with custom GeoJSON.\\n\\n    This function also requires `shapely`, `geopandas` and `plotly-geo` to be installed.\\n\\n    Returns figure for county choropleth. Uses data from package_data.\\n\\n    :param (list) fips: list of FIPS values which correspond to the con\\n        catination of state and county ids. An example is \\'01001\\'.\\n    :param (list) values: list of numbers/strings which correspond to the\\n        fips list. These are the values that will determine how the counties\\n        are colored.\\n    :param (list) scope: list of states and/or states abbreviations. Fits\\n        all states in the camera tightly. Selecting [\\'usa\\'] is the equivalent\\n        of appending all 50 states into your scope list. Selecting only \\'usa\\'\\n        does not include \\'Alaska\\', \\'Puerto Rico\\', \\'American Samoa\\',\\n        \\'Commonwealth of the Northern Mariana Islands\\', \\'Guam\\',\\n        \\'United States Virgin Islands\\'. These must be added manually to the\\n        list.\\n        Default = [\\'usa\\']\\n    :param (list) binning_endpoints: ascending numbers which implicitly define\\n        real number intervals which are used as bins. The colorscale used must\\n        have the same number of colors as the number of bins and this will\\n        result in a categorical colormap.\\n    :param (list) colorscale: a list of colors with length equal to the\\n        number of categories of colors. The length must match either all\\n        unique numbers in the \\'values\\' list or if endpoints is being used, the\\n        number of categories created by the endpoints.\\n\\n        For example, if binning_endpoints = [4, 6, 8], then there are 4 bins:\\n        [-inf, 4), [4, 6), [6, 8), [8, inf)\\n    :param (list) order: a list of the unique categories (numbers/bins) in any\\n        desired order. This is helpful if you want to order string values to\\n        a chosen colorscale.\\n    :param (float) simplify_county: determines the simplification factor\\n        for the counties. The larger the number, the fewer vertices and edges\\n        each polygon has. See\\n        http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) simplify_state: simplifies the state outline polygon.\\n        See http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) asp: the width-to-height aspect ratio for the camera.\\n        Default = 2.5\\n    :param (bool) show_hover: show county hover and centroid info\\n    :param (bool) show_state_data: reveals state boundary lines\\n    :param (dict) state_outline: dict of attributes of the state outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) county_outline: dict of attributes of the county outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) centroid_marker: dict of attributes of the centroid marker.\\n        The centroid markers are invisible by default and appear visible on\\n        selection. See https://plot.ly/python/reference/#scatter-marker for\\n        all valid params\\n    :param (bool) round_legend_values: automatically round the numbers that\\n        appear in the legend to the nearest integer.\\n        Default = False\\n    :param (bool) exponent_format: if set to True, puts numbers in the K, M,\\n        B number format. For example 4000.0 becomes 4.0K\\n        Default = False\\n    :param (str) legend_title: title that appears above the legend\\n    :param **layout_options: a **kwargs argument for all layout parameters\\n\\n\\n    Example 1: Florida::\\n\\n        import plotly.plotly as py\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'Florida\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        binning_endpoints = list(np.mgrid[min(values):max(values):4j])\\n        colorscale = [\"#030512\",\"#1d1d3b\",\"#323268\",\"#3d4b94\",\"#3e6ab0\",\\n                    \"#4989bc\",\"#60a7c7\",\"#85c5d3\",\"#b7e0e4\",\"#eafcfd\"]\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'Florida\\'], show_state_data=True,\\n            colorscale=colorscale, binning_endpoints=binning_endpoints,\\n            round_legend_values=True, plot_bgcolor=\\'rgb(229,229,229)\\',\\n            paper_bgcolor=\\'rgb(229,229,229)\\', legend_title=\\'Florida Population\\',\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            exponent_format=True,\\n        )\\n\\n    Example 2: New England::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        NE_states = [\\'Connecticut\\', \\'Maine\\', \\'Massachusetts\\',\\n                    \\'New Hampshire\\', \\'Rhode Island\\']\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'].isin(NE_states)]\\n        colorscale = [\\'rgb(68.0, 1.0, 84.0)\\',\\n        \\'rgb(66.0, 64.0, 134.0)\\',\\n        \\'rgb(38.0, 130.0, 142.0)\\',\\n        \\'rgb(63.0, 188.0, 115.0)\\',\\n        \\'rgb(216.0, 226.0, 25.0)\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=NE_states, show_state_data=True\\n        )\\n        fig.show()\\n\\n    Example 3: California and Surrounding States::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'California\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        colorscale = [\\n            \\'rgb(193, 193, 193)\\',\\n            \\'rgb(239,239,239)\\',\\n            \\'rgb(195, 196, 222)\\',\\n            \\'rgb(144,148,194)\\',\\n            \\'rgb(101,104,168)\\',\\n            \\'rgb(65, 53, 132)\\'\\n        ]\\n\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, colorscale=colorscale,\\n            scope=[\\'CA\\', \\'AZ\\', \\'Nevada\\', \\'Oregon\\', \\' Idaho\\'],\\n            binning_endpoints=[14348, 63983, 134827, 426762, 2081313],\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            legend_title=\\'California Counties\\',\\n            title=\\'California and Nearby States\\'\\n        )\\n        fig.show()\\n\\n    Example 4: USA::\\n\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/laucnty16.csv\\'\\n        )\\n        df_sample[\\'State FIPS Code\\'] = df_sample[\\'State FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(2)\\n        )\\n        df_sample[\\'County FIPS Code\\'] = df_sample[\\'County FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(3)\\n        )\\n        df_sample[\\'FIPS\\'] = (\\n            df_sample[\\'State FIPS Code\\'] + df_sample[\\'County FIPS Code\\']\\n        )\\n\\n        binning_endpoints = list(np.linspace(1, 12, len(colorscale) - 1))\\n        colorscale = [\"#f7fbff\", \"#ebf3fb\", \"#deebf7\", \"#d2e3f3\", \"#c6dbef\",\\n                    \"#b3d2e9\", \"#9ecae1\", \"#85bcdb\", \"#6baed6\", \"#57a0ce\",\\n                    \"#4292c6\", \"#3082be\", \"#2171b5\", \"#1361a9\", \"#08519c\",\\n                    \"#0b4083\",\"#08306b\"]\\n        fips = df_sample[\\'FIPS\\']\\n        values = df_sample[\\'Unemployment Rate (%)\\']\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'usa\\'],\\n            binning_endpoints=binning_endpoints, colorscale=colorscale,\\n            show_hover=True, centroid_marker={\\'opacity\\': 0},\\n            asp=2.9, title=\\'USA by Unemployment %\\',\\n            legend_title=\\'Unemployment %\\'\\n        )\\n        fig.show()\\n    '\n    if not _plotly_geo:\n        raise ValueError('\\nThe create_choropleth figure factory requires the plotly-geo package.\\nInstall using pip with:\\n\\n$ pip install plotly-geo\\n\\nOr, install using conda with\\n\\n$ conda install -c plotly plotly-geo\\n')\n    if not gp or not shapefile or (not shapely):\n        raise ImportError('geopandas, pyshp and shapely must be installed for this figure factory.\\n\\nRun the following commands to install the correct versions of the following modules:\\n\\n```\\n$ pip install geopandas==0.3.0\\n$ pip install pyshp==1.2.10\\n$ pip install shapely==1.6.3\\n```\\nIf you are using Windows, follow this post to properly install geopandas and dependencies:http://geoffboeing.com/2014/09/using-geopandas-windows/\\n\\nIf you are using Anaconda, do not use PIP to install the packages above. Instead use conda to install them:\\n\\n```\\n$ conda install plotly\\n$ conda install geopandas\\n```')\n    (df, df_state) = _create_us_counties_df(st_to_state_name_dict, state_to_st_dict)\n    fips_polygon_map = dict(zip(df['FIPS'].tolist(), df['geometry'].tolist()))\n    if not state_outline:\n        state_outline = {'color': 'rgb(240, 240, 240)', 'width': 1}\n    if not county_outline:\n        county_outline = {'color': 'rgb(0, 0, 0)', 'width': 0}\n    if not centroid_marker:\n        centroid_marker = {'size': 3, 'color': 'white', 'opacity': 1}\n    if 'opacity' not in centroid_marker:\n        centroid_marker.update({'opacity': 1})\n    if len(fips) != len(values):\n        raise PlotlyError('fips and values must be the same length')\n    if isinstance(fips, pd.core.series.Series):\n        fips = fips.tolist()\n    if isinstance(values, pd.core.series.Series):\n        values = values.tolist()\n    fips = map(lambda x: int(x), fips)\n    if binning_endpoints:\n        intervals = utils.endpts_to_intervals(binning_endpoints)\n        LEVELS = _intervals_as_labels(intervals, round_legend_values, exponent_format)\n    elif not order:\n        LEVELS = sorted(list(set(values)))\n    else:\n        same_sets = sorted(list(set(values))) == set(order)\n        no_duplicates = not any((order.count(x) > 1 for x in order))\n        if same_sets and no_duplicates:\n            LEVELS = order\n        else:\n            raise PlotlyError('if you are using a custom order of unique values from your color column, you must: have all the unique values in your order and have no duplicate items')\n    if not colorscale:\n        colorscale = []\n        viridis_colors = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES['Viridis'])\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.hex_to_rgb)\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.label_rgb)\n        viri_len = len(viridis_colors) + 1\n        viri_intervals = utils.endpts_to_intervals(list(np.linspace(0, 1, viri_len)))[1:-1]\n        for L in np.linspace(0, 1, len(LEVELS)):\n            for (idx, inter) in enumerate(viri_intervals):\n                if L == 0:\n                    break\n                elif inter[0] < L <= inter[1]:\n                    break\n            intermed = (L - viri_intervals[idx][0]) / (viri_intervals[idx][1] - viri_intervals[idx][0])\n            float_color = clrs.find_intermediate_color(viridis_colors[idx], viridis_colors[idx], intermed, colortype='rgb')\n            float_color = clrs.unlabel_rgb(float_color)\n            float_color = clrs.unconvert_from_RGB_255(float_color)\n            int_rgb = clrs.convert_to_RGB_255(float_color)\n            int_rgb = clrs.label_rgb(int_rgb)\n            colorscale.append(int_rgb)\n    if len(colorscale) < len(LEVELS):\n        raise PlotlyError(\"You have {} LEVELS. Your number of colors in 'colorscale' must be at least the number of LEVELS: {}. If you are using 'binning_endpoints' then 'colorscale' must have at least len(binning_endpoints) + 2 colors\".format(len(LEVELS), min(LEVELS, LEVELS[:20])))\n    color_lookup = dict(zip(LEVELS, colorscale))\n    x_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    y_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    if isinstance(scope, str):\n        raise PlotlyError(\"'scope' must be a list/tuple/sequence\")\n    scope_names = []\n    extra_states = ['Alaska', 'Commonwealth of the Northern Mariana Islands', 'Puerto Rico', 'Guam', 'United States Virgin Islands', 'American Samoa']\n    for state in scope:\n        if state.lower() == 'usa':\n            scope_names = df['STATE_NAME'].unique()\n            scope_names = list(scope_names)\n            for ex_st in extra_states:\n                try:\n                    scope_names.remove(ex_st)\n                except ValueError:\n                    pass\n        else:\n            if state in st_to_state_name_dict.keys():\n                state = st_to_state_name_dict[state]\n            scope_names.append(state)\n    df_state = df_state[df_state['STATE_NAME'].isin(scope_names)]\n    plot_data = []\n    x_centroids = []\n    y_centroids = []\n    centroid_text = []\n    fips_not_in_shapefile = []\n    if not binning_endpoints:\n        for (index, f) in enumerate(fips):\n            level = values[index]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    else:\n        for (index, f) in enumerate(fips):\n            for (j, inter) in enumerate(intervals):\n                if inter[0] < values[index] <= inter[1]:\n                    break\n            level = LEVELS[j]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    if len(fips_not_in_shapefile) > 0:\n        msg = 'Unrecognized FIPS Values\\n\\nWhoops! It looks like you are trying to pass at least one FIPS value that is not in our shapefile of FIPS and data for the counties. Your choropleth will still show up but these counties cannot be shown.\\nUnrecognized FIPS are: {}'.format(fips_not_in_shapefile)\n        warnings.warn(msg)\n    x_states = []\n    y_states = []\n    for (index, row) in df_state.iterrows():\n        if df_state['geometry'][index].type == 'Polygon':\n            x = row.geometry.simplify(simplify_state).exterior.xy[0].tolist()\n            y = row.geometry.simplify(simplify_state).exterior.xy[1].tolist()\n            x_states = x_states + x\n            y_states = y_states + y\n        elif df_state['geometry'][index].type == 'MultiPolygon':\n            x = [poly.simplify(simplify_state).exterior.xy[0].tolist() for poly in df_state['geometry'][index]]\n            y = [poly.simplify(simplify_state).exterior.xy[1].tolist() for poly in df_state['geometry'][index]]\n            for segment in range(len(x)):\n                x_states = x_states + x[segment]\n                y_states = y_states + y[segment]\n                x_states.append(np.nan)\n                y_states.append(np.nan)\n        x_states.append(np.nan)\n        y_states.append(np.nan)\n    for lev in LEVELS:\n        county_data = dict(type='scatter', mode='lines', x=x_traces[lev], y=y_traces[lev], line=county_outline, fill='toself', fillcolor=color_lookup[lev], name=lev, hoverinfo='none')\n        plot_data.append(county_data)\n    if show_hover:\n        hover_points = dict(type='scatter', showlegend=False, legendgroup='centroids', x=x_centroids, y=y_centroids, text=centroid_text, name='US Counties', mode='markers', marker={'color': 'white', 'opacity': 0}, hoverinfo='text')\n        centroids_on_select = dict(selected=dict(marker=centroid_marker), unselected=dict(marker=dict(opacity=0)))\n        hover_points.update(centroids_on_select)\n        plot_data.append(hover_points)\n    if show_state_data:\n        state_data = dict(type='scatter', legendgroup='States', line=state_outline, x=x_states, y=y_states, hoverinfo='text', showlegend=False, mode='lines')\n        plot_data.append(state_data)\n    DEFAULT_LAYOUT = dict(hovermode='closest', xaxis=dict(autorange=False, range=USA_XRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), yaxis=dict(autorange=False, range=USA_YRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), margin=dict(t=40, b=20, r=20, l=20), width=900, height=450, dragmode='select', legend=dict(traceorder='reversed', xanchor='right', yanchor='top', x=1, y=1), annotations=[])\n    fig = dict(data=plot_data, layout=DEFAULT_LAYOUT)\n    fig['layout'].update(layout_options)\n    fig['layout']['annotations'].append(dict(x=1, y=1.05, xref='paper', yref='paper', xanchor='right', showarrow=False, text='<b>' + legend_title + '</b>'))\n    if len(scope) == 1 and scope[0].lower() == 'usa':\n        xaxis_range_low = -125.0\n        xaxis_range_high = -55.0\n        yaxis_range_low = 25.0\n        yaxis_range_high = 49.0\n    else:\n        xaxis_range_low = float('inf')\n        xaxis_range_high = float('-inf')\n        yaxis_range_low = float('inf')\n        yaxis_range_high = float('-inf')\n        for trace in fig['data']:\n            if all((isinstance(n, Number) for n in trace['x'])):\n                calc_x_min = min(trace['x'] or [float('inf')])\n                calc_x_max = max(trace['x'] or [float('-inf')])\n                if calc_x_min < xaxis_range_low:\n                    xaxis_range_low = calc_x_min\n                if calc_x_max > xaxis_range_high:\n                    xaxis_range_high = calc_x_max\n            if all((isinstance(n, Number) for n in trace['y'])):\n                calc_y_min = min(trace['y'] or [float('inf')])\n                calc_y_max = max(trace['y'] or [float('-inf')])\n                if calc_y_min < yaxis_range_low:\n                    yaxis_range_low = calc_y_min\n                if calc_y_max > yaxis_range_high:\n                    yaxis_range_high = calc_y_max\n    fig['layout']['xaxis']['range'] = [xaxis_range_low, xaxis_range_high]\n    fig['layout']['yaxis']['range'] = [yaxis_range_low, yaxis_range_high]\n    if asp is None:\n        usa_x_range = USA_XRANGE[1] - USA_XRANGE[0]\n        usa_y_range = USA_YRANGE[1] - USA_YRANGE[0]\n        asp = usa_x_range / usa_y_range\n    width = float(fig['layout']['xaxis']['range'][1] - fig['layout']['xaxis']['range'][0])\n    height = float(fig['layout']['yaxis']['range'][1] - fig['layout']['yaxis']['range'][0])\n    center = (sum(fig['layout']['xaxis']['range']) / 2.0, sum(fig['layout']['yaxis']['range']) / 2.0)\n    if height / width > 1 / asp:\n        new_width = asp * height\n        fig['layout']['xaxis']['range'][0] = center[0] - new_width * 0.5\n        fig['layout']['xaxis']['range'][1] = center[0] + new_width * 0.5\n    else:\n        new_height = 1 / asp * width\n        fig['layout']['yaxis']['range'][0] = center[1] - new_height * 0.5\n        fig['layout']['yaxis']['range'][1] = center[1] + new_height * 0.5\n    return go.Figure(fig)",
            "def create_choropleth(fips, values, scope=['usa'], binning_endpoints=None, colorscale=None, order=None, simplify_county=0.02, simplify_state=0.02, asp=None, show_hover=True, show_state_data=True, state_outline=None, county_outline=None, centroid_marker=None, round_legend_values=False, exponent_format=False, legend_title='', **layout_options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    **deprecated**, use instead\\n    :func:`plotly.express.choropleth` with custom GeoJSON.\\n\\n    This function also requires `shapely`, `geopandas` and `plotly-geo` to be installed.\\n\\n    Returns figure for county choropleth. Uses data from package_data.\\n\\n    :param (list) fips: list of FIPS values which correspond to the con\\n        catination of state and county ids. An example is \\'01001\\'.\\n    :param (list) values: list of numbers/strings which correspond to the\\n        fips list. These are the values that will determine how the counties\\n        are colored.\\n    :param (list) scope: list of states and/or states abbreviations. Fits\\n        all states in the camera tightly. Selecting [\\'usa\\'] is the equivalent\\n        of appending all 50 states into your scope list. Selecting only \\'usa\\'\\n        does not include \\'Alaska\\', \\'Puerto Rico\\', \\'American Samoa\\',\\n        \\'Commonwealth of the Northern Mariana Islands\\', \\'Guam\\',\\n        \\'United States Virgin Islands\\'. These must be added manually to the\\n        list.\\n        Default = [\\'usa\\']\\n    :param (list) binning_endpoints: ascending numbers which implicitly define\\n        real number intervals which are used as bins. The colorscale used must\\n        have the same number of colors as the number of bins and this will\\n        result in a categorical colormap.\\n    :param (list) colorscale: a list of colors with length equal to the\\n        number of categories of colors. The length must match either all\\n        unique numbers in the \\'values\\' list or if endpoints is being used, the\\n        number of categories created by the endpoints.\\n\\n        For example, if binning_endpoints = [4, 6, 8], then there are 4 bins:\\n        [-inf, 4), [4, 6), [6, 8), [8, inf)\\n    :param (list) order: a list of the unique categories (numbers/bins) in any\\n        desired order. This is helpful if you want to order string values to\\n        a chosen colorscale.\\n    :param (float) simplify_county: determines the simplification factor\\n        for the counties. The larger the number, the fewer vertices and edges\\n        each polygon has. See\\n        http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) simplify_state: simplifies the state outline polygon.\\n        See http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) asp: the width-to-height aspect ratio for the camera.\\n        Default = 2.5\\n    :param (bool) show_hover: show county hover and centroid info\\n    :param (bool) show_state_data: reveals state boundary lines\\n    :param (dict) state_outline: dict of attributes of the state outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) county_outline: dict of attributes of the county outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) centroid_marker: dict of attributes of the centroid marker.\\n        The centroid markers are invisible by default and appear visible on\\n        selection. See https://plot.ly/python/reference/#scatter-marker for\\n        all valid params\\n    :param (bool) round_legend_values: automatically round the numbers that\\n        appear in the legend to the nearest integer.\\n        Default = False\\n    :param (bool) exponent_format: if set to True, puts numbers in the K, M,\\n        B number format. For example 4000.0 becomes 4.0K\\n        Default = False\\n    :param (str) legend_title: title that appears above the legend\\n    :param **layout_options: a **kwargs argument for all layout parameters\\n\\n\\n    Example 1: Florida::\\n\\n        import plotly.plotly as py\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'Florida\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        binning_endpoints = list(np.mgrid[min(values):max(values):4j])\\n        colorscale = [\"#030512\",\"#1d1d3b\",\"#323268\",\"#3d4b94\",\"#3e6ab0\",\\n                    \"#4989bc\",\"#60a7c7\",\"#85c5d3\",\"#b7e0e4\",\"#eafcfd\"]\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'Florida\\'], show_state_data=True,\\n            colorscale=colorscale, binning_endpoints=binning_endpoints,\\n            round_legend_values=True, plot_bgcolor=\\'rgb(229,229,229)\\',\\n            paper_bgcolor=\\'rgb(229,229,229)\\', legend_title=\\'Florida Population\\',\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            exponent_format=True,\\n        )\\n\\n    Example 2: New England::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        NE_states = [\\'Connecticut\\', \\'Maine\\', \\'Massachusetts\\',\\n                    \\'New Hampshire\\', \\'Rhode Island\\']\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'].isin(NE_states)]\\n        colorscale = [\\'rgb(68.0, 1.0, 84.0)\\',\\n        \\'rgb(66.0, 64.0, 134.0)\\',\\n        \\'rgb(38.0, 130.0, 142.0)\\',\\n        \\'rgb(63.0, 188.0, 115.0)\\',\\n        \\'rgb(216.0, 226.0, 25.0)\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=NE_states, show_state_data=True\\n        )\\n        fig.show()\\n\\n    Example 3: California and Surrounding States::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'California\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        colorscale = [\\n            \\'rgb(193, 193, 193)\\',\\n            \\'rgb(239,239,239)\\',\\n            \\'rgb(195, 196, 222)\\',\\n            \\'rgb(144,148,194)\\',\\n            \\'rgb(101,104,168)\\',\\n            \\'rgb(65, 53, 132)\\'\\n        ]\\n\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, colorscale=colorscale,\\n            scope=[\\'CA\\', \\'AZ\\', \\'Nevada\\', \\'Oregon\\', \\' Idaho\\'],\\n            binning_endpoints=[14348, 63983, 134827, 426762, 2081313],\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            legend_title=\\'California Counties\\',\\n            title=\\'California and Nearby States\\'\\n        )\\n        fig.show()\\n\\n    Example 4: USA::\\n\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/laucnty16.csv\\'\\n        )\\n        df_sample[\\'State FIPS Code\\'] = df_sample[\\'State FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(2)\\n        )\\n        df_sample[\\'County FIPS Code\\'] = df_sample[\\'County FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(3)\\n        )\\n        df_sample[\\'FIPS\\'] = (\\n            df_sample[\\'State FIPS Code\\'] + df_sample[\\'County FIPS Code\\']\\n        )\\n\\n        binning_endpoints = list(np.linspace(1, 12, len(colorscale) - 1))\\n        colorscale = [\"#f7fbff\", \"#ebf3fb\", \"#deebf7\", \"#d2e3f3\", \"#c6dbef\",\\n                    \"#b3d2e9\", \"#9ecae1\", \"#85bcdb\", \"#6baed6\", \"#57a0ce\",\\n                    \"#4292c6\", \"#3082be\", \"#2171b5\", \"#1361a9\", \"#08519c\",\\n                    \"#0b4083\",\"#08306b\"]\\n        fips = df_sample[\\'FIPS\\']\\n        values = df_sample[\\'Unemployment Rate (%)\\']\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'usa\\'],\\n            binning_endpoints=binning_endpoints, colorscale=colorscale,\\n            show_hover=True, centroid_marker={\\'opacity\\': 0},\\n            asp=2.9, title=\\'USA by Unemployment %\\',\\n            legend_title=\\'Unemployment %\\'\\n        )\\n        fig.show()\\n    '\n    if not _plotly_geo:\n        raise ValueError('\\nThe create_choropleth figure factory requires the plotly-geo package.\\nInstall using pip with:\\n\\n$ pip install plotly-geo\\n\\nOr, install using conda with\\n\\n$ conda install -c plotly plotly-geo\\n')\n    if not gp or not shapefile or (not shapely):\n        raise ImportError('geopandas, pyshp and shapely must be installed for this figure factory.\\n\\nRun the following commands to install the correct versions of the following modules:\\n\\n```\\n$ pip install geopandas==0.3.0\\n$ pip install pyshp==1.2.10\\n$ pip install shapely==1.6.3\\n```\\nIf you are using Windows, follow this post to properly install geopandas and dependencies:http://geoffboeing.com/2014/09/using-geopandas-windows/\\n\\nIf you are using Anaconda, do not use PIP to install the packages above. Instead use conda to install them:\\n\\n```\\n$ conda install plotly\\n$ conda install geopandas\\n```')\n    (df, df_state) = _create_us_counties_df(st_to_state_name_dict, state_to_st_dict)\n    fips_polygon_map = dict(zip(df['FIPS'].tolist(), df['geometry'].tolist()))\n    if not state_outline:\n        state_outline = {'color': 'rgb(240, 240, 240)', 'width': 1}\n    if not county_outline:\n        county_outline = {'color': 'rgb(0, 0, 0)', 'width': 0}\n    if not centroid_marker:\n        centroid_marker = {'size': 3, 'color': 'white', 'opacity': 1}\n    if 'opacity' not in centroid_marker:\n        centroid_marker.update({'opacity': 1})\n    if len(fips) != len(values):\n        raise PlotlyError('fips and values must be the same length')\n    if isinstance(fips, pd.core.series.Series):\n        fips = fips.tolist()\n    if isinstance(values, pd.core.series.Series):\n        values = values.tolist()\n    fips = map(lambda x: int(x), fips)\n    if binning_endpoints:\n        intervals = utils.endpts_to_intervals(binning_endpoints)\n        LEVELS = _intervals_as_labels(intervals, round_legend_values, exponent_format)\n    elif not order:\n        LEVELS = sorted(list(set(values)))\n    else:\n        same_sets = sorted(list(set(values))) == set(order)\n        no_duplicates = not any((order.count(x) > 1 for x in order))\n        if same_sets and no_duplicates:\n            LEVELS = order\n        else:\n            raise PlotlyError('if you are using a custom order of unique values from your color column, you must: have all the unique values in your order and have no duplicate items')\n    if not colorscale:\n        colorscale = []\n        viridis_colors = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES['Viridis'])\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.hex_to_rgb)\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.label_rgb)\n        viri_len = len(viridis_colors) + 1\n        viri_intervals = utils.endpts_to_intervals(list(np.linspace(0, 1, viri_len)))[1:-1]\n        for L in np.linspace(0, 1, len(LEVELS)):\n            for (idx, inter) in enumerate(viri_intervals):\n                if L == 0:\n                    break\n                elif inter[0] < L <= inter[1]:\n                    break\n            intermed = (L - viri_intervals[idx][0]) / (viri_intervals[idx][1] - viri_intervals[idx][0])\n            float_color = clrs.find_intermediate_color(viridis_colors[idx], viridis_colors[idx], intermed, colortype='rgb')\n            float_color = clrs.unlabel_rgb(float_color)\n            float_color = clrs.unconvert_from_RGB_255(float_color)\n            int_rgb = clrs.convert_to_RGB_255(float_color)\n            int_rgb = clrs.label_rgb(int_rgb)\n            colorscale.append(int_rgb)\n    if len(colorscale) < len(LEVELS):\n        raise PlotlyError(\"You have {} LEVELS. Your number of colors in 'colorscale' must be at least the number of LEVELS: {}. If you are using 'binning_endpoints' then 'colorscale' must have at least len(binning_endpoints) + 2 colors\".format(len(LEVELS), min(LEVELS, LEVELS[:20])))\n    color_lookup = dict(zip(LEVELS, colorscale))\n    x_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    y_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    if isinstance(scope, str):\n        raise PlotlyError(\"'scope' must be a list/tuple/sequence\")\n    scope_names = []\n    extra_states = ['Alaska', 'Commonwealth of the Northern Mariana Islands', 'Puerto Rico', 'Guam', 'United States Virgin Islands', 'American Samoa']\n    for state in scope:\n        if state.lower() == 'usa':\n            scope_names = df['STATE_NAME'].unique()\n            scope_names = list(scope_names)\n            for ex_st in extra_states:\n                try:\n                    scope_names.remove(ex_st)\n                except ValueError:\n                    pass\n        else:\n            if state in st_to_state_name_dict.keys():\n                state = st_to_state_name_dict[state]\n            scope_names.append(state)\n    df_state = df_state[df_state['STATE_NAME'].isin(scope_names)]\n    plot_data = []\n    x_centroids = []\n    y_centroids = []\n    centroid_text = []\n    fips_not_in_shapefile = []\n    if not binning_endpoints:\n        for (index, f) in enumerate(fips):\n            level = values[index]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    else:\n        for (index, f) in enumerate(fips):\n            for (j, inter) in enumerate(intervals):\n                if inter[0] < values[index] <= inter[1]:\n                    break\n            level = LEVELS[j]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    if len(fips_not_in_shapefile) > 0:\n        msg = 'Unrecognized FIPS Values\\n\\nWhoops! It looks like you are trying to pass at least one FIPS value that is not in our shapefile of FIPS and data for the counties. Your choropleth will still show up but these counties cannot be shown.\\nUnrecognized FIPS are: {}'.format(fips_not_in_shapefile)\n        warnings.warn(msg)\n    x_states = []\n    y_states = []\n    for (index, row) in df_state.iterrows():\n        if df_state['geometry'][index].type == 'Polygon':\n            x = row.geometry.simplify(simplify_state).exterior.xy[0].tolist()\n            y = row.geometry.simplify(simplify_state).exterior.xy[1].tolist()\n            x_states = x_states + x\n            y_states = y_states + y\n        elif df_state['geometry'][index].type == 'MultiPolygon':\n            x = [poly.simplify(simplify_state).exterior.xy[0].tolist() for poly in df_state['geometry'][index]]\n            y = [poly.simplify(simplify_state).exterior.xy[1].tolist() for poly in df_state['geometry'][index]]\n            for segment in range(len(x)):\n                x_states = x_states + x[segment]\n                y_states = y_states + y[segment]\n                x_states.append(np.nan)\n                y_states.append(np.nan)\n        x_states.append(np.nan)\n        y_states.append(np.nan)\n    for lev in LEVELS:\n        county_data = dict(type='scatter', mode='lines', x=x_traces[lev], y=y_traces[lev], line=county_outline, fill='toself', fillcolor=color_lookup[lev], name=lev, hoverinfo='none')\n        plot_data.append(county_data)\n    if show_hover:\n        hover_points = dict(type='scatter', showlegend=False, legendgroup='centroids', x=x_centroids, y=y_centroids, text=centroid_text, name='US Counties', mode='markers', marker={'color': 'white', 'opacity': 0}, hoverinfo='text')\n        centroids_on_select = dict(selected=dict(marker=centroid_marker), unselected=dict(marker=dict(opacity=0)))\n        hover_points.update(centroids_on_select)\n        plot_data.append(hover_points)\n    if show_state_data:\n        state_data = dict(type='scatter', legendgroup='States', line=state_outline, x=x_states, y=y_states, hoverinfo='text', showlegend=False, mode='lines')\n        plot_data.append(state_data)\n    DEFAULT_LAYOUT = dict(hovermode='closest', xaxis=dict(autorange=False, range=USA_XRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), yaxis=dict(autorange=False, range=USA_YRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), margin=dict(t=40, b=20, r=20, l=20), width=900, height=450, dragmode='select', legend=dict(traceorder='reversed', xanchor='right', yanchor='top', x=1, y=1), annotations=[])\n    fig = dict(data=plot_data, layout=DEFAULT_LAYOUT)\n    fig['layout'].update(layout_options)\n    fig['layout']['annotations'].append(dict(x=1, y=1.05, xref='paper', yref='paper', xanchor='right', showarrow=False, text='<b>' + legend_title + '</b>'))\n    if len(scope) == 1 and scope[0].lower() == 'usa':\n        xaxis_range_low = -125.0\n        xaxis_range_high = -55.0\n        yaxis_range_low = 25.0\n        yaxis_range_high = 49.0\n    else:\n        xaxis_range_low = float('inf')\n        xaxis_range_high = float('-inf')\n        yaxis_range_low = float('inf')\n        yaxis_range_high = float('-inf')\n        for trace in fig['data']:\n            if all((isinstance(n, Number) for n in trace['x'])):\n                calc_x_min = min(trace['x'] or [float('inf')])\n                calc_x_max = max(trace['x'] or [float('-inf')])\n                if calc_x_min < xaxis_range_low:\n                    xaxis_range_low = calc_x_min\n                if calc_x_max > xaxis_range_high:\n                    xaxis_range_high = calc_x_max\n            if all((isinstance(n, Number) for n in trace['y'])):\n                calc_y_min = min(trace['y'] or [float('inf')])\n                calc_y_max = max(trace['y'] or [float('-inf')])\n                if calc_y_min < yaxis_range_low:\n                    yaxis_range_low = calc_y_min\n                if calc_y_max > yaxis_range_high:\n                    yaxis_range_high = calc_y_max\n    fig['layout']['xaxis']['range'] = [xaxis_range_low, xaxis_range_high]\n    fig['layout']['yaxis']['range'] = [yaxis_range_low, yaxis_range_high]\n    if asp is None:\n        usa_x_range = USA_XRANGE[1] - USA_XRANGE[0]\n        usa_y_range = USA_YRANGE[1] - USA_YRANGE[0]\n        asp = usa_x_range / usa_y_range\n    width = float(fig['layout']['xaxis']['range'][1] - fig['layout']['xaxis']['range'][0])\n    height = float(fig['layout']['yaxis']['range'][1] - fig['layout']['yaxis']['range'][0])\n    center = (sum(fig['layout']['xaxis']['range']) / 2.0, sum(fig['layout']['yaxis']['range']) / 2.0)\n    if height / width > 1 / asp:\n        new_width = asp * height\n        fig['layout']['xaxis']['range'][0] = center[0] - new_width * 0.5\n        fig['layout']['xaxis']['range'][1] = center[0] + new_width * 0.5\n    else:\n        new_height = 1 / asp * width\n        fig['layout']['yaxis']['range'][0] = center[1] - new_height * 0.5\n        fig['layout']['yaxis']['range'][1] = center[1] + new_height * 0.5\n    return go.Figure(fig)",
            "def create_choropleth(fips, values, scope=['usa'], binning_endpoints=None, colorscale=None, order=None, simplify_county=0.02, simplify_state=0.02, asp=None, show_hover=True, show_state_data=True, state_outline=None, county_outline=None, centroid_marker=None, round_legend_values=False, exponent_format=False, legend_title='', **layout_options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    **deprecated**, use instead\\n    :func:`plotly.express.choropleth` with custom GeoJSON.\\n\\n    This function also requires `shapely`, `geopandas` and `plotly-geo` to be installed.\\n\\n    Returns figure for county choropleth. Uses data from package_data.\\n\\n    :param (list) fips: list of FIPS values which correspond to the con\\n        catination of state and county ids. An example is \\'01001\\'.\\n    :param (list) values: list of numbers/strings which correspond to the\\n        fips list. These are the values that will determine how the counties\\n        are colored.\\n    :param (list) scope: list of states and/or states abbreviations. Fits\\n        all states in the camera tightly. Selecting [\\'usa\\'] is the equivalent\\n        of appending all 50 states into your scope list. Selecting only \\'usa\\'\\n        does not include \\'Alaska\\', \\'Puerto Rico\\', \\'American Samoa\\',\\n        \\'Commonwealth of the Northern Mariana Islands\\', \\'Guam\\',\\n        \\'United States Virgin Islands\\'. These must be added manually to the\\n        list.\\n        Default = [\\'usa\\']\\n    :param (list) binning_endpoints: ascending numbers which implicitly define\\n        real number intervals which are used as bins. The colorscale used must\\n        have the same number of colors as the number of bins and this will\\n        result in a categorical colormap.\\n    :param (list) colorscale: a list of colors with length equal to the\\n        number of categories of colors. The length must match either all\\n        unique numbers in the \\'values\\' list or if endpoints is being used, the\\n        number of categories created by the endpoints.\\n\\n        For example, if binning_endpoints = [4, 6, 8], then there are 4 bins:\\n        [-inf, 4), [4, 6), [6, 8), [8, inf)\\n    :param (list) order: a list of the unique categories (numbers/bins) in any\\n        desired order. This is helpful if you want to order string values to\\n        a chosen colorscale.\\n    :param (float) simplify_county: determines the simplification factor\\n        for the counties. The larger the number, the fewer vertices and edges\\n        each polygon has. See\\n        http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) simplify_state: simplifies the state outline polygon.\\n        See http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) asp: the width-to-height aspect ratio for the camera.\\n        Default = 2.5\\n    :param (bool) show_hover: show county hover and centroid info\\n    :param (bool) show_state_data: reveals state boundary lines\\n    :param (dict) state_outline: dict of attributes of the state outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) county_outline: dict of attributes of the county outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) centroid_marker: dict of attributes of the centroid marker.\\n        The centroid markers are invisible by default and appear visible on\\n        selection. See https://plot.ly/python/reference/#scatter-marker for\\n        all valid params\\n    :param (bool) round_legend_values: automatically round the numbers that\\n        appear in the legend to the nearest integer.\\n        Default = False\\n    :param (bool) exponent_format: if set to True, puts numbers in the K, M,\\n        B number format. For example 4000.0 becomes 4.0K\\n        Default = False\\n    :param (str) legend_title: title that appears above the legend\\n    :param **layout_options: a **kwargs argument for all layout parameters\\n\\n\\n    Example 1: Florida::\\n\\n        import plotly.plotly as py\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'Florida\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        binning_endpoints = list(np.mgrid[min(values):max(values):4j])\\n        colorscale = [\"#030512\",\"#1d1d3b\",\"#323268\",\"#3d4b94\",\"#3e6ab0\",\\n                    \"#4989bc\",\"#60a7c7\",\"#85c5d3\",\"#b7e0e4\",\"#eafcfd\"]\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'Florida\\'], show_state_data=True,\\n            colorscale=colorscale, binning_endpoints=binning_endpoints,\\n            round_legend_values=True, plot_bgcolor=\\'rgb(229,229,229)\\',\\n            paper_bgcolor=\\'rgb(229,229,229)\\', legend_title=\\'Florida Population\\',\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            exponent_format=True,\\n        )\\n\\n    Example 2: New England::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        NE_states = [\\'Connecticut\\', \\'Maine\\', \\'Massachusetts\\',\\n                    \\'New Hampshire\\', \\'Rhode Island\\']\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'].isin(NE_states)]\\n        colorscale = [\\'rgb(68.0, 1.0, 84.0)\\',\\n        \\'rgb(66.0, 64.0, 134.0)\\',\\n        \\'rgb(38.0, 130.0, 142.0)\\',\\n        \\'rgb(63.0, 188.0, 115.0)\\',\\n        \\'rgb(216.0, 226.0, 25.0)\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=NE_states, show_state_data=True\\n        )\\n        fig.show()\\n\\n    Example 3: California and Surrounding States::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'California\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        colorscale = [\\n            \\'rgb(193, 193, 193)\\',\\n            \\'rgb(239,239,239)\\',\\n            \\'rgb(195, 196, 222)\\',\\n            \\'rgb(144,148,194)\\',\\n            \\'rgb(101,104,168)\\',\\n            \\'rgb(65, 53, 132)\\'\\n        ]\\n\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, colorscale=colorscale,\\n            scope=[\\'CA\\', \\'AZ\\', \\'Nevada\\', \\'Oregon\\', \\' Idaho\\'],\\n            binning_endpoints=[14348, 63983, 134827, 426762, 2081313],\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            legend_title=\\'California Counties\\',\\n            title=\\'California and Nearby States\\'\\n        )\\n        fig.show()\\n\\n    Example 4: USA::\\n\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/laucnty16.csv\\'\\n        )\\n        df_sample[\\'State FIPS Code\\'] = df_sample[\\'State FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(2)\\n        )\\n        df_sample[\\'County FIPS Code\\'] = df_sample[\\'County FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(3)\\n        )\\n        df_sample[\\'FIPS\\'] = (\\n            df_sample[\\'State FIPS Code\\'] + df_sample[\\'County FIPS Code\\']\\n        )\\n\\n        binning_endpoints = list(np.linspace(1, 12, len(colorscale) - 1))\\n        colorscale = [\"#f7fbff\", \"#ebf3fb\", \"#deebf7\", \"#d2e3f3\", \"#c6dbef\",\\n                    \"#b3d2e9\", \"#9ecae1\", \"#85bcdb\", \"#6baed6\", \"#57a0ce\",\\n                    \"#4292c6\", \"#3082be\", \"#2171b5\", \"#1361a9\", \"#08519c\",\\n                    \"#0b4083\",\"#08306b\"]\\n        fips = df_sample[\\'FIPS\\']\\n        values = df_sample[\\'Unemployment Rate (%)\\']\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'usa\\'],\\n            binning_endpoints=binning_endpoints, colorscale=colorscale,\\n            show_hover=True, centroid_marker={\\'opacity\\': 0},\\n            asp=2.9, title=\\'USA by Unemployment %\\',\\n            legend_title=\\'Unemployment %\\'\\n        )\\n        fig.show()\\n    '\n    if not _plotly_geo:\n        raise ValueError('\\nThe create_choropleth figure factory requires the plotly-geo package.\\nInstall using pip with:\\n\\n$ pip install plotly-geo\\n\\nOr, install using conda with\\n\\n$ conda install -c plotly plotly-geo\\n')\n    if not gp or not shapefile or (not shapely):\n        raise ImportError('geopandas, pyshp and shapely must be installed for this figure factory.\\n\\nRun the following commands to install the correct versions of the following modules:\\n\\n```\\n$ pip install geopandas==0.3.0\\n$ pip install pyshp==1.2.10\\n$ pip install shapely==1.6.3\\n```\\nIf you are using Windows, follow this post to properly install geopandas and dependencies:http://geoffboeing.com/2014/09/using-geopandas-windows/\\n\\nIf you are using Anaconda, do not use PIP to install the packages above. Instead use conda to install them:\\n\\n```\\n$ conda install plotly\\n$ conda install geopandas\\n```')\n    (df, df_state) = _create_us_counties_df(st_to_state_name_dict, state_to_st_dict)\n    fips_polygon_map = dict(zip(df['FIPS'].tolist(), df['geometry'].tolist()))\n    if not state_outline:\n        state_outline = {'color': 'rgb(240, 240, 240)', 'width': 1}\n    if not county_outline:\n        county_outline = {'color': 'rgb(0, 0, 0)', 'width': 0}\n    if not centroid_marker:\n        centroid_marker = {'size': 3, 'color': 'white', 'opacity': 1}\n    if 'opacity' not in centroid_marker:\n        centroid_marker.update({'opacity': 1})\n    if len(fips) != len(values):\n        raise PlotlyError('fips and values must be the same length')\n    if isinstance(fips, pd.core.series.Series):\n        fips = fips.tolist()\n    if isinstance(values, pd.core.series.Series):\n        values = values.tolist()\n    fips = map(lambda x: int(x), fips)\n    if binning_endpoints:\n        intervals = utils.endpts_to_intervals(binning_endpoints)\n        LEVELS = _intervals_as_labels(intervals, round_legend_values, exponent_format)\n    elif not order:\n        LEVELS = sorted(list(set(values)))\n    else:\n        same_sets = sorted(list(set(values))) == set(order)\n        no_duplicates = not any((order.count(x) > 1 for x in order))\n        if same_sets and no_duplicates:\n            LEVELS = order\n        else:\n            raise PlotlyError('if you are using a custom order of unique values from your color column, you must: have all the unique values in your order and have no duplicate items')\n    if not colorscale:\n        colorscale = []\n        viridis_colors = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES['Viridis'])\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.hex_to_rgb)\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.label_rgb)\n        viri_len = len(viridis_colors) + 1\n        viri_intervals = utils.endpts_to_intervals(list(np.linspace(0, 1, viri_len)))[1:-1]\n        for L in np.linspace(0, 1, len(LEVELS)):\n            for (idx, inter) in enumerate(viri_intervals):\n                if L == 0:\n                    break\n                elif inter[0] < L <= inter[1]:\n                    break\n            intermed = (L - viri_intervals[idx][0]) / (viri_intervals[idx][1] - viri_intervals[idx][0])\n            float_color = clrs.find_intermediate_color(viridis_colors[idx], viridis_colors[idx], intermed, colortype='rgb')\n            float_color = clrs.unlabel_rgb(float_color)\n            float_color = clrs.unconvert_from_RGB_255(float_color)\n            int_rgb = clrs.convert_to_RGB_255(float_color)\n            int_rgb = clrs.label_rgb(int_rgb)\n            colorscale.append(int_rgb)\n    if len(colorscale) < len(LEVELS):\n        raise PlotlyError(\"You have {} LEVELS. Your number of colors in 'colorscale' must be at least the number of LEVELS: {}. If you are using 'binning_endpoints' then 'colorscale' must have at least len(binning_endpoints) + 2 colors\".format(len(LEVELS), min(LEVELS, LEVELS[:20])))\n    color_lookup = dict(zip(LEVELS, colorscale))\n    x_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    y_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    if isinstance(scope, str):\n        raise PlotlyError(\"'scope' must be a list/tuple/sequence\")\n    scope_names = []\n    extra_states = ['Alaska', 'Commonwealth of the Northern Mariana Islands', 'Puerto Rico', 'Guam', 'United States Virgin Islands', 'American Samoa']\n    for state in scope:\n        if state.lower() == 'usa':\n            scope_names = df['STATE_NAME'].unique()\n            scope_names = list(scope_names)\n            for ex_st in extra_states:\n                try:\n                    scope_names.remove(ex_st)\n                except ValueError:\n                    pass\n        else:\n            if state in st_to_state_name_dict.keys():\n                state = st_to_state_name_dict[state]\n            scope_names.append(state)\n    df_state = df_state[df_state['STATE_NAME'].isin(scope_names)]\n    plot_data = []\n    x_centroids = []\n    y_centroids = []\n    centroid_text = []\n    fips_not_in_shapefile = []\n    if not binning_endpoints:\n        for (index, f) in enumerate(fips):\n            level = values[index]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    else:\n        for (index, f) in enumerate(fips):\n            for (j, inter) in enumerate(intervals):\n                if inter[0] < values[index] <= inter[1]:\n                    break\n            level = LEVELS[j]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    if len(fips_not_in_shapefile) > 0:\n        msg = 'Unrecognized FIPS Values\\n\\nWhoops! It looks like you are trying to pass at least one FIPS value that is not in our shapefile of FIPS and data for the counties. Your choropleth will still show up but these counties cannot be shown.\\nUnrecognized FIPS are: {}'.format(fips_not_in_shapefile)\n        warnings.warn(msg)\n    x_states = []\n    y_states = []\n    for (index, row) in df_state.iterrows():\n        if df_state['geometry'][index].type == 'Polygon':\n            x = row.geometry.simplify(simplify_state).exterior.xy[0].tolist()\n            y = row.geometry.simplify(simplify_state).exterior.xy[1].tolist()\n            x_states = x_states + x\n            y_states = y_states + y\n        elif df_state['geometry'][index].type == 'MultiPolygon':\n            x = [poly.simplify(simplify_state).exterior.xy[0].tolist() for poly in df_state['geometry'][index]]\n            y = [poly.simplify(simplify_state).exterior.xy[1].tolist() for poly in df_state['geometry'][index]]\n            for segment in range(len(x)):\n                x_states = x_states + x[segment]\n                y_states = y_states + y[segment]\n                x_states.append(np.nan)\n                y_states.append(np.nan)\n        x_states.append(np.nan)\n        y_states.append(np.nan)\n    for lev in LEVELS:\n        county_data = dict(type='scatter', mode='lines', x=x_traces[lev], y=y_traces[lev], line=county_outline, fill='toself', fillcolor=color_lookup[lev], name=lev, hoverinfo='none')\n        plot_data.append(county_data)\n    if show_hover:\n        hover_points = dict(type='scatter', showlegend=False, legendgroup='centroids', x=x_centroids, y=y_centroids, text=centroid_text, name='US Counties', mode='markers', marker={'color': 'white', 'opacity': 0}, hoverinfo='text')\n        centroids_on_select = dict(selected=dict(marker=centroid_marker), unselected=dict(marker=dict(opacity=0)))\n        hover_points.update(centroids_on_select)\n        plot_data.append(hover_points)\n    if show_state_data:\n        state_data = dict(type='scatter', legendgroup='States', line=state_outline, x=x_states, y=y_states, hoverinfo='text', showlegend=False, mode='lines')\n        plot_data.append(state_data)\n    DEFAULT_LAYOUT = dict(hovermode='closest', xaxis=dict(autorange=False, range=USA_XRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), yaxis=dict(autorange=False, range=USA_YRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), margin=dict(t=40, b=20, r=20, l=20), width=900, height=450, dragmode='select', legend=dict(traceorder='reversed', xanchor='right', yanchor='top', x=1, y=1), annotations=[])\n    fig = dict(data=plot_data, layout=DEFAULT_LAYOUT)\n    fig['layout'].update(layout_options)\n    fig['layout']['annotations'].append(dict(x=1, y=1.05, xref='paper', yref='paper', xanchor='right', showarrow=False, text='<b>' + legend_title + '</b>'))\n    if len(scope) == 1 and scope[0].lower() == 'usa':\n        xaxis_range_low = -125.0\n        xaxis_range_high = -55.0\n        yaxis_range_low = 25.0\n        yaxis_range_high = 49.0\n    else:\n        xaxis_range_low = float('inf')\n        xaxis_range_high = float('-inf')\n        yaxis_range_low = float('inf')\n        yaxis_range_high = float('-inf')\n        for trace in fig['data']:\n            if all((isinstance(n, Number) for n in trace['x'])):\n                calc_x_min = min(trace['x'] or [float('inf')])\n                calc_x_max = max(trace['x'] or [float('-inf')])\n                if calc_x_min < xaxis_range_low:\n                    xaxis_range_low = calc_x_min\n                if calc_x_max > xaxis_range_high:\n                    xaxis_range_high = calc_x_max\n            if all((isinstance(n, Number) for n in trace['y'])):\n                calc_y_min = min(trace['y'] or [float('inf')])\n                calc_y_max = max(trace['y'] or [float('-inf')])\n                if calc_y_min < yaxis_range_low:\n                    yaxis_range_low = calc_y_min\n                if calc_y_max > yaxis_range_high:\n                    yaxis_range_high = calc_y_max\n    fig['layout']['xaxis']['range'] = [xaxis_range_low, xaxis_range_high]\n    fig['layout']['yaxis']['range'] = [yaxis_range_low, yaxis_range_high]\n    if asp is None:\n        usa_x_range = USA_XRANGE[1] - USA_XRANGE[0]\n        usa_y_range = USA_YRANGE[1] - USA_YRANGE[0]\n        asp = usa_x_range / usa_y_range\n    width = float(fig['layout']['xaxis']['range'][1] - fig['layout']['xaxis']['range'][0])\n    height = float(fig['layout']['yaxis']['range'][1] - fig['layout']['yaxis']['range'][0])\n    center = (sum(fig['layout']['xaxis']['range']) / 2.0, sum(fig['layout']['yaxis']['range']) / 2.0)\n    if height / width > 1 / asp:\n        new_width = asp * height\n        fig['layout']['xaxis']['range'][0] = center[0] - new_width * 0.5\n        fig['layout']['xaxis']['range'][1] = center[0] + new_width * 0.5\n    else:\n        new_height = 1 / asp * width\n        fig['layout']['yaxis']['range'][0] = center[1] - new_height * 0.5\n        fig['layout']['yaxis']['range'][1] = center[1] + new_height * 0.5\n    return go.Figure(fig)",
            "def create_choropleth(fips, values, scope=['usa'], binning_endpoints=None, colorscale=None, order=None, simplify_county=0.02, simplify_state=0.02, asp=None, show_hover=True, show_state_data=True, state_outline=None, county_outline=None, centroid_marker=None, round_legend_values=False, exponent_format=False, legend_title='', **layout_options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    **deprecated**, use instead\\n    :func:`plotly.express.choropleth` with custom GeoJSON.\\n\\n    This function also requires `shapely`, `geopandas` and `plotly-geo` to be installed.\\n\\n    Returns figure for county choropleth. Uses data from package_data.\\n\\n    :param (list) fips: list of FIPS values which correspond to the con\\n        catination of state and county ids. An example is \\'01001\\'.\\n    :param (list) values: list of numbers/strings which correspond to the\\n        fips list. These are the values that will determine how the counties\\n        are colored.\\n    :param (list) scope: list of states and/or states abbreviations. Fits\\n        all states in the camera tightly. Selecting [\\'usa\\'] is the equivalent\\n        of appending all 50 states into your scope list. Selecting only \\'usa\\'\\n        does not include \\'Alaska\\', \\'Puerto Rico\\', \\'American Samoa\\',\\n        \\'Commonwealth of the Northern Mariana Islands\\', \\'Guam\\',\\n        \\'United States Virgin Islands\\'. These must be added manually to the\\n        list.\\n        Default = [\\'usa\\']\\n    :param (list) binning_endpoints: ascending numbers which implicitly define\\n        real number intervals which are used as bins. The colorscale used must\\n        have the same number of colors as the number of bins and this will\\n        result in a categorical colormap.\\n    :param (list) colorscale: a list of colors with length equal to the\\n        number of categories of colors. The length must match either all\\n        unique numbers in the \\'values\\' list or if endpoints is being used, the\\n        number of categories created by the endpoints.\\n\\n        For example, if binning_endpoints = [4, 6, 8], then there are 4 bins:\\n        [-inf, 4), [4, 6), [6, 8), [8, inf)\\n    :param (list) order: a list of the unique categories (numbers/bins) in any\\n        desired order. This is helpful if you want to order string values to\\n        a chosen colorscale.\\n    :param (float) simplify_county: determines the simplification factor\\n        for the counties. The larger the number, the fewer vertices and edges\\n        each polygon has. See\\n        http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) simplify_state: simplifies the state outline polygon.\\n        See http://toblerity.org/shapely/manual.html#object.simplify for more\\n        information.\\n        Default = 0.02\\n    :param (float) asp: the width-to-height aspect ratio for the camera.\\n        Default = 2.5\\n    :param (bool) show_hover: show county hover and centroid info\\n    :param (bool) show_state_data: reveals state boundary lines\\n    :param (dict) state_outline: dict of attributes of the state outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) county_outline: dict of attributes of the county outline\\n        including width and color. See\\n        https://plot.ly/python/reference/#scatter-marker-line for all valid\\n        params\\n    :param (dict) centroid_marker: dict of attributes of the centroid marker.\\n        The centroid markers are invisible by default and appear visible on\\n        selection. See https://plot.ly/python/reference/#scatter-marker for\\n        all valid params\\n    :param (bool) round_legend_values: automatically round the numbers that\\n        appear in the legend to the nearest integer.\\n        Default = False\\n    :param (bool) exponent_format: if set to True, puts numbers in the K, M,\\n        B number format. For example 4000.0 becomes 4.0K\\n        Default = False\\n    :param (str) legend_title: title that appears above the legend\\n    :param **layout_options: a **kwargs argument for all layout parameters\\n\\n\\n    Example 1: Florida::\\n\\n        import plotly.plotly as py\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'Florida\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        binning_endpoints = list(np.mgrid[min(values):max(values):4j])\\n        colorscale = [\"#030512\",\"#1d1d3b\",\"#323268\",\"#3d4b94\",\"#3e6ab0\",\\n                    \"#4989bc\",\"#60a7c7\",\"#85c5d3\",\"#b7e0e4\",\"#eafcfd\"]\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'Florida\\'], show_state_data=True,\\n            colorscale=colorscale, binning_endpoints=binning_endpoints,\\n            round_legend_values=True, plot_bgcolor=\\'rgb(229,229,229)\\',\\n            paper_bgcolor=\\'rgb(229,229,229)\\', legend_title=\\'Florida Population\\',\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            exponent_format=True,\\n        )\\n\\n    Example 2: New England::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        NE_states = [\\'Connecticut\\', \\'Maine\\', \\'Massachusetts\\',\\n                    \\'New Hampshire\\', \\'Rhode Island\\']\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'].isin(NE_states)]\\n        colorscale = [\\'rgb(68.0, 1.0, 84.0)\\',\\n        \\'rgb(66.0, 64.0, 134.0)\\',\\n        \\'rgb(38.0, 130.0, 142.0)\\',\\n        \\'rgb(63.0, 188.0, 115.0)\\',\\n        \\'rgb(216.0, 226.0, 25.0)\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=NE_states, show_state_data=True\\n        )\\n        fig.show()\\n\\n    Example 3: California and Surrounding States::\\n\\n        import plotly.figure_factory as ff\\n\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/minoritymajority.csv\\'\\n        )\\n        df_sample_r = df_sample[df_sample[\\'STNAME\\'] == \\'California\\']\\n\\n        values = df_sample_r[\\'TOT_POP\\'].tolist()\\n        fips = df_sample_r[\\'FIPS\\'].tolist()\\n\\n        colorscale = [\\n            \\'rgb(193, 193, 193)\\',\\n            \\'rgb(239,239,239)\\',\\n            \\'rgb(195, 196, 222)\\',\\n            \\'rgb(144,148,194)\\',\\n            \\'rgb(101,104,168)\\',\\n            \\'rgb(65, 53, 132)\\'\\n        ]\\n\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, colorscale=colorscale,\\n            scope=[\\'CA\\', \\'AZ\\', \\'Nevada\\', \\'Oregon\\', \\' Idaho\\'],\\n            binning_endpoints=[14348, 63983, 134827, 426762, 2081313],\\n            county_outline={\\'color\\': \\'rgb(255,255,255)\\', \\'width\\': 0.5},\\n            legend_title=\\'California Counties\\',\\n            title=\\'California and Nearby States\\'\\n        )\\n        fig.show()\\n\\n    Example 4: USA::\\n\\n        import plotly.figure_factory as ff\\n\\n        import numpy as np\\n        import pandas as pd\\n\\n        df_sample = pd.read_csv(\\n            \\'https://raw.githubusercontent.com/plotly/datasets/master/laucnty16.csv\\'\\n        )\\n        df_sample[\\'State FIPS Code\\'] = df_sample[\\'State FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(2)\\n        )\\n        df_sample[\\'County FIPS Code\\'] = df_sample[\\'County FIPS Code\\'].apply(\\n            lambda x: str(x).zfill(3)\\n        )\\n        df_sample[\\'FIPS\\'] = (\\n            df_sample[\\'State FIPS Code\\'] + df_sample[\\'County FIPS Code\\']\\n        )\\n\\n        binning_endpoints = list(np.linspace(1, 12, len(colorscale) - 1))\\n        colorscale = [\"#f7fbff\", \"#ebf3fb\", \"#deebf7\", \"#d2e3f3\", \"#c6dbef\",\\n                    \"#b3d2e9\", \"#9ecae1\", \"#85bcdb\", \"#6baed6\", \"#57a0ce\",\\n                    \"#4292c6\", \"#3082be\", \"#2171b5\", \"#1361a9\", \"#08519c\",\\n                    \"#0b4083\",\"#08306b\"]\\n        fips = df_sample[\\'FIPS\\']\\n        values = df_sample[\\'Unemployment Rate (%)\\']\\n        fig = ff.create_choropleth(\\n            fips=fips, values=values, scope=[\\'usa\\'],\\n            binning_endpoints=binning_endpoints, colorscale=colorscale,\\n            show_hover=True, centroid_marker={\\'opacity\\': 0},\\n            asp=2.9, title=\\'USA by Unemployment %\\',\\n            legend_title=\\'Unemployment %\\'\\n        )\\n        fig.show()\\n    '\n    if not _plotly_geo:\n        raise ValueError('\\nThe create_choropleth figure factory requires the plotly-geo package.\\nInstall using pip with:\\n\\n$ pip install plotly-geo\\n\\nOr, install using conda with\\n\\n$ conda install -c plotly plotly-geo\\n')\n    if not gp or not shapefile or (not shapely):\n        raise ImportError('geopandas, pyshp and shapely must be installed for this figure factory.\\n\\nRun the following commands to install the correct versions of the following modules:\\n\\n```\\n$ pip install geopandas==0.3.0\\n$ pip install pyshp==1.2.10\\n$ pip install shapely==1.6.3\\n```\\nIf you are using Windows, follow this post to properly install geopandas and dependencies:http://geoffboeing.com/2014/09/using-geopandas-windows/\\n\\nIf you are using Anaconda, do not use PIP to install the packages above. Instead use conda to install them:\\n\\n```\\n$ conda install plotly\\n$ conda install geopandas\\n```')\n    (df, df_state) = _create_us_counties_df(st_to_state_name_dict, state_to_st_dict)\n    fips_polygon_map = dict(zip(df['FIPS'].tolist(), df['geometry'].tolist()))\n    if not state_outline:\n        state_outline = {'color': 'rgb(240, 240, 240)', 'width': 1}\n    if not county_outline:\n        county_outline = {'color': 'rgb(0, 0, 0)', 'width': 0}\n    if not centroid_marker:\n        centroid_marker = {'size': 3, 'color': 'white', 'opacity': 1}\n    if 'opacity' not in centroid_marker:\n        centroid_marker.update({'opacity': 1})\n    if len(fips) != len(values):\n        raise PlotlyError('fips and values must be the same length')\n    if isinstance(fips, pd.core.series.Series):\n        fips = fips.tolist()\n    if isinstance(values, pd.core.series.Series):\n        values = values.tolist()\n    fips = map(lambda x: int(x), fips)\n    if binning_endpoints:\n        intervals = utils.endpts_to_intervals(binning_endpoints)\n        LEVELS = _intervals_as_labels(intervals, round_legend_values, exponent_format)\n    elif not order:\n        LEVELS = sorted(list(set(values)))\n    else:\n        same_sets = sorted(list(set(values))) == set(order)\n        no_duplicates = not any((order.count(x) > 1 for x in order))\n        if same_sets and no_duplicates:\n            LEVELS = order\n        else:\n            raise PlotlyError('if you are using a custom order of unique values from your color column, you must: have all the unique values in your order and have no duplicate items')\n    if not colorscale:\n        colorscale = []\n        viridis_colors = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES['Viridis'])\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.hex_to_rgb)\n        viridis_colors = clrs.color_parser(viridis_colors, clrs.label_rgb)\n        viri_len = len(viridis_colors) + 1\n        viri_intervals = utils.endpts_to_intervals(list(np.linspace(0, 1, viri_len)))[1:-1]\n        for L in np.linspace(0, 1, len(LEVELS)):\n            for (idx, inter) in enumerate(viri_intervals):\n                if L == 0:\n                    break\n                elif inter[0] < L <= inter[1]:\n                    break\n            intermed = (L - viri_intervals[idx][0]) / (viri_intervals[idx][1] - viri_intervals[idx][0])\n            float_color = clrs.find_intermediate_color(viridis_colors[idx], viridis_colors[idx], intermed, colortype='rgb')\n            float_color = clrs.unlabel_rgb(float_color)\n            float_color = clrs.unconvert_from_RGB_255(float_color)\n            int_rgb = clrs.convert_to_RGB_255(float_color)\n            int_rgb = clrs.label_rgb(int_rgb)\n            colorscale.append(int_rgb)\n    if len(colorscale) < len(LEVELS):\n        raise PlotlyError(\"You have {} LEVELS. Your number of colors in 'colorscale' must be at least the number of LEVELS: {}. If you are using 'binning_endpoints' then 'colorscale' must have at least len(binning_endpoints) + 2 colors\".format(len(LEVELS), min(LEVELS, LEVELS[:20])))\n    color_lookup = dict(zip(LEVELS, colorscale))\n    x_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    y_traces = dict(zip(LEVELS, [[] for i in range(len(LEVELS))]))\n    if isinstance(scope, str):\n        raise PlotlyError(\"'scope' must be a list/tuple/sequence\")\n    scope_names = []\n    extra_states = ['Alaska', 'Commonwealth of the Northern Mariana Islands', 'Puerto Rico', 'Guam', 'United States Virgin Islands', 'American Samoa']\n    for state in scope:\n        if state.lower() == 'usa':\n            scope_names = df['STATE_NAME'].unique()\n            scope_names = list(scope_names)\n            for ex_st in extra_states:\n                try:\n                    scope_names.remove(ex_st)\n                except ValueError:\n                    pass\n        else:\n            if state in st_to_state_name_dict.keys():\n                state = st_to_state_name_dict[state]\n            scope_names.append(state)\n    df_state = df_state[df_state['STATE_NAME'].isin(scope_names)]\n    plot_data = []\n    x_centroids = []\n    y_centroids = []\n    centroid_text = []\n    fips_not_in_shapefile = []\n    if not binning_endpoints:\n        for (index, f) in enumerate(fips):\n            level = values[index]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    else:\n        for (index, f) in enumerate(fips):\n            for (j, inter) in enumerate(intervals):\n                if inter[0] < values[index] <= inter[1]:\n                    break\n            level = LEVELS[j]\n            try:\n                fips_polygon_map[f].type\n                (x_traces, y_traces, x_centroids, y_centroids, centroid_text) = _calculations(df, fips, values, index, f, simplify_county, level, x_centroids, y_centroids, centroid_text, x_traces, y_traces, fips_polygon_map)\n            except KeyError:\n                fips_not_in_shapefile.append(f)\n    if len(fips_not_in_shapefile) > 0:\n        msg = 'Unrecognized FIPS Values\\n\\nWhoops! It looks like you are trying to pass at least one FIPS value that is not in our shapefile of FIPS and data for the counties. Your choropleth will still show up but these counties cannot be shown.\\nUnrecognized FIPS are: {}'.format(fips_not_in_shapefile)\n        warnings.warn(msg)\n    x_states = []\n    y_states = []\n    for (index, row) in df_state.iterrows():\n        if df_state['geometry'][index].type == 'Polygon':\n            x = row.geometry.simplify(simplify_state).exterior.xy[0].tolist()\n            y = row.geometry.simplify(simplify_state).exterior.xy[1].tolist()\n            x_states = x_states + x\n            y_states = y_states + y\n        elif df_state['geometry'][index].type == 'MultiPolygon':\n            x = [poly.simplify(simplify_state).exterior.xy[0].tolist() for poly in df_state['geometry'][index]]\n            y = [poly.simplify(simplify_state).exterior.xy[1].tolist() for poly in df_state['geometry'][index]]\n            for segment in range(len(x)):\n                x_states = x_states + x[segment]\n                y_states = y_states + y[segment]\n                x_states.append(np.nan)\n                y_states.append(np.nan)\n        x_states.append(np.nan)\n        y_states.append(np.nan)\n    for lev in LEVELS:\n        county_data = dict(type='scatter', mode='lines', x=x_traces[lev], y=y_traces[lev], line=county_outline, fill='toself', fillcolor=color_lookup[lev], name=lev, hoverinfo='none')\n        plot_data.append(county_data)\n    if show_hover:\n        hover_points = dict(type='scatter', showlegend=False, legendgroup='centroids', x=x_centroids, y=y_centroids, text=centroid_text, name='US Counties', mode='markers', marker={'color': 'white', 'opacity': 0}, hoverinfo='text')\n        centroids_on_select = dict(selected=dict(marker=centroid_marker), unselected=dict(marker=dict(opacity=0)))\n        hover_points.update(centroids_on_select)\n        plot_data.append(hover_points)\n    if show_state_data:\n        state_data = dict(type='scatter', legendgroup='States', line=state_outline, x=x_states, y=y_states, hoverinfo='text', showlegend=False, mode='lines')\n        plot_data.append(state_data)\n    DEFAULT_LAYOUT = dict(hovermode='closest', xaxis=dict(autorange=False, range=USA_XRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), yaxis=dict(autorange=False, range=USA_YRANGE, showgrid=False, zeroline=False, fixedrange=True, showticklabels=False), margin=dict(t=40, b=20, r=20, l=20), width=900, height=450, dragmode='select', legend=dict(traceorder='reversed', xanchor='right', yanchor='top', x=1, y=1), annotations=[])\n    fig = dict(data=plot_data, layout=DEFAULT_LAYOUT)\n    fig['layout'].update(layout_options)\n    fig['layout']['annotations'].append(dict(x=1, y=1.05, xref='paper', yref='paper', xanchor='right', showarrow=False, text='<b>' + legend_title + '</b>'))\n    if len(scope) == 1 and scope[0].lower() == 'usa':\n        xaxis_range_low = -125.0\n        xaxis_range_high = -55.0\n        yaxis_range_low = 25.0\n        yaxis_range_high = 49.0\n    else:\n        xaxis_range_low = float('inf')\n        xaxis_range_high = float('-inf')\n        yaxis_range_low = float('inf')\n        yaxis_range_high = float('-inf')\n        for trace in fig['data']:\n            if all((isinstance(n, Number) for n in trace['x'])):\n                calc_x_min = min(trace['x'] or [float('inf')])\n                calc_x_max = max(trace['x'] or [float('-inf')])\n                if calc_x_min < xaxis_range_low:\n                    xaxis_range_low = calc_x_min\n                if calc_x_max > xaxis_range_high:\n                    xaxis_range_high = calc_x_max\n            if all((isinstance(n, Number) for n in trace['y'])):\n                calc_y_min = min(trace['y'] or [float('inf')])\n                calc_y_max = max(trace['y'] or [float('-inf')])\n                if calc_y_min < yaxis_range_low:\n                    yaxis_range_low = calc_y_min\n                if calc_y_max > yaxis_range_high:\n                    yaxis_range_high = calc_y_max\n    fig['layout']['xaxis']['range'] = [xaxis_range_low, xaxis_range_high]\n    fig['layout']['yaxis']['range'] = [yaxis_range_low, yaxis_range_high]\n    if asp is None:\n        usa_x_range = USA_XRANGE[1] - USA_XRANGE[0]\n        usa_y_range = USA_YRANGE[1] - USA_YRANGE[0]\n        asp = usa_x_range / usa_y_range\n    width = float(fig['layout']['xaxis']['range'][1] - fig['layout']['xaxis']['range'][0])\n    height = float(fig['layout']['yaxis']['range'][1] - fig['layout']['yaxis']['range'][0])\n    center = (sum(fig['layout']['xaxis']['range']) / 2.0, sum(fig['layout']['yaxis']['range']) / 2.0)\n    if height / width > 1 / asp:\n        new_width = asp * height\n        fig['layout']['xaxis']['range'][0] = center[0] - new_width * 0.5\n        fig['layout']['xaxis']['range'][1] = center[0] + new_width * 0.5\n    else:\n        new_height = 1 / asp * width\n        fig['layout']['yaxis']['range'][0] = center[1] - new_height * 0.5\n        fig['layout']['yaxis']['range'][1] = center[1] + new_height * 0.5\n    return go.Figure(fig)"
        ]
    }
]