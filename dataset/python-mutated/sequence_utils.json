[
    {
        "func_name": "pad_sequences",
        "original": "@keras_export(['keras.utils.pad_sequences', 'keras.preprocessing.sequence.pad_sequences'])\ndef pad_sequences(sequences, maxlen=None, dtype='int32', padding='pre', truncating='pre', value=0.0):\n    \"\"\"Pads sequences to the same length.\n\n    This function transforms a list (of length `num_samples`)\n    of sequences (lists of integers)\n    into a 2D NumPy array of shape `(num_samples, num_timesteps)`.\n    `num_timesteps` is either the `maxlen` argument if provided,\n    or the length of the longest sequence in the list.\n\n    Sequences that are shorter than `num_timesteps`\n    are padded with `value` until they are `num_timesteps` long.\n\n    Sequences longer than `num_timesteps` are truncated\n    so that they fit the desired length.\n\n    The position where padding or truncation happens is determined by\n    the arguments `padding` and `truncating`, respectively.\n    Pre-padding or removing values from the beginning of the sequence is the\n    default.\n\n    >>> sequence = [[1], [2, 3], [4, 5, 6]]\n    >>> keras.utils.pad_sequences(sequence)\n    array([[0, 0, 1],\n           [0, 2, 3],\n           [4, 5, 6]], dtype=int32)\n\n    >>> keras.utils.pad_sequences(sequence, value=-1)\n    array([[-1, -1,  1],\n           [-1,  2,  3],\n           [ 4,  5,  6]], dtype=int32)\n\n    >>> keras.utils.pad_sequences(sequence, padding='post')\n    array([[1, 0, 0],\n           [2, 3, 0],\n           [4, 5, 6]], dtype=int32)\n\n    >>> keras.utils.pad_sequences(sequence, maxlen=2)\n    array([[0, 1],\n           [2, 3],\n           [5, 6]], dtype=int32)\n\n    Args:\n        sequences: List of sequences (each sequence is a list of integers).\n        maxlen: Optional Int, maximum length of all sequences. If not provided,\n            sequences will be padded to the length of the longest individual\n            sequence.\n        dtype: (Optional, defaults to `\"int32\"`). Type of the output sequences.\n            To pad sequences with variable length strings, you can use `object`.\n        padding: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\n            pad either before or after each sequence.\n        truncating: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\n            remove values from sequences larger than\n            `maxlen`, either at the beginning or at the end of the sequences.\n        value: Float or String, padding value. (Optional, defaults to 0.)\n\n    Returns:\n        NumPy array with shape `(len(sequences), maxlen)`\n    \"\"\"\n    if not hasattr(sequences, '__len__'):\n        raise ValueError('`sequences` must be iterable.')\n    num_samples = len(sequences)\n    lengths = []\n    sample_shape = ()\n    flag = True\n    for x in sequences:\n        try:\n            lengths.append(len(x))\n            if flag and len(x):\n                sample_shape = np.asarray(x).shape[1:]\n                flag = False\n        except TypeError as e:\n            raise ValueError(f'`sequences` must be a list of iterables. Found non-iterable: {str(x)}') from e\n    if maxlen is None:\n        maxlen = np.max(lengths)\n    is_dtype_str = np.issubdtype(dtype, np.str_) or np.issubdtype(dtype, np.unicode_)\n    if isinstance(value, str) and dtype != object and (not is_dtype_str):\n        raise ValueError(f\"`dtype` {dtype} is not compatible with `value`'s type: {type(value)}\\nYou should set `dtype=object` for variable length strings.\")\n    x = np.full((num_samples, maxlen) + sample_shape, value, dtype=dtype)\n    for (idx, s) in enumerate(sequences):\n        if not len(s):\n            continue\n        if truncating == 'pre':\n            trunc = s[-maxlen:]\n        elif truncating == 'post':\n            trunc = s[:maxlen]\n        else:\n            raise ValueError(f'Truncating type \"{truncating}\" not understood')\n        trunc = np.asarray(trunc, dtype=dtype)\n        if trunc.shape[1:] != sample_shape:\n            raise ValueError(f'Shape of sample {trunc.shape[1:]} of sequence at position {idx} is different from expected shape {sample_shape}')\n        if padding == 'post':\n            x[idx, :len(trunc)] = trunc\n        elif padding == 'pre':\n            x[idx, -len(trunc):] = trunc\n        else:\n            raise ValueError(f'Padding type \"{padding}\" not understood')\n    return x",
        "mutated": [
            "@keras_export(['keras.utils.pad_sequences', 'keras.preprocessing.sequence.pad_sequences'])\ndef pad_sequences(sequences, maxlen=None, dtype='int32', padding='pre', truncating='pre', value=0.0):\n    if False:\n        i = 10\n    'Pads sequences to the same length.\\n\\n    This function transforms a list (of length `num_samples`)\\n    of sequences (lists of integers)\\n    into a 2D NumPy array of shape `(num_samples, num_timesteps)`.\\n    `num_timesteps` is either the `maxlen` argument if provided,\\n    or the length of the longest sequence in the list.\\n\\n    Sequences that are shorter than `num_timesteps`\\n    are padded with `value` until they are `num_timesteps` long.\\n\\n    Sequences longer than `num_timesteps` are truncated\\n    so that they fit the desired length.\\n\\n    The position where padding or truncation happens is determined by\\n    the arguments `padding` and `truncating`, respectively.\\n    Pre-padding or removing values from the beginning of the sequence is the\\n    default.\\n\\n    >>> sequence = [[1], [2, 3], [4, 5, 6]]\\n    >>> keras.utils.pad_sequences(sequence)\\n    array([[0, 0, 1],\\n           [0, 2, 3],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, value=-1)\\n    array([[-1, -1,  1],\\n           [-1,  2,  3],\\n           [ 4,  5,  6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, padding=\\'post\\')\\n    array([[1, 0, 0],\\n           [2, 3, 0],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, maxlen=2)\\n    array([[0, 1],\\n           [2, 3],\\n           [5, 6]], dtype=int32)\\n\\n    Args:\\n        sequences: List of sequences (each sequence is a list of integers).\\n        maxlen: Optional Int, maximum length of all sequences. If not provided,\\n            sequences will be padded to the length of the longest individual\\n            sequence.\\n        dtype: (Optional, defaults to `\"int32\"`). Type of the output sequences.\\n            To pad sequences with variable length strings, you can use `object`.\\n        padding: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            pad either before or after each sequence.\\n        truncating: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            remove values from sequences larger than\\n            `maxlen`, either at the beginning or at the end of the sequences.\\n        value: Float or String, padding value. (Optional, defaults to 0.)\\n\\n    Returns:\\n        NumPy array with shape `(len(sequences), maxlen)`\\n    '\n    if not hasattr(sequences, '__len__'):\n        raise ValueError('`sequences` must be iterable.')\n    num_samples = len(sequences)\n    lengths = []\n    sample_shape = ()\n    flag = True\n    for x in sequences:\n        try:\n            lengths.append(len(x))\n            if flag and len(x):\n                sample_shape = np.asarray(x).shape[1:]\n                flag = False\n        except TypeError as e:\n            raise ValueError(f'`sequences` must be a list of iterables. Found non-iterable: {str(x)}') from e\n    if maxlen is None:\n        maxlen = np.max(lengths)\n    is_dtype_str = np.issubdtype(dtype, np.str_) or np.issubdtype(dtype, np.unicode_)\n    if isinstance(value, str) and dtype != object and (not is_dtype_str):\n        raise ValueError(f\"`dtype` {dtype} is not compatible with `value`'s type: {type(value)}\\nYou should set `dtype=object` for variable length strings.\")\n    x = np.full((num_samples, maxlen) + sample_shape, value, dtype=dtype)\n    for (idx, s) in enumerate(sequences):\n        if not len(s):\n            continue\n        if truncating == 'pre':\n            trunc = s[-maxlen:]\n        elif truncating == 'post':\n            trunc = s[:maxlen]\n        else:\n            raise ValueError(f'Truncating type \"{truncating}\" not understood')\n        trunc = np.asarray(trunc, dtype=dtype)\n        if trunc.shape[1:] != sample_shape:\n            raise ValueError(f'Shape of sample {trunc.shape[1:]} of sequence at position {idx} is different from expected shape {sample_shape}')\n        if padding == 'post':\n            x[idx, :len(trunc)] = trunc\n        elif padding == 'pre':\n            x[idx, -len(trunc):] = trunc\n        else:\n            raise ValueError(f'Padding type \"{padding}\" not understood')\n    return x",
            "@keras_export(['keras.utils.pad_sequences', 'keras.preprocessing.sequence.pad_sequences'])\ndef pad_sequences(sequences, maxlen=None, dtype='int32', padding='pre', truncating='pre', value=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Pads sequences to the same length.\\n\\n    This function transforms a list (of length `num_samples`)\\n    of sequences (lists of integers)\\n    into a 2D NumPy array of shape `(num_samples, num_timesteps)`.\\n    `num_timesteps` is either the `maxlen` argument if provided,\\n    or the length of the longest sequence in the list.\\n\\n    Sequences that are shorter than `num_timesteps`\\n    are padded with `value` until they are `num_timesteps` long.\\n\\n    Sequences longer than `num_timesteps` are truncated\\n    so that they fit the desired length.\\n\\n    The position where padding or truncation happens is determined by\\n    the arguments `padding` and `truncating`, respectively.\\n    Pre-padding or removing values from the beginning of the sequence is the\\n    default.\\n\\n    >>> sequence = [[1], [2, 3], [4, 5, 6]]\\n    >>> keras.utils.pad_sequences(sequence)\\n    array([[0, 0, 1],\\n           [0, 2, 3],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, value=-1)\\n    array([[-1, -1,  1],\\n           [-1,  2,  3],\\n           [ 4,  5,  6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, padding=\\'post\\')\\n    array([[1, 0, 0],\\n           [2, 3, 0],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, maxlen=2)\\n    array([[0, 1],\\n           [2, 3],\\n           [5, 6]], dtype=int32)\\n\\n    Args:\\n        sequences: List of sequences (each sequence is a list of integers).\\n        maxlen: Optional Int, maximum length of all sequences. If not provided,\\n            sequences will be padded to the length of the longest individual\\n            sequence.\\n        dtype: (Optional, defaults to `\"int32\"`). Type of the output sequences.\\n            To pad sequences with variable length strings, you can use `object`.\\n        padding: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            pad either before or after each sequence.\\n        truncating: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            remove values from sequences larger than\\n            `maxlen`, either at the beginning or at the end of the sequences.\\n        value: Float or String, padding value. (Optional, defaults to 0.)\\n\\n    Returns:\\n        NumPy array with shape `(len(sequences), maxlen)`\\n    '\n    if not hasattr(sequences, '__len__'):\n        raise ValueError('`sequences` must be iterable.')\n    num_samples = len(sequences)\n    lengths = []\n    sample_shape = ()\n    flag = True\n    for x in sequences:\n        try:\n            lengths.append(len(x))\n            if flag and len(x):\n                sample_shape = np.asarray(x).shape[1:]\n                flag = False\n        except TypeError as e:\n            raise ValueError(f'`sequences` must be a list of iterables. Found non-iterable: {str(x)}') from e\n    if maxlen is None:\n        maxlen = np.max(lengths)\n    is_dtype_str = np.issubdtype(dtype, np.str_) or np.issubdtype(dtype, np.unicode_)\n    if isinstance(value, str) and dtype != object and (not is_dtype_str):\n        raise ValueError(f\"`dtype` {dtype} is not compatible with `value`'s type: {type(value)}\\nYou should set `dtype=object` for variable length strings.\")\n    x = np.full((num_samples, maxlen) + sample_shape, value, dtype=dtype)\n    for (idx, s) in enumerate(sequences):\n        if not len(s):\n            continue\n        if truncating == 'pre':\n            trunc = s[-maxlen:]\n        elif truncating == 'post':\n            trunc = s[:maxlen]\n        else:\n            raise ValueError(f'Truncating type \"{truncating}\" not understood')\n        trunc = np.asarray(trunc, dtype=dtype)\n        if trunc.shape[1:] != sample_shape:\n            raise ValueError(f'Shape of sample {trunc.shape[1:]} of sequence at position {idx} is different from expected shape {sample_shape}')\n        if padding == 'post':\n            x[idx, :len(trunc)] = trunc\n        elif padding == 'pre':\n            x[idx, -len(trunc):] = trunc\n        else:\n            raise ValueError(f'Padding type \"{padding}\" not understood')\n    return x",
            "@keras_export(['keras.utils.pad_sequences', 'keras.preprocessing.sequence.pad_sequences'])\ndef pad_sequences(sequences, maxlen=None, dtype='int32', padding='pre', truncating='pre', value=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Pads sequences to the same length.\\n\\n    This function transforms a list (of length `num_samples`)\\n    of sequences (lists of integers)\\n    into a 2D NumPy array of shape `(num_samples, num_timesteps)`.\\n    `num_timesteps` is either the `maxlen` argument if provided,\\n    or the length of the longest sequence in the list.\\n\\n    Sequences that are shorter than `num_timesteps`\\n    are padded with `value` until they are `num_timesteps` long.\\n\\n    Sequences longer than `num_timesteps` are truncated\\n    so that they fit the desired length.\\n\\n    The position where padding or truncation happens is determined by\\n    the arguments `padding` and `truncating`, respectively.\\n    Pre-padding or removing values from the beginning of the sequence is the\\n    default.\\n\\n    >>> sequence = [[1], [2, 3], [4, 5, 6]]\\n    >>> keras.utils.pad_sequences(sequence)\\n    array([[0, 0, 1],\\n           [0, 2, 3],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, value=-1)\\n    array([[-1, -1,  1],\\n           [-1,  2,  3],\\n           [ 4,  5,  6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, padding=\\'post\\')\\n    array([[1, 0, 0],\\n           [2, 3, 0],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, maxlen=2)\\n    array([[0, 1],\\n           [2, 3],\\n           [5, 6]], dtype=int32)\\n\\n    Args:\\n        sequences: List of sequences (each sequence is a list of integers).\\n        maxlen: Optional Int, maximum length of all sequences. If not provided,\\n            sequences will be padded to the length of the longest individual\\n            sequence.\\n        dtype: (Optional, defaults to `\"int32\"`). Type of the output sequences.\\n            To pad sequences with variable length strings, you can use `object`.\\n        padding: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            pad either before or after each sequence.\\n        truncating: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            remove values from sequences larger than\\n            `maxlen`, either at the beginning or at the end of the sequences.\\n        value: Float or String, padding value. (Optional, defaults to 0.)\\n\\n    Returns:\\n        NumPy array with shape `(len(sequences), maxlen)`\\n    '\n    if not hasattr(sequences, '__len__'):\n        raise ValueError('`sequences` must be iterable.')\n    num_samples = len(sequences)\n    lengths = []\n    sample_shape = ()\n    flag = True\n    for x in sequences:\n        try:\n            lengths.append(len(x))\n            if flag and len(x):\n                sample_shape = np.asarray(x).shape[1:]\n                flag = False\n        except TypeError as e:\n            raise ValueError(f'`sequences` must be a list of iterables. Found non-iterable: {str(x)}') from e\n    if maxlen is None:\n        maxlen = np.max(lengths)\n    is_dtype_str = np.issubdtype(dtype, np.str_) or np.issubdtype(dtype, np.unicode_)\n    if isinstance(value, str) and dtype != object and (not is_dtype_str):\n        raise ValueError(f\"`dtype` {dtype} is not compatible with `value`'s type: {type(value)}\\nYou should set `dtype=object` for variable length strings.\")\n    x = np.full((num_samples, maxlen) + sample_shape, value, dtype=dtype)\n    for (idx, s) in enumerate(sequences):\n        if not len(s):\n            continue\n        if truncating == 'pre':\n            trunc = s[-maxlen:]\n        elif truncating == 'post':\n            trunc = s[:maxlen]\n        else:\n            raise ValueError(f'Truncating type \"{truncating}\" not understood')\n        trunc = np.asarray(trunc, dtype=dtype)\n        if trunc.shape[1:] != sample_shape:\n            raise ValueError(f'Shape of sample {trunc.shape[1:]} of sequence at position {idx} is different from expected shape {sample_shape}')\n        if padding == 'post':\n            x[idx, :len(trunc)] = trunc\n        elif padding == 'pre':\n            x[idx, -len(trunc):] = trunc\n        else:\n            raise ValueError(f'Padding type \"{padding}\" not understood')\n    return x",
            "@keras_export(['keras.utils.pad_sequences', 'keras.preprocessing.sequence.pad_sequences'])\ndef pad_sequences(sequences, maxlen=None, dtype='int32', padding='pre', truncating='pre', value=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Pads sequences to the same length.\\n\\n    This function transforms a list (of length `num_samples`)\\n    of sequences (lists of integers)\\n    into a 2D NumPy array of shape `(num_samples, num_timesteps)`.\\n    `num_timesteps` is either the `maxlen` argument if provided,\\n    or the length of the longest sequence in the list.\\n\\n    Sequences that are shorter than `num_timesteps`\\n    are padded with `value` until they are `num_timesteps` long.\\n\\n    Sequences longer than `num_timesteps` are truncated\\n    so that they fit the desired length.\\n\\n    The position where padding or truncation happens is determined by\\n    the arguments `padding` and `truncating`, respectively.\\n    Pre-padding or removing values from the beginning of the sequence is the\\n    default.\\n\\n    >>> sequence = [[1], [2, 3], [4, 5, 6]]\\n    >>> keras.utils.pad_sequences(sequence)\\n    array([[0, 0, 1],\\n           [0, 2, 3],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, value=-1)\\n    array([[-1, -1,  1],\\n           [-1,  2,  3],\\n           [ 4,  5,  6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, padding=\\'post\\')\\n    array([[1, 0, 0],\\n           [2, 3, 0],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, maxlen=2)\\n    array([[0, 1],\\n           [2, 3],\\n           [5, 6]], dtype=int32)\\n\\n    Args:\\n        sequences: List of sequences (each sequence is a list of integers).\\n        maxlen: Optional Int, maximum length of all sequences. If not provided,\\n            sequences will be padded to the length of the longest individual\\n            sequence.\\n        dtype: (Optional, defaults to `\"int32\"`). Type of the output sequences.\\n            To pad sequences with variable length strings, you can use `object`.\\n        padding: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            pad either before or after each sequence.\\n        truncating: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            remove values from sequences larger than\\n            `maxlen`, either at the beginning or at the end of the sequences.\\n        value: Float or String, padding value. (Optional, defaults to 0.)\\n\\n    Returns:\\n        NumPy array with shape `(len(sequences), maxlen)`\\n    '\n    if not hasattr(sequences, '__len__'):\n        raise ValueError('`sequences` must be iterable.')\n    num_samples = len(sequences)\n    lengths = []\n    sample_shape = ()\n    flag = True\n    for x in sequences:\n        try:\n            lengths.append(len(x))\n            if flag and len(x):\n                sample_shape = np.asarray(x).shape[1:]\n                flag = False\n        except TypeError as e:\n            raise ValueError(f'`sequences` must be a list of iterables. Found non-iterable: {str(x)}') from e\n    if maxlen is None:\n        maxlen = np.max(lengths)\n    is_dtype_str = np.issubdtype(dtype, np.str_) or np.issubdtype(dtype, np.unicode_)\n    if isinstance(value, str) and dtype != object and (not is_dtype_str):\n        raise ValueError(f\"`dtype` {dtype} is not compatible with `value`'s type: {type(value)}\\nYou should set `dtype=object` for variable length strings.\")\n    x = np.full((num_samples, maxlen) + sample_shape, value, dtype=dtype)\n    for (idx, s) in enumerate(sequences):\n        if not len(s):\n            continue\n        if truncating == 'pre':\n            trunc = s[-maxlen:]\n        elif truncating == 'post':\n            trunc = s[:maxlen]\n        else:\n            raise ValueError(f'Truncating type \"{truncating}\" not understood')\n        trunc = np.asarray(trunc, dtype=dtype)\n        if trunc.shape[1:] != sample_shape:\n            raise ValueError(f'Shape of sample {trunc.shape[1:]} of sequence at position {idx} is different from expected shape {sample_shape}')\n        if padding == 'post':\n            x[idx, :len(trunc)] = trunc\n        elif padding == 'pre':\n            x[idx, -len(trunc):] = trunc\n        else:\n            raise ValueError(f'Padding type \"{padding}\" not understood')\n    return x",
            "@keras_export(['keras.utils.pad_sequences', 'keras.preprocessing.sequence.pad_sequences'])\ndef pad_sequences(sequences, maxlen=None, dtype='int32', padding='pre', truncating='pre', value=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Pads sequences to the same length.\\n\\n    This function transforms a list (of length `num_samples`)\\n    of sequences (lists of integers)\\n    into a 2D NumPy array of shape `(num_samples, num_timesteps)`.\\n    `num_timesteps` is either the `maxlen` argument if provided,\\n    or the length of the longest sequence in the list.\\n\\n    Sequences that are shorter than `num_timesteps`\\n    are padded with `value` until they are `num_timesteps` long.\\n\\n    Sequences longer than `num_timesteps` are truncated\\n    so that they fit the desired length.\\n\\n    The position where padding or truncation happens is determined by\\n    the arguments `padding` and `truncating`, respectively.\\n    Pre-padding or removing values from the beginning of the sequence is the\\n    default.\\n\\n    >>> sequence = [[1], [2, 3], [4, 5, 6]]\\n    >>> keras.utils.pad_sequences(sequence)\\n    array([[0, 0, 1],\\n           [0, 2, 3],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, value=-1)\\n    array([[-1, -1,  1],\\n           [-1,  2,  3],\\n           [ 4,  5,  6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, padding=\\'post\\')\\n    array([[1, 0, 0],\\n           [2, 3, 0],\\n           [4, 5, 6]], dtype=int32)\\n\\n    >>> keras.utils.pad_sequences(sequence, maxlen=2)\\n    array([[0, 1],\\n           [2, 3],\\n           [5, 6]], dtype=int32)\\n\\n    Args:\\n        sequences: List of sequences (each sequence is a list of integers).\\n        maxlen: Optional Int, maximum length of all sequences. If not provided,\\n            sequences will be padded to the length of the longest individual\\n            sequence.\\n        dtype: (Optional, defaults to `\"int32\"`). Type of the output sequences.\\n            To pad sequences with variable length strings, you can use `object`.\\n        padding: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            pad either before or after each sequence.\\n        truncating: String, \"pre\" or \"post\" (optional, defaults to `\"pre\"`):\\n            remove values from sequences larger than\\n            `maxlen`, either at the beginning or at the end of the sequences.\\n        value: Float or String, padding value. (Optional, defaults to 0.)\\n\\n    Returns:\\n        NumPy array with shape `(len(sequences), maxlen)`\\n    '\n    if not hasattr(sequences, '__len__'):\n        raise ValueError('`sequences` must be iterable.')\n    num_samples = len(sequences)\n    lengths = []\n    sample_shape = ()\n    flag = True\n    for x in sequences:\n        try:\n            lengths.append(len(x))\n            if flag and len(x):\n                sample_shape = np.asarray(x).shape[1:]\n                flag = False\n        except TypeError as e:\n            raise ValueError(f'`sequences` must be a list of iterables. Found non-iterable: {str(x)}') from e\n    if maxlen is None:\n        maxlen = np.max(lengths)\n    is_dtype_str = np.issubdtype(dtype, np.str_) or np.issubdtype(dtype, np.unicode_)\n    if isinstance(value, str) and dtype != object and (not is_dtype_str):\n        raise ValueError(f\"`dtype` {dtype} is not compatible with `value`'s type: {type(value)}\\nYou should set `dtype=object` for variable length strings.\")\n    x = np.full((num_samples, maxlen) + sample_shape, value, dtype=dtype)\n    for (idx, s) in enumerate(sequences):\n        if not len(s):\n            continue\n        if truncating == 'pre':\n            trunc = s[-maxlen:]\n        elif truncating == 'post':\n            trunc = s[:maxlen]\n        else:\n            raise ValueError(f'Truncating type \"{truncating}\" not understood')\n        trunc = np.asarray(trunc, dtype=dtype)\n        if trunc.shape[1:] != sample_shape:\n            raise ValueError(f'Shape of sample {trunc.shape[1:]} of sequence at position {idx} is different from expected shape {sample_shape}')\n        if padding == 'post':\n            x[idx, :len(trunc)] = trunc\n        elif padding == 'pre':\n            x[idx, -len(trunc):] = trunc\n        else:\n            raise ValueError(f'Padding type \"{padding}\" not understood')\n    return x"
        ]
    }
]