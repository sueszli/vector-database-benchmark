[
    {
        "func_name": "_to_stublist",
        "original": "def _to_stublist(degree_sequence):\n    \"\"\"Returns a list of degree-repeated node numbers.\n\n    ``degree_sequence`` is a list of nonnegative integers representing\n    the degrees of nodes in a graph.\n\n    This function returns a list of node numbers with multiplicities\n    according to the given degree sequence. For example, if the first\n    element of ``degree_sequence`` is ``3``, then the first node number,\n    ``0``, will appear at the head of the returned list three times. The\n    node numbers are assumed to be the numbers zero through\n    ``len(degree_sequence) - 1``.\n\n    Examples\n    --------\n\n    >>> degree_sequence = [1, 2, 3]\n    >>> _to_stublist(degree_sequence)\n    [0, 1, 1, 2, 2, 2]\n\n    If a zero appears in the sequence, that means the node exists but\n    has degree zero, so that number will be skipped in the returned\n    list::\n\n    >>> degree_sequence = [2, 0, 1]\n    >>> _to_stublist(degree_sequence)\n    [0, 0, 2]\n\n    \"\"\"\n    return list(chaini(([n] * d for (n, d) in enumerate(degree_sequence))))",
        "mutated": [
            "def _to_stublist(degree_sequence):\n    if False:\n        i = 10\n    'Returns a list of degree-repeated node numbers.\\n\\n    ``degree_sequence`` is a list of nonnegative integers representing\\n    the degrees of nodes in a graph.\\n\\n    This function returns a list of node numbers with multiplicities\\n    according to the given degree sequence. For example, if the first\\n    element of ``degree_sequence`` is ``3``, then the first node number,\\n    ``0``, will appear at the head of the returned list three times. The\\n    node numbers are assumed to be the numbers zero through\\n    ``len(degree_sequence) - 1``.\\n\\n    Examples\\n    --------\\n\\n    >>> degree_sequence = [1, 2, 3]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 1, 1, 2, 2, 2]\\n\\n    If a zero appears in the sequence, that means the node exists but\\n    has degree zero, so that number will be skipped in the returned\\n    list::\\n\\n    >>> degree_sequence = [2, 0, 1]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 0, 2]\\n\\n    '\n    return list(chaini(([n] * d for (n, d) in enumerate(degree_sequence))))",
            "def _to_stublist(degree_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a list of degree-repeated node numbers.\\n\\n    ``degree_sequence`` is a list of nonnegative integers representing\\n    the degrees of nodes in a graph.\\n\\n    This function returns a list of node numbers with multiplicities\\n    according to the given degree sequence. For example, if the first\\n    element of ``degree_sequence`` is ``3``, then the first node number,\\n    ``0``, will appear at the head of the returned list three times. The\\n    node numbers are assumed to be the numbers zero through\\n    ``len(degree_sequence) - 1``.\\n\\n    Examples\\n    --------\\n\\n    >>> degree_sequence = [1, 2, 3]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 1, 1, 2, 2, 2]\\n\\n    If a zero appears in the sequence, that means the node exists but\\n    has degree zero, so that number will be skipped in the returned\\n    list::\\n\\n    >>> degree_sequence = [2, 0, 1]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 0, 2]\\n\\n    '\n    return list(chaini(([n] * d for (n, d) in enumerate(degree_sequence))))",
            "def _to_stublist(degree_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a list of degree-repeated node numbers.\\n\\n    ``degree_sequence`` is a list of nonnegative integers representing\\n    the degrees of nodes in a graph.\\n\\n    This function returns a list of node numbers with multiplicities\\n    according to the given degree sequence. For example, if the first\\n    element of ``degree_sequence`` is ``3``, then the first node number,\\n    ``0``, will appear at the head of the returned list three times. The\\n    node numbers are assumed to be the numbers zero through\\n    ``len(degree_sequence) - 1``.\\n\\n    Examples\\n    --------\\n\\n    >>> degree_sequence = [1, 2, 3]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 1, 1, 2, 2, 2]\\n\\n    If a zero appears in the sequence, that means the node exists but\\n    has degree zero, so that number will be skipped in the returned\\n    list::\\n\\n    >>> degree_sequence = [2, 0, 1]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 0, 2]\\n\\n    '\n    return list(chaini(([n] * d for (n, d) in enumerate(degree_sequence))))",
            "def _to_stublist(degree_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a list of degree-repeated node numbers.\\n\\n    ``degree_sequence`` is a list of nonnegative integers representing\\n    the degrees of nodes in a graph.\\n\\n    This function returns a list of node numbers with multiplicities\\n    according to the given degree sequence. For example, if the first\\n    element of ``degree_sequence`` is ``3``, then the first node number,\\n    ``0``, will appear at the head of the returned list three times. The\\n    node numbers are assumed to be the numbers zero through\\n    ``len(degree_sequence) - 1``.\\n\\n    Examples\\n    --------\\n\\n    >>> degree_sequence = [1, 2, 3]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 1, 1, 2, 2, 2]\\n\\n    If a zero appears in the sequence, that means the node exists but\\n    has degree zero, so that number will be skipped in the returned\\n    list::\\n\\n    >>> degree_sequence = [2, 0, 1]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 0, 2]\\n\\n    '\n    return list(chaini(([n] * d for (n, d) in enumerate(degree_sequence))))",
            "def _to_stublist(degree_sequence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a list of degree-repeated node numbers.\\n\\n    ``degree_sequence`` is a list of nonnegative integers representing\\n    the degrees of nodes in a graph.\\n\\n    This function returns a list of node numbers with multiplicities\\n    according to the given degree sequence. For example, if the first\\n    element of ``degree_sequence`` is ``3``, then the first node number,\\n    ``0``, will appear at the head of the returned list three times. The\\n    node numbers are assumed to be the numbers zero through\\n    ``len(degree_sequence) - 1``.\\n\\n    Examples\\n    --------\\n\\n    >>> degree_sequence = [1, 2, 3]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 1, 1, 2, 2, 2]\\n\\n    If a zero appears in the sequence, that means the node exists but\\n    has degree zero, so that number will be skipped in the returned\\n    list::\\n\\n    >>> degree_sequence = [2, 0, 1]\\n    >>> _to_stublist(degree_sequence)\\n    [0, 0, 2]\\n\\n    '\n    return list(chaini(([n] * d for (n, d) in enumerate(degree_sequence))))"
        ]
    },
    {
        "func_name": "_configuration_model",
        "original": "def _configuration_model(deg_sequence, create_using, directed=False, in_deg_sequence=None, seed=None):\n    \"\"\"Helper function for generating either undirected or directed\n    configuration model graphs.\n\n    ``deg_sequence`` is a list of nonnegative integers representing the\n    degree of the node whose label is the index of the list element.\n\n    ``create_using`` see :func:`~networkx.empty_graph`.\n\n    ``directed`` and ``in_deg_sequence`` are required if you want the\n    returned graph to be generated using the directed configuration\n    model algorithm. If ``directed`` is ``False``, then ``deg_sequence``\n    is interpreted as the degree sequence of an undirected graph and\n    ``in_deg_sequence`` is ignored. Otherwise, if ``directed`` is\n    ``True``, then ``deg_sequence`` is interpreted as the out-degree\n    sequence and ``in_deg_sequence`` as the in-degree sequence of a\n    directed graph.\n\n    .. note::\n\n       ``deg_sequence`` and ``in_deg_sequence`` need not be the same\n       length.\n\n    ``seed`` is a random.Random or numpy.random.RandomState instance\n\n    This function returns a graph, directed if and only if ``directed``\n    is ``True``, generated according to the configuration model\n    algorithm. For more information on the algorithm, see the\n    :func:`configuration_model` or :func:`directed_configuration_model`\n    functions.\n\n    \"\"\"\n    n = len(deg_sequence)\n    G = nx.empty_graph(n, create_using)\n    if n == 0:\n        return G\n    if directed:\n        pairs = zip_longest(deg_sequence, in_deg_sequence, fillvalue=0)\n        (out_deg, in_deg) = zip(*pairs)\n        out_stublist = _to_stublist(out_deg)\n        in_stublist = _to_stublist(in_deg)\n        seed.shuffle(out_stublist)\n        seed.shuffle(in_stublist)\n    else:\n        stublist = _to_stublist(deg_sequence)\n        n = len(stublist)\n        half = n // 2\n        seed.shuffle(stublist)\n        (out_stublist, in_stublist) = (stublist[:half], stublist[half:])\n    G.add_edges_from(zip(out_stublist, in_stublist))\n    return G",
        "mutated": [
            "def _configuration_model(deg_sequence, create_using, directed=False, in_deg_sequence=None, seed=None):\n    if False:\n        i = 10\n    'Helper function for generating either undirected or directed\\n    configuration model graphs.\\n\\n    ``deg_sequence`` is a list of nonnegative integers representing the\\n    degree of the node whose label is the index of the list element.\\n\\n    ``create_using`` see :func:`~networkx.empty_graph`.\\n\\n    ``directed`` and ``in_deg_sequence`` are required if you want the\\n    returned graph to be generated using the directed configuration\\n    model algorithm. If ``directed`` is ``False``, then ``deg_sequence``\\n    is interpreted as the degree sequence of an undirected graph and\\n    ``in_deg_sequence`` is ignored. Otherwise, if ``directed`` is\\n    ``True``, then ``deg_sequence`` is interpreted as the out-degree\\n    sequence and ``in_deg_sequence`` as the in-degree sequence of a\\n    directed graph.\\n\\n    .. note::\\n\\n       ``deg_sequence`` and ``in_deg_sequence`` need not be the same\\n       length.\\n\\n    ``seed`` is a random.Random or numpy.random.RandomState instance\\n\\n    This function returns a graph, directed if and only if ``directed``\\n    is ``True``, generated according to the configuration model\\n    algorithm. For more information on the algorithm, see the\\n    :func:`configuration_model` or :func:`directed_configuration_model`\\n    functions.\\n\\n    '\n    n = len(deg_sequence)\n    G = nx.empty_graph(n, create_using)\n    if n == 0:\n        return G\n    if directed:\n        pairs = zip_longest(deg_sequence, in_deg_sequence, fillvalue=0)\n        (out_deg, in_deg) = zip(*pairs)\n        out_stublist = _to_stublist(out_deg)\n        in_stublist = _to_stublist(in_deg)\n        seed.shuffle(out_stublist)\n        seed.shuffle(in_stublist)\n    else:\n        stublist = _to_stublist(deg_sequence)\n        n = len(stublist)\n        half = n // 2\n        seed.shuffle(stublist)\n        (out_stublist, in_stublist) = (stublist[:half], stublist[half:])\n    G.add_edges_from(zip(out_stublist, in_stublist))\n    return G",
            "def _configuration_model(deg_sequence, create_using, directed=False, in_deg_sequence=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Helper function for generating either undirected or directed\\n    configuration model graphs.\\n\\n    ``deg_sequence`` is a list of nonnegative integers representing the\\n    degree of the node whose label is the index of the list element.\\n\\n    ``create_using`` see :func:`~networkx.empty_graph`.\\n\\n    ``directed`` and ``in_deg_sequence`` are required if you want the\\n    returned graph to be generated using the directed configuration\\n    model algorithm. If ``directed`` is ``False``, then ``deg_sequence``\\n    is interpreted as the degree sequence of an undirected graph and\\n    ``in_deg_sequence`` is ignored. Otherwise, if ``directed`` is\\n    ``True``, then ``deg_sequence`` is interpreted as the out-degree\\n    sequence and ``in_deg_sequence`` as the in-degree sequence of a\\n    directed graph.\\n\\n    .. note::\\n\\n       ``deg_sequence`` and ``in_deg_sequence`` need not be the same\\n       length.\\n\\n    ``seed`` is a random.Random or numpy.random.RandomState instance\\n\\n    This function returns a graph, directed if and only if ``directed``\\n    is ``True``, generated according to the configuration model\\n    algorithm. For more information on the algorithm, see the\\n    :func:`configuration_model` or :func:`directed_configuration_model`\\n    functions.\\n\\n    '\n    n = len(deg_sequence)\n    G = nx.empty_graph(n, create_using)\n    if n == 0:\n        return G\n    if directed:\n        pairs = zip_longest(deg_sequence, in_deg_sequence, fillvalue=0)\n        (out_deg, in_deg) = zip(*pairs)\n        out_stublist = _to_stublist(out_deg)\n        in_stublist = _to_stublist(in_deg)\n        seed.shuffle(out_stublist)\n        seed.shuffle(in_stublist)\n    else:\n        stublist = _to_stublist(deg_sequence)\n        n = len(stublist)\n        half = n // 2\n        seed.shuffle(stublist)\n        (out_stublist, in_stublist) = (stublist[:half], stublist[half:])\n    G.add_edges_from(zip(out_stublist, in_stublist))\n    return G",
            "def _configuration_model(deg_sequence, create_using, directed=False, in_deg_sequence=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Helper function for generating either undirected or directed\\n    configuration model graphs.\\n\\n    ``deg_sequence`` is a list of nonnegative integers representing the\\n    degree of the node whose label is the index of the list element.\\n\\n    ``create_using`` see :func:`~networkx.empty_graph`.\\n\\n    ``directed`` and ``in_deg_sequence`` are required if you want the\\n    returned graph to be generated using the directed configuration\\n    model algorithm. If ``directed`` is ``False``, then ``deg_sequence``\\n    is interpreted as the degree sequence of an undirected graph and\\n    ``in_deg_sequence`` is ignored. Otherwise, if ``directed`` is\\n    ``True``, then ``deg_sequence`` is interpreted as the out-degree\\n    sequence and ``in_deg_sequence`` as the in-degree sequence of a\\n    directed graph.\\n\\n    .. note::\\n\\n       ``deg_sequence`` and ``in_deg_sequence`` need not be the same\\n       length.\\n\\n    ``seed`` is a random.Random or numpy.random.RandomState instance\\n\\n    This function returns a graph, directed if and only if ``directed``\\n    is ``True``, generated according to the configuration model\\n    algorithm. For more information on the algorithm, see the\\n    :func:`configuration_model` or :func:`directed_configuration_model`\\n    functions.\\n\\n    '\n    n = len(deg_sequence)\n    G = nx.empty_graph(n, create_using)\n    if n == 0:\n        return G\n    if directed:\n        pairs = zip_longest(deg_sequence, in_deg_sequence, fillvalue=0)\n        (out_deg, in_deg) = zip(*pairs)\n        out_stublist = _to_stublist(out_deg)\n        in_stublist = _to_stublist(in_deg)\n        seed.shuffle(out_stublist)\n        seed.shuffle(in_stublist)\n    else:\n        stublist = _to_stublist(deg_sequence)\n        n = len(stublist)\n        half = n // 2\n        seed.shuffle(stublist)\n        (out_stublist, in_stublist) = (stublist[:half], stublist[half:])\n    G.add_edges_from(zip(out_stublist, in_stublist))\n    return G",
            "def _configuration_model(deg_sequence, create_using, directed=False, in_deg_sequence=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Helper function for generating either undirected or directed\\n    configuration model graphs.\\n\\n    ``deg_sequence`` is a list of nonnegative integers representing the\\n    degree of the node whose label is the index of the list element.\\n\\n    ``create_using`` see :func:`~networkx.empty_graph`.\\n\\n    ``directed`` and ``in_deg_sequence`` are required if you want the\\n    returned graph to be generated using the directed configuration\\n    model algorithm. If ``directed`` is ``False``, then ``deg_sequence``\\n    is interpreted as the degree sequence of an undirected graph and\\n    ``in_deg_sequence`` is ignored. Otherwise, if ``directed`` is\\n    ``True``, then ``deg_sequence`` is interpreted as the out-degree\\n    sequence and ``in_deg_sequence`` as the in-degree sequence of a\\n    directed graph.\\n\\n    .. note::\\n\\n       ``deg_sequence`` and ``in_deg_sequence`` need not be the same\\n       length.\\n\\n    ``seed`` is a random.Random or numpy.random.RandomState instance\\n\\n    This function returns a graph, directed if and only if ``directed``\\n    is ``True``, generated according to the configuration model\\n    algorithm. For more information on the algorithm, see the\\n    :func:`configuration_model` or :func:`directed_configuration_model`\\n    functions.\\n\\n    '\n    n = len(deg_sequence)\n    G = nx.empty_graph(n, create_using)\n    if n == 0:\n        return G\n    if directed:\n        pairs = zip_longest(deg_sequence, in_deg_sequence, fillvalue=0)\n        (out_deg, in_deg) = zip(*pairs)\n        out_stublist = _to_stublist(out_deg)\n        in_stublist = _to_stublist(in_deg)\n        seed.shuffle(out_stublist)\n        seed.shuffle(in_stublist)\n    else:\n        stublist = _to_stublist(deg_sequence)\n        n = len(stublist)\n        half = n // 2\n        seed.shuffle(stublist)\n        (out_stublist, in_stublist) = (stublist[:half], stublist[half:])\n    G.add_edges_from(zip(out_stublist, in_stublist))\n    return G",
            "def _configuration_model(deg_sequence, create_using, directed=False, in_deg_sequence=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Helper function for generating either undirected or directed\\n    configuration model graphs.\\n\\n    ``deg_sequence`` is a list of nonnegative integers representing the\\n    degree of the node whose label is the index of the list element.\\n\\n    ``create_using`` see :func:`~networkx.empty_graph`.\\n\\n    ``directed`` and ``in_deg_sequence`` are required if you want the\\n    returned graph to be generated using the directed configuration\\n    model algorithm. If ``directed`` is ``False``, then ``deg_sequence``\\n    is interpreted as the degree sequence of an undirected graph and\\n    ``in_deg_sequence`` is ignored. Otherwise, if ``directed`` is\\n    ``True``, then ``deg_sequence`` is interpreted as the out-degree\\n    sequence and ``in_deg_sequence`` as the in-degree sequence of a\\n    directed graph.\\n\\n    .. note::\\n\\n       ``deg_sequence`` and ``in_deg_sequence`` need not be the same\\n       length.\\n\\n    ``seed`` is a random.Random or numpy.random.RandomState instance\\n\\n    This function returns a graph, directed if and only if ``directed``\\n    is ``True``, generated according to the configuration model\\n    algorithm. For more information on the algorithm, see the\\n    :func:`configuration_model` or :func:`directed_configuration_model`\\n    functions.\\n\\n    '\n    n = len(deg_sequence)\n    G = nx.empty_graph(n, create_using)\n    if n == 0:\n        return G\n    if directed:\n        pairs = zip_longest(deg_sequence, in_deg_sequence, fillvalue=0)\n        (out_deg, in_deg) = zip(*pairs)\n        out_stublist = _to_stublist(out_deg)\n        in_stublist = _to_stublist(in_deg)\n        seed.shuffle(out_stublist)\n        seed.shuffle(in_stublist)\n    else:\n        stublist = _to_stublist(deg_sequence)\n        n = len(stublist)\n        half = n // 2\n        seed.shuffle(stublist)\n        (out_stublist, in_stublist) = (stublist[:half], stublist[half:])\n    G.add_edges_from(zip(out_stublist, in_stublist))\n    return G"
        ]
    },
    {
        "func_name": "configuration_model",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef configuration_model(deg_sequence, create_using=None, seed=None):\n    \"\"\"Returns a random graph with the given degree sequence.\n\n    The configuration model generates a random pseudograph (graph with\n    parallel edges and self loops) by randomly assigning edges to\n    match the given degree sequence.\n\n    Parameters\n    ----------\n    deg_sequence :  list of nonnegative integers\n        Each list entry corresponds to the degree of a node.\n    create_using : NetworkX graph constructor, optional (default MultiGraph)\n        Graph type to create. If graph instance, then cleared before populated.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : MultiGraph\n        A graph with the specified degree sequence.\n        Nodes are labeled starting at 0 with an index\n        corresponding to the position in deg_sequence.\n\n    Raises\n    ------\n    NetworkXError\n        If the degree sequence does not have an even sum.\n\n    See Also\n    --------\n    is_graphical\n\n    Notes\n    -----\n    As described by Newman [1]_.\n\n    A non-graphical degree sequence (not realizable by some simple\n    graph) is allowed since this function returns graphs with self\n    loops and parallel edges.  An exception is raised if the degree\n    sequence does not have an even sum.\n\n    This configuration model construction process can lead to\n    duplicate edges and loops.  You can remove the self-loops and\n    parallel edges (see below) which will likely result in a graph\n    that doesn't have the exact degree sequence specified.\n\n    The density of self-loops and parallel edges tends to decrease as\n    the number of nodes increases. However, typically the number of\n    self-loops will approach a Poisson distribution with a nonzero mean,\n    and similarly for the number of parallel edges.  Consider a node\n    with *k* stubs. The probability of being joined to another stub of\n    the same node is basically (*k* - *1*) / *N*, where *k* is the\n    degree and *N* is the number of nodes. So the probability of a\n    self-loop scales like *c* / *N* for some constant *c*. As *N* grows,\n    this means we expect *c* self-loops. Similarly for parallel edges.\n\n    References\n    ----------\n    .. [1] M.E.J. Newman, \"The structure and function of complex networks\",\n       SIAM REVIEW 45-2, pp 167-256, 2003.\n\n    Examples\n    --------\n    You can create a degree sequence following a particular distribution\n    by using the one of the distribution functions in\n    :mod:`~networkx.utils.random_sequence` (or one of your own). For\n    example, to create an undirected multigraph on one hundred nodes\n    with degree sequence chosen from the power law distribution:\n\n    >>> sequence = nx.random_powerlaw_tree_sequence(100, tries=5000)\n    >>> G = nx.configuration_model(sequence)\n    >>> len(G)\n    100\n    >>> actual_degrees = [d for v, d in G.degree()]\n    >>> actual_degrees == sequence\n    True\n\n    The returned graph is a multigraph, which may have parallel\n    edges. To remove any parallel edges from the returned graph:\n\n    >>> G = nx.Graph(G)\n\n    Similarly, to remove self-loops:\n\n    >>> G.remove_edges_from(nx.selfloop_edges(G))\n\n    \"\"\"\n    if sum(deg_sequence) % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed():\n        raise nx.NetworkXNotImplemented('not implemented for directed graphs')\n    G = _configuration_model(deg_sequence, G, seed=seed)\n    return G",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef configuration_model(deg_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n    'Returns a random graph with the given degree sequence.\\n\\n    The configuration model generates a random pseudograph (graph with\\n    parallel edges and self loops) by randomly assigning edges to\\n    match the given degree sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence :  list of nonnegative integers\\n        Each list entry corresponds to the degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiGraph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequence does not have an even sum.\\n\\n    See Also\\n    --------\\n    is_graphical\\n\\n    Notes\\n    -----\\n    As described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequence does not have an even sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.\\n\\n    The density of self-loops and parallel edges tends to decrease as\\n    the number of nodes increases. However, typically the number of\\n    self-loops will approach a Poisson distribution with a nonzero mean,\\n    and similarly for the number of parallel edges.  Consider a node\\n    with *k* stubs. The probability of being joined to another stub of\\n    the same node is basically (*k* - *1*) / *N*, where *k* is the\\n    degree and *N* is the number of nodes. So the probability of a\\n    self-loop scales like *c* / *N* for some constant *c*. As *N* grows,\\n    this means we expect *c* self-loops. Similarly for parallel edges.\\n\\n    References\\n    ----------\\n    .. [1] M.E.J. Newman, \"The structure and function of complex networks\",\\n       SIAM REVIEW 45-2, pp 167-256, 2003.\\n\\n    Examples\\n    --------\\n    You can create a degree sequence following a particular distribution\\n    by using the one of the distribution functions in\\n    :mod:`~networkx.utils.random_sequence` (or one of your own). For\\n    example, to create an undirected multigraph on one hundred nodes\\n    with degree sequence chosen from the power law distribution:\\n\\n    >>> sequence = nx.random_powerlaw_tree_sequence(100, tries=5000)\\n    >>> G = nx.configuration_model(sequence)\\n    >>> len(G)\\n    100\\n    >>> actual_degrees = [d for v, d in G.degree()]\\n    >>> actual_degrees == sequence\\n    True\\n\\n    The returned graph is a multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> G = nx.Graph(G)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> G.remove_edges_from(nx.selfloop_edges(G))\\n\\n    '\n    if sum(deg_sequence) % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed():\n        raise nx.NetworkXNotImplemented('not implemented for directed graphs')\n    G = _configuration_model(deg_sequence, G, seed=seed)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef configuration_model(deg_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a random graph with the given degree sequence.\\n\\n    The configuration model generates a random pseudograph (graph with\\n    parallel edges and self loops) by randomly assigning edges to\\n    match the given degree sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence :  list of nonnegative integers\\n        Each list entry corresponds to the degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiGraph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequence does not have an even sum.\\n\\n    See Also\\n    --------\\n    is_graphical\\n\\n    Notes\\n    -----\\n    As described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequence does not have an even sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.\\n\\n    The density of self-loops and parallel edges tends to decrease as\\n    the number of nodes increases. However, typically the number of\\n    self-loops will approach a Poisson distribution with a nonzero mean,\\n    and similarly for the number of parallel edges.  Consider a node\\n    with *k* stubs. The probability of being joined to another stub of\\n    the same node is basically (*k* - *1*) / *N*, where *k* is the\\n    degree and *N* is the number of nodes. So the probability of a\\n    self-loop scales like *c* / *N* for some constant *c*. As *N* grows,\\n    this means we expect *c* self-loops. Similarly for parallel edges.\\n\\n    References\\n    ----------\\n    .. [1] M.E.J. Newman, \"The structure and function of complex networks\",\\n       SIAM REVIEW 45-2, pp 167-256, 2003.\\n\\n    Examples\\n    --------\\n    You can create a degree sequence following a particular distribution\\n    by using the one of the distribution functions in\\n    :mod:`~networkx.utils.random_sequence` (or one of your own). For\\n    example, to create an undirected multigraph on one hundred nodes\\n    with degree sequence chosen from the power law distribution:\\n\\n    >>> sequence = nx.random_powerlaw_tree_sequence(100, tries=5000)\\n    >>> G = nx.configuration_model(sequence)\\n    >>> len(G)\\n    100\\n    >>> actual_degrees = [d for v, d in G.degree()]\\n    >>> actual_degrees == sequence\\n    True\\n\\n    The returned graph is a multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> G = nx.Graph(G)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> G.remove_edges_from(nx.selfloop_edges(G))\\n\\n    '\n    if sum(deg_sequence) % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed():\n        raise nx.NetworkXNotImplemented('not implemented for directed graphs')\n    G = _configuration_model(deg_sequence, G, seed=seed)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef configuration_model(deg_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a random graph with the given degree sequence.\\n\\n    The configuration model generates a random pseudograph (graph with\\n    parallel edges and self loops) by randomly assigning edges to\\n    match the given degree sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence :  list of nonnegative integers\\n        Each list entry corresponds to the degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiGraph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequence does not have an even sum.\\n\\n    See Also\\n    --------\\n    is_graphical\\n\\n    Notes\\n    -----\\n    As described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequence does not have an even sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.\\n\\n    The density of self-loops and parallel edges tends to decrease as\\n    the number of nodes increases. However, typically the number of\\n    self-loops will approach a Poisson distribution with a nonzero mean,\\n    and similarly for the number of parallel edges.  Consider a node\\n    with *k* stubs. The probability of being joined to another stub of\\n    the same node is basically (*k* - *1*) / *N*, where *k* is the\\n    degree and *N* is the number of nodes. So the probability of a\\n    self-loop scales like *c* / *N* for some constant *c*. As *N* grows,\\n    this means we expect *c* self-loops. Similarly for parallel edges.\\n\\n    References\\n    ----------\\n    .. [1] M.E.J. Newman, \"The structure and function of complex networks\",\\n       SIAM REVIEW 45-2, pp 167-256, 2003.\\n\\n    Examples\\n    --------\\n    You can create a degree sequence following a particular distribution\\n    by using the one of the distribution functions in\\n    :mod:`~networkx.utils.random_sequence` (or one of your own). For\\n    example, to create an undirected multigraph on one hundred nodes\\n    with degree sequence chosen from the power law distribution:\\n\\n    >>> sequence = nx.random_powerlaw_tree_sequence(100, tries=5000)\\n    >>> G = nx.configuration_model(sequence)\\n    >>> len(G)\\n    100\\n    >>> actual_degrees = [d for v, d in G.degree()]\\n    >>> actual_degrees == sequence\\n    True\\n\\n    The returned graph is a multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> G = nx.Graph(G)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> G.remove_edges_from(nx.selfloop_edges(G))\\n\\n    '\n    if sum(deg_sequence) % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed():\n        raise nx.NetworkXNotImplemented('not implemented for directed graphs')\n    G = _configuration_model(deg_sequence, G, seed=seed)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef configuration_model(deg_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a random graph with the given degree sequence.\\n\\n    The configuration model generates a random pseudograph (graph with\\n    parallel edges and self loops) by randomly assigning edges to\\n    match the given degree sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence :  list of nonnegative integers\\n        Each list entry corresponds to the degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiGraph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequence does not have an even sum.\\n\\n    See Also\\n    --------\\n    is_graphical\\n\\n    Notes\\n    -----\\n    As described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequence does not have an even sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.\\n\\n    The density of self-loops and parallel edges tends to decrease as\\n    the number of nodes increases. However, typically the number of\\n    self-loops will approach a Poisson distribution with a nonzero mean,\\n    and similarly for the number of parallel edges.  Consider a node\\n    with *k* stubs. The probability of being joined to another stub of\\n    the same node is basically (*k* - *1*) / *N*, where *k* is the\\n    degree and *N* is the number of nodes. So the probability of a\\n    self-loop scales like *c* / *N* for some constant *c*. As *N* grows,\\n    this means we expect *c* self-loops. Similarly for parallel edges.\\n\\n    References\\n    ----------\\n    .. [1] M.E.J. Newman, \"The structure and function of complex networks\",\\n       SIAM REVIEW 45-2, pp 167-256, 2003.\\n\\n    Examples\\n    --------\\n    You can create a degree sequence following a particular distribution\\n    by using the one of the distribution functions in\\n    :mod:`~networkx.utils.random_sequence` (or one of your own). For\\n    example, to create an undirected multigraph on one hundred nodes\\n    with degree sequence chosen from the power law distribution:\\n\\n    >>> sequence = nx.random_powerlaw_tree_sequence(100, tries=5000)\\n    >>> G = nx.configuration_model(sequence)\\n    >>> len(G)\\n    100\\n    >>> actual_degrees = [d for v, d in G.degree()]\\n    >>> actual_degrees == sequence\\n    True\\n\\n    The returned graph is a multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> G = nx.Graph(G)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> G.remove_edges_from(nx.selfloop_edges(G))\\n\\n    '\n    if sum(deg_sequence) % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed():\n        raise nx.NetworkXNotImplemented('not implemented for directed graphs')\n    G = _configuration_model(deg_sequence, G, seed=seed)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef configuration_model(deg_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a random graph with the given degree sequence.\\n\\n    The configuration model generates a random pseudograph (graph with\\n    parallel edges and self loops) by randomly assigning edges to\\n    match the given degree sequence.\\n\\n    Parameters\\n    ----------\\n    deg_sequence :  list of nonnegative integers\\n        Each list entry corresponds to the degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiGraph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequence does not have an even sum.\\n\\n    See Also\\n    --------\\n    is_graphical\\n\\n    Notes\\n    -----\\n    As described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequence does not have an even sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.\\n\\n    The density of self-loops and parallel edges tends to decrease as\\n    the number of nodes increases. However, typically the number of\\n    self-loops will approach a Poisson distribution with a nonzero mean,\\n    and similarly for the number of parallel edges.  Consider a node\\n    with *k* stubs. The probability of being joined to another stub of\\n    the same node is basically (*k* - *1*) / *N*, where *k* is the\\n    degree and *N* is the number of nodes. So the probability of a\\n    self-loop scales like *c* / *N* for some constant *c*. As *N* grows,\\n    this means we expect *c* self-loops. Similarly for parallel edges.\\n\\n    References\\n    ----------\\n    .. [1] M.E.J. Newman, \"The structure and function of complex networks\",\\n       SIAM REVIEW 45-2, pp 167-256, 2003.\\n\\n    Examples\\n    --------\\n    You can create a degree sequence following a particular distribution\\n    by using the one of the distribution functions in\\n    :mod:`~networkx.utils.random_sequence` (or one of your own). For\\n    example, to create an undirected multigraph on one hundred nodes\\n    with degree sequence chosen from the power law distribution:\\n\\n    >>> sequence = nx.random_powerlaw_tree_sequence(100, tries=5000)\\n    >>> G = nx.configuration_model(sequence)\\n    >>> len(G)\\n    100\\n    >>> actual_degrees = [d for v, d in G.degree()]\\n    >>> actual_degrees == sequence\\n    True\\n\\n    The returned graph is a multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> G = nx.Graph(G)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> G.remove_edges_from(nx.selfloop_edges(G))\\n\\n    '\n    if sum(deg_sequence) % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed():\n        raise nx.NetworkXNotImplemented('not implemented for directed graphs')\n    G = _configuration_model(deg_sequence, G, seed=seed)\n    return G"
        ]
    },
    {
        "func_name": "directed_configuration_model",
        "original": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef directed_configuration_model(in_degree_sequence, out_degree_sequence, create_using=None, seed=None):\n    \"\"\"Returns a directed_random graph with the given degree sequences.\n\n    The configuration model generates a random directed pseudograph\n    (graph with parallel edges and self loops) by randomly assigning\n    edges to match the given degree sequences.\n\n    Parameters\n    ----------\n    in_degree_sequence :  list of nonnegative integers\n       Each list entry corresponds to the in-degree of a node.\n    out_degree_sequence :  list of nonnegative integers\n       Each list entry corresponds to the out-degree of a node.\n    create_using : NetworkX graph constructor, optional (default MultiDiGraph)\n        Graph type to create. If graph instance, then cleared before populated.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : MultiDiGraph\n        A graph with the specified degree sequences.\n        Nodes are labeled starting at 0 with an index\n        corresponding to the position in deg_sequence.\n\n    Raises\n    ------\n    NetworkXError\n        If the degree sequences do not have the same sum.\n\n    See Also\n    --------\n    configuration_model\n\n    Notes\n    -----\n    Algorithm as described by Newman [1]_.\n\n    A non-graphical degree sequence (not realizable by some simple\n    graph) is allowed since this function returns graphs with self\n    loops and parallel edges.  An exception is raised if the degree\n    sequences does not have the same sum.\n\n    This configuration model construction process can lead to\n    duplicate edges and loops.  You can remove the self-loops and\n    parallel edges (see below) which will likely result in a graph\n    that doesn't have the exact degree sequence specified.  This\n    \"finite-size effect\" decreases as the size of the graph increases.\n\n    References\n    ----------\n    .. [1] Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\n       Random graphs with arbitrary degree distributions and their applications\n       Phys. Rev. E, 64, 026118 (2001)\n\n    Examples\n    --------\n    One can modify the in- and out-degree sequences from an existing\n    directed graph in order to create a new directed graph. For example,\n    here we modify the directed path graph:\n\n    >>> D = nx.DiGraph([(0, 1), (1, 2), (2, 3)])\n    >>> din = list(d for n, d in D.in_degree())\n    >>> dout = list(d for n, d in D.out_degree())\n    >>> din.append(1)\n    >>> dout[0] = 2\n    >>> # We now expect an edge from node 0 to a new node, node 3.\n    ... D = nx.directed_configuration_model(din, dout)\n\n    The returned graph is a directed multigraph, which may have parallel\n    edges. To remove any parallel edges from the returned graph:\n\n    >>> D = nx.DiGraph(D)\n\n    Similarly, to remove self-loops:\n\n    >>> D.remove_edges_from(nx.selfloop_edges(D))\n\n    \"\"\"\n    if sum(in_degree_sequence) != sum(out_degree_sequence):\n        msg = 'Invalid degree sequences: sequences must have equal sums'\n        raise nx.NetworkXError(msg)\n    if create_using is None:\n        create_using = nx.MultiDiGraph\n    G = _configuration_model(out_degree_sequence, create_using, directed=True, in_deg_sequence=in_degree_sequence, seed=seed)\n    name = 'directed configuration_model {} nodes {} edges'\n    return G",
        "mutated": [
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef directed_configuration_model(in_degree_sequence, out_degree_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n    'Returns a directed_random graph with the given degree sequences.\\n\\n    The configuration model generates a random directed pseudograph\\n    (graph with parallel edges and self loops) by randomly assigning\\n    edges to match the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the in-degree of a node.\\n    out_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiDiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiDiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences do not have the same sum.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequences does not have the same sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.  This\\n    \"finite-size effect\" decreases as the size of the graph increases.\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\\n       Random graphs with arbitrary degree distributions and their applications\\n       Phys. Rev. E, 64, 026118 (2001)\\n\\n    Examples\\n    --------\\n    One can modify the in- and out-degree sequences from an existing\\n    directed graph in order to create a new directed graph. For example,\\n    here we modify the directed path graph:\\n\\n    >>> D = nx.DiGraph([(0, 1), (1, 2), (2, 3)])\\n    >>> din = list(d for n, d in D.in_degree())\\n    >>> dout = list(d for n, d in D.out_degree())\\n    >>> din.append(1)\\n    >>> dout[0] = 2\\n    >>> # We now expect an edge from node 0 to a new node, node 3.\\n    ... D = nx.directed_configuration_model(din, dout)\\n\\n    The returned graph is a directed multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> D = nx.DiGraph(D)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> D.remove_edges_from(nx.selfloop_edges(D))\\n\\n    '\n    if sum(in_degree_sequence) != sum(out_degree_sequence):\n        msg = 'Invalid degree sequences: sequences must have equal sums'\n        raise nx.NetworkXError(msg)\n    if create_using is None:\n        create_using = nx.MultiDiGraph\n    G = _configuration_model(out_degree_sequence, create_using, directed=True, in_deg_sequence=in_degree_sequence, seed=seed)\n    name = 'directed configuration_model {} nodes {} edges'\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef directed_configuration_model(in_degree_sequence, out_degree_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a directed_random graph with the given degree sequences.\\n\\n    The configuration model generates a random directed pseudograph\\n    (graph with parallel edges and self loops) by randomly assigning\\n    edges to match the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the in-degree of a node.\\n    out_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiDiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiDiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences do not have the same sum.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequences does not have the same sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.  This\\n    \"finite-size effect\" decreases as the size of the graph increases.\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\\n       Random graphs with arbitrary degree distributions and their applications\\n       Phys. Rev. E, 64, 026118 (2001)\\n\\n    Examples\\n    --------\\n    One can modify the in- and out-degree sequences from an existing\\n    directed graph in order to create a new directed graph. For example,\\n    here we modify the directed path graph:\\n\\n    >>> D = nx.DiGraph([(0, 1), (1, 2), (2, 3)])\\n    >>> din = list(d for n, d in D.in_degree())\\n    >>> dout = list(d for n, d in D.out_degree())\\n    >>> din.append(1)\\n    >>> dout[0] = 2\\n    >>> # We now expect an edge from node 0 to a new node, node 3.\\n    ... D = nx.directed_configuration_model(din, dout)\\n\\n    The returned graph is a directed multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> D = nx.DiGraph(D)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> D.remove_edges_from(nx.selfloop_edges(D))\\n\\n    '\n    if sum(in_degree_sequence) != sum(out_degree_sequence):\n        msg = 'Invalid degree sequences: sequences must have equal sums'\n        raise nx.NetworkXError(msg)\n    if create_using is None:\n        create_using = nx.MultiDiGraph\n    G = _configuration_model(out_degree_sequence, create_using, directed=True, in_deg_sequence=in_degree_sequence, seed=seed)\n    name = 'directed configuration_model {} nodes {} edges'\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef directed_configuration_model(in_degree_sequence, out_degree_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a directed_random graph with the given degree sequences.\\n\\n    The configuration model generates a random directed pseudograph\\n    (graph with parallel edges and self loops) by randomly assigning\\n    edges to match the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the in-degree of a node.\\n    out_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiDiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiDiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences do not have the same sum.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequences does not have the same sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.  This\\n    \"finite-size effect\" decreases as the size of the graph increases.\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\\n       Random graphs with arbitrary degree distributions and their applications\\n       Phys. Rev. E, 64, 026118 (2001)\\n\\n    Examples\\n    --------\\n    One can modify the in- and out-degree sequences from an existing\\n    directed graph in order to create a new directed graph. For example,\\n    here we modify the directed path graph:\\n\\n    >>> D = nx.DiGraph([(0, 1), (1, 2), (2, 3)])\\n    >>> din = list(d for n, d in D.in_degree())\\n    >>> dout = list(d for n, d in D.out_degree())\\n    >>> din.append(1)\\n    >>> dout[0] = 2\\n    >>> # We now expect an edge from node 0 to a new node, node 3.\\n    ... D = nx.directed_configuration_model(din, dout)\\n\\n    The returned graph is a directed multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> D = nx.DiGraph(D)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> D.remove_edges_from(nx.selfloop_edges(D))\\n\\n    '\n    if sum(in_degree_sequence) != sum(out_degree_sequence):\n        msg = 'Invalid degree sequences: sequences must have equal sums'\n        raise nx.NetworkXError(msg)\n    if create_using is None:\n        create_using = nx.MultiDiGraph\n    G = _configuration_model(out_degree_sequence, create_using, directed=True, in_deg_sequence=in_degree_sequence, seed=seed)\n    name = 'directed configuration_model {} nodes {} edges'\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef directed_configuration_model(in_degree_sequence, out_degree_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a directed_random graph with the given degree sequences.\\n\\n    The configuration model generates a random directed pseudograph\\n    (graph with parallel edges and self loops) by randomly assigning\\n    edges to match the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the in-degree of a node.\\n    out_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiDiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiDiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences do not have the same sum.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequences does not have the same sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.  This\\n    \"finite-size effect\" decreases as the size of the graph increases.\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\\n       Random graphs with arbitrary degree distributions and their applications\\n       Phys. Rev. E, 64, 026118 (2001)\\n\\n    Examples\\n    --------\\n    One can modify the in- and out-degree sequences from an existing\\n    directed graph in order to create a new directed graph. For example,\\n    here we modify the directed path graph:\\n\\n    >>> D = nx.DiGraph([(0, 1), (1, 2), (2, 3)])\\n    >>> din = list(d for n, d in D.in_degree())\\n    >>> dout = list(d for n, d in D.out_degree())\\n    >>> din.append(1)\\n    >>> dout[0] = 2\\n    >>> # We now expect an edge from node 0 to a new node, node 3.\\n    ... D = nx.directed_configuration_model(din, dout)\\n\\n    The returned graph is a directed multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> D = nx.DiGraph(D)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> D.remove_edges_from(nx.selfloop_edges(D))\\n\\n    '\n    if sum(in_degree_sequence) != sum(out_degree_sequence):\n        msg = 'Invalid degree sequences: sequences must have equal sums'\n        raise nx.NetworkXError(msg)\n    if create_using is None:\n        create_using = nx.MultiDiGraph\n    G = _configuration_model(out_degree_sequence, create_using, directed=True, in_deg_sequence=in_degree_sequence, seed=seed)\n    name = 'directed configuration_model {} nodes {} edges'\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef directed_configuration_model(in_degree_sequence, out_degree_sequence, create_using=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a directed_random graph with the given degree sequences.\\n\\n    The configuration model generates a random directed pseudograph\\n    (graph with parallel edges and self loops) by randomly assigning\\n    edges to match the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the in-degree of a node.\\n    out_degree_sequence :  list of nonnegative integers\\n       Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default MultiDiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : MultiDiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences do not have the same sum.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Newman [1]_.\\n\\n    A non-graphical degree sequence (not realizable by some simple\\n    graph) is allowed since this function returns graphs with self\\n    loops and parallel edges.  An exception is raised if the degree\\n    sequences does not have the same sum.\\n\\n    This configuration model construction process can lead to\\n    duplicate edges and loops.  You can remove the self-loops and\\n    parallel edges (see below) which will likely result in a graph\\n    that doesn\\'t have the exact degree sequence specified.  This\\n    \"finite-size effect\" decreases as the size of the graph increases.\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\\n       Random graphs with arbitrary degree distributions and their applications\\n       Phys. Rev. E, 64, 026118 (2001)\\n\\n    Examples\\n    --------\\n    One can modify the in- and out-degree sequences from an existing\\n    directed graph in order to create a new directed graph. For example,\\n    here we modify the directed path graph:\\n\\n    >>> D = nx.DiGraph([(0, 1), (1, 2), (2, 3)])\\n    >>> din = list(d for n, d in D.in_degree())\\n    >>> dout = list(d for n, d in D.out_degree())\\n    >>> din.append(1)\\n    >>> dout[0] = 2\\n    >>> # We now expect an edge from node 0 to a new node, node 3.\\n    ... D = nx.directed_configuration_model(din, dout)\\n\\n    The returned graph is a directed multigraph, which may have parallel\\n    edges. To remove any parallel edges from the returned graph:\\n\\n    >>> D = nx.DiGraph(D)\\n\\n    Similarly, to remove self-loops:\\n\\n    >>> D.remove_edges_from(nx.selfloop_edges(D))\\n\\n    '\n    if sum(in_degree_sequence) != sum(out_degree_sequence):\n        msg = 'Invalid degree sequences: sequences must have equal sums'\n        raise nx.NetworkXError(msg)\n    if create_using is None:\n        create_using = nx.MultiDiGraph\n    G = _configuration_model(out_degree_sequence, create_using, directed=True, in_deg_sequence=in_degree_sequence, seed=seed)\n    name = 'directed configuration_model {} nodes {} edges'\n    return G"
        ]
    },
    {
        "func_name": "expected_degree_graph",
        "original": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef expected_degree_graph(w, seed=None, selfloops=True):\n    \"\"\"Returns a random graph with given expected degrees.\n\n    Given a sequence of expected degrees $W=(w_0,w_1,\\\\ldots,w_{n-1})$\n    of length $n$ this algorithm assigns an edge between node $u$ and\n    node $v$ with probability\n\n    .. math::\n\n       p_{uv} = \\\\frac{w_u w_v}{\\\\sum_k w_k} .\n\n    Parameters\n    ----------\n    w : list\n        The list of expected degrees.\n    selfloops: bool (default=True)\n        Set to False to remove the possibility of self-loop edges.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    Graph\n\n    Examples\n    --------\n    >>> z = [10 for i in range(100)]\n    >>> G = nx.expected_degree_graph(z)\n\n    Notes\n    -----\n    The nodes have integer labels corresponding to index of expected degrees\n    input sequence.\n\n    The complexity of this algorithm is $\\\\mathcal{O}(n+m)$ where $n$ is the\n    number of nodes and $m$ is the expected number of edges.\n\n    The model in [1]_ includes the possibility of self-loop edges.\n    Set selfloops=False to produce a graph without self loops.\n\n    For finite graphs this model doesn't produce exactly the given\n    expected degree sequence.  Instead the expected degrees are as\n    follows.\n\n    For the case without self loops (selfloops=False),\n\n    .. math::\n\n       E[deg(u)] = \\\\sum_{v \\\\ne u} p_{uv}\n                = w_u \\\\left( 1 - \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\n\n\n    NetworkX uses the standard convention that a self-loop edge counts 2\n    in the degree of a node, so with self loops (selfloops=True),\n\n    .. math::\n\n       E[deg(u)] =  \\\\sum_{v \\\\ne u} p_{uv}  + 2 p_{uu}\n                = w_u \\\\left( 1 + \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\n\n    References\n    ----------\n    .. [1] Fan Chung and L. Lu, Connected components in random graphs with\n       given expected degree sequences, Ann. Combinatorics, 6,\n       pp. 125-145, 2002.\n    .. [2] Joel Miller and Aric Hagberg,\n       Efficient generation of networks with given expected degrees,\n       in Algorithms and Models for the Web-Graph (WAW 2011),\n       Alan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\n       pp. 115-126, 2011.\n    \"\"\"\n    n = len(w)\n    G = nx.empty_graph(n)\n    if n == 0 or max(w) == 0:\n        return G\n    rho = 1 / sum(w)\n    order = sorted(enumerate(w), key=itemgetter(1), reverse=True)\n    mapping = {c: u for (c, (u, v)) in enumerate(order)}\n    seq = [v for (u, v) in order]\n    last = n\n    if not selfloops:\n        last -= 1\n    for u in range(last):\n        v = u\n        if not selfloops:\n            v += 1\n        factor = seq[u] * rho\n        p = min(seq[v] * factor, 1)\n        while v < n and p > 0:\n            if p != 1:\n                r = seed.random()\n                v += math.floor(math.log(r, 1 - p))\n            if v < n:\n                q = min(seq[v] * factor, 1)\n                if seed.random() < q / p:\n                    G.add_edge(mapping[u], mapping[v])\n                v += 1\n                p = q\n    return G",
        "mutated": [
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef expected_degree_graph(w, seed=None, selfloops=True):\n    if False:\n        i = 10\n    \"Returns a random graph with given expected degrees.\\n\\n    Given a sequence of expected degrees $W=(w_0,w_1,\\\\ldots,w_{n-1})$\\n    of length $n$ this algorithm assigns an edge between node $u$ and\\n    node $v$ with probability\\n\\n    .. math::\\n\\n       p_{uv} = \\\\frac{w_u w_v}{\\\\sum_k w_k} .\\n\\n    Parameters\\n    ----------\\n    w : list\\n        The list of expected degrees.\\n    selfloops: bool (default=True)\\n        Set to False to remove the possibility of self-loop edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    Graph\\n\\n    Examples\\n    --------\\n    >>> z = [10 for i in range(100)]\\n    >>> G = nx.expected_degree_graph(z)\\n\\n    Notes\\n    -----\\n    The nodes have integer labels corresponding to index of expected degrees\\n    input sequence.\\n\\n    The complexity of this algorithm is $\\\\mathcal{O}(n+m)$ where $n$ is the\\n    number of nodes and $m$ is the expected number of edges.\\n\\n    The model in [1]_ includes the possibility of self-loop edges.\\n    Set selfloops=False to produce a graph without self loops.\\n\\n    For finite graphs this model doesn't produce exactly the given\\n    expected degree sequence.  Instead the expected degrees are as\\n    follows.\\n\\n    For the case without self loops (selfloops=False),\\n\\n    .. math::\\n\\n       E[deg(u)] = \\\\sum_{v \\\\ne u} p_{uv}\\n                = w_u \\\\left( 1 - \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n\\n    NetworkX uses the standard convention that a self-loop edge counts 2\\n    in the degree of a node, so with self loops (selfloops=True),\\n\\n    .. math::\\n\\n       E[deg(u)] =  \\\\sum_{v \\\\ne u} p_{uv}  + 2 p_{uu}\\n                = w_u \\\\left( 1 + \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n    References\\n    ----------\\n    .. [1] Fan Chung and L. Lu, Connected components in random graphs with\\n       given expected degree sequences, Ann. Combinatorics, 6,\\n       pp. 125-145, 2002.\\n    .. [2] Joel Miller and Aric Hagberg,\\n       Efficient generation of networks with given expected degrees,\\n       in Algorithms and Models for the Web-Graph (WAW 2011),\\n       Alan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\\n       pp. 115-126, 2011.\\n    \"\n    n = len(w)\n    G = nx.empty_graph(n)\n    if n == 0 or max(w) == 0:\n        return G\n    rho = 1 / sum(w)\n    order = sorted(enumerate(w), key=itemgetter(1), reverse=True)\n    mapping = {c: u for (c, (u, v)) in enumerate(order)}\n    seq = [v for (u, v) in order]\n    last = n\n    if not selfloops:\n        last -= 1\n    for u in range(last):\n        v = u\n        if not selfloops:\n            v += 1\n        factor = seq[u] * rho\n        p = min(seq[v] * factor, 1)\n        while v < n and p > 0:\n            if p != 1:\n                r = seed.random()\n                v += math.floor(math.log(r, 1 - p))\n            if v < n:\n                q = min(seq[v] * factor, 1)\n                if seed.random() < q / p:\n                    G.add_edge(mapping[u], mapping[v])\n                v += 1\n                p = q\n    return G",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef expected_degree_graph(w, seed=None, selfloops=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Returns a random graph with given expected degrees.\\n\\n    Given a sequence of expected degrees $W=(w_0,w_1,\\\\ldots,w_{n-1})$\\n    of length $n$ this algorithm assigns an edge between node $u$ and\\n    node $v$ with probability\\n\\n    .. math::\\n\\n       p_{uv} = \\\\frac{w_u w_v}{\\\\sum_k w_k} .\\n\\n    Parameters\\n    ----------\\n    w : list\\n        The list of expected degrees.\\n    selfloops: bool (default=True)\\n        Set to False to remove the possibility of self-loop edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    Graph\\n\\n    Examples\\n    --------\\n    >>> z = [10 for i in range(100)]\\n    >>> G = nx.expected_degree_graph(z)\\n\\n    Notes\\n    -----\\n    The nodes have integer labels corresponding to index of expected degrees\\n    input sequence.\\n\\n    The complexity of this algorithm is $\\\\mathcal{O}(n+m)$ where $n$ is the\\n    number of nodes and $m$ is the expected number of edges.\\n\\n    The model in [1]_ includes the possibility of self-loop edges.\\n    Set selfloops=False to produce a graph without self loops.\\n\\n    For finite graphs this model doesn't produce exactly the given\\n    expected degree sequence.  Instead the expected degrees are as\\n    follows.\\n\\n    For the case without self loops (selfloops=False),\\n\\n    .. math::\\n\\n       E[deg(u)] = \\\\sum_{v \\\\ne u} p_{uv}\\n                = w_u \\\\left( 1 - \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n\\n    NetworkX uses the standard convention that a self-loop edge counts 2\\n    in the degree of a node, so with self loops (selfloops=True),\\n\\n    .. math::\\n\\n       E[deg(u)] =  \\\\sum_{v \\\\ne u} p_{uv}  + 2 p_{uu}\\n                = w_u \\\\left( 1 + \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n    References\\n    ----------\\n    .. [1] Fan Chung and L. Lu, Connected components in random graphs with\\n       given expected degree sequences, Ann. Combinatorics, 6,\\n       pp. 125-145, 2002.\\n    .. [2] Joel Miller and Aric Hagberg,\\n       Efficient generation of networks with given expected degrees,\\n       in Algorithms and Models for the Web-Graph (WAW 2011),\\n       Alan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\\n       pp. 115-126, 2011.\\n    \"\n    n = len(w)\n    G = nx.empty_graph(n)\n    if n == 0 or max(w) == 0:\n        return G\n    rho = 1 / sum(w)\n    order = sorted(enumerate(w), key=itemgetter(1), reverse=True)\n    mapping = {c: u for (c, (u, v)) in enumerate(order)}\n    seq = [v for (u, v) in order]\n    last = n\n    if not selfloops:\n        last -= 1\n    for u in range(last):\n        v = u\n        if not selfloops:\n            v += 1\n        factor = seq[u] * rho\n        p = min(seq[v] * factor, 1)\n        while v < n and p > 0:\n            if p != 1:\n                r = seed.random()\n                v += math.floor(math.log(r, 1 - p))\n            if v < n:\n                q = min(seq[v] * factor, 1)\n                if seed.random() < q / p:\n                    G.add_edge(mapping[u], mapping[v])\n                v += 1\n                p = q\n    return G",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef expected_degree_graph(w, seed=None, selfloops=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Returns a random graph with given expected degrees.\\n\\n    Given a sequence of expected degrees $W=(w_0,w_1,\\\\ldots,w_{n-1})$\\n    of length $n$ this algorithm assigns an edge between node $u$ and\\n    node $v$ with probability\\n\\n    .. math::\\n\\n       p_{uv} = \\\\frac{w_u w_v}{\\\\sum_k w_k} .\\n\\n    Parameters\\n    ----------\\n    w : list\\n        The list of expected degrees.\\n    selfloops: bool (default=True)\\n        Set to False to remove the possibility of self-loop edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    Graph\\n\\n    Examples\\n    --------\\n    >>> z = [10 for i in range(100)]\\n    >>> G = nx.expected_degree_graph(z)\\n\\n    Notes\\n    -----\\n    The nodes have integer labels corresponding to index of expected degrees\\n    input sequence.\\n\\n    The complexity of this algorithm is $\\\\mathcal{O}(n+m)$ where $n$ is the\\n    number of nodes and $m$ is the expected number of edges.\\n\\n    The model in [1]_ includes the possibility of self-loop edges.\\n    Set selfloops=False to produce a graph without self loops.\\n\\n    For finite graphs this model doesn't produce exactly the given\\n    expected degree sequence.  Instead the expected degrees are as\\n    follows.\\n\\n    For the case without self loops (selfloops=False),\\n\\n    .. math::\\n\\n       E[deg(u)] = \\\\sum_{v \\\\ne u} p_{uv}\\n                = w_u \\\\left( 1 - \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n\\n    NetworkX uses the standard convention that a self-loop edge counts 2\\n    in the degree of a node, so with self loops (selfloops=True),\\n\\n    .. math::\\n\\n       E[deg(u)] =  \\\\sum_{v \\\\ne u} p_{uv}  + 2 p_{uu}\\n                = w_u \\\\left( 1 + \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n    References\\n    ----------\\n    .. [1] Fan Chung and L. Lu, Connected components in random graphs with\\n       given expected degree sequences, Ann. Combinatorics, 6,\\n       pp. 125-145, 2002.\\n    .. [2] Joel Miller and Aric Hagberg,\\n       Efficient generation of networks with given expected degrees,\\n       in Algorithms and Models for the Web-Graph (WAW 2011),\\n       Alan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\\n       pp. 115-126, 2011.\\n    \"\n    n = len(w)\n    G = nx.empty_graph(n)\n    if n == 0 or max(w) == 0:\n        return G\n    rho = 1 / sum(w)\n    order = sorted(enumerate(w), key=itemgetter(1), reverse=True)\n    mapping = {c: u for (c, (u, v)) in enumerate(order)}\n    seq = [v for (u, v) in order]\n    last = n\n    if not selfloops:\n        last -= 1\n    for u in range(last):\n        v = u\n        if not selfloops:\n            v += 1\n        factor = seq[u] * rho\n        p = min(seq[v] * factor, 1)\n        while v < n and p > 0:\n            if p != 1:\n                r = seed.random()\n                v += math.floor(math.log(r, 1 - p))\n            if v < n:\n                q = min(seq[v] * factor, 1)\n                if seed.random() < q / p:\n                    G.add_edge(mapping[u], mapping[v])\n                v += 1\n                p = q\n    return G",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef expected_degree_graph(w, seed=None, selfloops=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Returns a random graph with given expected degrees.\\n\\n    Given a sequence of expected degrees $W=(w_0,w_1,\\\\ldots,w_{n-1})$\\n    of length $n$ this algorithm assigns an edge between node $u$ and\\n    node $v$ with probability\\n\\n    .. math::\\n\\n       p_{uv} = \\\\frac{w_u w_v}{\\\\sum_k w_k} .\\n\\n    Parameters\\n    ----------\\n    w : list\\n        The list of expected degrees.\\n    selfloops: bool (default=True)\\n        Set to False to remove the possibility of self-loop edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    Graph\\n\\n    Examples\\n    --------\\n    >>> z = [10 for i in range(100)]\\n    >>> G = nx.expected_degree_graph(z)\\n\\n    Notes\\n    -----\\n    The nodes have integer labels corresponding to index of expected degrees\\n    input sequence.\\n\\n    The complexity of this algorithm is $\\\\mathcal{O}(n+m)$ where $n$ is the\\n    number of nodes and $m$ is the expected number of edges.\\n\\n    The model in [1]_ includes the possibility of self-loop edges.\\n    Set selfloops=False to produce a graph without self loops.\\n\\n    For finite graphs this model doesn't produce exactly the given\\n    expected degree sequence.  Instead the expected degrees are as\\n    follows.\\n\\n    For the case without self loops (selfloops=False),\\n\\n    .. math::\\n\\n       E[deg(u)] = \\\\sum_{v \\\\ne u} p_{uv}\\n                = w_u \\\\left( 1 - \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n\\n    NetworkX uses the standard convention that a self-loop edge counts 2\\n    in the degree of a node, so with self loops (selfloops=True),\\n\\n    .. math::\\n\\n       E[deg(u)] =  \\\\sum_{v \\\\ne u} p_{uv}  + 2 p_{uu}\\n                = w_u \\\\left( 1 + \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n    References\\n    ----------\\n    .. [1] Fan Chung and L. Lu, Connected components in random graphs with\\n       given expected degree sequences, Ann. Combinatorics, 6,\\n       pp. 125-145, 2002.\\n    .. [2] Joel Miller and Aric Hagberg,\\n       Efficient generation of networks with given expected degrees,\\n       in Algorithms and Models for the Web-Graph (WAW 2011),\\n       Alan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\\n       pp. 115-126, 2011.\\n    \"\n    n = len(w)\n    G = nx.empty_graph(n)\n    if n == 0 or max(w) == 0:\n        return G\n    rho = 1 / sum(w)\n    order = sorted(enumerate(w), key=itemgetter(1), reverse=True)\n    mapping = {c: u for (c, (u, v)) in enumerate(order)}\n    seq = [v for (u, v) in order]\n    last = n\n    if not selfloops:\n        last -= 1\n    for u in range(last):\n        v = u\n        if not selfloops:\n            v += 1\n        factor = seq[u] * rho\n        p = min(seq[v] * factor, 1)\n        while v < n and p > 0:\n            if p != 1:\n                r = seed.random()\n                v += math.floor(math.log(r, 1 - p))\n            if v < n:\n                q = min(seq[v] * factor, 1)\n                if seed.random() < q / p:\n                    G.add_edge(mapping[u], mapping[v])\n                v += 1\n                p = q\n    return G",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef expected_degree_graph(w, seed=None, selfloops=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Returns a random graph with given expected degrees.\\n\\n    Given a sequence of expected degrees $W=(w_0,w_1,\\\\ldots,w_{n-1})$\\n    of length $n$ this algorithm assigns an edge between node $u$ and\\n    node $v$ with probability\\n\\n    .. math::\\n\\n       p_{uv} = \\\\frac{w_u w_v}{\\\\sum_k w_k} .\\n\\n    Parameters\\n    ----------\\n    w : list\\n        The list of expected degrees.\\n    selfloops: bool (default=True)\\n        Set to False to remove the possibility of self-loop edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    Graph\\n\\n    Examples\\n    --------\\n    >>> z = [10 for i in range(100)]\\n    >>> G = nx.expected_degree_graph(z)\\n\\n    Notes\\n    -----\\n    The nodes have integer labels corresponding to index of expected degrees\\n    input sequence.\\n\\n    The complexity of this algorithm is $\\\\mathcal{O}(n+m)$ where $n$ is the\\n    number of nodes and $m$ is the expected number of edges.\\n\\n    The model in [1]_ includes the possibility of self-loop edges.\\n    Set selfloops=False to produce a graph without self loops.\\n\\n    For finite graphs this model doesn't produce exactly the given\\n    expected degree sequence.  Instead the expected degrees are as\\n    follows.\\n\\n    For the case without self loops (selfloops=False),\\n\\n    .. math::\\n\\n       E[deg(u)] = \\\\sum_{v \\\\ne u} p_{uv}\\n                = w_u \\\\left( 1 - \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n\\n    NetworkX uses the standard convention that a self-loop edge counts 2\\n    in the degree of a node, so with self loops (selfloops=True),\\n\\n    .. math::\\n\\n       E[deg(u)] =  \\\\sum_{v \\\\ne u} p_{uv}  + 2 p_{uu}\\n                = w_u \\\\left( 1 + \\\\frac{w_u}{\\\\sum_k w_k} \\\\right) .\\n\\n    References\\n    ----------\\n    .. [1] Fan Chung and L. Lu, Connected components in random graphs with\\n       given expected degree sequences, Ann. Combinatorics, 6,\\n       pp. 125-145, 2002.\\n    .. [2] Joel Miller and Aric Hagberg,\\n       Efficient generation of networks with given expected degrees,\\n       in Algorithms and Models for the Web-Graph (WAW 2011),\\n       Alan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\\n       pp. 115-126, 2011.\\n    \"\n    n = len(w)\n    G = nx.empty_graph(n)\n    if n == 0 or max(w) == 0:\n        return G\n    rho = 1 / sum(w)\n    order = sorted(enumerate(w), key=itemgetter(1), reverse=True)\n    mapping = {c: u for (c, (u, v)) in enumerate(order)}\n    seq = [v for (u, v) in order]\n    last = n\n    if not selfloops:\n        last -= 1\n    for u in range(last):\n        v = u\n        if not selfloops:\n            v += 1\n        factor = seq[u] * rho\n        p = min(seq[v] * factor, 1)\n        while v < n and p > 0:\n            if p != 1:\n                r = seed.random()\n                v += math.floor(math.log(r, 1 - p))\n            if v < n:\n                q = min(seq[v] * factor, 1)\n                if seed.random() < q / p:\n                    G.add_edge(mapping[u], mapping[v])\n                v += 1\n                p = q\n    return G"
        ]
    },
    {
        "func_name": "havel_hakimi_graph",
        "original": "@nx._dispatch(graphs=None)\ndef havel_hakimi_graph(deg_sequence, create_using=None):\n    \"\"\"Returns a simple graph with given degree sequence constructed\n    using the Havel-Hakimi algorithm.\n\n    Parameters\n    ----------\n    deg_sequence: list of integers\n        Each integer corresponds to the degree of a node (need not be sorted).\n    create_using : NetworkX graph constructor, optional (default=nx.Graph)\n        Graph type to create. If graph instance, then cleared before populated.\n        Directed graphs are not allowed.\n\n    Raises\n    ------\n    NetworkXException\n        For a non-graphical degree sequence (i.e. one\n        not realizable by some simple graph).\n\n    Notes\n    -----\n    The Havel-Hakimi algorithm constructs a simple graph by\n    successively connecting the node of highest degree to other nodes\n    of highest degree, resorting remaining nodes by degree, and\n    repeating the process. The resulting graph has a high\n    degree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\n    corresponding to their position in deg_sequence.\n\n    The basic algorithm is from Hakimi [1]_ and was generalized by\n    Kleitman and Wang [2]_.\n\n    References\n    ----------\n    .. [1] Hakimi S., On Realizability of a Set of Integers as\n       Degrees of the Vertices of a Linear Graph. I,\n       Journal of SIAM, 10(3), pp. 496-506 (1962)\n    .. [2] Kleitman D.J. and Wang D.L.\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\n       and Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)\n    \"\"\"\n    if not nx.is_graphical(deg_sequence):\n        raise nx.NetworkXError('Invalid degree sequence')\n    p = len(deg_sequence)\n    G = nx.empty_graph(p, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed graphs are not supported')\n    num_degs = [[] for i in range(p)]\n    (dmax, dsum, n) = (0, 0, 0)\n    for d in deg_sequence:\n        if d > 0:\n            num_degs[d].append(n)\n            (dmax, dsum, n) = (max(dmax, d), dsum + d, n + 1)\n    if n == 0:\n        return G\n    modstubs = [(0, 0)] * (dmax + 1)\n    while n > 0:\n        while len(num_degs[dmax]) == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            raise nx.NetworkXError('Non-graphical integer sequence')\n        source = num_degs[dmax].pop()\n        n -= 1\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while len(num_degs[k]) == 0:\n                k -= 1\n            target = num_degs[k].pop()\n            G.add_edge(source, target)\n            n -= 1\n            if k > 1:\n                modstubs[mslen] = (k - 1, target)\n                mslen += 1\n        for i in range(mslen):\n            (stubval, stubtarget) = modstubs[i]\n            num_degs[stubval].append(stubtarget)\n            n += 1\n    return G",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef havel_hakimi_graph(deg_sequence, create_using=None):\n    if False:\n        i = 10\n    'Returns a simple graph with given degree sequence constructed\\n    using the Havel-Hakimi algorithm.\\n\\n    Parameters\\n    ----------\\n    deg_sequence: list of integers\\n        Each integer corresponds to the degree of a node (need not be sorted).\\n    create_using : NetworkX graph constructor, optional (default=nx.Graph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n        Directed graphs are not allowed.\\n\\n    Raises\\n    ------\\n    NetworkXException\\n        For a non-graphical degree sequence (i.e. one\\n        not realizable by some simple graph).\\n\\n    Notes\\n    -----\\n    The Havel-Hakimi algorithm constructs a simple graph by\\n    successively connecting the node of highest degree to other nodes\\n    of highest degree, resorting remaining nodes by degree, and\\n    repeating the process. The resulting graph has a high\\n    degree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\\n    corresponding to their position in deg_sequence.\\n\\n    The basic algorithm is from Hakimi [1]_ and was generalized by\\n    Kleitman and Wang [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Hakimi S., On Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Linear Graph. I,\\n       Journal of SIAM, 10(3), pp. 496-506 (1962)\\n    .. [2] Kleitman D.J. and Wang D.L.\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    if not nx.is_graphical(deg_sequence):\n        raise nx.NetworkXError('Invalid degree sequence')\n    p = len(deg_sequence)\n    G = nx.empty_graph(p, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed graphs are not supported')\n    num_degs = [[] for i in range(p)]\n    (dmax, dsum, n) = (0, 0, 0)\n    for d in deg_sequence:\n        if d > 0:\n            num_degs[d].append(n)\n            (dmax, dsum, n) = (max(dmax, d), dsum + d, n + 1)\n    if n == 0:\n        return G\n    modstubs = [(0, 0)] * (dmax + 1)\n    while n > 0:\n        while len(num_degs[dmax]) == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            raise nx.NetworkXError('Non-graphical integer sequence')\n        source = num_degs[dmax].pop()\n        n -= 1\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while len(num_degs[k]) == 0:\n                k -= 1\n            target = num_degs[k].pop()\n            G.add_edge(source, target)\n            n -= 1\n            if k > 1:\n                modstubs[mslen] = (k - 1, target)\n                mslen += 1\n        for i in range(mslen):\n            (stubval, stubtarget) = modstubs[i]\n            num_degs[stubval].append(stubtarget)\n            n += 1\n    return G",
            "@nx._dispatch(graphs=None)\ndef havel_hakimi_graph(deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a simple graph with given degree sequence constructed\\n    using the Havel-Hakimi algorithm.\\n\\n    Parameters\\n    ----------\\n    deg_sequence: list of integers\\n        Each integer corresponds to the degree of a node (need not be sorted).\\n    create_using : NetworkX graph constructor, optional (default=nx.Graph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n        Directed graphs are not allowed.\\n\\n    Raises\\n    ------\\n    NetworkXException\\n        For a non-graphical degree sequence (i.e. one\\n        not realizable by some simple graph).\\n\\n    Notes\\n    -----\\n    The Havel-Hakimi algorithm constructs a simple graph by\\n    successively connecting the node of highest degree to other nodes\\n    of highest degree, resorting remaining nodes by degree, and\\n    repeating the process. The resulting graph has a high\\n    degree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\\n    corresponding to their position in deg_sequence.\\n\\n    The basic algorithm is from Hakimi [1]_ and was generalized by\\n    Kleitman and Wang [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Hakimi S., On Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Linear Graph. I,\\n       Journal of SIAM, 10(3), pp. 496-506 (1962)\\n    .. [2] Kleitman D.J. and Wang D.L.\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    if not nx.is_graphical(deg_sequence):\n        raise nx.NetworkXError('Invalid degree sequence')\n    p = len(deg_sequence)\n    G = nx.empty_graph(p, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed graphs are not supported')\n    num_degs = [[] for i in range(p)]\n    (dmax, dsum, n) = (0, 0, 0)\n    for d in deg_sequence:\n        if d > 0:\n            num_degs[d].append(n)\n            (dmax, dsum, n) = (max(dmax, d), dsum + d, n + 1)\n    if n == 0:\n        return G\n    modstubs = [(0, 0)] * (dmax + 1)\n    while n > 0:\n        while len(num_degs[dmax]) == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            raise nx.NetworkXError('Non-graphical integer sequence')\n        source = num_degs[dmax].pop()\n        n -= 1\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while len(num_degs[k]) == 0:\n                k -= 1\n            target = num_degs[k].pop()\n            G.add_edge(source, target)\n            n -= 1\n            if k > 1:\n                modstubs[mslen] = (k - 1, target)\n                mslen += 1\n        for i in range(mslen):\n            (stubval, stubtarget) = modstubs[i]\n            num_degs[stubval].append(stubtarget)\n            n += 1\n    return G",
            "@nx._dispatch(graphs=None)\ndef havel_hakimi_graph(deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a simple graph with given degree sequence constructed\\n    using the Havel-Hakimi algorithm.\\n\\n    Parameters\\n    ----------\\n    deg_sequence: list of integers\\n        Each integer corresponds to the degree of a node (need not be sorted).\\n    create_using : NetworkX graph constructor, optional (default=nx.Graph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n        Directed graphs are not allowed.\\n\\n    Raises\\n    ------\\n    NetworkXException\\n        For a non-graphical degree sequence (i.e. one\\n        not realizable by some simple graph).\\n\\n    Notes\\n    -----\\n    The Havel-Hakimi algorithm constructs a simple graph by\\n    successively connecting the node of highest degree to other nodes\\n    of highest degree, resorting remaining nodes by degree, and\\n    repeating the process. The resulting graph has a high\\n    degree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\\n    corresponding to their position in deg_sequence.\\n\\n    The basic algorithm is from Hakimi [1]_ and was generalized by\\n    Kleitman and Wang [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Hakimi S., On Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Linear Graph. I,\\n       Journal of SIAM, 10(3), pp. 496-506 (1962)\\n    .. [2] Kleitman D.J. and Wang D.L.\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    if not nx.is_graphical(deg_sequence):\n        raise nx.NetworkXError('Invalid degree sequence')\n    p = len(deg_sequence)\n    G = nx.empty_graph(p, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed graphs are not supported')\n    num_degs = [[] for i in range(p)]\n    (dmax, dsum, n) = (0, 0, 0)\n    for d in deg_sequence:\n        if d > 0:\n            num_degs[d].append(n)\n            (dmax, dsum, n) = (max(dmax, d), dsum + d, n + 1)\n    if n == 0:\n        return G\n    modstubs = [(0, 0)] * (dmax + 1)\n    while n > 0:\n        while len(num_degs[dmax]) == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            raise nx.NetworkXError('Non-graphical integer sequence')\n        source = num_degs[dmax].pop()\n        n -= 1\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while len(num_degs[k]) == 0:\n                k -= 1\n            target = num_degs[k].pop()\n            G.add_edge(source, target)\n            n -= 1\n            if k > 1:\n                modstubs[mslen] = (k - 1, target)\n                mslen += 1\n        for i in range(mslen):\n            (stubval, stubtarget) = modstubs[i]\n            num_degs[stubval].append(stubtarget)\n            n += 1\n    return G",
            "@nx._dispatch(graphs=None)\ndef havel_hakimi_graph(deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a simple graph with given degree sequence constructed\\n    using the Havel-Hakimi algorithm.\\n\\n    Parameters\\n    ----------\\n    deg_sequence: list of integers\\n        Each integer corresponds to the degree of a node (need not be sorted).\\n    create_using : NetworkX graph constructor, optional (default=nx.Graph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n        Directed graphs are not allowed.\\n\\n    Raises\\n    ------\\n    NetworkXException\\n        For a non-graphical degree sequence (i.e. one\\n        not realizable by some simple graph).\\n\\n    Notes\\n    -----\\n    The Havel-Hakimi algorithm constructs a simple graph by\\n    successively connecting the node of highest degree to other nodes\\n    of highest degree, resorting remaining nodes by degree, and\\n    repeating the process. The resulting graph has a high\\n    degree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\\n    corresponding to their position in deg_sequence.\\n\\n    The basic algorithm is from Hakimi [1]_ and was generalized by\\n    Kleitman and Wang [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Hakimi S., On Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Linear Graph. I,\\n       Journal of SIAM, 10(3), pp. 496-506 (1962)\\n    .. [2] Kleitman D.J. and Wang D.L.\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    if not nx.is_graphical(deg_sequence):\n        raise nx.NetworkXError('Invalid degree sequence')\n    p = len(deg_sequence)\n    G = nx.empty_graph(p, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed graphs are not supported')\n    num_degs = [[] for i in range(p)]\n    (dmax, dsum, n) = (0, 0, 0)\n    for d in deg_sequence:\n        if d > 0:\n            num_degs[d].append(n)\n            (dmax, dsum, n) = (max(dmax, d), dsum + d, n + 1)\n    if n == 0:\n        return G\n    modstubs = [(0, 0)] * (dmax + 1)\n    while n > 0:\n        while len(num_degs[dmax]) == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            raise nx.NetworkXError('Non-graphical integer sequence')\n        source = num_degs[dmax].pop()\n        n -= 1\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while len(num_degs[k]) == 0:\n                k -= 1\n            target = num_degs[k].pop()\n            G.add_edge(source, target)\n            n -= 1\n            if k > 1:\n                modstubs[mslen] = (k - 1, target)\n                mslen += 1\n        for i in range(mslen):\n            (stubval, stubtarget) = modstubs[i]\n            num_degs[stubval].append(stubtarget)\n            n += 1\n    return G",
            "@nx._dispatch(graphs=None)\ndef havel_hakimi_graph(deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a simple graph with given degree sequence constructed\\n    using the Havel-Hakimi algorithm.\\n\\n    Parameters\\n    ----------\\n    deg_sequence: list of integers\\n        Each integer corresponds to the degree of a node (need not be sorted).\\n    create_using : NetworkX graph constructor, optional (default=nx.Graph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n        Directed graphs are not allowed.\\n\\n    Raises\\n    ------\\n    NetworkXException\\n        For a non-graphical degree sequence (i.e. one\\n        not realizable by some simple graph).\\n\\n    Notes\\n    -----\\n    The Havel-Hakimi algorithm constructs a simple graph by\\n    successively connecting the node of highest degree to other nodes\\n    of highest degree, resorting remaining nodes by degree, and\\n    repeating the process. The resulting graph has a high\\n    degree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\\n    corresponding to their position in deg_sequence.\\n\\n    The basic algorithm is from Hakimi [1]_ and was generalized by\\n    Kleitman and Wang [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Hakimi S., On Realizability of a Set of Integers as\\n       Degrees of the Vertices of a Linear Graph. I,\\n       Journal of SIAM, 10(3), pp. 496-506 (1962)\\n    .. [2] Kleitman D.J. and Wang D.L.\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    if not nx.is_graphical(deg_sequence):\n        raise nx.NetworkXError('Invalid degree sequence')\n    p = len(deg_sequence)\n    G = nx.empty_graph(p, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed graphs are not supported')\n    num_degs = [[] for i in range(p)]\n    (dmax, dsum, n) = (0, 0, 0)\n    for d in deg_sequence:\n        if d > 0:\n            num_degs[d].append(n)\n            (dmax, dsum, n) = (max(dmax, d), dsum + d, n + 1)\n    if n == 0:\n        return G\n    modstubs = [(0, 0)] * (dmax + 1)\n    while n > 0:\n        while len(num_degs[dmax]) == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            raise nx.NetworkXError('Non-graphical integer sequence')\n        source = num_degs[dmax].pop()\n        n -= 1\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while len(num_degs[k]) == 0:\n                k -= 1\n            target = num_degs[k].pop()\n            G.add_edge(source, target)\n            n -= 1\n            if k > 1:\n                modstubs[mslen] = (k - 1, target)\n                mslen += 1\n        for i in range(mslen):\n            (stubval, stubtarget) = modstubs[i]\n            num_degs[stubval].append(stubtarget)\n            n += 1\n    return G"
        ]
    },
    {
        "func_name": "directed_havel_hakimi_graph",
        "original": "@nx._dispatch(graphs=None)\ndef directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):\n    \"\"\"Returns a directed graph with the given degree sequences.\n\n    Parameters\n    ----------\n    in_deg_sequence :  list of integers\n        Each list entry corresponds to the in-degree of a node.\n    out_deg_sequence : list of integers\n        Each list entry corresponds to the out-degree of a node.\n    create_using : NetworkX graph constructor, optional (default DiGraph)\n        Graph type to create. If graph instance, then cleared before populated.\n\n    Returns\n    -------\n    G : DiGraph\n        A graph with the specified degree sequences.\n        Nodes are labeled starting at 0 with an index\n        corresponding to the position in deg_sequence\n\n    Raises\n    ------\n    NetworkXError\n        If the degree sequences are not digraphical.\n\n    See Also\n    --------\n    configuration_model\n\n    Notes\n    -----\n    Algorithm as described by Kleitman and Wang [1]_.\n\n    References\n    ----------\n    .. [1] D.J. Kleitman and D.L. Wang\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\n       and Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)\n    \"\"\"\n    in_deg_sequence = nx.utils.make_list_of_ints(in_deg_sequence)\n    out_deg_sequence = nx.utils.make_list_of_ints(out_deg_sequence)\n    (sumin, sumout) = (0, 0)\n    (nin, nout) = (len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    G = nx.empty_graph(maxn, create_using, default=nx.DiGraph)\n    if maxn == 0:\n        return G\n    maxin = 0\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            raise nx.NetworkXError('Invalid degree sequences. Sequence values must be positive.')\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg, n))\n        elif out_deg > 0:\n            zeroheap.append((-1 * out_deg, n))\n    if sumin != sumout:\n        raise nx.NetworkXError('Invalid degree sequences. Sequences must have equal sums.')\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein, target) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            raise nx.NetworkXError('Non-digraphical integer sequence')\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0][0]):\n                (stubout, stubsource) = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin, stubsource) = heapq.heappop(stubheap)\n            if stubout == 0:\n                raise nx.NetworkXError('Non-digraphical integer sequence')\n            G.add_edge(stubsource, target)\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin, stubsource)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, (stub[0], stub[2]))\n        if freeout < 0:\n            heapq.heappush(zeroheap, (freeout, target))\n    return G",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):\n    if False:\n        i = 10\n    'Returns a directed graph with the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_deg_sequence :  list of integers\\n        Each list entry corresponds to the in-degree of a node.\\n    out_deg_sequence : list of integers\\n        Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default DiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n\\n    Returns\\n    -------\\n    G : DiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences are not digraphical.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Kleitman and Wang [1]_.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    in_deg_sequence = nx.utils.make_list_of_ints(in_deg_sequence)\n    out_deg_sequence = nx.utils.make_list_of_ints(out_deg_sequence)\n    (sumin, sumout) = (0, 0)\n    (nin, nout) = (len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    G = nx.empty_graph(maxn, create_using, default=nx.DiGraph)\n    if maxn == 0:\n        return G\n    maxin = 0\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            raise nx.NetworkXError('Invalid degree sequences. Sequence values must be positive.')\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg, n))\n        elif out_deg > 0:\n            zeroheap.append((-1 * out_deg, n))\n    if sumin != sumout:\n        raise nx.NetworkXError('Invalid degree sequences. Sequences must have equal sums.')\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein, target) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            raise nx.NetworkXError('Non-digraphical integer sequence')\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0][0]):\n                (stubout, stubsource) = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin, stubsource) = heapq.heappop(stubheap)\n            if stubout == 0:\n                raise nx.NetworkXError('Non-digraphical integer sequence')\n            G.add_edge(stubsource, target)\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin, stubsource)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, (stub[0], stub[2]))\n        if freeout < 0:\n            heapq.heappush(zeroheap, (freeout, target))\n    return G",
            "@nx._dispatch(graphs=None)\ndef directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a directed graph with the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_deg_sequence :  list of integers\\n        Each list entry corresponds to the in-degree of a node.\\n    out_deg_sequence : list of integers\\n        Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default DiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n\\n    Returns\\n    -------\\n    G : DiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences are not digraphical.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Kleitman and Wang [1]_.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    in_deg_sequence = nx.utils.make_list_of_ints(in_deg_sequence)\n    out_deg_sequence = nx.utils.make_list_of_ints(out_deg_sequence)\n    (sumin, sumout) = (0, 0)\n    (nin, nout) = (len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    G = nx.empty_graph(maxn, create_using, default=nx.DiGraph)\n    if maxn == 0:\n        return G\n    maxin = 0\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            raise nx.NetworkXError('Invalid degree sequences. Sequence values must be positive.')\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg, n))\n        elif out_deg > 0:\n            zeroheap.append((-1 * out_deg, n))\n    if sumin != sumout:\n        raise nx.NetworkXError('Invalid degree sequences. Sequences must have equal sums.')\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein, target) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            raise nx.NetworkXError('Non-digraphical integer sequence')\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0][0]):\n                (stubout, stubsource) = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin, stubsource) = heapq.heappop(stubheap)\n            if stubout == 0:\n                raise nx.NetworkXError('Non-digraphical integer sequence')\n            G.add_edge(stubsource, target)\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin, stubsource)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, (stub[0], stub[2]))\n        if freeout < 0:\n            heapq.heappush(zeroheap, (freeout, target))\n    return G",
            "@nx._dispatch(graphs=None)\ndef directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a directed graph with the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_deg_sequence :  list of integers\\n        Each list entry corresponds to the in-degree of a node.\\n    out_deg_sequence : list of integers\\n        Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default DiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n\\n    Returns\\n    -------\\n    G : DiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences are not digraphical.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Kleitman and Wang [1]_.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    in_deg_sequence = nx.utils.make_list_of_ints(in_deg_sequence)\n    out_deg_sequence = nx.utils.make_list_of_ints(out_deg_sequence)\n    (sumin, sumout) = (0, 0)\n    (nin, nout) = (len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    G = nx.empty_graph(maxn, create_using, default=nx.DiGraph)\n    if maxn == 0:\n        return G\n    maxin = 0\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            raise nx.NetworkXError('Invalid degree sequences. Sequence values must be positive.')\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg, n))\n        elif out_deg > 0:\n            zeroheap.append((-1 * out_deg, n))\n    if sumin != sumout:\n        raise nx.NetworkXError('Invalid degree sequences. Sequences must have equal sums.')\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein, target) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            raise nx.NetworkXError('Non-digraphical integer sequence')\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0][0]):\n                (stubout, stubsource) = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin, stubsource) = heapq.heappop(stubheap)\n            if stubout == 0:\n                raise nx.NetworkXError('Non-digraphical integer sequence')\n            G.add_edge(stubsource, target)\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin, stubsource)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, (stub[0], stub[2]))\n        if freeout < 0:\n            heapq.heappush(zeroheap, (freeout, target))\n    return G",
            "@nx._dispatch(graphs=None)\ndef directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a directed graph with the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_deg_sequence :  list of integers\\n        Each list entry corresponds to the in-degree of a node.\\n    out_deg_sequence : list of integers\\n        Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default DiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n\\n    Returns\\n    -------\\n    G : DiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences are not digraphical.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Kleitman and Wang [1]_.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    in_deg_sequence = nx.utils.make_list_of_ints(in_deg_sequence)\n    out_deg_sequence = nx.utils.make_list_of_ints(out_deg_sequence)\n    (sumin, sumout) = (0, 0)\n    (nin, nout) = (len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    G = nx.empty_graph(maxn, create_using, default=nx.DiGraph)\n    if maxn == 0:\n        return G\n    maxin = 0\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            raise nx.NetworkXError('Invalid degree sequences. Sequence values must be positive.')\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg, n))\n        elif out_deg > 0:\n            zeroheap.append((-1 * out_deg, n))\n    if sumin != sumout:\n        raise nx.NetworkXError('Invalid degree sequences. Sequences must have equal sums.')\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein, target) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            raise nx.NetworkXError('Non-digraphical integer sequence')\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0][0]):\n                (stubout, stubsource) = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin, stubsource) = heapq.heappop(stubheap)\n            if stubout == 0:\n                raise nx.NetworkXError('Non-digraphical integer sequence')\n            G.add_edge(stubsource, target)\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin, stubsource)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, (stub[0], stub[2]))\n        if freeout < 0:\n            heapq.heappush(zeroheap, (freeout, target))\n    return G",
            "@nx._dispatch(graphs=None)\ndef directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a directed graph with the given degree sequences.\\n\\n    Parameters\\n    ----------\\n    in_deg_sequence :  list of integers\\n        Each list entry corresponds to the in-degree of a node.\\n    out_deg_sequence : list of integers\\n        Each list entry corresponds to the out-degree of a node.\\n    create_using : NetworkX graph constructor, optional (default DiGraph)\\n        Graph type to create. If graph instance, then cleared before populated.\\n\\n    Returns\\n    -------\\n    G : DiGraph\\n        A graph with the specified degree sequences.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in deg_sequence\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the degree sequences are not digraphical.\\n\\n    See Also\\n    --------\\n    configuration_model\\n\\n    Notes\\n    -----\\n    Algorithm as described by Kleitman and Wang [1]_.\\n\\n    References\\n    ----------\\n    .. [1] D.J. Kleitman and D.L. Wang\\n       Algorithms for Constructing Graphs and Digraphs with Given Valences\\n       and Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)\\n    '\n    in_deg_sequence = nx.utils.make_list_of_ints(in_deg_sequence)\n    out_deg_sequence = nx.utils.make_list_of_ints(out_deg_sequence)\n    (sumin, sumout) = (0, 0)\n    (nin, nout) = (len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    G = nx.empty_graph(maxn, create_using, default=nx.DiGraph)\n    if maxn == 0:\n        return G\n    maxin = 0\n    (stubheap, zeroheap) = ([], [])\n    for n in range(maxn):\n        (in_deg, out_deg) = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            raise nx.NetworkXError('Invalid degree sequences. Sequence values must be positive.')\n        (sumin, sumout, maxin) = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg, n))\n        elif out_deg > 0:\n            zeroheap.append((-1 * out_deg, n))\n    if sumin != sumout:\n        raise nx.NetworkXError('Invalid degree sequences. Sequences must have equal sums.')\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0, 0)] * (maxin + 1)\n    while stubheap:\n        (freeout, freein, target) = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            raise nx.NetworkXError('Non-digraphical integer sequence')\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0][0]):\n                (stubout, stubsource) = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                (stubout, stubin, stubsource) = heapq.heappop(stubheap)\n            if stubout == 0:\n                raise nx.NetworkXError('Non-digraphical integer sequence')\n            G.add_edge(stubsource, target)\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin, stubsource)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, (stub[0], stub[2]))\n        if freeout < 0:\n            heapq.heappush(zeroheap, (freeout, target))\n    return G"
        ]
    },
    {
        "func_name": "degree_sequence_tree",
        "original": "@nx._dispatch(graphs=None)\ndef degree_sequence_tree(deg_sequence, create_using=None):\n    \"\"\"Make a tree for the given degree sequence.\n\n    A tree has #nodes-#edges=1 so\n    the degree sequence must have\n    len(deg_sequence)-sum(deg_sequence)/2=1\n    \"\"\"\n    degree_sum = sum(deg_sequence)\n    if degree_sum % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    if len(deg_sequence) - degree_sum // 2 != 1:\n        msg = 'Invalid degree sequence: tree must have number of nodes equal to one less than the number of edges'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed Graph not supported')\n    deg = sorted((s for s in deg_sequence if s > 1), reverse=True)\n    n = len(deg) + 2\n    nx.add_path(G, range(n))\n    last = n\n    for source in range(1, n - 1):\n        nedges = deg.pop() - 2\n        for target in range(last, last + nedges):\n            G.add_edge(source, target)\n        last += nedges\n    if len(G) > len(deg_sequence):\n        G.remove_node(0)\n    return G",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef degree_sequence_tree(deg_sequence, create_using=None):\n    if False:\n        i = 10\n    'Make a tree for the given degree sequence.\\n\\n    A tree has #nodes-#edges=1 so\\n    the degree sequence must have\\n    len(deg_sequence)-sum(deg_sequence)/2=1\\n    '\n    degree_sum = sum(deg_sequence)\n    if degree_sum % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    if len(deg_sequence) - degree_sum // 2 != 1:\n        msg = 'Invalid degree sequence: tree must have number of nodes equal to one less than the number of edges'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed Graph not supported')\n    deg = sorted((s for s in deg_sequence if s > 1), reverse=True)\n    n = len(deg) + 2\n    nx.add_path(G, range(n))\n    last = n\n    for source in range(1, n - 1):\n        nedges = deg.pop() - 2\n        for target in range(last, last + nedges):\n            G.add_edge(source, target)\n        last += nedges\n    if len(G) > len(deg_sequence):\n        G.remove_node(0)\n    return G",
            "@nx._dispatch(graphs=None)\ndef degree_sequence_tree(deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Make a tree for the given degree sequence.\\n\\n    A tree has #nodes-#edges=1 so\\n    the degree sequence must have\\n    len(deg_sequence)-sum(deg_sequence)/2=1\\n    '\n    degree_sum = sum(deg_sequence)\n    if degree_sum % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    if len(deg_sequence) - degree_sum // 2 != 1:\n        msg = 'Invalid degree sequence: tree must have number of nodes equal to one less than the number of edges'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed Graph not supported')\n    deg = sorted((s for s in deg_sequence if s > 1), reverse=True)\n    n = len(deg) + 2\n    nx.add_path(G, range(n))\n    last = n\n    for source in range(1, n - 1):\n        nedges = deg.pop() - 2\n        for target in range(last, last + nedges):\n            G.add_edge(source, target)\n        last += nedges\n    if len(G) > len(deg_sequence):\n        G.remove_node(0)\n    return G",
            "@nx._dispatch(graphs=None)\ndef degree_sequence_tree(deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Make a tree for the given degree sequence.\\n\\n    A tree has #nodes-#edges=1 so\\n    the degree sequence must have\\n    len(deg_sequence)-sum(deg_sequence)/2=1\\n    '\n    degree_sum = sum(deg_sequence)\n    if degree_sum % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    if len(deg_sequence) - degree_sum // 2 != 1:\n        msg = 'Invalid degree sequence: tree must have number of nodes equal to one less than the number of edges'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed Graph not supported')\n    deg = sorted((s for s in deg_sequence if s > 1), reverse=True)\n    n = len(deg) + 2\n    nx.add_path(G, range(n))\n    last = n\n    for source in range(1, n - 1):\n        nedges = deg.pop() - 2\n        for target in range(last, last + nedges):\n            G.add_edge(source, target)\n        last += nedges\n    if len(G) > len(deg_sequence):\n        G.remove_node(0)\n    return G",
            "@nx._dispatch(graphs=None)\ndef degree_sequence_tree(deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Make a tree for the given degree sequence.\\n\\n    A tree has #nodes-#edges=1 so\\n    the degree sequence must have\\n    len(deg_sequence)-sum(deg_sequence)/2=1\\n    '\n    degree_sum = sum(deg_sequence)\n    if degree_sum % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    if len(deg_sequence) - degree_sum // 2 != 1:\n        msg = 'Invalid degree sequence: tree must have number of nodes equal to one less than the number of edges'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed Graph not supported')\n    deg = sorted((s for s in deg_sequence if s > 1), reverse=True)\n    n = len(deg) + 2\n    nx.add_path(G, range(n))\n    last = n\n    for source in range(1, n - 1):\n        nedges = deg.pop() - 2\n        for target in range(last, last + nedges):\n            G.add_edge(source, target)\n        last += nedges\n    if len(G) > len(deg_sequence):\n        G.remove_node(0)\n    return G",
            "@nx._dispatch(graphs=None)\ndef degree_sequence_tree(deg_sequence, create_using=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Make a tree for the given degree sequence.\\n\\n    A tree has #nodes-#edges=1 so\\n    the degree sequence must have\\n    len(deg_sequence)-sum(deg_sequence)/2=1\\n    '\n    degree_sum = sum(deg_sequence)\n    if degree_sum % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    if len(deg_sequence) - degree_sum // 2 != 1:\n        msg = 'Invalid degree sequence: tree must have number of nodes equal to one less than the number of edges'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed Graph not supported')\n    deg = sorted((s for s in deg_sequence if s > 1), reverse=True)\n    n = len(deg) + 2\n    nx.add_path(G, range(n))\n    last = n\n    for source in range(1, n - 1):\n        nedges = deg.pop() - 2\n        for target in range(last, last + nedges):\n            G.add_edge(source, target)\n        last += nedges\n    if len(G) > len(deg_sequence):\n        G.remove_node(0)\n    return G"
        ]
    },
    {
        "func_name": "random_degree_sequence_graph",
        "original": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_degree_sequence_graph(sequence, seed=None, tries=10):\n    \"\"\"Returns a simple random graph with the given degree sequence.\n\n    If the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the\n    algorithm produces almost uniform random graphs in $O(m d_m)$ time\n    where $m$ is the number of edges.\n\n    Parameters\n    ----------\n    sequence :  list of integers\n        Sequence of degrees\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    tries : int, optional\n        Maximum number of tries to create a graph\n\n    Returns\n    -------\n    G : Graph\n        A graph with the specified degree sequence.\n        Nodes are labeled starting at 0 with an index\n        corresponding to the position in the sequence.\n\n    Raises\n    ------\n    NetworkXUnfeasible\n        If the degree sequence is not graphical.\n    NetworkXError\n        If a graph is not produced in specified number of tries\n\n    See Also\n    --------\n    is_graphical, configuration_model\n\n    Notes\n    -----\n    The generator algorithm [1]_ is not guaranteed to produce a graph.\n\n    References\n    ----------\n    .. [1] Moshen Bayati, Jeong Han Kim, and Amin Saberi,\n       A sequential algorithm for generating random graphs.\n       Algorithmica, Volume 58, Number 4, 860-910,\n       DOI: 10.1007/s00453-009-9340-1\n\n    Examples\n    --------\n    >>> sequence = [1, 2, 2, 3]\n    >>> G = nx.random_degree_sequence_graph(sequence, seed=42)\n    >>> sorted(d for n, d in G.degree())\n    [1, 2, 2, 3]\n    \"\"\"\n    DSRG = DegreeSequenceRandomGraph(sequence, seed)\n    for try_n in range(tries):\n        try:\n            return DSRG.generate()\n        except nx.NetworkXUnfeasible:\n            pass\n    raise nx.NetworkXError(f'failed to generate graph in {tries} tries')",
        "mutated": [
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_degree_sequence_graph(sequence, seed=None, tries=10):\n    if False:\n        i = 10\n    'Returns a simple random graph with the given degree sequence.\\n\\n    If the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the\\n    algorithm produces almost uniform random graphs in $O(m d_m)$ time\\n    where $m$ is the number of edges.\\n\\n    Parameters\\n    ----------\\n    sequence :  list of integers\\n        Sequence of degrees\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int, optional\\n        Maximum number of tries to create a graph\\n\\n    Returns\\n    -------\\n    G : Graph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in the sequence.\\n\\n    Raises\\n    ------\\n    NetworkXUnfeasible\\n        If the degree sequence is not graphical.\\n    NetworkXError\\n        If a graph is not produced in specified number of tries\\n\\n    See Also\\n    --------\\n    is_graphical, configuration_model\\n\\n    Notes\\n    -----\\n    The generator algorithm [1]_ is not guaranteed to produce a graph.\\n\\n    References\\n    ----------\\n    .. [1] Moshen Bayati, Jeong Han Kim, and Amin Saberi,\\n       A sequential algorithm for generating random graphs.\\n       Algorithmica, Volume 58, Number 4, 860-910,\\n       DOI: 10.1007/s00453-009-9340-1\\n\\n    Examples\\n    --------\\n    >>> sequence = [1, 2, 2, 3]\\n    >>> G = nx.random_degree_sequence_graph(sequence, seed=42)\\n    >>> sorted(d for n, d in G.degree())\\n    [1, 2, 2, 3]\\n    '\n    DSRG = DegreeSequenceRandomGraph(sequence, seed)\n    for try_n in range(tries):\n        try:\n            return DSRG.generate()\n        except nx.NetworkXUnfeasible:\n            pass\n    raise nx.NetworkXError(f'failed to generate graph in {tries} tries')",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_degree_sequence_graph(sequence, seed=None, tries=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a simple random graph with the given degree sequence.\\n\\n    If the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the\\n    algorithm produces almost uniform random graphs in $O(m d_m)$ time\\n    where $m$ is the number of edges.\\n\\n    Parameters\\n    ----------\\n    sequence :  list of integers\\n        Sequence of degrees\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int, optional\\n        Maximum number of tries to create a graph\\n\\n    Returns\\n    -------\\n    G : Graph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in the sequence.\\n\\n    Raises\\n    ------\\n    NetworkXUnfeasible\\n        If the degree sequence is not graphical.\\n    NetworkXError\\n        If a graph is not produced in specified number of tries\\n\\n    See Also\\n    --------\\n    is_graphical, configuration_model\\n\\n    Notes\\n    -----\\n    The generator algorithm [1]_ is not guaranteed to produce a graph.\\n\\n    References\\n    ----------\\n    .. [1] Moshen Bayati, Jeong Han Kim, and Amin Saberi,\\n       A sequential algorithm for generating random graphs.\\n       Algorithmica, Volume 58, Number 4, 860-910,\\n       DOI: 10.1007/s00453-009-9340-1\\n\\n    Examples\\n    --------\\n    >>> sequence = [1, 2, 2, 3]\\n    >>> G = nx.random_degree_sequence_graph(sequence, seed=42)\\n    >>> sorted(d for n, d in G.degree())\\n    [1, 2, 2, 3]\\n    '\n    DSRG = DegreeSequenceRandomGraph(sequence, seed)\n    for try_n in range(tries):\n        try:\n            return DSRG.generate()\n        except nx.NetworkXUnfeasible:\n            pass\n    raise nx.NetworkXError(f'failed to generate graph in {tries} tries')",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_degree_sequence_graph(sequence, seed=None, tries=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a simple random graph with the given degree sequence.\\n\\n    If the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the\\n    algorithm produces almost uniform random graphs in $O(m d_m)$ time\\n    where $m$ is the number of edges.\\n\\n    Parameters\\n    ----------\\n    sequence :  list of integers\\n        Sequence of degrees\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int, optional\\n        Maximum number of tries to create a graph\\n\\n    Returns\\n    -------\\n    G : Graph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in the sequence.\\n\\n    Raises\\n    ------\\n    NetworkXUnfeasible\\n        If the degree sequence is not graphical.\\n    NetworkXError\\n        If a graph is not produced in specified number of tries\\n\\n    See Also\\n    --------\\n    is_graphical, configuration_model\\n\\n    Notes\\n    -----\\n    The generator algorithm [1]_ is not guaranteed to produce a graph.\\n\\n    References\\n    ----------\\n    .. [1] Moshen Bayati, Jeong Han Kim, and Amin Saberi,\\n       A sequential algorithm for generating random graphs.\\n       Algorithmica, Volume 58, Number 4, 860-910,\\n       DOI: 10.1007/s00453-009-9340-1\\n\\n    Examples\\n    --------\\n    >>> sequence = [1, 2, 2, 3]\\n    >>> G = nx.random_degree_sequence_graph(sequence, seed=42)\\n    >>> sorted(d for n, d in G.degree())\\n    [1, 2, 2, 3]\\n    '\n    DSRG = DegreeSequenceRandomGraph(sequence, seed)\n    for try_n in range(tries):\n        try:\n            return DSRG.generate()\n        except nx.NetworkXUnfeasible:\n            pass\n    raise nx.NetworkXError(f'failed to generate graph in {tries} tries')",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_degree_sequence_graph(sequence, seed=None, tries=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a simple random graph with the given degree sequence.\\n\\n    If the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the\\n    algorithm produces almost uniform random graphs in $O(m d_m)$ time\\n    where $m$ is the number of edges.\\n\\n    Parameters\\n    ----------\\n    sequence :  list of integers\\n        Sequence of degrees\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int, optional\\n        Maximum number of tries to create a graph\\n\\n    Returns\\n    -------\\n    G : Graph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in the sequence.\\n\\n    Raises\\n    ------\\n    NetworkXUnfeasible\\n        If the degree sequence is not graphical.\\n    NetworkXError\\n        If a graph is not produced in specified number of tries\\n\\n    See Also\\n    --------\\n    is_graphical, configuration_model\\n\\n    Notes\\n    -----\\n    The generator algorithm [1]_ is not guaranteed to produce a graph.\\n\\n    References\\n    ----------\\n    .. [1] Moshen Bayati, Jeong Han Kim, and Amin Saberi,\\n       A sequential algorithm for generating random graphs.\\n       Algorithmica, Volume 58, Number 4, 860-910,\\n       DOI: 10.1007/s00453-009-9340-1\\n\\n    Examples\\n    --------\\n    >>> sequence = [1, 2, 2, 3]\\n    >>> G = nx.random_degree_sequence_graph(sequence, seed=42)\\n    >>> sorted(d for n, d in G.degree())\\n    [1, 2, 2, 3]\\n    '\n    DSRG = DegreeSequenceRandomGraph(sequence, seed)\n    for try_n in range(tries):\n        try:\n            return DSRG.generate()\n        except nx.NetworkXUnfeasible:\n            pass\n    raise nx.NetworkXError(f'failed to generate graph in {tries} tries')",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_degree_sequence_graph(sequence, seed=None, tries=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a simple random graph with the given degree sequence.\\n\\n    If the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the\\n    algorithm produces almost uniform random graphs in $O(m d_m)$ time\\n    where $m$ is the number of edges.\\n\\n    Parameters\\n    ----------\\n    sequence :  list of integers\\n        Sequence of degrees\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int, optional\\n        Maximum number of tries to create a graph\\n\\n    Returns\\n    -------\\n    G : Graph\\n        A graph with the specified degree sequence.\\n        Nodes are labeled starting at 0 with an index\\n        corresponding to the position in the sequence.\\n\\n    Raises\\n    ------\\n    NetworkXUnfeasible\\n        If the degree sequence is not graphical.\\n    NetworkXError\\n        If a graph is not produced in specified number of tries\\n\\n    See Also\\n    --------\\n    is_graphical, configuration_model\\n\\n    Notes\\n    -----\\n    The generator algorithm [1]_ is not guaranteed to produce a graph.\\n\\n    References\\n    ----------\\n    .. [1] Moshen Bayati, Jeong Han Kim, and Amin Saberi,\\n       A sequential algorithm for generating random graphs.\\n       Algorithmica, Volume 58, Number 4, 860-910,\\n       DOI: 10.1007/s00453-009-9340-1\\n\\n    Examples\\n    --------\\n    >>> sequence = [1, 2, 2, 3]\\n    >>> G = nx.random_degree_sequence_graph(sequence, seed=42)\\n    >>> sorted(d for n, d in G.degree())\\n    [1, 2, 2, 3]\\n    '\n    DSRG = DegreeSequenceRandomGraph(sequence, seed)\n    for try_n in range(tries):\n        try:\n            return DSRG.generate()\n        except nx.NetworkXUnfeasible:\n            pass\n    raise nx.NetworkXError(f'failed to generate graph in {tries} tries')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, degree, rng):\n    if not nx.is_graphical(degree):\n        raise nx.NetworkXUnfeasible('degree sequence is not graphical')\n    self.rng = rng\n    self.degree = list(degree)\n    self.m = sum(self.degree) / 2.0\n    try:\n        self.dmax = max(self.degree)\n    except ValueError:\n        self.dmax = 0",
        "mutated": [
            "def __init__(self, degree, rng):\n    if False:\n        i = 10\n    if not nx.is_graphical(degree):\n        raise nx.NetworkXUnfeasible('degree sequence is not graphical')\n    self.rng = rng\n    self.degree = list(degree)\n    self.m = sum(self.degree) / 2.0\n    try:\n        self.dmax = max(self.degree)\n    except ValueError:\n        self.dmax = 0",
            "def __init__(self, degree, rng):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not nx.is_graphical(degree):\n        raise nx.NetworkXUnfeasible('degree sequence is not graphical')\n    self.rng = rng\n    self.degree = list(degree)\n    self.m = sum(self.degree) / 2.0\n    try:\n        self.dmax = max(self.degree)\n    except ValueError:\n        self.dmax = 0",
            "def __init__(self, degree, rng):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not nx.is_graphical(degree):\n        raise nx.NetworkXUnfeasible('degree sequence is not graphical')\n    self.rng = rng\n    self.degree = list(degree)\n    self.m = sum(self.degree) / 2.0\n    try:\n        self.dmax = max(self.degree)\n    except ValueError:\n        self.dmax = 0",
            "def __init__(self, degree, rng):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not nx.is_graphical(degree):\n        raise nx.NetworkXUnfeasible('degree sequence is not graphical')\n    self.rng = rng\n    self.degree = list(degree)\n    self.m = sum(self.degree) / 2.0\n    try:\n        self.dmax = max(self.degree)\n    except ValueError:\n        self.dmax = 0",
            "def __init__(self, degree, rng):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not nx.is_graphical(degree):\n        raise nx.NetworkXUnfeasible('degree sequence is not graphical')\n    self.rng = rng\n    self.degree = list(degree)\n    self.m = sum(self.degree) / 2.0\n    try:\n        self.dmax = max(self.degree)\n    except ValueError:\n        self.dmax = 0"
        ]
    },
    {
        "func_name": "generate",
        "original": "def generate(self):\n    self.remaining_degree = dict(enumerate(self.degree))\n    self.graph = nx.Graph()\n    self.graph.add_nodes_from(self.remaining_degree)\n    for (n, d) in list(self.remaining_degree.items()):\n        if d == 0:\n            del self.remaining_degree[n]\n    if len(self.remaining_degree) > 0:\n        self.phase1()\n        self.phase2()\n        self.phase3()\n    return self.graph",
        "mutated": [
            "def generate(self):\n    if False:\n        i = 10\n    self.remaining_degree = dict(enumerate(self.degree))\n    self.graph = nx.Graph()\n    self.graph.add_nodes_from(self.remaining_degree)\n    for (n, d) in list(self.remaining_degree.items()):\n        if d == 0:\n            del self.remaining_degree[n]\n    if len(self.remaining_degree) > 0:\n        self.phase1()\n        self.phase2()\n        self.phase3()\n    return self.graph",
            "def generate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.remaining_degree = dict(enumerate(self.degree))\n    self.graph = nx.Graph()\n    self.graph.add_nodes_from(self.remaining_degree)\n    for (n, d) in list(self.remaining_degree.items()):\n        if d == 0:\n            del self.remaining_degree[n]\n    if len(self.remaining_degree) > 0:\n        self.phase1()\n        self.phase2()\n        self.phase3()\n    return self.graph",
            "def generate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.remaining_degree = dict(enumerate(self.degree))\n    self.graph = nx.Graph()\n    self.graph.add_nodes_from(self.remaining_degree)\n    for (n, d) in list(self.remaining_degree.items()):\n        if d == 0:\n            del self.remaining_degree[n]\n    if len(self.remaining_degree) > 0:\n        self.phase1()\n        self.phase2()\n        self.phase3()\n    return self.graph",
            "def generate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.remaining_degree = dict(enumerate(self.degree))\n    self.graph = nx.Graph()\n    self.graph.add_nodes_from(self.remaining_degree)\n    for (n, d) in list(self.remaining_degree.items()):\n        if d == 0:\n            del self.remaining_degree[n]\n    if len(self.remaining_degree) > 0:\n        self.phase1()\n        self.phase2()\n        self.phase3()\n    return self.graph",
            "def generate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.remaining_degree = dict(enumerate(self.degree))\n    self.graph = nx.Graph()\n    self.graph.add_nodes_from(self.remaining_degree)\n    for (n, d) in list(self.remaining_degree.items()):\n        if d == 0:\n            del self.remaining_degree[n]\n    if len(self.remaining_degree) > 0:\n        self.phase1()\n        self.phase2()\n        self.phase3()\n    return self.graph"
        ]
    },
    {
        "func_name": "update_remaining",
        "original": "def update_remaining(self, u, v, aux_graph=None):\n    if aux_graph is not None:\n        aux_graph.remove_edge(u, v)\n    if self.remaining_degree[u] == 1:\n        del self.remaining_degree[u]\n        if aux_graph is not None:\n            aux_graph.remove_node(u)\n    else:\n        self.remaining_degree[u] -= 1\n    if self.remaining_degree[v] == 1:\n        del self.remaining_degree[v]\n        if aux_graph is not None:\n            aux_graph.remove_node(v)\n    else:\n        self.remaining_degree[v] -= 1",
        "mutated": [
            "def update_remaining(self, u, v, aux_graph=None):\n    if False:\n        i = 10\n    if aux_graph is not None:\n        aux_graph.remove_edge(u, v)\n    if self.remaining_degree[u] == 1:\n        del self.remaining_degree[u]\n        if aux_graph is not None:\n            aux_graph.remove_node(u)\n    else:\n        self.remaining_degree[u] -= 1\n    if self.remaining_degree[v] == 1:\n        del self.remaining_degree[v]\n        if aux_graph is not None:\n            aux_graph.remove_node(v)\n    else:\n        self.remaining_degree[v] -= 1",
            "def update_remaining(self, u, v, aux_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if aux_graph is not None:\n        aux_graph.remove_edge(u, v)\n    if self.remaining_degree[u] == 1:\n        del self.remaining_degree[u]\n        if aux_graph is not None:\n            aux_graph.remove_node(u)\n    else:\n        self.remaining_degree[u] -= 1\n    if self.remaining_degree[v] == 1:\n        del self.remaining_degree[v]\n        if aux_graph is not None:\n            aux_graph.remove_node(v)\n    else:\n        self.remaining_degree[v] -= 1",
            "def update_remaining(self, u, v, aux_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if aux_graph is not None:\n        aux_graph.remove_edge(u, v)\n    if self.remaining_degree[u] == 1:\n        del self.remaining_degree[u]\n        if aux_graph is not None:\n            aux_graph.remove_node(u)\n    else:\n        self.remaining_degree[u] -= 1\n    if self.remaining_degree[v] == 1:\n        del self.remaining_degree[v]\n        if aux_graph is not None:\n            aux_graph.remove_node(v)\n    else:\n        self.remaining_degree[v] -= 1",
            "def update_remaining(self, u, v, aux_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if aux_graph is not None:\n        aux_graph.remove_edge(u, v)\n    if self.remaining_degree[u] == 1:\n        del self.remaining_degree[u]\n        if aux_graph is not None:\n            aux_graph.remove_node(u)\n    else:\n        self.remaining_degree[u] -= 1\n    if self.remaining_degree[v] == 1:\n        del self.remaining_degree[v]\n        if aux_graph is not None:\n            aux_graph.remove_node(v)\n    else:\n        self.remaining_degree[v] -= 1",
            "def update_remaining(self, u, v, aux_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if aux_graph is not None:\n        aux_graph.remove_edge(u, v)\n    if self.remaining_degree[u] == 1:\n        del self.remaining_degree[u]\n        if aux_graph is not None:\n            aux_graph.remove_node(u)\n    else:\n        self.remaining_degree[u] -= 1\n    if self.remaining_degree[v] == 1:\n        del self.remaining_degree[v]\n        if aux_graph is not None:\n            aux_graph.remove_node(v)\n    else:\n        self.remaining_degree[v] -= 1"
        ]
    },
    {
        "func_name": "p",
        "original": "def p(self, u, v):\n    return 1 - self.degree[u] * self.degree[v] / (4.0 * self.m)",
        "mutated": [
            "def p(self, u, v):\n    if False:\n        i = 10\n    return 1 - self.degree[u] * self.degree[v] / (4.0 * self.m)",
            "def p(self, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 1 - self.degree[u] * self.degree[v] / (4.0 * self.m)",
            "def p(self, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 1 - self.degree[u] * self.degree[v] / (4.0 * self.m)",
            "def p(self, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 1 - self.degree[u] * self.degree[v] / (4.0 * self.m)",
            "def p(self, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 1 - self.degree[u] * self.degree[v] / (4.0 * self.m)"
        ]
    },
    {
        "func_name": "q",
        "original": "def q(self, u, v):\n    norm = max(self.remaining_degree.values()) ** 2\n    return self.remaining_degree[u] * self.remaining_degree[v] / norm",
        "mutated": [
            "def q(self, u, v):\n    if False:\n        i = 10\n    norm = max(self.remaining_degree.values()) ** 2\n    return self.remaining_degree[u] * self.remaining_degree[v] / norm",
            "def q(self, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    norm = max(self.remaining_degree.values()) ** 2\n    return self.remaining_degree[u] * self.remaining_degree[v] / norm",
            "def q(self, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    norm = max(self.remaining_degree.values()) ** 2\n    return self.remaining_degree[u] * self.remaining_degree[v] / norm",
            "def q(self, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    norm = max(self.remaining_degree.values()) ** 2\n    return self.remaining_degree[u] * self.remaining_degree[v] / norm",
            "def q(self, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    norm = max(self.remaining_degree.values()) ** 2\n    return self.remaining_degree[u] * self.remaining_degree[v] / norm"
        ]
    },
    {
        "func_name": "suitable_edge",
        "original": "def suitable_edge(self):\n    \"\"\"Returns True if and only if an arbitrary remaining node can\n        potentially be joined with some other remaining node.\n\n        \"\"\"\n    nodes = iter(self.remaining_degree)\n    u = next(nodes)\n    return any((v not in self.graph[u] for v in nodes))",
        "mutated": [
            "def suitable_edge(self):\n    if False:\n        i = 10\n    'Returns True if and only if an arbitrary remaining node can\\n        potentially be joined with some other remaining node.\\n\\n        '\n    nodes = iter(self.remaining_degree)\n    u = next(nodes)\n    return any((v not in self.graph[u] for v in nodes))",
            "def suitable_edge(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if and only if an arbitrary remaining node can\\n        potentially be joined with some other remaining node.\\n\\n        '\n    nodes = iter(self.remaining_degree)\n    u = next(nodes)\n    return any((v not in self.graph[u] for v in nodes))",
            "def suitable_edge(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if and only if an arbitrary remaining node can\\n        potentially be joined with some other remaining node.\\n\\n        '\n    nodes = iter(self.remaining_degree)\n    u = next(nodes)\n    return any((v not in self.graph[u] for v in nodes))",
            "def suitable_edge(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if and only if an arbitrary remaining node can\\n        potentially be joined with some other remaining node.\\n\\n        '\n    nodes = iter(self.remaining_degree)\n    u = next(nodes)\n    return any((v not in self.graph[u] for v in nodes))",
            "def suitable_edge(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if and only if an arbitrary remaining node can\\n        potentially be joined with some other remaining node.\\n\\n        '\n    nodes = iter(self.remaining_degree)\n    u = next(nodes)\n    return any((v not in self.graph[u] for v in nodes))"
        ]
    },
    {
        "func_name": "phase1",
        "original": "def phase1(self):\n    rem_deg = self.remaining_degree\n    while sum(rem_deg.values()) >= 2 * self.dmax ** 2:\n        (u, v) = sorted(random_weighted_sample(rem_deg, 2, self.rng))\n        if self.graph.has_edge(u, v):\n            continue\n        if self.rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
        "mutated": [
            "def phase1(self):\n    if False:\n        i = 10\n    rem_deg = self.remaining_degree\n    while sum(rem_deg.values()) >= 2 * self.dmax ** 2:\n        (u, v) = sorted(random_weighted_sample(rem_deg, 2, self.rng))\n        if self.graph.has_edge(u, v):\n            continue\n        if self.rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
            "def phase1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rem_deg = self.remaining_degree\n    while sum(rem_deg.values()) >= 2 * self.dmax ** 2:\n        (u, v) = sorted(random_weighted_sample(rem_deg, 2, self.rng))\n        if self.graph.has_edge(u, v):\n            continue\n        if self.rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
            "def phase1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rem_deg = self.remaining_degree\n    while sum(rem_deg.values()) >= 2 * self.dmax ** 2:\n        (u, v) = sorted(random_weighted_sample(rem_deg, 2, self.rng))\n        if self.graph.has_edge(u, v):\n            continue\n        if self.rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
            "def phase1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rem_deg = self.remaining_degree\n    while sum(rem_deg.values()) >= 2 * self.dmax ** 2:\n        (u, v) = sorted(random_weighted_sample(rem_deg, 2, self.rng))\n        if self.graph.has_edge(u, v):\n            continue\n        if self.rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
            "def phase1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rem_deg = self.remaining_degree\n    while sum(rem_deg.values()) >= 2 * self.dmax ** 2:\n        (u, v) = sorted(random_weighted_sample(rem_deg, 2, self.rng))\n        if self.graph.has_edge(u, v):\n            continue\n        if self.rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)"
        ]
    },
    {
        "func_name": "phase2",
        "original": "def phase2(self):\n    remaining_deg = self.remaining_degree\n    rng = self.rng\n    while len(remaining_deg) >= 2 * self.dmax:\n        while True:\n            (u, v) = sorted(rng.sample(list(remaining_deg.keys()), 2))\n            if self.graph.has_edge(u, v):\n                continue\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
        "mutated": [
            "def phase2(self):\n    if False:\n        i = 10\n    remaining_deg = self.remaining_degree\n    rng = self.rng\n    while len(remaining_deg) >= 2 * self.dmax:\n        while True:\n            (u, v) = sorted(rng.sample(list(remaining_deg.keys()), 2))\n            if self.graph.has_edge(u, v):\n                continue\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
            "def phase2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    remaining_deg = self.remaining_degree\n    rng = self.rng\n    while len(remaining_deg) >= 2 * self.dmax:\n        while True:\n            (u, v) = sorted(rng.sample(list(remaining_deg.keys()), 2))\n            if self.graph.has_edge(u, v):\n                continue\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
            "def phase2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    remaining_deg = self.remaining_degree\n    rng = self.rng\n    while len(remaining_deg) >= 2 * self.dmax:\n        while True:\n            (u, v) = sorted(rng.sample(list(remaining_deg.keys()), 2))\n            if self.graph.has_edge(u, v):\n                continue\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
            "def phase2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    remaining_deg = self.remaining_degree\n    rng = self.rng\n    while len(remaining_deg) >= 2 * self.dmax:\n        while True:\n            (u, v) = sorted(rng.sample(list(remaining_deg.keys()), 2))\n            if self.graph.has_edge(u, v):\n                continue\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)",
            "def phase2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    remaining_deg = self.remaining_degree\n    rng = self.rng\n    while len(remaining_deg) >= 2 * self.dmax:\n        while True:\n            (u, v) = sorted(rng.sample(list(remaining_deg.keys()), 2))\n            if self.graph.has_edge(u, v):\n                continue\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v)"
        ]
    },
    {
        "func_name": "phase3",
        "original": "def phase3(self):\n    potential_edges = combinations(self.remaining_degree, 2)\n    H = nx.Graph([(u, v) for (u, v) in potential_edges if not self.graph.has_edge(u, v)])\n    rng = self.rng\n    while self.remaining_degree:\n        if not self.suitable_edge():\n            raise nx.NetworkXUnfeasible('no suitable edges left')\n        while True:\n            (u, v) = sorted(rng.choice(list(H.edges())))\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v, aux_graph=H)",
        "mutated": [
            "def phase3(self):\n    if False:\n        i = 10\n    potential_edges = combinations(self.remaining_degree, 2)\n    H = nx.Graph([(u, v) for (u, v) in potential_edges if not self.graph.has_edge(u, v)])\n    rng = self.rng\n    while self.remaining_degree:\n        if not self.suitable_edge():\n            raise nx.NetworkXUnfeasible('no suitable edges left')\n        while True:\n            (u, v) = sorted(rng.choice(list(H.edges())))\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v, aux_graph=H)",
            "def phase3(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    potential_edges = combinations(self.remaining_degree, 2)\n    H = nx.Graph([(u, v) for (u, v) in potential_edges if not self.graph.has_edge(u, v)])\n    rng = self.rng\n    while self.remaining_degree:\n        if not self.suitable_edge():\n            raise nx.NetworkXUnfeasible('no suitable edges left')\n        while True:\n            (u, v) = sorted(rng.choice(list(H.edges())))\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v, aux_graph=H)",
            "def phase3(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    potential_edges = combinations(self.remaining_degree, 2)\n    H = nx.Graph([(u, v) for (u, v) in potential_edges if not self.graph.has_edge(u, v)])\n    rng = self.rng\n    while self.remaining_degree:\n        if not self.suitable_edge():\n            raise nx.NetworkXUnfeasible('no suitable edges left')\n        while True:\n            (u, v) = sorted(rng.choice(list(H.edges())))\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v, aux_graph=H)",
            "def phase3(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    potential_edges = combinations(self.remaining_degree, 2)\n    H = nx.Graph([(u, v) for (u, v) in potential_edges if not self.graph.has_edge(u, v)])\n    rng = self.rng\n    while self.remaining_degree:\n        if not self.suitable_edge():\n            raise nx.NetworkXUnfeasible('no suitable edges left')\n        while True:\n            (u, v) = sorted(rng.choice(list(H.edges())))\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v, aux_graph=H)",
            "def phase3(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    potential_edges = combinations(self.remaining_degree, 2)\n    H = nx.Graph([(u, v) for (u, v) in potential_edges if not self.graph.has_edge(u, v)])\n    rng = self.rng\n    while self.remaining_degree:\n        if not self.suitable_edge():\n            raise nx.NetworkXUnfeasible('no suitable edges left')\n        while True:\n            (u, v) = sorted(rng.choice(list(H.edges())))\n            if rng.random() < self.q(u, v):\n                break\n        if rng.random() < self.p(u, v):\n            self.graph.add_edge(u, v)\n            self.update_remaining(u, v, aux_graph=H)"
        ]
    }
]