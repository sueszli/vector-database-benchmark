[
    {
        "func_name": "_is_equal_tensor_proto",
        "original": "def _is_equal_tensor_proto(a, b):\n    name_a = a.name\n    name_b = b.name\n    a.name = ''\n    b.name = ''\n    res = a == b\n    a.name = name_a\n    b.name = name_b\n    return res",
        "mutated": [
            "def _is_equal_tensor_proto(a, b):\n    if False:\n        i = 10\n    name_a = a.name\n    name_b = b.name\n    a.name = ''\n    b.name = ''\n    res = a == b\n    a.name = name_a\n    b.name = name_b\n    return res",
            "def _is_equal_tensor_proto(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    name_a = a.name\n    name_b = b.name\n    a.name = ''\n    b.name = ''\n    res = a == b\n    a.name = name_a\n    b.name = name_b\n    return res",
            "def _is_equal_tensor_proto(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    name_a = a.name\n    name_b = b.name\n    a.name = ''\n    b.name = ''\n    res = a == b\n    a.name = name_a\n    b.name = name_b\n    return res",
            "def _is_equal_tensor_proto(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    name_a = a.name\n    name_b = b.name\n    a.name = ''\n    b.name = ''\n    res = a == b\n    a.name = name_a\n    b.name = name_b\n    return res",
            "def _is_equal_tensor_proto(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    name_a = a.name\n    name_b = b.name\n    a.name = ''\n    b.name = ''\n    res = a == b\n    a.name = name_a\n    b.name = name_b\n    return res"
        ]
    },
    {
        "func_name": "_node_replace_input_with",
        "original": "def _node_replace_input_with(node_proto, name, new_name):\n    for (i, input_name) in enumerate(node_proto.input):\n        if input_name == name:\n            node_proto.input.insert(i, new_name)\n            node_proto.input.pop(i + 1)\n    if node_proto.op_type == 'If':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)\n        _graph_replace_input_with(node_proto.attribute[1].g, name, new_name)\n    if node_proto.op_type == 'Loop':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)",
        "mutated": [
            "def _node_replace_input_with(node_proto, name, new_name):\n    if False:\n        i = 10\n    for (i, input_name) in enumerate(node_proto.input):\n        if input_name == name:\n            node_proto.input.insert(i, new_name)\n            node_proto.input.pop(i + 1)\n    if node_proto.op_type == 'If':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)\n        _graph_replace_input_with(node_proto.attribute[1].g, name, new_name)\n    if node_proto.op_type == 'Loop':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)",
            "def _node_replace_input_with(node_proto, name, new_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for (i, input_name) in enumerate(node_proto.input):\n        if input_name == name:\n            node_proto.input.insert(i, new_name)\n            node_proto.input.pop(i + 1)\n    if node_proto.op_type == 'If':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)\n        _graph_replace_input_with(node_proto.attribute[1].g, name, new_name)\n    if node_proto.op_type == 'Loop':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)",
            "def _node_replace_input_with(node_proto, name, new_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for (i, input_name) in enumerate(node_proto.input):\n        if input_name == name:\n            node_proto.input.insert(i, new_name)\n            node_proto.input.pop(i + 1)\n    if node_proto.op_type == 'If':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)\n        _graph_replace_input_with(node_proto.attribute[1].g, name, new_name)\n    if node_proto.op_type == 'Loop':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)",
            "def _node_replace_input_with(node_proto, name, new_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for (i, input_name) in enumerate(node_proto.input):\n        if input_name == name:\n            node_proto.input.insert(i, new_name)\n            node_proto.input.pop(i + 1)\n    if node_proto.op_type == 'If':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)\n        _graph_replace_input_with(node_proto.attribute[1].g, name, new_name)\n    if node_proto.op_type == 'Loop':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)",
            "def _node_replace_input_with(node_proto, name, new_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for (i, input_name) in enumerate(node_proto.input):\n        if input_name == name:\n            node_proto.input.insert(i, new_name)\n            node_proto.input.pop(i + 1)\n    if node_proto.op_type == 'If':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)\n        _graph_replace_input_with(node_proto.attribute[1].g, name, new_name)\n    if node_proto.op_type == 'Loop':\n        _graph_replace_input_with(node_proto.attribute[0].g, name, new_name)"
        ]
    },
    {
        "func_name": "_graph_replace_input_with",
        "original": "def _graph_replace_input_with(graph_proto, name, new_name):\n    for n in graph_proto.node:\n        _node_replace_input_with(n, name, new_name)",
        "mutated": [
            "def _graph_replace_input_with(graph_proto, name, new_name):\n    if False:\n        i = 10\n    for n in graph_proto.node:\n        _node_replace_input_with(n, name, new_name)",
            "def _graph_replace_input_with(graph_proto, name, new_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for n in graph_proto.node:\n        _node_replace_input_with(n, name, new_name)",
            "def _graph_replace_input_with(graph_proto, name, new_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for n in graph_proto.node:\n        _node_replace_input_with(n, name, new_name)",
            "def _graph_replace_input_with(graph_proto, name, new_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for n in graph_proto.node:\n        _node_replace_input_with(n, name, new_name)",
            "def _graph_replace_input_with(graph_proto, name, new_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for n in graph_proto.node:\n        _node_replace_input_with(n, name, new_name)"
        ]
    },
    {
        "func_name": "_remove_dup_initializers_from_model",
        "original": "def _remove_dup_initializers_from_model(model, model_without_ext, ind_to_replace):\n    inits_with_data = list(model.graph.initializer)\n    inits = list(model_without_ext.graph.initializer)\n    for (i, ref_i) in ind_to_replace:\n        assert inits_with_data[i].name == inits[i].name\n        assert inits_with_data[ref_i].name == inits[ref_i].name\n        assert i > ref_i\n        name_i = inits[i].name\n        name_ref = inits[ref_i].name\n        model_without_ext.graph.initializer.remove(inits[i])\n        _graph_replace_input_with(model_without_ext.graph, name_i, name_ref)",
        "mutated": [
            "def _remove_dup_initializers_from_model(model, model_without_ext, ind_to_replace):\n    if False:\n        i = 10\n    inits_with_data = list(model.graph.initializer)\n    inits = list(model_without_ext.graph.initializer)\n    for (i, ref_i) in ind_to_replace:\n        assert inits_with_data[i].name == inits[i].name\n        assert inits_with_data[ref_i].name == inits[ref_i].name\n        assert i > ref_i\n        name_i = inits[i].name\n        name_ref = inits[ref_i].name\n        model_without_ext.graph.initializer.remove(inits[i])\n        _graph_replace_input_with(model_without_ext.graph, name_i, name_ref)",
            "def _remove_dup_initializers_from_model(model, model_without_ext, ind_to_replace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    inits_with_data = list(model.graph.initializer)\n    inits = list(model_without_ext.graph.initializer)\n    for (i, ref_i) in ind_to_replace:\n        assert inits_with_data[i].name == inits[i].name\n        assert inits_with_data[ref_i].name == inits[ref_i].name\n        assert i > ref_i\n        name_i = inits[i].name\n        name_ref = inits[ref_i].name\n        model_without_ext.graph.initializer.remove(inits[i])\n        _graph_replace_input_with(model_without_ext.graph, name_i, name_ref)",
            "def _remove_dup_initializers_from_model(model, model_without_ext, ind_to_replace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    inits_with_data = list(model.graph.initializer)\n    inits = list(model_without_ext.graph.initializer)\n    for (i, ref_i) in ind_to_replace:\n        assert inits_with_data[i].name == inits[i].name\n        assert inits_with_data[ref_i].name == inits[ref_i].name\n        assert i > ref_i\n        name_i = inits[i].name\n        name_ref = inits[ref_i].name\n        model_without_ext.graph.initializer.remove(inits[i])\n        _graph_replace_input_with(model_without_ext.graph, name_i, name_ref)",
            "def _remove_dup_initializers_from_model(model, model_without_ext, ind_to_replace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    inits_with_data = list(model.graph.initializer)\n    inits = list(model_without_ext.graph.initializer)\n    for (i, ref_i) in ind_to_replace:\n        assert inits_with_data[i].name == inits[i].name\n        assert inits_with_data[ref_i].name == inits[ref_i].name\n        assert i > ref_i\n        name_i = inits[i].name\n        name_ref = inits[ref_i].name\n        model_without_ext.graph.initializer.remove(inits[i])\n        _graph_replace_input_with(model_without_ext.graph, name_i, name_ref)",
            "def _remove_dup_initializers_from_model(model, model_without_ext, ind_to_replace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    inits_with_data = list(model.graph.initializer)\n    inits = list(model_without_ext.graph.initializer)\n    for (i, ref_i) in ind_to_replace:\n        assert inits_with_data[i].name == inits[i].name\n        assert inits_with_data[ref_i].name == inits[ref_i].name\n        assert i > ref_i\n        name_i = inits[i].name\n        name_ref = inits[ref_i].name\n        model_without_ext.graph.initializer.remove(inits[i])\n        _graph_replace_input_with(model_without_ext.graph, name_i, name_ref)"
        ]
    },
    {
        "func_name": "remove_dup_initializers",
        "original": "def remove_dup_initializers(onnx_file_path):\n    \"\"\"\n    Removes duplicate initializers from the model to reduce its size.\n    Writes a new file in the same directory as onnx_file_path and returns the path to that file.\n    \"\"\"\n    model_file_folder = os.path.dirname(onnx_file_path)\n    model_file_name = os.path.basename(onnx_file_path)\n    model = onnx.load(os.path.join(model_file_folder, model_file_name))\n    inits = list(model.graph.initializer)\n    dup_set = set()\n    dup_map = {}\n    ind_to_replace = []\n    total_reduced_size = 0\n    for i in range(len(inits)):\n        if i in dup_set:\n            continue\n        for j in range(i + 1, len(inits)):\n            if j in dup_set:\n                continue\n            if _is_equal_tensor_proto(inits[i], inits[j]):\n                dup_set.add(i)\n                dup_set.add(j)\n                dtype = inits[j].data_type\n                mem_size = numpy.prod(inits[j].dims)\n                if dtype == 1:\n                    mem_size *= 4\n                elif dtype == 6:\n                    mem_size *= 4\n                elif dtype == 7 or dtype == 11:\n                    mem_size *= 8\n                else:\n                    print('unexpected data type: ', dtype)\n                total_reduced_size += mem_size\n                name_i = inits[i].name\n                name_j = inits[j].name\n                if name_i in dup_map:\n                    dup_map[name_i].append(name_j)\n                else:\n                    dup_map[name_i] = [name_j]\n                ind_to_replace.append((j, i))\n    print('total reduced size: ', total_reduced_size / 1024 / 1024 / 1024, 'GB')\n    ind_to_replace = sorted(ind_to_replace)\n    _remove_dup_initializers_from_model(model, model, ind_to_replace)\n    optimized_model_file_name = 'optimized_' + model_file_name\n    new_model = os.path.join(model_file_folder, optimized_model_file_name)\n    onnx.save(model, new_model)\n    return new_model",
        "mutated": [
            "def remove_dup_initializers(onnx_file_path):\n    if False:\n        i = 10\n    '\\n    Removes duplicate initializers from the model to reduce its size.\\n    Writes a new file in the same directory as onnx_file_path and returns the path to that file.\\n    '\n    model_file_folder = os.path.dirname(onnx_file_path)\n    model_file_name = os.path.basename(onnx_file_path)\n    model = onnx.load(os.path.join(model_file_folder, model_file_name))\n    inits = list(model.graph.initializer)\n    dup_set = set()\n    dup_map = {}\n    ind_to_replace = []\n    total_reduced_size = 0\n    for i in range(len(inits)):\n        if i in dup_set:\n            continue\n        for j in range(i + 1, len(inits)):\n            if j in dup_set:\n                continue\n            if _is_equal_tensor_proto(inits[i], inits[j]):\n                dup_set.add(i)\n                dup_set.add(j)\n                dtype = inits[j].data_type\n                mem_size = numpy.prod(inits[j].dims)\n                if dtype == 1:\n                    mem_size *= 4\n                elif dtype == 6:\n                    mem_size *= 4\n                elif dtype == 7 or dtype == 11:\n                    mem_size *= 8\n                else:\n                    print('unexpected data type: ', dtype)\n                total_reduced_size += mem_size\n                name_i = inits[i].name\n                name_j = inits[j].name\n                if name_i in dup_map:\n                    dup_map[name_i].append(name_j)\n                else:\n                    dup_map[name_i] = [name_j]\n                ind_to_replace.append((j, i))\n    print('total reduced size: ', total_reduced_size / 1024 / 1024 / 1024, 'GB')\n    ind_to_replace = sorted(ind_to_replace)\n    _remove_dup_initializers_from_model(model, model, ind_to_replace)\n    optimized_model_file_name = 'optimized_' + model_file_name\n    new_model = os.path.join(model_file_folder, optimized_model_file_name)\n    onnx.save(model, new_model)\n    return new_model",
            "def remove_dup_initializers(onnx_file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Removes duplicate initializers from the model to reduce its size.\\n    Writes a new file in the same directory as onnx_file_path and returns the path to that file.\\n    '\n    model_file_folder = os.path.dirname(onnx_file_path)\n    model_file_name = os.path.basename(onnx_file_path)\n    model = onnx.load(os.path.join(model_file_folder, model_file_name))\n    inits = list(model.graph.initializer)\n    dup_set = set()\n    dup_map = {}\n    ind_to_replace = []\n    total_reduced_size = 0\n    for i in range(len(inits)):\n        if i in dup_set:\n            continue\n        for j in range(i + 1, len(inits)):\n            if j in dup_set:\n                continue\n            if _is_equal_tensor_proto(inits[i], inits[j]):\n                dup_set.add(i)\n                dup_set.add(j)\n                dtype = inits[j].data_type\n                mem_size = numpy.prod(inits[j].dims)\n                if dtype == 1:\n                    mem_size *= 4\n                elif dtype == 6:\n                    mem_size *= 4\n                elif dtype == 7 or dtype == 11:\n                    mem_size *= 8\n                else:\n                    print('unexpected data type: ', dtype)\n                total_reduced_size += mem_size\n                name_i = inits[i].name\n                name_j = inits[j].name\n                if name_i in dup_map:\n                    dup_map[name_i].append(name_j)\n                else:\n                    dup_map[name_i] = [name_j]\n                ind_to_replace.append((j, i))\n    print('total reduced size: ', total_reduced_size / 1024 / 1024 / 1024, 'GB')\n    ind_to_replace = sorted(ind_to_replace)\n    _remove_dup_initializers_from_model(model, model, ind_to_replace)\n    optimized_model_file_name = 'optimized_' + model_file_name\n    new_model = os.path.join(model_file_folder, optimized_model_file_name)\n    onnx.save(model, new_model)\n    return new_model",
            "def remove_dup_initializers(onnx_file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Removes duplicate initializers from the model to reduce its size.\\n    Writes a new file in the same directory as onnx_file_path and returns the path to that file.\\n    '\n    model_file_folder = os.path.dirname(onnx_file_path)\n    model_file_name = os.path.basename(onnx_file_path)\n    model = onnx.load(os.path.join(model_file_folder, model_file_name))\n    inits = list(model.graph.initializer)\n    dup_set = set()\n    dup_map = {}\n    ind_to_replace = []\n    total_reduced_size = 0\n    for i in range(len(inits)):\n        if i in dup_set:\n            continue\n        for j in range(i + 1, len(inits)):\n            if j in dup_set:\n                continue\n            if _is_equal_tensor_proto(inits[i], inits[j]):\n                dup_set.add(i)\n                dup_set.add(j)\n                dtype = inits[j].data_type\n                mem_size = numpy.prod(inits[j].dims)\n                if dtype == 1:\n                    mem_size *= 4\n                elif dtype == 6:\n                    mem_size *= 4\n                elif dtype == 7 or dtype == 11:\n                    mem_size *= 8\n                else:\n                    print('unexpected data type: ', dtype)\n                total_reduced_size += mem_size\n                name_i = inits[i].name\n                name_j = inits[j].name\n                if name_i in dup_map:\n                    dup_map[name_i].append(name_j)\n                else:\n                    dup_map[name_i] = [name_j]\n                ind_to_replace.append((j, i))\n    print('total reduced size: ', total_reduced_size / 1024 / 1024 / 1024, 'GB')\n    ind_to_replace = sorted(ind_to_replace)\n    _remove_dup_initializers_from_model(model, model, ind_to_replace)\n    optimized_model_file_name = 'optimized_' + model_file_name\n    new_model = os.path.join(model_file_folder, optimized_model_file_name)\n    onnx.save(model, new_model)\n    return new_model",
            "def remove_dup_initializers(onnx_file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Removes duplicate initializers from the model to reduce its size.\\n    Writes a new file in the same directory as onnx_file_path and returns the path to that file.\\n    '\n    model_file_folder = os.path.dirname(onnx_file_path)\n    model_file_name = os.path.basename(onnx_file_path)\n    model = onnx.load(os.path.join(model_file_folder, model_file_name))\n    inits = list(model.graph.initializer)\n    dup_set = set()\n    dup_map = {}\n    ind_to_replace = []\n    total_reduced_size = 0\n    for i in range(len(inits)):\n        if i in dup_set:\n            continue\n        for j in range(i + 1, len(inits)):\n            if j in dup_set:\n                continue\n            if _is_equal_tensor_proto(inits[i], inits[j]):\n                dup_set.add(i)\n                dup_set.add(j)\n                dtype = inits[j].data_type\n                mem_size = numpy.prod(inits[j].dims)\n                if dtype == 1:\n                    mem_size *= 4\n                elif dtype == 6:\n                    mem_size *= 4\n                elif dtype == 7 or dtype == 11:\n                    mem_size *= 8\n                else:\n                    print('unexpected data type: ', dtype)\n                total_reduced_size += mem_size\n                name_i = inits[i].name\n                name_j = inits[j].name\n                if name_i in dup_map:\n                    dup_map[name_i].append(name_j)\n                else:\n                    dup_map[name_i] = [name_j]\n                ind_to_replace.append((j, i))\n    print('total reduced size: ', total_reduced_size / 1024 / 1024 / 1024, 'GB')\n    ind_to_replace = sorted(ind_to_replace)\n    _remove_dup_initializers_from_model(model, model, ind_to_replace)\n    optimized_model_file_name = 'optimized_' + model_file_name\n    new_model = os.path.join(model_file_folder, optimized_model_file_name)\n    onnx.save(model, new_model)\n    return new_model",
            "def remove_dup_initializers(onnx_file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Removes duplicate initializers from the model to reduce its size.\\n    Writes a new file in the same directory as onnx_file_path and returns the path to that file.\\n    '\n    model_file_folder = os.path.dirname(onnx_file_path)\n    model_file_name = os.path.basename(onnx_file_path)\n    model = onnx.load(os.path.join(model_file_folder, model_file_name))\n    inits = list(model.graph.initializer)\n    dup_set = set()\n    dup_map = {}\n    ind_to_replace = []\n    total_reduced_size = 0\n    for i in range(len(inits)):\n        if i in dup_set:\n            continue\n        for j in range(i + 1, len(inits)):\n            if j in dup_set:\n                continue\n            if _is_equal_tensor_proto(inits[i], inits[j]):\n                dup_set.add(i)\n                dup_set.add(j)\n                dtype = inits[j].data_type\n                mem_size = numpy.prod(inits[j].dims)\n                if dtype == 1:\n                    mem_size *= 4\n                elif dtype == 6:\n                    mem_size *= 4\n                elif dtype == 7 or dtype == 11:\n                    mem_size *= 8\n                else:\n                    print('unexpected data type: ', dtype)\n                total_reduced_size += mem_size\n                name_i = inits[i].name\n                name_j = inits[j].name\n                if name_i in dup_map:\n                    dup_map[name_i].append(name_j)\n                else:\n                    dup_map[name_i] = [name_j]\n                ind_to_replace.append((j, i))\n    print('total reduced size: ', total_reduced_size / 1024 / 1024 / 1024, 'GB')\n    ind_to_replace = sorted(ind_to_replace)\n    _remove_dup_initializers_from_model(model, model, ind_to_replace)\n    optimized_model_file_name = 'optimized_' + model_file_name\n    new_model = os.path.join(model_file_folder, optimized_model_file_name)\n    onnx.save(model, new_model)\n    return new_model"
        ]
    }
]