[
    {
        "func_name": "min_distance",
        "original": "def min_distance(word1, word2):\n    \"\"\"\n    Finds minimum distance by getting longest common subsequence\n\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))",
        "mutated": [
            "def min_distance(word1, word2):\n    if False:\n        i = 10\n    '\\n    Finds minimum distance by getting longest common subsequence\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))",
            "def min_distance(word1, word2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Finds minimum distance by getting longest common subsequence\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))",
            "def min_distance(word1, word2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Finds minimum distance by getting longest common subsequence\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))",
            "def min_distance(word1, word2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Finds minimum distance by getting longest common subsequence\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))",
            "def min_distance(word1, word2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Finds minimum distance by getting longest common subsequence\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))"
        ]
    },
    {
        "func_name": "lcs",
        "original": "def lcs(word1, word2, i, j):\n    \"\"\"\n    The length of longest common subsequence among the two given strings word1 and word2\n    \"\"\"\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))",
        "mutated": [
            "def lcs(word1, word2, i, j):\n    if False:\n        i = 10\n    '\\n    The length of longest common subsequence among the two given strings word1 and word2\\n    '\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))",
            "def lcs(word1, word2, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The length of longest common subsequence among the two given strings word1 and word2\\n    '\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))",
            "def lcs(word1, word2, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The length of longest common subsequence among the two given strings word1 and word2\\n    '\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))",
            "def lcs(word1, word2, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The length of longest common subsequence among the two given strings word1 and word2\\n    '\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))",
            "def lcs(word1, word2, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The length of longest common subsequence among the two given strings word1 and word2\\n    '\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))"
        ]
    },
    {
        "func_name": "min_distance_dp",
        "original": "def min_distance_dp(word1, word2):\n    \"\"\"\n    Finds minimum distance in a dynamic programming manner\n    TC: O(length1*length2), SC: O(length1*length2)\n\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    (length1, length2) = (len(word1) + 1, len(word2) + 1)\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n    if length1 == length2:\n        for i in range(1, length1):\n            (res[i][0], res[0][i]) = (i, i)\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i - 1] == word2[j - 1]:\n                res[i][j] = res[i - 1][j - 1]\n            else:\n                res[i][j] = min(res[i - 1][j], res[i][j - 1]) + 1\n    return res[len(word1)][len(word2)]",
        "mutated": [
            "def min_distance_dp(word1, word2):\n    if False:\n        i = 10\n    '\\n    Finds minimum distance in a dynamic programming manner\\n    TC: O(length1*length2), SC: O(length1*length2)\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    (length1, length2) = (len(word1) + 1, len(word2) + 1)\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n    if length1 == length2:\n        for i in range(1, length1):\n            (res[i][0], res[0][i]) = (i, i)\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i - 1] == word2[j - 1]:\n                res[i][j] = res[i - 1][j - 1]\n            else:\n                res[i][j] = min(res[i - 1][j], res[i][j - 1]) + 1\n    return res[len(word1)][len(word2)]",
            "def min_distance_dp(word1, word2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Finds minimum distance in a dynamic programming manner\\n    TC: O(length1*length2), SC: O(length1*length2)\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    (length1, length2) = (len(word1) + 1, len(word2) + 1)\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n    if length1 == length2:\n        for i in range(1, length1):\n            (res[i][0], res[0][i]) = (i, i)\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i - 1] == word2[j - 1]:\n                res[i][j] = res[i - 1][j - 1]\n            else:\n                res[i][j] = min(res[i - 1][j], res[i][j - 1]) + 1\n    return res[len(word1)][len(word2)]",
            "def min_distance_dp(word1, word2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Finds minimum distance in a dynamic programming manner\\n    TC: O(length1*length2), SC: O(length1*length2)\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    (length1, length2) = (len(word1) + 1, len(word2) + 1)\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n    if length1 == length2:\n        for i in range(1, length1):\n            (res[i][0], res[0][i]) = (i, i)\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i - 1] == word2[j - 1]:\n                res[i][j] = res[i - 1][j - 1]\n            else:\n                res[i][j] = min(res[i - 1][j], res[i][j - 1]) + 1\n    return res[len(word1)][len(word2)]",
            "def min_distance_dp(word1, word2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Finds minimum distance in a dynamic programming manner\\n    TC: O(length1*length2), SC: O(length1*length2)\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    (length1, length2) = (len(word1) + 1, len(word2) + 1)\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n    if length1 == length2:\n        for i in range(1, length1):\n            (res[i][0], res[0][i]) = (i, i)\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i - 1] == word2[j - 1]:\n                res[i][j] = res[i - 1][j - 1]\n            else:\n                res[i][j] = min(res[i - 1][j], res[i][j - 1]) + 1\n    return res[len(word1)][len(word2)]",
            "def min_distance_dp(word1, word2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Finds minimum distance in a dynamic programming manner\\n    TC: O(length1*length2), SC: O(length1*length2)\\n\\n    :type word1: str\\n    :type word2: str\\n    :rtype: int\\n    '\n    (length1, length2) = (len(word1) + 1, len(word2) + 1)\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n    if length1 == length2:\n        for i in range(1, length1):\n            (res[i][0], res[0][i]) = (i, i)\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i - 1] == word2[j - 1]:\n                res[i][j] = res[i - 1][j - 1]\n            else:\n                res[i][j] = min(res[i - 1][j], res[i][j - 1]) + 1\n    return res[len(word1)][len(word2)]"
        ]
    }
]