[
    {
        "func_name": "name",
        "original": "@staticmethod\ndef name():\n    return 'tap_tester_facebook_discovery_test'",
        "mutated": [
            "@staticmethod\ndef name():\n    if False:\n        i = 10\n    return 'tap_tester_facebook_discovery_test'",
            "@staticmethod\ndef name():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'tap_tester_facebook_discovery_test'",
            "@staticmethod\ndef name():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'tap_tester_facebook_discovery_test'",
            "@staticmethod\ndef name():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'tap_tester_facebook_discovery_test'",
            "@staticmethod\ndef name():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'tap_tester_facebook_discovery_test'"
        ]
    },
    {
        "func_name": "streams_to_test",
        "original": "def streams_to_test(self):\n    return self.expected_streams()",
        "mutated": [
            "def streams_to_test(self):\n    if False:\n        i = 10\n    return self.expected_streams()",
            "def streams_to_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.expected_streams()",
            "def streams_to_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.expected_streams()",
            "def streams_to_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.expected_streams()",
            "def streams_to_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.expected_streams()"
        ]
    },
    {
        "func_name": "test_run",
        "original": "def test_run(self):\n    \"\"\"\n        Testing that discovery creates the appropriate catalog with valid metadata.\n\n        \u2022 Verify number of actual streams discovered match expected\n        \u2022 Verify the stream names discovered were what we expect\n        \u2022 Verify stream names follow naming convention\n          streams should only have lowercase alphas and underscores\n        \u2022 verify there is only 1 top level breadcrumb\n        \u2022 verify replication key(s)\n        \u2022 verify primary key(s)\n        \u2022 verify that if there is a replication key we are doing INCREMENTAL otherwise FULL\n        \u2022 verify the actual replication matches our expected replication method\n        \u2022 verify that primary, replication and foreign keys\n          are given the inclusion of automatic.\n        \u2022 verify that all other fields have inclusion of available metadata.\n        \"\"\"\n    streams_to_test = self.streams_to_test()\n    conn_id = connections.ensure_connection(self)\n    found_catalogs = self.run_and_verify_check_mode(conn_id)\n    found_catalog_names = {c['tap_stream_id'] for c in found_catalogs}\n    self.assertTrue(all([re.fullmatch('[a-z_]+', name) for name in found_catalog_names]), msg=\"One or more streams don't follow standard naming\")\n    for stream in streams_to_test:\n        with self.subTest(stream=stream):\n            catalog = next(iter([catalog for catalog in found_catalogs if catalog['stream_name'] == stream]))\n            self.assertIsNotNone(catalog)\n            expected_primary_keys = self.expected_primary_keys()[stream]\n            expected_replication_keys = self.expected_replication_keys()[stream]\n            expected_automatic_fields = expected_primary_keys | expected_replication_keys\n            expected_replication_method = self.expected_replication_method()[stream]\n            schema_and_metadata = menagerie.get_annotated_schema(conn_id, catalog['stream_id'])\n            metadata = schema_and_metadata['metadata']\n            stream_properties = [item for item in metadata if item.get('breadcrumb') == []]\n            actual_primary_keys = set(stream_properties[0].get('metadata', {self.PRIMARY_KEYS: []}).get(self.PRIMARY_KEYS, []))\n            actual_replication_keys = set(stream_properties[0].get('metadata', {self.REPLICATION_KEYS: []}).get(self.REPLICATION_KEYS, []))\n            actual_replication_method = stream_properties[0].get('metadata', {self.REPLICATION_METHOD: None}).get(self.REPLICATION_METHOD)\n            actual_automatic_fields = set((item.get('breadcrumb', ['properties', None])[1] for item in metadata if item.get('metadata').get('inclusion') == 'automatic'))\n            self.assertTrue(len(stream_properties) == 1, msg='There is NOT only one top level breadcrumb for {}'.format(stream) + '\\nstream_properties | {}'.format(stream_properties))\n            self.assertSetEqual(expected_replication_keys, actual_replication_keys)\n            self.assertSetEqual(expected_primary_keys, actual_primary_keys)\n            self.assertEqual(expected_replication_method, actual_replication_method)\n            if actual_replication_keys:\n                self.assertEqual(self.INCREMENTAL, actual_replication_method)\n            else:\n                self.assertEqual(self.FULL_TABLE, actual_replication_method)\n            self.assertSetEqual(expected_automatic_fields, actual_automatic_fields)\n            self.assertTrue(all({item.get('metadata').get('inclusion') == 'available' for item in metadata if item.get('breadcrumb', []) != [] and item.get('breadcrumb', ['properties', None])[1] not in actual_automatic_fields}), msg='Not all non key properties are set to available in metadata')",
        "mutated": [
            "def test_run(self):\n    if False:\n        i = 10\n    '\\n        Testing that discovery creates the appropriate catalog with valid metadata.\\n\\n        \u2022 Verify number of actual streams discovered match expected\\n        \u2022 Verify the stream names discovered were what we expect\\n        \u2022 Verify stream names follow naming convention\\n          streams should only have lowercase alphas and underscores\\n        \u2022 verify there is only 1 top level breadcrumb\\n        \u2022 verify replication key(s)\\n        \u2022 verify primary key(s)\\n        \u2022 verify that if there is a replication key we are doing INCREMENTAL otherwise FULL\\n        \u2022 verify the actual replication matches our expected replication method\\n        \u2022 verify that primary, replication and foreign keys\\n          are given the inclusion of automatic.\\n        \u2022 verify that all other fields have inclusion of available metadata.\\n        '\n    streams_to_test = self.streams_to_test()\n    conn_id = connections.ensure_connection(self)\n    found_catalogs = self.run_and_verify_check_mode(conn_id)\n    found_catalog_names = {c['tap_stream_id'] for c in found_catalogs}\n    self.assertTrue(all([re.fullmatch('[a-z_]+', name) for name in found_catalog_names]), msg=\"One or more streams don't follow standard naming\")\n    for stream in streams_to_test:\n        with self.subTest(stream=stream):\n            catalog = next(iter([catalog for catalog in found_catalogs if catalog['stream_name'] == stream]))\n            self.assertIsNotNone(catalog)\n            expected_primary_keys = self.expected_primary_keys()[stream]\n            expected_replication_keys = self.expected_replication_keys()[stream]\n            expected_automatic_fields = expected_primary_keys | expected_replication_keys\n            expected_replication_method = self.expected_replication_method()[stream]\n            schema_and_metadata = menagerie.get_annotated_schema(conn_id, catalog['stream_id'])\n            metadata = schema_and_metadata['metadata']\n            stream_properties = [item for item in metadata if item.get('breadcrumb') == []]\n            actual_primary_keys = set(stream_properties[0].get('metadata', {self.PRIMARY_KEYS: []}).get(self.PRIMARY_KEYS, []))\n            actual_replication_keys = set(stream_properties[0].get('metadata', {self.REPLICATION_KEYS: []}).get(self.REPLICATION_KEYS, []))\n            actual_replication_method = stream_properties[0].get('metadata', {self.REPLICATION_METHOD: None}).get(self.REPLICATION_METHOD)\n            actual_automatic_fields = set((item.get('breadcrumb', ['properties', None])[1] for item in metadata if item.get('metadata').get('inclusion') == 'automatic'))\n            self.assertTrue(len(stream_properties) == 1, msg='There is NOT only one top level breadcrumb for {}'.format(stream) + '\\nstream_properties | {}'.format(stream_properties))\n            self.assertSetEqual(expected_replication_keys, actual_replication_keys)\n            self.assertSetEqual(expected_primary_keys, actual_primary_keys)\n            self.assertEqual(expected_replication_method, actual_replication_method)\n            if actual_replication_keys:\n                self.assertEqual(self.INCREMENTAL, actual_replication_method)\n            else:\n                self.assertEqual(self.FULL_TABLE, actual_replication_method)\n            self.assertSetEqual(expected_automatic_fields, actual_automatic_fields)\n            self.assertTrue(all({item.get('metadata').get('inclusion') == 'available' for item in metadata if item.get('breadcrumb', []) != [] and item.get('breadcrumb', ['properties', None])[1] not in actual_automatic_fields}), msg='Not all non key properties are set to available in metadata')",
            "def test_run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Testing that discovery creates the appropriate catalog with valid metadata.\\n\\n        \u2022 Verify number of actual streams discovered match expected\\n        \u2022 Verify the stream names discovered were what we expect\\n        \u2022 Verify stream names follow naming convention\\n          streams should only have lowercase alphas and underscores\\n        \u2022 verify there is only 1 top level breadcrumb\\n        \u2022 verify replication key(s)\\n        \u2022 verify primary key(s)\\n        \u2022 verify that if there is a replication key we are doing INCREMENTAL otherwise FULL\\n        \u2022 verify the actual replication matches our expected replication method\\n        \u2022 verify that primary, replication and foreign keys\\n          are given the inclusion of automatic.\\n        \u2022 verify that all other fields have inclusion of available metadata.\\n        '\n    streams_to_test = self.streams_to_test()\n    conn_id = connections.ensure_connection(self)\n    found_catalogs = self.run_and_verify_check_mode(conn_id)\n    found_catalog_names = {c['tap_stream_id'] for c in found_catalogs}\n    self.assertTrue(all([re.fullmatch('[a-z_]+', name) for name in found_catalog_names]), msg=\"One or more streams don't follow standard naming\")\n    for stream in streams_to_test:\n        with self.subTest(stream=stream):\n            catalog = next(iter([catalog for catalog in found_catalogs if catalog['stream_name'] == stream]))\n            self.assertIsNotNone(catalog)\n            expected_primary_keys = self.expected_primary_keys()[stream]\n            expected_replication_keys = self.expected_replication_keys()[stream]\n            expected_automatic_fields = expected_primary_keys | expected_replication_keys\n            expected_replication_method = self.expected_replication_method()[stream]\n            schema_and_metadata = menagerie.get_annotated_schema(conn_id, catalog['stream_id'])\n            metadata = schema_and_metadata['metadata']\n            stream_properties = [item for item in metadata if item.get('breadcrumb') == []]\n            actual_primary_keys = set(stream_properties[0].get('metadata', {self.PRIMARY_KEYS: []}).get(self.PRIMARY_KEYS, []))\n            actual_replication_keys = set(stream_properties[0].get('metadata', {self.REPLICATION_KEYS: []}).get(self.REPLICATION_KEYS, []))\n            actual_replication_method = stream_properties[0].get('metadata', {self.REPLICATION_METHOD: None}).get(self.REPLICATION_METHOD)\n            actual_automatic_fields = set((item.get('breadcrumb', ['properties', None])[1] for item in metadata if item.get('metadata').get('inclusion') == 'automatic'))\n            self.assertTrue(len(stream_properties) == 1, msg='There is NOT only one top level breadcrumb for {}'.format(stream) + '\\nstream_properties | {}'.format(stream_properties))\n            self.assertSetEqual(expected_replication_keys, actual_replication_keys)\n            self.assertSetEqual(expected_primary_keys, actual_primary_keys)\n            self.assertEqual(expected_replication_method, actual_replication_method)\n            if actual_replication_keys:\n                self.assertEqual(self.INCREMENTAL, actual_replication_method)\n            else:\n                self.assertEqual(self.FULL_TABLE, actual_replication_method)\n            self.assertSetEqual(expected_automatic_fields, actual_automatic_fields)\n            self.assertTrue(all({item.get('metadata').get('inclusion') == 'available' for item in metadata if item.get('breadcrumb', []) != [] and item.get('breadcrumb', ['properties', None])[1] not in actual_automatic_fields}), msg='Not all non key properties are set to available in metadata')",
            "def test_run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Testing that discovery creates the appropriate catalog with valid metadata.\\n\\n        \u2022 Verify number of actual streams discovered match expected\\n        \u2022 Verify the stream names discovered were what we expect\\n        \u2022 Verify stream names follow naming convention\\n          streams should only have lowercase alphas and underscores\\n        \u2022 verify there is only 1 top level breadcrumb\\n        \u2022 verify replication key(s)\\n        \u2022 verify primary key(s)\\n        \u2022 verify that if there is a replication key we are doing INCREMENTAL otherwise FULL\\n        \u2022 verify the actual replication matches our expected replication method\\n        \u2022 verify that primary, replication and foreign keys\\n          are given the inclusion of automatic.\\n        \u2022 verify that all other fields have inclusion of available metadata.\\n        '\n    streams_to_test = self.streams_to_test()\n    conn_id = connections.ensure_connection(self)\n    found_catalogs = self.run_and_verify_check_mode(conn_id)\n    found_catalog_names = {c['tap_stream_id'] for c in found_catalogs}\n    self.assertTrue(all([re.fullmatch('[a-z_]+', name) for name in found_catalog_names]), msg=\"One or more streams don't follow standard naming\")\n    for stream in streams_to_test:\n        with self.subTest(stream=stream):\n            catalog = next(iter([catalog for catalog in found_catalogs if catalog['stream_name'] == stream]))\n            self.assertIsNotNone(catalog)\n            expected_primary_keys = self.expected_primary_keys()[stream]\n            expected_replication_keys = self.expected_replication_keys()[stream]\n            expected_automatic_fields = expected_primary_keys | expected_replication_keys\n            expected_replication_method = self.expected_replication_method()[stream]\n            schema_and_metadata = menagerie.get_annotated_schema(conn_id, catalog['stream_id'])\n            metadata = schema_and_metadata['metadata']\n            stream_properties = [item for item in metadata if item.get('breadcrumb') == []]\n            actual_primary_keys = set(stream_properties[0].get('metadata', {self.PRIMARY_KEYS: []}).get(self.PRIMARY_KEYS, []))\n            actual_replication_keys = set(stream_properties[0].get('metadata', {self.REPLICATION_KEYS: []}).get(self.REPLICATION_KEYS, []))\n            actual_replication_method = stream_properties[0].get('metadata', {self.REPLICATION_METHOD: None}).get(self.REPLICATION_METHOD)\n            actual_automatic_fields = set((item.get('breadcrumb', ['properties', None])[1] for item in metadata if item.get('metadata').get('inclusion') == 'automatic'))\n            self.assertTrue(len(stream_properties) == 1, msg='There is NOT only one top level breadcrumb for {}'.format(stream) + '\\nstream_properties | {}'.format(stream_properties))\n            self.assertSetEqual(expected_replication_keys, actual_replication_keys)\n            self.assertSetEqual(expected_primary_keys, actual_primary_keys)\n            self.assertEqual(expected_replication_method, actual_replication_method)\n            if actual_replication_keys:\n                self.assertEqual(self.INCREMENTAL, actual_replication_method)\n            else:\n                self.assertEqual(self.FULL_TABLE, actual_replication_method)\n            self.assertSetEqual(expected_automatic_fields, actual_automatic_fields)\n            self.assertTrue(all({item.get('metadata').get('inclusion') == 'available' for item in metadata if item.get('breadcrumb', []) != [] and item.get('breadcrumb', ['properties', None])[1] not in actual_automatic_fields}), msg='Not all non key properties are set to available in metadata')",
            "def test_run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Testing that discovery creates the appropriate catalog with valid metadata.\\n\\n        \u2022 Verify number of actual streams discovered match expected\\n        \u2022 Verify the stream names discovered were what we expect\\n        \u2022 Verify stream names follow naming convention\\n          streams should only have lowercase alphas and underscores\\n        \u2022 verify there is only 1 top level breadcrumb\\n        \u2022 verify replication key(s)\\n        \u2022 verify primary key(s)\\n        \u2022 verify that if there is a replication key we are doing INCREMENTAL otherwise FULL\\n        \u2022 verify the actual replication matches our expected replication method\\n        \u2022 verify that primary, replication and foreign keys\\n          are given the inclusion of automatic.\\n        \u2022 verify that all other fields have inclusion of available metadata.\\n        '\n    streams_to_test = self.streams_to_test()\n    conn_id = connections.ensure_connection(self)\n    found_catalogs = self.run_and_verify_check_mode(conn_id)\n    found_catalog_names = {c['tap_stream_id'] for c in found_catalogs}\n    self.assertTrue(all([re.fullmatch('[a-z_]+', name) for name in found_catalog_names]), msg=\"One or more streams don't follow standard naming\")\n    for stream in streams_to_test:\n        with self.subTest(stream=stream):\n            catalog = next(iter([catalog for catalog in found_catalogs if catalog['stream_name'] == stream]))\n            self.assertIsNotNone(catalog)\n            expected_primary_keys = self.expected_primary_keys()[stream]\n            expected_replication_keys = self.expected_replication_keys()[stream]\n            expected_automatic_fields = expected_primary_keys | expected_replication_keys\n            expected_replication_method = self.expected_replication_method()[stream]\n            schema_and_metadata = menagerie.get_annotated_schema(conn_id, catalog['stream_id'])\n            metadata = schema_and_metadata['metadata']\n            stream_properties = [item for item in metadata if item.get('breadcrumb') == []]\n            actual_primary_keys = set(stream_properties[0].get('metadata', {self.PRIMARY_KEYS: []}).get(self.PRIMARY_KEYS, []))\n            actual_replication_keys = set(stream_properties[0].get('metadata', {self.REPLICATION_KEYS: []}).get(self.REPLICATION_KEYS, []))\n            actual_replication_method = stream_properties[0].get('metadata', {self.REPLICATION_METHOD: None}).get(self.REPLICATION_METHOD)\n            actual_automatic_fields = set((item.get('breadcrumb', ['properties', None])[1] for item in metadata if item.get('metadata').get('inclusion') == 'automatic'))\n            self.assertTrue(len(stream_properties) == 1, msg='There is NOT only one top level breadcrumb for {}'.format(stream) + '\\nstream_properties | {}'.format(stream_properties))\n            self.assertSetEqual(expected_replication_keys, actual_replication_keys)\n            self.assertSetEqual(expected_primary_keys, actual_primary_keys)\n            self.assertEqual(expected_replication_method, actual_replication_method)\n            if actual_replication_keys:\n                self.assertEqual(self.INCREMENTAL, actual_replication_method)\n            else:\n                self.assertEqual(self.FULL_TABLE, actual_replication_method)\n            self.assertSetEqual(expected_automatic_fields, actual_automatic_fields)\n            self.assertTrue(all({item.get('metadata').get('inclusion') == 'available' for item in metadata if item.get('breadcrumb', []) != [] and item.get('breadcrumb', ['properties', None])[1] not in actual_automatic_fields}), msg='Not all non key properties are set to available in metadata')",
            "def test_run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Testing that discovery creates the appropriate catalog with valid metadata.\\n\\n        \u2022 Verify number of actual streams discovered match expected\\n        \u2022 Verify the stream names discovered were what we expect\\n        \u2022 Verify stream names follow naming convention\\n          streams should only have lowercase alphas and underscores\\n        \u2022 verify there is only 1 top level breadcrumb\\n        \u2022 verify replication key(s)\\n        \u2022 verify primary key(s)\\n        \u2022 verify that if there is a replication key we are doing INCREMENTAL otherwise FULL\\n        \u2022 verify the actual replication matches our expected replication method\\n        \u2022 verify that primary, replication and foreign keys\\n          are given the inclusion of automatic.\\n        \u2022 verify that all other fields have inclusion of available metadata.\\n        '\n    streams_to_test = self.streams_to_test()\n    conn_id = connections.ensure_connection(self)\n    found_catalogs = self.run_and_verify_check_mode(conn_id)\n    found_catalog_names = {c['tap_stream_id'] for c in found_catalogs}\n    self.assertTrue(all([re.fullmatch('[a-z_]+', name) for name in found_catalog_names]), msg=\"One or more streams don't follow standard naming\")\n    for stream in streams_to_test:\n        with self.subTest(stream=stream):\n            catalog = next(iter([catalog for catalog in found_catalogs if catalog['stream_name'] == stream]))\n            self.assertIsNotNone(catalog)\n            expected_primary_keys = self.expected_primary_keys()[stream]\n            expected_replication_keys = self.expected_replication_keys()[stream]\n            expected_automatic_fields = expected_primary_keys | expected_replication_keys\n            expected_replication_method = self.expected_replication_method()[stream]\n            schema_and_metadata = menagerie.get_annotated_schema(conn_id, catalog['stream_id'])\n            metadata = schema_and_metadata['metadata']\n            stream_properties = [item for item in metadata if item.get('breadcrumb') == []]\n            actual_primary_keys = set(stream_properties[0].get('metadata', {self.PRIMARY_KEYS: []}).get(self.PRIMARY_KEYS, []))\n            actual_replication_keys = set(stream_properties[0].get('metadata', {self.REPLICATION_KEYS: []}).get(self.REPLICATION_KEYS, []))\n            actual_replication_method = stream_properties[0].get('metadata', {self.REPLICATION_METHOD: None}).get(self.REPLICATION_METHOD)\n            actual_automatic_fields = set((item.get('breadcrumb', ['properties', None])[1] for item in metadata if item.get('metadata').get('inclusion') == 'automatic'))\n            self.assertTrue(len(stream_properties) == 1, msg='There is NOT only one top level breadcrumb for {}'.format(stream) + '\\nstream_properties | {}'.format(stream_properties))\n            self.assertSetEqual(expected_replication_keys, actual_replication_keys)\n            self.assertSetEqual(expected_primary_keys, actual_primary_keys)\n            self.assertEqual(expected_replication_method, actual_replication_method)\n            if actual_replication_keys:\n                self.assertEqual(self.INCREMENTAL, actual_replication_method)\n            else:\n                self.assertEqual(self.FULL_TABLE, actual_replication_method)\n            self.assertSetEqual(expected_automatic_fields, actual_automatic_fields)\n            self.assertTrue(all({item.get('metadata').get('inclusion') == 'available' for item in metadata if item.get('breadcrumb', []) != [] and item.get('breadcrumb', ['properties', None])[1] not in actual_automatic_fields}), msg='Not all non key properties are set to available in metadata')"
        ]
    }
]