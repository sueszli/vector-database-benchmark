[
    {
        "func_name": "dfs",
        "original": "def dfs(node):\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK",
        "mutated": [
            "def dfs(node):\n    if False:\n        i = 10\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK",
            "def dfs(node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK",
            "def dfs(node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK",
            "def dfs(node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK",
            "def dfs(node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK"
        ]
    },
    {
        "func_name": "top_sort_recursive",
        "original": "def top_sort_recursive(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order",
        "mutated": [
            "def top_sort_recursive(graph):\n    if False:\n        i = 10\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order",
            "def top_sort_recursive(graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order",
            "def top_sort_recursive(graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order",
            "def top_sort_recursive(graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order",
            "def top_sort_recursive(graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order"
        ]
    },
    {
        "func_name": "is_ready",
        "original": "def is_ready(node):\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True",
        "mutated": [
            "def is_ready(node):\n    if False:\n        i = 10\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True",
            "def is_ready(node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True",
            "def is_ready(node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True",
            "def is_ready(node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True",
            "def is_ready(node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True"
        ]
    },
    {
        "func_name": "top_sort",
        "original": "def top_sort(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order",
        "mutated": [
            "def top_sort(graph):\n    if False:\n        i = 10\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order",
            "def top_sort(graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order",
            "def top_sort(graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order",
            "def top_sort(graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order",
            "def top_sort(graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Time complexity is the same as DFS, which is O(V + E)\\n        Space complexity: O(V)\\n    '\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order"
        ]
    }
]