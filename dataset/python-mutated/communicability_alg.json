[
    {
        "func_name": "communicability",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability(G):\n    \"\"\"Returns communicability between all pairs of nodes in G.\n\n    The communicability between pairs of nodes in G is the sum of\n    walks of different lengths starting at node u and ending at node v.\n\n    Parameters\n    ----------\n    G: graph\n\n    Returns\n    -------\n    comm: dictionary of dictionaries\n        Dictionary of dictionaries keyed by nodes with communicability\n        as the value.\n\n    Raises\n    ------\n    NetworkXError\n       If the graph is not undirected and simple.\n\n    See Also\n    --------\n    communicability_exp:\n       Communicability between all pairs of nodes in G  using spectral\n       decomposition.\n    communicability_betweenness_centrality:\n       Communicability betweenness centrality for each node in G.\n\n    Notes\n    -----\n    This algorithm uses a spectral decomposition of the adjacency matrix.\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\n    the powers  of the adjacency matrix and the number of walks in the graph,\n    the communicability  between nodes `u` and `v` based on the graph spectrum\n    is [1]_\n\n    .. math::\n        C(u,v)=\\\\sum_{j=1}^{n}\\\\phi_{j}(u)\\\\phi_{j}(v)e^{\\\\lambda_{j}},\n\n    where `\\\\phi_{j}(u)` is the `u\\\\rm{th}` element of the `j\\\\rm{th}` orthonormal\n    eigenvector of the adjacency matrix associated with the eigenvalue\n    `\\\\lambda_{j}`.\n\n    References\n    ----------\n    .. [1] Ernesto Estrada, Naomichi Hatano,\n       \"Communicability in complex networks\",\n       Phys. Rev. E 77, 036111 (2008).\n       https://arxiv.org/abs/0707.0756\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\n    >>> c = nx.communicability(G)\n    \"\"\"\n    import numpy as np\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    (w, vec) = np.linalg.eigh(A)\n    expw = np.exp(w)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            s = 0\n            p = mapping[u]\n            q = mapping[v]\n            for j in range(len(nodelist)):\n                s += vec[:, j][p] * vec[:, j][q] * expw[j]\n            c[u][v] = float(s)\n    return c",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability(G):\n    if False:\n        i = 10\n    'Returns communicability between all pairs of nodes in G.\\n\\n    The communicability between pairs of nodes in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n       If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability_exp:\\n       Communicability between all pairs of nodes in G  using spectral\\n       decomposition.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses a spectral decomposition of the adjacency matrix.\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability  between nodes `u` and `v` based on the graph spectrum\\n    is [1]_\\n\\n    .. math::\\n        C(u,v)=\\\\sum_{j=1}^{n}\\\\phi_{j}(u)\\\\phi_{j}(v)e^{\\\\lambda_{j}},\\n\\n    where `\\\\phi_{j}(u)` is the `u\\\\rm{th}` element of the `j\\\\rm{th}` orthonormal\\n    eigenvector of the adjacency matrix associated with the eigenvalue\\n    `\\\\lambda_{j}`.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability(G)\\n    '\n    import numpy as np\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    (w, vec) = np.linalg.eigh(A)\n    expw = np.exp(w)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            s = 0\n            p = mapping[u]\n            q = mapping[v]\n            for j in range(len(nodelist)):\n                s += vec[:, j][p] * vec[:, j][q] * expw[j]\n            c[u][v] = float(s)\n    return c",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns communicability between all pairs of nodes in G.\\n\\n    The communicability between pairs of nodes in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n       If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability_exp:\\n       Communicability between all pairs of nodes in G  using spectral\\n       decomposition.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses a spectral decomposition of the adjacency matrix.\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability  between nodes `u` and `v` based on the graph spectrum\\n    is [1]_\\n\\n    .. math::\\n        C(u,v)=\\\\sum_{j=1}^{n}\\\\phi_{j}(u)\\\\phi_{j}(v)e^{\\\\lambda_{j}},\\n\\n    where `\\\\phi_{j}(u)` is the `u\\\\rm{th}` element of the `j\\\\rm{th}` orthonormal\\n    eigenvector of the adjacency matrix associated with the eigenvalue\\n    `\\\\lambda_{j}`.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability(G)\\n    '\n    import numpy as np\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    (w, vec) = np.linalg.eigh(A)\n    expw = np.exp(w)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            s = 0\n            p = mapping[u]\n            q = mapping[v]\n            for j in range(len(nodelist)):\n                s += vec[:, j][p] * vec[:, j][q] * expw[j]\n            c[u][v] = float(s)\n    return c",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns communicability between all pairs of nodes in G.\\n\\n    The communicability between pairs of nodes in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n       If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability_exp:\\n       Communicability between all pairs of nodes in G  using spectral\\n       decomposition.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses a spectral decomposition of the adjacency matrix.\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability  between nodes `u` and `v` based on the graph spectrum\\n    is [1]_\\n\\n    .. math::\\n        C(u,v)=\\\\sum_{j=1}^{n}\\\\phi_{j}(u)\\\\phi_{j}(v)e^{\\\\lambda_{j}},\\n\\n    where `\\\\phi_{j}(u)` is the `u\\\\rm{th}` element of the `j\\\\rm{th}` orthonormal\\n    eigenvector of the adjacency matrix associated with the eigenvalue\\n    `\\\\lambda_{j}`.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability(G)\\n    '\n    import numpy as np\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    (w, vec) = np.linalg.eigh(A)\n    expw = np.exp(w)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            s = 0\n            p = mapping[u]\n            q = mapping[v]\n            for j in range(len(nodelist)):\n                s += vec[:, j][p] * vec[:, j][q] * expw[j]\n            c[u][v] = float(s)\n    return c",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns communicability between all pairs of nodes in G.\\n\\n    The communicability between pairs of nodes in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n       If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability_exp:\\n       Communicability between all pairs of nodes in G  using spectral\\n       decomposition.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses a spectral decomposition of the adjacency matrix.\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability  between nodes `u` and `v` based on the graph spectrum\\n    is [1]_\\n\\n    .. math::\\n        C(u,v)=\\\\sum_{j=1}^{n}\\\\phi_{j}(u)\\\\phi_{j}(v)e^{\\\\lambda_{j}},\\n\\n    where `\\\\phi_{j}(u)` is the `u\\\\rm{th}` element of the `j\\\\rm{th}` orthonormal\\n    eigenvector of the adjacency matrix associated with the eigenvalue\\n    `\\\\lambda_{j}`.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability(G)\\n    '\n    import numpy as np\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    (w, vec) = np.linalg.eigh(A)\n    expw = np.exp(w)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            s = 0\n            p = mapping[u]\n            q = mapping[v]\n            for j in range(len(nodelist)):\n                s += vec[:, j][p] * vec[:, j][q] * expw[j]\n            c[u][v] = float(s)\n    return c",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns communicability between all pairs of nodes in G.\\n\\n    The communicability between pairs of nodes in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n       If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability_exp:\\n       Communicability between all pairs of nodes in G  using spectral\\n       decomposition.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses a spectral decomposition of the adjacency matrix.\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability  between nodes `u` and `v` based on the graph spectrum\\n    is [1]_\\n\\n    .. math::\\n        C(u,v)=\\\\sum_{j=1}^{n}\\\\phi_{j}(u)\\\\phi_{j}(v)e^{\\\\lambda_{j}},\\n\\n    where `\\\\phi_{j}(u)` is the `u\\\\rm{th}` element of the `j\\\\rm{th}` orthonormal\\n    eigenvector of the adjacency matrix associated with the eigenvalue\\n    `\\\\lambda_{j}`.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability(G)\\n    '\n    import numpy as np\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    (w, vec) = np.linalg.eigh(A)\n    expw = np.exp(w)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            s = 0\n            p = mapping[u]\n            q = mapping[v]\n            for j in range(len(nodelist)):\n                s += vec[:, j][p] * vec[:, j][q] * expw[j]\n            c[u][v] = float(s)\n    return c"
        ]
    },
    {
        "func_name": "communicability_exp",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability_exp(G):\n    \"\"\"Returns communicability between all pairs of nodes in G.\n\n    Communicability between pair of node (u,v) of node in G is the sum of\n    walks of different lengths starting at node u and ending at node v.\n\n    Parameters\n    ----------\n    G: graph\n\n    Returns\n    -------\n    comm: dictionary of dictionaries\n        Dictionary of dictionaries keyed by nodes with communicability\n        as the value.\n\n    Raises\n    ------\n    NetworkXError\n        If the graph is not undirected and simple.\n\n    See Also\n    --------\n    communicability:\n       Communicability between pairs of nodes in G.\n    communicability_betweenness_centrality:\n       Communicability betweenness centrality for each node in G.\n\n    Notes\n    -----\n    This algorithm uses matrix exponentiation of the adjacency matrix.\n\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\n    the powers  of the adjacency matrix and the number of walks in the graph,\n    the communicability between nodes u and v is [1]_,\n\n    .. math::\n        C(u,v) = (e^A)_{uv},\n\n    where `A` is the adjacency matrix of G.\n\n    References\n    ----------\n    .. [1] Ernesto Estrada, Naomichi Hatano,\n       \"Communicability in complex networks\",\n       Phys. Rev. E 77, 036111 (2008).\n       https://arxiv.org/abs/0707.0756\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\n    >>> c = nx.communicability_exp(G)\n    \"\"\"\n    import scipy as sp\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    expA = sp.linalg.expm(A)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            c[u][v] = float(expA[mapping[u], mapping[v]])\n    return c",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability_exp(G):\n    if False:\n        i = 10\n    'Returns communicability between all pairs of nodes in G.\\n\\n    Communicability between pair of node (u,v) of node in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability:\\n       Communicability between pairs of nodes in G.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses matrix exponentiation of the adjacency matrix.\\n\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability between nodes u and v is [1]_,\\n\\n    .. math::\\n        C(u,v) = (e^A)_{uv},\\n\\n    where `A` is the adjacency matrix of G.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability_exp(G)\\n    '\n    import scipy as sp\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    expA = sp.linalg.expm(A)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            c[u][v] = float(expA[mapping[u], mapping[v]])\n    return c",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability_exp(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns communicability between all pairs of nodes in G.\\n\\n    Communicability between pair of node (u,v) of node in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability:\\n       Communicability between pairs of nodes in G.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses matrix exponentiation of the adjacency matrix.\\n\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability between nodes u and v is [1]_,\\n\\n    .. math::\\n        C(u,v) = (e^A)_{uv},\\n\\n    where `A` is the adjacency matrix of G.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability_exp(G)\\n    '\n    import scipy as sp\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    expA = sp.linalg.expm(A)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            c[u][v] = float(expA[mapping[u], mapping[v]])\n    return c",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability_exp(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns communicability between all pairs of nodes in G.\\n\\n    Communicability between pair of node (u,v) of node in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability:\\n       Communicability between pairs of nodes in G.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses matrix exponentiation of the adjacency matrix.\\n\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability between nodes u and v is [1]_,\\n\\n    .. math::\\n        C(u,v) = (e^A)_{uv},\\n\\n    where `A` is the adjacency matrix of G.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability_exp(G)\\n    '\n    import scipy as sp\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    expA = sp.linalg.expm(A)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            c[u][v] = float(expA[mapping[u], mapping[v]])\n    return c",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability_exp(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns communicability between all pairs of nodes in G.\\n\\n    Communicability between pair of node (u,v) of node in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability:\\n       Communicability between pairs of nodes in G.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses matrix exponentiation of the adjacency matrix.\\n\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability between nodes u and v is [1]_,\\n\\n    .. math::\\n        C(u,v) = (e^A)_{uv},\\n\\n    where `A` is the adjacency matrix of G.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability_exp(G)\\n    '\n    import scipy as sp\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    expA = sp.linalg.expm(A)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            c[u][v] = float(expA[mapping[u], mapping[v]])\n    return c",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef communicability_exp(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns communicability between all pairs of nodes in G.\\n\\n    Communicability between pair of node (u,v) of node in G is the sum of\\n    walks of different lengths starting at node u and ending at node v.\\n\\n    Parameters\\n    ----------\\n    G: graph\\n\\n    Returns\\n    -------\\n    comm: dictionary of dictionaries\\n        Dictionary of dictionaries keyed by nodes with communicability\\n        as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is not undirected and simple.\\n\\n    See Also\\n    --------\\n    communicability:\\n       Communicability between pairs of nodes in G.\\n    communicability_betweenness_centrality:\\n       Communicability betweenness centrality for each node in G.\\n\\n    Notes\\n    -----\\n    This algorithm uses matrix exponentiation of the adjacency matrix.\\n\\n    Let G=(V,E) be a simple undirected graph.  Using the connection between\\n    the powers  of the adjacency matrix and the number of walks in the graph,\\n    the communicability between nodes u and v is [1]_,\\n\\n    .. math::\\n        C(u,v) = (e^A)_{uv},\\n\\n    where `A` is the adjacency matrix of G.\\n\\n    References\\n    ----------\\n    .. [1] Ernesto Estrada, Naomichi Hatano,\\n       \"Communicability in complex networks\",\\n       Phys. Rev. E 77, 036111 (2008).\\n       https://arxiv.org/abs/0707.0756\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\\n    >>> c = nx.communicability_exp(G)\\n    '\n    import scipy as sp\n    nodelist = list(G)\n    A = nx.to_numpy_array(G, nodelist)\n    A[A != 0.0] = 1\n    expA = sp.linalg.expm(A)\n    mapping = dict(zip(nodelist, range(len(nodelist))))\n    c = {}\n    for u in G:\n        c[u] = {}\n        for v in G:\n            c[u][v] = float(expA[mapping[u], mapping[v]])\n    return c"
        ]
    }
]