[
    {
        "func_name": "_select_train_warm_items",
        "original": "def _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=None):\n    \"\"\"\n    Selects a certain percentage of the URM_all WARM items and splits the URM in two\n    IMPORTANT: the number of items to be sampled is not computed with respect to the shape of the URM but with respect\n    to the number of WARM items it contains. Cold items don't count.\n    :param URM_all:\n    :param train_item_percentage:\n    :param train_interaction_percentage:\n    :return:\n    \"\"\"\n    sample_successful = False\n    terminate = False\n    n_interactions = URM_all.nnz\n    URM = sps.csc_matrix(URM_all)\n    item_interactions = np.ediff1d(URM.indptr)\n    n_warm_items = np.sum(item_interactions > 0)\n    n_train_items = int(n_warm_items * train_item_percentage)\n    indices_for_sampling = np.arange(0, URM_all.shape[1], dtype=np.int)[item_interactions > 0]\n    np.random.shuffle(indices_for_sampling)\n    while not terminate:\n        if n_train_items == n_warm_items and n_train_items > 1:\n            n_train_items -= 1\n        train_items = indices_for_sampling[0:n_train_items]\n        if train_interaction_percentage is not None:\n            train_interactions = np.sum(item_interactions[train_items])\n            current_train_interaction_percentage = train_interactions / n_interactions\n            if current_train_interaction_percentage < train_interaction_percentage * 0.9:\n                if n_train_items == n_warm_items:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items += 1\n            elif current_train_interaction_percentage > train_interaction_percentage * 1.1:\n                if n_train_items == 1:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items -= 1\n            else:\n                terminate = True\n                sample_successful = True\n        else:\n            terminate = True\n            sample_successful = True\n    assert sample_successful, 'Unable to select the train items with the desired specifications'\n    return train_items",
        "mutated": [
            "def _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=None):\n    if False:\n        i = 10\n    \"\\n    Selects a certain percentage of the URM_all WARM items and splits the URM in two\\n    IMPORTANT: the number of items to be sampled is not computed with respect to the shape of the URM but with respect\\n    to the number of WARM items it contains. Cold items don't count.\\n    :param URM_all:\\n    :param train_item_percentage:\\n    :param train_interaction_percentage:\\n    :return:\\n    \"\n    sample_successful = False\n    terminate = False\n    n_interactions = URM_all.nnz\n    URM = sps.csc_matrix(URM_all)\n    item_interactions = np.ediff1d(URM.indptr)\n    n_warm_items = np.sum(item_interactions > 0)\n    n_train_items = int(n_warm_items * train_item_percentage)\n    indices_for_sampling = np.arange(0, URM_all.shape[1], dtype=np.int)[item_interactions > 0]\n    np.random.shuffle(indices_for_sampling)\n    while not terminate:\n        if n_train_items == n_warm_items and n_train_items > 1:\n            n_train_items -= 1\n        train_items = indices_for_sampling[0:n_train_items]\n        if train_interaction_percentage is not None:\n            train_interactions = np.sum(item_interactions[train_items])\n            current_train_interaction_percentage = train_interactions / n_interactions\n            if current_train_interaction_percentage < train_interaction_percentage * 0.9:\n                if n_train_items == n_warm_items:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items += 1\n            elif current_train_interaction_percentage > train_interaction_percentage * 1.1:\n                if n_train_items == 1:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items -= 1\n            else:\n                terminate = True\n                sample_successful = True\n        else:\n            terminate = True\n            sample_successful = True\n    assert sample_successful, 'Unable to select the train items with the desired specifications'\n    return train_items",
            "def _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Selects a certain percentage of the URM_all WARM items and splits the URM in two\\n    IMPORTANT: the number of items to be sampled is not computed with respect to the shape of the URM but with respect\\n    to the number of WARM items it contains. Cold items don't count.\\n    :param URM_all:\\n    :param train_item_percentage:\\n    :param train_interaction_percentage:\\n    :return:\\n    \"\n    sample_successful = False\n    terminate = False\n    n_interactions = URM_all.nnz\n    URM = sps.csc_matrix(URM_all)\n    item_interactions = np.ediff1d(URM.indptr)\n    n_warm_items = np.sum(item_interactions > 0)\n    n_train_items = int(n_warm_items * train_item_percentage)\n    indices_for_sampling = np.arange(0, URM_all.shape[1], dtype=np.int)[item_interactions > 0]\n    np.random.shuffle(indices_for_sampling)\n    while not terminate:\n        if n_train_items == n_warm_items and n_train_items > 1:\n            n_train_items -= 1\n        train_items = indices_for_sampling[0:n_train_items]\n        if train_interaction_percentage is not None:\n            train_interactions = np.sum(item_interactions[train_items])\n            current_train_interaction_percentage = train_interactions / n_interactions\n            if current_train_interaction_percentage < train_interaction_percentage * 0.9:\n                if n_train_items == n_warm_items:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items += 1\n            elif current_train_interaction_percentage > train_interaction_percentage * 1.1:\n                if n_train_items == 1:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items -= 1\n            else:\n                terminate = True\n                sample_successful = True\n        else:\n            terminate = True\n            sample_successful = True\n    assert sample_successful, 'Unable to select the train items with the desired specifications'\n    return train_items",
            "def _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Selects a certain percentage of the URM_all WARM items and splits the URM in two\\n    IMPORTANT: the number of items to be sampled is not computed with respect to the shape of the URM but with respect\\n    to the number of WARM items it contains. Cold items don't count.\\n    :param URM_all:\\n    :param train_item_percentage:\\n    :param train_interaction_percentage:\\n    :return:\\n    \"\n    sample_successful = False\n    terminate = False\n    n_interactions = URM_all.nnz\n    URM = sps.csc_matrix(URM_all)\n    item_interactions = np.ediff1d(URM.indptr)\n    n_warm_items = np.sum(item_interactions > 0)\n    n_train_items = int(n_warm_items * train_item_percentage)\n    indices_for_sampling = np.arange(0, URM_all.shape[1], dtype=np.int)[item_interactions > 0]\n    np.random.shuffle(indices_for_sampling)\n    while not terminate:\n        if n_train_items == n_warm_items and n_train_items > 1:\n            n_train_items -= 1\n        train_items = indices_for_sampling[0:n_train_items]\n        if train_interaction_percentage is not None:\n            train_interactions = np.sum(item_interactions[train_items])\n            current_train_interaction_percentage = train_interactions / n_interactions\n            if current_train_interaction_percentage < train_interaction_percentage * 0.9:\n                if n_train_items == n_warm_items:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items += 1\n            elif current_train_interaction_percentage > train_interaction_percentage * 1.1:\n                if n_train_items == 1:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items -= 1\n            else:\n                terminate = True\n                sample_successful = True\n        else:\n            terminate = True\n            sample_successful = True\n    assert sample_successful, 'Unable to select the train items with the desired specifications'\n    return train_items",
            "def _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Selects a certain percentage of the URM_all WARM items and splits the URM in two\\n    IMPORTANT: the number of items to be sampled is not computed with respect to the shape of the URM but with respect\\n    to the number of WARM items it contains. Cold items don't count.\\n    :param URM_all:\\n    :param train_item_percentage:\\n    :param train_interaction_percentage:\\n    :return:\\n    \"\n    sample_successful = False\n    terminate = False\n    n_interactions = URM_all.nnz\n    URM = sps.csc_matrix(URM_all)\n    item_interactions = np.ediff1d(URM.indptr)\n    n_warm_items = np.sum(item_interactions > 0)\n    n_train_items = int(n_warm_items * train_item_percentage)\n    indices_for_sampling = np.arange(0, URM_all.shape[1], dtype=np.int)[item_interactions > 0]\n    np.random.shuffle(indices_for_sampling)\n    while not terminate:\n        if n_train_items == n_warm_items and n_train_items > 1:\n            n_train_items -= 1\n        train_items = indices_for_sampling[0:n_train_items]\n        if train_interaction_percentage is not None:\n            train_interactions = np.sum(item_interactions[train_items])\n            current_train_interaction_percentage = train_interactions / n_interactions\n            if current_train_interaction_percentage < train_interaction_percentage * 0.9:\n                if n_train_items == n_warm_items:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items += 1\n            elif current_train_interaction_percentage > train_interaction_percentage * 1.1:\n                if n_train_items == 1:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items -= 1\n            else:\n                terminate = True\n                sample_successful = True\n        else:\n            terminate = True\n            sample_successful = True\n    assert sample_successful, 'Unable to select the train items with the desired specifications'\n    return train_items",
            "def _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Selects a certain percentage of the URM_all WARM items and splits the URM in two\\n    IMPORTANT: the number of items to be sampled is not computed with respect to the shape of the URM but with respect\\n    to the number of WARM items it contains. Cold items don't count.\\n    :param URM_all:\\n    :param train_item_percentage:\\n    :param train_interaction_percentage:\\n    :return:\\n    \"\n    sample_successful = False\n    terminate = False\n    n_interactions = URM_all.nnz\n    URM = sps.csc_matrix(URM_all)\n    item_interactions = np.ediff1d(URM.indptr)\n    n_warm_items = np.sum(item_interactions > 0)\n    n_train_items = int(n_warm_items * train_item_percentage)\n    indices_for_sampling = np.arange(0, URM_all.shape[1], dtype=np.int)[item_interactions > 0]\n    np.random.shuffle(indices_for_sampling)\n    while not terminate:\n        if n_train_items == n_warm_items and n_train_items > 1:\n            n_train_items -= 1\n        train_items = indices_for_sampling[0:n_train_items]\n        if train_interaction_percentage is not None:\n            train_interactions = np.sum(item_interactions[train_items])\n            current_train_interaction_percentage = train_interactions / n_interactions\n            if current_train_interaction_percentage < train_interaction_percentage * 0.9:\n                if n_train_items == n_warm_items:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items += 1\n            elif current_train_interaction_percentage > train_interaction_percentage * 1.1:\n                if n_train_items == 1:\n                    terminate = True\n                    sample_successful = False\n                else:\n                    n_train_items -= 1\n            else:\n                terminate = True\n                sample_successful = True\n        else:\n            terminate = True\n            sample_successful = True\n    assert sample_successful, 'Unable to select the train items with the desired specifications'\n    return train_items"
        ]
    },
    {
        "func_name": "_zero_out_values",
        "original": "def _zero_out_values(sparse_matrix, columns_to_zero=None, rows_to_zero=None):\n    if rows_to_zero is not None:\n        sparse_matrix = sps.csr_matrix(sparse_matrix)\n        for n_row in rows_to_zero:\n            start_pos = sparse_matrix.indptr[n_row]\n            end_pos = sparse_matrix.indptr[n_row + 1]\n            sparse_matrix.data[start_pos:end_pos] = np.zeros_like(sparse_matrix.data[start_pos:end_pos])\n        sparse_matrix.eliminate_zeros()\n    if columns_to_zero is not None:\n        sparse_matrix = _zero_out_values(sparse_matrix.T, rows_to_zero=columns_to_zero).T\n    sparse_matrix = sps.csr_matrix(sparse_matrix)\n    return sparse_matrix",
        "mutated": [
            "def _zero_out_values(sparse_matrix, columns_to_zero=None, rows_to_zero=None):\n    if False:\n        i = 10\n    if rows_to_zero is not None:\n        sparse_matrix = sps.csr_matrix(sparse_matrix)\n        for n_row in rows_to_zero:\n            start_pos = sparse_matrix.indptr[n_row]\n            end_pos = sparse_matrix.indptr[n_row + 1]\n            sparse_matrix.data[start_pos:end_pos] = np.zeros_like(sparse_matrix.data[start_pos:end_pos])\n        sparse_matrix.eliminate_zeros()\n    if columns_to_zero is not None:\n        sparse_matrix = _zero_out_values(sparse_matrix.T, rows_to_zero=columns_to_zero).T\n    sparse_matrix = sps.csr_matrix(sparse_matrix)\n    return sparse_matrix",
            "def _zero_out_values(sparse_matrix, columns_to_zero=None, rows_to_zero=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if rows_to_zero is not None:\n        sparse_matrix = sps.csr_matrix(sparse_matrix)\n        for n_row in rows_to_zero:\n            start_pos = sparse_matrix.indptr[n_row]\n            end_pos = sparse_matrix.indptr[n_row + 1]\n            sparse_matrix.data[start_pos:end_pos] = np.zeros_like(sparse_matrix.data[start_pos:end_pos])\n        sparse_matrix.eliminate_zeros()\n    if columns_to_zero is not None:\n        sparse_matrix = _zero_out_values(sparse_matrix.T, rows_to_zero=columns_to_zero).T\n    sparse_matrix = sps.csr_matrix(sparse_matrix)\n    return sparse_matrix",
            "def _zero_out_values(sparse_matrix, columns_to_zero=None, rows_to_zero=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if rows_to_zero is not None:\n        sparse_matrix = sps.csr_matrix(sparse_matrix)\n        for n_row in rows_to_zero:\n            start_pos = sparse_matrix.indptr[n_row]\n            end_pos = sparse_matrix.indptr[n_row + 1]\n            sparse_matrix.data[start_pos:end_pos] = np.zeros_like(sparse_matrix.data[start_pos:end_pos])\n        sparse_matrix.eliminate_zeros()\n    if columns_to_zero is not None:\n        sparse_matrix = _zero_out_values(sparse_matrix.T, rows_to_zero=columns_to_zero).T\n    sparse_matrix = sps.csr_matrix(sparse_matrix)\n    return sparse_matrix",
            "def _zero_out_values(sparse_matrix, columns_to_zero=None, rows_to_zero=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if rows_to_zero is not None:\n        sparse_matrix = sps.csr_matrix(sparse_matrix)\n        for n_row in rows_to_zero:\n            start_pos = sparse_matrix.indptr[n_row]\n            end_pos = sparse_matrix.indptr[n_row + 1]\n            sparse_matrix.data[start_pos:end_pos] = np.zeros_like(sparse_matrix.data[start_pos:end_pos])\n        sparse_matrix.eliminate_zeros()\n    if columns_to_zero is not None:\n        sparse_matrix = _zero_out_values(sparse_matrix.T, rows_to_zero=columns_to_zero).T\n    sparse_matrix = sps.csr_matrix(sparse_matrix)\n    return sparse_matrix",
            "def _zero_out_values(sparse_matrix, columns_to_zero=None, rows_to_zero=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if rows_to_zero is not None:\n        sparse_matrix = sps.csr_matrix(sparse_matrix)\n        for n_row in rows_to_zero:\n            start_pos = sparse_matrix.indptr[n_row]\n            end_pos = sparse_matrix.indptr[n_row + 1]\n            sparse_matrix.data[start_pos:end_pos] = np.zeros_like(sparse_matrix.data[start_pos:end_pos])\n        sparse_matrix.eliminate_zeros()\n    if columns_to_zero is not None:\n        sparse_matrix = _zero_out_values(sparse_matrix.T, rows_to_zero=columns_to_zero).T\n    sparse_matrix = sps.csr_matrix(sparse_matrix)\n    return sparse_matrix"
        ]
    },
    {
        "func_name": "split_train_in_two_cold_items",
        "original": "def split_train_in_two_cold_items(URM_all, ICM_list=None, train_item_percentage=0.1, train_interaction_percentage=None):\n    \"\"\"\n    The function splits an URM in two matrices selecting the number of interactions one user at a time\n    :param URM_train:\n    :param train_percentage:\n    :param verbose:\n    :return:\n    \"\"\"\n    assert train_item_percentage >= 0.0 and train_item_percentage <= 1.0, \"train_item_percentage must be a value between 0.0 and 1.0, provided was '{}'\".format(train_item_percentage)\n    URM_all = sps.csc_matrix(URM_all)\n    (n_users, n_items) = URM_all.shape\n    train_items = _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=train_interaction_percentage)\n    validation_items_mask = np.ones(n_items, dtype=np.bool)\n    validation_items_mask[train_items] = False\n    validation_items = np.arange(0, n_items, dtype=np.int)[validation_items_mask]\n    URM_train = _zero_out_values(URM_all.copy(), columns_to_zero=validation_items)\n    URM_validation = _zero_out_values(URM_all.copy(), columns_to_zero=train_items)\n    if ICM_list is not None:\n        ICM_train_list = []\n        ICM_valiation_list = []\n        for ICM_object in ICM_list:\n            ICM_object_train = _zero_out_values(ICM_object.copy(), rows_to_zero=validation_items)\n            ICM_object_validation = _zero_out_values(ICM_object.copy(), rows_to_zero=train_items)\n            ICM_train_list.append(ICM_object_train)\n            ICM_valiation_list.append(ICM_object_validation)\n        return (URM_train, URM_validation, ICM_train_list, ICM_valiation_list, train_items)\n    else:\n        return (URM_train, URM_validation, train_items)",
        "mutated": [
            "def split_train_in_two_cold_items(URM_all, ICM_list=None, train_item_percentage=0.1, train_interaction_percentage=None):\n    if False:\n        i = 10\n    '\\n    The function splits an URM in two matrices selecting the number of interactions one user at a time\\n    :param URM_train:\\n    :param train_percentage:\\n    :param verbose:\\n    :return:\\n    '\n    assert train_item_percentage >= 0.0 and train_item_percentage <= 1.0, \"train_item_percentage must be a value between 0.0 and 1.0, provided was '{}'\".format(train_item_percentage)\n    URM_all = sps.csc_matrix(URM_all)\n    (n_users, n_items) = URM_all.shape\n    train_items = _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=train_interaction_percentage)\n    validation_items_mask = np.ones(n_items, dtype=np.bool)\n    validation_items_mask[train_items] = False\n    validation_items = np.arange(0, n_items, dtype=np.int)[validation_items_mask]\n    URM_train = _zero_out_values(URM_all.copy(), columns_to_zero=validation_items)\n    URM_validation = _zero_out_values(URM_all.copy(), columns_to_zero=train_items)\n    if ICM_list is not None:\n        ICM_train_list = []\n        ICM_valiation_list = []\n        for ICM_object in ICM_list:\n            ICM_object_train = _zero_out_values(ICM_object.copy(), rows_to_zero=validation_items)\n            ICM_object_validation = _zero_out_values(ICM_object.copy(), rows_to_zero=train_items)\n            ICM_train_list.append(ICM_object_train)\n            ICM_valiation_list.append(ICM_object_validation)\n        return (URM_train, URM_validation, ICM_train_list, ICM_valiation_list, train_items)\n    else:\n        return (URM_train, URM_validation, train_items)",
            "def split_train_in_two_cold_items(URM_all, ICM_list=None, train_item_percentage=0.1, train_interaction_percentage=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The function splits an URM in two matrices selecting the number of interactions one user at a time\\n    :param URM_train:\\n    :param train_percentage:\\n    :param verbose:\\n    :return:\\n    '\n    assert train_item_percentage >= 0.0 and train_item_percentage <= 1.0, \"train_item_percentage must be a value between 0.0 and 1.0, provided was '{}'\".format(train_item_percentage)\n    URM_all = sps.csc_matrix(URM_all)\n    (n_users, n_items) = URM_all.shape\n    train_items = _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=train_interaction_percentage)\n    validation_items_mask = np.ones(n_items, dtype=np.bool)\n    validation_items_mask[train_items] = False\n    validation_items = np.arange(0, n_items, dtype=np.int)[validation_items_mask]\n    URM_train = _zero_out_values(URM_all.copy(), columns_to_zero=validation_items)\n    URM_validation = _zero_out_values(URM_all.copy(), columns_to_zero=train_items)\n    if ICM_list is not None:\n        ICM_train_list = []\n        ICM_valiation_list = []\n        for ICM_object in ICM_list:\n            ICM_object_train = _zero_out_values(ICM_object.copy(), rows_to_zero=validation_items)\n            ICM_object_validation = _zero_out_values(ICM_object.copy(), rows_to_zero=train_items)\n            ICM_train_list.append(ICM_object_train)\n            ICM_valiation_list.append(ICM_object_validation)\n        return (URM_train, URM_validation, ICM_train_list, ICM_valiation_list, train_items)\n    else:\n        return (URM_train, URM_validation, train_items)",
            "def split_train_in_two_cold_items(URM_all, ICM_list=None, train_item_percentage=0.1, train_interaction_percentage=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The function splits an URM in two matrices selecting the number of interactions one user at a time\\n    :param URM_train:\\n    :param train_percentage:\\n    :param verbose:\\n    :return:\\n    '\n    assert train_item_percentage >= 0.0 and train_item_percentage <= 1.0, \"train_item_percentage must be a value between 0.0 and 1.0, provided was '{}'\".format(train_item_percentage)\n    URM_all = sps.csc_matrix(URM_all)\n    (n_users, n_items) = URM_all.shape\n    train_items = _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=train_interaction_percentage)\n    validation_items_mask = np.ones(n_items, dtype=np.bool)\n    validation_items_mask[train_items] = False\n    validation_items = np.arange(0, n_items, dtype=np.int)[validation_items_mask]\n    URM_train = _zero_out_values(URM_all.copy(), columns_to_zero=validation_items)\n    URM_validation = _zero_out_values(URM_all.copy(), columns_to_zero=train_items)\n    if ICM_list is not None:\n        ICM_train_list = []\n        ICM_valiation_list = []\n        for ICM_object in ICM_list:\n            ICM_object_train = _zero_out_values(ICM_object.copy(), rows_to_zero=validation_items)\n            ICM_object_validation = _zero_out_values(ICM_object.copy(), rows_to_zero=train_items)\n            ICM_train_list.append(ICM_object_train)\n            ICM_valiation_list.append(ICM_object_validation)\n        return (URM_train, URM_validation, ICM_train_list, ICM_valiation_list, train_items)\n    else:\n        return (URM_train, URM_validation, train_items)",
            "def split_train_in_two_cold_items(URM_all, ICM_list=None, train_item_percentage=0.1, train_interaction_percentage=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The function splits an URM in two matrices selecting the number of interactions one user at a time\\n    :param URM_train:\\n    :param train_percentage:\\n    :param verbose:\\n    :return:\\n    '\n    assert train_item_percentage >= 0.0 and train_item_percentage <= 1.0, \"train_item_percentage must be a value between 0.0 and 1.0, provided was '{}'\".format(train_item_percentage)\n    URM_all = sps.csc_matrix(URM_all)\n    (n_users, n_items) = URM_all.shape\n    train_items = _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=train_interaction_percentage)\n    validation_items_mask = np.ones(n_items, dtype=np.bool)\n    validation_items_mask[train_items] = False\n    validation_items = np.arange(0, n_items, dtype=np.int)[validation_items_mask]\n    URM_train = _zero_out_values(URM_all.copy(), columns_to_zero=validation_items)\n    URM_validation = _zero_out_values(URM_all.copy(), columns_to_zero=train_items)\n    if ICM_list is not None:\n        ICM_train_list = []\n        ICM_valiation_list = []\n        for ICM_object in ICM_list:\n            ICM_object_train = _zero_out_values(ICM_object.copy(), rows_to_zero=validation_items)\n            ICM_object_validation = _zero_out_values(ICM_object.copy(), rows_to_zero=train_items)\n            ICM_train_list.append(ICM_object_train)\n            ICM_valiation_list.append(ICM_object_validation)\n        return (URM_train, URM_validation, ICM_train_list, ICM_valiation_list, train_items)\n    else:\n        return (URM_train, URM_validation, train_items)",
            "def split_train_in_two_cold_items(URM_all, ICM_list=None, train_item_percentage=0.1, train_interaction_percentage=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The function splits an URM in two matrices selecting the number of interactions one user at a time\\n    :param URM_train:\\n    :param train_percentage:\\n    :param verbose:\\n    :return:\\n    '\n    assert train_item_percentage >= 0.0 and train_item_percentage <= 1.0, \"train_item_percentage must be a value between 0.0 and 1.0, provided was '{}'\".format(train_item_percentage)\n    URM_all = sps.csc_matrix(URM_all)\n    (n_users, n_items) = URM_all.shape\n    train_items = _select_train_warm_items(URM_all, train_item_percentage, train_interaction_percentage=train_interaction_percentage)\n    validation_items_mask = np.ones(n_items, dtype=np.bool)\n    validation_items_mask[train_items] = False\n    validation_items = np.arange(0, n_items, dtype=np.int)[validation_items_mask]\n    URM_train = _zero_out_values(URM_all.copy(), columns_to_zero=validation_items)\n    URM_validation = _zero_out_values(URM_all.copy(), columns_to_zero=train_items)\n    if ICM_list is not None:\n        ICM_train_list = []\n        ICM_valiation_list = []\n        for ICM_object in ICM_list:\n            ICM_object_train = _zero_out_values(ICM_object.copy(), rows_to_zero=validation_items)\n            ICM_object_validation = _zero_out_values(ICM_object.copy(), rows_to_zero=train_items)\n            ICM_train_list.append(ICM_object_train)\n            ICM_valiation_list.append(ICM_object_validation)\n        return (URM_train, URM_validation, ICM_train_list, ICM_valiation_list, train_items)\n    else:\n        return (URM_train, URM_validation, train_items)"
        ]
    }
]