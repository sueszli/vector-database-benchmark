[
    {
        "func_name": "difference_delta",
        "original": "def difference_delta(expr, n=None, step=1):\n    \"\"\"Difference Operator.\n\n    Explanation\n    ===========\n\n    Discrete analog of differential operator. Given a sequence x[n],\n    returns the sequence x[n + step] - x[n].\n\n    Examples\n    ========\n\n    >>> from sympy import difference_delta as dd\n    >>> from sympy.abc import n\n    >>> dd(n*(n + 1), n)\n    2*n + 2\n    >>> dd(n*(n + 1), n, 2)\n    4*n + 6\n\n    References\n    ==========\n\n    .. [1] https://reference.wolfram.com/language/ref/DifferenceDelta.html\n    \"\"\"\n    expr = sympify(expr)\n    if n is None:\n        f = expr.free_symbols\n        if len(f) == 1:\n            n = f.pop()\n        elif len(f) == 0:\n            return S.Zero\n        else:\n            raise ValueError('Since there is more than one variable in the expression, a variable must be supplied to take the difference of %s' % expr)\n    step = sympify(step)\n    if step.is_number is False or step.is_finite is False:\n        raise ValueError('Step should be a finite number.')\n    if hasattr(expr, '_eval_difference_delta'):\n        result = expr._eval_difference_delta(n, step)\n        if result:\n            return result\n    return expr.subs(n, n + step) - expr",
        "mutated": [
            "def difference_delta(expr, n=None, step=1):\n    if False:\n        i = 10\n    'Difference Operator.\\n\\n    Explanation\\n    ===========\\n\\n    Discrete analog of differential operator. Given a sequence x[n],\\n    returns the sequence x[n + step] - x[n].\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import difference_delta as dd\\n    >>> from sympy.abc import n\\n    >>> dd(n*(n + 1), n)\\n    2*n + 2\\n    >>> dd(n*(n + 1), n, 2)\\n    4*n + 6\\n\\n    References\\n    ==========\\n\\n    .. [1] https://reference.wolfram.com/language/ref/DifferenceDelta.html\\n    '\n    expr = sympify(expr)\n    if n is None:\n        f = expr.free_symbols\n        if len(f) == 1:\n            n = f.pop()\n        elif len(f) == 0:\n            return S.Zero\n        else:\n            raise ValueError('Since there is more than one variable in the expression, a variable must be supplied to take the difference of %s' % expr)\n    step = sympify(step)\n    if step.is_number is False or step.is_finite is False:\n        raise ValueError('Step should be a finite number.')\n    if hasattr(expr, '_eval_difference_delta'):\n        result = expr._eval_difference_delta(n, step)\n        if result:\n            return result\n    return expr.subs(n, n + step) - expr",
            "def difference_delta(expr, n=None, step=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Difference Operator.\\n\\n    Explanation\\n    ===========\\n\\n    Discrete analog of differential operator. Given a sequence x[n],\\n    returns the sequence x[n + step] - x[n].\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import difference_delta as dd\\n    >>> from sympy.abc import n\\n    >>> dd(n*(n + 1), n)\\n    2*n + 2\\n    >>> dd(n*(n + 1), n, 2)\\n    4*n + 6\\n\\n    References\\n    ==========\\n\\n    .. [1] https://reference.wolfram.com/language/ref/DifferenceDelta.html\\n    '\n    expr = sympify(expr)\n    if n is None:\n        f = expr.free_symbols\n        if len(f) == 1:\n            n = f.pop()\n        elif len(f) == 0:\n            return S.Zero\n        else:\n            raise ValueError('Since there is more than one variable in the expression, a variable must be supplied to take the difference of %s' % expr)\n    step = sympify(step)\n    if step.is_number is False or step.is_finite is False:\n        raise ValueError('Step should be a finite number.')\n    if hasattr(expr, '_eval_difference_delta'):\n        result = expr._eval_difference_delta(n, step)\n        if result:\n            return result\n    return expr.subs(n, n + step) - expr",
            "def difference_delta(expr, n=None, step=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Difference Operator.\\n\\n    Explanation\\n    ===========\\n\\n    Discrete analog of differential operator. Given a sequence x[n],\\n    returns the sequence x[n + step] - x[n].\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import difference_delta as dd\\n    >>> from sympy.abc import n\\n    >>> dd(n*(n + 1), n)\\n    2*n + 2\\n    >>> dd(n*(n + 1), n, 2)\\n    4*n + 6\\n\\n    References\\n    ==========\\n\\n    .. [1] https://reference.wolfram.com/language/ref/DifferenceDelta.html\\n    '\n    expr = sympify(expr)\n    if n is None:\n        f = expr.free_symbols\n        if len(f) == 1:\n            n = f.pop()\n        elif len(f) == 0:\n            return S.Zero\n        else:\n            raise ValueError('Since there is more than one variable in the expression, a variable must be supplied to take the difference of %s' % expr)\n    step = sympify(step)\n    if step.is_number is False or step.is_finite is False:\n        raise ValueError('Step should be a finite number.')\n    if hasattr(expr, '_eval_difference_delta'):\n        result = expr._eval_difference_delta(n, step)\n        if result:\n            return result\n    return expr.subs(n, n + step) - expr",
            "def difference_delta(expr, n=None, step=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Difference Operator.\\n\\n    Explanation\\n    ===========\\n\\n    Discrete analog of differential operator. Given a sequence x[n],\\n    returns the sequence x[n + step] - x[n].\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import difference_delta as dd\\n    >>> from sympy.abc import n\\n    >>> dd(n*(n + 1), n)\\n    2*n + 2\\n    >>> dd(n*(n + 1), n, 2)\\n    4*n + 6\\n\\n    References\\n    ==========\\n\\n    .. [1] https://reference.wolfram.com/language/ref/DifferenceDelta.html\\n    '\n    expr = sympify(expr)\n    if n is None:\n        f = expr.free_symbols\n        if len(f) == 1:\n            n = f.pop()\n        elif len(f) == 0:\n            return S.Zero\n        else:\n            raise ValueError('Since there is more than one variable in the expression, a variable must be supplied to take the difference of %s' % expr)\n    step = sympify(step)\n    if step.is_number is False or step.is_finite is False:\n        raise ValueError('Step should be a finite number.')\n    if hasattr(expr, '_eval_difference_delta'):\n        result = expr._eval_difference_delta(n, step)\n        if result:\n            return result\n    return expr.subs(n, n + step) - expr",
            "def difference_delta(expr, n=None, step=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Difference Operator.\\n\\n    Explanation\\n    ===========\\n\\n    Discrete analog of differential operator. Given a sequence x[n],\\n    returns the sequence x[n + step] - x[n].\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import difference_delta as dd\\n    >>> from sympy.abc import n\\n    >>> dd(n*(n + 1), n)\\n    2*n + 2\\n    >>> dd(n*(n + 1), n, 2)\\n    4*n + 6\\n\\n    References\\n    ==========\\n\\n    .. [1] https://reference.wolfram.com/language/ref/DifferenceDelta.html\\n    '\n    expr = sympify(expr)\n    if n is None:\n        f = expr.free_symbols\n        if len(f) == 1:\n            n = f.pop()\n        elif len(f) == 0:\n            return S.Zero\n        else:\n            raise ValueError('Since there is more than one variable in the expression, a variable must be supplied to take the difference of %s' % expr)\n    step = sympify(step)\n    if step.is_number is False or step.is_finite is False:\n        raise ValueError('Step should be a finite number.')\n    if hasattr(expr, '_eval_difference_delta'):\n        result = expr._eval_difference_delta(n, step)\n        if result:\n            return result\n    return expr.subs(n, n + step) - expr"
        ]
    },
    {
        "func_name": "dominant",
        "original": "def dominant(expr, n):\n    \"\"\"Finds the dominant term in a sum, that is a term that dominates\n    every other term.\n\n    Explanation\n    ===========\n\n    If limit(a/b, n, oo) is oo then a dominates b.\n    If limit(a/b, n, oo) is 0 then b dominates a.\n    Otherwise, a and b are comparable.\n\n    If there is no unique dominant term, then returns ``None``.\n\n    Examples\n    ========\n\n    >>> from sympy import Sum\n    >>> from sympy.series.limitseq import dominant\n    >>> from sympy.abc import n, k\n    >>> dominant(5*n**3 + 4*n**2 + n + 1, n)\n    5*n**3\n    >>> dominant(2**n + Sum(k, (k, 0, n)), n)\n    2**n\n\n    See Also\n    ========\n\n    sympy.series.limitseq.dominant\n    \"\"\"\n    terms = Add.make_args(expr.expand(func=True))\n    term0 = terms[-1]\n    comp = [term0]\n    for t in terms[:-1]:\n        r = term0 / t\n        e = r.gammasimp()\n        if e == r:\n            e = r.factor()\n        l = limit_seq(e, n)\n        if l is None:\n            return None\n        elif l.is_zero:\n            term0 = t\n            comp = [term0]\n        elif l not in [S.Infinity, S.NegativeInfinity]:\n            comp.append(t)\n    if len(comp) > 1:\n        return None\n    return term0",
        "mutated": [
            "def dominant(expr, n):\n    if False:\n        i = 10\n    'Finds the dominant term in a sum, that is a term that dominates\\n    every other term.\\n\\n    Explanation\\n    ===========\\n\\n    If limit(a/b, n, oo) is oo then a dominates b.\\n    If limit(a/b, n, oo) is 0 then b dominates a.\\n    Otherwise, a and b are comparable.\\n\\n    If there is no unique dominant term, then returns ``None``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Sum\\n    >>> from sympy.series.limitseq import dominant\\n    >>> from sympy.abc import n, k\\n    >>> dominant(5*n**3 + 4*n**2 + n + 1, n)\\n    5*n**3\\n    >>> dominant(2**n + Sum(k, (k, 0, n)), n)\\n    2**n\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n    '\n    terms = Add.make_args(expr.expand(func=True))\n    term0 = terms[-1]\n    comp = [term0]\n    for t in terms[:-1]:\n        r = term0 / t\n        e = r.gammasimp()\n        if e == r:\n            e = r.factor()\n        l = limit_seq(e, n)\n        if l is None:\n            return None\n        elif l.is_zero:\n            term0 = t\n            comp = [term0]\n        elif l not in [S.Infinity, S.NegativeInfinity]:\n            comp.append(t)\n    if len(comp) > 1:\n        return None\n    return term0",
            "def dominant(expr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Finds the dominant term in a sum, that is a term that dominates\\n    every other term.\\n\\n    Explanation\\n    ===========\\n\\n    If limit(a/b, n, oo) is oo then a dominates b.\\n    If limit(a/b, n, oo) is 0 then b dominates a.\\n    Otherwise, a and b are comparable.\\n\\n    If there is no unique dominant term, then returns ``None``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Sum\\n    >>> from sympy.series.limitseq import dominant\\n    >>> from sympy.abc import n, k\\n    >>> dominant(5*n**3 + 4*n**2 + n + 1, n)\\n    5*n**3\\n    >>> dominant(2**n + Sum(k, (k, 0, n)), n)\\n    2**n\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n    '\n    terms = Add.make_args(expr.expand(func=True))\n    term0 = terms[-1]\n    comp = [term0]\n    for t in terms[:-1]:\n        r = term0 / t\n        e = r.gammasimp()\n        if e == r:\n            e = r.factor()\n        l = limit_seq(e, n)\n        if l is None:\n            return None\n        elif l.is_zero:\n            term0 = t\n            comp = [term0]\n        elif l not in [S.Infinity, S.NegativeInfinity]:\n            comp.append(t)\n    if len(comp) > 1:\n        return None\n    return term0",
            "def dominant(expr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Finds the dominant term in a sum, that is a term that dominates\\n    every other term.\\n\\n    Explanation\\n    ===========\\n\\n    If limit(a/b, n, oo) is oo then a dominates b.\\n    If limit(a/b, n, oo) is 0 then b dominates a.\\n    Otherwise, a and b are comparable.\\n\\n    If there is no unique dominant term, then returns ``None``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Sum\\n    >>> from sympy.series.limitseq import dominant\\n    >>> from sympy.abc import n, k\\n    >>> dominant(5*n**3 + 4*n**2 + n + 1, n)\\n    5*n**3\\n    >>> dominant(2**n + Sum(k, (k, 0, n)), n)\\n    2**n\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n    '\n    terms = Add.make_args(expr.expand(func=True))\n    term0 = terms[-1]\n    comp = [term0]\n    for t in terms[:-1]:\n        r = term0 / t\n        e = r.gammasimp()\n        if e == r:\n            e = r.factor()\n        l = limit_seq(e, n)\n        if l is None:\n            return None\n        elif l.is_zero:\n            term0 = t\n            comp = [term0]\n        elif l not in [S.Infinity, S.NegativeInfinity]:\n            comp.append(t)\n    if len(comp) > 1:\n        return None\n    return term0",
            "def dominant(expr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Finds the dominant term in a sum, that is a term that dominates\\n    every other term.\\n\\n    Explanation\\n    ===========\\n\\n    If limit(a/b, n, oo) is oo then a dominates b.\\n    If limit(a/b, n, oo) is 0 then b dominates a.\\n    Otherwise, a and b are comparable.\\n\\n    If there is no unique dominant term, then returns ``None``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Sum\\n    >>> from sympy.series.limitseq import dominant\\n    >>> from sympy.abc import n, k\\n    >>> dominant(5*n**3 + 4*n**2 + n + 1, n)\\n    5*n**3\\n    >>> dominant(2**n + Sum(k, (k, 0, n)), n)\\n    2**n\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n    '\n    terms = Add.make_args(expr.expand(func=True))\n    term0 = terms[-1]\n    comp = [term0]\n    for t in terms[:-1]:\n        r = term0 / t\n        e = r.gammasimp()\n        if e == r:\n            e = r.factor()\n        l = limit_seq(e, n)\n        if l is None:\n            return None\n        elif l.is_zero:\n            term0 = t\n            comp = [term0]\n        elif l not in [S.Infinity, S.NegativeInfinity]:\n            comp.append(t)\n    if len(comp) > 1:\n        return None\n    return term0",
            "def dominant(expr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Finds the dominant term in a sum, that is a term that dominates\\n    every other term.\\n\\n    Explanation\\n    ===========\\n\\n    If limit(a/b, n, oo) is oo then a dominates b.\\n    If limit(a/b, n, oo) is 0 then b dominates a.\\n    Otherwise, a and b are comparable.\\n\\n    If there is no unique dominant term, then returns ``None``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Sum\\n    >>> from sympy.series.limitseq import dominant\\n    >>> from sympy.abc import n, k\\n    >>> dominant(5*n**3 + 4*n**2 + n + 1, n)\\n    5*n**3\\n    >>> dominant(2**n + Sum(k, (k, 0, n)), n)\\n    2**n\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n    '\n    terms = Add.make_args(expr.expand(func=True))\n    term0 = terms[-1]\n    comp = [term0]\n    for t in terms[:-1]:\n        r = term0 / t\n        e = r.gammasimp()\n        if e == r:\n            e = r.factor()\n        l = limit_seq(e, n)\n        if l is None:\n            return None\n        elif l.is_zero:\n            term0 = t\n            comp = [term0]\n        elif l not in [S.Infinity, S.NegativeInfinity]:\n            comp.append(t)\n    if len(comp) > 1:\n        return None\n    return term0"
        ]
    },
    {
        "func_name": "_limit_inf",
        "original": "def _limit_inf(expr, n):\n    try:\n        return Limit(expr, n, S.Infinity).doit(deep=False)\n    except (NotImplementedError, PoleError):\n        return None",
        "mutated": [
            "def _limit_inf(expr, n):\n    if False:\n        i = 10\n    try:\n        return Limit(expr, n, S.Infinity).doit(deep=False)\n    except (NotImplementedError, PoleError):\n        return None",
            "def _limit_inf(expr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        return Limit(expr, n, S.Infinity).doit(deep=False)\n    except (NotImplementedError, PoleError):\n        return None",
            "def _limit_inf(expr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        return Limit(expr, n, S.Infinity).doit(deep=False)\n    except (NotImplementedError, PoleError):\n        return None",
            "def _limit_inf(expr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        return Limit(expr, n, S.Infinity).doit(deep=False)\n    except (NotImplementedError, PoleError):\n        return None",
            "def _limit_inf(expr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        return Limit(expr, n, S.Infinity).doit(deep=False)\n    except (NotImplementedError, PoleError):\n        return None"
        ]
    },
    {
        "func_name": "_limit_seq",
        "original": "def _limit_seq(expr, n, trials):\n    from sympy.concrete.summations import Sum\n    for i in range(trials):\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        if not den.has(n) or not num.has(n):\n            result = _limit_inf(expr.doit(), n)\n            if result is not None:\n                return result\n            return None\n        (num, den) = (difference_delta(t.expand(), n) for t in [num, den])\n        expr = (num / den).gammasimp()\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        num = dominant(num, n)\n        if num is None:\n            return None\n        den = dominant(den, n)\n        if den is None:\n            return None\n        expr = (num / den).gammasimp()",
        "mutated": [
            "def _limit_seq(expr, n, trials):\n    if False:\n        i = 10\n    from sympy.concrete.summations import Sum\n    for i in range(trials):\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        if not den.has(n) or not num.has(n):\n            result = _limit_inf(expr.doit(), n)\n            if result is not None:\n                return result\n            return None\n        (num, den) = (difference_delta(t.expand(), n) for t in [num, den])\n        expr = (num / den).gammasimp()\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        num = dominant(num, n)\n        if num is None:\n            return None\n        den = dominant(den, n)\n        if den is None:\n            return None\n        expr = (num / den).gammasimp()",
            "def _limit_seq(expr, n, trials):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from sympy.concrete.summations import Sum\n    for i in range(trials):\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        if not den.has(n) or not num.has(n):\n            result = _limit_inf(expr.doit(), n)\n            if result is not None:\n                return result\n            return None\n        (num, den) = (difference_delta(t.expand(), n) for t in [num, den])\n        expr = (num / den).gammasimp()\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        num = dominant(num, n)\n        if num is None:\n            return None\n        den = dominant(den, n)\n        if den is None:\n            return None\n        expr = (num / den).gammasimp()",
            "def _limit_seq(expr, n, trials):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from sympy.concrete.summations import Sum\n    for i in range(trials):\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        if not den.has(n) or not num.has(n):\n            result = _limit_inf(expr.doit(), n)\n            if result is not None:\n                return result\n            return None\n        (num, den) = (difference_delta(t.expand(), n) for t in [num, den])\n        expr = (num / den).gammasimp()\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        num = dominant(num, n)\n        if num is None:\n            return None\n        den = dominant(den, n)\n        if den is None:\n            return None\n        expr = (num / den).gammasimp()",
            "def _limit_seq(expr, n, trials):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from sympy.concrete.summations import Sum\n    for i in range(trials):\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        if not den.has(n) or not num.has(n):\n            result = _limit_inf(expr.doit(), n)\n            if result is not None:\n                return result\n            return None\n        (num, den) = (difference_delta(t.expand(), n) for t in [num, den])\n        expr = (num / den).gammasimp()\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        num = dominant(num, n)\n        if num is None:\n            return None\n        den = dominant(den, n)\n        if den is None:\n            return None\n        expr = (num / den).gammasimp()",
            "def _limit_seq(expr, n, trials):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from sympy.concrete.summations import Sum\n    for i in range(trials):\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        if not den.has(n) or not num.has(n):\n            result = _limit_inf(expr.doit(), n)\n            if result is not None:\n                return result\n            return None\n        (num, den) = (difference_delta(t.expand(), n) for t in [num, den])\n        expr = (num / den).gammasimp()\n        if not expr.has(Sum):\n            result = _limit_inf(expr, n)\n            if result is not None:\n                return result\n        (num, den) = expr.as_numer_denom()\n        num = dominant(num, n)\n        if num is None:\n            return None\n        den = dominant(den, n)\n        if den is None:\n            return None\n        expr = (num / den).gammasimp()"
        ]
    },
    {
        "func_name": "limit_seq",
        "original": "def limit_seq(expr, n=None, trials=5):\n    \"\"\"Finds the limit of a sequence as index ``n`` tends to infinity.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        SymPy expression for the ``n-th`` term of the sequence\n    n : Symbol, optional\n        The index of the sequence, an integer that tends to positive\n        infinity. If None, inferred from the expression unless it has\n        multiple symbols.\n    trials: int, optional\n        The algorithm is highly recursive. ``trials`` is a safeguard from\n        infinite recursion in case the limit is not easily computed by the\n        algorithm. Try increasing ``trials`` if the algorithm returns ``None``.\n\n    Admissible Terms\n    ================\n\n    The algorithm is designed for sequences built from rational functions,\n    indefinite sums, and indefinite products over an indeterminate n. Terms of\n    alternating sign are also allowed, but more complex oscillatory behavior is\n    not supported.\n\n    Examples\n    ========\n\n    >>> from sympy import limit_seq, Sum, binomial\n    >>> from sympy.abc import n, k, m\n    >>> limit_seq((5*n**3 + 3*n**2 + 4) / (3*n**3 + 4*n - 5), n)\n    5/3\n    >>> limit_seq(binomial(2*n, n) / Sum(binomial(2*k, k), (k, 1, n)), n)\n    3/4\n    >>> limit_seq(Sum(k**2 * Sum(2**m/m, (m, 1, k)), (k, 1, n)) / (2**n*n), n)\n    4\n\n    See Also\n    ========\n\n    sympy.series.limitseq.dominant\n\n    References\n    ==========\n\n    .. [1] Computing Limits of Sequences - Manuel Kauers\n    \"\"\"\n    from sympy.concrete.summations import Sum\n    if n is None:\n        free = expr.free_symbols\n        if len(free) == 1:\n            n = free.pop()\n        elif not free:\n            return expr\n        else:\n            raise ValueError('Expression has more than one variable. Please specify a variable.')\n    elif n not in expr.free_symbols:\n        return expr\n    expr = expr.rewrite(fibonacci, S.GoldenRatio)\n    expr = expr.rewrite(factorial, subfactorial, gamma)\n    n_ = Dummy('n', integer=True, positive=True)\n    n1 = Dummy('n', odd=True, positive=True)\n    n2 = Dummy('n', even=True, positive=True)\n    powers = (p.as_base_exp() for p in expr.atoms(Pow))\n    if any((b.is_negative and e.has(n) for (b, e) in powers)) or expr.has(cos, sin):\n        L1 = _limit_seq(expr.xreplace({n: n1}), n1, trials)\n        if L1 is not None:\n            L2 = _limit_seq(expr.xreplace({n: n2}), n2, trials)\n            if L1 != L2:\n                if L1.is_comparable and L2.is_comparable:\n                    return AccumulationBounds(Min(L1, L2), Max(L1, L2))\n                else:\n                    return None\n    else:\n        L1 = _limit_seq(expr.xreplace({n: n_}), n_, trials)\n    if L1 is not None:\n        return L1\n    elif expr.is_Add:\n        limits = [limit_seq(term, n, trials) for term in expr.args]\n        if any((result is None for result in limits)):\n            return None\n        else:\n            return Add(*limits)\n    elif not expr.has(Sum):\n        lim = _limit_seq(Abs(expr.xreplace({n: n_})), n_, trials)\n        if lim is not None and lim.is_zero:\n            return S.Zero",
        "mutated": [
            "def limit_seq(expr, n=None, trials=5):\n    if False:\n        i = 10\n    'Finds the limit of a sequence as index ``n`` tends to infinity.\\n\\n    Parameters\\n    ==========\\n\\n    expr : Expr\\n        SymPy expression for the ``n-th`` term of the sequence\\n    n : Symbol, optional\\n        The index of the sequence, an integer that tends to positive\\n        infinity. If None, inferred from the expression unless it has\\n        multiple symbols.\\n    trials: int, optional\\n        The algorithm is highly recursive. ``trials`` is a safeguard from\\n        infinite recursion in case the limit is not easily computed by the\\n        algorithm. Try increasing ``trials`` if the algorithm returns ``None``.\\n\\n    Admissible Terms\\n    ================\\n\\n    The algorithm is designed for sequences built from rational functions,\\n    indefinite sums, and indefinite products over an indeterminate n. Terms of\\n    alternating sign are also allowed, but more complex oscillatory behavior is\\n    not supported.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import limit_seq, Sum, binomial\\n    >>> from sympy.abc import n, k, m\\n    >>> limit_seq((5*n**3 + 3*n**2 + 4) / (3*n**3 + 4*n - 5), n)\\n    5/3\\n    >>> limit_seq(binomial(2*n, n) / Sum(binomial(2*k, k), (k, 1, n)), n)\\n    3/4\\n    >>> limit_seq(Sum(k**2 * Sum(2**m/m, (m, 1, k)), (k, 1, n)) / (2**n*n), n)\\n    4\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n\\n    References\\n    ==========\\n\\n    .. [1] Computing Limits of Sequences - Manuel Kauers\\n    '\n    from sympy.concrete.summations import Sum\n    if n is None:\n        free = expr.free_symbols\n        if len(free) == 1:\n            n = free.pop()\n        elif not free:\n            return expr\n        else:\n            raise ValueError('Expression has more than one variable. Please specify a variable.')\n    elif n not in expr.free_symbols:\n        return expr\n    expr = expr.rewrite(fibonacci, S.GoldenRatio)\n    expr = expr.rewrite(factorial, subfactorial, gamma)\n    n_ = Dummy('n', integer=True, positive=True)\n    n1 = Dummy('n', odd=True, positive=True)\n    n2 = Dummy('n', even=True, positive=True)\n    powers = (p.as_base_exp() for p in expr.atoms(Pow))\n    if any((b.is_negative and e.has(n) for (b, e) in powers)) or expr.has(cos, sin):\n        L1 = _limit_seq(expr.xreplace({n: n1}), n1, trials)\n        if L1 is not None:\n            L2 = _limit_seq(expr.xreplace({n: n2}), n2, trials)\n            if L1 != L2:\n                if L1.is_comparable and L2.is_comparable:\n                    return AccumulationBounds(Min(L1, L2), Max(L1, L2))\n                else:\n                    return None\n    else:\n        L1 = _limit_seq(expr.xreplace({n: n_}), n_, trials)\n    if L1 is not None:\n        return L1\n    elif expr.is_Add:\n        limits = [limit_seq(term, n, trials) for term in expr.args]\n        if any((result is None for result in limits)):\n            return None\n        else:\n            return Add(*limits)\n    elif not expr.has(Sum):\n        lim = _limit_seq(Abs(expr.xreplace({n: n_})), n_, trials)\n        if lim is not None and lim.is_zero:\n            return S.Zero",
            "def limit_seq(expr, n=None, trials=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Finds the limit of a sequence as index ``n`` tends to infinity.\\n\\n    Parameters\\n    ==========\\n\\n    expr : Expr\\n        SymPy expression for the ``n-th`` term of the sequence\\n    n : Symbol, optional\\n        The index of the sequence, an integer that tends to positive\\n        infinity. If None, inferred from the expression unless it has\\n        multiple symbols.\\n    trials: int, optional\\n        The algorithm is highly recursive. ``trials`` is a safeguard from\\n        infinite recursion in case the limit is not easily computed by the\\n        algorithm. Try increasing ``trials`` if the algorithm returns ``None``.\\n\\n    Admissible Terms\\n    ================\\n\\n    The algorithm is designed for sequences built from rational functions,\\n    indefinite sums, and indefinite products over an indeterminate n. Terms of\\n    alternating sign are also allowed, but more complex oscillatory behavior is\\n    not supported.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import limit_seq, Sum, binomial\\n    >>> from sympy.abc import n, k, m\\n    >>> limit_seq((5*n**3 + 3*n**2 + 4) / (3*n**3 + 4*n - 5), n)\\n    5/3\\n    >>> limit_seq(binomial(2*n, n) / Sum(binomial(2*k, k), (k, 1, n)), n)\\n    3/4\\n    >>> limit_seq(Sum(k**2 * Sum(2**m/m, (m, 1, k)), (k, 1, n)) / (2**n*n), n)\\n    4\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n\\n    References\\n    ==========\\n\\n    .. [1] Computing Limits of Sequences - Manuel Kauers\\n    '\n    from sympy.concrete.summations import Sum\n    if n is None:\n        free = expr.free_symbols\n        if len(free) == 1:\n            n = free.pop()\n        elif not free:\n            return expr\n        else:\n            raise ValueError('Expression has more than one variable. Please specify a variable.')\n    elif n not in expr.free_symbols:\n        return expr\n    expr = expr.rewrite(fibonacci, S.GoldenRatio)\n    expr = expr.rewrite(factorial, subfactorial, gamma)\n    n_ = Dummy('n', integer=True, positive=True)\n    n1 = Dummy('n', odd=True, positive=True)\n    n2 = Dummy('n', even=True, positive=True)\n    powers = (p.as_base_exp() for p in expr.atoms(Pow))\n    if any((b.is_negative and e.has(n) for (b, e) in powers)) or expr.has(cos, sin):\n        L1 = _limit_seq(expr.xreplace({n: n1}), n1, trials)\n        if L1 is not None:\n            L2 = _limit_seq(expr.xreplace({n: n2}), n2, trials)\n            if L1 != L2:\n                if L1.is_comparable and L2.is_comparable:\n                    return AccumulationBounds(Min(L1, L2), Max(L1, L2))\n                else:\n                    return None\n    else:\n        L1 = _limit_seq(expr.xreplace({n: n_}), n_, trials)\n    if L1 is not None:\n        return L1\n    elif expr.is_Add:\n        limits = [limit_seq(term, n, trials) for term in expr.args]\n        if any((result is None for result in limits)):\n            return None\n        else:\n            return Add(*limits)\n    elif not expr.has(Sum):\n        lim = _limit_seq(Abs(expr.xreplace({n: n_})), n_, trials)\n        if lim is not None and lim.is_zero:\n            return S.Zero",
            "def limit_seq(expr, n=None, trials=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Finds the limit of a sequence as index ``n`` tends to infinity.\\n\\n    Parameters\\n    ==========\\n\\n    expr : Expr\\n        SymPy expression for the ``n-th`` term of the sequence\\n    n : Symbol, optional\\n        The index of the sequence, an integer that tends to positive\\n        infinity. If None, inferred from the expression unless it has\\n        multiple symbols.\\n    trials: int, optional\\n        The algorithm is highly recursive. ``trials`` is a safeguard from\\n        infinite recursion in case the limit is not easily computed by the\\n        algorithm. Try increasing ``trials`` if the algorithm returns ``None``.\\n\\n    Admissible Terms\\n    ================\\n\\n    The algorithm is designed for sequences built from rational functions,\\n    indefinite sums, and indefinite products over an indeterminate n. Terms of\\n    alternating sign are also allowed, but more complex oscillatory behavior is\\n    not supported.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import limit_seq, Sum, binomial\\n    >>> from sympy.abc import n, k, m\\n    >>> limit_seq((5*n**3 + 3*n**2 + 4) / (3*n**3 + 4*n - 5), n)\\n    5/3\\n    >>> limit_seq(binomial(2*n, n) / Sum(binomial(2*k, k), (k, 1, n)), n)\\n    3/4\\n    >>> limit_seq(Sum(k**2 * Sum(2**m/m, (m, 1, k)), (k, 1, n)) / (2**n*n), n)\\n    4\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n\\n    References\\n    ==========\\n\\n    .. [1] Computing Limits of Sequences - Manuel Kauers\\n    '\n    from sympy.concrete.summations import Sum\n    if n is None:\n        free = expr.free_symbols\n        if len(free) == 1:\n            n = free.pop()\n        elif not free:\n            return expr\n        else:\n            raise ValueError('Expression has more than one variable. Please specify a variable.')\n    elif n not in expr.free_symbols:\n        return expr\n    expr = expr.rewrite(fibonacci, S.GoldenRatio)\n    expr = expr.rewrite(factorial, subfactorial, gamma)\n    n_ = Dummy('n', integer=True, positive=True)\n    n1 = Dummy('n', odd=True, positive=True)\n    n2 = Dummy('n', even=True, positive=True)\n    powers = (p.as_base_exp() for p in expr.atoms(Pow))\n    if any((b.is_negative and e.has(n) for (b, e) in powers)) or expr.has(cos, sin):\n        L1 = _limit_seq(expr.xreplace({n: n1}), n1, trials)\n        if L1 is not None:\n            L2 = _limit_seq(expr.xreplace({n: n2}), n2, trials)\n            if L1 != L2:\n                if L1.is_comparable and L2.is_comparable:\n                    return AccumulationBounds(Min(L1, L2), Max(L1, L2))\n                else:\n                    return None\n    else:\n        L1 = _limit_seq(expr.xreplace({n: n_}), n_, trials)\n    if L1 is not None:\n        return L1\n    elif expr.is_Add:\n        limits = [limit_seq(term, n, trials) for term in expr.args]\n        if any((result is None for result in limits)):\n            return None\n        else:\n            return Add(*limits)\n    elif not expr.has(Sum):\n        lim = _limit_seq(Abs(expr.xreplace({n: n_})), n_, trials)\n        if lim is not None and lim.is_zero:\n            return S.Zero",
            "def limit_seq(expr, n=None, trials=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Finds the limit of a sequence as index ``n`` tends to infinity.\\n\\n    Parameters\\n    ==========\\n\\n    expr : Expr\\n        SymPy expression for the ``n-th`` term of the sequence\\n    n : Symbol, optional\\n        The index of the sequence, an integer that tends to positive\\n        infinity. If None, inferred from the expression unless it has\\n        multiple symbols.\\n    trials: int, optional\\n        The algorithm is highly recursive. ``trials`` is a safeguard from\\n        infinite recursion in case the limit is not easily computed by the\\n        algorithm. Try increasing ``trials`` if the algorithm returns ``None``.\\n\\n    Admissible Terms\\n    ================\\n\\n    The algorithm is designed for sequences built from rational functions,\\n    indefinite sums, and indefinite products over an indeterminate n. Terms of\\n    alternating sign are also allowed, but more complex oscillatory behavior is\\n    not supported.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import limit_seq, Sum, binomial\\n    >>> from sympy.abc import n, k, m\\n    >>> limit_seq((5*n**3 + 3*n**2 + 4) / (3*n**3 + 4*n - 5), n)\\n    5/3\\n    >>> limit_seq(binomial(2*n, n) / Sum(binomial(2*k, k), (k, 1, n)), n)\\n    3/4\\n    >>> limit_seq(Sum(k**2 * Sum(2**m/m, (m, 1, k)), (k, 1, n)) / (2**n*n), n)\\n    4\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n\\n    References\\n    ==========\\n\\n    .. [1] Computing Limits of Sequences - Manuel Kauers\\n    '\n    from sympy.concrete.summations import Sum\n    if n is None:\n        free = expr.free_symbols\n        if len(free) == 1:\n            n = free.pop()\n        elif not free:\n            return expr\n        else:\n            raise ValueError('Expression has more than one variable. Please specify a variable.')\n    elif n not in expr.free_symbols:\n        return expr\n    expr = expr.rewrite(fibonacci, S.GoldenRatio)\n    expr = expr.rewrite(factorial, subfactorial, gamma)\n    n_ = Dummy('n', integer=True, positive=True)\n    n1 = Dummy('n', odd=True, positive=True)\n    n2 = Dummy('n', even=True, positive=True)\n    powers = (p.as_base_exp() for p in expr.atoms(Pow))\n    if any((b.is_negative and e.has(n) for (b, e) in powers)) or expr.has(cos, sin):\n        L1 = _limit_seq(expr.xreplace({n: n1}), n1, trials)\n        if L1 is not None:\n            L2 = _limit_seq(expr.xreplace({n: n2}), n2, trials)\n            if L1 != L2:\n                if L1.is_comparable and L2.is_comparable:\n                    return AccumulationBounds(Min(L1, L2), Max(L1, L2))\n                else:\n                    return None\n    else:\n        L1 = _limit_seq(expr.xreplace({n: n_}), n_, trials)\n    if L1 is not None:\n        return L1\n    elif expr.is_Add:\n        limits = [limit_seq(term, n, trials) for term in expr.args]\n        if any((result is None for result in limits)):\n            return None\n        else:\n            return Add(*limits)\n    elif not expr.has(Sum):\n        lim = _limit_seq(Abs(expr.xreplace({n: n_})), n_, trials)\n        if lim is not None and lim.is_zero:\n            return S.Zero",
            "def limit_seq(expr, n=None, trials=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Finds the limit of a sequence as index ``n`` tends to infinity.\\n\\n    Parameters\\n    ==========\\n\\n    expr : Expr\\n        SymPy expression for the ``n-th`` term of the sequence\\n    n : Symbol, optional\\n        The index of the sequence, an integer that tends to positive\\n        infinity. If None, inferred from the expression unless it has\\n        multiple symbols.\\n    trials: int, optional\\n        The algorithm is highly recursive. ``trials`` is a safeguard from\\n        infinite recursion in case the limit is not easily computed by the\\n        algorithm. Try increasing ``trials`` if the algorithm returns ``None``.\\n\\n    Admissible Terms\\n    ================\\n\\n    The algorithm is designed for sequences built from rational functions,\\n    indefinite sums, and indefinite products over an indeterminate n. Terms of\\n    alternating sign are also allowed, but more complex oscillatory behavior is\\n    not supported.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import limit_seq, Sum, binomial\\n    >>> from sympy.abc import n, k, m\\n    >>> limit_seq((5*n**3 + 3*n**2 + 4) / (3*n**3 + 4*n - 5), n)\\n    5/3\\n    >>> limit_seq(binomial(2*n, n) / Sum(binomial(2*k, k), (k, 1, n)), n)\\n    3/4\\n    >>> limit_seq(Sum(k**2 * Sum(2**m/m, (m, 1, k)), (k, 1, n)) / (2**n*n), n)\\n    4\\n\\n    See Also\\n    ========\\n\\n    sympy.series.limitseq.dominant\\n\\n    References\\n    ==========\\n\\n    .. [1] Computing Limits of Sequences - Manuel Kauers\\n    '\n    from sympy.concrete.summations import Sum\n    if n is None:\n        free = expr.free_symbols\n        if len(free) == 1:\n            n = free.pop()\n        elif not free:\n            return expr\n        else:\n            raise ValueError('Expression has more than one variable. Please specify a variable.')\n    elif n not in expr.free_symbols:\n        return expr\n    expr = expr.rewrite(fibonacci, S.GoldenRatio)\n    expr = expr.rewrite(factorial, subfactorial, gamma)\n    n_ = Dummy('n', integer=True, positive=True)\n    n1 = Dummy('n', odd=True, positive=True)\n    n2 = Dummy('n', even=True, positive=True)\n    powers = (p.as_base_exp() for p in expr.atoms(Pow))\n    if any((b.is_negative and e.has(n) for (b, e) in powers)) or expr.has(cos, sin):\n        L1 = _limit_seq(expr.xreplace({n: n1}), n1, trials)\n        if L1 is not None:\n            L2 = _limit_seq(expr.xreplace({n: n2}), n2, trials)\n            if L1 != L2:\n                if L1.is_comparable and L2.is_comparable:\n                    return AccumulationBounds(Min(L1, L2), Max(L1, L2))\n                else:\n                    return None\n    else:\n        L1 = _limit_seq(expr.xreplace({n: n_}), n_, trials)\n    if L1 is not None:\n        return L1\n    elif expr.is_Add:\n        limits = [limit_seq(term, n, trials) for term in expr.args]\n        if any((result is None for result in limits)):\n            return None\n        else:\n            return Add(*limits)\n    elif not expr.has(Sum):\n        lim = _limit_seq(Abs(expr.xreplace({n: n_})), n_, trials)\n        if lim is not None and lim.is_zero:\n            return S.Zero"
        ]
    }
]