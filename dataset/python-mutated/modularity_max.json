[
    {
        "func_name": "_greedy_modularity_communities_generator",
        "original": "def _greedy_modularity_communities_generator(G, weight=None, resolution=1):\n    \"\"\"Yield community partitions of G and the modularity change at each step.\n\n    This function performs Clauset-Newman-Moore greedy modularity maximization [2]_\n    At each step of the process it yields the change in modularity that will occur in\n    the next step followed by yielding the new community partition after that step.\n\n    Greedy modularity maximization begins with each node in its own community\n    and repeatedly joins the pair of communities that lead to the largest\n    modularity until one community contains all nodes (the partition has one set).\n\n    This function maximizes the generalized modularity, where `resolution`\n    is the resolution parameter, often expressed as $\\\\gamma$.\n    See :func:`~networkx.algorithms.community.quality.modularity`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : string or None, optional (default=None)\n        The name of an edge attribute that holds the numerical value used\n        as a weight.  If None, then each edge has weight 1.\n        The degree is the sum of the edge weights adjacent to the node.\n\n    resolution : float (default=1)\n        If resolution is less than 1, modularity favors larger communities.\n        Greater than 1 favors smaller communities.\n\n    Yields\n    ------\n    Alternating yield statements produce the following two objects:\n\n    communities: dict_values\n        A dict_values of frozensets of nodes, one for each community.\n        This represents a partition of the nodes of the graph into communities.\n        The first yield is the partition with each node in its own community.\n\n    dq: float\n        The change in modularity when merging the next two communities\n        that leads to the largest modularity.\n\n    See Also\n    --------\n    modularity\n\n    References\n    ----------\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\n       Oxford University Press 2011.\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\n       \"Finding community structure in very large networks.\"\n       Physical Review E 70(6), 2004.\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\n       Detection\" Phys. Rev. E74, 2006.\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\n       Physical Review E 70(5 Pt 2):056131, 2004.\n    \"\"\"\n    directed = G.is_directed()\n    N = G.number_of_nodes()\n    m = G.size(weight)\n    q0 = 1 / m\n    if directed:\n        a = {node: deg_out * q0 for (node, deg_out) in G.out_degree(weight=weight)}\n        b = {node: deg_in * q0 for (node, deg_in) in G.in_degree(weight=weight)}\n    else:\n        a = b = {node: deg * q0 * 0.5 for (node, deg) in G.degree(weight=weight)}\n    dq_dict = defaultdict(lambda : defaultdict(float))\n    for (u, v, wt) in G.edges(data=weight, default=1):\n        if u == v:\n            continue\n        dq_dict[u][v] += wt\n        dq_dict[v][u] += wt\n    for (u, nbrdict) in dq_dict.items():\n        for (v, wt) in nbrdict.items():\n            dq_dict[u][v] = q0 * wt - resolution * (a[u] * b[v] + b[u] * a[v])\n    dq_heap = {u: MappedQueue({(u, v): -dq for (v, dq) in dq_dict[u].items()}) for u in G}\n    H = MappedQueue([dq_heap[n].heap[0] for n in G if len(dq_heap[n]) > 0])\n    communities = {n: frozenset([n]) for n in G}\n    yield communities.values()\n    while len(H) > 1:\n        try:\n            (negdq, u, v) = H.pop()\n        except IndexError:\n            break\n        dq = -negdq\n        yield dq\n        dq_heap[u].pop()\n        if len(dq_heap[u]) > 0:\n            H.push(dq_heap[u].heap[0])\n        if dq_heap[v].heap[0] == (v, u):\n            H.remove((v, u))\n            dq_heap[v].remove((v, u))\n            if len(dq_heap[v]) > 0:\n                H.push(dq_heap[v].heap[0])\n        else:\n            dq_heap[v].remove((v, u))\n        communities[v] = frozenset(communities[u] | communities[v])\n        del communities[u]\n        u_nbrs = set(dq_dict[u])\n        v_nbrs = set(dq_dict[v])\n        all_nbrs = (u_nbrs | v_nbrs) - {u, v}\n        both_nbrs = u_nbrs & v_nbrs\n        for w in all_nbrs:\n            if w in both_nbrs:\n                dq_vw = dq_dict[v][w] + dq_dict[u][w]\n            elif w in v_nbrs:\n                dq_vw = dq_dict[v][w] - resolution * (a[u] * b[w] + a[w] * b[u])\n            else:\n                dq_vw = dq_dict[u][w] - resolution * (a[v] * b[w] + a[w] * b[v])\n            for (row, col) in [(v, w), (w, v)]:\n                dq_heap_row = dq_heap[row]\n                dq_dict[row][col] = dq_vw\n                if len(dq_heap_row) > 0:\n                    d_oldmax = dq_heap_row.heap[0]\n                else:\n                    d_oldmax = None\n                d = (row, col)\n                d_negdq = -dq_vw\n                if w in v_nbrs:\n                    dq_heap_row.update(d, d, priority=d_negdq)\n                else:\n                    dq_heap_row.push(d, priority=d_negdq)\n                if d_oldmax is None:\n                    H.push(d, priority=d_negdq)\n                else:\n                    row_max = dq_heap_row.heap[0]\n                    if d_oldmax != row_max or d_oldmax.priority != row_max.priority:\n                        H.update(d_oldmax, row_max)\n        for w in dq_dict[u]:\n            dq_old = dq_dict[w][u]\n            del dq_dict[w][u]\n            if w != v:\n                for (row, col) in [(w, u), (u, w)]:\n                    dq_heap_row = dq_heap[row]\n                    d_old = (row, col)\n                    if dq_heap_row.heap[0] == d_old:\n                        dq_heap_row.remove(d_old)\n                        H.remove(d_old)\n                        if len(dq_heap_row) > 0:\n                            H.push(dq_heap_row.heap[0])\n                    else:\n                        dq_heap_row.remove(d_old)\n        del dq_dict[u]\n        dq_heap[u] = MappedQueue()\n        a[v] += a[u]\n        a[u] = 0\n        if directed:\n            b[v] += b[u]\n            b[u] = 0\n        yield communities.values()",
        "mutated": [
            "def _greedy_modularity_communities_generator(G, weight=None, resolution=1):\n    if False:\n        i = 10\n    'Yield community partitions of G and the modularity change at each step.\\n\\n    This function performs Clauset-Newman-Moore greedy modularity maximization [2]_\\n    At each step of the process it yields the change in modularity that will occur in\\n    the next step followed by yielding the new community partition after that step.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until one community contains all nodes (the partition has one set).\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    Yields\\n    ------\\n    Alternating yield statements produce the following two objects:\\n\\n    communities: dict_values\\n        A dict_values of frozensets of nodes, one for each community.\\n        This represents a partition of the nodes of the graph into communities.\\n        The first yield is the partition with each node in its own community.\\n\\n    dq: float\\n        The change in modularity when merging the next two communities\\n        that leads to the largest modularity.\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    directed = G.is_directed()\n    N = G.number_of_nodes()\n    m = G.size(weight)\n    q0 = 1 / m\n    if directed:\n        a = {node: deg_out * q0 for (node, deg_out) in G.out_degree(weight=weight)}\n        b = {node: deg_in * q0 for (node, deg_in) in G.in_degree(weight=weight)}\n    else:\n        a = b = {node: deg * q0 * 0.5 for (node, deg) in G.degree(weight=weight)}\n    dq_dict = defaultdict(lambda : defaultdict(float))\n    for (u, v, wt) in G.edges(data=weight, default=1):\n        if u == v:\n            continue\n        dq_dict[u][v] += wt\n        dq_dict[v][u] += wt\n    for (u, nbrdict) in dq_dict.items():\n        for (v, wt) in nbrdict.items():\n            dq_dict[u][v] = q0 * wt - resolution * (a[u] * b[v] + b[u] * a[v])\n    dq_heap = {u: MappedQueue({(u, v): -dq for (v, dq) in dq_dict[u].items()}) for u in G}\n    H = MappedQueue([dq_heap[n].heap[0] for n in G if len(dq_heap[n]) > 0])\n    communities = {n: frozenset([n]) for n in G}\n    yield communities.values()\n    while len(H) > 1:\n        try:\n            (negdq, u, v) = H.pop()\n        except IndexError:\n            break\n        dq = -negdq\n        yield dq\n        dq_heap[u].pop()\n        if len(dq_heap[u]) > 0:\n            H.push(dq_heap[u].heap[0])\n        if dq_heap[v].heap[0] == (v, u):\n            H.remove((v, u))\n            dq_heap[v].remove((v, u))\n            if len(dq_heap[v]) > 0:\n                H.push(dq_heap[v].heap[0])\n        else:\n            dq_heap[v].remove((v, u))\n        communities[v] = frozenset(communities[u] | communities[v])\n        del communities[u]\n        u_nbrs = set(dq_dict[u])\n        v_nbrs = set(dq_dict[v])\n        all_nbrs = (u_nbrs | v_nbrs) - {u, v}\n        both_nbrs = u_nbrs & v_nbrs\n        for w in all_nbrs:\n            if w in both_nbrs:\n                dq_vw = dq_dict[v][w] + dq_dict[u][w]\n            elif w in v_nbrs:\n                dq_vw = dq_dict[v][w] - resolution * (a[u] * b[w] + a[w] * b[u])\n            else:\n                dq_vw = dq_dict[u][w] - resolution * (a[v] * b[w] + a[w] * b[v])\n            for (row, col) in [(v, w), (w, v)]:\n                dq_heap_row = dq_heap[row]\n                dq_dict[row][col] = dq_vw\n                if len(dq_heap_row) > 0:\n                    d_oldmax = dq_heap_row.heap[0]\n                else:\n                    d_oldmax = None\n                d = (row, col)\n                d_negdq = -dq_vw\n                if w in v_nbrs:\n                    dq_heap_row.update(d, d, priority=d_negdq)\n                else:\n                    dq_heap_row.push(d, priority=d_negdq)\n                if d_oldmax is None:\n                    H.push(d, priority=d_negdq)\n                else:\n                    row_max = dq_heap_row.heap[0]\n                    if d_oldmax != row_max or d_oldmax.priority != row_max.priority:\n                        H.update(d_oldmax, row_max)\n        for w in dq_dict[u]:\n            dq_old = dq_dict[w][u]\n            del dq_dict[w][u]\n            if w != v:\n                for (row, col) in [(w, u), (u, w)]:\n                    dq_heap_row = dq_heap[row]\n                    d_old = (row, col)\n                    if dq_heap_row.heap[0] == d_old:\n                        dq_heap_row.remove(d_old)\n                        H.remove(d_old)\n                        if len(dq_heap_row) > 0:\n                            H.push(dq_heap_row.heap[0])\n                    else:\n                        dq_heap_row.remove(d_old)\n        del dq_dict[u]\n        dq_heap[u] = MappedQueue()\n        a[v] += a[u]\n        a[u] = 0\n        if directed:\n            b[v] += b[u]\n            b[u] = 0\n        yield communities.values()",
            "def _greedy_modularity_communities_generator(G, weight=None, resolution=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Yield community partitions of G and the modularity change at each step.\\n\\n    This function performs Clauset-Newman-Moore greedy modularity maximization [2]_\\n    At each step of the process it yields the change in modularity that will occur in\\n    the next step followed by yielding the new community partition after that step.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until one community contains all nodes (the partition has one set).\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    Yields\\n    ------\\n    Alternating yield statements produce the following two objects:\\n\\n    communities: dict_values\\n        A dict_values of frozensets of nodes, one for each community.\\n        This represents a partition of the nodes of the graph into communities.\\n        The first yield is the partition with each node in its own community.\\n\\n    dq: float\\n        The change in modularity when merging the next two communities\\n        that leads to the largest modularity.\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    directed = G.is_directed()\n    N = G.number_of_nodes()\n    m = G.size(weight)\n    q0 = 1 / m\n    if directed:\n        a = {node: deg_out * q0 for (node, deg_out) in G.out_degree(weight=weight)}\n        b = {node: deg_in * q0 for (node, deg_in) in G.in_degree(weight=weight)}\n    else:\n        a = b = {node: deg * q0 * 0.5 for (node, deg) in G.degree(weight=weight)}\n    dq_dict = defaultdict(lambda : defaultdict(float))\n    for (u, v, wt) in G.edges(data=weight, default=1):\n        if u == v:\n            continue\n        dq_dict[u][v] += wt\n        dq_dict[v][u] += wt\n    for (u, nbrdict) in dq_dict.items():\n        for (v, wt) in nbrdict.items():\n            dq_dict[u][v] = q0 * wt - resolution * (a[u] * b[v] + b[u] * a[v])\n    dq_heap = {u: MappedQueue({(u, v): -dq for (v, dq) in dq_dict[u].items()}) for u in G}\n    H = MappedQueue([dq_heap[n].heap[0] for n in G if len(dq_heap[n]) > 0])\n    communities = {n: frozenset([n]) for n in G}\n    yield communities.values()\n    while len(H) > 1:\n        try:\n            (negdq, u, v) = H.pop()\n        except IndexError:\n            break\n        dq = -negdq\n        yield dq\n        dq_heap[u].pop()\n        if len(dq_heap[u]) > 0:\n            H.push(dq_heap[u].heap[0])\n        if dq_heap[v].heap[0] == (v, u):\n            H.remove((v, u))\n            dq_heap[v].remove((v, u))\n            if len(dq_heap[v]) > 0:\n                H.push(dq_heap[v].heap[0])\n        else:\n            dq_heap[v].remove((v, u))\n        communities[v] = frozenset(communities[u] | communities[v])\n        del communities[u]\n        u_nbrs = set(dq_dict[u])\n        v_nbrs = set(dq_dict[v])\n        all_nbrs = (u_nbrs | v_nbrs) - {u, v}\n        both_nbrs = u_nbrs & v_nbrs\n        for w in all_nbrs:\n            if w in both_nbrs:\n                dq_vw = dq_dict[v][w] + dq_dict[u][w]\n            elif w in v_nbrs:\n                dq_vw = dq_dict[v][w] - resolution * (a[u] * b[w] + a[w] * b[u])\n            else:\n                dq_vw = dq_dict[u][w] - resolution * (a[v] * b[w] + a[w] * b[v])\n            for (row, col) in [(v, w), (w, v)]:\n                dq_heap_row = dq_heap[row]\n                dq_dict[row][col] = dq_vw\n                if len(dq_heap_row) > 0:\n                    d_oldmax = dq_heap_row.heap[0]\n                else:\n                    d_oldmax = None\n                d = (row, col)\n                d_negdq = -dq_vw\n                if w in v_nbrs:\n                    dq_heap_row.update(d, d, priority=d_negdq)\n                else:\n                    dq_heap_row.push(d, priority=d_negdq)\n                if d_oldmax is None:\n                    H.push(d, priority=d_negdq)\n                else:\n                    row_max = dq_heap_row.heap[0]\n                    if d_oldmax != row_max or d_oldmax.priority != row_max.priority:\n                        H.update(d_oldmax, row_max)\n        for w in dq_dict[u]:\n            dq_old = dq_dict[w][u]\n            del dq_dict[w][u]\n            if w != v:\n                for (row, col) in [(w, u), (u, w)]:\n                    dq_heap_row = dq_heap[row]\n                    d_old = (row, col)\n                    if dq_heap_row.heap[0] == d_old:\n                        dq_heap_row.remove(d_old)\n                        H.remove(d_old)\n                        if len(dq_heap_row) > 0:\n                            H.push(dq_heap_row.heap[0])\n                    else:\n                        dq_heap_row.remove(d_old)\n        del dq_dict[u]\n        dq_heap[u] = MappedQueue()\n        a[v] += a[u]\n        a[u] = 0\n        if directed:\n            b[v] += b[u]\n            b[u] = 0\n        yield communities.values()",
            "def _greedy_modularity_communities_generator(G, weight=None, resolution=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Yield community partitions of G and the modularity change at each step.\\n\\n    This function performs Clauset-Newman-Moore greedy modularity maximization [2]_\\n    At each step of the process it yields the change in modularity that will occur in\\n    the next step followed by yielding the new community partition after that step.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until one community contains all nodes (the partition has one set).\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    Yields\\n    ------\\n    Alternating yield statements produce the following two objects:\\n\\n    communities: dict_values\\n        A dict_values of frozensets of nodes, one for each community.\\n        This represents a partition of the nodes of the graph into communities.\\n        The first yield is the partition with each node in its own community.\\n\\n    dq: float\\n        The change in modularity when merging the next two communities\\n        that leads to the largest modularity.\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    directed = G.is_directed()\n    N = G.number_of_nodes()\n    m = G.size(weight)\n    q0 = 1 / m\n    if directed:\n        a = {node: deg_out * q0 for (node, deg_out) in G.out_degree(weight=weight)}\n        b = {node: deg_in * q0 for (node, deg_in) in G.in_degree(weight=weight)}\n    else:\n        a = b = {node: deg * q0 * 0.5 for (node, deg) in G.degree(weight=weight)}\n    dq_dict = defaultdict(lambda : defaultdict(float))\n    for (u, v, wt) in G.edges(data=weight, default=1):\n        if u == v:\n            continue\n        dq_dict[u][v] += wt\n        dq_dict[v][u] += wt\n    for (u, nbrdict) in dq_dict.items():\n        for (v, wt) in nbrdict.items():\n            dq_dict[u][v] = q0 * wt - resolution * (a[u] * b[v] + b[u] * a[v])\n    dq_heap = {u: MappedQueue({(u, v): -dq for (v, dq) in dq_dict[u].items()}) for u in G}\n    H = MappedQueue([dq_heap[n].heap[0] for n in G if len(dq_heap[n]) > 0])\n    communities = {n: frozenset([n]) for n in G}\n    yield communities.values()\n    while len(H) > 1:\n        try:\n            (negdq, u, v) = H.pop()\n        except IndexError:\n            break\n        dq = -negdq\n        yield dq\n        dq_heap[u].pop()\n        if len(dq_heap[u]) > 0:\n            H.push(dq_heap[u].heap[0])\n        if dq_heap[v].heap[0] == (v, u):\n            H.remove((v, u))\n            dq_heap[v].remove((v, u))\n            if len(dq_heap[v]) > 0:\n                H.push(dq_heap[v].heap[0])\n        else:\n            dq_heap[v].remove((v, u))\n        communities[v] = frozenset(communities[u] | communities[v])\n        del communities[u]\n        u_nbrs = set(dq_dict[u])\n        v_nbrs = set(dq_dict[v])\n        all_nbrs = (u_nbrs | v_nbrs) - {u, v}\n        both_nbrs = u_nbrs & v_nbrs\n        for w in all_nbrs:\n            if w in both_nbrs:\n                dq_vw = dq_dict[v][w] + dq_dict[u][w]\n            elif w in v_nbrs:\n                dq_vw = dq_dict[v][w] - resolution * (a[u] * b[w] + a[w] * b[u])\n            else:\n                dq_vw = dq_dict[u][w] - resolution * (a[v] * b[w] + a[w] * b[v])\n            for (row, col) in [(v, w), (w, v)]:\n                dq_heap_row = dq_heap[row]\n                dq_dict[row][col] = dq_vw\n                if len(dq_heap_row) > 0:\n                    d_oldmax = dq_heap_row.heap[0]\n                else:\n                    d_oldmax = None\n                d = (row, col)\n                d_negdq = -dq_vw\n                if w in v_nbrs:\n                    dq_heap_row.update(d, d, priority=d_negdq)\n                else:\n                    dq_heap_row.push(d, priority=d_negdq)\n                if d_oldmax is None:\n                    H.push(d, priority=d_negdq)\n                else:\n                    row_max = dq_heap_row.heap[0]\n                    if d_oldmax != row_max or d_oldmax.priority != row_max.priority:\n                        H.update(d_oldmax, row_max)\n        for w in dq_dict[u]:\n            dq_old = dq_dict[w][u]\n            del dq_dict[w][u]\n            if w != v:\n                for (row, col) in [(w, u), (u, w)]:\n                    dq_heap_row = dq_heap[row]\n                    d_old = (row, col)\n                    if dq_heap_row.heap[0] == d_old:\n                        dq_heap_row.remove(d_old)\n                        H.remove(d_old)\n                        if len(dq_heap_row) > 0:\n                            H.push(dq_heap_row.heap[0])\n                    else:\n                        dq_heap_row.remove(d_old)\n        del dq_dict[u]\n        dq_heap[u] = MappedQueue()\n        a[v] += a[u]\n        a[u] = 0\n        if directed:\n            b[v] += b[u]\n            b[u] = 0\n        yield communities.values()",
            "def _greedy_modularity_communities_generator(G, weight=None, resolution=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Yield community partitions of G and the modularity change at each step.\\n\\n    This function performs Clauset-Newman-Moore greedy modularity maximization [2]_\\n    At each step of the process it yields the change in modularity that will occur in\\n    the next step followed by yielding the new community partition after that step.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until one community contains all nodes (the partition has one set).\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    Yields\\n    ------\\n    Alternating yield statements produce the following two objects:\\n\\n    communities: dict_values\\n        A dict_values of frozensets of nodes, one for each community.\\n        This represents a partition of the nodes of the graph into communities.\\n        The first yield is the partition with each node in its own community.\\n\\n    dq: float\\n        The change in modularity when merging the next two communities\\n        that leads to the largest modularity.\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    directed = G.is_directed()\n    N = G.number_of_nodes()\n    m = G.size(weight)\n    q0 = 1 / m\n    if directed:\n        a = {node: deg_out * q0 for (node, deg_out) in G.out_degree(weight=weight)}\n        b = {node: deg_in * q0 for (node, deg_in) in G.in_degree(weight=weight)}\n    else:\n        a = b = {node: deg * q0 * 0.5 for (node, deg) in G.degree(weight=weight)}\n    dq_dict = defaultdict(lambda : defaultdict(float))\n    for (u, v, wt) in G.edges(data=weight, default=1):\n        if u == v:\n            continue\n        dq_dict[u][v] += wt\n        dq_dict[v][u] += wt\n    for (u, nbrdict) in dq_dict.items():\n        for (v, wt) in nbrdict.items():\n            dq_dict[u][v] = q0 * wt - resolution * (a[u] * b[v] + b[u] * a[v])\n    dq_heap = {u: MappedQueue({(u, v): -dq for (v, dq) in dq_dict[u].items()}) for u in G}\n    H = MappedQueue([dq_heap[n].heap[0] for n in G if len(dq_heap[n]) > 0])\n    communities = {n: frozenset([n]) for n in G}\n    yield communities.values()\n    while len(H) > 1:\n        try:\n            (negdq, u, v) = H.pop()\n        except IndexError:\n            break\n        dq = -negdq\n        yield dq\n        dq_heap[u].pop()\n        if len(dq_heap[u]) > 0:\n            H.push(dq_heap[u].heap[0])\n        if dq_heap[v].heap[0] == (v, u):\n            H.remove((v, u))\n            dq_heap[v].remove((v, u))\n            if len(dq_heap[v]) > 0:\n                H.push(dq_heap[v].heap[0])\n        else:\n            dq_heap[v].remove((v, u))\n        communities[v] = frozenset(communities[u] | communities[v])\n        del communities[u]\n        u_nbrs = set(dq_dict[u])\n        v_nbrs = set(dq_dict[v])\n        all_nbrs = (u_nbrs | v_nbrs) - {u, v}\n        both_nbrs = u_nbrs & v_nbrs\n        for w in all_nbrs:\n            if w in both_nbrs:\n                dq_vw = dq_dict[v][w] + dq_dict[u][w]\n            elif w in v_nbrs:\n                dq_vw = dq_dict[v][w] - resolution * (a[u] * b[w] + a[w] * b[u])\n            else:\n                dq_vw = dq_dict[u][w] - resolution * (a[v] * b[w] + a[w] * b[v])\n            for (row, col) in [(v, w), (w, v)]:\n                dq_heap_row = dq_heap[row]\n                dq_dict[row][col] = dq_vw\n                if len(dq_heap_row) > 0:\n                    d_oldmax = dq_heap_row.heap[0]\n                else:\n                    d_oldmax = None\n                d = (row, col)\n                d_negdq = -dq_vw\n                if w in v_nbrs:\n                    dq_heap_row.update(d, d, priority=d_negdq)\n                else:\n                    dq_heap_row.push(d, priority=d_negdq)\n                if d_oldmax is None:\n                    H.push(d, priority=d_negdq)\n                else:\n                    row_max = dq_heap_row.heap[0]\n                    if d_oldmax != row_max or d_oldmax.priority != row_max.priority:\n                        H.update(d_oldmax, row_max)\n        for w in dq_dict[u]:\n            dq_old = dq_dict[w][u]\n            del dq_dict[w][u]\n            if w != v:\n                for (row, col) in [(w, u), (u, w)]:\n                    dq_heap_row = dq_heap[row]\n                    d_old = (row, col)\n                    if dq_heap_row.heap[0] == d_old:\n                        dq_heap_row.remove(d_old)\n                        H.remove(d_old)\n                        if len(dq_heap_row) > 0:\n                            H.push(dq_heap_row.heap[0])\n                    else:\n                        dq_heap_row.remove(d_old)\n        del dq_dict[u]\n        dq_heap[u] = MappedQueue()\n        a[v] += a[u]\n        a[u] = 0\n        if directed:\n            b[v] += b[u]\n            b[u] = 0\n        yield communities.values()",
            "def _greedy_modularity_communities_generator(G, weight=None, resolution=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Yield community partitions of G and the modularity change at each step.\\n\\n    This function performs Clauset-Newman-Moore greedy modularity maximization [2]_\\n    At each step of the process it yields the change in modularity that will occur in\\n    the next step followed by yielding the new community partition after that step.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until one community contains all nodes (the partition has one set).\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    Yields\\n    ------\\n    Alternating yield statements produce the following two objects:\\n\\n    communities: dict_values\\n        A dict_values of frozensets of nodes, one for each community.\\n        This represents a partition of the nodes of the graph into communities.\\n        The first yield is the partition with each node in its own community.\\n\\n    dq: float\\n        The change in modularity when merging the next two communities\\n        that leads to the largest modularity.\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    directed = G.is_directed()\n    N = G.number_of_nodes()\n    m = G.size(weight)\n    q0 = 1 / m\n    if directed:\n        a = {node: deg_out * q0 for (node, deg_out) in G.out_degree(weight=weight)}\n        b = {node: deg_in * q0 for (node, deg_in) in G.in_degree(weight=weight)}\n    else:\n        a = b = {node: deg * q0 * 0.5 for (node, deg) in G.degree(weight=weight)}\n    dq_dict = defaultdict(lambda : defaultdict(float))\n    for (u, v, wt) in G.edges(data=weight, default=1):\n        if u == v:\n            continue\n        dq_dict[u][v] += wt\n        dq_dict[v][u] += wt\n    for (u, nbrdict) in dq_dict.items():\n        for (v, wt) in nbrdict.items():\n            dq_dict[u][v] = q0 * wt - resolution * (a[u] * b[v] + b[u] * a[v])\n    dq_heap = {u: MappedQueue({(u, v): -dq for (v, dq) in dq_dict[u].items()}) for u in G}\n    H = MappedQueue([dq_heap[n].heap[0] for n in G if len(dq_heap[n]) > 0])\n    communities = {n: frozenset([n]) for n in G}\n    yield communities.values()\n    while len(H) > 1:\n        try:\n            (negdq, u, v) = H.pop()\n        except IndexError:\n            break\n        dq = -negdq\n        yield dq\n        dq_heap[u].pop()\n        if len(dq_heap[u]) > 0:\n            H.push(dq_heap[u].heap[0])\n        if dq_heap[v].heap[0] == (v, u):\n            H.remove((v, u))\n            dq_heap[v].remove((v, u))\n            if len(dq_heap[v]) > 0:\n                H.push(dq_heap[v].heap[0])\n        else:\n            dq_heap[v].remove((v, u))\n        communities[v] = frozenset(communities[u] | communities[v])\n        del communities[u]\n        u_nbrs = set(dq_dict[u])\n        v_nbrs = set(dq_dict[v])\n        all_nbrs = (u_nbrs | v_nbrs) - {u, v}\n        both_nbrs = u_nbrs & v_nbrs\n        for w in all_nbrs:\n            if w in both_nbrs:\n                dq_vw = dq_dict[v][w] + dq_dict[u][w]\n            elif w in v_nbrs:\n                dq_vw = dq_dict[v][w] - resolution * (a[u] * b[w] + a[w] * b[u])\n            else:\n                dq_vw = dq_dict[u][w] - resolution * (a[v] * b[w] + a[w] * b[v])\n            for (row, col) in [(v, w), (w, v)]:\n                dq_heap_row = dq_heap[row]\n                dq_dict[row][col] = dq_vw\n                if len(dq_heap_row) > 0:\n                    d_oldmax = dq_heap_row.heap[0]\n                else:\n                    d_oldmax = None\n                d = (row, col)\n                d_negdq = -dq_vw\n                if w in v_nbrs:\n                    dq_heap_row.update(d, d, priority=d_negdq)\n                else:\n                    dq_heap_row.push(d, priority=d_negdq)\n                if d_oldmax is None:\n                    H.push(d, priority=d_negdq)\n                else:\n                    row_max = dq_heap_row.heap[0]\n                    if d_oldmax != row_max or d_oldmax.priority != row_max.priority:\n                        H.update(d_oldmax, row_max)\n        for w in dq_dict[u]:\n            dq_old = dq_dict[w][u]\n            del dq_dict[w][u]\n            if w != v:\n                for (row, col) in [(w, u), (u, w)]:\n                    dq_heap_row = dq_heap[row]\n                    d_old = (row, col)\n                    if dq_heap_row.heap[0] == d_old:\n                        dq_heap_row.remove(d_old)\n                        H.remove(d_old)\n                        if len(dq_heap_row) > 0:\n                            H.push(dq_heap_row.heap[0])\n                    else:\n                        dq_heap_row.remove(d_old)\n        del dq_dict[u]\n        dq_heap[u] = MappedQueue()\n        a[v] += a[u]\n        a[u] = 0\n        if directed:\n            b[v] += b[u]\n            b[u] = 0\n        yield communities.values()"
        ]
    },
    {
        "func_name": "greedy_modularity_communities",
        "original": "@nx._dispatch(edge_attrs='weight')\ndef greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1, best_n=None):\n    \"\"\"Find communities in G using greedy modularity maximization.\n\n    This function uses Clauset-Newman-Moore greedy modularity maximization [2]_\n    to find the community partition with the largest modularity.\n\n    Greedy modularity maximization begins with each node in its own community\n    and repeatedly joins the pair of communities that lead to the largest\n    modularity until no further increase in modularity is possible (a maximum).\n    Two keyword arguments adjust the stopping condition. `cutoff` is a lower\n    limit on the number of communities so you can stop the process before\n    reaching a maximum (used to save computation time). `best_n` is an upper\n    limit on the number of communities so you can make the process continue\n    until at most n communities remain even if the maximum modularity occurs\n    for more. To obtain exactly n communities, set both `cutoff` and `best_n` to n.\n\n    This function maximizes the generalized modularity, where `resolution`\n    is the resolution parameter, often expressed as $\\\\gamma$.\n    See :func:`~networkx.algorithms.community.quality.modularity`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : string or None, optional (default=None)\n        The name of an edge attribute that holds the numerical value used\n        as a weight.  If None, then each edge has weight 1.\n        The degree is the sum of the edge weights adjacent to the node.\n\n    resolution : float, optional (default=1)\n        If resolution is less than 1, modularity favors larger communities.\n        Greater than 1 favors smaller communities.\n\n    cutoff : int, optional (default=1)\n        A minimum number of communities below which the merging process stops.\n        The process stops at this number of communities even if modularity\n        is not maximized. The goal is to let the user stop the process early.\n        The process stops before the cutoff if it finds a maximum of modularity.\n\n    best_n : int or None, optional (default=None)\n        A maximum number of communities above which the merging process will\n        not stop. This forces community merging to continue after modularity\n        starts to decrease until `best_n` communities remain.\n        If ``None``, don't force it to continue beyond a maximum.\n\n    Raises\n    ------\n    ValueError : If the `cutoff` or `best_n`  value is not in the range\n        ``[1, G.number_of_nodes()]``, or if `best_n` < `cutoff`.\n\n    Returns\n    -------\n    communities: list\n        A list of frozensets of nodes, one for each community.\n        Sorted by length with largest communities first.\n\n    Examples\n    --------\n    >>> G = nx.karate_club_graph()\n    >>> c = nx.community.greedy_modularity_communities(G)\n    >>> sorted(c[0])\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\n\n    See Also\n    --------\n    modularity\n\n    References\n    ----------\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\n       Oxford University Press 2011.\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\n       \"Finding community structure in very large networks.\"\n       Physical Review E 70(6), 2004.\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\n       Detection\" Phys. Rev. E74, 2006.\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\n       Physical Review E 70(5 Pt 2):056131, 2004.\n    \"\"\"\n    if not G.size():\n        return [{n} for n in G]\n    if cutoff < 1 or cutoff > G.number_of_nodes():\n        raise ValueError(f'cutoff must be between 1 and {len(G)}. Got {cutoff}.')\n    if best_n is not None:\n        if best_n < 1 or best_n > G.number_of_nodes():\n            raise ValueError(f'best_n must be between 1 and {len(G)}. Got {best_n}.')\n        if best_n < cutoff:\n            raise ValueError(f'Must have best_n >= cutoff. Got {best_n} < {cutoff}')\n        if best_n == 1:\n            return [set(G)]\n    else:\n        best_n = G.number_of_nodes()\n    community_gen = _greedy_modularity_communities_generator(G, weight=weight, resolution=resolution)\n    communities = next(community_gen)\n    while len(communities) > cutoff:\n        try:\n            dq = next(community_gen)\n        except StopIteration:\n            communities = sorted(communities, key=len, reverse=True)\n            while len(communities) > best_n:\n                (comm1, comm2, *rest) = communities\n                communities = [comm1 ^ comm2]\n                communities.extend(rest)\n            return communities\n        if dq < 0 and len(communities) <= best_n:\n            break\n        communities = next(community_gen)\n    return sorted(communities, key=len, reverse=True)",
        "mutated": [
            "@nx._dispatch(edge_attrs='weight')\ndef greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1, best_n=None):\n    if False:\n        i = 10\n    'Find communities in G using greedy modularity maximization.\\n\\n    This function uses Clauset-Newman-Moore greedy modularity maximization [2]_\\n    to find the community partition with the largest modularity.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until no further increase in modularity is possible (a maximum).\\n    Two keyword arguments adjust the stopping condition. `cutoff` is a lower\\n    limit on the number of communities so you can stop the process before\\n    reaching a maximum (used to save computation time). `best_n` is an upper\\n    limit on the number of communities so you can make the process continue\\n    until at most n communities remain even if the maximum modularity occurs\\n    for more. To obtain exactly n communities, set both `cutoff` and `best_n` to n.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float, optional (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    cutoff : int, optional (default=1)\\n        A minimum number of communities below which the merging process stops.\\n        The process stops at this number of communities even if modularity\\n        is not maximized. The goal is to let the user stop the process early.\\n        The process stops before the cutoff if it finds a maximum of modularity.\\n\\n    best_n : int or None, optional (default=None)\\n        A maximum number of communities above which the merging process will\\n        not stop. This forces community merging to continue after modularity\\n        starts to decrease until `best_n` communities remain.\\n        If ``None``, don\\'t force it to continue beyond a maximum.\\n\\n    Raises\\n    ------\\n    ValueError : If the `cutoff` or `best_n`  value is not in the range\\n        ``[1, G.number_of_nodes()]``, or if `best_n` < `cutoff`.\\n\\n    Returns\\n    -------\\n    communities: list\\n        A list of frozensets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    if not G.size():\n        return [{n} for n in G]\n    if cutoff < 1 or cutoff > G.number_of_nodes():\n        raise ValueError(f'cutoff must be between 1 and {len(G)}. Got {cutoff}.')\n    if best_n is not None:\n        if best_n < 1 or best_n > G.number_of_nodes():\n            raise ValueError(f'best_n must be between 1 and {len(G)}. Got {best_n}.')\n        if best_n < cutoff:\n            raise ValueError(f'Must have best_n >= cutoff. Got {best_n} < {cutoff}')\n        if best_n == 1:\n            return [set(G)]\n    else:\n        best_n = G.number_of_nodes()\n    community_gen = _greedy_modularity_communities_generator(G, weight=weight, resolution=resolution)\n    communities = next(community_gen)\n    while len(communities) > cutoff:\n        try:\n            dq = next(community_gen)\n        except StopIteration:\n            communities = sorted(communities, key=len, reverse=True)\n            while len(communities) > best_n:\n                (comm1, comm2, *rest) = communities\n                communities = [comm1 ^ comm2]\n                communities.extend(rest)\n            return communities\n        if dq < 0 and len(communities) <= best_n:\n            break\n        communities = next(community_gen)\n    return sorted(communities, key=len, reverse=True)",
            "@nx._dispatch(edge_attrs='weight')\ndef greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1, best_n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find communities in G using greedy modularity maximization.\\n\\n    This function uses Clauset-Newman-Moore greedy modularity maximization [2]_\\n    to find the community partition with the largest modularity.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until no further increase in modularity is possible (a maximum).\\n    Two keyword arguments adjust the stopping condition. `cutoff` is a lower\\n    limit on the number of communities so you can stop the process before\\n    reaching a maximum (used to save computation time). `best_n` is an upper\\n    limit on the number of communities so you can make the process continue\\n    until at most n communities remain even if the maximum modularity occurs\\n    for more. To obtain exactly n communities, set both `cutoff` and `best_n` to n.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float, optional (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    cutoff : int, optional (default=1)\\n        A minimum number of communities below which the merging process stops.\\n        The process stops at this number of communities even if modularity\\n        is not maximized. The goal is to let the user stop the process early.\\n        The process stops before the cutoff if it finds a maximum of modularity.\\n\\n    best_n : int or None, optional (default=None)\\n        A maximum number of communities above which the merging process will\\n        not stop. This forces community merging to continue after modularity\\n        starts to decrease until `best_n` communities remain.\\n        If ``None``, don\\'t force it to continue beyond a maximum.\\n\\n    Raises\\n    ------\\n    ValueError : If the `cutoff` or `best_n`  value is not in the range\\n        ``[1, G.number_of_nodes()]``, or if `best_n` < `cutoff`.\\n\\n    Returns\\n    -------\\n    communities: list\\n        A list of frozensets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    if not G.size():\n        return [{n} for n in G]\n    if cutoff < 1 or cutoff > G.number_of_nodes():\n        raise ValueError(f'cutoff must be between 1 and {len(G)}. Got {cutoff}.')\n    if best_n is not None:\n        if best_n < 1 or best_n > G.number_of_nodes():\n            raise ValueError(f'best_n must be between 1 and {len(G)}. Got {best_n}.')\n        if best_n < cutoff:\n            raise ValueError(f'Must have best_n >= cutoff. Got {best_n} < {cutoff}')\n        if best_n == 1:\n            return [set(G)]\n    else:\n        best_n = G.number_of_nodes()\n    community_gen = _greedy_modularity_communities_generator(G, weight=weight, resolution=resolution)\n    communities = next(community_gen)\n    while len(communities) > cutoff:\n        try:\n            dq = next(community_gen)\n        except StopIteration:\n            communities = sorted(communities, key=len, reverse=True)\n            while len(communities) > best_n:\n                (comm1, comm2, *rest) = communities\n                communities = [comm1 ^ comm2]\n                communities.extend(rest)\n            return communities\n        if dq < 0 and len(communities) <= best_n:\n            break\n        communities = next(community_gen)\n    return sorted(communities, key=len, reverse=True)",
            "@nx._dispatch(edge_attrs='weight')\ndef greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1, best_n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find communities in G using greedy modularity maximization.\\n\\n    This function uses Clauset-Newman-Moore greedy modularity maximization [2]_\\n    to find the community partition with the largest modularity.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until no further increase in modularity is possible (a maximum).\\n    Two keyword arguments adjust the stopping condition. `cutoff` is a lower\\n    limit on the number of communities so you can stop the process before\\n    reaching a maximum (used to save computation time). `best_n` is an upper\\n    limit on the number of communities so you can make the process continue\\n    until at most n communities remain even if the maximum modularity occurs\\n    for more. To obtain exactly n communities, set both `cutoff` and `best_n` to n.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float, optional (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    cutoff : int, optional (default=1)\\n        A minimum number of communities below which the merging process stops.\\n        The process stops at this number of communities even if modularity\\n        is not maximized. The goal is to let the user stop the process early.\\n        The process stops before the cutoff if it finds a maximum of modularity.\\n\\n    best_n : int or None, optional (default=None)\\n        A maximum number of communities above which the merging process will\\n        not stop. This forces community merging to continue after modularity\\n        starts to decrease until `best_n` communities remain.\\n        If ``None``, don\\'t force it to continue beyond a maximum.\\n\\n    Raises\\n    ------\\n    ValueError : If the `cutoff` or `best_n`  value is not in the range\\n        ``[1, G.number_of_nodes()]``, or if `best_n` < `cutoff`.\\n\\n    Returns\\n    -------\\n    communities: list\\n        A list of frozensets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    if not G.size():\n        return [{n} for n in G]\n    if cutoff < 1 or cutoff > G.number_of_nodes():\n        raise ValueError(f'cutoff must be between 1 and {len(G)}. Got {cutoff}.')\n    if best_n is not None:\n        if best_n < 1 or best_n > G.number_of_nodes():\n            raise ValueError(f'best_n must be between 1 and {len(G)}. Got {best_n}.')\n        if best_n < cutoff:\n            raise ValueError(f'Must have best_n >= cutoff. Got {best_n} < {cutoff}')\n        if best_n == 1:\n            return [set(G)]\n    else:\n        best_n = G.number_of_nodes()\n    community_gen = _greedy_modularity_communities_generator(G, weight=weight, resolution=resolution)\n    communities = next(community_gen)\n    while len(communities) > cutoff:\n        try:\n            dq = next(community_gen)\n        except StopIteration:\n            communities = sorted(communities, key=len, reverse=True)\n            while len(communities) > best_n:\n                (comm1, comm2, *rest) = communities\n                communities = [comm1 ^ comm2]\n                communities.extend(rest)\n            return communities\n        if dq < 0 and len(communities) <= best_n:\n            break\n        communities = next(community_gen)\n    return sorted(communities, key=len, reverse=True)",
            "@nx._dispatch(edge_attrs='weight')\ndef greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1, best_n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find communities in G using greedy modularity maximization.\\n\\n    This function uses Clauset-Newman-Moore greedy modularity maximization [2]_\\n    to find the community partition with the largest modularity.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until no further increase in modularity is possible (a maximum).\\n    Two keyword arguments adjust the stopping condition. `cutoff` is a lower\\n    limit on the number of communities so you can stop the process before\\n    reaching a maximum (used to save computation time). `best_n` is an upper\\n    limit on the number of communities so you can make the process continue\\n    until at most n communities remain even if the maximum modularity occurs\\n    for more. To obtain exactly n communities, set both `cutoff` and `best_n` to n.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float, optional (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    cutoff : int, optional (default=1)\\n        A minimum number of communities below which the merging process stops.\\n        The process stops at this number of communities even if modularity\\n        is not maximized. The goal is to let the user stop the process early.\\n        The process stops before the cutoff if it finds a maximum of modularity.\\n\\n    best_n : int or None, optional (default=None)\\n        A maximum number of communities above which the merging process will\\n        not stop. This forces community merging to continue after modularity\\n        starts to decrease until `best_n` communities remain.\\n        If ``None``, don\\'t force it to continue beyond a maximum.\\n\\n    Raises\\n    ------\\n    ValueError : If the `cutoff` or `best_n`  value is not in the range\\n        ``[1, G.number_of_nodes()]``, or if `best_n` < `cutoff`.\\n\\n    Returns\\n    -------\\n    communities: list\\n        A list of frozensets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    if not G.size():\n        return [{n} for n in G]\n    if cutoff < 1 or cutoff > G.number_of_nodes():\n        raise ValueError(f'cutoff must be between 1 and {len(G)}. Got {cutoff}.')\n    if best_n is not None:\n        if best_n < 1 or best_n > G.number_of_nodes():\n            raise ValueError(f'best_n must be between 1 and {len(G)}. Got {best_n}.')\n        if best_n < cutoff:\n            raise ValueError(f'Must have best_n >= cutoff. Got {best_n} < {cutoff}')\n        if best_n == 1:\n            return [set(G)]\n    else:\n        best_n = G.number_of_nodes()\n    community_gen = _greedy_modularity_communities_generator(G, weight=weight, resolution=resolution)\n    communities = next(community_gen)\n    while len(communities) > cutoff:\n        try:\n            dq = next(community_gen)\n        except StopIteration:\n            communities = sorted(communities, key=len, reverse=True)\n            while len(communities) > best_n:\n                (comm1, comm2, *rest) = communities\n                communities = [comm1 ^ comm2]\n                communities.extend(rest)\n            return communities\n        if dq < 0 and len(communities) <= best_n:\n            break\n        communities = next(community_gen)\n    return sorted(communities, key=len, reverse=True)",
            "@nx._dispatch(edge_attrs='weight')\ndef greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1, best_n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find communities in G using greedy modularity maximization.\\n\\n    This function uses Clauset-Newman-Moore greedy modularity maximization [2]_\\n    to find the community partition with the largest modularity.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and repeatedly joins the pair of communities that lead to the largest\\n    modularity until no further increase in modularity is possible (a maximum).\\n    Two keyword arguments adjust the stopping condition. `cutoff` is a lower\\n    limit on the number of communities so you can stop the process before\\n    reaching a maximum (used to save computation time). `best_n` is an upper\\n    limit on the number of communities so you can make the process continue\\n    until at most n communities remain even if the maximum modularity occurs\\n    for more. To obtain exactly n communities, set both `cutoff` and `best_n` to n.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    resolution : float, optional (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    cutoff : int, optional (default=1)\\n        A minimum number of communities below which the merging process stops.\\n        The process stops at this number of communities even if modularity\\n        is not maximized. The goal is to let the user stop the process early.\\n        The process stops before the cutoff if it finds a maximum of modularity.\\n\\n    best_n : int or None, optional (default=None)\\n        A maximum number of communities above which the merging process will\\n        not stop. This forces community merging to continue after modularity\\n        starts to decrease until `best_n` communities remain.\\n        If ``None``, don\\'t force it to continue beyond a maximum.\\n\\n    Raises\\n    ------\\n    ValueError : If the `cutoff` or `best_n`  value is not in the range\\n        ``[1, G.number_of_nodes()]``, or if `best_n` < `cutoff`.\\n\\n    Returns\\n    -------\\n    communities: list\\n        A list of frozensets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    modularity\\n\\n    References\\n    ----------\\n    .. [1] Newman, M. E. J. \"Networks: An Introduction\", page 224\\n       Oxford University Press 2011.\\n    .. [2] Clauset, A., Newman, M. E., & Moore, C.\\n       \"Finding community structure in very large networks.\"\\n       Physical Review E 70(6), 2004.\\n    .. [3] Reichardt and Bornholdt \"Statistical Mechanics of Community\\n       Detection\" Phys. Rev. E74, 2006.\\n    .. [4] Newman, M. E. J.\"Analysis of weighted networks\"\\n       Physical Review E 70(5 Pt 2):056131, 2004.\\n    '\n    if not G.size():\n        return [{n} for n in G]\n    if cutoff < 1 or cutoff > G.number_of_nodes():\n        raise ValueError(f'cutoff must be between 1 and {len(G)}. Got {cutoff}.')\n    if best_n is not None:\n        if best_n < 1 or best_n > G.number_of_nodes():\n            raise ValueError(f'best_n must be between 1 and {len(G)}. Got {best_n}.')\n        if best_n < cutoff:\n            raise ValueError(f'Must have best_n >= cutoff. Got {best_n} < {cutoff}')\n        if best_n == 1:\n            return [set(G)]\n    else:\n        best_n = G.number_of_nodes()\n    community_gen = _greedy_modularity_communities_generator(G, weight=weight, resolution=resolution)\n    communities = next(community_gen)\n    while len(communities) > cutoff:\n        try:\n            dq = next(community_gen)\n        except StopIteration:\n            communities = sorted(communities, key=len, reverse=True)\n            while len(communities) > best_n:\n                (comm1, comm2, *rest) = communities\n                communities = [comm1 ^ comm2]\n                communities.extend(rest)\n            return communities\n        if dq < 0 and len(communities) <= best_n:\n            break\n        communities = next(community_gen)\n    return sorted(communities, key=len, reverse=True)"
        ]
    },
    {
        "func_name": "naive_greedy_modularity_communities",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch(edge_attrs='weight')\ndef naive_greedy_modularity_communities(G, resolution=1, weight=None):\n    \"\"\"Find communities in G using greedy modularity maximization.\n\n    This implementation is O(n^4), much slower than alternatives, but it is\n    provided as an easy-to-understand reference implementation.\n\n    Greedy modularity maximization begins with each node in its own community\n    and joins the pair of communities that most increases modularity until no\n    such pair exists.\n\n    This function maximizes the generalized modularity, where `resolution`\n    is the resolution parameter, often expressed as $\\\\gamma$.\n    See :func:`~networkx.algorithms.community.quality.modularity`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Graph must be simple and undirected.\n\n    resolution : float (default=1)\n        If resolution is less than 1, modularity favors larger communities.\n        Greater than 1 favors smaller communities.\n\n    weight : string or None, optional (default=None)\n        The name of an edge attribute that holds the numerical value used\n        as a weight.  If None, then each edge has weight 1.\n        The degree is the sum of the edge weights adjacent to the node.\n\n    Returns\n    -------\n    list\n        A list of sets of nodes, one for each community.\n        Sorted by length with largest communities first.\n\n    Examples\n    --------\n    >>> G = nx.karate_club_graph()\n    >>> c = nx.community.naive_greedy_modularity_communities(G)\n    >>> sorted(c[0])\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\n\n    See Also\n    --------\n    greedy_modularity_communities\n    modularity\n    \"\"\"\n    communities = [frozenset([u]) for u in G.nodes()]\n    merges = []\n    old_modularity = None\n    new_modularity = modularity(G, communities, resolution=resolution, weight=weight)\n    while old_modularity is None or new_modularity > old_modularity:\n        old_modularity = new_modularity\n        trial_communities = list(communities)\n        to_merge = None\n        for (i, u) in enumerate(communities):\n            for (j, v) in enumerate(communities):\n                if j <= i or len(u) == 0 or len(v) == 0:\n                    continue\n                trial_communities[j] = u | v\n                trial_communities[i] = frozenset([])\n                trial_modularity = modularity(G, trial_communities, resolution=resolution, weight=weight)\n                if trial_modularity >= new_modularity:\n                    if trial_modularity > new_modularity:\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                    elif to_merge and min(i, j) < min(to_merge[0], to_merge[1]):\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                trial_communities[i] = u\n                trial_communities[j] = v\n        if to_merge is not None:\n            merges.append(to_merge)\n            (i, j, dq) = to_merge\n            (u, v) = (communities[i], communities[j])\n            communities[j] = u | v\n            communities[i] = frozenset([])\n    return sorted((c for c in communities if len(c) > 0), key=len, reverse=True)",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch(edge_attrs='weight')\ndef naive_greedy_modularity_communities(G, resolution=1, weight=None):\n    if False:\n        i = 10\n    'Find communities in G using greedy modularity maximization.\\n\\n    This implementation is O(n^4), much slower than alternatives, but it is\\n    provided as an easy-to-understand reference implementation.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and joins the pair of communities that most increases modularity until no\\n    such pair exists.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    Returns\\n    -------\\n    list\\n        A list of sets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.naive_greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    greedy_modularity_communities\\n    modularity\\n    '\n    communities = [frozenset([u]) for u in G.nodes()]\n    merges = []\n    old_modularity = None\n    new_modularity = modularity(G, communities, resolution=resolution, weight=weight)\n    while old_modularity is None or new_modularity > old_modularity:\n        old_modularity = new_modularity\n        trial_communities = list(communities)\n        to_merge = None\n        for (i, u) in enumerate(communities):\n            for (j, v) in enumerate(communities):\n                if j <= i or len(u) == 0 or len(v) == 0:\n                    continue\n                trial_communities[j] = u | v\n                trial_communities[i] = frozenset([])\n                trial_modularity = modularity(G, trial_communities, resolution=resolution, weight=weight)\n                if trial_modularity >= new_modularity:\n                    if trial_modularity > new_modularity:\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                    elif to_merge and min(i, j) < min(to_merge[0], to_merge[1]):\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                trial_communities[i] = u\n                trial_communities[j] = v\n        if to_merge is not None:\n            merges.append(to_merge)\n            (i, j, dq) = to_merge\n            (u, v) = (communities[i], communities[j])\n            communities[j] = u | v\n            communities[i] = frozenset([])\n    return sorted((c for c in communities if len(c) > 0), key=len, reverse=True)",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch(edge_attrs='weight')\ndef naive_greedy_modularity_communities(G, resolution=1, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find communities in G using greedy modularity maximization.\\n\\n    This implementation is O(n^4), much slower than alternatives, but it is\\n    provided as an easy-to-understand reference implementation.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and joins the pair of communities that most increases modularity until no\\n    such pair exists.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    Returns\\n    -------\\n    list\\n        A list of sets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.naive_greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    greedy_modularity_communities\\n    modularity\\n    '\n    communities = [frozenset([u]) for u in G.nodes()]\n    merges = []\n    old_modularity = None\n    new_modularity = modularity(G, communities, resolution=resolution, weight=weight)\n    while old_modularity is None or new_modularity > old_modularity:\n        old_modularity = new_modularity\n        trial_communities = list(communities)\n        to_merge = None\n        for (i, u) in enumerate(communities):\n            for (j, v) in enumerate(communities):\n                if j <= i or len(u) == 0 or len(v) == 0:\n                    continue\n                trial_communities[j] = u | v\n                trial_communities[i] = frozenset([])\n                trial_modularity = modularity(G, trial_communities, resolution=resolution, weight=weight)\n                if trial_modularity >= new_modularity:\n                    if trial_modularity > new_modularity:\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                    elif to_merge and min(i, j) < min(to_merge[0], to_merge[1]):\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                trial_communities[i] = u\n                trial_communities[j] = v\n        if to_merge is not None:\n            merges.append(to_merge)\n            (i, j, dq) = to_merge\n            (u, v) = (communities[i], communities[j])\n            communities[j] = u | v\n            communities[i] = frozenset([])\n    return sorted((c for c in communities if len(c) > 0), key=len, reverse=True)",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch(edge_attrs='weight')\ndef naive_greedy_modularity_communities(G, resolution=1, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find communities in G using greedy modularity maximization.\\n\\n    This implementation is O(n^4), much slower than alternatives, but it is\\n    provided as an easy-to-understand reference implementation.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and joins the pair of communities that most increases modularity until no\\n    such pair exists.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    Returns\\n    -------\\n    list\\n        A list of sets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.naive_greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    greedy_modularity_communities\\n    modularity\\n    '\n    communities = [frozenset([u]) for u in G.nodes()]\n    merges = []\n    old_modularity = None\n    new_modularity = modularity(G, communities, resolution=resolution, weight=weight)\n    while old_modularity is None or new_modularity > old_modularity:\n        old_modularity = new_modularity\n        trial_communities = list(communities)\n        to_merge = None\n        for (i, u) in enumerate(communities):\n            for (j, v) in enumerate(communities):\n                if j <= i or len(u) == 0 or len(v) == 0:\n                    continue\n                trial_communities[j] = u | v\n                trial_communities[i] = frozenset([])\n                trial_modularity = modularity(G, trial_communities, resolution=resolution, weight=weight)\n                if trial_modularity >= new_modularity:\n                    if trial_modularity > new_modularity:\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                    elif to_merge and min(i, j) < min(to_merge[0], to_merge[1]):\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                trial_communities[i] = u\n                trial_communities[j] = v\n        if to_merge is not None:\n            merges.append(to_merge)\n            (i, j, dq) = to_merge\n            (u, v) = (communities[i], communities[j])\n            communities[j] = u | v\n            communities[i] = frozenset([])\n    return sorted((c for c in communities if len(c) > 0), key=len, reverse=True)",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch(edge_attrs='weight')\ndef naive_greedy_modularity_communities(G, resolution=1, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find communities in G using greedy modularity maximization.\\n\\n    This implementation is O(n^4), much slower than alternatives, but it is\\n    provided as an easy-to-understand reference implementation.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and joins the pair of communities that most increases modularity until no\\n    such pair exists.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    Returns\\n    -------\\n    list\\n        A list of sets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.naive_greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    greedy_modularity_communities\\n    modularity\\n    '\n    communities = [frozenset([u]) for u in G.nodes()]\n    merges = []\n    old_modularity = None\n    new_modularity = modularity(G, communities, resolution=resolution, weight=weight)\n    while old_modularity is None or new_modularity > old_modularity:\n        old_modularity = new_modularity\n        trial_communities = list(communities)\n        to_merge = None\n        for (i, u) in enumerate(communities):\n            for (j, v) in enumerate(communities):\n                if j <= i or len(u) == 0 or len(v) == 0:\n                    continue\n                trial_communities[j] = u | v\n                trial_communities[i] = frozenset([])\n                trial_modularity = modularity(G, trial_communities, resolution=resolution, weight=weight)\n                if trial_modularity >= new_modularity:\n                    if trial_modularity > new_modularity:\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                    elif to_merge and min(i, j) < min(to_merge[0], to_merge[1]):\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                trial_communities[i] = u\n                trial_communities[j] = v\n        if to_merge is not None:\n            merges.append(to_merge)\n            (i, j, dq) = to_merge\n            (u, v) = (communities[i], communities[j])\n            communities[j] = u | v\n            communities[i] = frozenset([])\n    return sorted((c for c in communities if len(c) > 0), key=len, reverse=True)",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch(edge_attrs='weight')\ndef naive_greedy_modularity_communities(G, resolution=1, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find communities in G using greedy modularity maximization.\\n\\n    This implementation is O(n^4), much slower than alternatives, but it is\\n    provided as an easy-to-understand reference implementation.\\n\\n    Greedy modularity maximization begins with each node in its own community\\n    and joins the pair of communities that most increases modularity until no\\n    such pair exists.\\n\\n    This function maximizes the generalized modularity, where `resolution`\\n    is the resolution parameter, often expressed as $\\\\gamma$.\\n    See :func:`~networkx.algorithms.community.quality.modularity`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    resolution : float (default=1)\\n        If resolution is less than 1, modularity favors larger communities.\\n        Greater than 1 favors smaller communities.\\n\\n    weight : string or None, optional (default=None)\\n        The name of an edge attribute that holds the numerical value used\\n        as a weight.  If None, then each edge has weight 1.\\n        The degree is the sum of the edge weights adjacent to the node.\\n\\n    Returns\\n    -------\\n    list\\n        A list of sets of nodes, one for each community.\\n        Sorted by length with largest communities first.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> c = nx.community.naive_greedy_modularity_communities(G)\\n    >>> sorted(c[0])\\n    [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\\n\\n    See Also\\n    --------\\n    greedy_modularity_communities\\n    modularity\\n    '\n    communities = [frozenset([u]) for u in G.nodes()]\n    merges = []\n    old_modularity = None\n    new_modularity = modularity(G, communities, resolution=resolution, weight=weight)\n    while old_modularity is None or new_modularity > old_modularity:\n        old_modularity = new_modularity\n        trial_communities = list(communities)\n        to_merge = None\n        for (i, u) in enumerate(communities):\n            for (j, v) in enumerate(communities):\n                if j <= i or len(u) == 0 or len(v) == 0:\n                    continue\n                trial_communities[j] = u | v\n                trial_communities[i] = frozenset([])\n                trial_modularity = modularity(G, trial_communities, resolution=resolution, weight=weight)\n                if trial_modularity >= new_modularity:\n                    if trial_modularity > new_modularity:\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                    elif to_merge and min(i, j) < min(to_merge[0], to_merge[1]):\n                        new_modularity = trial_modularity\n                        to_merge = (i, j, new_modularity - old_modularity)\n                trial_communities[i] = u\n                trial_communities[j] = v\n        if to_merge is not None:\n            merges.append(to_merge)\n            (i, j, dq) = to_merge\n            (u, v) = (communities[i], communities[j])\n            communities[j] = u | v\n            communities[i] = frozenset([])\n    return sorted((c for c in communities if len(c) > 0), key=len, reverse=True)"
        ]
    }
]