[
    {
        "func_name": "_compress_ids",
        "original": "def _compress_ids(data):\n    \"\"\"\n    Function to take incoming raw state data and roll IDs with multiple names\n    into a single state block for reporting purposes. This functionality is most\n    useful for any \"_id\" state_output options, such as ``terse_id``.\n\n    The following example state has one ID and four names.\n\n    .. code-block:: yaml\n\n    mix-matched results:\n      cmd.run:\n        - names:\n          - \"true\"\n          - \"false\"\n          - \"/bin/true\"\n          - \"/bin/false\"\n\n    With ``state_output: terse_id`` set, this can create many lines of output\n    which are not unique enough to be worth the screen real estate they occupy.\n\n    .. code-block:: text\n\n        19:10:10.969049 [  8.546 ms]        cmd.run        Changed   Name: mix-matched results\n        19:10:10.977998 [  8.606 ms]        cmd.run        Failed    Name: mix-matched results\n        19:10:10.987116 [  7.618 ms]        cmd.run        Changed   Name: mix-matched results\n        19:10:10.995172 [  9.344 ms]        cmd.run        Failed    Name: mix-matched results\n\n    Enabling ``state_compress_ids: True`` consolidates the state data by ID and\n    result (e.g. success or failure). The earliest start time is chosen for\n    display, duration is aggregated, and the total number of names if shown in\n    parentheses to the right of the ID.\n\n    .. code-block:: text\n\n        19:10:46.283323 [ 16.236 ms]        cmd.run        Changed   Name: mix-matched results (2)\n        19:10:46.292181 [ 16.255 ms]        cmd.run        Failed    Name: mix-matched results (2)\n\n    A better real world use case would be passing dozens of files and\n    directories to the ``names`` parameter of the ``file.absent`` state. The\n    amount of lines consolidated in that case would be substantial.\n    \"\"\"\n    if not isinstance(data, dict):\n        return data\n    compressed = {}\n    try:\n        for (host, hostdata) in data.items():\n            compressed[host] = {}\n            id_count = collections.Counter(['_'.join(map(str, [tname.split('_|-')[0], info['__id__'], info['__sls__'], info['result']])) for (tname, info) in hostdata.items()])\n            for (tname, info) in hostdata.items():\n                comps = tname.split('_|-')\n                _id = '_'.join(map(str, [comps[0], info['__id__'], info['__sls__'], info['result']]))\n                if id_count[_id] == 1:\n                    compressed[host][tname] = info\n                    continue\n                comps[2] = '_'.join(map(str, ['state_compressed', info['__sls__'], info['__id__'], info['result']]))\n                comps[1] = '{} ({})'.format(info['__id__'], id_count[_id])\n                tname = '_|-'.join(comps)\n                if tname not in compressed[host]:\n                    compressed[host][tname] = info\n                    continue\n                compressed[host][tname]['__run_num__'] = min(info['__run_num__'], compressed[host][tname]['__run_num__'])\n                compressed[host][tname]['duration'] = round(sum([info['duration'], compressed[host][tname]['duration']]), 3)\n                compressed[host][tname]['start_time'] = sorted([info['start_time'], compressed[host][tname]['start_time']])[0]\n                if compressed[host][tname].get('changes') and info.get('changes'):\n                    if not compressed[host][tname]['changes'].get('compressed changes'):\n                        compressed[host][tname]['changes'] = {'compressed changes': {compressed[host][tname]['name']: compressed[host][tname]['changes']}}\n                    compressed[host][tname]['changes']['compressed changes'].update({info['name']: info['changes']})\n                elif info.get('changes'):\n                    compressed[host][tname]['changes'] = {'compressed changes': {info['name']: info['changes']}}\n    except Exception:\n        log.warning('Unable to compress state output by ID! Returning output normally.')\n        return data\n    return compressed",
        "mutated": [
            "def _compress_ids(data):\n    if False:\n        i = 10\n    '\\n    Function to take incoming raw state data and roll IDs with multiple names\\n    into a single state block for reporting purposes. This functionality is most\\n    useful for any \"_id\" state_output options, such as ``terse_id``.\\n\\n    The following example state has one ID and four names.\\n\\n    .. code-block:: yaml\\n\\n    mix-matched results:\\n      cmd.run:\\n        - names:\\n          - \"true\"\\n          - \"false\"\\n          - \"/bin/true\"\\n          - \"/bin/false\"\\n\\n    With ``state_output: terse_id`` set, this can create many lines of output\\n    which are not unique enough to be worth the screen real estate they occupy.\\n\\n    .. code-block:: text\\n\\n        19:10:10.969049 [  8.546 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.977998 [  8.606 ms]        cmd.run        Failed    Name: mix-matched results\\n        19:10:10.987116 [  7.618 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.995172 [  9.344 ms]        cmd.run        Failed    Name: mix-matched results\\n\\n    Enabling ``state_compress_ids: True`` consolidates the state data by ID and\\n    result (e.g. success or failure). The earliest start time is chosen for\\n    display, duration is aggregated, and the total number of names if shown in\\n    parentheses to the right of the ID.\\n\\n    .. code-block:: text\\n\\n        19:10:46.283323 [ 16.236 ms]        cmd.run        Changed   Name: mix-matched results (2)\\n        19:10:46.292181 [ 16.255 ms]        cmd.run        Failed    Name: mix-matched results (2)\\n\\n    A better real world use case would be passing dozens of files and\\n    directories to the ``names`` parameter of the ``file.absent`` state. The\\n    amount of lines consolidated in that case would be substantial.\\n    '\n    if not isinstance(data, dict):\n        return data\n    compressed = {}\n    try:\n        for (host, hostdata) in data.items():\n            compressed[host] = {}\n            id_count = collections.Counter(['_'.join(map(str, [tname.split('_|-')[0], info['__id__'], info['__sls__'], info['result']])) for (tname, info) in hostdata.items()])\n            for (tname, info) in hostdata.items():\n                comps = tname.split('_|-')\n                _id = '_'.join(map(str, [comps[0], info['__id__'], info['__sls__'], info['result']]))\n                if id_count[_id] == 1:\n                    compressed[host][tname] = info\n                    continue\n                comps[2] = '_'.join(map(str, ['state_compressed', info['__sls__'], info['__id__'], info['result']]))\n                comps[1] = '{} ({})'.format(info['__id__'], id_count[_id])\n                tname = '_|-'.join(comps)\n                if tname not in compressed[host]:\n                    compressed[host][tname] = info\n                    continue\n                compressed[host][tname]['__run_num__'] = min(info['__run_num__'], compressed[host][tname]['__run_num__'])\n                compressed[host][tname]['duration'] = round(sum([info['duration'], compressed[host][tname]['duration']]), 3)\n                compressed[host][tname]['start_time'] = sorted([info['start_time'], compressed[host][tname]['start_time']])[0]\n                if compressed[host][tname].get('changes') and info.get('changes'):\n                    if not compressed[host][tname]['changes'].get('compressed changes'):\n                        compressed[host][tname]['changes'] = {'compressed changes': {compressed[host][tname]['name']: compressed[host][tname]['changes']}}\n                    compressed[host][tname]['changes']['compressed changes'].update({info['name']: info['changes']})\n                elif info.get('changes'):\n                    compressed[host][tname]['changes'] = {'compressed changes': {info['name']: info['changes']}}\n    except Exception:\n        log.warning('Unable to compress state output by ID! Returning output normally.')\n        return data\n    return compressed",
            "def _compress_ids(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Function to take incoming raw state data and roll IDs with multiple names\\n    into a single state block for reporting purposes. This functionality is most\\n    useful for any \"_id\" state_output options, such as ``terse_id``.\\n\\n    The following example state has one ID and four names.\\n\\n    .. code-block:: yaml\\n\\n    mix-matched results:\\n      cmd.run:\\n        - names:\\n          - \"true\"\\n          - \"false\"\\n          - \"/bin/true\"\\n          - \"/bin/false\"\\n\\n    With ``state_output: terse_id`` set, this can create many lines of output\\n    which are not unique enough to be worth the screen real estate they occupy.\\n\\n    .. code-block:: text\\n\\n        19:10:10.969049 [  8.546 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.977998 [  8.606 ms]        cmd.run        Failed    Name: mix-matched results\\n        19:10:10.987116 [  7.618 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.995172 [  9.344 ms]        cmd.run        Failed    Name: mix-matched results\\n\\n    Enabling ``state_compress_ids: True`` consolidates the state data by ID and\\n    result (e.g. success or failure). The earliest start time is chosen for\\n    display, duration is aggregated, and the total number of names if shown in\\n    parentheses to the right of the ID.\\n\\n    .. code-block:: text\\n\\n        19:10:46.283323 [ 16.236 ms]        cmd.run        Changed   Name: mix-matched results (2)\\n        19:10:46.292181 [ 16.255 ms]        cmd.run        Failed    Name: mix-matched results (2)\\n\\n    A better real world use case would be passing dozens of files and\\n    directories to the ``names`` parameter of the ``file.absent`` state. The\\n    amount of lines consolidated in that case would be substantial.\\n    '\n    if not isinstance(data, dict):\n        return data\n    compressed = {}\n    try:\n        for (host, hostdata) in data.items():\n            compressed[host] = {}\n            id_count = collections.Counter(['_'.join(map(str, [tname.split('_|-')[0], info['__id__'], info['__sls__'], info['result']])) for (tname, info) in hostdata.items()])\n            for (tname, info) in hostdata.items():\n                comps = tname.split('_|-')\n                _id = '_'.join(map(str, [comps[0], info['__id__'], info['__sls__'], info['result']]))\n                if id_count[_id] == 1:\n                    compressed[host][tname] = info\n                    continue\n                comps[2] = '_'.join(map(str, ['state_compressed', info['__sls__'], info['__id__'], info['result']]))\n                comps[1] = '{} ({})'.format(info['__id__'], id_count[_id])\n                tname = '_|-'.join(comps)\n                if tname not in compressed[host]:\n                    compressed[host][tname] = info\n                    continue\n                compressed[host][tname]['__run_num__'] = min(info['__run_num__'], compressed[host][tname]['__run_num__'])\n                compressed[host][tname]['duration'] = round(sum([info['duration'], compressed[host][tname]['duration']]), 3)\n                compressed[host][tname]['start_time'] = sorted([info['start_time'], compressed[host][tname]['start_time']])[0]\n                if compressed[host][tname].get('changes') and info.get('changes'):\n                    if not compressed[host][tname]['changes'].get('compressed changes'):\n                        compressed[host][tname]['changes'] = {'compressed changes': {compressed[host][tname]['name']: compressed[host][tname]['changes']}}\n                    compressed[host][tname]['changes']['compressed changes'].update({info['name']: info['changes']})\n                elif info.get('changes'):\n                    compressed[host][tname]['changes'] = {'compressed changes': {info['name']: info['changes']}}\n    except Exception:\n        log.warning('Unable to compress state output by ID! Returning output normally.')\n        return data\n    return compressed",
            "def _compress_ids(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Function to take incoming raw state data and roll IDs with multiple names\\n    into a single state block for reporting purposes. This functionality is most\\n    useful for any \"_id\" state_output options, such as ``terse_id``.\\n\\n    The following example state has one ID and four names.\\n\\n    .. code-block:: yaml\\n\\n    mix-matched results:\\n      cmd.run:\\n        - names:\\n          - \"true\"\\n          - \"false\"\\n          - \"/bin/true\"\\n          - \"/bin/false\"\\n\\n    With ``state_output: terse_id`` set, this can create many lines of output\\n    which are not unique enough to be worth the screen real estate they occupy.\\n\\n    .. code-block:: text\\n\\n        19:10:10.969049 [  8.546 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.977998 [  8.606 ms]        cmd.run        Failed    Name: mix-matched results\\n        19:10:10.987116 [  7.618 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.995172 [  9.344 ms]        cmd.run        Failed    Name: mix-matched results\\n\\n    Enabling ``state_compress_ids: True`` consolidates the state data by ID and\\n    result (e.g. success or failure). The earliest start time is chosen for\\n    display, duration is aggregated, and the total number of names if shown in\\n    parentheses to the right of the ID.\\n\\n    .. code-block:: text\\n\\n        19:10:46.283323 [ 16.236 ms]        cmd.run        Changed   Name: mix-matched results (2)\\n        19:10:46.292181 [ 16.255 ms]        cmd.run        Failed    Name: mix-matched results (2)\\n\\n    A better real world use case would be passing dozens of files and\\n    directories to the ``names`` parameter of the ``file.absent`` state. The\\n    amount of lines consolidated in that case would be substantial.\\n    '\n    if not isinstance(data, dict):\n        return data\n    compressed = {}\n    try:\n        for (host, hostdata) in data.items():\n            compressed[host] = {}\n            id_count = collections.Counter(['_'.join(map(str, [tname.split('_|-')[0], info['__id__'], info['__sls__'], info['result']])) for (tname, info) in hostdata.items()])\n            for (tname, info) in hostdata.items():\n                comps = tname.split('_|-')\n                _id = '_'.join(map(str, [comps[0], info['__id__'], info['__sls__'], info['result']]))\n                if id_count[_id] == 1:\n                    compressed[host][tname] = info\n                    continue\n                comps[2] = '_'.join(map(str, ['state_compressed', info['__sls__'], info['__id__'], info['result']]))\n                comps[1] = '{} ({})'.format(info['__id__'], id_count[_id])\n                tname = '_|-'.join(comps)\n                if tname not in compressed[host]:\n                    compressed[host][tname] = info\n                    continue\n                compressed[host][tname]['__run_num__'] = min(info['__run_num__'], compressed[host][tname]['__run_num__'])\n                compressed[host][tname]['duration'] = round(sum([info['duration'], compressed[host][tname]['duration']]), 3)\n                compressed[host][tname]['start_time'] = sorted([info['start_time'], compressed[host][tname]['start_time']])[0]\n                if compressed[host][tname].get('changes') and info.get('changes'):\n                    if not compressed[host][tname]['changes'].get('compressed changes'):\n                        compressed[host][tname]['changes'] = {'compressed changes': {compressed[host][tname]['name']: compressed[host][tname]['changes']}}\n                    compressed[host][tname]['changes']['compressed changes'].update({info['name']: info['changes']})\n                elif info.get('changes'):\n                    compressed[host][tname]['changes'] = {'compressed changes': {info['name']: info['changes']}}\n    except Exception:\n        log.warning('Unable to compress state output by ID! Returning output normally.')\n        return data\n    return compressed",
            "def _compress_ids(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Function to take incoming raw state data and roll IDs with multiple names\\n    into a single state block for reporting purposes. This functionality is most\\n    useful for any \"_id\" state_output options, such as ``terse_id``.\\n\\n    The following example state has one ID and four names.\\n\\n    .. code-block:: yaml\\n\\n    mix-matched results:\\n      cmd.run:\\n        - names:\\n          - \"true\"\\n          - \"false\"\\n          - \"/bin/true\"\\n          - \"/bin/false\"\\n\\n    With ``state_output: terse_id`` set, this can create many lines of output\\n    which are not unique enough to be worth the screen real estate they occupy.\\n\\n    .. code-block:: text\\n\\n        19:10:10.969049 [  8.546 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.977998 [  8.606 ms]        cmd.run        Failed    Name: mix-matched results\\n        19:10:10.987116 [  7.618 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.995172 [  9.344 ms]        cmd.run        Failed    Name: mix-matched results\\n\\n    Enabling ``state_compress_ids: True`` consolidates the state data by ID and\\n    result (e.g. success or failure). The earliest start time is chosen for\\n    display, duration is aggregated, and the total number of names if shown in\\n    parentheses to the right of the ID.\\n\\n    .. code-block:: text\\n\\n        19:10:46.283323 [ 16.236 ms]        cmd.run        Changed   Name: mix-matched results (2)\\n        19:10:46.292181 [ 16.255 ms]        cmd.run        Failed    Name: mix-matched results (2)\\n\\n    A better real world use case would be passing dozens of files and\\n    directories to the ``names`` parameter of the ``file.absent`` state. The\\n    amount of lines consolidated in that case would be substantial.\\n    '\n    if not isinstance(data, dict):\n        return data\n    compressed = {}\n    try:\n        for (host, hostdata) in data.items():\n            compressed[host] = {}\n            id_count = collections.Counter(['_'.join(map(str, [tname.split('_|-')[0], info['__id__'], info['__sls__'], info['result']])) for (tname, info) in hostdata.items()])\n            for (tname, info) in hostdata.items():\n                comps = tname.split('_|-')\n                _id = '_'.join(map(str, [comps[0], info['__id__'], info['__sls__'], info['result']]))\n                if id_count[_id] == 1:\n                    compressed[host][tname] = info\n                    continue\n                comps[2] = '_'.join(map(str, ['state_compressed', info['__sls__'], info['__id__'], info['result']]))\n                comps[1] = '{} ({})'.format(info['__id__'], id_count[_id])\n                tname = '_|-'.join(comps)\n                if tname not in compressed[host]:\n                    compressed[host][tname] = info\n                    continue\n                compressed[host][tname]['__run_num__'] = min(info['__run_num__'], compressed[host][tname]['__run_num__'])\n                compressed[host][tname]['duration'] = round(sum([info['duration'], compressed[host][tname]['duration']]), 3)\n                compressed[host][tname]['start_time'] = sorted([info['start_time'], compressed[host][tname]['start_time']])[0]\n                if compressed[host][tname].get('changes') and info.get('changes'):\n                    if not compressed[host][tname]['changes'].get('compressed changes'):\n                        compressed[host][tname]['changes'] = {'compressed changes': {compressed[host][tname]['name']: compressed[host][tname]['changes']}}\n                    compressed[host][tname]['changes']['compressed changes'].update({info['name']: info['changes']})\n                elif info.get('changes'):\n                    compressed[host][tname]['changes'] = {'compressed changes': {info['name']: info['changes']}}\n    except Exception:\n        log.warning('Unable to compress state output by ID! Returning output normally.')\n        return data\n    return compressed",
            "def _compress_ids(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Function to take incoming raw state data and roll IDs with multiple names\\n    into a single state block for reporting purposes. This functionality is most\\n    useful for any \"_id\" state_output options, such as ``terse_id``.\\n\\n    The following example state has one ID and four names.\\n\\n    .. code-block:: yaml\\n\\n    mix-matched results:\\n      cmd.run:\\n        - names:\\n          - \"true\"\\n          - \"false\"\\n          - \"/bin/true\"\\n          - \"/bin/false\"\\n\\n    With ``state_output: terse_id`` set, this can create many lines of output\\n    which are not unique enough to be worth the screen real estate they occupy.\\n\\n    .. code-block:: text\\n\\n        19:10:10.969049 [  8.546 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.977998 [  8.606 ms]        cmd.run        Failed    Name: mix-matched results\\n        19:10:10.987116 [  7.618 ms]        cmd.run        Changed   Name: mix-matched results\\n        19:10:10.995172 [  9.344 ms]        cmd.run        Failed    Name: mix-matched results\\n\\n    Enabling ``state_compress_ids: True`` consolidates the state data by ID and\\n    result (e.g. success or failure). The earliest start time is chosen for\\n    display, duration is aggregated, and the total number of names if shown in\\n    parentheses to the right of the ID.\\n\\n    .. code-block:: text\\n\\n        19:10:46.283323 [ 16.236 ms]        cmd.run        Changed   Name: mix-matched results (2)\\n        19:10:46.292181 [ 16.255 ms]        cmd.run        Failed    Name: mix-matched results (2)\\n\\n    A better real world use case would be passing dozens of files and\\n    directories to the ``names`` parameter of the ``file.absent`` state. The\\n    amount of lines consolidated in that case would be substantial.\\n    '\n    if not isinstance(data, dict):\n        return data\n    compressed = {}\n    try:\n        for (host, hostdata) in data.items():\n            compressed[host] = {}\n            id_count = collections.Counter(['_'.join(map(str, [tname.split('_|-')[0], info['__id__'], info['__sls__'], info['result']])) for (tname, info) in hostdata.items()])\n            for (tname, info) in hostdata.items():\n                comps = tname.split('_|-')\n                _id = '_'.join(map(str, [comps[0], info['__id__'], info['__sls__'], info['result']]))\n                if id_count[_id] == 1:\n                    compressed[host][tname] = info\n                    continue\n                comps[2] = '_'.join(map(str, ['state_compressed', info['__sls__'], info['__id__'], info['result']]))\n                comps[1] = '{} ({})'.format(info['__id__'], id_count[_id])\n                tname = '_|-'.join(comps)\n                if tname not in compressed[host]:\n                    compressed[host][tname] = info\n                    continue\n                compressed[host][tname]['__run_num__'] = min(info['__run_num__'], compressed[host][tname]['__run_num__'])\n                compressed[host][tname]['duration'] = round(sum([info['duration'], compressed[host][tname]['duration']]), 3)\n                compressed[host][tname]['start_time'] = sorted([info['start_time'], compressed[host][tname]['start_time']])[0]\n                if compressed[host][tname].get('changes') and info.get('changes'):\n                    if not compressed[host][tname]['changes'].get('compressed changes'):\n                        compressed[host][tname]['changes'] = {'compressed changes': {compressed[host][tname]['name']: compressed[host][tname]['changes']}}\n                    compressed[host][tname]['changes']['compressed changes'].update({info['name']: info['changes']})\n                elif info.get('changes'):\n                    compressed[host][tname]['changes'] = {'compressed changes': {info['name']: info['changes']}}\n    except Exception:\n        log.warning('Unable to compress state output by ID! Returning output normally.')\n        return data\n    return compressed"
        ]
    },
    {
        "func_name": "output",
        "original": "def output(data, **kwargs):\n    \"\"\"\n    The HighState Outputter is only meant to be used with the state.highstate\n    function, or a function that returns highstate return data.\n    \"\"\"\n    if isinstance(data, dict) and 'return' in data:\n        data = data['return']\n    if isinstance(data, dict) and 'data' in data:\n        data = data['data']\n    if isinstance(data, dict) and len(data.keys()) == 1:\n        _data = next(iter(data.values()))\n        if isinstance(_data, dict):\n            if 'jid' in _data and 'fun' in _data:\n                data = _data.get('return', {}).get('data', data)\n    if isinstance(data, int) or isinstance(data, str):\n        return data\n    if data is None:\n        return 'None'\n    local_masters = [key for key in data.keys() if key.endswith('_master')]\n    orchestrator_output = 'retcode' in data.keys() and len(local_masters) == 1\n    if orchestrator_output:\n        del data['retcode']\n    if __opts__.get('state_compress_ids', False):\n        data = _compress_ids(data)\n    indent_level = kwargs.get('indent_level', 1)\n    ret = [_format_host(host, hostdata, indent_level=indent_level)[0] for (host, hostdata) in data.items()]\n    if ret:\n        return '\\n'.join(ret)\n    log.error('Data passed to highstate outputter is not a valid highstate return: %s', data)\n    return ''",
        "mutated": [
            "def output(data, **kwargs):\n    if False:\n        i = 10\n    '\\n    The HighState Outputter is only meant to be used with the state.highstate\\n    function, or a function that returns highstate return data.\\n    '\n    if isinstance(data, dict) and 'return' in data:\n        data = data['return']\n    if isinstance(data, dict) and 'data' in data:\n        data = data['data']\n    if isinstance(data, dict) and len(data.keys()) == 1:\n        _data = next(iter(data.values()))\n        if isinstance(_data, dict):\n            if 'jid' in _data and 'fun' in _data:\n                data = _data.get('return', {}).get('data', data)\n    if isinstance(data, int) or isinstance(data, str):\n        return data\n    if data is None:\n        return 'None'\n    local_masters = [key for key in data.keys() if key.endswith('_master')]\n    orchestrator_output = 'retcode' in data.keys() and len(local_masters) == 1\n    if orchestrator_output:\n        del data['retcode']\n    if __opts__.get('state_compress_ids', False):\n        data = _compress_ids(data)\n    indent_level = kwargs.get('indent_level', 1)\n    ret = [_format_host(host, hostdata, indent_level=indent_level)[0] for (host, hostdata) in data.items()]\n    if ret:\n        return '\\n'.join(ret)\n    log.error('Data passed to highstate outputter is not a valid highstate return: %s', data)\n    return ''",
            "def output(data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The HighState Outputter is only meant to be used with the state.highstate\\n    function, or a function that returns highstate return data.\\n    '\n    if isinstance(data, dict) and 'return' in data:\n        data = data['return']\n    if isinstance(data, dict) and 'data' in data:\n        data = data['data']\n    if isinstance(data, dict) and len(data.keys()) == 1:\n        _data = next(iter(data.values()))\n        if isinstance(_data, dict):\n            if 'jid' in _data and 'fun' in _data:\n                data = _data.get('return', {}).get('data', data)\n    if isinstance(data, int) or isinstance(data, str):\n        return data\n    if data is None:\n        return 'None'\n    local_masters = [key for key in data.keys() if key.endswith('_master')]\n    orchestrator_output = 'retcode' in data.keys() and len(local_masters) == 1\n    if orchestrator_output:\n        del data['retcode']\n    if __opts__.get('state_compress_ids', False):\n        data = _compress_ids(data)\n    indent_level = kwargs.get('indent_level', 1)\n    ret = [_format_host(host, hostdata, indent_level=indent_level)[0] for (host, hostdata) in data.items()]\n    if ret:\n        return '\\n'.join(ret)\n    log.error('Data passed to highstate outputter is not a valid highstate return: %s', data)\n    return ''",
            "def output(data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The HighState Outputter is only meant to be used with the state.highstate\\n    function, or a function that returns highstate return data.\\n    '\n    if isinstance(data, dict) and 'return' in data:\n        data = data['return']\n    if isinstance(data, dict) and 'data' in data:\n        data = data['data']\n    if isinstance(data, dict) and len(data.keys()) == 1:\n        _data = next(iter(data.values()))\n        if isinstance(_data, dict):\n            if 'jid' in _data and 'fun' in _data:\n                data = _data.get('return', {}).get('data', data)\n    if isinstance(data, int) or isinstance(data, str):\n        return data\n    if data is None:\n        return 'None'\n    local_masters = [key for key in data.keys() if key.endswith('_master')]\n    orchestrator_output = 'retcode' in data.keys() and len(local_masters) == 1\n    if orchestrator_output:\n        del data['retcode']\n    if __opts__.get('state_compress_ids', False):\n        data = _compress_ids(data)\n    indent_level = kwargs.get('indent_level', 1)\n    ret = [_format_host(host, hostdata, indent_level=indent_level)[0] for (host, hostdata) in data.items()]\n    if ret:\n        return '\\n'.join(ret)\n    log.error('Data passed to highstate outputter is not a valid highstate return: %s', data)\n    return ''",
            "def output(data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The HighState Outputter is only meant to be used with the state.highstate\\n    function, or a function that returns highstate return data.\\n    '\n    if isinstance(data, dict) and 'return' in data:\n        data = data['return']\n    if isinstance(data, dict) and 'data' in data:\n        data = data['data']\n    if isinstance(data, dict) and len(data.keys()) == 1:\n        _data = next(iter(data.values()))\n        if isinstance(_data, dict):\n            if 'jid' in _data and 'fun' in _data:\n                data = _data.get('return', {}).get('data', data)\n    if isinstance(data, int) or isinstance(data, str):\n        return data\n    if data is None:\n        return 'None'\n    local_masters = [key for key in data.keys() if key.endswith('_master')]\n    orchestrator_output = 'retcode' in data.keys() and len(local_masters) == 1\n    if orchestrator_output:\n        del data['retcode']\n    if __opts__.get('state_compress_ids', False):\n        data = _compress_ids(data)\n    indent_level = kwargs.get('indent_level', 1)\n    ret = [_format_host(host, hostdata, indent_level=indent_level)[0] for (host, hostdata) in data.items()]\n    if ret:\n        return '\\n'.join(ret)\n    log.error('Data passed to highstate outputter is not a valid highstate return: %s', data)\n    return ''",
            "def output(data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The HighState Outputter is only meant to be used with the state.highstate\\n    function, or a function that returns highstate return data.\\n    '\n    if isinstance(data, dict) and 'return' in data:\n        data = data['return']\n    if isinstance(data, dict) and 'data' in data:\n        data = data['data']\n    if isinstance(data, dict) and len(data.keys()) == 1:\n        _data = next(iter(data.values()))\n        if isinstance(_data, dict):\n            if 'jid' in _data and 'fun' in _data:\n                data = _data.get('return', {}).get('data', data)\n    if isinstance(data, int) or isinstance(data, str):\n        return data\n    if data is None:\n        return 'None'\n    local_masters = [key for key in data.keys() if key.endswith('_master')]\n    orchestrator_output = 'retcode' in data.keys() and len(local_masters) == 1\n    if orchestrator_output:\n        del data['retcode']\n    if __opts__.get('state_compress_ids', False):\n        data = _compress_ids(data)\n    indent_level = kwargs.get('indent_level', 1)\n    ret = [_format_host(host, hostdata, indent_level=indent_level)[0] for (host, hostdata) in data.items()]\n    if ret:\n        return '\\n'.join(ret)\n    log.error('Data passed to highstate outputter is not a valid highstate return: %s', data)\n    return ''"
        ]
    },
    {
        "func_name": "_counts",
        "original": "def _counts(label, count):\n    return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))",
        "mutated": [
            "def _counts(label, count):\n    if False:\n        i = 10\n    return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))",
            "def _counts(label, count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))",
            "def _counts(label, count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))",
            "def _counts(label, count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))",
            "def _counts(label, count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))"
        ]
    },
    {
        "func_name": "_format_host",
        "original": "def _format_host(host, data, indent_level=1):\n    \"\"\"\n    Main highstate formatter. can be called recursively if a nested highstate\n    contains other highstates (ie in an orchestration)\n    \"\"\"\n    host = salt.utils.data.decode(host)\n    colors = salt.utils.color.get_colors(__opts__.get('color'), __opts__.get('color_theme'))\n    tabular = __opts__.get('state_tabular', False)\n    rcounts = {}\n    rdurations = []\n    pdurations = []\n    hcolor = colors['GREEN']\n    hstrs = []\n    nchanges = 0\n    strip_colors = __opts__.get('strip_colors', True)\n    if isinstance(data, int):\n        nchanges = 1\n        hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, str):\n        nchanges = 1\n        for data in data.splitlines():\n            hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, list):\n        hcolor = colors['LIGHT_RED']\n        hstrs.append('    {0}Data failed to compile:{1[ENDC]}'.format(hcolor, colors))\n        for err in data:\n            if strip_colors:\n                err = salt.output.strip_esc_sequence(salt.utils.data.decode(err))\n            hstrs.append('{0}----------\\n    {1}{2[ENDC]}'.format(hcolor, err, colors))\n    elif isinstance(data, dict):\n        data_tmp = {}\n        for (tname, info) in data.items():\n            if isinstance(info, dict) and tname != 'changes' and info and ('__run_num__' not in info):\n                err = 'The State execution failed to record the order in which all states were executed. The state return missing data is:'\n                hstrs.insert(0, pprint.pformat(info))\n                hstrs.insert(0, err)\n            if isinstance(info, dict) and 'result' in info:\n                data_tmp[tname] = info\n        data = data_tmp\n        for tname in sorted(data, key=lambda k: data[k].get('__run_num__', 0)):\n            ret = data[tname]\n            rcounts.setdefault(ret['result'], 0)\n            compressed_count = 1\n            if __opts__.get('state_compress_ids', False) and '_|-state_compressed_' in tname:\n                (_, _id, _, _) = tname.split('_|-')\n                count_match = re.search('\\\\((\\\\d+)\\\\)$', _id)\n                if count_match:\n                    compressed_count = int(count_match.group(1))\n            rcounts[ret['result']] += compressed_count\n            if '__parallel__' in ret:\n                pduration = ret.get('duration', 0)\n                try:\n                    pdurations.append(float(pduration))\n                except ValueError:\n                    (pduration, _, _) = pduration.partition(' ms')\n                    try:\n                        pdurations.append(float(pduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            else:\n                rduration = ret.get('duration', 0)\n                try:\n                    rdurations.append(float(rduration))\n                except ValueError:\n                    (rduration, _, _) = rduration.partition(' ms')\n                    try:\n                        rdurations.append(float(rduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            tcolor = colors['GREEN']\n            if ret.get('name') in ['state.orch', 'state.orchestrate', 'state.sls']:\n                nested = output(ret['changes'], indent_level=indent_level + 1)\n                ctext = re.sub('^', ' ' * 14 * indent_level, '\\n' + nested, flags=re.MULTILINE)\n                schanged = True\n                nchanges += 1\n            else:\n                (schanged, ctext) = _format_changes(ret['changes'])\n                if schanged and compressed_count > 1:\n                    nchanges += len(ret['changes'].get('compressed changes', {})) or 1\n                else:\n                    nchanges += 1 if schanged else 0\n            if __opts__.get('state_output_diff', False) and ret['result'] and (not schanged):\n                continue\n            if not __opts__.get('state_verbose', False) and ret['result'] and (not schanged):\n                continue\n            if schanged:\n                tcolor = colors['CYAN']\n            if ret['result'] is False:\n                hcolor = colors['RED']\n                tcolor = colors['RED']\n            if ret['result'] is None:\n                hcolor = colors['LIGHT_YELLOW']\n                tcolor = colors['LIGHT_YELLOW']\n            state_output = __opts__.get('state_output', 'full').lower()\n            comps = tname.split('_|-')\n            if state_output.endswith('_id'):\n                comps[2] = comps[1]\n            if state_output.startswith('filter'):\n                cliargs = __opts__.get('arg', [])\n                clikwargs = {}\n                for item in cliargs:\n                    if isinstance(item, dict) and '__kwarg__' in item:\n                        clikwargs = item.copy()\n                exclude = clikwargs.get('exclude', __opts__.get('state_output_exclude', []))\n                if isinstance(exclude, str):\n                    exclude = str(exclude).split(',')\n                terse = clikwargs.get('terse', __opts__.get('state_output_terse', []))\n                if isinstance(terse, str):\n                    terse = str(terse).split(',')\n                if str(ret['result']) in terse:\n                    msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                    hstrs.append(msg)\n                    continue\n                if str(ret['result']) in exclude:\n                    continue\n            elif any((state_output.startswith('terse'), state_output.startswith('mixed') and ret['result'] is not False, state_output.startswith('changes') and ret['result'] and (not schanged))):\n                msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                hstrs.append(msg)\n                continue\n            state_lines = ['{tcolor}----------{colors[ENDC]}', '    {tcolor}      ID: {comps[1]}{colors[ENDC]}', '    {tcolor}Function: {comps[0]}.{comps[3]}{colors[ENDC]}', '    {tcolor}  Result: {ret[result]!s}{colors[ENDC]}', '    {tcolor} Comment: {comment}{colors[ENDC]}']\n            if __opts__.get('state_output_profile') and 'start_time' in ret:\n                state_lines.extend(['    {tcolor} Started: {ret[start_time]!s}{colors[ENDC]}', '    {tcolor}Duration: {ret[duration]!s}{colors[ENDC]}'])\n            if comps[1] != comps[2]:\n                state_lines.insert(3, '    {tcolor}    Name: {comps[2]}{colors[ENDC]}')\n            try:\n                if not isinstance(ret['comment'], str):\n                    ret['comment'] = str(ret['comment'])\n            except UnicodeDecodeError:\n                ret['comment'] = salt.utils.stringutils.to_unicode(ret['comment'])\n            try:\n                comment = salt.utils.data.decode(ret['comment'])\n                comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            except AttributeError:\n                try:\n                    comment = ret['comment'].join(' ').replace('\\n', '\\n' + ' ' * 13)\n                except AttributeError:\n                    comment = str(ret['comment'])\n                    comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            if 'data' in ret:\n                if isinstance(ret['data'], list):\n                    for item in ret['data']:\n                        comment = '{} {}'.format(comment, item)\n                elif isinstance(ret['data'], dict):\n                    for (key, value) in ret['data'].items():\n                        comment = '{}\\n\\t\\t{}: {}'.format(comment, key, value)\n                else:\n                    comment = '{} {}'.format(comment, ret['data'])\n            for detail in ['start_time', 'duration']:\n                ret.setdefault(detail, '')\n            if ret['duration'] != '':\n                ret['duration'] = '{} ms'.format(ret['duration'])\n            svars = {'tcolor': tcolor, 'comps': comps, 'ret': ret, 'comment': salt.utils.data.decode(comment), 'colors': colors}\n            hstrs.extend([sline.format(**svars) for sline in state_lines])\n            changes = '     Changes:   ' + ctext\n            hstrs.append('{0}{1}{2[ENDC]}'.format(tcolor, changes, colors))\n            if 'warnings' in ret:\n                rcounts.setdefault('warnings', 0)\n                rcounts['warnings'] += 1\n                wrapper = textwrap.TextWrapper(width=80, initial_indent=' ' * 14, subsequent_indent=' ' * 14)\n                hstrs.append('   {colors[LIGHT_RED]} Warnings: {0}{colors[ENDC]}'.format(wrapper.fill('\\n'.join(ret['warnings'])).lstrip(), colors=colors))\n        colorfmt = '{0}{1}{2[ENDC]}'\n        rlabel = {True: 'Succeeded', False: 'Failed', None: 'Not Run', 'warnings': 'Warnings'}\n        count_max_len = max([len(str(x)) for x in rcounts.values()] or [0])\n        label_max_len = max([len(x) for x in rlabel.values()] or [0])\n        line_max_len = label_max_len + count_max_len + 2\n        hstrs.append(colorfmt.format(colors['CYAN'], '\\nSummary for {}\\n{}'.format(host, '-' * line_max_len), colors))\n\n        def _counts(label, count):\n            return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))\n        changestats = []\n        if None in rcounts and rcounts.get(None, 0) > 0:\n            changestats.append(colorfmt.format(colors['LIGHT_YELLOW'], 'unchanged={}'.format(rcounts.get(None, 0)), colors))\n        if nchanges > 0:\n            changestats.append(colorfmt.format(colors['GREEN'], 'changed={}'.format(nchanges), colors))\n        if changestats:\n            changestats = ' ({})'.format(', '.join(changestats))\n        else:\n            changestats = ''\n        hstrs.append(colorfmt.format(colors['GREEN'], _counts(rlabel[True], rcounts.get(True, 0) + rcounts.get(None, 0)), colors) + changestats)\n        num_failed = rcounts.get(False, 0)\n        hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts(rlabel[False], num_failed), colors))\n        if __opts__.get('state_output_pct', False):\n            try:\n                success_pct = round((rcounts.get(True, 0) + rcounts.get(None, 0)) / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['GREEN'], _counts('Success %', success_pct), colors))\n            except ZeroDivisionError:\n                pass\n            try:\n                failed_pct = round(num_failed / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts('Failure %', failed_pct), colors))\n            except ZeroDivisionError:\n                pass\n        num_warnings = rcounts.get('warnings', 0)\n        if num_warnings:\n            hstrs.append(colorfmt.format(colors['LIGHT_RED'], _counts(rlabel['warnings'], num_warnings), colors))\n        totals = '{0}\\nTotal states run: {1:>{2}}'.format('-' * line_max_len, sum(rcounts.values()) - rcounts.get('warnings', 0), line_max_len - 7)\n        hstrs.append(colorfmt.format(colors['CYAN'], totals, colors))\n        if __opts__.get('state_output_profile'):\n            sum_duration = sum(rdurations)\n            if pdurations:\n                max_pduration = max(pdurations)\n                sum_duration = sum_duration + max_pduration\n            duration_unit = 'ms'\n            if sum_duration > 999:\n                sum_duration /= 1000\n                duration_unit = 's'\n            total_duration = 'Total run time: {} {}'.format('{:.3f}'.format(sum_duration).rjust(line_max_len - 5), duration_unit)\n            hstrs.append(colorfmt.format(colors['CYAN'], total_duration, colors))\n    if strip_colors:\n        host = salt.output.strip_esc_sequence(host)\n    hstrs.insert(0, '{0}{1}:{2[ENDC]}'.format(hcolor, host, colors))\n    return ('\\n'.join(hstrs), nchanges > 0)",
        "mutated": [
            "def _format_host(host, data, indent_level=1):\n    if False:\n        i = 10\n    '\\n    Main highstate formatter. can be called recursively if a nested highstate\\n    contains other highstates (ie in an orchestration)\\n    '\n    host = salt.utils.data.decode(host)\n    colors = salt.utils.color.get_colors(__opts__.get('color'), __opts__.get('color_theme'))\n    tabular = __opts__.get('state_tabular', False)\n    rcounts = {}\n    rdurations = []\n    pdurations = []\n    hcolor = colors['GREEN']\n    hstrs = []\n    nchanges = 0\n    strip_colors = __opts__.get('strip_colors', True)\n    if isinstance(data, int):\n        nchanges = 1\n        hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, str):\n        nchanges = 1\n        for data in data.splitlines():\n            hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, list):\n        hcolor = colors['LIGHT_RED']\n        hstrs.append('    {0}Data failed to compile:{1[ENDC]}'.format(hcolor, colors))\n        for err in data:\n            if strip_colors:\n                err = salt.output.strip_esc_sequence(salt.utils.data.decode(err))\n            hstrs.append('{0}----------\\n    {1}{2[ENDC]}'.format(hcolor, err, colors))\n    elif isinstance(data, dict):\n        data_tmp = {}\n        for (tname, info) in data.items():\n            if isinstance(info, dict) and tname != 'changes' and info and ('__run_num__' not in info):\n                err = 'The State execution failed to record the order in which all states were executed. The state return missing data is:'\n                hstrs.insert(0, pprint.pformat(info))\n                hstrs.insert(0, err)\n            if isinstance(info, dict) and 'result' in info:\n                data_tmp[tname] = info\n        data = data_tmp\n        for tname in sorted(data, key=lambda k: data[k].get('__run_num__', 0)):\n            ret = data[tname]\n            rcounts.setdefault(ret['result'], 0)\n            compressed_count = 1\n            if __opts__.get('state_compress_ids', False) and '_|-state_compressed_' in tname:\n                (_, _id, _, _) = tname.split('_|-')\n                count_match = re.search('\\\\((\\\\d+)\\\\)$', _id)\n                if count_match:\n                    compressed_count = int(count_match.group(1))\n            rcounts[ret['result']] += compressed_count\n            if '__parallel__' in ret:\n                pduration = ret.get('duration', 0)\n                try:\n                    pdurations.append(float(pduration))\n                except ValueError:\n                    (pduration, _, _) = pduration.partition(' ms')\n                    try:\n                        pdurations.append(float(pduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            else:\n                rduration = ret.get('duration', 0)\n                try:\n                    rdurations.append(float(rduration))\n                except ValueError:\n                    (rduration, _, _) = rduration.partition(' ms')\n                    try:\n                        rdurations.append(float(rduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            tcolor = colors['GREEN']\n            if ret.get('name') in ['state.orch', 'state.orchestrate', 'state.sls']:\n                nested = output(ret['changes'], indent_level=indent_level + 1)\n                ctext = re.sub('^', ' ' * 14 * indent_level, '\\n' + nested, flags=re.MULTILINE)\n                schanged = True\n                nchanges += 1\n            else:\n                (schanged, ctext) = _format_changes(ret['changes'])\n                if schanged and compressed_count > 1:\n                    nchanges += len(ret['changes'].get('compressed changes', {})) or 1\n                else:\n                    nchanges += 1 if schanged else 0\n            if __opts__.get('state_output_diff', False) and ret['result'] and (not schanged):\n                continue\n            if not __opts__.get('state_verbose', False) and ret['result'] and (not schanged):\n                continue\n            if schanged:\n                tcolor = colors['CYAN']\n            if ret['result'] is False:\n                hcolor = colors['RED']\n                tcolor = colors['RED']\n            if ret['result'] is None:\n                hcolor = colors['LIGHT_YELLOW']\n                tcolor = colors['LIGHT_YELLOW']\n            state_output = __opts__.get('state_output', 'full').lower()\n            comps = tname.split('_|-')\n            if state_output.endswith('_id'):\n                comps[2] = comps[1]\n            if state_output.startswith('filter'):\n                cliargs = __opts__.get('arg', [])\n                clikwargs = {}\n                for item in cliargs:\n                    if isinstance(item, dict) and '__kwarg__' in item:\n                        clikwargs = item.copy()\n                exclude = clikwargs.get('exclude', __opts__.get('state_output_exclude', []))\n                if isinstance(exclude, str):\n                    exclude = str(exclude).split(',')\n                terse = clikwargs.get('terse', __opts__.get('state_output_terse', []))\n                if isinstance(terse, str):\n                    terse = str(terse).split(',')\n                if str(ret['result']) in terse:\n                    msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                    hstrs.append(msg)\n                    continue\n                if str(ret['result']) in exclude:\n                    continue\n            elif any((state_output.startswith('terse'), state_output.startswith('mixed') and ret['result'] is not False, state_output.startswith('changes') and ret['result'] and (not schanged))):\n                msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                hstrs.append(msg)\n                continue\n            state_lines = ['{tcolor}----------{colors[ENDC]}', '    {tcolor}      ID: {comps[1]}{colors[ENDC]}', '    {tcolor}Function: {comps[0]}.{comps[3]}{colors[ENDC]}', '    {tcolor}  Result: {ret[result]!s}{colors[ENDC]}', '    {tcolor} Comment: {comment}{colors[ENDC]}']\n            if __opts__.get('state_output_profile') and 'start_time' in ret:\n                state_lines.extend(['    {tcolor} Started: {ret[start_time]!s}{colors[ENDC]}', '    {tcolor}Duration: {ret[duration]!s}{colors[ENDC]}'])\n            if comps[1] != comps[2]:\n                state_lines.insert(3, '    {tcolor}    Name: {comps[2]}{colors[ENDC]}')\n            try:\n                if not isinstance(ret['comment'], str):\n                    ret['comment'] = str(ret['comment'])\n            except UnicodeDecodeError:\n                ret['comment'] = salt.utils.stringutils.to_unicode(ret['comment'])\n            try:\n                comment = salt.utils.data.decode(ret['comment'])\n                comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            except AttributeError:\n                try:\n                    comment = ret['comment'].join(' ').replace('\\n', '\\n' + ' ' * 13)\n                except AttributeError:\n                    comment = str(ret['comment'])\n                    comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            if 'data' in ret:\n                if isinstance(ret['data'], list):\n                    for item in ret['data']:\n                        comment = '{} {}'.format(comment, item)\n                elif isinstance(ret['data'], dict):\n                    for (key, value) in ret['data'].items():\n                        comment = '{}\\n\\t\\t{}: {}'.format(comment, key, value)\n                else:\n                    comment = '{} {}'.format(comment, ret['data'])\n            for detail in ['start_time', 'duration']:\n                ret.setdefault(detail, '')\n            if ret['duration'] != '':\n                ret['duration'] = '{} ms'.format(ret['duration'])\n            svars = {'tcolor': tcolor, 'comps': comps, 'ret': ret, 'comment': salt.utils.data.decode(comment), 'colors': colors}\n            hstrs.extend([sline.format(**svars) for sline in state_lines])\n            changes = '     Changes:   ' + ctext\n            hstrs.append('{0}{1}{2[ENDC]}'.format(tcolor, changes, colors))\n            if 'warnings' in ret:\n                rcounts.setdefault('warnings', 0)\n                rcounts['warnings'] += 1\n                wrapper = textwrap.TextWrapper(width=80, initial_indent=' ' * 14, subsequent_indent=' ' * 14)\n                hstrs.append('   {colors[LIGHT_RED]} Warnings: {0}{colors[ENDC]}'.format(wrapper.fill('\\n'.join(ret['warnings'])).lstrip(), colors=colors))\n        colorfmt = '{0}{1}{2[ENDC]}'\n        rlabel = {True: 'Succeeded', False: 'Failed', None: 'Not Run', 'warnings': 'Warnings'}\n        count_max_len = max([len(str(x)) for x in rcounts.values()] or [0])\n        label_max_len = max([len(x) for x in rlabel.values()] or [0])\n        line_max_len = label_max_len + count_max_len + 2\n        hstrs.append(colorfmt.format(colors['CYAN'], '\\nSummary for {}\\n{}'.format(host, '-' * line_max_len), colors))\n\n        def _counts(label, count):\n            return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))\n        changestats = []\n        if None in rcounts and rcounts.get(None, 0) > 0:\n            changestats.append(colorfmt.format(colors['LIGHT_YELLOW'], 'unchanged={}'.format(rcounts.get(None, 0)), colors))\n        if nchanges > 0:\n            changestats.append(colorfmt.format(colors['GREEN'], 'changed={}'.format(nchanges), colors))\n        if changestats:\n            changestats = ' ({})'.format(', '.join(changestats))\n        else:\n            changestats = ''\n        hstrs.append(colorfmt.format(colors['GREEN'], _counts(rlabel[True], rcounts.get(True, 0) + rcounts.get(None, 0)), colors) + changestats)\n        num_failed = rcounts.get(False, 0)\n        hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts(rlabel[False], num_failed), colors))\n        if __opts__.get('state_output_pct', False):\n            try:\n                success_pct = round((rcounts.get(True, 0) + rcounts.get(None, 0)) / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['GREEN'], _counts('Success %', success_pct), colors))\n            except ZeroDivisionError:\n                pass\n            try:\n                failed_pct = round(num_failed / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts('Failure %', failed_pct), colors))\n            except ZeroDivisionError:\n                pass\n        num_warnings = rcounts.get('warnings', 0)\n        if num_warnings:\n            hstrs.append(colorfmt.format(colors['LIGHT_RED'], _counts(rlabel['warnings'], num_warnings), colors))\n        totals = '{0}\\nTotal states run: {1:>{2}}'.format('-' * line_max_len, sum(rcounts.values()) - rcounts.get('warnings', 0), line_max_len - 7)\n        hstrs.append(colorfmt.format(colors['CYAN'], totals, colors))\n        if __opts__.get('state_output_profile'):\n            sum_duration = sum(rdurations)\n            if pdurations:\n                max_pduration = max(pdurations)\n                sum_duration = sum_duration + max_pduration\n            duration_unit = 'ms'\n            if sum_duration > 999:\n                sum_duration /= 1000\n                duration_unit = 's'\n            total_duration = 'Total run time: {} {}'.format('{:.3f}'.format(sum_duration).rjust(line_max_len - 5), duration_unit)\n            hstrs.append(colorfmt.format(colors['CYAN'], total_duration, colors))\n    if strip_colors:\n        host = salt.output.strip_esc_sequence(host)\n    hstrs.insert(0, '{0}{1}:{2[ENDC]}'.format(hcolor, host, colors))\n    return ('\\n'.join(hstrs), nchanges > 0)",
            "def _format_host(host, data, indent_level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Main highstate formatter. can be called recursively if a nested highstate\\n    contains other highstates (ie in an orchestration)\\n    '\n    host = salt.utils.data.decode(host)\n    colors = salt.utils.color.get_colors(__opts__.get('color'), __opts__.get('color_theme'))\n    tabular = __opts__.get('state_tabular', False)\n    rcounts = {}\n    rdurations = []\n    pdurations = []\n    hcolor = colors['GREEN']\n    hstrs = []\n    nchanges = 0\n    strip_colors = __opts__.get('strip_colors', True)\n    if isinstance(data, int):\n        nchanges = 1\n        hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, str):\n        nchanges = 1\n        for data in data.splitlines():\n            hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, list):\n        hcolor = colors['LIGHT_RED']\n        hstrs.append('    {0}Data failed to compile:{1[ENDC]}'.format(hcolor, colors))\n        for err in data:\n            if strip_colors:\n                err = salt.output.strip_esc_sequence(salt.utils.data.decode(err))\n            hstrs.append('{0}----------\\n    {1}{2[ENDC]}'.format(hcolor, err, colors))\n    elif isinstance(data, dict):\n        data_tmp = {}\n        for (tname, info) in data.items():\n            if isinstance(info, dict) and tname != 'changes' and info and ('__run_num__' not in info):\n                err = 'The State execution failed to record the order in which all states were executed. The state return missing data is:'\n                hstrs.insert(0, pprint.pformat(info))\n                hstrs.insert(0, err)\n            if isinstance(info, dict) and 'result' in info:\n                data_tmp[tname] = info\n        data = data_tmp\n        for tname in sorted(data, key=lambda k: data[k].get('__run_num__', 0)):\n            ret = data[tname]\n            rcounts.setdefault(ret['result'], 0)\n            compressed_count = 1\n            if __opts__.get('state_compress_ids', False) and '_|-state_compressed_' in tname:\n                (_, _id, _, _) = tname.split('_|-')\n                count_match = re.search('\\\\((\\\\d+)\\\\)$', _id)\n                if count_match:\n                    compressed_count = int(count_match.group(1))\n            rcounts[ret['result']] += compressed_count\n            if '__parallel__' in ret:\n                pduration = ret.get('duration', 0)\n                try:\n                    pdurations.append(float(pduration))\n                except ValueError:\n                    (pduration, _, _) = pduration.partition(' ms')\n                    try:\n                        pdurations.append(float(pduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            else:\n                rduration = ret.get('duration', 0)\n                try:\n                    rdurations.append(float(rduration))\n                except ValueError:\n                    (rduration, _, _) = rduration.partition(' ms')\n                    try:\n                        rdurations.append(float(rduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            tcolor = colors['GREEN']\n            if ret.get('name') in ['state.orch', 'state.orchestrate', 'state.sls']:\n                nested = output(ret['changes'], indent_level=indent_level + 1)\n                ctext = re.sub('^', ' ' * 14 * indent_level, '\\n' + nested, flags=re.MULTILINE)\n                schanged = True\n                nchanges += 1\n            else:\n                (schanged, ctext) = _format_changes(ret['changes'])\n                if schanged and compressed_count > 1:\n                    nchanges += len(ret['changes'].get('compressed changes', {})) or 1\n                else:\n                    nchanges += 1 if schanged else 0\n            if __opts__.get('state_output_diff', False) and ret['result'] and (not schanged):\n                continue\n            if not __opts__.get('state_verbose', False) and ret['result'] and (not schanged):\n                continue\n            if schanged:\n                tcolor = colors['CYAN']\n            if ret['result'] is False:\n                hcolor = colors['RED']\n                tcolor = colors['RED']\n            if ret['result'] is None:\n                hcolor = colors['LIGHT_YELLOW']\n                tcolor = colors['LIGHT_YELLOW']\n            state_output = __opts__.get('state_output', 'full').lower()\n            comps = tname.split('_|-')\n            if state_output.endswith('_id'):\n                comps[2] = comps[1]\n            if state_output.startswith('filter'):\n                cliargs = __opts__.get('arg', [])\n                clikwargs = {}\n                for item in cliargs:\n                    if isinstance(item, dict) and '__kwarg__' in item:\n                        clikwargs = item.copy()\n                exclude = clikwargs.get('exclude', __opts__.get('state_output_exclude', []))\n                if isinstance(exclude, str):\n                    exclude = str(exclude).split(',')\n                terse = clikwargs.get('terse', __opts__.get('state_output_terse', []))\n                if isinstance(terse, str):\n                    terse = str(terse).split(',')\n                if str(ret['result']) in terse:\n                    msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                    hstrs.append(msg)\n                    continue\n                if str(ret['result']) in exclude:\n                    continue\n            elif any((state_output.startswith('terse'), state_output.startswith('mixed') and ret['result'] is not False, state_output.startswith('changes') and ret['result'] and (not schanged))):\n                msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                hstrs.append(msg)\n                continue\n            state_lines = ['{tcolor}----------{colors[ENDC]}', '    {tcolor}      ID: {comps[1]}{colors[ENDC]}', '    {tcolor}Function: {comps[0]}.{comps[3]}{colors[ENDC]}', '    {tcolor}  Result: {ret[result]!s}{colors[ENDC]}', '    {tcolor} Comment: {comment}{colors[ENDC]}']\n            if __opts__.get('state_output_profile') and 'start_time' in ret:\n                state_lines.extend(['    {tcolor} Started: {ret[start_time]!s}{colors[ENDC]}', '    {tcolor}Duration: {ret[duration]!s}{colors[ENDC]}'])\n            if comps[1] != comps[2]:\n                state_lines.insert(3, '    {tcolor}    Name: {comps[2]}{colors[ENDC]}')\n            try:\n                if not isinstance(ret['comment'], str):\n                    ret['comment'] = str(ret['comment'])\n            except UnicodeDecodeError:\n                ret['comment'] = salt.utils.stringutils.to_unicode(ret['comment'])\n            try:\n                comment = salt.utils.data.decode(ret['comment'])\n                comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            except AttributeError:\n                try:\n                    comment = ret['comment'].join(' ').replace('\\n', '\\n' + ' ' * 13)\n                except AttributeError:\n                    comment = str(ret['comment'])\n                    comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            if 'data' in ret:\n                if isinstance(ret['data'], list):\n                    for item in ret['data']:\n                        comment = '{} {}'.format(comment, item)\n                elif isinstance(ret['data'], dict):\n                    for (key, value) in ret['data'].items():\n                        comment = '{}\\n\\t\\t{}: {}'.format(comment, key, value)\n                else:\n                    comment = '{} {}'.format(comment, ret['data'])\n            for detail in ['start_time', 'duration']:\n                ret.setdefault(detail, '')\n            if ret['duration'] != '':\n                ret['duration'] = '{} ms'.format(ret['duration'])\n            svars = {'tcolor': tcolor, 'comps': comps, 'ret': ret, 'comment': salt.utils.data.decode(comment), 'colors': colors}\n            hstrs.extend([sline.format(**svars) for sline in state_lines])\n            changes = '     Changes:   ' + ctext\n            hstrs.append('{0}{1}{2[ENDC]}'.format(tcolor, changes, colors))\n            if 'warnings' in ret:\n                rcounts.setdefault('warnings', 0)\n                rcounts['warnings'] += 1\n                wrapper = textwrap.TextWrapper(width=80, initial_indent=' ' * 14, subsequent_indent=' ' * 14)\n                hstrs.append('   {colors[LIGHT_RED]} Warnings: {0}{colors[ENDC]}'.format(wrapper.fill('\\n'.join(ret['warnings'])).lstrip(), colors=colors))\n        colorfmt = '{0}{1}{2[ENDC]}'\n        rlabel = {True: 'Succeeded', False: 'Failed', None: 'Not Run', 'warnings': 'Warnings'}\n        count_max_len = max([len(str(x)) for x in rcounts.values()] or [0])\n        label_max_len = max([len(x) for x in rlabel.values()] or [0])\n        line_max_len = label_max_len + count_max_len + 2\n        hstrs.append(colorfmt.format(colors['CYAN'], '\\nSummary for {}\\n{}'.format(host, '-' * line_max_len), colors))\n\n        def _counts(label, count):\n            return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))\n        changestats = []\n        if None in rcounts and rcounts.get(None, 0) > 0:\n            changestats.append(colorfmt.format(colors['LIGHT_YELLOW'], 'unchanged={}'.format(rcounts.get(None, 0)), colors))\n        if nchanges > 0:\n            changestats.append(colorfmt.format(colors['GREEN'], 'changed={}'.format(nchanges), colors))\n        if changestats:\n            changestats = ' ({})'.format(', '.join(changestats))\n        else:\n            changestats = ''\n        hstrs.append(colorfmt.format(colors['GREEN'], _counts(rlabel[True], rcounts.get(True, 0) + rcounts.get(None, 0)), colors) + changestats)\n        num_failed = rcounts.get(False, 0)\n        hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts(rlabel[False], num_failed), colors))\n        if __opts__.get('state_output_pct', False):\n            try:\n                success_pct = round((rcounts.get(True, 0) + rcounts.get(None, 0)) / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['GREEN'], _counts('Success %', success_pct), colors))\n            except ZeroDivisionError:\n                pass\n            try:\n                failed_pct = round(num_failed / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts('Failure %', failed_pct), colors))\n            except ZeroDivisionError:\n                pass\n        num_warnings = rcounts.get('warnings', 0)\n        if num_warnings:\n            hstrs.append(colorfmt.format(colors['LIGHT_RED'], _counts(rlabel['warnings'], num_warnings), colors))\n        totals = '{0}\\nTotal states run: {1:>{2}}'.format('-' * line_max_len, sum(rcounts.values()) - rcounts.get('warnings', 0), line_max_len - 7)\n        hstrs.append(colorfmt.format(colors['CYAN'], totals, colors))\n        if __opts__.get('state_output_profile'):\n            sum_duration = sum(rdurations)\n            if pdurations:\n                max_pduration = max(pdurations)\n                sum_duration = sum_duration + max_pduration\n            duration_unit = 'ms'\n            if sum_duration > 999:\n                sum_duration /= 1000\n                duration_unit = 's'\n            total_duration = 'Total run time: {} {}'.format('{:.3f}'.format(sum_duration).rjust(line_max_len - 5), duration_unit)\n            hstrs.append(colorfmt.format(colors['CYAN'], total_duration, colors))\n    if strip_colors:\n        host = salt.output.strip_esc_sequence(host)\n    hstrs.insert(0, '{0}{1}:{2[ENDC]}'.format(hcolor, host, colors))\n    return ('\\n'.join(hstrs), nchanges > 0)",
            "def _format_host(host, data, indent_level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Main highstate formatter. can be called recursively if a nested highstate\\n    contains other highstates (ie in an orchestration)\\n    '\n    host = salt.utils.data.decode(host)\n    colors = salt.utils.color.get_colors(__opts__.get('color'), __opts__.get('color_theme'))\n    tabular = __opts__.get('state_tabular', False)\n    rcounts = {}\n    rdurations = []\n    pdurations = []\n    hcolor = colors['GREEN']\n    hstrs = []\n    nchanges = 0\n    strip_colors = __opts__.get('strip_colors', True)\n    if isinstance(data, int):\n        nchanges = 1\n        hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, str):\n        nchanges = 1\n        for data in data.splitlines():\n            hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, list):\n        hcolor = colors['LIGHT_RED']\n        hstrs.append('    {0}Data failed to compile:{1[ENDC]}'.format(hcolor, colors))\n        for err in data:\n            if strip_colors:\n                err = salt.output.strip_esc_sequence(salt.utils.data.decode(err))\n            hstrs.append('{0}----------\\n    {1}{2[ENDC]}'.format(hcolor, err, colors))\n    elif isinstance(data, dict):\n        data_tmp = {}\n        for (tname, info) in data.items():\n            if isinstance(info, dict) and tname != 'changes' and info and ('__run_num__' not in info):\n                err = 'The State execution failed to record the order in which all states were executed. The state return missing data is:'\n                hstrs.insert(0, pprint.pformat(info))\n                hstrs.insert(0, err)\n            if isinstance(info, dict) and 'result' in info:\n                data_tmp[tname] = info\n        data = data_tmp\n        for tname in sorted(data, key=lambda k: data[k].get('__run_num__', 0)):\n            ret = data[tname]\n            rcounts.setdefault(ret['result'], 0)\n            compressed_count = 1\n            if __opts__.get('state_compress_ids', False) and '_|-state_compressed_' in tname:\n                (_, _id, _, _) = tname.split('_|-')\n                count_match = re.search('\\\\((\\\\d+)\\\\)$', _id)\n                if count_match:\n                    compressed_count = int(count_match.group(1))\n            rcounts[ret['result']] += compressed_count\n            if '__parallel__' in ret:\n                pduration = ret.get('duration', 0)\n                try:\n                    pdurations.append(float(pduration))\n                except ValueError:\n                    (pduration, _, _) = pduration.partition(' ms')\n                    try:\n                        pdurations.append(float(pduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            else:\n                rduration = ret.get('duration', 0)\n                try:\n                    rdurations.append(float(rduration))\n                except ValueError:\n                    (rduration, _, _) = rduration.partition(' ms')\n                    try:\n                        rdurations.append(float(rduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            tcolor = colors['GREEN']\n            if ret.get('name') in ['state.orch', 'state.orchestrate', 'state.sls']:\n                nested = output(ret['changes'], indent_level=indent_level + 1)\n                ctext = re.sub('^', ' ' * 14 * indent_level, '\\n' + nested, flags=re.MULTILINE)\n                schanged = True\n                nchanges += 1\n            else:\n                (schanged, ctext) = _format_changes(ret['changes'])\n                if schanged and compressed_count > 1:\n                    nchanges += len(ret['changes'].get('compressed changes', {})) or 1\n                else:\n                    nchanges += 1 if schanged else 0\n            if __opts__.get('state_output_diff', False) and ret['result'] and (not schanged):\n                continue\n            if not __opts__.get('state_verbose', False) and ret['result'] and (not schanged):\n                continue\n            if schanged:\n                tcolor = colors['CYAN']\n            if ret['result'] is False:\n                hcolor = colors['RED']\n                tcolor = colors['RED']\n            if ret['result'] is None:\n                hcolor = colors['LIGHT_YELLOW']\n                tcolor = colors['LIGHT_YELLOW']\n            state_output = __opts__.get('state_output', 'full').lower()\n            comps = tname.split('_|-')\n            if state_output.endswith('_id'):\n                comps[2] = comps[1]\n            if state_output.startswith('filter'):\n                cliargs = __opts__.get('arg', [])\n                clikwargs = {}\n                for item in cliargs:\n                    if isinstance(item, dict) and '__kwarg__' in item:\n                        clikwargs = item.copy()\n                exclude = clikwargs.get('exclude', __opts__.get('state_output_exclude', []))\n                if isinstance(exclude, str):\n                    exclude = str(exclude).split(',')\n                terse = clikwargs.get('terse', __opts__.get('state_output_terse', []))\n                if isinstance(terse, str):\n                    terse = str(terse).split(',')\n                if str(ret['result']) in terse:\n                    msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                    hstrs.append(msg)\n                    continue\n                if str(ret['result']) in exclude:\n                    continue\n            elif any((state_output.startswith('terse'), state_output.startswith('mixed') and ret['result'] is not False, state_output.startswith('changes') and ret['result'] and (not schanged))):\n                msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                hstrs.append(msg)\n                continue\n            state_lines = ['{tcolor}----------{colors[ENDC]}', '    {tcolor}      ID: {comps[1]}{colors[ENDC]}', '    {tcolor}Function: {comps[0]}.{comps[3]}{colors[ENDC]}', '    {tcolor}  Result: {ret[result]!s}{colors[ENDC]}', '    {tcolor} Comment: {comment}{colors[ENDC]}']\n            if __opts__.get('state_output_profile') and 'start_time' in ret:\n                state_lines.extend(['    {tcolor} Started: {ret[start_time]!s}{colors[ENDC]}', '    {tcolor}Duration: {ret[duration]!s}{colors[ENDC]}'])\n            if comps[1] != comps[2]:\n                state_lines.insert(3, '    {tcolor}    Name: {comps[2]}{colors[ENDC]}')\n            try:\n                if not isinstance(ret['comment'], str):\n                    ret['comment'] = str(ret['comment'])\n            except UnicodeDecodeError:\n                ret['comment'] = salt.utils.stringutils.to_unicode(ret['comment'])\n            try:\n                comment = salt.utils.data.decode(ret['comment'])\n                comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            except AttributeError:\n                try:\n                    comment = ret['comment'].join(' ').replace('\\n', '\\n' + ' ' * 13)\n                except AttributeError:\n                    comment = str(ret['comment'])\n                    comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            if 'data' in ret:\n                if isinstance(ret['data'], list):\n                    for item in ret['data']:\n                        comment = '{} {}'.format(comment, item)\n                elif isinstance(ret['data'], dict):\n                    for (key, value) in ret['data'].items():\n                        comment = '{}\\n\\t\\t{}: {}'.format(comment, key, value)\n                else:\n                    comment = '{} {}'.format(comment, ret['data'])\n            for detail in ['start_time', 'duration']:\n                ret.setdefault(detail, '')\n            if ret['duration'] != '':\n                ret['duration'] = '{} ms'.format(ret['duration'])\n            svars = {'tcolor': tcolor, 'comps': comps, 'ret': ret, 'comment': salt.utils.data.decode(comment), 'colors': colors}\n            hstrs.extend([sline.format(**svars) for sline in state_lines])\n            changes = '     Changes:   ' + ctext\n            hstrs.append('{0}{1}{2[ENDC]}'.format(tcolor, changes, colors))\n            if 'warnings' in ret:\n                rcounts.setdefault('warnings', 0)\n                rcounts['warnings'] += 1\n                wrapper = textwrap.TextWrapper(width=80, initial_indent=' ' * 14, subsequent_indent=' ' * 14)\n                hstrs.append('   {colors[LIGHT_RED]} Warnings: {0}{colors[ENDC]}'.format(wrapper.fill('\\n'.join(ret['warnings'])).lstrip(), colors=colors))\n        colorfmt = '{0}{1}{2[ENDC]}'\n        rlabel = {True: 'Succeeded', False: 'Failed', None: 'Not Run', 'warnings': 'Warnings'}\n        count_max_len = max([len(str(x)) for x in rcounts.values()] or [0])\n        label_max_len = max([len(x) for x in rlabel.values()] or [0])\n        line_max_len = label_max_len + count_max_len + 2\n        hstrs.append(colorfmt.format(colors['CYAN'], '\\nSummary for {}\\n{}'.format(host, '-' * line_max_len), colors))\n\n        def _counts(label, count):\n            return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))\n        changestats = []\n        if None in rcounts and rcounts.get(None, 0) > 0:\n            changestats.append(colorfmt.format(colors['LIGHT_YELLOW'], 'unchanged={}'.format(rcounts.get(None, 0)), colors))\n        if nchanges > 0:\n            changestats.append(colorfmt.format(colors['GREEN'], 'changed={}'.format(nchanges), colors))\n        if changestats:\n            changestats = ' ({})'.format(', '.join(changestats))\n        else:\n            changestats = ''\n        hstrs.append(colorfmt.format(colors['GREEN'], _counts(rlabel[True], rcounts.get(True, 0) + rcounts.get(None, 0)), colors) + changestats)\n        num_failed = rcounts.get(False, 0)\n        hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts(rlabel[False], num_failed), colors))\n        if __opts__.get('state_output_pct', False):\n            try:\n                success_pct = round((rcounts.get(True, 0) + rcounts.get(None, 0)) / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['GREEN'], _counts('Success %', success_pct), colors))\n            except ZeroDivisionError:\n                pass\n            try:\n                failed_pct = round(num_failed / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts('Failure %', failed_pct), colors))\n            except ZeroDivisionError:\n                pass\n        num_warnings = rcounts.get('warnings', 0)\n        if num_warnings:\n            hstrs.append(colorfmt.format(colors['LIGHT_RED'], _counts(rlabel['warnings'], num_warnings), colors))\n        totals = '{0}\\nTotal states run: {1:>{2}}'.format('-' * line_max_len, sum(rcounts.values()) - rcounts.get('warnings', 0), line_max_len - 7)\n        hstrs.append(colorfmt.format(colors['CYAN'], totals, colors))\n        if __opts__.get('state_output_profile'):\n            sum_duration = sum(rdurations)\n            if pdurations:\n                max_pduration = max(pdurations)\n                sum_duration = sum_duration + max_pduration\n            duration_unit = 'ms'\n            if sum_duration > 999:\n                sum_duration /= 1000\n                duration_unit = 's'\n            total_duration = 'Total run time: {} {}'.format('{:.3f}'.format(sum_duration).rjust(line_max_len - 5), duration_unit)\n            hstrs.append(colorfmt.format(colors['CYAN'], total_duration, colors))\n    if strip_colors:\n        host = salt.output.strip_esc_sequence(host)\n    hstrs.insert(0, '{0}{1}:{2[ENDC]}'.format(hcolor, host, colors))\n    return ('\\n'.join(hstrs), nchanges > 0)",
            "def _format_host(host, data, indent_level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Main highstate formatter. can be called recursively if a nested highstate\\n    contains other highstates (ie in an orchestration)\\n    '\n    host = salt.utils.data.decode(host)\n    colors = salt.utils.color.get_colors(__opts__.get('color'), __opts__.get('color_theme'))\n    tabular = __opts__.get('state_tabular', False)\n    rcounts = {}\n    rdurations = []\n    pdurations = []\n    hcolor = colors['GREEN']\n    hstrs = []\n    nchanges = 0\n    strip_colors = __opts__.get('strip_colors', True)\n    if isinstance(data, int):\n        nchanges = 1\n        hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, str):\n        nchanges = 1\n        for data in data.splitlines():\n            hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, list):\n        hcolor = colors['LIGHT_RED']\n        hstrs.append('    {0}Data failed to compile:{1[ENDC]}'.format(hcolor, colors))\n        for err in data:\n            if strip_colors:\n                err = salt.output.strip_esc_sequence(salt.utils.data.decode(err))\n            hstrs.append('{0}----------\\n    {1}{2[ENDC]}'.format(hcolor, err, colors))\n    elif isinstance(data, dict):\n        data_tmp = {}\n        for (tname, info) in data.items():\n            if isinstance(info, dict) and tname != 'changes' and info and ('__run_num__' not in info):\n                err = 'The State execution failed to record the order in which all states were executed. The state return missing data is:'\n                hstrs.insert(0, pprint.pformat(info))\n                hstrs.insert(0, err)\n            if isinstance(info, dict) and 'result' in info:\n                data_tmp[tname] = info\n        data = data_tmp\n        for tname in sorted(data, key=lambda k: data[k].get('__run_num__', 0)):\n            ret = data[tname]\n            rcounts.setdefault(ret['result'], 0)\n            compressed_count = 1\n            if __opts__.get('state_compress_ids', False) and '_|-state_compressed_' in tname:\n                (_, _id, _, _) = tname.split('_|-')\n                count_match = re.search('\\\\((\\\\d+)\\\\)$', _id)\n                if count_match:\n                    compressed_count = int(count_match.group(1))\n            rcounts[ret['result']] += compressed_count\n            if '__parallel__' in ret:\n                pduration = ret.get('duration', 0)\n                try:\n                    pdurations.append(float(pduration))\n                except ValueError:\n                    (pduration, _, _) = pduration.partition(' ms')\n                    try:\n                        pdurations.append(float(pduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            else:\n                rduration = ret.get('duration', 0)\n                try:\n                    rdurations.append(float(rduration))\n                except ValueError:\n                    (rduration, _, _) = rduration.partition(' ms')\n                    try:\n                        rdurations.append(float(rduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            tcolor = colors['GREEN']\n            if ret.get('name') in ['state.orch', 'state.orchestrate', 'state.sls']:\n                nested = output(ret['changes'], indent_level=indent_level + 1)\n                ctext = re.sub('^', ' ' * 14 * indent_level, '\\n' + nested, flags=re.MULTILINE)\n                schanged = True\n                nchanges += 1\n            else:\n                (schanged, ctext) = _format_changes(ret['changes'])\n                if schanged and compressed_count > 1:\n                    nchanges += len(ret['changes'].get('compressed changes', {})) or 1\n                else:\n                    nchanges += 1 if schanged else 0\n            if __opts__.get('state_output_diff', False) and ret['result'] and (not schanged):\n                continue\n            if not __opts__.get('state_verbose', False) and ret['result'] and (not schanged):\n                continue\n            if schanged:\n                tcolor = colors['CYAN']\n            if ret['result'] is False:\n                hcolor = colors['RED']\n                tcolor = colors['RED']\n            if ret['result'] is None:\n                hcolor = colors['LIGHT_YELLOW']\n                tcolor = colors['LIGHT_YELLOW']\n            state_output = __opts__.get('state_output', 'full').lower()\n            comps = tname.split('_|-')\n            if state_output.endswith('_id'):\n                comps[2] = comps[1]\n            if state_output.startswith('filter'):\n                cliargs = __opts__.get('arg', [])\n                clikwargs = {}\n                for item in cliargs:\n                    if isinstance(item, dict) and '__kwarg__' in item:\n                        clikwargs = item.copy()\n                exclude = clikwargs.get('exclude', __opts__.get('state_output_exclude', []))\n                if isinstance(exclude, str):\n                    exclude = str(exclude).split(',')\n                terse = clikwargs.get('terse', __opts__.get('state_output_terse', []))\n                if isinstance(terse, str):\n                    terse = str(terse).split(',')\n                if str(ret['result']) in terse:\n                    msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                    hstrs.append(msg)\n                    continue\n                if str(ret['result']) in exclude:\n                    continue\n            elif any((state_output.startswith('terse'), state_output.startswith('mixed') and ret['result'] is not False, state_output.startswith('changes') and ret['result'] and (not schanged))):\n                msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                hstrs.append(msg)\n                continue\n            state_lines = ['{tcolor}----------{colors[ENDC]}', '    {tcolor}      ID: {comps[1]}{colors[ENDC]}', '    {tcolor}Function: {comps[0]}.{comps[3]}{colors[ENDC]}', '    {tcolor}  Result: {ret[result]!s}{colors[ENDC]}', '    {tcolor} Comment: {comment}{colors[ENDC]}']\n            if __opts__.get('state_output_profile') and 'start_time' in ret:\n                state_lines.extend(['    {tcolor} Started: {ret[start_time]!s}{colors[ENDC]}', '    {tcolor}Duration: {ret[duration]!s}{colors[ENDC]}'])\n            if comps[1] != comps[2]:\n                state_lines.insert(3, '    {tcolor}    Name: {comps[2]}{colors[ENDC]}')\n            try:\n                if not isinstance(ret['comment'], str):\n                    ret['comment'] = str(ret['comment'])\n            except UnicodeDecodeError:\n                ret['comment'] = salt.utils.stringutils.to_unicode(ret['comment'])\n            try:\n                comment = salt.utils.data.decode(ret['comment'])\n                comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            except AttributeError:\n                try:\n                    comment = ret['comment'].join(' ').replace('\\n', '\\n' + ' ' * 13)\n                except AttributeError:\n                    comment = str(ret['comment'])\n                    comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            if 'data' in ret:\n                if isinstance(ret['data'], list):\n                    for item in ret['data']:\n                        comment = '{} {}'.format(comment, item)\n                elif isinstance(ret['data'], dict):\n                    for (key, value) in ret['data'].items():\n                        comment = '{}\\n\\t\\t{}: {}'.format(comment, key, value)\n                else:\n                    comment = '{} {}'.format(comment, ret['data'])\n            for detail in ['start_time', 'duration']:\n                ret.setdefault(detail, '')\n            if ret['duration'] != '':\n                ret['duration'] = '{} ms'.format(ret['duration'])\n            svars = {'tcolor': tcolor, 'comps': comps, 'ret': ret, 'comment': salt.utils.data.decode(comment), 'colors': colors}\n            hstrs.extend([sline.format(**svars) for sline in state_lines])\n            changes = '     Changes:   ' + ctext\n            hstrs.append('{0}{1}{2[ENDC]}'.format(tcolor, changes, colors))\n            if 'warnings' in ret:\n                rcounts.setdefault('warnings', 0)\n                rcounts['warnings'] += 1\n                wrapper = textwrap.TextWrapper(width=80, initial_indent=' ' * 14, subsequent_indent=' ' * 14)\n                hstrs.append('   {colors[LIGHT_RED]} Warnings: {0}{colors[ENDC]}'.format(wrapper.fill('\\n'.join(ret['warnings'])).lstrip(), colors=colors))\n        colorfmt = '{0}{1}{2[ENDC]}'\n        rlabel = {True: 'Succeeded', False: 'Failed', None: 'Not Run', 'warnings': 'Warnings'}\n        count_max_len = max([len(str(x)) for x in rcounts.values()] or [0])\n        label_max_len = max([len(x) for x in rlabel.values()] or [0])\n        line_max_len = label_max_len + count_max_len + 2\n        hstrs.append(colorfmt.format(colors['CYAN'], '\\nSummary for {}\\n{}'.format(host, '-' * line_max_len), colors))\n\n        def _counts(label, count):\n            return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))\n        changestats = []\n        if None in rcounts and rcounts.get(None, 0) > 0:\n            changestats.append(colorfmt.format(colors['LIGHT_YELLOW'], 'unchanged={}'.format(rcounts.get(None, 0)), colors))\n        if nchanges > 0:\n            changestats.append(colorfmt.format(colors['GREEN'], 'changed={}'.format(nchanges), colors))\n        if changestats:\n            changestats = ' ({})'.format(', '.join(changestats))\n        else:\n            changestats = ''\n        hstrs.append(colorfmt.format(colors['GREEN'], _counts(rlabel[True], rcounts.get(True, 0) + rcounts.get(None, 0)), colors) + changestats)\n        num_failed = rcounts.get(False, 0)\n        hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts(rlabel[False], num_failed), colors))\n        if __opts__.get('state_output_pct', False):\n            try:\n                success_pct = round((rcounts.get(True, 0) + rcounts.get(None, 0)) / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['GREEN'], _counts('Success %', success_pct), colors))\n            except ZeroDivisionError:\n                pass\n            try:\n                failed_pct = round(num_failed / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts('Failure %', failed_pct), colors))\n            except ZeroDivisionError:\n                pass\n        num_warnings = rcounts.get('warnings', 0)\n        if num_warnings:\n            hstrs.append(colorfmt.format(colors['LIGHT_RED'], _counts(rlabel['warnings'], num_warnings), colors))\n        totals = '{0}\\nTotal states run: {1:>{2}}'.format('-' * line_max_len, sum(rcounts.values()) - rcounts.get('warnings', 0), line_max_len - 7)\n        hstrs.append(colorfmt.format(colors['CYAN'], totals, colors))\n        if __opts__.get('state_output_profile'):\n            sum_duration = sum(rdurations)\n            if pdurations:\n                max_pduration = max(pdurations)\n                sum_duration = sum_duration + max_pduration\n            duration_unit = 'ms'\n            if sum_duration > 999:\n                sum_duration /= 1000\n                duration_unit = 's'\n            total_duration = 'Total run time: {} {}'.format('{:.3f}'.format(sum_duration).rjust(line_max_len - 5), duration_unit)\n            hstrs.append(colorfmt.format(colors['CYAN'], total_duration, colors))\n    if strip_colors:\n        host = salt.output.strip_esc_sequence(host)\n    hstrs.insert(0, '{0}{1}:{2[ENDC]}'.format(hcolor, host, colors))\n    return ('\\n'.join(hstrs), nchanges > 0)",
            "def _format_host(host, data, indent_level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Main highstate formatter. can be called recursively if a nested highstate\\n    contains other highstates (ie in an orchestration)\\n    '\n    host = salt.utils.data.decode(host)\n    colors = salt.utils.color.get_colors(__opts__.get('color'), __opts__.get('color_theme'))\n    tabular = __opts__.get('state_tabular', False)\n    rcounts = {}\n    rdurations = []\n    pdurations = []\n    hcolor = colors['GREEN']\n    hstrs = []\n    nchanges = 0\n    strip_colors = __opts__.get('strip_colors', True)\n    if isinstance(data, int):\n        nchanges = 1\n        hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, str):\n        nchanges = 1\n        for data in data.splitlines():\n            hstrs.append('{0}    {1}{2[ENDC]}'.format(hcolor, data, colors))\n        hcolor = colors['CYAN']\n    elif isinstance(data, list):\n        hcolor = colors['LIGHT_RED']\n        hstrs.append('    {0}Data failed to compile:{1[ENDC]}'.format(hcolor, colors))\n        for err in data:\n            if strip_colors:\n                err = salt.output.strip_esc_sequence(salt.utils.data.decode(err))\n            hstrs.append('{0}----------\\n    {1}{2[ENDC]}'.format(hcolor, err, colors))\n    elif isinstance(data, dict):\n        data_tmp = {}\n        for (tname, info) in data.items():\n            if isinstance(info, dict) and tname != 'changes' and info and ('__run_num__' not in info):\n                err = 'The State execution failed to record the order in which all states were executed. The state return missing data is:'\n                hstrs.insert(0, pprint.pformat(info))\n                hstrs.insert(0, err)\n            if isinstance(info, dict) and 'result' in info:\n                data_tmp[tname] = info\n        data = data_tmp\n        for tname in sorted(data, key=lambda k: data[k].get('__run_num__', 0)):\n            ret = data[tname]\n            rcounts.setdefault(ret['result'], 0)\n            compressed_count = 1\n            if __opts__.get('state_compress_ids', False) and '_|-state_compressed_' in tname:\n                (_, _id, _, _) = tname.split('_|-')\n                count_match = re.search('\\\\((\\\\d+)\\\\)$', _id)\n                if count_match:\n                    compressed_count = int(count_match.group(1))\n            rcounts[ret['result']] += compressed_count\n            if '__parallel__' in ret:\n                pduration = ret.get('duration', 0)\n                try:\n                    pdurations.append(float(pduration))\n                except ValueError:\n                    (pduration, _, _) = pduration.partition(' ms')\n                    try:\n                        pdurations.append(float(pduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            else:\n                rduration = ret.get('duration', 0)\n                try:\n                    rdurations.append(float(rduration))\n                except ValueError:\n                    (rduration, _, _) = rduration.partition(' ms')\n                    try:\n                        rdurations.append(float(rduration))\n                    except ValueError:\n                        log.error('Cannot parse a float from duration %s', ret.get('duration', 0))\n            tcolor = colors['GREEN']\n            if ret.get('name') in ['state.orch', 'state.orchestrate', 'state.sls']:\n                nested = output(ret['changes'], indent_level=indent_level + 1)\n                ctext = re.sub('^', ' ' * 14 * indent_level, '\\n' + nested, flags=re.MULTILINE)\n                schanged = True\n                nchanges += 1\n            else:\n                (schanged, ctext) = _format_changes(ret['changes'])\n                if schanged and compressed_count > 1:\n                    nchanges += len(ret['changes'].get('compressed changes', {})) or 1\n                else:\n                    nchanges += 1 if schanged else 0\n            if __opts__.get('state_output_diff', False) and ret['result'] and (not schanged):\n                continue\n            if not __opts__.get('state_verbose', False) and ret['result'] and (not schanged):\n                continue\n            if schanged:\n                tcolor = colors['CYAN']\n            if ret['result'] is False:\n                hcolor = colors['RED']\n                tcolor = colors['RED']\n            if ret['result'] is None:\n                hcolor = colors['LIGHT_YELLOW']\n                tcolor = colors['LIGHT_YELLOW']\n            state_output = __opts__.get('state_output', 'full').lower()\n            comps = tname.split('_|-')\n            if state_output.endswith('_id'):\n                comps[2] = comps[1]\n            if state_output.startswith('filter'):\n                cliargs = __opts__.get('arg', [])\n                clikwargs = {}\n                for item in cliargs:\n                    if isinstance(item, dict) and '__kwarg__' in item:\n                        clikwargs = item.copy()\n                exclude = clikwargs.get('exclude', __opts__.get('state_output_exclude', []))\n                if isinstance(exclude, str):\n                    exclude = str(exclude).split(',')\n                terse = clikwargs.get('terse', __opts__.get('state_output_terse', []))\n                if isinstance(terse, str):\n                    terse = str(terse).split(',')\n                if str(ret['result']) in terse:\n                    msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                    hstrs.append(msg)\n                    continue\n                if str(ret['result']) in exclude:\n                    continue\n            elif any((state_output.startswith('terse'), state_output.startswith('mixed') and ret['result'] is not False, state_output.startswith('changes') and ret['result'] and (not schanged))):\n                msg = _format_terse(tcolor, comps, ret, colors, tabular)\n                hstrs.append(msg)\n                continue\n            state_lines = ['{tcolor}----------{colors[ENDC]}', '    {tcolor}      ID: {comps[1]}{colors[ENDC]}', '    {tcolor}Function: {comps[0]}.{comps[3]}{colors[ENDC]}', '    {tcolor}  Result: {ret[result]!s}{colors[ENDC]}', '    {tcolor} Comment: {comment}{colors[ENDC]}']\n            if __opts__.get('state_output_profile') and 'start_time' in ret:\n                state_lines.extend(['    {tcolor} Started: {ret[start_time]!s}{colors[ENDC]}', '    {tcolor}Duration: {ret[duration]!s}{colors[ENDC]}'])\n            if comps[1] != comps[2]:\n                state_lines.insert(3, '    {tcolor}    Name: {comps[2]}{colors[ENDC]}')\n            try:\n                if not isinstance(ret['comment'], str):\n                    ret['comment'] = str(ret['comment'])\n            except UnicodeDecodeError:\n                ret['comment'] = salt.utils.stringutils.to_unicode(ret['comment'])\n            try:\n                comment = salt.utils.data.decode(ret['comment'])\n                comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            except AttributeError:\n                try:\n                    comment = ret['comment'].join(' ').replace('\\n', '\\n' + ' ' * 13)\n                except AttributeError:\n                    comment = str(ret['comment'])\n                    comment = comment.strip().replace('\\n', '\\n' + ' ' * 14)\n            if 'data' in ret:\n                if isinstance(ret['data'], list):\n                    for item in ret['data']:\n                        comment = '{} {}'.format(comment, item)\n                elif isinstance(ret['data'], dict):\n                    for (key, value) in ret['data'].items():\n                        comment = '{}\\n\\t\\t{}: {}'.format(comment, key, value)\n                else:\n                    comment = '{} {}'.format(comment, ret['data'])\n            for detail in ['start_time', 'duration']:\n                ret.setdefault(detail, '')\n            if ret['duration'] != '':\n                ret['duration'] = '{} ms'.format(ret['duration'])\n            svars = {'tcolor': tcolor, 'comps': comps, 'ret': ret, 'comment': salt.utils.data.decode(comment), 'colors': colors}\n            hstrs.extend([sline.format(**svars) for sline in state_lines])\n            changes = '     Changes:   ' + ctext\n            hstrs.append('{0}{1}{2[ENDC]}'.format(tcolor, changes, colors))\n            if 'warnings' in ret:\n                rcounts.setdefault('warnings', 0)\n                rcounts['warnings'] += 1\n                wrapper = textwrap.TextWrapper(width=80, initial_indent=' ' * 14, subsequent_indent=' ' * 14)\n                hstrs.append('   {colors[LIGHT_RED]} Warnings: {0}{colors[ENDC]}'.format(wrapper.fill('\\n'.join(ret['warnings'])).lstrip(), colors=colors))\n        colorfmt = '{0}{1}{2[ENDC]}'\n        rlabel = {True: 'Succeeded', False: 'Failed', None: 'Not Run', 'warnings': 'Warnings'}\n        count_max_len = max([len(str(x)) for x in rcounts.values()] or [0])\n        label_max_len = max([len(x) for x in rlabel.values()] or [0])\n        line_max_len = label_max_len + count_max_len + 2\n        hstrs.append(colorfmt.format(colors['CYAN'], '\\nSummary for {}\\n{}'.format(host, '-' * line_max_len), colors))\n\n        def _counts(label, count):\n            return '{0}: {1:>{2}}'.format(label, count, line_max_len - (len(label) + 2))\n        changestats = []\n        if None in rcounts and rcounts.get(None, 0) > 0:\n            changestats.append(colorfmt.format(colors['LIGHT_YELLOW'], 'unchanged={}'.format(rcounts.get(None, 0)), colors))\n        if nchanges > 0:\n            changestats.append(colorfmt.format(colors['GREEN'], 'changed={}'.format(nchanges), colors))\n        if changestats:\n            changestats = ' ({})'.format(', '.join(changestats))\n        else:\n            changestats = ''\n        hstrs.append(colorfmt.format(colors['GREEN'], _counts(rlabel[True], rcounts.get(True, 0) + rcounts.get(None, 0)), colors) + changestats)\n        num_failed = rcounts.get(False, 0)\n        hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts(rlabel[False], num_failed), colors))\n        if __opts__.get('state_output_pct', False):\n            try:\n                success_pct = round((rcounts.get(True, 0) + rcounts.get(None, 0)) / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['GREEN'], _counts('Success %', success_pct), colors))\n            except ZeroDivisionError:\n                pass\n            try:\n                failed_pct = round(num_failed / (sum(rcounts.values()) - rcounts.get('warnings', 0)) * 100, 2)\n                hstrs.append(colorfmt.format(colors['RED'] if num_failed else colors['CYAN'], _counts('Failure %', failed_pct), colors))\n            except ZeroDivisionError:\n                pass\n        num_warnings = rcounts.get('warnings', 0)\n        if num_warnings:\n            hstrs.append(colorfmt.format(colors['LIGHT_RED'], _counts(rlabel['warnings'], num_warnings), colors))\n        totals = '{0}\\nTotal states run: {1:>{2}}'.format('-' * line_max_len, sum(rcounts.values()) - rcounts.get('warnings', 0), line_max_len - 7)\n        hstrs.append(colorfmt.format(colors['CYAN'], totals, colors))\n        if __opts__.get('state_output_profile'):\n            sum_duration = sum(rdurations)\n            if pdurations:\n                max_pduration = max(pdurations)\n                sum_duration = sum_duration + max_pduration\n            duration_unit = 'ms'\n            if sum_duration > 999:\n                sum_duration /= 1000\n                duration_unit = 's'\n            total_duration = 'Total run time: {} {}'.format('{:.3f}'.format(sum_duration).rjust(line_max_len - 5), duration_unit)\n            hstrs.append(colorfmt.format(colors['CYAN'], total_duration, colors))\n    if strip_colors:\n        host = salt.output.strip_esc_sequence(host)\n    hstrs.insert(0, '{0}{1}:{2[ENDC]}'.format(hcolor, host, colors))\n    return ('\\n'.join(hstrs), nchanges > 0)"
        ]
    },
    {
        "func_name": "_nested_changes",
        "original": "def _nested_changes(changes):\n    \"\"\"\n    Print the changes data using the nested outputter\n    \"\"\"\n    ret = '\\n'\n    ret += salt.output.out_format(changes, 'nested', __opts__, nested_indent=14)\n    return ret",
        "mutated": [
            "def _nested_changes(changes):\n    if False:\n        i = 10\n    '\\n    Print the changes data using the nested outputter\\n    '\n    ret = '\\n'\n    ret += salt.output.out_format(changes, 'nested', __opts__, nested_indent=14)\n    return ret",
            "def _nested_changes(changes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Print the changes data using the nested outputter\\n    '\n    ret = '\\n'\n    ret += salt.output.out_format(changes, 'nested', __opts__, nested_indent=14)\n    return ret",
            "def _nested_changes(changes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Print the changes data using the nested outputter\\n    '\n    ret = '\\n'\n    ret += salt.output.out_format(changes, 'nested', __opts__, nested_indent=14)\n    return ret",
            "def _nested_changes(changes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Print the changes data using the nested outputter\\n    '\n    ret = '\\n'\n    ret += salt.output.out_format(changes, 'nested', __opts__, nested_indent=14)\n    return ret",
            "def _nested_changes(changes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Print the changes data using the nested outputter\\n    '\n    ret = '\\n'\n    ret += salt.output.out_format(changes, 'nested', __opts__, nested_indent=14)\n    return ret"
        ]
    },
    {
        "func_name": "_format_changes",
        "original": "def _format_changes(changes, orchestration=False):\n    \"\"\"\n    Format the changes dict based on what the data is\n    \"\"\"\n    if not changes:\n        return (False, '')\n    if orchestration:\n        return (True, _nested_changes(changes))\n    if not isinstance(changes, dict):\n        return (True, 'Invalid Changes data: {}'.format(changes))\n    ret = changes.get('ret')\n    if ret is not None and changes.get('out') == 'highstate':\n        ctext = ''\n        changed = False\n        for (host, hostdata) in ret.items():\n            (s, c) = _format_host(host, hostdata)\n            ctext += '\\n' + '\\n'.join((' ' * 14 + l for l in s.splitlines()))\n            changed = changed or c\n    else:\n        changed = True\n        ctext = _nested_changes(changes)\n    return (changed, ctext)",
        "mutated": [
            "def _format_changes(changes, orchestration=False):\n    if False:\n        i = 10\n    '\\n    Format the changes dict based on what the data is\\n    '\n    if not changes:\n        return (False, '')\n    if orchestration:\n        return (True, _nested_changes(changes))\n    if not isinstance(changes, dict):\n        return (True, 'Invalid Changes data: {}'.format(changes))\n    ret = changes.get('ret')\n    if ret is not None and changes.get('out') == 'highstate':\n        ctext = ''\n        changed = False\n        for (host, hostdata) in ret.items():\n            (s, c) = _format_host(host, hostdata)\n            ctext += '\\n' + '\\n'.join((' ' * 14 + l for l in s.splitlines()))\n            changed = changed or c\n    else:\n        changed = True\n        ctext = _nested_changes(changes)\n    return (changed, ctext)",
            "def _format_changes(changes, orchestration=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Format the changes dict based on what the data is\\n    '\n    if not changes:\n        return (False, '')\n    if orchestration:\n        return (True, _nested_changes(changes))\n    if not isinstance(changes, dict):\n        return (True, 'Invalid Changes data: {}'.format(changes))\n    ret = changes.get('ret')\n    if ret is not None and changes.get('out') == 'highstate':\n        ctext = ''\n        changed = False\n        for (host, hostdata) in ret.items():\n            (s, c) = _format_host(host, hostdata)\n            ctext += '\\n' + '\\n'.join((' ' * 14 + l for l in s.splitlines()))\n            changed = changed or c\n    else:\n        changed = True\n        ctext = _nested_changes(changes)\n    return (changed, ctext)",
            "def _format_changes(changes, orchestration=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Format the changes dict based on what the data is\\n    '\n    if not changes:\n        return (False, '')\n    if orchestration:\n        return (True, _nested_changes(changes))\n    if not isinstance(changes, dict):\n        return (True, 'Invalid Changes data: {}'.format(changes))\n    ret = changes.get('ret')\n    if ret is not None and changes.get('out') == 'highstate':\n        ctext = ''\n        changed = False\n        for (host, hostdata) in ret.items():\n            (s, c) = _format_host(host, hostdata)\n            ctext += '\\n' + '\\n'.join((' ' * 14 + l for l in s.splitlines()))\n            changed = changed or c\n    else:\n        changed = True\n        ctext = _nested_changes(changes)\n    return (changed, ctext)",
            "def _format_changes(changes, orchestration=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Format the changes dict based on what the data is\\n    '\n    if not changes:\n        return (False, '')\n    if orchestration:\n        return (True, _nested_changes(changes))\n    if not isinstance(changes, dict):\n        return (True, 'Invalid Changes data: {}'.format(changes))\n    ret = changes.get('ret')\n    if ret is not None and changes.get('out') == 'highstate':\n        ctext = ''\n        changed = False\n        for (host, hostdata) in ret.items():\n            (s, c) = _format_host(host, hostdata)\n            ctext += '\\n' + '\\n'.join((' ' * 14 + l for l in s.splitlines()))\n            changed = changed or c\n    else:\n        changed = True\n        ctext = _nested_changes(changes)\n    return (changed, ctext)",
            "def _format_changes(changes, orchestration=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Format the changes dict based on what the data is\\n    '\n    if not changes:\n        return (False, '')\n    if orchestration:\n        return (True, _nested_changes(changes))\n    if not isinstance(changes, dict):\n        return (True, 'Invalid Changes data: {}'.format(changes))\n    ret = changes.get('ret')\n    if ret is not None and changes.get('out') == 'highstate':\n        ctext = ''\n        changed = False\n        for (host, hostdata) in ret.items():\n            (s, c) = _format_host(host, hostdata)\n            ctext += '\\n' + '\\n'.join((' ' * 14 + l for l in s.splitlines()))\n            changed = changed or c\n    else:\n        changed = True\n        ctext = _nested_changes(changes)\n    return (changed, ctext)"
        ]
    },
    {
        "func_name": "_format_terse",
        "original": "def _format_terse(tcolor, comps, ret, colors, tabular):\n    \"\"\"\n    Terse formatting of a message.\n    \"\"\"\n    result = 'Clean'\n    if ret['changes']:\n        result = 'Changed'\n    if ret['result'] is False:\n        result = 'Failed'\n    elif ret['result'] is None:\n        result = 'Differs'\n    if tabular is True:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}\\n'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += '{0}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += '{6[start_time]!s} [{6[duration]!s:>7} ms] '\n        fmt_string += '{2:>10}.{3:<10} {4:7}   Name: {1}{5}'\n    elif isinstance(tabular, str):\n        fmt_string = tabular\n    else:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += ' {0} Name: {1} - Function: {2}.{3} - Result: {4}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += ' - Started: {6[start_time]!s} - Duration: {6[duration]!s} ms'\n        fmt_string += '{5}'\n    msg = fmt_string.format(tcolor, comps[2], comps[0], comps[-1], result, colors['ENDC'], ret)\n    return msg",
        "mutated": [
            "def _format_terse(tcolor, comps, ret, colors, tabular):\n    if False:\n        i = 10\n    '\\n    Terse formatting of a message.\\n    '\n    result = 'Clean'\n    if ret['changes']:\n        result = 'Changed'\n    if ret['result'] is False:\n        result = 'Failed'\n    elif ret['result'] is None:\n        result = 'Differs'\n    if tabular is True:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}\\n'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += '{0}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += '{6[start_time]!s} [{6[duration]!s:>7} ms] '\n        fmt_string += '{2:>10}.{3:<10} {4:7}   Name: {1}{5}'\n    elif isinstance(tabular, str):\n        fmt_string = tabular\n    else:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += ' {0} Name: {1} - Function: {2}.{3} - Result: {4}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += ' - Started: {6[start_time]!s} - Duration: {6[duration]!s} ms'\n        fmt_string += '{5}'\n    msg = fmt_string.format(tcolor, comps[2], comps[0], comps[-1], result, colors['ENDC'], ret)\n    return msg",
            "def _format_terse(tcolor, comps, ret, colors, tabular):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Terse formatting of a message.\\n    '\n    result = 'Clean'\n    if ret['changes']:\n        result = 'Changed'\n    if ret['result'] is False:\n        result = 'Failed'\n    elif ret['result'] is None:\n        result = 'Differs'\n    if tabular is True:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}\\n'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += '{0}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += '{6[start_time]!s} [{6[duration]!s:>7} ms] '\n        fmt_string += '{2:>10}.{3:<10} {4:7}   Name: {1}{5}'\n    elif isinstance(tabular, str):\n        fmt_string = tabular\n    else:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += ' {0} Name: {1} - Function: {2}.{3} - Result: {4}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += ' - Started: {6[start_time]!s} - Duration: {6[duration]!s} ms'\n        fmt_string += '{5}'\n    msg = fmt_string.format(tcolor, comps[2], comps[0], comps[-1], result, colors['ENDC'], ret)\n    return msg",
            "def _format_terse(tcolor, comps, ret, colors, tabular):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Terse formatting of a message.\\n    '\n    result = 'Clean'\n    if ret['changes']:\n        result = 'Changed'\n    if ret['result'] is False:\n        result = 'Failed'\n    elif ret['result'] is None:\n        result = 'Differs'\n    if tabular is True:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}\\n'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += '{0}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += '{6[start_time]!s} [{6[duration]!s:>7} ms] '\n        fmt_string += '{2:>10}.{3:<10} {4:7}   Name: {1}{5}'\n    elif isinstance(tabular, str):\n        fmt_string = tabular\n    else:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += ' {0} Name: {1} - Function: {2}.{3} - Result: {4}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += ' - Started: {6[start_time]!s} - Duration: {6[duration]!s} ms'\n        fmt_string += '{5}'\n    msg = fmt_string.format(tcolor, comps[2], comps[0], comps[-1], result, colors['ENDC'], ret)\n    return msg",
            "def _format_terse(tcolor, comps, ret, colors, tabular):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Terse formatting of a message.\\n    '\n    result = 'Clean'\n    if ret['changes']:\n        result = 'Changed'\n    if ret['result'] is False:\n        result = 'Failed'\n    elif ret['result'] is None:\n        result = 'Differs'\n    if tabular is True:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}\\n'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += '{0}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += '{6[start_time]!s} [{6[duration]!s:>7} ms] '\n        fmt_string += '{2:>10}.{3:<10} {4:7}   Name: {1}{5}'\n    elif isinstance(tabular, str):\n        fmt_string = tabular\n    else:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += ' {0} Name: {1} - Function: {2}.{3} - Result: {4}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += ' - Started: {6[start_time]!s} - Duration: {6[duration]!s} ms'\n        fmt_string += '{5}'\n    msg = fmt_string.format(tcolor, comps[2], comps[0], comps[-1], result, colors['ENDC'], ret)\n    return msg",
            "def _format_terse(tcolor, comps, ret, colors, tabular):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Terse formatting of a message.\\n    '\n    result = 'Clean'\n    if ret['changes']:\n        result = 'Changed'\n    if ret['result'] is False:\n        result = 'Failed'\n    elif ret['result'] is None:\n        result = 'Differs'\n    if tabular is True:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}\\n'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += '{0}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += '{6[start_time]!s} [{6[duration]!s:>7} ms] '\n        fmt_string += '{2:>10}.{3:<10} {4:7}   Name: {1}{5}'\n    elif isinstance(tabular, str):\n        fmt_string = tabular\n    else:\n        fmt_string = ''\n        if 'warnings' in ret:\n            fmt_string += '{c[LIGHT_RED]}Warnings:\\n{w}{c[ENDC]}'.format(c=colors, w='\\n'.join(ret['warnings']))\n        fmt_string += ' {0} Name: {1} - Function: {2}.{3} - Result: {4}'\n        if __opts__.get('state_output_profile') and 'start_time' in ret:\n            fmt_string += ' - Started: {6[start_time]!s} - Duration: {6[duration]!s} ms'\n        fmt_string += '{5}'\n    msg = fmt_string.format(tcolor, comps[2], comps[0], comps[-1], result, colors['ENDC'], ret)\n    return msg"
        ]
    }
]