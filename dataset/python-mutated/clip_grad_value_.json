[
    {
        "func_name": "clip_grad_value_",
        "original": "@paddle.autograd.no_grad()\ndef clip_grad_value_(parameters, clip_value):\n    \"\"\"\n    Clips gradient of an iterable of parameters at specified value.\n    The gradient will be modified in place.\n    This API can only run in dynamic graph mode, not static graph mode.\n\n    Args:\n        parameters (Iterable[paddle.Tensor]|paddle.Tensor): Tensors or a single Tensor\n            that will be normalized gradients\n        clip_value (float|int): maximum allowed value of the gradients.\n            The gradients are clipped in the range\n            :math:`\\\\left[\\\\text{-clip\\\\_value}, \\\\text{clip\\\\_value}\\\\right]`\n\n    Example:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> x = paddle.uniform([10, 10], min=-10.0, max=10.0, dtype='float32')\n            >>> clip_value = float(5.0)\n            >>> linear = paddle.nn.Linear(in_features=10, out_features=10)\n            >>> out = linear(x)\n            >>> loss = paddle.mean(out)\n            >>> loss.backward()\n            >>> paddle.nn.utils.clip_grad_value_(linear.parameters(), clip_value)\n            >>> sdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters())\n            >>> sdg.step()\n    \"\"\"\n    if not paddle.in_dynamic_mode():\n        raise RuntimeError('this API can only run in dynamic mode.')\n    if isinstance(parameters, paddle.Tensor):\n        parameters = [parameters]\n    clip_value = float(clip_value)\n    for (_, p) in enumerate(parameters):\n        if p.grad is not None:\n            p.grad.clip_(min=-clip_value, max=clip_value)",
        "mutated": [
            "@paddle.autograd.no_grad()\ndef clip_grad_value_(parameters, clip_value):\n    if False:\n        i = 10\n    \"\\n    Clips gradient of an iterable of parameters at specified value.\\n    The gradient will be modified in place.\\n    This API can only run in dynamic graph mode, not static graph mode.\\n\\n    Args:\\n        parameters (Iterable[paddle.Tensor]|paddle.Tensor): Tensors or a single Tensor\\n            that will be normalized gradients\\n        clip_value (float|int): maximum allowed value of the gradients.\\n            The gradients are clipped in the range\\n            :math:`\\\\left[\\\\text{-clip\\\\_value}, \\\\text{clip\\\\_value}\\\\right]`\\n\\n    Example:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n            >>> x = paddle.uniform([10, 10], min=-10.0, max=10.0, dtype='float32')\\n            >>> clip_value = float(5.0)\\n            >>> linear = paddle.nn.Linear(in_features=10, out_features=10)\\n            >>> out = linear(x)\\n            >>> loss = paddle.mean(out)\\n            >>> loss.backward()\\n            >>> paddle.nn.utils.clip_grad_value_(linear.parameters(), clip_value)\\n            >>> sdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters())\\n            >>> sdg.step()\\n    \"\n    if not paddle.in_dynamic_mode():\n        raise RuntimeError('this API can only run in dynamic mode.')\n    if isinstance(parameters, paddle.Tensor):\n        parameters = [parameters]\n    clip_value = float(clip_value)\n    for (_, p) in enumerate(parameters):\n        if p.grad is not None:\n            p.grad.clip_(min=-clip_value, max=clip_value)",
            "@paddle.autograd.no_grad()\ndef clip_grad_value_(parameters, clip_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Clips gradient of an iterable of parameters at specified value.\\n    The gradient will be modified in place.\\n    This API can only run in dynamic graph mode, not static graph mode.\\n\\n    Args:\\n        parameters (Iterable[paddle.Tensor]|paddle.Tensor): Tensors or a single Tensor\\n            that will be normalized gradients\\n        clip_value (float|int): maximum allowed value of the gradients.\\n            The gradients are clipped in the range\\n            :math:`\\\\left[\\\\text{-clip\\\\_value}, \\\\text{clip\\\\_value}\\\\right]`\\n\\n    Example:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n            >>> x = paddle.uniform([10, 10], min=-10.0, max=10.0, dtype='float32')\\n            >>> clip_value = float(5.0)\\n            >>> linear = paddle.nn.Linear(in_features=10, out_features=10)\\n            >>> out = linear(x)\\n            >>> loss = paddle.mean(out)\\n            >>> loss.backward()\\n            >>> paddle.nn.utils.clip_grad_value_(linear.parameters(), clip_value)\\n            >>> sdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters())\\n            >>> sdg.step()\\n    \"\n    if not paddle.in_dynamic_mode():\n        raise RuntimeError('this API can only run in dynamic mode.')\n    if isinstance(parameters, paddle.Tensor):\n        parameters = [parameters]\n    clip_value = float(clip_value)\n    for (_, p) in enumerate(parameters):\n        if p.grad is not None:\n            p.grad.clip_(min=-clip_value, max=clip_value)",
            "@paddle.autograd.no_grad()\ndef clip_grad_value_(parameters, clip_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Clips gradient of an iterable of parameters at specified value.\\n    The gradient will be modified in place.\\n    This API can only run in dynamic graph mode, not static graph mode.\\n\\n    Args:\\n        parameters (Iterable[paddle.Tensor]|paddle.Tensor): Tensors or a single Tensor\\n            that will be normalized gradients\\n        clip_value (float|int): maximum allowed value of the gradients.\\n            The gradients are clipped in the range\\n            :math:`\\\\left[\\\\text{-clip\\\\_value}, \\\\text{clip\\\\_value}\\\\right]`\\n\\n    Example:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n            >>> x = paddle.uniform([10, 10], min=-10.0, max=10.0, dtype='float32')\\n            >>> clip_value = float(5.0)\\n            >>> linear = paddle.nn.Linear(in_features=10, out_features=10)\\n            >>> out = linear(x)\\n            >>> loss = paddle.mean(out)\\n            >>> loss.backward()\\n            >>> paddle.nn.utils.clip_grad_value_(linear.parameters(), clip_value)\\n            >>> sdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters())\\n            >>> sdg.step()\\n    \"\n    if not paddle.in_dynamic_mode():\n        raise RuntimeError('this API can only run in dynamic mode.')\n    if isinstance(parameters, paddle.Tensor):\n        parameters = [parameters]\n    clip_value = float(clip_value)\n    for (_, p) in enumerate(parameters):\n        if p.grad is not None:\n            p.grad.clip_(min=-clip_value, max=clip_value)",
            "@paddle.autograd.no_grad()\ndef clip_grad_value_(parameters, clip_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Clips gradient of an iterable of parameters at specified value.\\n    The gradient will be modified in place.\\n    This API can only run in dynamic graph mode, not static graph mode.\\n\\n    Args:\\n        parameters (Iterable[paddle.Tensor]|paddle.Tensor): Tensors or a single Tensor\\n            that will be normalized gradients\\n        clip_value (float|int): maximum allowed value of the gradients.\\n            The gradients are clipped in the range\\n            :math:`\\\\left[\\\\text{-clip\\\\_value}, \\\\text{clip\\\\_value}\\\\right]`\\n\\n    Example:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n            >>> x = paddle.uniform([10, 10], min=-10.0, max=10.0, dtype='float32')\\n            >>> clip_value = float(5.0)\\n            >>> linear = paddle.nn.Linear(in_features=10, out_features=10)\\n            >>> out = linear(x)\\n            >>> loss = paddle.mean(out)\\n            >>> loss.backward()\\n            >>> paddle.nn.utils.clip_grad_value_(linear.parameters(), clip_value)\\n            >>> sdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters())\\n            >>> sdg.step()\\n    \"\n    if not paddle.in_dynamic_mode():\n        raise RuntimeError('this API can only run in dynamic mode.')\n    if isinstance(parameters, paddle.Tensor):\n        parameters = [parameters]\n    clip_value = float(clip_value)\n    for (_, p) in enumerate(parameters):\n        if p.grad is not None:\n            p.grad.clip_(min=-clip_value, max=clip_value)",
            "@paddle.autograd.no_grad()\ndef clip_grad_value_(parameters, clip_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Clips gradient of an iterable of parameters at specified value.\\n    The gradient will be modified in place.\\n    This API can only run in dynamic graph mode, not static graph mode.\\n\\n    Args:\\n        parameters (Iterable[paddle.Tensor]|paddle.Tensor): Tensors or a single Tensor\\n            that will be normalized gradients\\n        clip_value (float|int): maximum allowed value of the gradients.\\n            The gradients are clipped in the range\\n            :math:`\\\\left[\\\\text{-clip\\\\_value}, \\\\text{clip\\\\_value}\\\\right]`\\n\\n    Example:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n            >>> x = paddle.uniform([10, 10], min=-10.0, max=10.0, dtype='float32')\\n            >>> clip_value = float(5.0)\\n            >>> linear = paddle.nn.Linear(in_features=10, out_features=10)\\n            >>> out = linear(x)\\n            >>> loss = paddle.mean(out)\\n            >>> loss.backward()\\n            >>> paddle.nn.utils.clip_grad_value_(linear.parameters(), clip_value)\\n            >>> sdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters())\\n            >>> sdg.step()\\n    \"\n    if not paddle.in_dynamic_mode():\n        raise RuntimeError('this API can only run in dynamic mode.')\n    if isinstance(parameters, paddle.Tensor):\n        parameters = [parameters]\n    clip_value = float(clip_value)\n    for (_, p) in enumerate(parameters):\n        if p.grad is not None:\n            p.grad.clip_(min=-clip_value, max=clip_value)"
        ]
    }
]