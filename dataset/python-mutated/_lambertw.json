[
    {
        "func_name": "lambertw",
        "original": "def lambertw(z, k=0, tol=1e-08):\n    \"\"\"\n    lambertw(z, k=0, tol=1e-8)\n\n    Lambert W function.\n\n    The Lambert W function `W(z)` is defined as the inverse function\n    of ``w * exp(w)``. In other words, the value of ``W(z)`` is\n    such that ``z = W(z) * exp(W(z))`` for any complex number\n    ``z``.\n\n    The Lambert W function is a multivalued function with infinitely\n    many branches. Each branch gives a separate solution of the\n    equation ``z = w exp(w)``. Here, the branches are indexed by the\n    integer `k`.\n\n    Parameters\n    ----------\n    z : array_like\n        Input argument.\n    k : int, optional\n        Branch index.\n    tol : float, optional\n        Evaluation tolerance.\n\n    Returns\n    -------\n    w : array\n        `w` will have the same shape as `z`.\n\n    See Also\n    --------\n    wrightomega : the Wright Omega function\n\n    Notes\n    -----\n    All branches are supported by `lambertw`:\n\n    * ``lambertw(z)`` gives the principal solution (branch 0)\n    * ``lambertw(z, k)`` gives the solution on branch `k`\n\n    The Lambert W function has two partially real branches: the\n    principal branch (`k = 0`) is real for real ``z > -1/e``, and the\n    ``k = -1`` branch is real for ``-1/e < z < 0``. All branches except\n    ``k = 0`` have a logarithmic singularity at ``z = 0``.\n\n    **Possible issues**\n\n    The evaluation can become inaccurate very close to the branch point\n    at ``-1/e``. In some corner cases, `lambertw` might currently\n    fail to converge, or can end up on the wrong branch.\n\n    **Algorithm**\n\n    Halley's iteration is used to invert ``w * exp(w)``, using a first-order\n    asymptotic approximation (O(log(w)) or `O(w)`) as the initial estimate.\n\n    The definition, implementation and choice of branches is based on [2]_.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Lambert_W_function\n    .. [2] Corless et al, \"On the Lambert W function\", Adv. Comp. Math. 5\n       (1996) 329-359.\n       https://cs.uwaterloo.ca/research/tr/1993/03/W.pdf\n\n    Examples\n    --------\n    The Lambert W function is the inverse of ``w exp(w)``:\n\n    >>> import numpy as np\n    >>> from scipy.special import lambertw\n    >>> w = lambertw(1)\n    >>> w\n    (0.56714329040978384+0j)\n    >>> w * np.exp(w)\n    (1.0+0j)\n\n    Any branch gives a valid inverse:\n\n    >>> w = lambertw(1, k=3)\n    >>> w\n    (-2.8535817554090377+17.113535539412148j)\n    >>> w*np.exp(w)\n    (1.0000000000000002+1.609823385706477e-15j)\n\n    **Applications to equation-solving**\n\n    The Lambert W function may be used to solve various kinds of\n    equations.  We give two examples here.\n\n    First, the function can be used to solve implicit equations of the\n    form\n\n        :math:`x = a + b e^{c x}`\n\n    for :math:`x`.  We assume :math:`c` is not zero.  After a little\n    algebra, the equation may be written\n\n        :math:`z e^z = -b c e^{a c}`\n\n    where :math:`z = c (a - x)`.  :math:`z` may then be expressed using\n    the Lambert W function\n\n        :math:`z = W(-b c e^{a c})`\n\n    giving\n\n        :math:`x = a - W(-b c e^{a c})/c`\n\n    For example,\n\n    >>> a = 3\n    >>> b = 2\n    >>> c = -0.5\n\n    The solution to :math:`x = a + b e^{c x}` is:\n\n    >>> x = a - lambertw(-b*c*np.exp(a*c))/c\n    >>> x\n    (3.3707498368978794+0j)\n\n    Verify that it solves the equation:\n\n    >>> a + b*np.exp(c*x)\n    (3.37074983689788+0j)\n\n    The Lambert W function may also be used find the value of the infinite\n    power tower :math:`z^{z^{z^{\\\\ldots}}}`:\n\n    >>> def tower(z, n):\n    ...     if n == 0:\n    ...         return z\n    ...     return z ** tower(z, n-1)\n    ...\n    >>> tower(0.5, 100)\n    0.641185744504986\n    >>> -lambertw(-np.log(0.5)) / np.log(0.5)\n    (0.64118574450498589+0j)\n    \"\"\"\n    return _lambertw(z, k, tol)",
        "mutated": [
            "def lambertw(z, k=0, tol=1e-08):\n    if False:\n        i = 10\n    '\\n    lambertw(z, k=0, tol=1e-8)\\n\\n    Lambert W function.\\n\\n    The Lambert W function `W(z)` is defined as the inverse function\\n    of ``w * exp(w)``. In other words, the value of ``W(z)`` is\\n    such that ``z = W(z) * exp(W(z))`` for any complex number\\n    ``z``.\\n\\n    The Lambert W function is a multivalued function with infinitely\\n    many branches. Each branch gives a separate solution of the\\n    equation ``z = w exp(w)``. Here, the branches are indexed by the\\n    integer `k`.\\n\\n    Parameters\\n    ----------\\n    z : array_like\\n        Input argument.\\n    k : int, optional\\n        Branch index.\\n    tol : float, optional\\n        Evaluation tolerance.\\n\\n    Returns\\n    -------\\n    w : array\\n        `w` will have the same shape as `z`.\\n\\n    See Also\\n    --------\\n    wrightomega : the Wright Omega function\\n\\n    Notes\\n    -----\\n    All branches are supported by `lambertw`:\\n\\n    * ``lambertw(z)`` gives the principal solution (branch 0)\\n    * ``lambertw(z, k)`` gives the solution on branch `k`\\n\\n    The Lambert W function has two partially real branches: the\\n    principal branch (`k = 0`) is real for real ``z > -1/e``, and the\\n    ``k = -1`` branch is real for ``-1/e < z < 0``. All branches except\\n    ``k = 0`` have a logarithmic singularity at ``z = 0``.\\n\\n    **Possible issues**\\n\\n    The evaluation can become inaccurate very close to the branch point\\n    at ``-1/e``. In some corner cases, `lambertw` might currently\\n    fail to converge, or can end up on the wrong branch.\\n\\n    **Algorithm**\\n\\n    Halley\\'s iteration is used to invert ``w * exp(w)``, using a first-order\\n    asymptotic approximation (O(log(w)) or `O(w)`) as the initial estimate.\\n\\n    The definition, implementation and choice of branches is based on [2]_.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Lambert_W_function\\n    .. [2] Corless et al, \"On the Lambert W function\", Adv. Comp. Math. 5\\n       (1996) 329-359.\\n       https://cs.uwaterloo.ca/research/tr/1993/03/W.pdf\\n\\n    Examples\\n    --------\\n    The Lambert W function is the inverse of ``w exp(w)``:\\n\\n    >>> import numpy as np\\n    >>> from scipy.special import lambertw\\n    >>> w = lambertw(1)\\n    >>> w\\n    (0.56714329040978384+0j)\\n    >>> w * np.exp(w)\\n    (1.0+0j)\\n\\n    Any branch gives a valid inverse:\\n\\n    >>> w = lambertw(1, k=3)\\n    >>> w\\n    (-2.8535817554090377+17.113535539412148j)\\n    >>> w*np.exp(w)\\n    (1.0000000000000002+1.609823385706477e-15j)\\n\\n    **Applications to equation-solving**\\n\\n    The Lambert W function may be used to solve various kinds of\\n    equations.  We give two examples here.\\n\\n    First, the function can be used to solve implicit equations of the\\n    form\\n\\n        :math:`x = a + b e^{c x}`\\n\\n    for :math:`x`.  We assume :math:`c` is not zero.  After a little\\n    algebra, the equation may be written\\n\\n        :math:`z e^z = -b c e^{a c}`\\n\\n    where :math:`z = c (a - x)`.  :math:`z` may then be expressed using\\n    the Lambert W function\\n\\n        :math:`z = W(-b c e^{a c})`\\n\\n    giving\\n\\n        :math:`x = a - W(-b c e^{a c})/c`\\n\\n    For example,\\n\\n    >>> a = 3\\n    >>> b = 2\\n    >>> c = -0.5\\n\\n    The solution to :math:`x = a + b e^{c x}` is:\\n\\n    >>> x = a - lambertw(-b*c*np.exp(a*c))/c\\n    >>> x\\n    (3.3707498368978794+0j)\\n\\n    Verify that it solves the equation:\\n\\n    >>> a + b*np.exp(c*x)\\n    (3.37074983689788+0j)\\n\\n    The Lambert W function may also be used find the value of the infinite\\n    power tower :math:`z^{z^{z^{\\\\ldots}}}`:\\n\\n    >>> def tower(z, n):\\n    ...     if n == 0:\\n    ...         return z\\n    ...     return z ** tower(z, n-1)\\n    ...\\n    >>> tower(0.5, 100)\\n    0.641185744504986\\n    >>> -lambertw(-np.log(0.5)) / np.log(0.5)\\n    (0.64118574450498589+0j)\\n    '\n    return _lambertw(z, k, tol)",
            "def lambertw(z, k=0, tol=1e-08):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    lambertw(z, k=0, tol=1e-8)\\n\\n    Lambert W function.\\n\\n    The Lambert W function `W(z)` is defined as the inverse function\\n    of ``w * exp(w)``. In other words, the value of ``W(z)`` is\\n    such that ``z = W(z) * exp(W(z))`` for any complex number\\n    ``z``.\\n\\n    The Lambert W function is a multivalued function with infinitely\\n    many branches. Each branch gives a separate solution of the\\n    equation ``z = w exp(w)``. Here, the branches are indexed by the\\n    integer `k`.\\n\\n    Parameters\\n    ----------\\n    z : array_like\\n        Input argument.\\n    k : int, optional\\n        Branch index.\\n    tol : float, optional\\n        Evaluation tolerance.\\n\\n    Returns\\n    -------\\n    w : array\\n        `w` will have the same shape as `z`.\\n\\n    See Also\\n    --------\\n    wrightomega : the Wright Omega function\\n\\n    Notes\\n    -----\\n    All branches are supported by `lambertw`:\\n\\n    * ``lambertw(z)`` gives the principal solution (branch 0)\\n    * ``lambertw(z, k)`` gives the solution on branch `k`\\n\\n    The Lambert W function has two partially real branches: the\\n    principal branch (`k = 0`) is real for real ``z > -1/e``, and the\\n    ``k = -1`` branch is real for ``-1/e < z < 0``. All branches except\\n    ``k = 0`` have a logarithmic singularity at ``z = 0``.\\n\\n    **Possible issues**\\n\\n    The evaluation can become inaccurate very close to the branch point\\n    at ``-1/e``. In some corner cases, `lambertw` might currently\\n    fail to converge, or can end up on the wrong branch.\\n\\n    **Algorithm**\\n\\n    Halley\\'s iteration is used to invert ``w * exp(w)``, using a first-order\\n    asymptotic approximation (O(log(w)) or `O(w)`) as the initial estimate.\\n\\n    The definition, implementation and choice of branches is based on [2]_.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Lambert_W_function\\n    .. [2] Corless et al, \"On the Lambert W function\", Adv. Comp. Math. 5\\n       (1996) 329-359.\\n       https://cs.uwaterloo.ca/research/tr/1993/03/W.pdf\\n\\n    Examples\\n    --------\\n    The Lambert W function is the inverse of ``w exp(w)``:\\n\\n    >>> import numpy as np\\n    >>> from scipy.special import lambertw\\n    >>> w = lambertw(1)\\n    >>> w\\n    (0.56714329040978384+0j)\\n    >>> w * np.exp(w)\\n    (1.0+0j)\\n\\n    Any branch gives a valid inverse:\\n\\n    >>> w = lambertw(1, k=3)\\n    >>> w\\n    (-2.8535817554090377+17.113535539412148j)\\n    >>> w*np.exp(w)\\n    (1.0000000000000002+1.609823385706477e-15j)\\n\\n    **Applications to equation-solving**\\n\\n    The Lambert W function may be used to solve various kinds of\\n    equations.  We give two examples here.\\n\\n    First, the function can be used to solve implicit equations of the\\n    form\\n\\n        :math:`x = a + b e^{c x}`\\n\\n    for :math:`x`.  We assume :math:`c` is not zero.  After a little\\n    algebra, the equation may be written\\n\\n        :math:`z e^z = -b c e^{a c}`\\n\\n    where :math:`z = c (a - x)`.  :math:`z` may then be expressed using\\n    the Lambert W function\\n\\n        :math:`z = W(-b c e^{a c})`\\n\\n    giving\\n\\n        :math:`x = a - W(-b c e^{a c})/c`\\n\\n    For example,\\n\\n    >>> a = 3\\n    >>> b = 2\\n    >>> c = -0.5\\n\\n    The solution to :math:`x = a + b e^{c x}` is:\\n\\n    >>> x = a - lambertw(-b*c*np.exp(a*c))/c\\n    >>> x\\n    (3.3707498368978794+0j)\\n\\n    Verify that it solves the equation:\\n\\n    >>> a + b*np.exp(c*x)\\n    (3.37074983689788+0j)\\n\\n    The Lambert W function may also be used find the value of the infinite\\n    power tower :math:`z^{z^{z^{\\\\ldots}}}`:\\n\\n    >>> def tower(z, n):\\n    ...     if n == 0:\\n    ...         return z\\n    ...     return z ** tower(z, n-1)\\n    ...\\n    >>> tower(0.5, 100)\\n    0.641185744504986\\n    >>> -lambertw(-np.log(0.5)) / np.log(0.5)\\n    (0.64118574450498589+0j)\\n    '\n    return _lambertw(z, k, tol)",
            "def lambertw(z, k=0, tol=1e-08):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    lambertw(z, k=0, tol=1e-8)\\n\\n    Lambert W function.\\n\\n    The Lambert W function `W(z)` is defined as the inverse function\\n    of ``w * exp(w)``. In other words, the value of ``W(z)`` is\\n    such that ``z = W(z) * exp(W(z))`` for any complex number\\n    ``z``.\\n\\n    The Lambert W function is a multivalued function with infinitely\\n    many branches. Each branch gives a separate solution of the\\n    equation ``z = w exp(w)``. Here, the branches are indexed by the\\n    integer `k`.\\n\\n    Parameters\\n    ----------\\n    z : array_like\\n        Input argument.\\n    k : int, optional\\n        Branch index.\\n    tol : float, optional\\n        Evaluation tolerance.\\n\\n    Returns\\n    -------\\n    w : array\\n        `w` will have the same shape as `z`.\\n\\n    See Also\\n    --------\\n    wrightomega : the Wright Omega function\\n\\n    Notes\\n    -----\\n    All branches are supported by `lambertw`:\\n\\n    * ``lambertw(z)`` gives the principal solution (branch 0)\\n    * ``lambertw(z, k)`` gives the solution on branch `k`\\n\\n    The Lambert W function has two partially real branches: the\\n    principal branch (`k = 0`) is real for real ``z > -1/e``, and the\\n    ``k = -1`` branch is real for ``-1/e < z < 0``. All branches except\\n    ``k = 0`` have a logarithmic singularity at ``z = 0``.\\n\\n    **Possible issues**\\n\\n    The evaluation can become inaccurate very close to the branch point\\n    at ``-1/e``. In some corner cases, `lambertw` might currently\\n    fail to converge, or can end up on the wrong branch.\\n\\n    **Algorithm**\\n\\n    Halley\\'s iteration is used to invert ``w * exp(w)``, using a first-order\\n    asymptotic approximation (O(log(w)) or `O(w)`) as the initial estimate.\\n\\n    The definition, implementation and choice of branches is based on [2]_.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Lambert_W_function\\n    .. [2] Corless et al, \"On the Lambert W function\", Adv. Comp. Math. 5\\n       (1996) 329-359.\\n       https://cs.uwaterloo.ca/research/tr/1993/03/W.pdf\\n\\n    Examples\\n    --------\\n    The Lambert W function is the inverse of ``w exp(w)``:\\n\\n    >>> import numpy as np\\n    >>> from scipy.special import lambertw\\n    >>> w = lambertw(1)\\n    >>> w\\n    (0.56714329040978384+0j)\\n    >>> w * np.exp(w)\\n    (1.0+0j)\\n\\n    Any branch gives a valid inverse:\\n\\n    >>> w = lambertw(1, k=3)\\n    >>> w\\n    (-2.8535817554090377+17.113535539412148j)\\n    >>> w*np.exp(w)\\n    (1.0000000000000002+1.609823385706477e-15j)\\n\\n    **Applications to equation-solving**\\n\\n    The Lambert W function may be used to solve various kinds of\\n    equations.  We give two examples here.\\n\\n    First, the function can be used to solve implicit equations of the\\n    form\\n\\n        :math:`x = a + b e^{c x}`\\n\\n    for :math:`x`.  We assume :math:`c` is not zero.  After a little\\n    algebra, the equation may be written\\n\\n        :math:`z e^z = -b c e^{a c}`\\n\\n    where :math:`z = c (a - x)`.  :math:`z` may then be expressed using\\n    the Lambert W function\\n\\n        :math:`z = W(-b c e^{a c})`\\n\\n    giving\\n\\n        :math:`x = a - W(-b c e^{a c})/c`\\n\\n    For example,\\n\\n    >>> a = 3\\n    >>> b = 2\\n    >>> c = -0.5\\n\\n    The solution to :math:`x = a + b e^{c x}` is:\\n\\n    >>> x = a - lambertw(-b*c*np.exp(a*c))/c\\n    >>> x\\n    (3.3707498368978794+0j)\\n\\n    Verify that it solves the equation:\\n\\n    >>> a + b*np.exp(c*x)\\n    (3.37074983689788+0j)\\n\\n    The Lambert W function may also be used find the value of the infinite\\n    power tower :math:`z^{z^{z^{\\\\ldots}}}`:\\n\\n    >>> def tower(z, n):\\n    ...     if n == 0:\\n    ...         return z\\n    ...     return z ** tower(z, n-1)\\n    ...\\n    >>> tower(0.5, 100)\\n    0.641185744504986\\n    >>> -lambertw(-np.log(0.5)) / np.log(0.5)\\n    (0.64118574450498589+0j)\\n    '\n    return _lambertw(z, k, tol)",
            "def lambertw(z, k=0, tol=1e-08):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    lambertw(z, k=0, tol=1e-8)\\n\\n    Lambert W function.\\n\\n    The Lambert W function `W(z)` is defined as the inverse function\\n    of ``w * exp(w)``. In other words, the value of ``W(z)`` is\\n    such that ``z = W(z) * exp(W(z))`` for any complex number\\n    ``z``.\\n\\n    The Lambert W function is a multivalued function with infinitely\\n    many branches. Each branch gives a separate solution of the\\n    equation ``z = w exp(w)``. Here, the branches are indexed by the\\n    integer `k`.\\n\\n    Parameters\\n    ----------\\n    z : array_like\\n        Input argument.\\n    k : int, optional\\n        Branch index.\\n    tol : float, optional\\n        Evaluation tolerance.\\n\\n    Returns\\n    -------\\n    w : array\\n        `w` will have the same shape as `z`.\\n\\n    See Also\\n    --------\\n    wrightomega : the Wright Omega function\\n\\n    Notes\\n    -----\\n    All branches are supported by `lambertw`:\\n\\n    * ``lambertw(z)`` gives the principal solution (branch 0)\\n    * ``lambertw(z, k)`` gives the solution on branch `k`\\n\\n    The Lambert W function has two partially real branches: the\\n    principal branch (`k = 0`) is real for real ``z > -1/e``, and the\\n    ``k = -1`` branch is real for ``-1/e < z < 0``. All branches except\\n    ``k = 0`` have a logarithmic singularity at ``z = 0``.\\n\\n    **Possible issues**\\n\\n    The evaluation can become inaccurate very close to the branch point\\n    at ``-1/e``. In some corner cases, `lambertw` might currently\\n    fail to converge, or can end up on the wrong branch.\\n\\n    **Algorithm**\\n\\n    Halley\\'s iteration is used to invert ``w * exp(w)``, using a first-order\\n    asymptotic approximation (O(log(w)) or `O(w)`) as the initial estimate.\\n\\n    The definition, implementation and choice of branches is based on [2]_.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Lambert_W_function\\n    .. [2] Corless et al, \"On the Lambert W function\", Adv. Comp. Math. 5\\n       (1996) 329-359.\\n       https://cs.uwaterloo.ca/research/tr/1993/03/W.pdf\\n\\n    Examples\\n    --------\\n    The Lambert W function is the inverse of ``w exp(w)``:\\n\\n    >>> import numpy as np\\n    >>> from scipy.special import lambertw\\n    >>> w = lambertw(1)\\n    >>> w\\n    (0.56714329040978384+0j)\\n    >>> w * np.exp(w)\\n    (1.0+0j)\\n\\n    Any branch gives a valid inverse:\\n\\n    >>> w = lambertw(1, k=3)\\n    >>> w\\n    (-2.8535817554090377+17.113535539412148j)\\n    >>> w*np.exp(w)\\n    (1.0000000000000002+1.609823385706477e-15j)\\n\\n    **Applications to equation-solving**\\n\\n    The Lambert W function may be used to solve various kinds of\\n    equations.  We give two examples here.\\n\\n    First, the function can be used to solve implicit equations of the\\n    form\\n\\n        :math:`x = a + b e^{c x}`\\n\\n    for :math:`x`.  We assume :math:`c` is not zero.  After a little\\n    algebra, the equation may be written\\n\\n        :math:`z e^z = -b c e^{a c}`\\n\\n    where :math:`z = c (a - x)`.  :math:`z` may then be expressed using\\n    the Lambert W function\\n\\n        :math:`z = W(-b c e^{a c})`\\n\\n    giving\\n\\n        :math:`x = a - W(-b c e^{a c})/c`\\n\\n    For example,\\n\\n    >>> a = 3\\n    >>> b = 2\\n    >>> c = -0.5\\n\\n    The solution to :math:`x = a + b e^{c x}` is:\\n\\n    >>> x = a - lambertw(-b*c*np.exp(a*c))/c\\n    >>> x\\n    (3.3707498368978794+0j)\\n\\n    Verify that it solves the equation:\\n\\n    >>> a + b*np.exp(c*x)\\n    (3.37074983689788+0j)\\n\\n    The Lambert W function may also be used find the value of the infinite\\n    power tower :math:`z^{z^{z^{\\\\ldots}}}`:\\n\\n    >>> def tower(z, n):\\n    ...     if n == 0:\\n    ...         return z\\n    ...     return z ** tower(z, n-1)\\n    ...\\n    >>> tower(0.5, 100)\\n    0.641185744504986\\n    >>> -lambertw(-np.log(0.5)) / np.log(0.5)\\n    (0.64118574450498589+0j)\\n    '\n    return _lambertw(z, k, tol)",
            "def lambertw(z, k=0, tol=1e-08):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    lambertw(z, k=0, tol=1e-8)\\n\\n    Lambert W function.\\n\\n    The Lambert W function `W(z)` is defined as the inverse function\\n    of ``w * exp(w)``. In other words, the value of ``W(z)`` is\\n    such that ``z = W(z) * exp(W(z))`` for any complex number\\n    ``z``.\\n\\n    The Lambert W function is a multivalued function with infinitely\\n    many branches. Each branch gives a separate solution of the\\n    equation ``z = w exp(w)``. Here, the branches are indexed by the\\n    integer `k`.\\n\\n    Parameters\\n    ----------\\n    z : array_like\\n        Input argument.\\n    k : int, optional\\n        Branch index.\\n    tol : float, optional\\n        Evaluation tolerance.\\n\\n    Returns\\n    -------\\n    w : array\\n        `w` will have the same shape as `z`.\\n\\n    See Also\\n    --------\\n    wrightomega : the Wright Omega function\\n\\n    Notes\\n    -----\\n    All branches are supported by `lambertw`:\\n\\n    * ``lambertw(z)`` gives the principal solution (branch 0)\\n    * ``lambertw(z, k)`` gives the solution on branch `k`\\n\\n    The Lambert W function has two partially real branches: the\\n    principal branch (`k = 0`) is real for real ``z > -1/e``, and the\\n    ``k = -1`` branch is real for ``-1/e < z < 0``. All branches except\\n    ``k = 0`` have a logarithmic singularity at ``z = 0``.\\n\\n    **Possible issues**\\n\\n    The evaluation can become inaccurate very close to the branch point\\n    at ``-1/e``. In some corner cases, `lambertw` might currently\\n    fail to converge, or can end up on the wrong branch.\\n\\n    **Algorithm**\\n\\n    Halley\\'s iteration is used to invert ``w * exp(w)``, using a first-order\\n    asymptotic approximation (O(log(w)) or `O(w)`) as the initial estimate.\\n\\n    The definition, implementation and choice of branches is based on [2]_.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Lambert_W_function\\n    .. [2] Corless et al, \"On the Lambert W function\", Adv. Comp. Math. 5\\n       (1996) 329-359.\\n       https://cs.uwaterloo.ca/research/tr/1993/03/W.pdf\\n\\n    Examples\\n    --------\\n    The Lambert W function is the inverse of ``w exp(w)``:\\n\\n    >>> import numpy as np\\n    >>> from scipy.special import lambertw\\n    >>> w = lambertw(1)\\n    >>> w\\n    (0.56714329040978384+0j)\\n    >>> w * np.exp(w)\\n    (1.0+0j)\\n\\n    Any branch gives a valid inverse:\\n\\n    >>> w = lambertw(1, k=3)\\n    >>> w\\n    (-2.8535817554090377+17.113535539412148j)\\n    >>> w*np.exp(w)\\n    (1.0000000000000002+1.609823385706477e-15j)\\n\\n    **Applications to equation-solving**\\n\\n    The Lambert W function may be used to solve various kinds of\\n    equations.  We give two examples here.\\n\\n    First, the function can be used to solve implicit equations of the\\n    form\\n\\n        :math:`x = a + b e^{c x}`\\n\\n    for :math:`x`.  We assume :math:`c` is not zero.  After a little\\n    algebra, the equation may be written\\n\\n        :math:`z e^z = -b c e^{a c}`\\n\\n    where :math:`z = c (a - x)`.  :math:`z` may then be expressed using\\n    the Lambert W function\\n\\n        :math:`z = W(-b c e^{a c})`\\n\\n    giving\\n\\n        :math:`x = a - W(-b c e^{a c})/c`\\n\\n    For example,\\n\\n    >>> a = 3\\n    >>> b = 2\\n    >>> c = -0.5\\n\\n    The solution to :math:`x = a + b e^{c x}` is:\\n\\n    >>> x = a - lambertw(-b*c*np.exp(a*c))/c\\n    >>> x\\n    (3.3707498368978794+0j)\\n\\n    Verify that it solves the equation:\\n\\n    >>> a + b*np.exp(c*x)\\n    (3.37074983689788+0j)\\n\\n    The Lambert W function may also be used find the value of the infinite\\n    power tower :math:`z^{z^{z^{\\\\ldots}}}`:\\n\\n    >>> def tower(z, n):\\n    ...     if n == 0:\\n    ...         return z\\n    ...     return z ** tower(z, n-1)\\n    ...\\n    >>> tower(0.5, 100)\\n    0.641185744504986\\n    >>> -lambertw(-np.log(0.5)) / np.log(0.5)\\n    (0.64118574450498589+0j)\\n    '\n    return _lambertw(z, k, tol)"
        ]
    }
]