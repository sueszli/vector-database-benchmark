[
    {
        "func_name": "imread",
        "original": "def imread(f):\n    if f.endswith('png'):\n        return imageio.imread(f, format='PNG-PIL', ignoregamma=True)\n    else:\n        return imageio.imread(f)",
        "mutated": [
            "def imread(f):\n    if False:\n        i = 10\n    if f.endswith('png'):\n        return imageio.imread(f, format='PNG-PIL', ignoregamma=True)\n    else:\n        return imageio.imread(f)",
            "def imread(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if f.endswith('png'):\n        return imageio.imread(f, format='PNG-PIL', ignoregamma=True)\n    else:\n        return imageio.imread(f)",
            "def imread(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if f.endswith('png'):\n        return imageio.imread(f, format='PNG-PIL', ignoregamma=True)\n    else:\n        return imageio.imread(f)",
            "def imread(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if f.endswith('png'):\n        return imageio.imread(f, format='PNG-PIL', ignoregamma=True)\n    else:\n        return imageio.imread(f)",
            "def imread(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if f.endswith('png'):\n        return imageio.imread(f, format='PNG-PIL', ignoregamma=True)\n    else:\n        return imageio.imread(f)"
        ]
    },
    {
        "func_name": "depthread",
        "original": "def depthread(path):\n    with open(path, 'rb') as fid:\n        (width, height, channels) = np.genfromtxt(fid, delimiter='&', max_rows=1, usecols=(0, 1, 2), dtype=int)\n        fid.seek(0)\n        num_delimiter = 0\n        byte = fid.read(1)\n        while True:\n            if byte == b'&':\n                num_delimiter += 1\n                if num_delimiter >= 3:\n                    break\n            byte = fid.read(1)\n        array = np.fromfile(fid, np.float32)\n    array = array.reshape((width, height, channels), order='F')\n    return np.transpose(array, (1, 0, 2)).squeeze()",
        "mutated": [
            "def depthread(path):\n    if False:\n        i = 10\n    with open(path, 'rb') as fid:\n        (width, height, channels) = np.genfromtxt(fid, delimiter='&', max_rows=1, usecols=(0, 1, 2), dtype=int)\n        fid.seek(0)\n        num_delimiter = 0\n        byte = fid.read(1)\n        while True:\n            if byte == b'&':\n                num_delimiter += 1\n                if num_delimiter >= 3:\n                    break\n            byte = fid.read(1)\n        array = np.fromfile(fid, np.float32)\n    array = array.reshape((width, height, channels), order='F')\n    return np.transpose(array, (1, 0, 2)).squeeze()",
            "def depthread(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(path, 'rb') as fid:\n        (width, height, channels) = np.genfromtxt(fid, delimiter='&', max_rows=1, usecols=(0, 1, 2), dtype=int)\n        fid.seek(0)\n        num_delimiter = 0\n        byte = fid.read(1)\n        while True:\n            if byte == b'&':\n                num_delimiter += 1\n                if num_delimiter >= 3:\n                    break\n            byte = fid.read(1)\n        array = np.fromfile(fid, np.float32)\n    array = array.reshape((width, height, channels), order='F')\n    return np.transpose(array, (1, 0, 2)).squeeze()",
            "def depthread(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(path, 'rb') as fid:\n        (width, height, channels) = np.genfromtxt(fid, delimiter='&', max_rows=1, usecols=(0, 1, 2), dtype=int)\n        fid.seek(0)\n        num_delimiter = 0\n        byte = fid.read(1)\n        while True:\n            if byte == b'&':\n                num_delimiter += 1\n                if num_delimiter >= 3:\n                    break\n            byte = fid.read(1)\n        array = np.fromfile(fid, np.float32)\n    array = array.reshape((width, height, channels), order='F')\n    return np.transpose(array, (1, 0, 2)).squeeze()",
            "def depthread(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(path, 'rb') as fid:\n        (width, height, channels) = np.genfromtxt(fid, delimiter='&', max_rows=1, usecols=(0, 1, 2), dtype=int)\n        fid.seek(0)\n        num_delimiter = 0\n        byte = fid.read(1)\n        while True:\n            if byte == b'&':\n                num_delimiter += 1\n                if num_delimiter >= 3:\n                    break\n            byte = fid.read(1)\n        array = np.fromfile(fid, np.float32)\n    array = array.reshape((width, height, channels), order='F')\n    return np.transpose(array, (1, 0, 2)).squeeze()",
            "def depthread(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(path, 'rb') as fid:\n        (width, height, channels) = np.genfromtxt(fid, delimiter='&', max_rows=1, usecols=(0, 1, 2), dtype=int)\n        fid.seek(0)\n        num_delimiter = 0\n        byte = fid.read(1)\n        while True:\n            if byte == b'&':\n                num_delimiter += 1\n                if num_delimiter >= 3:\n                    break\n            byte = fid.read(1)\n        array = np.fromfile(fid, np.float32)\n    array = array.reshape((width, height, channels), order='F')\n    return np.transpose(array, (1, 0, 2)).squeeze()"
        ]
    },
    {
        "func_name": "_minify",
        "original": "def _minify(basedir, factors=[], resolutions=[]):\n    needtoload = False\n    for r in factors:\n        imgdir = os.path.join(basedir, 'images_{}'.format(r))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    for r in resolutions:\n        imgdir = os.path.join(basedir, 'images_{}x{}'.format(r[1], r[0]))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    if not needtoload:\n        return\n    from shutil import copy\n    from subprocess import check_output\n    imgdir = os.path.join(basedir, 'images')\n    imgs = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir))]\n    imgs = [f for f in imgs if any([f.endswith(ex) for ex in ['JPG', 'jpg', 'png', 'jpeg', 'PNG']])]\n    imgdir_orig = imgdir\n    wd = os.getcwd()\n    for r in factors + resolutions:\n        if isinstance(r, int):\n            name = 'images_{}'.format(r)\n            resizearg = '{}%'.format(100.0 / r)\n        else:\n            name = 'images_{}x{}'.format(r[1], r[0])\n            resizearg = '{}x{}'.format(r[1], r[0])\n        imgdir = os.path.join(basedir, name)\n        if os.path.exists(imgdir):\n            continue\n        print('Minifying', r, basedir)\n        os.makedirs(imgdir)\n        check_output('cp {}/* {}'.format(imgdir_orig, imgdir), shell=True)\n        ext = imgs[0].split('.')[-1]\n        args = ' '.join(['mogrify', '-resize', resizearg, '-format', 'png', '*.{}'.format(ext)])\n        print(args)\n        os.chdir(imgdir)\n        check_output(args, shell=True)\n        os.chdir(wd)\n        if ext != 'png':\n            check_output('rm {}/*.{}'.format(imgdir, ext), shell=True)\n            print('Removed duplicates')\n        print('Done')",
        "mutated": [
            "def _minify(basedir, factors=[], resolutions=[]):\n    if False:\n        i = 10\n    needtoload = False\n    for r in factors:\n        imgdir = os.path.join(basedir, 'images_{}'.format(r))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    for r in resolutions:\n        imgdir = os.path.join(basedir, 'images_{}x{}'.format(r[1], r[0]))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    if not needtoload:\n        return\n    from shutil import copy\n    from subprocess import check_output\n    imgdir = os.path.join(basedir, 'images')\n    imgs = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir))]\n    imgs = [f for f in imgs if any([f.endswith(ex) for ex in ['JPG', 'jpg', 'png', 'jpeg', 'PNG']])]\n    imgdir_orig = imgdir\n    wd = os.getcwd()\n    for r in factors + resolutions:\n        if isinstance(r, int):\n            name = 'images_{}'.format(r)\n            resizearg = '{}%'.format(100.0 / r)\n        else:\n            name = 'images_{}x{}'.format(r[1], r[0])\n            resizearg = '{}x{}'.format(r[1], r[0])\n        imgdir = os.path.join(basedir, name)\n        if os.path.exists(imgdir):\n            continue\n        print('Minifying', r, basedir)\n        os.makedirs(imgdir)\n        check_output('cp {}/* {}'.format(imgdir_orig, imgdir), shell=True)\n        ext = imgs[0].split('.')[-1]\n        args = ' '.join(['mogrify', '-resize', resizearg, '-format', 'png', '*.{}'.format(ext)])\n        print(args)\n        os.chdir(imgdir)\n        check_output(args, shell=True)\n        os.chdir(wd)\n        if ext != 'png':\n            check_output('rm {}/*.{}'.format(imgdir, ext), shell=True)\n            print('Removed duplicates')\n        print('Done')",
            "def _minify(basedir, factors=[], resolutions=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    needtoload = False\n    for r in factors:\n        imgdir = os.path.join(basedir, 'images_{}'.format(r))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    for r in resolutions:\n        imgdir = os.path.join(basedir, 'images_{}x{}'.format(r[1], r[0]))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    if not needtoload:\n        return\n    from shutil import copy\n    from subprocess import check_output\n    imgdir = os.path.join(basedir, 'images')\n    imgs = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir))]\n    imgs = [f for f in imgs if any([f.endswith(ex) for ex in ['JPG', 'jpg', 'png', 'jpeg', 'PNG']])]\n    imgdir_orig = imgdir\n    wd = os.getcwd()\n    for r in factors + resolutions:\n        if isinstance(r, int):\n            name = 'images_{}'.format(r)\n            resizearg = '{}%'.format(100.0 / r)\n        else:\n            name = 'images_{}x{}'.format(r[1], r[0])\n            resizearg = '{}x{}'.format(r[1], r[0])\n        imgdir = os.path.join(basedir, name)\n        if os.path.exists(imgdir):\n            continue\n        print('Minifying', r, basedir)\n        os.makedirs(imgdir)\n        check_output('cp {}/* {}'.format(imgdir_orig, imgdir), shell=True)\n        ext = imgs[0].split('.')[-1]\n        args = ' '.join(['mogrify', '-resize', resizearg, '-format', 'png', '*.{}'.format(ext)])\n        print(args)\n        os.chdir(imgdir)\n        check_output(args, shell=True)\n        os.chdir(wd)\n        if ext != 'png':\n            check_output('rm {}/*.{}'.format(imgdir, ext), shell=True)\n            print('Removed duplicates')\n        print('Done')",
            "def _minify(basedir, factors=[], resolutions=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    needtoload = False\n    for r in factors:\n        imgdir = os.path.join(basedir, 'images_{}'.format(r))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    for r in resolutions:\n        imgdir = os.path.join(basedir, 'images_{}x{}'.format(r[1], r[0]))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    if not needtoload:\n        return\n    from shutil import copy\n    from subprocess import check_output\n    imgdir = os.path.join(basedir, 'images')\n    imgs = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir))]\n    imgs = [f for f in imgs if any([f.endswith(ex) for ex in ['JPG', 'jpg', 'png', 'jpeg', 'PNG']])]\n    imgdir_orig = imgdir\n    wd = os.getcwd()\n    for r in factors + resolutions:\n        if isinstance(r, int):\n            name = 'images_{}'.format(r)\n            resizearg = '{}%'.format(100.0 / r)\n        else:\n            name = 'images_{}x{}'.format(r[1], r[0])\n            resizearg = '{}x{}'.format(r[1], r[0])\n        imgdir = os.path.join(basedir, name)\n        if os.path.exists(imgdir):\n            continue\n        print('Minifying', r, basedir)\n        os.makedirs(imgdir)\n        check_output('cp {}/* {}'.format(imgdir_orig, imgdir), shell=True)\n        ext = imgs[0].split('.')[-1]\n        args = ' '.join(['mogrify', '-resize', resizearg, '-format', 'png', '*.{}'.format(ext)])\n        print(args)\n        os.chdir(imgdir)\n        check_output(args, shell=True)\n        os.chdir(wd)\n        if ext != 'png':\n            check_output('rm {}/*.{}'.format(imgdir, ext), shell=True)\n            print('Removed duplicates')\n        print('Done')",
            "def _minify(basedir, factors=[], resolutions=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    needtoload = False\n    for r in factors:\n        imgdir = os.path.join(basedir, 'images_{}'.format(r))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    for r in resolutions:\n        imgdir = os.path.join(basedir, 'images_{}x{}'.format(r[1], r[0]))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    if not needtoload:\n        return\n    from shutil import copy\n    from subprocess import check_output\n    imgdir = os.path.join(basedir, 'images')\n    imgs = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir))]\n    imgs = [f for f in imgs if any([f.endswith(ex) for ex in ['JPG', 'jpg', 'png', 'jpeg', 'PNG']])]\n    imgdir_orig = imgdir\n    wd = os.getcwd()\n    for r in factors + resolutions:\n        if isinstance(r, int):\n            name = 'images_{}'.format(r)\n            resizearg = '{}%'.format(100.0 / r)\n        else:\n            name = 'images_{}x{}'.format(r[1], r[0])\n            resizearg = '{}x{}'.format(r[1], r[0])\n        imgdir = os.path.join(basedir, name)\n        if os.path.exists(imgdir):\n            continue\n        print('Minifying', r, basedir)\n        os.makedirs(imgdir)\n        check_output('cp {}/* {}'.format(imgdir_orig, imgdir), shell=True)\n        ext = imgs[0].split('.')[-1]\n        args = ' '.join(['mogrify', '-resize', resizearg, '-format', 'png', '*.{}'.format(ext)])\n        print(args)\n        os.chdir(imgdir)\n        check_output(args, shell=True)\n        os.chdir(wd)\n        if ext != 'png':\n            check_output('rm {}/*.{}'.format(imgdir, ext), shell=True)\n            print('Removed duplicates')\n        print('Done')",
            "def _minify(basedir, factors=[], resolutions=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    needtoload = False\n    for r in factors:\n        imgdir = os.path.join(basedir, 'images_{}'.format(r))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    for r in resolutions:\n        imgdir = os.path.join(basedir, 'images_{}x{}'.format(r[1], r[0]))\n        if not os.path.exists(imgdir):\n            needtoload = True\n    if not needtoload:\n        return\n    from shutil import copy\n    from subprocess import check_output\n    imgdir = os.path.join(basedir, 'images')\n    imgs = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir))]\n    imgs = [f for f in imgs if any([f.endswith(ex) for ex in ['JPG', 'jpg', 'png', 'jpeg', 'PNG']])]\n    imgdir_orig = imgdir\n    wd = os.getcwd()\n    for r in factors + resolutions:\n        if isinstance(r, int):\n            name = 'images_{}'.format(r)\n            resizearg = '{}%'.format(100.0 / r)\n        else:\n            name = 'images_{}x{}'.format(r[1], r[0])\n            resizearg = '{}x{}'.format(r[1], r[0])\n        imgdir = os.path.join(basedir, name)\n        if os.path.exists(imgdir):\n            continue\n        print('Minifying', r, basedir)\n        os.makedirs(imgdir)\n        check_output('cp {}/* {}'.format(imgdir_orig, imgdir), shell=True)\n        ext = imgs[0].split('.')[-1]\n        args = ' '.join(['mogrify', '-resize', resizearg, '-format', 'png', '*.{}'.format(ext)])\n        print(args)\n        os.chdir(imgdir)\n        check_output(args, shell=True)\n        os.chdir(wd)\n        if ext != 'png':\n            check_output('rm {}/*.{}'.format(imgdir, ext), shell=True)\n            print('Removed duplicates')\n        print('Done')"
        ]
    },
    {
        "func_name": "_load_data",
        "original": "def _load_data(basedir, factor=None, width=None, height=None, load_imgs=True, load_depths=False, load_SR=False):\n    poses_arr = np.load(os.path.join(basedir, 'poses_bounds.npy'))\n    if poses_arr.shape[1] == 17:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 5]).transpose([1, 2, 0])\n    elif poses_arr.shape[1] == 14:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 4]).transpose([1, 2, 0])\n    else:\n        raise NotImplementedError\n    bds = poses_arr[:, -2:].transpose([1, 0])\n    img0 = [os.path.join(basedir, 'images', f) for f in sorted(os.listdir(os.path.join(basedir, 'images'))) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')][0]\n    sh = imageio.imread(img0).shape\n    sfx = ''\n    if height is not None and width is not None:\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif factor is not None and factor != 1:\n        sfx = '_{}'.format(factor)\n        _minify(basedir, factors=[factor])\n        factor = factor\n    elif height is not None:\n        factor = sh[0] / float(height)\n        width = int(sh[1] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif width is not None:\n        factor = sh[1] / float(width)\n        height = int(sh[0] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    else:\n        factor = 1\n    imgdir = os.path.join(basedir, 'images' + sfx)\n    print(f'Loading images from {imgdir}')\n    if not os.path.exists(imgdir):\n        print(imgdir, 'does not exist, returning')\n        return\n    imgfiles = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n    if poses.shape[-1] != len(imgfiles):\n        print()\n        print('Mismatch between imgs {} and poses {} !!!!'.format(len(imgfiles), poses.shape[-1]))\n        names = set((name[:-4] for name in np.load(os.path.join(basedir, 'poses_names.npy'))))\n        assert len(names) == poses.shape[-1]\n        print('Below failed files are skip due to SfM failure:')\n        new_imgfiles = []\n        for i in imgfiles:\n            fname = os.path.split(i)[1][:-4]\n            if fname in names:\n                new_imgfiles.append(i)\n            else:\n                print('==>', i)\n        imgfiles = new_imgfiles\n    if len(imgfiles) < 3:\n        print('Too few images...')\n        import sys\n        sys.exit()\n    sh = imageio.imread(imgfiles[0]).shape\n    if poses.shape[1] == 4:\n        poses = np.concatenate([poses, np.zeros_like(poses[:, [0]])], 1)\n        poses[2, 4, :] = np.load(os.path.join(basedir, 'hwf_cxcy.npy'))[2]\n    poses[:2, 4, :] = np.array(sh[:2]).reshape([2, 1])\n    poses[2, 4, :] = poses[2, 4, :] * 1.0 / factor\n    if not load_imgs:\n        return (poses, bds)\n    imgs = [imread(f)[..., :3] / 255.0 for f in imgfiles]\n    imgs = np.stack(imgs, -1)\n    if load_SR:\n        if load_SR == 16:\n            imgdir_sr = os.path.join(basedir, 'images_16')\n        elif load_SR == 8:\n            imgdir_sr = os.path.join(basedir, 'images_8')\n        elif load_SR == 4:\n            imgdir_sr = os.path.join(basedir, 'images_4')\n        elif load_SR == 2:\n            imgdir_sr = os.path.join(basedir, 'images_2')\n        elif load_SR == 1:\n            imgdir_sr = os.path.join(basedir, 'images')\n        imgfiles_sr = [os.path.join(imgdir_sr, f) for f in sorted(os.listdir(imgdir_sr)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n        imgs_sr = [imread(f)[..., :3] / 255.0 for f in imgfiles_sr]\n        imgs_sr = np.stack(imgs_sr, -1)\n    print('Loaded image data', imgs.shape, poses[:, -1, 0])\n    if not load_depths and load_SR:\n        return (poses, bds, imgs, imgs_sr)\n    if not load_depths:\n        return (poses, bds, imgs)\n    depthdir = os.path.join(basedir, 'stereo', 'depth_maps')\n    assert os.path.exists(depthdir), f'Dir not found: {depthdir}'\n    depthfiles = [os.path.join(depthdir, f) for f in sorted(os.listdir(depthdir)) if f.endswith('.geometric.bin')]\n    assert poses.shape[-1] == len(depthfiles), 'Mismatch between imgs {} and poses {} !!!!'.format(len(depthfiles), poses.shape[-1])\n    depths = [depthread(f) for f in depthfiles]\n    depths = np.stack(depths, -1)\n    print('Loaded depth data', depths.shape)\n    return (poses, bds, imgs, depths)",
        "mutated": [
            "def _load_data(basedir, factor=None, width=None, height=None, load_imgs=True, load_depths=False, load_SR=False):\n    if False:\n        i = 10\n    poses_arr = np.load(os.path.join(basedir, 'poses_bounds.npy'))\n    if poses_arr.shape[1] == 17:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 5]).transpose([1, 2, 0])\n    elif poses_arr.shape[1] == 14:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 4]).transpose([1, 2, 0])\n    else:\n        raise NotImplementedError\n    bds = poses_arr[:, -2:].transpose([1, 0])\n    img0 = [os.path.join(basedir, 'images', f) for f in sorted(os.listdir(os.path.join(basedir, 'images'))) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')][0]\n    sh = imageio.imread(img0).shape\n    sfx = ''\n    if height is not None and width is not None:\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif factor is not None and factor != 1:\n        sfx = '_{}'.format(factor)\n        _minify(basedir, factors=[factor])\n        factor = factor\n    elif height is not None:\n        factor = sh[0] / float(height)\n        width = int(sh[1] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif width is not None:\n        factor = sh[1] / float(width)\n        height = int(sh[0] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    else:\n        factor = 1\n    imgdir = os.path.join(basedir, 'images' + sfx)\n    print(f'Loading images from {imgdir}')\n    if not os.path.exists(imgdir):\n        print(imgdir, 'does not exist, returning')\n        return\n    imgfiles = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n    if poses.shape[-1] != len(imgfiles):\n        print()\n        print('Mismatch between imgs {} and poses {} !!!!'.format(len(imgfiles), poses.shape[-1]))\n        names = set((name[:-4] for name in np.load(os.path.join(basedir, 'poses_names.npy'))))\n        assert len(names) == poses.shape[-1]\n        print('Below failed files are skip due to SfM failure:')\n        new_imgfiles = []\n        for i in imgfiles:\n            fname = os.path.split(i)[1][:-4]\n            if fname in names:\n                new_imgfiles.append(i)\n            else:\n                print('==>', i)\n        imgfiles = new_imgfiles\n    if len(imgfiles) < 3:\n        print('Too few images...')\n        import sys\n        sys.exit()\n    sh = imageio.imread(imgfiles[0]).shape\n    if poses.shape[1] == 4:\n        poses = np.concatenate([poses, np.zeros_like(poses[:, [0]])], 1)\n        poses[2, 4, :] = np.load(os.path.join(basedir, 'hwf_cxcy.npy'))[2]\n    poses[:2, 4, :] = np.array(sh[:2]).reshape([2, 1])\n    poses[2, 4, :] = poses[2, 4, :] * 1.0 / factor\n    if not load_imgs:\n        return (poses, bds)\n    imgs = [imread(f)[..., :3] / 255.0 for f in imgfiles]\n    imgs = np.stack(imgs, -1)\n    if load_SR:\n        if load_SR == 16:\n            imgdir_sr = os.path.join(basedir, 'images_16')\n        elif load_SR == 8:\n            imgdir_sr = os.path.join(basedir, 'images_8')\n        elif load_SR == 4:\n            imgdir_sr = os.path.join(basedir, 'images_4')\n        elif load_SR == 2:\n            imgdir_sr = os.path.join(basedir, 'images_2')\n        elif load_SR == 1:\n            imgdir_sr = os.path.join(basedir, 'images')\n        imgfiles_sr = [os.path.join(imgdir_sr, f) for f in sorted(os.listdir(imgdir_sr)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n        imgs_sr = [imread(f)[..., :3] / 255.0 for f in imgfiles_sr]\n        imgs_sr = np.stack(imgs_sr, -1)\n    print('Loaded image data', imgs.shape, poses[:, -1, 0])\n    if not load_depths and load_SR:\n        return (poses, bds, imgs, imgs_sr)\n    if not load_depths:\n        return (poses, bds, imgs)\n    depthdir = os.path.join(basedir, 'stereo', 'depth_maps')\n    assert os.path.exists(depthdir), f'Dir not found: {depthdir}'\n    depthfiles = [os.path.join(depthdir, f) for f in sorted(os.listdir(depthdir)) if f.endswith('.geometric.bin')]\n    assert poses.shape[-1] == len(depthfiles), 'Mismatch between imgs {} and poses {} !!!!'.format(len(depthfiles), poses.shape[-1])\n    depths = [depthread(f) for f in depthfiles]\n    depths = np.stack(depths, -1)\n    print('Loaded depth data', depths.shape)\n    return (poses, bds, imgs, depths)",
            "def _load_data(basedir, factor=None, width=None, height=None, load_imgs=True, load_depths=False, load_SR=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    poses_arr = np.load(os.path.join(basedir, 'poses_bounds.npy'))\n    if poses_arr.shape[1] == 17:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 5]).transpose([1, 2, 0])\n    elif poses_arr.shape[1] == 14:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 4]).transpose([1, 2, 0])\n    else:\n        raise NotImplementedError\n    bds = poses_arr[:, -2:].transpose([1, 0])\n    img0 = [os.path.join(basedir, 'images', f) for f in sorted(os.listdir(os.path.join(basedir, 'images'))) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')][0]\n    sh = imageio.imread(img0).shape\n    sfx = ''\n    if height is not None and width is not None:\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif factor is not None and factor != 1:\n        sfx = '_{}'.format(factor)\n        _minify(basedir, factors=[factor])\n        factor = factor\n    elif height is not None:\n        factor = sh[0] / float(height)\n        width = int(sh[1] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif width is not None:\n        factor = sh[1] / float(width)\n        height = int(sh[0] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    else:\n        factor = 1\n    imgdir = os.path.join(basedir, 'images' + sfx)\n    print(f'Loading images from {imgdir}')\n    if not os.path.exists(imgdir):\n        print(imgdir, 'does not exist, returning')\n        return\n    imgfiles = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n    if poses.shape[-1] != len(imgfiles):\n        print()\n        print('Mismatch between imgs {} and poses {} !!!!'.format(len(imgfiles), poses.shape[-1]))\n        names = set((name[:-4] for name in np.load(os.path.join(basedir, 'poses_names.npy'))))\n        assert len(names) == poses.shape[-1]\n        print('Below failed files are skip due to SfM failure:')\n        new_imgfiles = []\n        for i in imgfiles:\n            fname = os.path.split(i)[1][:-4]\n            if fname in names:\n                new_imgfiles.append(i)\n            else:\n                print('==>', i)\n        imgfiles = new_imgfiles\n    if len(imgfiles) < 3:\n        print('Too few images...')\n        import sys\n        sys.exit()\n    sh = imageio.imread(imgfiles[0]).shape\n    if poses.shape[1] == 4:\n        poses = np.concatenate([poses, np.zeros_like(poses[:, [0]])], 1)\n        poses[2, 4, :] = np.load(os.path.join(basedir, 'hwf_cxcy.npy'))[2]\n    poses[:2, 4, :] = np.array(sh[:2]).reshape([2, 1])\n    poses[2, 4, :] = poses[2, 4, :] * 1.0 / factor\n    if not load_imgs:\n        return (poses, bds)\n    imgs = [imread(f)[..., :3] / 255.0 for f in imgfiles]\n    imgs = np.stack(imgs, -1)\n    if load_SR:\n        if load_SR == 16:\n            imgdir_sr = os.path.join(basedir, 'images_16')\n        elif load_SR == 8:\n            imgdir_sr = os.path.join(basedir, 'images_8')\n        elif load_SR == 4:\n            imgdir_sr = os.path.join(basedir, 'images_4')\n        elif load_SR == 2:\n            imgdir_sr = os.path.join(basedir, 'images_2')\n        elif load_SR == 1:\n            imgdir_sr = os.path.join(basedir, 'images')\n        imgfiles_sr = [os.path.join(imgdir_sr, f) for f in sorted(os.listdir(imgdir_sr)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n        imgs_sr = [imread(f)[..., :3] / 255.0 for f in imgfiles_sr]\n        imgs_sr = np.stack(imgs_sr, -1)\n    print('Loaded image data', imgs.shape, poses[:, -1, 0])\n    if not load_depths and load_SR:\n        return (poses, bds, imgs, imgs_sr)\n    if not load_depths:\n        return (poses, bds, imgs)\n    depthdir = os.path.join(basedir, 'stereo', 'depth_maps')\n    assert os.path.exists(depthdir), f'Dir not found: {depthdir}'\n    depthfiles = [os.path.join(depthdir, f) for f in sorted(os.listdir(depthdir)) if f.endswith('.geometric.bin')]\n    assert poses.shape[-1] == len(depthfiles), 'Mismatch between imgs {} and poses {} !!!!'.format(len(depthfiles), poses.shape[-1])\n    depths = [depthread(f) for f in depthfiles]\n    depths = np.stack(depths, -1)\n    print('Loaded depth data', depths.shape)\n    return (poses, bds, imgs, depths)",
            "def _load_data(basedir, factor=None, width=None, height=None, load_imgs=True, load_depths=False, load_SR=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    poses_arr = np.load(os.path.join(basedir, 'poses_bounds.npy'))\n    if poses_arr.shape[1] == 17:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 5]).transpose([1, 2, 0])\n    elif poses_arr.shape[1] == 14:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 4]).transpose([1, 2, 0])\n    else:\n        raise NotImplementedError\n    bds = poses_arr[:, -2:].transpose([1, 0])\n    img0 = [os.path.join(basedir, 'images', f) for f in sorted(os.listdir(os.path.join(basedir, 'images'))) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')][0]\n    sh = imageio.imread(img0).shape\n    sfx = ''\n    if height is not None and width is not None:\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif factor is not None and factor != 1:\n        sfx = '_{}'.format(factor)\n        _minify(basedir, factors=[factor])\n        factor = factor\n    elif height is not None:\n        factor = sh[0] / float(height)\n        width = int(sh[1] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif width is not None:\n        factor = sh[1] / float(width)\n        height = int(sh[0] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    else:\n        factor = 1\n    imgdir = os.path.join(basedir, 'images' + sfx)\n    print(f'Loading images from {imgdir}')\n    if not os.path.exists(imgdir):\n        print(imgdir, 'does not exist, returning')\n        return\n    imgfiles = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n    if poses.shape[-1] != len(imgfiles):\n        print()\n        print('Mismatch between imgs {} and poses {} !!!!'.format(len(imgfiles), poses.shape[-1]))\n        names = set((name[:-4] for name in np.load(os.path.join(basedir, 'poses_names.npy'))))\n        assert len(names) == poses.shape[-1]\n        print('Below failed files are skip due to SfM failure:')\n        new_imgfiles = []\n        for i in imgfiles:\n            fname = os.path.split(i)[1][:-4]\n            if fname in names:\n                new_imgfiles.append(i)\n            else:\n                print('==>', i)\n        imgfiles = new_imgfiles\n    if len(imgfiles) < 3:\n        print('Too few images...')\n        import sys\n        sys.exit()\n    sh = imageio.imread(imgfiles[0]).shape\n    if poses.shape[1] == 4:\n        poses = np.concatenate([poses, np.zeros_like(poses[:, [0]])], 1)\n        poses[2, 4, :] = np.load(os.path.join(basedir, 'hwf_cxcy.npy'))[2]\n    poses[:2, 4, :] = np.array(sh[:2]).reshape([2, 1])\n    poses[2, 4, :] = poses[2, 4, :] * 1.0 / factor\n    if not load_imgs:\n        return (poses, bds)\n    imgs = [imread(f)[..., :3] / 255.0 for f in imgfiles]\n    imgs = np.stack(imgs, -1)\n    if load_SR:\n        if load_SR == 16:\n            imgdir_sr = os.path.join(basedir, 'images_16')\n        elif load_SR == 8:\n            imgdir_sr = os.path.join(basedir, 'images_8')\n        elif load_SR == 4:\n            imgdir_sr = os.path.join(basedir, 'images_4')\n        elif load_SR == 2:\n            imgdir_sr = os.path.join(basedir, 'images_2')\n        elif load_SR == 1:\n            imgdir_sr = os.path.join(basedir, 'images')\n        imgfiles_sr = [os.path.join(imgdir_sr, f) for f in sorted(os.listdir(imgdir_sr)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n        imgs_sr = [imread(f)[..., :3] / 255.0 for f in imgfiles_sr]\n        imgs_sr = np.stack(imgs_sr, -1)\n    print('Loaded image data', imgs.shape, poses[:, -1, 0])\n    if not load_depths and load_SR:\n        return (poses, bds, imgs, imgs_sr)\n    if not load_depths:\n        return (poses, bds, imgs)\n    depthdir = os.path.join(basedir, 'stereo', 'depth_maps')\n    assert os.path.exists(depthdir), f'Dir not found: {depthdir}'\n    depthfiles = [os.path.join(depthdir, f) for f in sorted(os.listdir(depthdir)) if f.endswith('.geometric.bin')]\n    assert poses.shape[-1] == len(depthfiles), 'Mismatch between imgs {} and poses {} !!!!'.format(len(depthfiles), poses.shape[-1])\n    depths = [depthread(f) for f in depthfiles]\n    depths = np.stack(depths, -1)\n    print('Loaded depth data', depths.shape)\n    return (poses, bds, imgs, depths)",
            "def _load_data(basedir, factor=None, width=None, height=None, load_imgs=True, load_depths=False, load_SR=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    poses_arr = np.load(os.path.join(basedir, 'poses_bounds.npy'))\n    if poses_arr.shape[1] == 17:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 5]).transpose([1, 2, 0])\n    elif poses_arr.shape[1] == 14:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 4]).transpose([1, 2, 0])\n    else:\n        raise NotImplementedError\n    bds = poses_arr[:, -2:].transpose([1, 0])\n    img0 = [os.path.join(basedir, 'images', f) for f in sorted(os.listdir(os.path.join(basedir, 'images'))) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')][0]\n    sh = imageio.imread(img0).shape\n    sfx = ''\n    if height is not None and width is not None:\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif factor is not None and factor != 1:\n        sfx = '_{}'.format(factor)\n        _minify(basedir, factors=[factor])\n        factor = factor\n    elif height is not None:\n        factor = sh[0] / float(height)\n        width = int(sh[1] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif width is not None:\n        factor = sh[1] / float(width)\n        height = int(sh[0] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    else:\n        factor = 1\n    imgdir = os.path.join(basedir, 'images' + sfx)\n    print(f'Loading images from {imgdir}')\n    if not os.path.exists(imgdir):\n        print(imgdir, 'does not exist, returning')\n        return\n    imgfiles = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n    if poses.shape[-1] != len(imgfiles):\n        print()\n        print('Mismatch between imgs {} and poses {} !!!!'.format(len(imgfiles), poses.shape[-1]))\n        names = set((name[:-4] for name in np.load(os.path.join(basedir, 'poses_names.npy'))))\n        assert len(names) == poses.shape[-1]\n        print('Below failed files are skip due to SfM failure:')\n        new_imgfiles = []\n        for i in imgfiles:\n            fname = os.path.split(i)[1][:-4]\n            if fname in names:\n                new_imgfiles.append(i)\n            else:\n                print('==>', i)\n        imgfiles = new_imgfiles\n    if len(imgfiles) < 3:\n        print('Too few images...')\n        import sys\n        sys.exit()\n    sh = imageio.imread(imgfiles[0]).shape\n    if poses.shape[1] == 4:\n        poses = np.concatenate([poses, np.zeros_like(poses[:, [0]])], 1)\n        poses[2, 4, :] = np.load(os.path.join(basedir, 'hwf_cxcy.npy'))[2]\n    poses[:2, 4, :] = np.array(sh[:2]).reshape([2, 1])\n    poses[2, 4, :] = poses[2, 4, :] * 1.0 / factor\n    if not load_imgs:\n        return (poses, bds)\n    imgs = [imread(f)[..., :3] / 255.0 for f in imgfiles]\n    imgs = np.stack(imgs, -1)\n    if load_SR:\n        if load_SR == 16:\n            imgdir_sr = os.path.join(basedir, 'images_16')\n        elif load_SR == 8:\n            imgdir_sr = os.path.join(basedir, 'images_8')\n        elif load_SR == 4:\n            imgdir_sr = os.path.join(basedir, 'images_4')\n        elif load_SR == 2:\n            imgdir_sr = os.path.join(basedir, 'images_2')\n        elif load_SR == 1:\n            imgdir_sr = os.path.join(basedir, 'images')\n        imgfiles_sr = [os.path.join(imgdir_sr, f) for f in sorted(os.listdir(imgdir_sr)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n        imgs_sr = [imread(f)[..., :3] / 255.0 for f in imgfiles_sr]\n        imgs_sr = np.stack(imgs_sr, -1)\n    print('Loaded image data', imgs.shape, poses[:, -1, 0])\n    if not load_depths and load_SR:\n        return (poses, bds, imgs, imgs_sr)\n    if not load_depths:\n        return (poses, bds, imgs)\n    depthdir = os.path.join(basedir, 'stereo', 'depth_maps')\n    assert os.path.exists(depthdir), f'Dir not found: {depthdir}'\n    depthfiles = [os.path.join(depthdir, f) for f in sorted(os.listdir(depthdir)) if f.endswith('.geometric.bin')]\n    assert poses.shape[-1] == len(depthfiles), 'Mismatch between imgs {} and poses {} !!!!'.format(len(depthfiles), poses.shape[-1])\n    depths = [depthread(f) for f in depthfiles]\n    depths = np.stack(depths, -1)\n    print('Loaded depth data', depths.shape)\n    return (poses, bds, imgs, depths)",
            "def _load_data(basedir, factor=None, width=None, height=None, load_imgs=True, load_depths=False, load_SR=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    poses_arr = np.load(os.path.join(basedir, 'poses_bounds.npy'))\n    if poses_arr.shape[1] == 17:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 5]).transpose([1, 2, 0])\n    elif poses_arr.shape[1] == 14:\n        poses = poses_arr[:, :-2].reshape([-1, 3, 4]).transpose([1, 2, 0])\n    else:\n        raise NotImplementedError\n    bds = poses_arr[:, -2:].transpose([1, 0])\n    img0 = [os.path.join(basedir, 'images', f) for f in sorted(os.listdir(os.path.join(basedir, 'images'))) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')][0]\n    sh = imageio.imread(img0).shape\n    sfx = ''\n    if height is not None and width is not None:\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif factor is not None and factor != 1:\n        sfx = '_{}'.format(factor)\n        _minify(basedir, factors=[factor])\n        factor = factor\n    elif height is not None:\n        factor = sh[0] / float(height)\n        width = int(sh[1] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    elif width is not None:\n        factor = sh[1] / float(width)\n        height = int(sh[0] / factor)\n        _minify(basedir, resolutions=[[height, width]])\n        sfx = '_{}x{}'.format(width, height)\n    else:\n        factor = 1\n    imgdir = os.path.join(basedir, 'images' + sfx)\n    print(f'Loading images from {imgdir}')\n    if not os.path.exists(imgdir):\n        print(imgdir, 'does not exist, returning')\n        return\n    imgfiles = [os.path.join(imgdir, f) for f in sorted(os.listdir(imgdir)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n    if poses.shape[-1] != len(imgfiles):\n        print()\n        print('Mismatch between imgs {} and poses {} !!!!'.format(len(imgfiles), poses.shape[-1]))\n        names = set((name[:-4] for name in np.load(os.path.join(basedir, 'poses_names.npy'))))\n        assert len(names) == poses.shape[-1]\n        print('Below failed files are skip due to SfM failure:')\n        new_imgfiles = []\n        for i in imgfiles:\n            fname = os.path.split(i)[1][:-4]\n            if fname in names:\n                new_imgfiles.append(i)\n            else:\n                print('==>', i)\n        imgfiles = new_imgfiles\n    if len(imgfiles) < 3:\n        print('Too few images...')\n        import sys\n        sys.exit()\n    sh = imageio.imread(imgfiles[0]).shape\n    if poses.shape[1] == 4:\n        poses = np.concatenate([poses, np.zeros_like(poses[:, [0]])], 1)\n        poses[2, 4, :] = np.load(os.path.join(basedir, 'hwf_cxcy.npy'))[2]\n    poses[:2, 4, :] = np.array(sh[:2]).reshape([2, 1])\n    poses[2, 4, :] = poses[2, 4, :] * 1.0 / factor\n    if not load_imgs:\n        return (poses, bds)\n    imgs = [imread(f)[..., :3] / 255.0 for f in imgfiles]\n    imgs = np.stack(imgs, -1)\n    if load_SR:\n        if load_SR == 16:\n            imgdir_sr = os.path.join(basedir, 'images_16')\n        elif load_SR == 8:\n            imgdir_sr = os.path.join(basedir, 'images_8')\n        elif load_SR == 4:\n            imgdir_sr = os.path.join(basedir, 'images_4')\n        elif load_SR == 2:\n            imgdir_sr = os.path.join(basedir, 'images_2')\n        elif load_SR == 1:\n            imgdir_sr = os.path.join(basedir, 'images')\n        imgfiles_sr = [os.path.join(imgdir_sr, f) for f in sorted(os.listdir(imgdir_sr)) if f.endswith('JPG') or f.endswith('jpg') or f.endswith('png')]\n        imgs_sr = [imread(f)[..., :3] / 255.0 for f in imgfiles_sr]\n        imgs_sr = np.stack(imgs_sr, -1)\n    print('Loaded image data', imgs.shape, poses[:, -1, 0])\n    if not load_depths and load_SR:\n        return (poses, bds, imgs, imgs_sr)\n    if not load_depths:\n        return (poses, bds, imgs)\n    depthdir = os.path.join(basedir, 'stereo', 'depth_maps')\n    assert os.path.exists(depthdir), f'Dir not found: {depthdir}'\n    depthfiles = [os.path.join(depthdir, f) for f in sorted(os.listdir(depthdir)) if f.endswith('.geometric.bin')]\n    assert poses.shape[-1] == len(depthfiles), 'Mismatch between imgs {} and poses {} !!!!'.format(len(depthfiles), poses.shape[-1])\n    depths = [depthread(f) for f in depthfiles]\n    depths = np.stack(depths, -1)\n    print('Loaded depth data', depths.shape)\n    return (poses, bds, imgs, depths)"
        ]
    },
    {
        "func_name": "normalize",
        "original": "def normalize(x):\n    return x / np.linalg.norm(x)",
        "mutated": [
            "def normalize(x):\n    if False:\n        i = 10\n    return x / np.linalg.norm(x)",
            "def normalize(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return x / np.linalg.norm(x)",
            "def normalize(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return x / np.linalg.norm(x)",
            "def normalize(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return x / np.linalg.norm(x)",
            "def normalize(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return x / np.linalg.norm(x)"
        ]
    },
    {
        "func_name": "viewmatrix",
        "original": "def viewmatrix(z, up, pos):\n    vec2 = normalize(z)\n    vec1_avg = up\n    vec0 = normalize(np.cross(vec1_avg, vec2))\n    vec1 = normalize(np.cross(vec2, vec0))\n    m = np.stack([vec0, vec1, vec2, pos], 1)\n    return m",
        "mutated": [
            "def viewmatrix(z, up, pos):\n    if False:\n        i = 10\n    vec2 = normalize(z)\n    vec1_avg = up\n    vec0 = normalize(np.cross(vec1_avg, vec2))\n    vec1 = normalize(np.cross(vec2, vec0))\n    m = np.stack([vec0, vec1, vec2, pos], 1)\n    return m",
            "def viewmatrix(z, up, pos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    vec2 = normalize(z)\n    vec1_avg = up\n    vec0 = normalize(np.cross(vec1_avg, vec2))\n    vec1 = normalize(np.cross(vec2, vec0))\n    m = np.stack([vec0, vec1, vec2, pos], 1)\n    return m",
            "def viewmatrix(z, up, pos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    vec2 = normalize(z)\n    vec1_avg = up\n    vec0 = normalize(np.cross(vec1_avg, vec2))\n    vec1 = normalize(np.cross(vec2, vec0))\n    m = np.stack([vec0, vec1, vec2, pos], 1)\n    return m",
            "def viewmatrix(z, up, pos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    vec2 = normalize(z)\n    vec1_avg = up\n    vec0 = normalize(np.cross(vec1_avg, vec2))\n    vec1 = normalize(np.cross(vec2, vec0))\n    m = np.stack([vec0, vec1, vec2, pos], 1)\n    return m",
            "def viewmatrix(z, up, pos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    vec2 = normalize(z)\n    vec1_avg = up\n    vec0 = normalize(np.cross(vec1_avg, vec2))\n    vec1 = normalize(np.cross(vec2, vec0))\n    m = np.stack([vec0, vec1, vec2, pos], 1)\n    return m"
        ]
    },
    {
        "func_name": "ptstocam",
        "original": "def ptstocam(pts, c2w):\n    tt = np.matmul(c2w[:3, :3].T, (pts - c2w[:3, 3])[..., np.newaxis])[..., 0]\n    return tt",
        "mutated": [
            "def ptstocam(pts, c2w):\n    if False:\n        i = 10\n    tt = np.matmul(c2w[:3, :3].T, (pts - c2w[:3, 3])[..., np.newaxis])[..., 0]\n    return tt",
            "def ptstocam(pts, c2w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tt = np.matmul(c2w[:3, :3].T, (pts - c2w[:3, 3])[..., np.newaxis])[..., 0]\n    return tt",
            "def ptstocam(pts, c2w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tt = np.matmul(c2w[:3, :3].T, (pts - c2w[:3, 3])[..., np.newaxis])[..., 0]\n    return tt",
            "def ptstocam(pts, c2w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tt = np.matmul(c2w[:3, :3].T, (pts - c2w[:3, 3])[..., np.newaxis])[..., 0]\n    return tt",
            "def ptstocam(pts, c2w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tt = np.matmul(c2w[:3, :3].T, (pts - c2w[:3, 3])[..., np.newaxis])[..., 0]\n    return tt"
        ]
    },
    {
        "func_name": "poses_avg",
        "original": "def poses_avg(poses):\n    hwf = poses[0, :3, -1:]\n    center = poses[:, :3, 3].mean(0)\n    vec2 = normalize(poses[:, :3, 2].sum(0))\n    up = poses[:, :3, 1].sum(0)\n    c2w = np.concatenate([viewmatrix(vec2, up, center), hwf], 1)\n    return c2w",
        "mutated": [
            "def poses_avg(poses):\n    if False:\n        i = 10\n    hwf = poses[0, :3, -1:]\n    center = poses[:, :3, 3].mean(0)\n    vec2 = normalize(poses[:, :3, 2].sum(0))\n    up = poses[:, :3, 1].sum(0)\n    c2w = np.concatenate([viewmatrix(vec2, up, center), hwf], 1)\n    return c2w",
            "def poses_avg(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    hwf = poses[0, :3, -1:]\n    center = poses[:, :3, 3].mean(0)\n    vec2 = normalize(poses[:, :3, 2].sum(0))\n    up = poses[:, :3, 1].sum(0)\n    c2w = np.concatenate([viewmatrix(vec2, up, center), hwf], 1)\n    return c2w",
            "def poses_avg(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    hwf = poses[0, :3, -1:]\n    center = poses[:, :3, 3].mean(0)\n    vec2 = normalize(poses[:, :3, 2].sum(0))\n    up = poses[:, :3, 1].sum(0)\n    c2w = np.concatenate([viewmatrix(vec2, up, center), hwf], 1)\n    return c2w",
            "def poses_avg(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    hwf = poses[0, :3, -1:]\n    center = poses[:, :3, 3].mean(0)\n    vec2 = normalize(poses[:, :3, 2].sum(0))\n    up = poses[:, :3, 1].sum(0)\n    c2w = np.concatenate([viewmatrix(vec2, up, center), hwf], 1)\n    return c2w",
            "def poses_avg(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    hwf = poses[0, :3, -1:]\n    center = poses[:, :3, 3].mean(0)\n    vec2 = normalize(poses[:, :3, 2].sum(0))\n    up = poses[:, :3, 1].sum(0)\n    c2w = np.concatenate([viewmatrix(vec2, up, center), hwf], 1)\n    return c2w"
        ]
    },
    {
        "func_name": "w2c_gen",
        "original": "def w2c_gen(poses):\n    final_pose = []\n    for idx in range(len(poses)):\n        pose = poses[idx, ...]\n        z = normalize(pose[:3, 2])\n        up = pose[:3, 1]\n        vec2 = normalize(z)\n        vec0 = normalize(np.cross(up, vec2))\n        vec1 = normalize(np.cross(vec2, vec0))\n        m = np.stack([vec0, vec1, vec2], 1)\n        mt = np.linalg.inv(m)\n        final_pose.append(mt)\n    final_pose = np.stack(final_pose, 0)\n    return final_pose",
        "mutated": [
            "def w2c_gen(poses):\n    if False:\n        i = 10\n    final_pose = []\n    for idx in range(len(poses)):\n        pose = poses[idx, ...]\n        z = normalize(pose[:3, 2])\n        up = pose[:3, 1]\n        vec2 = normalize(z)\n        vec0 = normalize(np.cross(up, vec2))\n        vec1 = normalize(np.cross(vec2, vec0))\n        m = np.stack([vec0, vec1, vec2], 1)\n        mt = np.linalg.inv(m)\n        final_pose.append(mt)\n    final_pose = np.stack(final_pose, 0)\n    return final_pose",
            "def w2c_gen(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    final_pose = []\n    for idx in range(len(poses)):\n        pose = poses[idx, ...]\n        z = normalize(pose[:3, 2])\n        up = pose[:3, 1]\n        vec2 = normalize(z)\n        vec0 = normalize(np.cross(up, vec2))\n        vec1 = normalize(np.cross(vec2, vec0))\n        m = np.stack([vec0, vec1, vec2], 1)\n        mt = np.linalg.inv(m)\n        final_pose.append(mt)\n    final_pose = np.stack(final_pose, 0)\n    return final_pose",
            "def w2c_gen(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    final_pose = []\n    for idx in range(len(poses)):\n        pose = poses[idx, ...]\n        z = normalize(pose[:3, 2])\n        up = pose[:3, 1]\n        vec2 = normalize(z)\n        vec0 = normalize(np.cross(up, vec2))\n        vec1 = normalize(np.cross(vec2, vec0))\n        m = np.stack([vec0, vec1, vec2], 1)\n        mt = np.linalg.inv(m)\n        final_pose.append(mt)\n    final_pose = np.stack(final_pose, 0)\n    return final_pose",
            "def w2c_gen(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    final_pose = []\n    for idx in range(len(poses)):\n        pose = poses[idx, ...]\n        z = normalize(pose[:3, 2])\n        up = pose[:3, 1]\n        vec2 = normalize(z)\n        vec0 = normalize(np.cross(up, vec2))\n        vec1 = normalize(np.cross(vec2, vec0))\n        m = np.stack([vec0, vec1, vec2], 1)\n        mt = np.linalg.inv(m)\n        final_pose.append(mt)\n    final_pose = np.stack(final_pose, 0)\n    return final_pose",
            "def w2c_gen(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    final_pose = []\n    for idx in range(len(poses)):\n        pose = poses[idx, ...]\n        z = normalize(pose[:3, 2])\n        up = pose[:3, 1]\n        vec2 = normalize(z)\n        vec0 = normalize(np.cross(up, vec2))\n        vec1 = normalize(np.cross(vec2, vec0))\n        m = np.stack([vec0, vec1, vec2], 1)\n        mt = np.linalg.inv(m)\n        final_pose.append(mt)\n    final_pose = np.stack(final_pose, 0)\n    return final_pose"
        ]
    },
    {
        "func_name": "render_path_spiral",
        "original": "def render_path_spiral(c2w, up, rads, focal, zdelta, zrate, rots, N):\n    render_poses = []\n    rads = np.array(list(rads) + [1.0])\n    hwf = c2w[:, 4:5]\n    for theta in np.linspace(0.0, 2 * np.pi * rots, N + 1)[:-1]:\n        c = np.dot(c2w[:3, :4], np.array([np.cos(theta), -np.sin(theta), -np.sin(theta * zrate) * zdelta, 1.0]) * rads)\n        z = normalize(c - np.dot(c2w[:3, :4], np.array([0, 0, -focal, 1.0])))\n        render_poses.append(np.concatenate([viewmatrix(z, up, c), hwf], 1))\n    return render_poses",
        "mutated": [
            "def render_path_spiral(c2w, up, rads, focal, zdelta, zrate, rots, N):\n    if False:\n        i = 10\n    render_poses = []\n    rads = np.array(list(rads) + [1.0])\n    hwf = c2w[:, 4:5]\n    for theta in np.linspace(0.0, 2 * np.pi * rots, N + 1)[:-1]:\n        c = np.dot(c2w[:3, :4], np.array([np.cos(theta), -np.sin(theta), -np.sin(theta * zrate) * zdelta, 1.0]) * rads)\n        z = normalize(c - np.dot(c2w[:3, :4], np.array([0, 0, -focal, 1.0])))\n        render_poses.append(np.concatenate([viewmatrix(z, up, c), hwf], 1))\n    return render_poses",
            "def render_path_spiral(c2w, up, rads, focal, zdelta, zrate, rots, N):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    render_poses = []\n    rads = np.array(list(rads) + [1.0])\n    hwf = c2w[:, 4:5]\n    for theta in np.linspace(0.0, 2 * np.pi * rots, N + 1)[:-1]:\n        c = np.dot(c2w[:3, :4], np.array([np.cos(theta), -np.sin(theta), -np.sin(theta * zrate) * zdelta, 1.0]) * rads)\n        z = normalize(c - np.dot(c2w[:3, :4], np.array([0, 0, -focal, 1.0])))\n        render_poses.append(np.concatenate([viewmatrix(z, up, c), hwf], 1))\n    return render_poses",
            "def render_path_spiral(c2w, up, rads, focal, zdelta, zrate, rots, N):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    render_poses = []\n    rads = np.array(list(rads) + [1.0])\n    hwf = c2w[:, 4:5]\n    for theta in np.linspace(0.0, 2 * np.pi * rots, N + 1)[:-1]:\n        c = np.dot(c2w[:3, :4], np.array([np.cos(theta), -np.sin(theta), -np.sin(theta * zrate) * zdelta, 1.0]) * rads)\n        z = normalize(c - np.dot(c2w[:3, :4], np.array([0, 0, -focal, 1.0])))\n        render_poses.append(np.concatenate([viewmatrix(z, up, c), hwf], 1))\n    return render_poses",
            "def render_path_spiral(c2w, up, rads, focal, zdelta, zrate, rots, N):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    render_poses = []\n    rads = np.array(list(rads) + [1.0])\n    hwf = c2w[:, 4:5]\n    for theta in np.linspace(0.0, 2 * np.pi * rots, N + 1)[:-1]:\n        c = np.dot(c2w[:3, :4], np.array([np.cos(theta), -np.sin(theta), -np.sin(theta * zrate) * zdelta, 1.0]) * rads)\n        z = normalize(c - np.dot(c2w[:3, :4], np.array([0, 0, -focal, 1.0])))\n        render_poses.append(np.concatenate([viewmatrix(z, up, c), hwf], 1))\n    return render_poses",
            "def render_path_spiral(c2w, up, rads, focal, zdelta, zrate, rots, N):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    render_poses = []\n    rads = np.array(list(rads) + [1.0])\n    hwf = c2w[:, 4:5]\n    for theta in np.linspace(0.0, 2 * np.pi * rots, N + 1)[:-1]:\n        c = np.dot(c2w[:3, :4], np.array([np.cos(theta), -np.sin(theta), -np.sin(theta * zrate) * zdelta, 1.0]) * rads)\n        z = normalize(c - np.dot(c2w[:3, :4], np.array([0, 0, -focal, 1.0])))\n        render_poses.append(np.concatenate([viewmatrix(z, up, c), hwf], 1))\n    return render_poses"
        ]
    },
    {
        "func_name": "recenter_poses",
        "original": "def recenter_poses(poses):\n    poses_ = poses + 0\n    bottom = np.reshape([0, 0, 0, 1.0], [1, 4])\n    c2w = poses_avg(poses)\n    c2w = np.concatenate([c2w[:3, :4], bottom], -2)\n    bottom = np.tile(np.reshape(bottom, [1, 1, 4]), [poses.shape[0], 1, 1])\n    poses = np.concatenate([poses[:, :3, :4], bottom], -2)\n    poses = np.linalg.inv(c2w) @ poses\n    poses_[:, :3, :4] = poses[:, :3, :4]\n    poses = poses_\n    return poses",
        "mutated": [
            "def recenter_poses(poses):\n    if False:\n        i = 10\n    poses_ = poses + 0\n    bottom = np.reshape([0, 0, 0, 1.0], [1, 4])\n    c2w = poses_avg(poses)\n    c2w = np.concatenate([c2w[:3, :4], bottom], -2)\n    bottom = np.tile(np.reshape(bottom, [1, 1, 4]), [poses.shape[0], 1, 1])\n    poses = np.concatenate([poses[:, :3, :4], bottom], -2)\n    poses = np.linalg.inv(c2w) @ poses\n    poses_[:, :3, :4] = poses[:, :3, :4]\n    poses = poses_\n    return poses",
            "def recenter_poses(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    poses_ = poses + 0\n    bottom = np.reshape([0, 0, 0, 1.0], [1, 4])\n    c2w = poses_avg(poses)\n    c2w = np.concatenate([c2w[:3, :4], bottom], -2)\n    bottom = np.tile(np.reshape(bottom, [1, 1, 4]), [poses.shape[0], 1, 1])\n    poses = np.concatenate([poses[:, :3, :4], bottom], -2)\n    poses = np.linalg.inv(c2w) @ poses\n    poses_[:, :3, :4] = poses[:, :3, :4]\n    poses = poses_\n    return poses",
            "def recenter_poses(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    poses_ = poses + 0\n    bottom = np.reshape([0, 0, 0, 1.0], [1, 4])\n    c2w = poses_avg(poses)\n    c2w = np.concatenate([c2w[:3, :4], bottom], -2)\n    bottom = np.tile(np.reshape(bottom, [1, 1, 4]), [poses.shape[0], 1, 1])\n    poses = np.concatenate([poses[:, :3, :4], bottom], -2)\n    poses = np.linalg.inv(c2w) @ poses\n    poses_[:, :3, :4] = poses[:, :3, :4]\n    poses = poses_\n    return poses",
            "def recenter_poses(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    poses_ = poses + 0\n    bottom = np.reshape([0, 0, 0, 1.0], [1, 4])\n    c2w = poses_avg(poses)\n    c2w = np.concatenate([c2w[:3, :4], bottom], -2)\n    bottom = np.tile(np.reshape(bottom, [1, 1, 4]), [poses.shape[0], 1, 1])\n    poses = np.concatenate([poses[:, :3, :4], bottom], -2)\n    poses = np.linalg.inv(c2w) @ poses\n    poses_[:, :3, :4] = poses[:, :3, :4]\n    poses = poses_\n    return poses",
            "def recenter_poses(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    poses_ = poses + 0\n    bottom = np.reshape([0, 0, 0, 1.0], [1, 4])\n    c2w = poses_avg(poses)\n    c2w = np.concatenate([c2w[:3, :4], bottom], -2)\n    bottom = np.tile(np.reshape(bottom, [1, 1, 4]), [poses.shape[0], 1, 1])\n    poses = np.concatenate([poses[:, :3, :4], bottom], -2)\n    poses = np.linalg.inv(c2w) @ poses\n    poses_[:, :3, :4] = poses[:, :3, :4]\n    poses = poses_\n    return poses"
        ]
    },
    {
        "func_name": "rerotate_poses",
        "original": "def rerotate_poses(poses):\n    poses = np.copy(poses)\n    centroid = poses[:, :3, 3].mean(0)\n    poses[:, :3, 3] = poses[:, :3, 3] - centroid\n    x = poses[:, :, 3]\n    mu = x.mean(0)\n    cov = np.cov((x - mu).T)\n    (ev, eig) = np.linalg.eig(cov)\n    cams_up = eig[:, np.argmin(ev)]\n    if cams_up[1] < 0:\n        cams_up = -cams_up\n    R = scipy.spatial.transform.Rotation.align_vectors([[0, 1, 0]], cams_up[None])[0].as_matrix()\n    poses[:, :3, :3] = R @ poses[:, :3, :3]\n    poses[:, :3, [3]] = R @ poses[:, :3, [3]]\n    poses[:, :3, 3] = poses[:, :3, 3] + centroid\n    return poses",
        "mutated": [
            "def rerotate_poses(poses):\n    if False:\n        i = 10\n    poses = np.copy(poses)\n    centroid = poses[:, :3, 3].mean(0)\n    poses[:, :3, 3] = poses[:, :3, 3] - centroid\n    x = poses[:, :, 3]\n    mu = x.mean(0)\n    cov = np.cov((x - mu).T)\n    (ev, eig) = np.linalg.eig(cov)\n    cams_up = eig[:, np.argmin(ev)]\n    if cams_up[1] < 0:\n        cams_up = -cams_up\n    R = scipy.spatial.transform.Rotation.align_vectors([[0, 1, 0]], cams_up[None])[0].as_matrix()\n    poses[:, :3, :3] = R @ poses[:, :3, :3]\n    poses[:, :3, [3]] = R @ poses[:, :3, [3]]\n    poses[:, :3, 3] = poses[:, :3, 3] + centroid\n    return poses",
            "def rerotate_poses(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    poses = np.copy(poses)\n    centroid = poses[:, :3, 3].mean(0)\n    poses[:, :3, 3] = poses[:, :3, 3] - centroid\n    x = poses[:, :, 3]\n    mu = x.mean(0)\n    cov = np.cov((x - mu).T)\n    (ev, eig) = np.linalg.eig(cov)\n    cams_up = eig[:, np.argmin(ev)]\n    if cams_up[1] < 0:\n        cams_up = -cams_up\n    R = scipy.spatial.transform.Rotation.align_vectors([[0, 1, 0]], cams_up[None])[0].as_matrix()\n    poses[:, :3, :3] = R @ poses[:, :3, :3]\n    poses[:, :3, [3]] = R @ poses[:, :3, [3]]\n    poses[:, :3, 3] = poses[:, :3, 3] + centroid\n    return poses",
            "def rerotate_poses(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    poses = np.copy(poses)\n    centroid = poses[:, :3, 3].mean(0)\n    poses[:, :3, 3] = poses[:, :3, 3] - centroid\n    x = poses[:, :, 3]\n    mu = x.mean(0)\n    cov = np.cov((x - mu).T)\n    (ev, eig) = np.linalg.eig(cov)\n    cams_up = eig[:, np.argmin(ev)]\n    if cams_up[1] < 0:\n        cams_up = -cams_up\n    R = scipy.spatial.transform.Rotation.align_vectors([[0, 1, 0]], cams_up[None])[0].as_matrix()\n    poses[:, :3, :3] = R @ poses[:, :3, :3]\n    poses[:, :3, [3]] = R @ poses[:, :3, [3]]\n    poses[:, :3, 3] = poses[:, :3, 3] + centroid\n    return poses",
            "def rerotate_poses(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    poses = np.copy(poses)\n    centroid = poses[:, :3, 3].mean(0)\n    poses[:, :3, 3] = poses[:, :3, 3] - centroid\n    x = poses[:, :, 3]\n    mu = x.mean(0)\n    cov = np.cov((x - mu).T)\n    (ev, eig) = np.linalg.eig(cov)\n    cams_up = eig[:, np.argmin(ev)]\n    if cams_up[1] < 0:\n        cams_up = -cams_up\n    R = scipy.spatial.transform.Rotation.align_vectors([[0, 1, 0]], cams_up[None])[0].as_matrix()\n    poses[:, :3, :3] = R @ poses[:, :3, :3]\n    poses[:, :3, [3]] = R @ poses[:, :3, [3]]\n    poses[:, :3, 3] = poses[:, :3, 3] + centroid\n    return poses",
            "def rerotate_poses(poses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    poses = np.copy(poses)\n    centroid = poses[:, :3, 3].mean(0)\n    poses[:, :3, 3] = poses[:, :3, 3] - centroid\n    x = poses[:, :, 3]\n    mu = x.mean(0)\n    cov = np.cov((x - mu).T)\n    (ev, eig) = np.linalg.eig(cov)\n    cams_up = eig[:, np.argmin(ev)]\n    if cams_up[1] < 0:\n        cams_up = -cams_up\n    R = scipy.spatial.transform.Rotation.align_vectors([[0, 1, 0]], cams_up[None])[0].as_matrix()\n    poses[:, :3, :3] = R @ poses[:, :3, :3]\n    poses[:, :3, [3]] = R @ poses[:, :3, [3]]\n    poses[:, :3, 3] = poses[:, :3, 3] + centroid\n    return poses"
        ]
    },
    {
        "func_name": "p34_to_44",
        "original": "def p34_to_44(p):\n    return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)",
        "mutated": [
            "def p34_to_44(p):\n    if False:\n        i = 10\n    return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)",
            "def p34_to_44(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)",
            "def p34_to_44(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)",
            "def p34_to_44(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)",
            "def p34_to_44(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)"
        ]
    },
    {
        "func_name": "min_line_dist",
        "original": "def min_line_dist(rays_o, rays_d):\n    A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n    b_i = -A_i @ rays_o\n    pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n    return pt_mindist",
        "mutated": [
            "def min_line_dist(rays_o, rays_d):\n    if False:\n        i = 10\n    A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n    b_i = -A_i @ rays_o\n    pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n    return pt_mindist",
            "def min_line_dist(rays_o, rays_d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n    b_i = -A_i @ rays_o\n    pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n    return pt_mindist",
            "def min_line_dist(rays_o, rays_d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n    b_i = -A_i @ rays_o\n    pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n    return pt_mindist",
            "def min_line_dist(rays_o, rays_d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n    b_i = -A_i @ rays_o\n    pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n    return pt_mindist",
            "def min_line_dist(rays_o, rays_d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n    b_i = -A_i @ rays_o\n    pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n    return pt_mindist"
        ]
    },
    {
        "func_name": "spherify_poses",
        "original": "def spherify_poses(poses, bds, depths):\n\n    def p34_to_44(p):\n        return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)\n    rays_d = poses[:, :3, 2:3]\n    rays_o = poses[:, :3, 3:4]\n\n    def min_line_dist(rays_o, rays_d):\n        A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n        b_i = -A_i @ rays_o\n        pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n        return pt_mindist\n    pt_mindist = min_line_dist(rays_o, rays_d)\n    center = pt_mindist\n    up = (poses[:, :3, 3] - center).mean(0)\n    vec0 = normalize(up)\n    vec1 = normalize(np.cross([0.1, 0.2, 0.3], vec0))\n    vec2 = normalize(np.cross(vec0, vec1))\n    pos = center\n    c2w = np.stack([vec1, vec2, vec0, pos], 1)\n    poses_reset = np.linalg.inv(p34_to_44(c2w[None])) @ p34_to_44(poses[:, :3, :4])\n    radius = np.sqrt(np.mean(np.sum(np.square(poses_reset[:, :3, 3]), -1)))\n    sc = 1.0 / radius\n    poses_reset[:, :3, 3] *= sc\n    bds *= sc\n    radius *= sc\n    depths *= sc\n    poses_reset = np.concatenate([poses_reset[:, :3, :4], np.broadcast_to(poses[0, :3, -1:], poses_reset[:, :3, -1:].shape)], -1)\n    return (poses_reset, radius, bds, depths)",
        "mutated": [
            "def spherify_poses(poses, bds, depths):\n    if False:\n        i = 10\n\n    def p34_to_44(p):\n        return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)\n    rays_d = poses[:, :3, 2:3]\n    rays_o = poses[:, :3, 3:4]\n\n    def min_line_dist(rays_o, rays_d):\n        A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n        b_i = -A_i @ rays_o\n        pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n        return pt_mindist\n    pt_mindist = min_line_dist(rays_o, rays_d)\n    center = pt_mindist\n    up = (poses[:, :3, 3] - center).mean(0)\n    vec0 = normalize(up)\n    vec1 = normalize(np.cross([0.1, 0.2, 0.3], vec0))\n    vec2 = normalize(np.cross(vec0, vec1))\n    pos = center\n    c2w = np.stack([vec1, vec2, vec0, pos], 1)\n    poses_reset = np.linalg.inv(p34_to_44(c2w[None])) @ p34_to_44(poses[:, :3, :4])\n    radius = np.sqrt(np.mean(np.sum(np.square(poses_reset[:, :3, 3]), -1)))\n    sc = 1.0 / radius\n    poses_reset[:, :3, 3] *= sc\n    bds *= sc\n    radius *= sc\n    depths *= sc\n    poses_reset = np.concatenate([poses_reset[:, :3, :4], np.broadcast_to(poses[0, :3, -1:], poses_reset[:, :3, -1:].shape)], -1)\n    return (poses_reset, radius, bds, depths)",
            "def spherify_poses(poses, bds, depths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def p34_to_44(p):\n        return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)\n    rays_d = poses[:, :3, 2:3]\n    rays_o = poses[:, :3, 3:4]\n\n    def min_line_dist(rays_o, rays_d):\n        A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n        b_i = -A_i @ rays_o\n        pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n        return pt_mindist\n    pt_mindist = min_line_dist(rays_o, rays_d)\n    center = pt_mindist\n    up = (poses[:, :3, 3] - center).mean(0)\n    vec0 = normalize(up)\n    vec1 = normalize(np.cross([0.1, 0.2, 0.3], vec0))\n    vec2 = normalize(np.cross(vec0, vec1))\n    pos = center\n    c2w = np.stack([vec1, vec2, vec0, pos], 1)\n    poses_reset = np.linalg.inv(p34_to_44(c2w[None])) @ p34_to_44(poses[:, :3, :4])\n    radius = np.sqrt(np.mean(np.sum(np.square(poses_reset[:, :3, 3]), -1)))\n    sc = 1.0 / radius\n    poses_reset[:, :3, 3] *= sc\n    bds *= sc\n    radius *= sc\n    depths *= sc\n    poses_reset = np.concatenate([poses_reset[:, :3, :4], np.broadcast_to(poses[0, :3, -1:], poses_reset[:, :3, -1:].shape)], -1)\n    return (poses_reset, radius, bds, depths)",
            "def spherify_poses(poses, bds, depths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def p34_to_44(p):\n        return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)\n    rays_d = poses[:, :3, 2:3]\n    rays_o = poses[:, :3, 3:4]\n\n    def min_line_dist(rays_o, rays_d):\n        A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n        b_i = -A_i @ rays_o\n        pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n        return pt_mindist\n    pt_mindist = min_line_dist(rays_o, rays_d)\n    center = pt_mindist\n    up = (poses[:, :3, 3] - center).mean(0)\n    vec0 = normalize(up)\n    vec1 = normalize(np.cross([0.1, 0.2, 0.3], vec0))\n    vec2 = normalize(np.cross(vec0, vec1))\n    pos = center\n    c2w = np.stack([vec1, vec2, vec0, pos], 1)\n    poses_reset = np.linalg.inv(p34_to_44(c2w[None])) @ p34_to_44(poses[:, :3, :4])\n    radius = np.sqrt(np.mean(np.sum(np.square(poses_reset[:, :3, 3]), -1)))\n    sc = 1.0 / radius\n    poses_reset[:, :3, 3] *= sc\n    bds *= sc\n    radius *= sc\n    depths *= sc\n    poses_reset = np.concatenate([poses_reset[:, :3, :4], np.broadcast_to(poses[0, :3, -1:], poses_reset[:, :3, -1:].shape)], -1)\n    return (poses_reset, radius, bds, depths)",
            "def spherify_poses(poses, bds, depths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def p34_to_44(p):\n        return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)\n    rays_d = poses[:, :3, 2:3]\n    rays_o = poses[:, :3, 3:4]\n\n    def min_line_dist(rays_o, rays_d):\n        A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n        b_i = -A_i @ rays_o\n        pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n        return pt_mindist\n    pt_mindist = min_line_dist(rays_o, rays_d)\n    center = pt_mindist\n    up = (poses[:, :3, 3] - center).mean(0)\n    vec0 = normalize(up)\n    vec1 = normalize(np.cross([0.1, 0.2, 0.3], vec0))\n    vec2 = normalize(np.cross(vec0, vec1))\n    pos = center\n    c2w = np.stack([vec1, vec2, vec0, pos], 1)\n    poses_reset = np.linalg.inv(p34_to_44(c2w[None])) @ p34_to_44(poses[:, :3, :4])\n    radius = np.sqrt(np.mean(np.sum(np.square(poses_reset[:, :3, 3]), -1)))\n    sc = 1.0 / radius\n    poses_reset[:, :3, 3] *= sc\n    bds *= sc\n    radius *= sc\n    depths *= sc\n    poses_reset = np.concatenate([poses_reset[:, :3, :4], np.broadcast_to(poses[0, :3, -1:], poses_reset[:, :3, -1:].shape)], -1)\n    return (poses_reset, radius, bds, depths)",
            "def spherify_poses(poses, bds, depths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def p34_to_44(p):\n        return np.concatenate([p, np.tile(np.reshape(np.eye(4)[-1, :], [1, 1, 4]), [p.shape[0], 1, 1])], 1)\n    rays_d = poses[:, :3, 2:3]\n    rays_o = poses[:, :3, 3:4]\n\n    def min_line_dist(rays_o, rays_d):\n        A_i = np.eye(3) - rays_d * np.transpose(rays_d, [0, 2, 1])\n        b_i = -A_i @ rays_o\n        pt_mindist = np.squeeze(-np.linalg.inv((np.transpose(A_i, [0, 2, 1]) @ A_i).mean(0)) @ b_i.mean(0))\n        return pt_mindist\n    pt_mindist = min_line_dist(rays_o, rays_d)\n    center = pt_mindist\n    up = (poses[:, :3, 3] - center).mean(0)\n    vec0 = normalize(up)\n    vec1 = normalize(np.cross([0.1, 0.2, 0.3], vec0))\n    vec2 = normalize(np.cross(vec0, vec1))\n    pos = center\n    c2w = np.stack([vec1, vec2, vec0, pos], 1)\n    poses_reset = np.linalg.inv(p34_to_44(c2w[None])) @ p34_to_44(poses[:, :3, :4])\n    radius = np.sqrt(np.mean(np.sum(np.square(poses_reset[:, :3, 3]), -1)))\n    sc = 1.0 / radius\n    poses_reset[:, :3, 3] *= sc\n    bds *= sc\n    radius *= sc\n    depths *= sc\n    poses_reset = np.concatenate([poses_reset[:, :3, :4], np.broadcast_to(poses[0, :3, -1:], poses_reset[:, :3, -1:].shape)], -1)\n    return (poses_reset, radius, bds, depths)"
        ]
    },
    {
        "func_name": "load_llff_data",
        "original": "def load_llff_data(basedir, factor=8, width=None, height=None, recenter=True, rerotate=True, bd_factor=0.75, spherify=False, path_zflat=False, load_depths=False, load_SR=False, movie_render_kwargs={}):\n    (poses, bds, imgs, *depths) = _load_data(basedir, factor=factor, width=width, height=height, load_depths=load_depths, load_SR=load_SR)\n    print('Loaded', basedir, bds.min(), bds.max())\n    if load_depths:\n        depths = depths[0]\n    elif load_SR and (not load_depths):\n        imgs_SRGT = depths[0]\n        depths = 0\n    else:\n        depths = 0\n    poses = np.concatenate([poses[:, 1:2, :], -poses[:, 0:1, :], poses[:, 2:, :]], 1)\n    poses = np.moveaxis(poses, -1, 0).astype(np.float32)\n    imgs = np.moveaxis(imgs, -1, 0).astype(np.float32)\n    images = imgs\n    bds = np.moveaxis(bds, -1, 0).astype(np.float32)\n    if bds.min() < 0 and bd_factor is not None:\n        print('Found negative z values from SfM sparse points!?')\n        print('Please try bd_factor=None')\n        import sys\n        sys.exit()\n    sc = 1.0 if bd_factor is None else 1.0 / (bds.min() * bd_factor)\n    poses[:, :3, 3] *= sc\n    bds *= sc\n    depths *= sc\n    if recenter:\n        poses = recenter_poses(poses)\n    if spherify:\n        (poses, radius, bds, depths) = spherify_poses(poses, bds, depths)\n        if rerotate:\n            poses = rerotate_poses(poses)\n        centroid = poses[:, :3, 3].mean(0)\n        radcircle = movie_render_kwargs.get('scale_r', 1) * np.linalg.norm(poses[:, :3, 3] - centroid, axis=-1).mean()\n        centroid[0] += movie_render_kwargs.get('shift_x', 0)\n        centroid[1] += movie_render_kwargs.get('shift_y', 0)\n        centroid[2] += movie_render_kwargs.get('shift_z', 0)\n        new_up_rad = movie_render_kwargs.get('pitch_deg', 0) * np.pi / 180\n        target_y = radcircle * np.tan(new_up_rad)\n        render_poses = []\n        for th in np.linspace(0.0, 2.0 * np.pi, 200):\n            camorigin = np.array([radcircle * np.cos(th), 0, radcircle * np.sin(th)])\n            if movie_render_kwargs.get('flip_up', False):\n                up = np.array([0, 1.0, 0])\n            else:\n                up = np.array([0, -1.0, 0])\n            vec2 = normalize(camorigin)\n            vec0 = normalize(np.cross(vec2, up))\n            vec1 = normalize(np.cross(vec2, vec0))\n            pos = camorigin + centroid\n            lookat = -vec2\n            lookat[1] = target_y\n            lookat = normalize(lookat)\n            vec2 = -lookat\n            vec1 = normalize(np.cross(vec2, vec0))\n            p = np.stack([vec0, vec1, vec2, pos], 1)\n            render_poses.append(p)\n        render_poses = np.stack(render_poses, 0)\n        render_poses = np.concatenate([render_poses, np.broadcast_to(poses[0, :3, -1:], render_poses[:, :3, -1:].shape)], -1)\n    else:\n        c2w = poses_avg(poses)\n        print('recentered', c2w.shape)\n        print(c2w[:3, :4])\n        up = normalize(poses[:, :3, 1].sum(0))\n        (close_depth, inf_depth) = (bds.min() * 0.9, bds.max() * 5.0)\n        dt = 0.75\n        mean_dz = 1.0 / ((1.0 - dt) / close_depth + dt / inf_depth)\n        focal = mean_dz * movie_render_kwargs.get('scale_f', 1)\n        zdelta = movie_render_kwargs.get('zdelta', 0.5)\n        zrate = movie_render_kwargs.get('zrate', 1.0)\n        tt = poses[:, :3, 3]\n        rads = np.percentile(np.abs(tt), 90, 0) * movie_render_kwargs.get('scale_r', 1)\n        c2w_path = c2w\n        N_views = 120\n        N_rots = movie_render_kwargs.get('N_rots', 1)\n        if path_zflat:\n            zloc = -close_depth * 0.1\n            c2w_path[:3, 3] = c2w_path[:3, 3] + zloc * c2w_path[:3, 2]\n            rads[2] = 0.0\n            N_rots = 1\n            N_views /= 2\n        render_poses = render_path_spiral(c2w_path, up, rads, focal, zdelta, zrate=zrate, rots=N_rots, N=N_views)\n    render_poses = torch.Tensor(render_poses)\n    c2w = poses_avg(poses)\n    w2c = w2c_gen(poses)\n    print('Data:')\n    print(poses.shape, images.shape, bds.shape)\n    dists = np.sum(np.square(c2w[:3, 3] - poses[:, :3, 3]), -1)\n    i_test = np.argmin(dists)\n    print('HOLDOUT view is', i_test)\n    images = images.astype(np.float32)\n    poses = poses.astype(np.float32)\n    if load_SR:\n        imgs_SRGT = np.moveaxis(imgs_SRGT, [-1, -2], [0, 1]).astype(np.float32)\n    else:\n        imgs_SRGT = None\n    return (images, depths, poses, bds, render_poses, i_test, imgs_SRGT, w2c)",
        "mutated": [
            "def load_llff_data(basedir, factor=8, width=None, height=None, recenter=True, rerotate=True, bd_factor=0.75, spherify=False, path_zflat=False, load_depths=False, load_SR=False, movie_render_kwargs={}):\n    if False:\n        i = 10\n    (poses, bds, imgs, *depths) = _load_data(basedir, factor=factor, width=width, height=height, load_depths=load_depths, load_SR=load_SR)\n    print('Loaded', basedir, bds.min(), bds.max())\n    if load_depths:\n        depths = depths[0]\n    elif load_SR and (not load_depths):\n        imgs_SRGT = depths[0]\n        depths = 0\n    else:\n        depths = 0\n    poses = np.concatenate([poses[:, 1:2, :], -poses[:, 0:1, :], poses[:, 2:, :]], 1)\n    poses = np.moveaxis(poses, -1, 0).astype(np.float32)\n    imgs = np.moveaxis(imgs, -1, 0).astype(np.float32)\n    images = imgs\n    bds = np.moveaxis(bds, -1, 0).astype(np.float32)\n    if bds.min() < 0 and bd_factor is not None:\n        print('Found negative z values from SfM sparse points!?')\n        print('Please try bd_factor=None')\n        import sys\n        sys.exit()\n    sc = 1.0 if bd_factor is None else 1.0 / (bds.min() * bd_factor)\n    poses[:, :3, 3] *= sc\n    bds *= sc\n    depths *= sc\n    if recenter:\n        poses = recenter_poses(poses)\n    if spherify:\n        (poses, radius, bds, depths) = spherify_poses(poses, bds, depths)\n        if rerotate:\n            poses = rerotate_poses(poses)\n        centroid = poses[:, :3, 3].mean(0)\n        radcircle = movie_render_kwargs.get('scale_r', 1) * np.linalg.norm(poses[:, :3, 3] - centroid, axis=-1).mean()\n        centroid[0] += movie_render_kwargs.get('shift_x', 0)\n        centroid[1] += movie_render_kwargs.get('shift_y', 0)\n        centroid[2] += movie_render_kwargs.get('shift_z', 0)\n        new_up_rad = movie_render_kwargs.get('pitch_deg', 0) * np.pi / 180\n        target_y = radcircle * np.tan(new_up_rad)\n        render_poses = []\n        for th in np.linspace(0.0, 2.0 * np.pi, 200):\n            camorigin = np.array([radcircle * np.cos(th), 0, radcircle * np.sin(th)])\n            if movie_render_kwargs.get('flip_up', False):\n                up = np.array([0, 1.0, 0])\n            else:\n                up = np.array([0, -1.0, 0])\n            vec2 = normalize(camorigin)\n            vec0 = normalize(np.cross(vec2, up))\n            vec1 = normalize(np.cross(vec2, vec0))\n            pos = camorigin + centroid\n            lookat = -vec2\n            lookat[1] = target_y\n            lookat = normalize(lookat)\n            vec2 = -lookat\n            vec1 = normalize(np.cross(vec2, vec0))\n            p = np.stack([vec0, vec1, vec2, pos], 1)\n            render_poses.append(p)\n        render_poses = np.stack(render_poses, 0)\n        render_poses = np.concatenate([render_poses, np.broadcast_to(poses[0, :3, -1:], render_poses[:, :3, -1:].shape)], -1)\n    else:\n        c2w = poses_avg(poses)\n        print('recentered', c2w.shape)\n        print(c2w[:3, :4])\n        up = normalize(poses[:, :3, 1].sum(0))\n        (close_depth, inf_depth) = (bds.min() * 0.9, bds.max() * 5.0)\n        dt = 0.75\n        mean_dz = 1.0 / ((1.0 - dt) / close_depth + dt / inf_depth)\n        focal = mean_dz * movie_render_kwargs.get('scale_f', 1)\n        zdelta = movie_render_kwargs.get('zdelta', 0.5)\n        zrate = movie_render_kwargs.get('zrate', 1.0)\n        tt = poses[:, :3, 3]\n        rads = np.percentile(np.abs(tt), 90, 0) * movie_render_kwargs.get('scale_r', 1)\n        c2w_path = c2w\n        N_views = 120\n        N_rots = movie_render_kwargs.get('N_rots', 1)\n        if path_zflat:\n            zloc = -close_depth * 0.1\n            c2w_path[:3, 3] = c2w_path[:3, 3] + zloc * c2w_path[:3, 2]\n            rads[2] = 0.0\n            N_rots = 1\n            N_views /= 2\n        render_poses = render_path_spiral(c2w_path, up, rads, focal, zdelta, zrate=zrate, rots=N_rots, N=N_views)\n    render_poses = torch.Tensor(render_poses)\n    c2w = poses_avg(poses)\n    w2c = w2c_gen(poses)\n    print('Data:')\n    print(poses.shape, images.shape, bds.shape)\n    dists = np.sum(np.square(c2w[:3, 3] - poses[:, :3, 3]), -1)\n    i_test = np.argmin(dists)\n    print('HOLDOUT view is', i_test)\n    images = images.astype(np.float32)\n    poses = poses.astype(np.float32)\n    if load_SR:\n        imgs_SRGT = np.moveaxis(imgs_SRGT, [-1, -2], [0, 1]).astype(np.float32)\n    else:\n        imgs_SRGT = None\n    return (images, depths, poses, bds, render_poses, i_test, imgs_SRGT, w2c)",
            "def load_llff_data(basedir, factor=8, width=None, height=None, recenter=True, rerotate=True, bd_factor=0.75, spherify=False, path_zflat=False, load_depths=False, load_SR=False, movie_render_kwargs={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (poses, bds, imgs, *depths) = _load_data(basedir, factor=factor, width=width, height=height, load_depths=load_depths, load_SR=load_SR)\n    print('Loaded', basedir, bds.min(), bds.max())\n    if load_depths:\n        depths = depths[0]\n    elif load_SR and (not load_depths):\n        imgs_SRGT = depths[0]\n        depths = 0\n    else:\n        depths = 0\n    poses = np.concatenate([poses[:, 1:2, :], -poses[:, 0:1, :], poses[:, 2:, :]], 1)\n    poses = np.moveaxis(poses, -1, 0).astype(np.float32)\n    imgs = np.moveaxis(imgs, -1, 0).astype(np.float32)\n    images = imgs\n    bds = np.moveaxis(bds, -1, 0).astype(np.float32)\n    if bds.min() < 0 and bd_factor is not None:\n        print('Found negative z values from SfM sparse points!?')\n        print('Please try bd_factor=None')\n        import sys\n        sys.exit()\n    sc = 1.0 if bd_factor is None else 1.0 / (bds.min() * bd_factor)\n    poses[:, :3, 3] *= sc\n    bds *= sc\n    depths *= sc\n    if recenter:\n        poses = recenter_poses(poses)\n    if spherify:\n        (poses, radius, bds, depths) = spherify_poses(poses, bds, depths)\n        if rerotate:\n            poses = rerotate_poses(poses)\n        centroid = poses[:, :3, 3].mean(0)\n        radcircle = movie_render_kwargs.get('scale_r', 1) * np.linalg.norm(poses[:, :3, 3] - centroid, axis=-1).mean()\n        centroid[0] += movie_render_kwargs.get('shift_x', 0)\n        centroid[1] += movie_render_kwargs.get('shift_y', 0)\n        centroid[2] += movie_render_kwargs.get('shift_z', 0)\n        new_up_rad = movie_render_kwargs.get('pitch_deg', 0) * np.pi / 180\n        target_y = radcircle * np.tan(new_up_rad)\n        render_poses = []\n        for th in np.linspace(0.0, 2.0 * np.pi, 200):\n            camorigin = np.array([radcircle * np.cos(th), 0, radcircle * np.sin(th)])\n            if movie_render_kwargs.get('flip_up', False):\n                up = np.array([0, 1.0, 0])\n            else:\n                up = np.array([0, -1.0, 0])\n            vec2 = normalize(camorigin)\n            vec0 = normalize(np.cross(vec2, up))\n            vec1 = normalize(np.cross(vec2, vec0))\n            pos = camorigin + centroid\n            lookat = -vec2\n            lookat[1] = target_y\n            lookat = normalize(lookat)\n            vec2 = -lookat\n            vec1 = normalize(np.cross(vec2, vec0))\n            p = np.stack([vec0, vec1, vec2, pos], 1)\n            render_poses.append(p)\n        render_poses = np.stack(render_poses, 0)\n        render_poses = np.concatenate([render_poses, np.broadcast_to(poses[0, :3, -1:], render_poses[:, :3, -1:].shape)], -1)\n    else:\n        c2w = poses_avg(poses)\n        print('recentered', c2w.shape)\n        print(c2w[:3, :4])\n        up = normalize(poses[:, :3, 1].sum(0))\n        (close_depth, inf_depth) = (bds.min() * 0.9, bds.max() * 5.0)\n        dt = 0.75\n        mean_dz = 1.0 / ((1.0 - dt) / close_depth + dt / inf_depth)\n        focal = mean_dz * movie_render_kwargs.get('scale_f', 1)\n        zdelta = movie_render_kwargs.get('zdelta', 0.5)\n        zrate = movie_render_kwargs.get('zrate', 1.0)\n        tt = poses[:, :3, 3]\n        rads = np.percentile(np.abs(tt), 90, 0) * movie_render_kwargs.get('scale_r', 1)\n        c2w_path = c2w\n        N_views = 120\n        N_rots = movie_render_kwargs.get('N_rots', 1)\n        if path_zflat:\n            zloc = -close_depth * 0.1\n            c2w_path[:3, 3] = c2w_path[:3, 3] + zloc * c2w_path[:3, 2]\n            rads[2] = 0.0\n            N_rots = 1\n            N_views /= 2\n        render_poses = render_path_spiral(c2w_path, up, rads, focal, zdelta, zrate=zrate, rots=N_rots, N=N_views)\n    render_poses = torch.Tensor(render_poses)\n    c2w = poses_avg(poses)\n    w2c = w2c_gen(poses)\n    print('Data:')\n    print(poses.shape, images.shape, bds.shape)\n    dists = np.sum(np.square(c2w[:3, 3] - poses[:, :3, 3]), -1)\n    i_test = np.argmin(dists)\n    print('HOLDOUT view is', i_test)\n    images = images.astype(np.float32)\n    poses = poses.astype(np.float32)\n    if load_SR:\n        imgs_SRGT = np.moveaxis(imgs_SRGT, [-1, -2], [0, 1]).astype(np.float32)\n    else:\n        imgs_SRGT = None\n    return (images, depths, poses, bds, render_poses, i_test, imgs_SRGT, w2c)",
            "def load_llff_data(basedir, factor=8, width=None, height=None, recenter=True, rerotate=True, bd_factor=0.75, spherify=False, path_zflat=False, load_depths=False, load_SR=False, movie_render_kwargs={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (poses, bds, imgs, *depths) = _load_data(basedir, factor=factor, width=width, height=height, load_depths=load_depths, load_SR=load_SR)\n    print('Loaded', basedir, bds.min(), bds.max())\n    if load_depths:\n        depths = depths[0]\n    elif load_SR and (not load_depths):\n        imgs_SRGT = depths[0]\n        depths = 0\n    else:\n        depths = 0\n    poses = np.concatenate([poses[:, 1:2, :], -poses[:, 0:1, :], poses[:, 2:, :]], 1)\n    poses = np.moveaxis(poses, -1, 0).astype(np.float32)\n    imgs = np.moveaxis(imgs, -1, 0).astype(np.float32)\n    images = imgs\n    bds = np.moveaxis(bds, -1, 0).astype(np.float32)\n    if bds.min() < 0 and bd_factor is not None:\n        print('Found negative z values from SfM sparse points!?')\n        print('Please try bd_factor=None')\n        import sys\n        sys.exit()\n    sc = 1.0 if bd_factor is None else 1.0 / (bds.min() * bd_factor)\n    poses[:, :3, 3] *= sc\n    bds *= sc\n    depths *= sc\n    if recenter:\n        poses = recenter_poses(poses)\n    if spherify:\n        (poses, radius, bds, depths) = spherify_poses(poses, bds, depths)\n        if rerotate:\n            poses = rerotate_poses(poses)\n        centroid = poses[:, :3, 3].mean(0)\n        radcircle = movie_render_kwargs.get('scale_r', 1) * np.linalg.norm(poses[:, :3, 3] - centroid, axis=-1).mean()\n        centroid[0] += movie_render_kwargs.get('shift_x', 0)\n        centroid[1] += movie_render_kwargs.get('shift_y', 0)\n        centroid[2] += movie_render_kwargs.get('shift_z', 0)\n        new_up_rad = movie_render_kwargs.get('pitch_deg', 0) * np.pi / 180\n        target_y = radcircle * np.tan(new_up_rad)\n        render_poses = []\n        for th in np.linspace(0.0, 2.0 * np.pi, 200):\n            camorigin = np.array([radcircle * np.cos(th), 0, radcircle * np.sin(th)])\n            if movie_render_kwargs.get('flip_up', False):\n                up = np.array([0, 1.0, 0])\n            else:\n                up = np.array([0, -1.0, 0])\n            vec2 = normalize(camorigin)\n            vec0 = normalize(np.cross(vec2, up))\n            vec1 = normalize(np.cross(vec2, vec0))\n            pos = camorigin + centroid\n            lookat = -vec2\n            lookat[1] = target_y\n            lookat = normalize(lookat)\n            vec2 = -lookat\n            vec1 = normalize(np.cross(vec2, vec0))\n            p = np.stack([vec0, vec1, vec2, pos], 1)\n            render_poses.append(p)\n        render_poses = np.stack(render_poses, 0)\n        render_poses = np.concatenate([render_poses, np.broadcast_to(poses[0, :3, -1:], render_poses[:, :3, -1:].shape)], -1)\n    else:\n        c2w = poses_avg(poses)\n        print('recentered', c2w.shape)\n        print(c2w[:3, :4])\n        up = normalize(poses[:, :3, 1].sum(0))\n        (close_depth, inf_depth) = (bds.min() * 0.9, bds.max() * 5.0)\n        dt = 0.75\n        mean_dz = 1.0 / ((1.0 - dt) / close_depth + dt / inf_depth)\n        focal = mean_dz * movie_render_kwargs.get('scale_f', 1)\n        zdelta = movie_render_kwargs.get('zdelta', 0.5)\n        zrate = movie_render_kwargs.get('zrate', 1.0)\n        tt = poses[:, :3, 3]\n        rads = np.percentile(np.abs(tt), 90, 0) * movie_render_kwargs.get('scale_r', 1)\n        c2w_path = c2w\n        N_views = 120\n        N_rots = movie_render_kwargs.get('N_rots', 1)\n        if path_zflat:\n            zloc = -close_depth * 0.1\n            c2w_path[:3, 3] = c2w_path[:3, 3] + zloc * c2w_path[:3, 2]\n            rads[2] = 0.0\n            N_rots = 1\n            N_views /= 2\n        render_poses = render_path_spiral(c2w_path, up, rads, focal, zdelta, zrate=zrate, rots=N_rots, N=N_views)\n    render_poses = torch.Tensor(render_poses)\n    c2w = poses_avg(poses)\n    w2c = w2c_gen(poses)\n    print('Data:')\n    print(poses.shape, images.shape, bds.shape)\n    dists = np.sum(np.square(c2w[:3, 3] - poses[:, :3, 3]), -1)\n    i_test = np.argmin(dists)\n    print('HOLDOUT view is', i_test)\n    images = images.astype(np.float32)\n    poses = poses.astype(np.float32)\n    if load_SR:\n        imgs_SRGT = np.moveaxis(imgs_SRGT, [-1, -2], [0, 1]).astype(np.float32)\n    else:\n        imgs_SRGT = None\n    return (images, depths, poses, bds, render_poses, i_test, imgs_SRGT, w2c)",
            "def load_llff_data(basedir, factor=8, width=None, height=None, recenter=True, rerotate=True, bd_factor=0.75, spherify=False, path_zflat=False, load_depths=False, load_SR=False, movie_render_kwargs={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (poses, bds, imgs, *depths) = _load_data(basedir, factor=factor, width=width, height=height, load_depths=load_depths, load_SR=load_SR)\n    print('Loaded', basedir, bds.min(), bds.max())\n    if load_depths:\n        depths = depths[0]\n    elif load_SR and (not load_depths):\n        imgs_SRGT = depths[0]\n        depths = 0\n    else:\n        depths = 0\n    poses = np.concatenate([poses[:, 1:2, :], -poses[:, 0:1, :], poses[:, 2:, :]], 1)\n    poses = np.moveaxis(poses, -1, 0).astype(np.float32)\n    imgs = np.moveaxis(imgs, -1, 0).astype(np.float32)\n    images = imgs\n    bds = np.moveaxis(bds, -1, 0).astype(np.float32)\n    if bds.min() < 0 and bd_factor is not None:\n        print('Found negative z values from SfM sparse points!?')\n        print('Please try bd_factor=None')\n        import sys\n        sys.exit()\n    sc = 1.0 if bd_factor is None else 1.0 / (bds.min() * bd_factor)\n    poses[:, :3, 3] *= sc\n    bds *= sc\n    depths *= sc\n    if recenter:\n        poses = recenter_poses(poses)\n    if spherify:\n        (poses, radius, bds, depths) = spherify_poses(poses, bds, depths)\n        if rerotate:\n            poses = rerotate_poses(poses)\n        centroid = poses[:, :3, 3].mean(0)\n        radcircle = movie_render_kwargs.get('scale_r', 1) * np.linalg.norm(poses[:, :3, 3] - centroid, axis=-1).mean()\n        centroid[0] += movie_render_kwargs.get('shift_x', 0)\n        centroid[1] += movie_render_kwargs.get('shift_y', 0)\n        centroid[2] += movie_render_kwargs.get('shift_z', 0)\n        new_up_rad = movie_render_kwargs.get('pitch_deg', 0) * np.pi / 180\n        target_y = radcircle * np.tan(new_up_rad)\n        render_poses = []\n        for th in np.linspace(0.0, 2.0 * np.pi, 200):\n            camorigin = np.array([radcircle * np.cos(th), 0, radcircle * np.sin(th)])\n            if movie_render_kwargs.get('flip_up', False):\n                up = np.array([0, 1.0, 0])\n            else:\n                up = np.array([0, -1.0, 0])\n            vec2 = normalize(camorigin)\n            vec0 = normalize(np.cross(vec2, up))\n            vec1 = normalize(np.cross(vec2, vec0))\n            pos = camorigin + centroid\n            lookat = -vec2\n            lookat[1] = target_y\n            lookat = normalize(lookat)\n            vec2 = -lookat\n            vec1 = normalize(np.cross(vec2, vec0))\n            p = np.stack([vec0, vec1, vec2, pos], 1)\n            render_poses.append(p)\n        render_poses = np.stack(render_poses, 0)\n        render_poses = np.concatenate([render_poses, np.broadcast_to(poses[0, :3, -1:], render_poses[:, :3, -1:].shape)], -1)\n    else:\n        c2w = poses_avg(poses)\n        print('recentered', c2w.shape)\n        print(c2w[:3, :4])\n        up = normalize(poses[:, :3, 1].sum(0))\n        (close_depth, inf_depth) = (bds.min() * 0.9, bds.max() * 5.0)\n        dt = 0.75\n        mean_dz = 1.0 / ((1.0 - dt) / close_depth + dt / inf_depth)\n        focal = mean_dz * movie_render_kwargs.get('scale_f', 1)\n        zdelta = movie_render_kwargs.get('zdelta', 0.5)\n        zrate = movie_render_kwargs.get('zrate', 1.0)\n        tt = poses[:, :3, 3]\n        rads = np.percentile(np.abs(tt), 90, 0) * movie_render_kwargs.get('scale_r', 1)\n        c2w_path = c2w\n        N_views = 120\n        N_rots = movie_render_kwargs.get('N_rots', 1)\n        if path_zflat:\n            zloc = -close_depth * 0.1\n            c2w_path[:3, 3] = c2w_path[:3, 3] + zloc * c2w_path[:3, 2]\n            rads[2] = 0.0\n            N_rots = 1\n            N_views /= 2\n        render_poses = render_path_spiral(c2w_path, up, rads, focal, zdelta, zrate=zrate, rots=N_rots, N=N_views)\n    render_poses = torch.Tensor(render_poses)\n    c2w = poses_avg(poses)\n    w2c = w2c_gen(poses)\n    print('Data:')\n    print(poses.shape, images.shape, bds.shape)\n    dists = np.sum(np.square(c2w[:3, 3] - poses[:, :3, 3]), -1)\n    i_test = np.argmin(dists)\n    print('HOLDOUT view is', i_test)\n    images = images.astype(np.float32)\n    poses = poses.astype(np.float32)\n    if load_SR:\n        imgs_SRGT = np.moveaxis(imgs_SRGT, [-1, -2], [0, 1]).astype(np.float32)\n    else:\n        imgs_SRGT = None\n    return (images, depths, poses, bds, render_poses, i_test, imgs_SRGT, w2c)",
            "def load_llff_data(basedir, factor=8, width=None, height=None, recenter=True, rerotate=True, bd_factor=0.75, spherify=False, path_zflat=False, load_depths=False, load_SR=False, movie_render_kwargs={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (poses, bds, imgs, *depths) = _load_data(basedir, factor=factor, width=width, height=height, load_depths=load_depths, load_SR=load_SR)\n    print('Loaded', basedir, bds.min(), bds.max())\n    if load_depths:\n        depths = depths[0]\n    elif load_SR and (not load_depths):\n        imgs_SRGT = depths[0]\n        depths = 0\n    else:\n        depths = 0\n    poses = np.concatenate([poses[:, 1:2, :], -poses[:, 0:1, :], poses[:, 2:, :]], 1)\n    poses = np.moveaxis(poses, -1, 0).astype(np.float32)\n    imgs = np.moveaxis(imgs, -1, 0).astype(np.float32)\n    images = imgs\n    bds = np.moveaxis(bds, -1, 0).astype(np.float32)\n    if bds.min() < 0 and bd_factor is not None:\n        print('Found negative z values from SfM sparse points!?')\n        print('Please try bd_factor=None')\n        import sys\n        sys.exit()\n    sc = 1.0 if bd_factor is None else 1.0 / (bds.min() * bd_factor)\n    poses[:, :3, 3] *= sc\n    bds *= sc\n    depths *= sc\n    if recenter:\n        poses = recenter_poses(poses)\n    if spherify:\n        (poses, radius, bds, depths) = spherify_poses(poses, bds, depths)\n        if rerotate:\n            poses = rerotate_poses(poses)\n        centroid = poses[:, :3, 3].mean(0)\n        radcircle = movie_render_kwargs.get('scale_r', 1) * np.linalg.norm(poses[:, :3, 3] - centroid, axis=-1).mean()\n        centroid[0] += movie_render_kwargs.get('shift_x', 0)\n        centroid[1] += movie_render_kwargs.get('shift_y', 0)\n        centroid[2] += movie_render_kwargs.get('shift_z', 0)\n        new_up_rad = movie_render_kwargs.get('pitch_deg', 0) * np.pi / 180\n        target_y = radcircle * np.tan(new_up_rad)\n        render_poses = []\n        for th in np.linspace(0.0, 2.0 * np.pi, 200):\n            camorigin = np.array([radcircle * np.cos(th), 0, radcircle * np.sin(th)])\n            if movie_render_kwargs.get('flip_up', False):\n                up = np.array([0, 1.0, 0])\n            else:\n                up = np.array([0, -1.0, 0])\n            vec2 = normalize(camorigin)\n            vec0 = normalize(np.cross(vec2, up))\n            vec1 = normalize(np.cross(vec2, vec0))\n            pos = camorigin + centroid\n            lookat = -vec2\n            lookat[1] = target_y\n            lookat = normalize(lookat)\n            vec2 = -lookat\n            vec1 = normalize(np.cross(vec2, vec0))\n            p = np.stack([vec0, vec1, vec2, pos], 1)\n            render_poses.append(p)\n        render_poses = np.stack(render_poses, 0)\n        render_poses = np.concatenate([render_poses, np.broadcast_to(poses[0, :3, -1:], render_poses[:, :3, -1:].shape)], -1)\n    else:\n        c2w = poses_avg(poses)\n        print('recentered', c2w.shape)\n        print(c2w[:3, :4])\n        up = normalize(poses[:, :3, 1].sum(0))\n        (close_depth, inf_depth) = (bds.min() * 0.9, bds.max() * 5.0)\n        dt = 0.75\n        mean_dz = 1.0 / ((1.0 - dt) / close_depth + dt / inf_depth)\n        focal = mean_dz * movie_render_kwargs.get('scale_f', 1)\n        zdelta = movie_render_kwargs.get('zdelta', 0.5)\n        zrate = movie_render_kwargs.get('zrate', 1.0)\n        tt = poses[:, :3, 3]\n        rads = np.percentile(np.abs(tt), 90, 0) * movie_render_kwargs.get('scale_r', 1)\n        c2w_path = c2w\n        N_views = 120\n        N_rots = movie_render_kwargs.get('N_rots', 1)\n        if path_zflat:\n            zloc = -close_depth * 0.1\n            c2w_path[:3, 3] = c2w_path[:3, 3] + zloc * c2w_path[:3, 2]\n            rads[2] = 0.0\n            N_rots = 1\n            N_views /= 2\n        render_poses = render_path_spiral(c2w_path, up, rads, focal, zdelta, zrate=zrate, rots=N_rots, N=N_views)\n    render_poses = torch.Tensor(render_poses)\n    c2w = poses_avg(poses)\n    w2c = w2c_gen(poses)\n    print('Data:')\n    print(poses.shape, images.shape, bds.shape)\n    dists = np.sum(np.square(c2w[:3, 3] - poses[:, :3, 3]), -1)\n    i_test = np.argmin(dists)\n    print('HOLDOUT view is', i_test)\n    images = images.astype(np.float32)\n    poses = poses.astype(np.float32)\n    if load_SR:\n        imgs_SRGT = np.moveaxis(imgs_SRGT, [-1, -2], [0, 1]).astype(np.float32)\n    else:\n        imgs_SRGT = None\n    return (images, depths, poses, bds, render_poses, i_test, imgs_SRGT, w2c)"
        ]
    }
]