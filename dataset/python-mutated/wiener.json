[
    {
        "func_name": "wiener_index",
        "original": "@nx._dispatch(edge_attrs='weight')\ndef wiener_index(G, weight=None):\n    \"\"\"Returns the Wiener index of the given graph.\n\n    The *Wiener index* of a graph is the sum of the shortest-path\n    distances between each pair of reachable nodes. For pairs of nodes\n    in undirected graphs, only one orientation of the pair is counted.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : object\n        The edge attribute to use as distance when computing\n        shortest-path distances. This is passed directly to the\n        :func:`networkx.shortest_path_length` function.\n\n    Returns\n    -------\n    float\n        The Wiener index of the graph `G`.\n\n    Raises\n    ------\n    NetworkXError\n        If the graph `G` is not connected.\n\n    Notes\n    -----\n    If a pair of nodes is not reachable, the distance is assumed to be\n    infinity. This means that for graphs that are not\n    strongly-connected, this function returns ``inf``.\n\n    The Wiener index is not usually defined for directed graphs, however\n    this function uses the natural generalization of the Wiener index to\n    directed graphs.\n\n    Examples\n    --------\n    The Wiener index of the (unweighted) complete graph on *n* nodes\n    equals the number of pairs of the *n* nodes, since each pair of\n    nodes is at distance one::\n\n        >>> n = 10\n        >>> G = nx.complete_graph(n)\n        >>> nx.wiener_index(G) == n * (n - 1) / 2\n        True\n\n    Graphs that are not strongly-connected have infinite Wiener index::\n\n        >>> G = nx.empty_graph(2)\n        >>> nx.wiener_index(G)\n        inf\n\n    \"\"\"\n    is_directed = G.is_directed()\n    if is_directed and (not is_strongly_connected(G)) or (not is_directed and (not is_connected(G))):\n        return float('inf')\n    total = sum(chaini((p.values() for (v, p) in spl(G, weight=weight))))\n    return total if is_directed else total / 2",
        "mutated": [
            "@nx._dispatch(edge_attrs='weight')\ndef wiener_index(G, weight=None):\n    if False:\n        i = 10\n    'Returns the Wiener index of the given graph.\\n\\n    The *Wiener index* of a graph is the sum of the shortest-path\\n    distances between each pair of reachable nodes. For pairs of nodes\\n    in undirected graphs, only one orientation of the pair is counted.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : object\\n        The edge attribute to use as distance when computing\\n        shortest-path distances. This is passed directly to the\\n        :func:`networkx.shortest_path_length` function.\\n\\n    Returns\\n    -------\\n    float\\n        The Wiener index of the graph `G`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph `G` is not connected.\\n\\n    Notes\\n    -----\\n    If a pair of nodes is not reachable, the distance is assumed to be\\n    infinity. This means that for graphs that are not\\n    strongly-connected, this function returns ``inf``.\\n\\n    The Wiener index is not usually defined for directed graphs, however\\n    this function uses the natural generalization of the Wiener index to\\n    directed graphs.\\n\\n    Examples\\n    --------\\n    The Wiener index of the (unweighted) complete graph on *n* nodes\\n    equals the number of pairs of the *n* nodes, since each pair of\\n    nodes is at distance one::\\n\\n        >>> n = 10\\n        >>> G = nx.complete_graph(n)\\n        >>> nx.wiener_index(G) == n * (n - 1) / 2\\n        True\\n\\n    Graphs that are not strongly-connected have infinite Wiener index::\\n\\n        >>> G = nx.empty_graph(2)\\n        >>> nx.wiener_index(G)\\n        inf\\n\\n    '\n    is_directed = G.is_directed()\n    if is_directed and (not is_strongly_connected(G)) or (not is_directed and (not is_connected(G))):\n        return float('inf')\n    total = sum(chaini((p.values() for (v, p) in spl(G, weight=weight))))\n    return total if is_directed else total / 2",
            "@nx._dispatch(edge_attrs='weight')\ndef wiener_index(G, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the Wiener index of the given graph.\\n\\n    The *Wiener index* of a graph is the sum of the shortest-path\\n    distances between each pair of reachable nodes. For pairs of nodes\\n    in undirected graphs, only one orientation of the pair is counted.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : object\\n        The edge attribute to use as distance when computing\\n        shortest-path distances. This is passed directly to the\\n        :func:`networkx.shortest_path_length` function.\\n\\n    Returns\\n    -------\\n    float\\n        The Wiener index of the graph `G`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph `G` is not connected.\\n\\n    Notes\\n    -----\\n    If a pair of nodes is not reachable, the distance is assumed to be\\n    infinity. This means that for graphs that are not\\n    strongly-connected, this function returns ``inf``.\\n\\n    The Wiener index is not usually defined for directed graphs, however\\n    this function uses the natural generalization of the Wiener index to\\n    directed graphs.\\n\\n    Examples\\n    --------\\n    The Wiener index of the (unweighted) complete graph on *n* nodes\\n    equals the number of pairs of the *n* nodes, since each pair of\\n    nodes is at distance one::\\n\\n        >>> n = 10\\n        >>> G = nx.complete_graph(n)\\n        >>> nx.wiener_index(G) == n * (n - 1) / 2\\n        True\\n\\n    Graphs that are not strongly-connected have infinite Wiener index::\\n\\n        >>> G = nx.empty_graph(2)\\n        >>> nx.wiener_index(G)\\n        inf\\n\\n    '\n    is_directed = G.is_directed()\n    if is_directed and (not is_strongly_connected(G)) or (not is_directed and (not is_connected(G))):\n        return float('inf')\n    total = sum(chaini((p.values() for (v, p) in spl(G, weight=weight))))\n    return total if is_directed else total / 2",
            "@nx._dispatch(edge_attrs='weight')\ndef wiener_index(G, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the Wiener index of the given graph.\\n\\n    The *Wiener index* of a graph is the sum of the shortest-path\\n    distances between each pair of reachable nodes. For pairs of nodes\\n    in undirected graphs, only one orientation of the pair is counted.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : object\\n        The edge attribute to use as distance when computing\\n        shortest-path distances. This is passed directly to the\\n        :func:`networkx.shortest_path_length` function.\\n\\n    Returns\\n    -------\\n    float\\n        The Wiener index of the graph `G`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph `G` is not connected.\\n\\n    Notes\\n    -----\\n    If a pair of nodes is not reachable, the distance is assumed to be\\n    infinity. This means that for graphs that are not\\n    strongly-connected, this function returns ``inf``.\\n\\n    The Wiener index is not usually defined for directed graphs, however\\n    this function uses the natural generalization of the Wiener index to\\n    directed graphs.\\n\\n    Examples\\n    --------\\n    The Wiener index of the (unweighted) complete graph on *n* nodes\\n    equals the number of pairs of the *n* nodes, since each pair of\\n    nodes is at distance one::\\n\\n        >>> n = 10\\n        >>> G = nx.complete_graph(n)\\n        >>> nx.wiener_index(G) == n * (n - 1) / 2\\n        True\\n\\n    Graphs that are not strongly-connected have infinite Wiener index::\\n\\n        >>> G = nx.empty_graph(2)\\n        >>> nx.wiener_index(G)\\n        inf\\n\\n    '\n    is_directed = G.is_directed()\n    if is_directed and (not is_strongly_connected(G)) or (not is_directed and (not is_connected(G))):\n        return float('inf')\n    total = sum(chaini((p.values() for (v, p) in spl(G, weight=weight))))\n    return total if is_directed else total / 2",
            "@nx._dispatch(edge_attrs='weight')\ndef wiener_index(G, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the Wiener index of the given graph.\\n\\n    The *Wiener index* of a graph is the sum of the shortest-path\\n    distances between each pair of reachable nodes. For pairs of nodes\\n    in undirected graphs, only one orientation of the pair is counted.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : object\\n        The edge attribute to use as distance when computing\\n        shortest-path distances. This is passed directly to the\\n        :func:`networkx.shortest_path_length` function.\\n\\n    Returns\\n    -------\\n    float\\n        The Wiener index of the graph `G`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph `G` is not connected.\\n\\n    Notes\\n    -----\\n    If a pair of nodes is not reachable, the distance is assumed to be\\n    infinity. This means that for graphs that are not\\n    strongly-connected, this function returns ``inf``.\\n\\n    The Wiener index is not usually defined for directed graphs, however\\n    this function uses the natural generalization of the Wiener index to\\n    directed graphs.\\n\\n    Examples\\n    --------\\n    The Wiener index of the (unweighted) complete graph on *n* nodes\\n    equals the number of pairs of the *n* nodes, since each pair of\\n    nodes is at distance one::\\n\\n        >>> n = 10\\n        >>> G = nx.complete_graph(n)\\n        >>> nx.wiener_index(G) == n * (n - 1) / 2\\n        True\\n\\n    Graphs that are not strongly-connected have infinite Wiener index::\\n\\n        >>> G = nx.empty_graph(2)\\n        >>> nx.wiener_index(G)\\n        inf\\n\\n    '\n    is_directed = G.is_directed()\n    if is_directed and (not is_strongly_connected(G)) or (not is_directed and (not is_connected(G))):\n        return float('inf')\n    total = sum(chaini((p.values() for (v, p) in spl(G, weight=weight))))\n    return total if is_directed else total / 2",
            "@nx._dispatch(edge_attrs='weight')\ndef wiener_index(G, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the Wiener index of the given graph.\\n\\n    The *Wiener index* of a graph is the sum of the shortest-path\\n    distances between each pair of reachable nodes. For pairs of nodes\\n    in undirected graphs, only one orientation of the pair is counted.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    weight : object\\n        The edge attribute to use as distance when computing\\n        shortest-path distances. This is passed directly to the\\n        :func:`networkx.shortest_path_length` function.\\n\\n    Returns\\n    -------\\n    float\\n        The Wiener index of the graph `G`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph `G` is not connected.\\n\\n    Notes\\n    -----\\n    If a pair of nodes is not reachable, the distance is assumed to be\\n    infinity. This means that for graphs that are not\\n    strongly-connected, this function returns ``inf``.\\n\\n    The Wiener index is not usually defined for directed graphs, however\\n    this function uses the natural generalization of the Wiener index to\\n    directed graphs.\\n\\n    Examples\\n    --------\\n    The Wiener index of the (unweighted) complete graph on *n* nodes\\n    equals the number of pairs of the *n* nodes, since each pair of\\n    nodes is at distance one::\\n\\n        >>> n = 10\\n        >>> G = nx.complete_graph(n)\\n        >>> nx.wiener_index(G) == n * (n - 1) / 2\\n        True\\n\\n    Graphs that are not strongly-connected have infinite Wiener index::\\n\\n        >>> G = nx.empty_graph(2)\\n        >>> nx.wiener_index(G)\\n        inf\\n\\n    '\n    is_directed = G.is_directed()\n    if is_directed and (not is_strongly_connected(G)) or (not is_directed and (not is_connected(G))):\n        return float('inf')\n    total = sum(chaini((p.values() for (v, p) in spl(G, weight=weight))))\n    return total if is_directed else total / 2"
        ]
    }
]