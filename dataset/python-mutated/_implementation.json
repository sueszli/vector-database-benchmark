[
    {
        "func_name": "_dnsname_match",
        "original": "def _dnsname_match(dn, hostname, max_wildcards=1):\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return dn.lower() == hostname.lower()\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
        "mutated": [
            "def _dnsname_match(dn, hostname, max_wildcards=1):\n    if False:\n        i = 10\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return dn.lower() == hostname.lower()\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
            "def _dnsname_match(dn, hostname, max_wildcards=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return dn.lower() == hostname.lower()\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
            "def _dnsname_match(dn, hostname, max_wildcards=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return dn.lower() == hostname.lower()\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
            "def _dnsname_match(dn, hostname, max_wildcards=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return dn.lower() == hostname.lower()\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
            "def _dnsname_match(dn, hostname, max_wildcards=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return dn.lower() == hostname.lower()\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)"
        ]
    },
    {
        "func_name": "_to_unicode",
        "original": "def _to_unicode(obj):\n    if isinstance(obj, str) and sys.version_info < (3,):\n        obj = unicode(obj, encoding='ascii', errors='strict')\n    return obj",
        "mutated": [
            "def _to_unicode(obj):\n    if False:\n        i = 10\n    if isinstance(obj, str) and sys.version_info < (3,):\n        obj = unicode(obj, encoding='ascii', errors='strict')\n    return obj",
            "def _to_unicode(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(obj, str) and sys.version_info < (3,):\n        obj = unicode(obj, encoding='ascii', errors='strict')\n    return obj",
            "def _to_unicode(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(obj, str) and sys.version_info < (3,):\n        obj = unicode(obj, encoding='ascii', errors='strict')\n    return obj",
            "def _to_unicode(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(obj, str) and sys.version_info < (3,):\n        obj = unicode(obj, encoding='ascii', errors='strict')\n    return obj",
            "def _to_unicode(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(obj, str) and sys.version_info < (3,):\n        obj = unicode(obj, encoding='ascii', errors='strict')\n    return obj"
        ]
    },
    {
        "func_name": "_ipaddress_match",
        "original": "def _ipaddress_match(ipname, host_ip):\n    \"\"\"Exact matching of IP addresses.\n\n    RFC 6125 explicitly doesn't define an algorithm for this\n    (section 1.7.2 - \"Out of Scope\").\n    \"\"\"\n    ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())\n    return ip == host_ip",
        "mutated": [
            "def _ipaddress_match(ipname, host_ip):\n    if False:\n        i = 10\n    'Exact matching of IP addresses.\\n\\n    RFC 6125 explicitly doesn\\'t define an algorithm for this\\n    (section 1.7.2 - \"Out of Scope\").\\n    '\n    ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())\n    return ip == host_ip",
            "def _ipaddress_match(ipname, host_ip):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Exact matching of IP addresses.\\n\\n    RFC 6125 explicitly doesn\\'t define an algorithm for this\\n    (section 1.7.2 - \"Out of Scope\").\\n    '\n    ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())\n    return ip == host_ip",
            "def _ipaddress_match(ipname, host_ip):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Exact matching of IP addresses.\\n\\n    RFC 6125 explicitly doesn\\'t define an algorithm for this\\n    (section 1.7.2 - \"Out of Scope\").\\n    '\n    ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())\n    return ip == host_ip",
            "def _ipaddress_match(ipname, host_ip):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Exact matching of IP addresses.\\n\\n    RFC 6125 explicitly doesn\\'t define an algorithm for this\\n    (section 1.7.2 - \"Out of Scope\").\\n    '\n    ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())\n    return ip == host_ip",
            "def _ipaddress_match(ipname, host_ip):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Exact matching of IP addresses.\\n\\n    RFC 6125 explicitly doesn\\'t define an algorithm for this\\n    (section 1.7.2 - \"Out of Scope\").\\n    '\n    ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())\n    return ip == host_ip"
        ]
    },
    {
        "func_name": "match_hostname",
        "original": "def match_hostname(cert, hostname):\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n\n    CertificateError is raised on failure. On success, the function\n    returns nothing.\n    \"\"\"\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        host_ip = ipaddress.ip_address(_to_unicode(hostname))\n    except ValueError:\n        host_ip = None\n    except UnicodeError:\n        host_ip = None\n    except AttributeError:\n        if ipaddress is None:\n            host_ip = None\n        else:\n            raise\n    dnsnames = []\n    san = cert.get('subjectAltName', ())\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r doesn't match %r\" % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError('no appropriate commonName or subjectAltName fields were found')",
        "mutated": [
            "def match_hostname(cert, hostname):\n    if False:\n        i = 10\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        host_ip = ipaddress.ip_address(_to_unicode(hostname))\n    except ValueError:\n        host_ip = None\n    except UnicodeError:\n        host_ip = None\n    except AttributeError:\n        if ipaddress is None:\n            host_ip = None\n        else:\n            raise\n    dnsnames = []\n    san = cert.get('subjectAltName', ())\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r doesn't match %r\" % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError('no appropriate commonName or subjectAltName fields were found')",
            "def match_hostname(cert, hostname):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        host_ip = ipaddress.ip_address(_to_unicode(hostname))\n    except ValueError:\n        host_ip = None\n    except UnicodeError:\n        host_ip = None\n    except AttributeError:\n        if ipaddress is None:\n            host_ip = None\n        else:\n            raise\n    dnsnames = []\n    san = cert.get('subjectAltName', ())\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r doesn't match %r\" % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError('no appropriate commonName or subjectAltName fields were found')",
            "def match_hostname(cert, hostname):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        host_ip = ipaddress.ip_address(_to_unicode(hostname))\n    except ValueError:\n        host_ip = None\n    except UnicodeError:\n        host_ip = None\n    except AttributeError:\n        if ipaddress is None:\n            host_ip = None\n        else:\n            raise\n    dnsnames = []\n    san = cert.get('subjectAltName', ())\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r doesn't match %r\" % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError('no appropriate commonName or subjectAltName fields were found')",
            "def match_hostname(cert, hostname):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        host_ip = ipaddress.ip_address(_to_unicode(hostname))\n    except ValueError:\n        host_ip = None\n    except UnicodeError:\n        host_ip = None\n    except AttributeError:\n        if ipaddress is None:\n            host_ip = None\n        else:\n            raise\n    dnsnames = []\n    san = cert.get('subjectAltName', ())\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r doesn't match %r\" % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError('no appropriate commonName or subjectAltName fields were found')",
            "def match_hostname(cert, hostname):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        host_ip = ipaddress.ip_address(_to_unicode(hostname))\n    except ValueError:\n        host_ip = None\n    except UnicodeError:\n        host_ip = None\n    except AttributeError:\n        if ipaddress is None:\n            host_ip = None\n        else:\n            raise\n    dnsnames = []\n    san = cert.get('subjectAltName', ())\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r doesn't match %r\" % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError('no appropriate commonName or subjectAltName fields were found')"
        ]
    }
]