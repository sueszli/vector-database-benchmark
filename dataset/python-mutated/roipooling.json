[
    {
        "func_name": "map_string2func",
        "original": "def map_string2func(funcname, clss):\n    \"\"\"\n    Helper function that converts string function names to function calls\n    \"\"\"\n    if funcname == 'fprop_roipooling':\n        return _get_fprop_roipooling(clss)\n    if funcname == 'bprop_roipooling':\n        return _get_bprop_roipooling(clss)\n    raise AttributeError(\"kernel type '\" + funcname + \"' not understood\")",
        "mutated": [
            "def map_string2func(funcname, clss):\n    if False:\n        i = 10\n    '\\n    Helper function that converts string function names to function calls\\n    '\n    if funcname == 'fprop_roipooling':\n        return _get_fprop_roipooling(clss)\n    if funcname == 'bprop_roipooling':\n        return _get_bprop_roipooling(clss)\n    raise AttributeError(\"kernel type '\" + funcname + \"' not understood\")",
            "def map_string2func(funcname, clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function that converts string function names to function calls\\n    '\n    if funcname == 'fprop_roipooling':\n        return _get_fprop_roipooling(clss)\n    if funcname == 'bprop_roipooling':\n        return _get_bprop_roipooling(clss)\n    raise AttributeError(\"kernel type '\" + funcname + \"' not understood\")",
            "def map_string2func(funcname, clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function that converts string function names to function calls\\n    '\n    if funcname == 'fprop_roipooling':\n        return _get_fprop_roipooling(clss)\n    if funcname == 'bprop_roipooling':\n        return _get_bprop_roipooling(clss)\n    raise AttributeError(\"kernel type '\" + funcname + \"' not understood\")",
            "def map_string2func(funcname, clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function that converts string function names to function calls\\n    '\n    if funcname == 'fprop_roipooling':\n        return _get_fprop_roipooling(clss)\n    if funcname == 'bprop_roipooling':\n        return _get_bprop_roipooling(clss)\n    raise AttributeError(\"kernel type '\" + funcname + \"' not understood\")",
            "def map_string2func(funcname, clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function that converts string function names to function calls\\n    '\n    if funcname == 'fprop_roipooling':\n        return _get_fprop_roipooling(clss)\n    if funcname == 'bprop_roipooling':\n        return _get_bprop_roipooling(clss)\n    raise AttributeError(\"kernel type '\" + funcname + \"' not understood\")"
        ]
    },
    {
        "func_name": "_get_fprop_roipooling",
        "original": "@context_dependent_memoize\ndef _get_fprop_roipooling(clss):\n    code = \"\\n#define FLT_MAX 3.402823466E+38F\\n\\n__global__ void fprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* bottom_data, const float* bottom_rois, float* top_data,\\n    int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, ph, pw, n) is an element in the pooled output\\n        int n = index % num_rois;\\n        int pw = (index / num_rois) % pooled_width;\\n        int ph = (index / num_rois / pooled_width) % pooled_height;\\n        int c = index / num_rois / pooled_width / pooled_height;\\n\\n        bottom_rois += n * 5;\\n        int roi_batch_ind = bottom_rois[0];\\n        int roi_start_w = round(bottom_rois[1] * spatial_scale);\\n        int roi_start_h = round(bottom_rois[2] * spatial_scale);\\n        int roi_end_w = round(bottom_rois[3] * spatial_scale);\\n        int roi_end_h = round(bottom_rois[4] * spatial_scale);\\n\\n        // Force malformed ROIs to be 1x1\\n        int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n        int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n        float bin_size_h = static_cast<float>(roi_height)\\n                           / static_cast<float>(pooled_height);\\n        float bin_size_w = static_cast<float>(roi_width)\\n                           / static_cast<float>(pooled_width);\\n\\n        int hstart = static_cast<int>(floor(static_cast<float>(ph)\\n                                            * bin_size_h));\\n        int wstart = static_cast<int>(floor(static_cast<float>(pw)\\n                                            * bin_size_w));\\n        int hend = static_cast<int>(ceil(static_cast<float>(ph + 1)\\n                                         * bin_size_h));\\n        int wend = static_cast<int>(ceil(static_cast<float>(pw + 1)\\n                                         * bin_size_w));\\n\\n        // Add roi offsets and clip to input boundaries\\n        hstart = min(max(hstart + roi_start_h, 0), height);\\n        hend = min(max(hend + roi_start_h, 0), height);\\n        wstart = min(max(wstart + roi_start_w, 0), width);\\n        wend = min(max(wend + roi_start_w, 0), width);\\n        bool is_empty = (hend <= hstart) || (wend <= wstart);\\n\\n        // Define an empty pooling region to be zero\\n        float maxval = is_empty ? 0 : -FLT_MAX;\\n        // If nothing is pooled, argmax = -1 causes nothing to be backprop'd\\n        int maxidx = -1;\\n\\n        bottom_data += c * height * width * img_count;\\n\\n        for (int h = hstart; h < hend; ++h) {\\n          for (int w = wstart; w < wend; ++w) {\\n            int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n            if (bottom_data[bottom_index] > maxval) {\\n              maxval = bottom_data[bottom_index];\\n              maxidx = bottom_index;\\n            }\\n          }\\n        }\\n        top_data[index] = maxval;\\n        argmax_data[index] = maxidx;\\n        // Notice the maxidx (from bottom_index) is relative to the dimension\\n        // (h, w, img_count) of the feature map, so max value is HWN\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('fprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_fprop_roipooling(clss):\n    if False:\n        i = 10\n    code = \"\\n#define FLT_MAX 3.402823466E+38F\\n\\n__global__ void fprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* bottom_data, const float* bottom_rois, float* top_data,\\n    int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, ph, pw, n) is an element in the pooled output\\n        int n = index % num_rois;\\n        int pw = (index / num_rois) % pooled_width;\\n        int ph = (index / num_rois / pooled_width) % pooled_height;\\n        int c = index / num_rois / pooled_width / pooled_height;\\n\\n        bottom_rois += n * 5;\\n        int roi_batch_ind = bottom_rois[0];\\n        int roi_start_w = round(bottom_rois[1] * spatial_scale);\\n        int roi_start_h = round(bottom_rois[2] * spatial_scale);\\n        int roi_end_w = round(bottom_rois[3] * spatial_scale);\\n        int roi_end_h = round(bottom_rois[4] * spatial_scale);\\n\\n        // Force malformed ROIs to be 1x1\\n        int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n        int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n        float bin_size_h = static_cast<float>(roi_height)\\n                           / static_cast<float>(pooled_height);\\n        float bin_size_w = static_cast<float>(roi_width)\\n                           / static_cast<float>(pooled_width);\\n\\n        int hstart = static_cast<int>(floor(static_cast<float>(ph)\\n                                            * bin_size_h));\\n        int wstart = static_cast<int>(floor(static_cast<float>(pw)\\n                                            * bin_size_w));\\n        int hend = static_cast<int>(ceil(static_cast<float>(ph + 1)\\n                                         * bin_size_h));\\n        int wend = static_cast<int>(ceil(static_cast<float>(pw + 1)\\n                                         * bin_size_w));\\n\\n        // Add roi offsets and clip to input boundaries\\n        hstart = min(max(hstart + roi_start_h, 0), height);\\n        hend = min(max(hend + roi_start_h, 0), height);\\n        wstart = min(max(wstart + roi_start_w, 0), width);\\n        wend = min(max(wend + roi_start_w, 0), width);\\n        bool is_empty = (hend <= hstart) || (wend <= wstart);\\n\\n        // Define an empty pooling region to be zero\\n        float maxval = is_empty ? 0 : -FLT_MAX;\\n        // If nothing is pooled, argmax = -1 causes nothing to be backprop'd\\n        int maxidx = -1;\\n\\n        bottom_data += c * height * width * img_count;\\n\\n        for (int h = hstart; h < hend; ++h) {\\n          for (int w = wstart; w < wend; ++w) {\\n            int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n            if (bottom_data[bottom_index] > maxval) {\\n              maxval = bottom_data[bottom_index];\\n              maxidx = bottom_index;\\n            }\\n          }\\n        }\\n        top_data[index] = maxval;\\n        argmax_data[index] = maxidx;\\n        // Notice the maxidx (from bottom_index) is relative to the dimension\\n        // (h, w, img_count) of the feature map, so max value is HWN\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('fprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
            "@context_dependent_memoize\ndef _get_fprop_roipooling(clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    code = \"\\n#define FLT_MAX 3.402823466E+38F\\n\\n__global__ void fprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* bottom_data, const float* bottom_rois, float* top_data,\\n    int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, ph, pw, n) is an element in the pooled output\\n        int n = index % num_rois;\\n        int pw = (index / num_rois) % pooled_width;\\n        int ph = (index / num_rois / pooled_width) % pooled_height;\\n        int c = index / num_rois / pooled_width / pooled_height;\\n\\n        bottom_rois += n * 5;\\n        int roi_batch_ind = bottom_rois[0];\\n        int roi_start_w = round(bottom_rois[1] * spatial_scale);\\n        int roi_start_h = round(bottom_rois[2] * spatial_scale);\\n        int roi_end_w = round(bottom_rois[3] * spatial_scale);\\n        int roi_end_h = round(bottom_rois[4] * spatial_scale);\\n\\n        // Force malformed ROIs to be 1x1\\n        int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n        int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n        float bin_size_h = static_cast<float>(roi_height)\\n                           / static_cast<float>(pooled_height);\\n        float bin_size_w = static_cast<float>(roi_width)\\n                           / static_cast<float>(pooled_width);\\n\\n        int hstart = static_cast<int>(floor(static_cast<float>(ph)\\n                                            * bin_size_h));\\n        int wstart = static_cast<int>(floor(static_cast<float>(pw)\\n                                            * bin_size_w));\\n        int hend = static_cast<int>(ceil(static_cast<float>(ph + 1)\\n                                         * bin_size_h));\\n        int wend = static_cast<int>(ceil(static_cast<float>(pw + 1)\\n                                         * bin_size_w));\\n\\n        // Add roi offsets and clip to input boundaries\\n        hstart = min(max(hstart + roi_start_h, 0), height);\\n        hend = min(max(hend + roi_start_h, 0), height);\\n        wstart = min(max(wstart + roi_start_w, 0), width);\\n        wend = min(max(wend + roi_start_w, 0), width);\\n        bool is_empty = (hend <= hstart) || (wend <= wstart);\\n\\n        // Define an empty pooling region to be zero\\n        float maxval = is_empty ? 0 : -FLT_MAX;\\n        // If nothing is pooled, argmax = -1 causes nothing to be backprop'd\\n        int maxidx = -1;\\n\\n        bottom_data += c * height * width * img_count;\\n\\n        for (int h = hstart; h < hend; ++h) {\\n          for (int w = wstart; w < wend; ++w) {\\n            int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n            if (bottom_data[bottom_index] > maxval) {\\n              maxval = bottom_data[bottom_index];\\n              maxidx = bottom_index;\\n            }\\n          }\\n        }\\n        top_data[index] = maxval;\\n        argmax_data[index] = maxidx;\\n        // Notice the maxidx (from bottom_index) is relative to the dimension\\n        // (h, w, img_count) of the feature map, so max value is HWN\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('fprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
            "@context_dependent_memoize\ndef _get_fprop_roipooling(clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    code = \"\\n#define FLT_MAX 3.402823466E+38F\\n\\n__global__ void fprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* bottom_data, const float* bottom_rois, float* top_data,\\n    int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, ph, pw, n) is an element in the pooled output\\n        int n = index % num_rois;\\n        int pw = (index / num_rois) % pooled_width;\\n        int ph = (index / num_rois / pooled_width) % pooled_height;\\n        int c = index / num_rois / pooled_width / pooled_height;\\n\\n        bottom_rois += n * 5;\\n        int roi_batch_ind = bottom_rois[0];\\n        int roi_start_w = round(bottom_rois[1] * spatial_scale);\\n        int roi_start_h = round(bottom_rois[2] * spatial_scale);\\n        int roi_end_w = round(bottom_rois[3] * spatial_scale);\\n        int roi_end_h = round(bottom_rois[4] * spatial_scale);\\n\\n        // Force malformed ROIs to be 1x1\\n        int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n        int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n        float bin_size_h = static_cast<float>(roi_height)\\n                           / static_cast<float>(pooled_height);\\n        float bin_size_w = static_cast<float>(roi_width)\\n                           / static_cast<float>(pooled_width);\\n\\n        int hstart = static_cast<int>(floor(static_cast<float>(ph)\\n                                            * bin_size_h));\\n        int wstart = static_cast<int>(floor(static_cast<float>(pw)\\n                                            * bin_size_w));\\n        int hend = static_cast<int>(ceil(static_cast<float>(ph + 1)\\n                                         * bin_size_h));\\n        int wend = static_cast<int>(ceil(static_cast<float>(pw + 1)\\n                                         * bin_size_w));\\n\\n        // Add roi offsets and clip to input boundaries\\n        hstart = min(max(hstart + roi_start_h, 0), height);\\n        hend = min(max(hend + roi_start_h, 0), height);\\n        wstart = min(max(wstart + roi_start_w, 0), width);\\n        wend = min(max(wend + roi_start_w, 0), width);\\n        bool is_empty = (hend <= hstart) || (wend <= wstart);\\n\\n        // Define an empty pooling region to be zero\\n        float maxval = is_empty ? 0 : -FLT_MAX;\\n        // If nothing is pooled, argmax = -1 causes nothing to be backprop'd\\n        int maxidx = -1;\\n\\n        bottom_data += c * height * width * img_count;\\n\\n        for (int h = hstart; h < hend; ++h) {\\n          for (int w = wstart; w < wend; ++w) {\\n            int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n            if (bottom_data[bottom_index] > maxval) {\\n              maxval = bottom_data[bottom_index];\\n              maxidx = bottom_index;\\n            }\\n          }\\n        }\\n        top_data[index] = maxval;\\n        argmax_data[index] = maxidx;\\n        // Notice the maxidx (from bottom_index) is relative to the dimension\\n        // (h, w, img_count) of the feature map, so max value is HWN\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('fprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
            "@context_dependent_memoize\ndef _get_fprop_roipooling(clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    code = \"\\n#define FLT_MAX 3.402823466E+38F\\n\\n__global__ void fprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* bottom_data, const float* bottom_rois, float* top_data,\\n    int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, ph, pw, n) is an element in the pooled output\\n        int n = index % num_rois;\\n        int pw = (index / num_rois) % pooled_width;\\n        int ph = (index / num_rois / pooled_width) % pooled_height;\\n        int c = index / num_rois / pooled_width / pooled_height;\\n\\n        bottom_rois += n * 5;\\n        int roi_batch_ind = bottom_rois[0];\\n        int roi_start_w = round(bottom_rois[1] * spatial_scale);\\n        int roi_start_h = round(bottom_rois[2] * spatial_scale);\\n        int roi_end_w = round(bottom_rois[3] * spatial_scale);\\n        int roi_end_h = round(bottom_rois[4] * spatial_scale);\\n\\n        // Force malformed ROIs to be 1x1\\n        int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n        int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n        float bin_size_h = static_cast<float>(roi_height)\\n                           / static_cast<float>(pooled_height);\\n        float bin_size_w = static_cast<float>(roi_width)\\n                           / static_cast<float>(pooled_width);\\n\\n        int hstart = static_cast<int>(floor(static_cast<float>(ph)\\n                                            * bin_size_h));\\n        int wstart = static_cast<int>(floor(static_cast<float>(pw)\\n                                            * bin_size_w));\\n        int hend = static_cast<int>(ceil(static_cast<float>(ph + 1)\\n                                         * bin_size_h));\\n        int wend = static_cast<int>(ceil(static_cast<float>(pw + 1)\\n                                         * bin_size_w));\\n\\n        // Add roi offsets and clip to input boundaries\\n        hstart = min(max(hstart + roi_start_h, 0), height);\\n        hend = min(max(hend + roi_start_h, 0), height);\\n        wstart = min(max(wstart + roi_start_w, 0), width);\\n        wend = min(max(wend + roi_start_w, 0), width);\\n        bool is_empty = (hend <= hstart) || (wend <= wstart);\\n\\n        // Define an empty pooling region to be zero\\n        float maxval = is_empty ? 0 : -FLT_MAX;\\n        // If nothing is pooled, argmax = -1 causes nothing to be backprop'd\\n        int maxidx = -1;\\n\\n        bottom_data += c * height * width * img_count;\\n\\n        for (int h = hstart; h < hend; ++h) {\\n          for (int w = wstart; w < wend; ++w) {\\n            int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n            if (bottom_data[bottom_index] > maxval) {\\n              maxval = bottom_data[bottom_index];\\n              maxidx = bottom_index;\\n            }\\n          }\\n        }\\n        top_data[index] = maxval;\\n        argmax_data[index] = maxidx;\\n        // Notice the maxidx (from bottom_index) is relative to the dimension\\n        // (h, w, img_count) of the feature map, so max value is HWN\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('fprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
            "@context_dependent_memoize\ndef _get_fprop_roipooling(clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    code = \"\\n#define FLT_MAX 3.402823466E+38F\\n\\n__global__ void fprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* bottom_data, const float* bottom_rois, float* top_data,\\n    int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, ph, pw, n) is an element in the pooled output\\n        int n = index % num_rois;\\n        int pw = (index / num_rois) % pooled_width;\\n        int ph = (index / num_rois / pooled_width) % pooled_height;\\n        int c = index / num_rois / pooled_width / pooled_height;\\n\\n        bottom_rois += n * 5;\\n        int roi_batch_ind = bottom_rois[0];\\n        int roi_start_w = round(bottom_rois[1] * spatial_scale);\\n        int roi_start_h = round(bottom_rois[2] * spatial_scale);\\n        int roi_end_w = round(bottom_rois[3] * spatial_scale);\\n        int roi_end_h = round(bottom_rois[4] * spatial_scale);\\n\\n        // Force malformed ROIs to be 1x1\\n        int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n        int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n        float bin_size_h = static_cast<float>(roi_height)\\n                           / static_cast<float>(pooled_height);\\n        float bin_size_w = static_cast<float>(roi_width)\\n                           / static_cast<float>(pooled_width);\\n\\n        int hstart = static_cast<int>(floor(static_cast<float>(ph)\\n                                            * bin_size_h));\\n        int wstart = static_cast<int>(floor(static_cast<float>(pw)\\n                                            * bin_size_w));\\n        int hend = static_cast<int>(ceil(static_cast<float>(ph + 1)\\n                                         * bin_size_h));\\n        int wend = static_cast<int>(ceil(static_cast<float>(pw + 1)\\n                                         * bin_size_w));\\n\\n        // Add roi offsets and clip to input boundaries\\n        hstart = min(max(hstart + roi_start_h, 0), height);\\n        hend = min(max(hend + roi_start_h, 0), height);\\n        wstart = min(max(wstart + roi_start_w, 0), width);\\n        wend = min(max(wend + roi_start_w, 0), width);\\n        bool is_empty = (hend <= hstart) || (wend <= wstart);\\n\\n        // Define an empty pooling region to be zero\\n        float maxval = is_empty ? 0 : -FLT_MAX;\\n        // If nothing is pooled, argmax = -1 causes nothing to be backprop'd\\n        int maxidx = -1;\\n\\n        bottom_data += c * height * width * img_count;\\n\\n        for (int h = hstart; h < hend; ++h) {\\n          for (int w = wstart; w < wend; ++w) {\\n            int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n            if (bottom_data[bottom_index] > maxval) {\\n              maxval = bottom_data[bottom_index];\\n              maxidx = bottom_index;\\n            }\\n          }\\n        }\\n        top_data[index] = maxval;\\n        argmax_data[index] = maxidx;\\n        // Notice the maxidx (from bottom_index) is relative to the dimension\\n        // (h, w, img_count) of the feature map, so max value is HWN\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('fprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel"
        ]
    },
    {
        "func_name": "_get_bprop_roipooling",
        "original": "@context_dependent_memoize\ndef _get_bprop_roipooling(clss):\n    code = \"\\n__global__ void bprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* top_diff, const float* bottom_rois, float* bottom_diff,\\n    const int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, h, w, n) coords in bottom data on feature map\\n        int n = index % img_count;\\n        int w = (index / img_count) % width;\\n        int h = (index / img_count / width) % height;\\n        int c = index / img_count/ width / height;\\n\\n        float gradient = 0;\\n        // Accumulate gradient over all ROIs that pooled this element\\n        for (int roi_n = 0; roi_n < num_rois; ++roi_n) {\\n          const float* offset_bottom_rois = bottom_rois + roi_n * 5;\\n          int roi_batch_ind = offset_bottom_rois[0];\\n          // Skip if ROI's batch index doesn't match n\\n          if (n != roi_batch_ind) {\\n            continue;\\n          }\\n\\n          int roi_start_w = round(offset_bottom_rois[1] * spatial_scale);\\n          int roi_start_h = round(offset_bottom_rois[2] * spatial_scale);\\n          int roi_end_w = round(offset_bottom_rois[3] * spatial_scale);\\n          int roi_end_h = round(offset_bottom_rois[4] * spatial_scale);\\n\\n          // Skip if ROI doesn't include (h, w)\\n          const bool in_roi = (w >= roi_start_w && w <= roi_end_w &&\\n                               h >= roi_start_h && h <= roi_end_h);\\n          if (!in_roi) {\\n            continue;\\n          }\\n\\n          int offset = c * pooled_height * pooled_width * num_rois;\\n          const float* offset_top_diff = top_diff + offset;\\n          const int* offset_argmax_data = argmax_data + offset;\\n\\n          // Compute feasible set of pooled units that could have pooled\\n          // this bottom unit\\n\\n          // Force malformed ROIs to be 1x1\\n          int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n          int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n\\n          float bin_size_h = static_cast<float>(roi_height)\\n                             / static_cast<float>(pooled_height);\\n          float bin_size_w = static_cast<float>(roi_width)\\n                             / static_cast<float>(pooled_width);\\n\\n          int phstart = floor(static_cast<float>(h - roi_start_h) / bin_size_h);\\n          int phend = ceil(static_cast<float>(h - roi_start_h + 1) / bin_size_h);\\n          int pwstart = floor(static_cast<float>(w - roi_start_w) / bin_size_w);\\n          int pwend = ceil(static_cast<float>(w - roi_start_w + 1) / bin_size_w);\\n\\n          phstart = min(max(phstart, 0), pooled_height);\\n          phend = min(max(phend, 0), pooled_height);\\n          pwstart = min(max(pwstart, 0), pooled_width);\\n          pwend = min(max(pwend, 0), pooled_width);\\n\\n          for (int ph = phstart; ph < phend; ++ph) {\\n            for (int pw = pwstart; pw < pwend; ++pw) {\\n              int top_index = ph * pooled_width * num_rois + pw * num_rois + roi_n;\\n              int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n              if (offset_argmax_data[top_index] == bottom_index) {\\n                gradient += offset_top_diff[top_index];\\n              }\\n            }\\n          }\\n        }\\n        bottom_diff[index] = gradient;\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('bprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_bprop_roipooling(clss):\n    if False:\n        i = 10\n    code = \"\\n__global__ void bprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* top_diff, const float* bottom_rois, float* bottom_diff,\\n    const int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, h, w, n) coords in bottom data on feature map\\n        int n = index % img_count;\\n        int w = (index / img_count) % width;\\n        int h = (index / img_count / width) % height;\\n        int c = index / img_count/ width / height;\\n\\n        float gradient = 0;\\n        // Accumulate gradient over all ROIs that pooled this element\\n        for (int roi_n = 0; roi_n < num_rois; ++roi_n) {\\n          const float* offset_bottom_rois = bottom_rois + roi_n * 5;\\n          int roi_batch_ind = offset_bottom_rois[0];\\n          // Skip if ROI's batch index doesn't match n\\n          if (n != roi_batch_ind) {\\n            continue;\\n          }\\n\\n          int roi_start_w = round(offset_bottom_rois[1] * spatial_scale);\\n          int roi_start_h = round(offset_bottom_rois[2] * spatial_scale);\\n          int roi_end_w = round(offset_bottom_rois[3] * spatial_scale);\\n          int roi_end_h = round(offset_bottom_rois[4] * spatial_scale);\\n\\n          // Skip if ROI doesn't include (h, w)\\n          const bool in_roi = (w >= roi_start_w && w <= roi_end_w &&\\n                               h >= roi_start_h && h <= roi_end_h);\\n          if (!in_roi) {\\n            continue;\\n          }\\n\\n          int offset = c * pooled_height * pooled_width * num_rois;\\n          const float* offset_top_diff = top_diff + offset;\\n          const int* offset_argmax_data = argmax_data + offset;\\n\\n          // Compute feasible set of pooled units that could have pooled\\n          // this bottom unit\\n\\n          // Force malformed ROIs to be 1x1\\n          int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n          int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n\\n          float bin_size_h = static_cast<float>(roi_height)\\n                             / static_cast<float>(pooled_height);\\n          float bin_size_w = static_cast<float>(roi_width)\\n                             / static_cast<float>(pooled_width);\\n\\n          int phstart = floor(static_cast<float>(h - roi_start_h) / bin_size_h);\\n          int phend = ceil(static_cast<float>(h - roi_start_h + 1) / bin_size_h);\\n          int pwstart = floor(static_cast<float>(w - roi_start_w) / bin_size_w);\\n          int pwend = ceil(static_cast<float>(w - roi_start_w + 1) / bin_size_w);\\n\\n          phstart = min(max(phstart, 0), pooled_height);\\n          phend = min(max(phend, 0), pooled_height);\\n          pwstart = min(max(pwstart, 0), pooled_width);\\n          pwend = min(max(pwend, 0), pooled_width);\\n\\n          for (int ph = phstart; ph < phend; ++ph) {\\n            for (int pw = pwstart; pw < pwend; ++pw) {\\n              int top_index = ph * pooled_width * num_rois + pw * num_rois + roi_n;\\n              int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n              if (offset_argmax_data[top_index] == bottom_index) {\\n                gradient += offset_top_diff[top_index];\\n              }\\n            }\\n          }\\n        }\\n        bottom_diff[index] = gradient;\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('bprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
            "@context_dependent_memoize\ndef _get_bprop_roipooling(clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    code = \"\\n__global__ void bprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* top_diff, const float* bottom_rois, float* bottom_diff,\\n    const int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, h, w, n) coords in bottom data on feature map\\n        int n = index % img_count;\\n        int w = (index / img_count) % width;\\n        int h = (index / img_count / width) % height;\\n        int c = index / img_count/ width / height;\\n\\n        float gradient = 0;\\n        // Accumulate gradient over all ROIs that pooled this element\\n        for (int roi_n = 0; roi_n < num_rois; ++roi_n) {\\n          const float* offset_bottom_rois = bottom_rois + roi_n * 5;\\n          int roi_batch_ind = offset_bottom_rois[0];\\n          // Skip if ROI's batch index doesn't match n\\n          if (n != roi_batch_ind) {\\n            continue;\\n          }\\n\\n          int roi_start_w = round(offset_bottom_rois[1] * spatial_scale);\\n          int roi_start_h = round(offset_bottom_rois[2] * spatial_scale);\\n          int roi_end_w = round(offset_bottom_rois[3] * spatial_scale);\\n          int roi_end_h = round(offset_bottom_rois[4] * spatial_scale);\\n\\n          // Skip if ROI doesn't include (h, w)\\n          const bool in_roi = (w >= roi_start_w && w <= roi_end_w &&\\n                               h >= roi_start_h && h <= roi_end_h);\\n          if (!in_roi) {\\n            continue;\\n          }\\n\\n          int offset = c * pooled_height * pooled_width * num_rois;\\n          const float* offset_top_diff = top_diff + offset;\\n          const int* offset_argmax_data = argmax_data + offset;\\n\\n          // Compute feasible set of pooled units that could have pooled\\n          // this bottom unit\\n\\n          // Force malformed ROIs to be 1x1\\n          int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n          int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n\\n          float bin_size_h = static_cast<float>(roi_height)\\n                             / static_cast<float>(pooled_height);\\n          float bin_size_w = static_cast<float>(roi_width)\\n                             / static_cast<float>(pooled_width);\\n\\n          int phstart = floor(static_cast<float>(h - roi_start_h) / bin_size_h);\\n          int phend = ceil(static_cast<float>(h - roi_start_h + 1) / bin_size_h);\\n          int pwstart = floor(static_cast<float>(w - roi_start_w) / bin_size_w);\\n          int pwend = ceil(static_cast<float>(w - roi_start_w + 1) / bin_size_w);\\n\\n          phstart = min(max(phstart, 0), pooled_height);\\n          phend = min(max(phend, 0), pooled_height);\\n          pwstart = min(max(pwstart, 0), pooled_width);\\n          pwend = min(max(pwend, 0), pooled_width);\\n\\n          for (int ph = phstart; ph < phend; ++ph) {\\n            for (int pw = pwstart; pw < pwend; ++pw) {\\n              int top_index = ph * pooled_width * num_rois + pw * num_rois + roi_n;\\n              int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n              if (offset_argmax_data[top_index] == bottom_index) {\\n                gradient += offset_top_diff[top_index];\\n              }\\n            }\\n          }\\n        }\\n        bottom_diff[index] = gradient;\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('bprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
            "@context_dependent_memoize\ndef _get_bprop_roipooling(clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    code = \"\\n__global__ void bprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* top_diff, const float* bottom_rois, float* bottom_diff,\\n    const int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, h, w, n) coords in bottom data on feature map\\n        int n = index % img_count;\\n        int w = (index / img_count) % width;\\n        int h = (index / img_count / width) % height;\\n        int c = index / img_count/ width / height;\\n\\n        float gradient = 0;\\n        // Accumulate gradient over all ROIs that pooled this element\\n        for (int roi_n = 0; roi_n < num_rois; ++roi_n) {\\n          const float* offset_bottom_rois = bottom_rois + roi_n * 5;\\n          int roi_batch_ind = offset_bottom_rois[0];\\n          // Skip if ROI's batch index doesn't match n\\n          if (n != roi_batch_ind) {\\n            continue;\\n          }\\n\\n          int roi_start_w = round(offset_bottom_rois[1] * spatial_scale);\\n          int roi_start_h = round(offset_bottom_rois[2] * spatial_scale);\\n          int roi_end_w = round(offset_bottom_rois[3] * spatial_scale);\\n          int roi_end_h = round(offset_bottom_rois[4] * spatial_scale);\\n\\n          // Skip if ROI doesn't include (h, w)\\n          const bool in_roi = (w >= roi_start_w && w <= roi_end_w &&\\n                               h >= roi_start_h && h <= roi_end_h);\\n          if (!in_roi) {\\n            continue;\\n          }\\n\\n          int offset = c * pooled_height * pooled_width * num_rois;\\n          const float* offset_top_diff = top_diff + offset;\\n          const int* offset_argmax_data = argmax_data + offset;\\n\\n          // Compute feasible set of pooled units that could have pooled\\n          // this bottom unit\\n\\n          // Force malformed ROIs to be 1x1\\n          int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n          int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n\\n          float bin_size_h = static_cast<float>(roi_height)\\n                             / static_cast<float>(pooled_height);\\n          float bin_size_w = static_cast<float>(roi_width)\\n                             / static_cast<float>(pooled_width);\\n\\n          int phstart = floor(static_cast<float>(h - roi_start_h) / bin_size_h);\\n          int phend = ceil(static_cast<float>(h - roi_start_h + 1) / bin_size_h);\\n          int pwstart = floor(static_cast<float>(w - roi_start_w) / bin_size_w);\\n          int pwend = ceil(static_cast<float>(w - roi_start_w + 1) / bin_size_w);\\n\\n          phstart = min(max(phstart, 0), pooled_height);\\n          phend = min(max(phend, 0), pooled_height);\\n          pwstart = min(max(pwstart, 0), pooled_width);\\n          pwend = min(max(pwend, 0), pooled_width);\\n\\n          for (int ph = phstart; ph < phend; ++ph) {\\n            for (int pw = pwstart; pw < pwend; ++pw) {\\n              int top_index = ph * pooled_width * num_rois + pw * num_rois + roi_n;\\n              int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n              if (offset_argmax_data[top_index] == bottom_index) {\\n                gradient += offset_top_diff[top_index];\\n              }\\n            }\\n          }\\n        }\\n        bottom_diff[index] = gradient;\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('bprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
            "@context_dependent_memoize\ndef _get_bprop_roipooling(clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    code = \"\\n__global__ void bprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* top_diff, const float* bottom_rois, float* bottom_diff,\\n    const int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, h, w, n) coords in bottom data on feature map\\n        int n = index % img_count;\\n        int w = (index / img_count) % width;\\n        int h = (index / img_count / width) % height;\\n        int c = index / img_count/ width / height;\\n\\n        float gradient = 0;\\n        // Accumulate gradient over all ROIs that pooled this element\\n        for (int roi_n = 0; roi_n < num_rois; ++roi_n) {\\n          const float* offset_bottom_rois = bottom_rois + roi_n * 5;\\n          int roi_batch_ind = offset_bottom_rois[0];\\n          // Skip if ROI's batch index doesn't match n\\n          if (n != roi_batch_ind) {\\n            continue;\\n          }\\n\\n          int roi_start_w = round(offset_bottom_rois[1] * spatial_scale);\\n          int roi_start_h = round(offset_bottom_rois[2] * spatial_scale);\\n          int roi_end_w = round(offset_bottom_rois[3] * spatial_scale);\\n          int roi_end_h = round(offset_bottom_rois[4] * spatial_scale);\\n\\n          // Skip if ROI doesn't include (h, w)\\n          const bool in_roi = (w >= roi_start_w && w <= roi_end_w &&\\n                               h >= roi_start_h && h <= roi_end_h);\\n          if (!in_roi) {\\n            continue;\\n          }\\n\\n          int offset = c * pooled_height * pooled_width * num_rois;\\n          const float* offset_top_diff = top_diff + offset;\\n          const int* offset_argmax_data = argmax_data + offset;\\n\\n          // Compute feasible set of pooled units that could have pooled\\n          // this bottom unit\\n\\n          // Force malformed ROIs to be 1x1\\n          int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n          int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n\\n          float bin_size_h = static_cast<float>(roi_height)\\n                             / static_cast<float>(pooled_height);\\n          float bin_size_w = static_cast<float>(roi_width)\\n                             / static_cast<float>(pooled_width);\\n\\n          int phstart = floor(static_cast<float>(h - roi_start_h) / bin_size_h);\\n          int phend = ceil(static_cast<float>(h - roi_start_h + 1) / bin_size_h);\\n          int pwstart = floor(static_cast<float>(w - roi_start_w) / bin_size_w);\\n          int pwend = ceil(static_cast<float>(w - roi_start_w + 1) / bin_size_w);\\n\\n          phstart = min(max(phstart, 0), pooled_height);\\n          phend = min(max(phend, 0), pooled_height);\\n          pwstart = min(max(pwstart, 0), pooled_width);\\n          pwend = min(max(pwend, 0), pooled_width);\\n\\n          for (int ph = phstart; ph < phend; ++ph) {\\n            for (int pw = pwstart; pw < pwend; ++pw) {\\n              int top_index = ph * pooled_width * num_rois + pw * num_rois + roi_n;\\n              int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n              if (offset_argmax_data[top_index] == bottom_index) {\\n                gradient += offset_top_diff[top_index];\\n              }\\n            }\\n          }\\n        }\\n        bottom_diff[index] = gradient;\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('bprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel",
            "@context_dependent_memoize\ndef _get_bprop_roipooling(clss):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    code = \"\\n__global__ void bprop_roipooling(const int nthreads,\\n    const int num_rois, const int img_count,\\n    const int channels, const int height, const int width,\\n    const int pooled_height, const int pooled_width,\\n    const float* top_diff, const float* bottom_rois, float* bottom_diff,\\n    const int* argmax_data, const float spatial_scale) {\\n    for (int index = blockIdx.x * blockDim.x + threadIdx.x; \\\\\\n        index < (nthreads); index += blockDim.x * gridDim.x){\\n        // (c, h, w, n) coords in bottom data on feature map\\n        int n = index % img_count;\\n        int w = (index / img_count) % width;\\n        int h = (index / img_count / width) % height;\\n        int c = index / img_count/ width / height;\\n\\n        float gradient = 0;\\n        // Accumulate gradient over all ROIs that pooled this element\\n        for (int roi_n = 0; roi_n < num_rois; ++roi_n) {\\n          const float* offset_bottom_rois = bottom_rois + roi_n * 5;\\n          int roi_batch_ind = offset_bottom_rois[0];\\n          // Skip if ROI's batch index doesn't match n\\n          if (n != roi_batch_ind) {\\n            continue;\\n          }\\n\\n          int roi_start_w = round(offset_bottom_rois[1] * spatial_scale);\\n          int roi_start_h = round(offset_bottom_rois[2] * spatial_scale);\\n          int roi_end_w = round(offset_bottom_rois[3] * spatial_scale);\\n          int roi_end_h = round(offset_bottom_rois[4] * spatial_scale);\\n\\n          // Skip if ROI doesn't include (h, w)\\n          const bool in_roi = (w >= roi_start_w && w <= roi_end_w &&\\n                               h >= roi_start_h && h <= roi_end_h);\\n          if (!in_roi) {\\n            continue;\\n          }\\n\\n          int offset = c * pooled_height * pooled_width * num_rois;\\n          const float* offset_top_diff = top_diff + offset;\\n          const int* offset_argmax_data = argmax_data + offset;\\n\\n          // Compute feasible set of pooled units that could have pooled\\n          // this bottom unit\\n\\n          // Force malformed ROIs to be 1x1\\n          int roi_width = max(roi_end_w - roi_start_w + 1, 1);\\n          int roi_height = max(roi_end_h - roi_start_h + 1, 1);\\n\\n          float bin_size_h = static_cast<float>(roi_height)\\n                             / static_cast<float>(pooled_height);\\n          float bin_size_w = static_cast<float>(roi_width)\\n                             / static_cast<float>(pooled_width);\\n\\n          int phstart = floor(static_cast<float>(h - roi_start_h) / bin_size_h);\\n          int phend = ceil(static_cast<float>(h - roi_start_h + 1) / bin_size_h);\\n          int pwstart = floor(static_cast<float>(w - roi_start_w) / bin_size_w);\\n          int pwend = ceil(static_cast<float>(w - roi_start_w + 1) / bin_size_w);\\n\\n          phstart = min(max(phstart, 0), pooled_height);\\n          phend = min(max(phend, 0), pooled_height);\\n          pwstart = min(max(pwstart, 0), pooled_width);\\n          pwend = min(max(pwend, 0), pooled_width);\\n\\n          for (int ph = phstart; ph < phend; ++ph) {\\n            for (int pw = pwstart; pw < pwend; ++pw) {\\n              int top_index = ph * pooled_width * num_rois + pw * num_rois + roi_n;\\n              int bottom_index = h * width * img_count + w * img_count + roi_batch_ind;\\n              if (offset_argmax_data[top_index] == bottom_index) {\\n                gradient += offset_top_diff[top_index];\\n              }\\n            }\\n          }\\n        }\\n        bottom_diff[index] = gradient;\\n    }\\n}\\n\\n\"\n    module = SourceModule(code)\n    kernel = module.get_function('bprop_roipooling')\n    sig = '8I 4P 1f'\n    kernel.prepare(sig)\n    return kernel"
        ]
    }
]