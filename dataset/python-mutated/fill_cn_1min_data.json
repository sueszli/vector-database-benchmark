[
    {
        "func_name": "get_date_range",
        "original": "def get_date_range(data_1min_dir: Path, max_workers: int=16, date_field_name: str='date'):\n    csv_files = list(data_1min_dir.glob('*.csv'))\n    min_date = None\n    max_date = None\n    with tqdm(total=len(csv_files)) as p_bar:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for (_file, _result) in zip(csv_files, executor.map(pd.read_csv, csv_files)):\n                if not _result.empty:\n                    _dates = pd.to_datetime(_result[date_field_name])\n                    _tmp_min = _dates.min()\n                    min_date = min(min_date, _tmp_min) if min_date is not None else _tmp_min\n                    _tmp_max = _dates.max()\n                    max_date = max(max_date, _tmp_max) if max_date is not None else _tmp_max\n                p_bar.update()\n    return (min_date, max_date)",
        "mutated": [
            "def get_date_range(data_1min_dir: Path, max_workers: int=16, date_field_name: str='date'):\n    if False:\n        i = 10\n    csv_files = list(data_1min_dir.glob('*.csv'))\n    min_date = None\n    max_date = None\n    with tqdm(total=len(csv_files)) as p_bar:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for (_file, _result) in zip(csv_files, executor.map(pd.read_csv, csv_files)):\n                if not _result.empty:\n                    _dates = pd.to_datetime(_result[date_field_name])\n                    _tmp_min = _dates.min()\n                    min_date = min(min_date, _tmp_min) if min_date is not None else _tmp_min\n                    _tmp_max = _dates.max()\n                    max_date = max(max_date, _tmp_max) if max_date is not None else _tmp_max\n                p_bar.update()\n    return (min_date, max_date)",
            "def get_date_range(data_1min_dir: Path, max_workers: int=16, date_field_name: str='date'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    csv_files = list(data_1min_dir.glob('*.csv'))\n    min_date = None\n    max_date = None\n    with tqdm(total=len(csv_files)) as p_bar:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for (_file, _result) in zip(csv_files, executor.map(pd.read_csv, csv_files)):\n                if not _result.empty:\n                    _dates = pd.to_datetime(_result[date_field_name])\n                    _tmp_min = _dates.min()\n                    min_date = min(min_date, _tmp_min) if min_date is not None else _tmp_min\n                    _tmp_max = _dates.max()\n                    max_date = max(max_date, _tmp_max) if max_date is not None else _tmp_max\n                p_bar.update()\n    return (min_date, max_date)",
            "def get_date_range(data_1min_dir: Path, max_workers: int=16, date_field_name: str='date'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    csv_files = list(data_1min_dir.glob('*.csv'))\n    min_date = None\n    max_date = None\n    with tqdm(total=len(csv_files)) as p_bar:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for (_file, _result) in zip(csv_files, executor.map(pd.read_csv, csv_files)):\n                if not _result.empty:\n                    _dates = pd.to_datetime(_result[date_field_name])\n                    _tmp_min = _dates.min()\n                    min_date = min(min_date, _tmp_min) if min_date is not None else _tmp_min\n                    _tmp_max = _dates.max()\n                    max_date = max(max_date, _tmp_max) if max_date is not None else _tmp_max\n                p_bar.update()\n    return (min_date, max_date)",
            "def get_date_range(data_1min_dir: Path, max_workers: int=16, date_field_name: str='date'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    csv_files = list(data_1min_dir.glob('*.csv'))\n    min_date = None\n    max_date = None\n    with tqdm(total=len(csv_files)) as p_bar:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for (_file, _result) in zip(csv_files, executor.map(pd.read_csv, csv_files)):\n                if not _result.empty:\n                    _dates = pd.to_datetime(_result[date_field_name])\n                    _tmp_min = _dates.min()\n                    min_date = min(min_date, _tmp_min) if min_date is not None else _tmp_min\n                    _tmp_max = _dates.max()\n                    max_date = max(max_date, _tmp_max) if max_date is not None else _tmp_max\n                p_bar.update()\n    return (min_date, max_date)",
            "def get_date_range(data_1min_dir: Path, max_workers: int=16, date_field_name: str='date'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    csv_files = list(data_1min_dir.glob('*.csv'))\n    min_date = None\n    max_date = None\n    with tqdm(total=len(csv_files)) as p_bar:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for (_file, _result) in zip(csv_files, executor.map(pd.read_csv, csv_files)):\n                if not _result.empty:\n                    _dates = pd.to_datetime(_result[date_field_name])\n                    _tmp_min = _dates.min()\n                    min_date = min(min_date, _tmp_min) if min_date is not None else _tmp_min\n                    _tmp_max = _dates.max()\n                    max_date = max(max_date, _tmp_max) if max_date is not None else _tmp_max\n                p_bar.update()\n    return (min_date, max_date)"
        ]
    },
    {
        "func_name": "get_symbols",
        "original": "def get_symbols(data_1min_dir: Path):\n    return list(map(lambda x: x.name[:-4].upper(), data_1min_dir.glob('*.csv')))",
        "mutated": [
            "def get_symbols(data_1min_dir: Path):\n    if False:\n        i = 10\n    return list(map(lambda x: x.name[:-4].upper(), data_1min_dir.glob('*.csv')))",
            "def get_symbols(data_1min_dir: Path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return list(map(lambda x: x.name[:-4].upper(), data_1min_dir.glob('*.csv')))",
            "def get_symbols(data_1min_dir: Path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return list(map(lambda x: x.name[:-4].upper(), data_1min_dir.glob('*.csv')))",
            "def get_symbols(data_1min_dir: Path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return list(map(lambda x: x.name[:-4].upper(), data_1min_dir.glob('*.csv')))",
            "def get_symbols(data_1min_dir: Path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return list(map(lambda x: x.name[:-4].upper(), data_1min_dir.glob('*.csv')))"
        ]
    },
    {
        "func_name": "fill_1min_using_1d",
        "original": "def fill_1min_using_1d(data_1min_dir: [str, Path], qlib_data_1d_dir: [str, Path], max_workers: int=16, date_field_name: str='date', symbol_field_name: str='symbol'):\n    \"\"\"Use 1d data to fill in the missing symbols relative to 1min\n\n    Parameters\n    ----------\n    data_1min_dir: str\n        1min data dir\n    qlib_data_1d_dir: str\n        1d qlib data(bin data) dir, from: https://qlib.readthedocs.io/en/latest/component/data.html#converting-csv-format-into-qlib-format\n    max_workers: int\n        ThreadPoolExecutor(max_workers), by default 16\n    date_field_name: str\n        date field name, by default date\n    symbol_field_name: str\n        symbol field name, by default symbol\n\n    \"\"\"\n    data_1min_dir = Path(data_1min_dir).expanduser().resolve()\n    qlib_data_1d_dir = Path(qlib_data_1d_dir).expanduser().resolve()\n    (min_date, max_date) = get_date_range(data_1min_dir, max_workers, date_field_name)\n    symbols_1min = get_symbols(data_1min_dir)\n    qlib.init(provider_uri=str(qlib_data_1d_dir))\n    data_1d = D.features(D.instruments('all'), ['$close'], min_date, max_date, freq='day')\n    miss_symbols = set(data_1d.index.get_level_values(level='instrument').unique()) - set(symbols_1min)\n    if not miss_symbols:\n        logger.warning('More symbols in 1min than 1d, no padding required')\n        return\n    logger.info(f'miss_symbols  {len(miss_symbols)}: {miss_symbols}')\n    tmp_df = pd.read_csv(list(data_1min_dir.glob('*.csv'))[0])\n    columns = tmp_df.columns\n    _si = tmp_df[symbol_field_name].first_valid_index()\n    is_lower = tmp_df.loc[_si][symbol_field_name].islower()\n    for symbol in tqdm(miss_symbols):\n        if is_lower:\n            symbol = symbol.lower()\n        index_1d = data_1d.loc(axis=0)[symbol.upper()].index\n        index_1min = generate_minutes_calendar_from_daily(index_1d)\n        index_1min.name = date_field_name\n        _df = pd.DataFrame(columns=columns, index=index_1min)\n        if date_field_name in _df.columns:\n            del _df[date_field_name]\n        _df.reset_index(inplace=True)\n        _df[symbol_field_name] = symbol\n        _df['paused_num'] = 0\n        _df.to_csv(data_1min_dir.joinpath(f'{symbol}.csv'), index=False)",
        "mutated": [
            "def fill_1min_using_1d(data_1min_dir: [str, Path], qlib_data_1d_dir: [str, Path], max_workers: int=16, date_field_name: str='date', symbol_field_name: str='symbol'):\n    if False:\n        i = 10\n    'Use 1d data to fill in the missing symbols relative to 1min\\n\\n    Parameters\\n    ----------\\n    data_1min_dir: str\\n        1min data dir\\n    qlib_data_1d_dir: str\\n        1d qlib data(bin data) dir, from: https://qlib.readthedocs.io/en/latest/component/data.html#converting-csv-format-into-qlib-format\\n    max_workers: int\\n        ThreadPoolExecutor(max_workers), by default 16\\n    date_field_name: str\\n        date field name, by default date\\n    symbol_field_name: str\\n        symbol field name, by default symbol\\n\\n    '\n    data_1min_dir = Path(data_1min_dir).expanduser().resolve()\n    qlib_data_1d_dir = Path(qlib_data_1d_dir).expanduser().resolve()\n    (min_date, max_date) = get_date_range(data_1min_dir, max_workers, date_field_name)\n    symbols_1min = get_symbols(data_1min_dir)\n    qlib.init(provider_uri=str(qlib_data_1d_dir))\n    data_1d = D.features(D.instruments('all'), ['$close'], min_date, max_date, freq='day')\n    miss_symbols = set(data_1d.index.get_level_values(level='instrument').unique()) - set(symbols_1min)\n    if not miss_symbols:\n        logger.warning('More symbols in 1min than 1d, no padding required')\n        return\n    logger.info(f'miss_symbols  {len(miss_symbols)}: {miss_symbols}')\n    tmp_df = pd.read_csv(list(data_1min_dir.glob('*.csv'))[0])\n    columns = tmp_df.columns\n    _si = tmp_df[symbol_field_name].first_valid_index()\n    is_lower = tmp_df.loc[_si][symbol_field_name].islower()\n    for symbol in tqdm(miss_symbols):\n        if is_lower:\n            symbol = symbol.lower()\n        index_1d = data_1d.loc(axis=0)[symbol.upper()].index\n        index_1min = generate_minutes_calendar_from_daily(index_1d)\n        index_1min.name = date_field_name\n        _df = pd.DataFrame(columns=columns, index=index_1min)\n        if date_field_name in _df.columns:\n            del _df[date_field_name]\n        _df.reset_index(inplace=True)\n        _df[symbol_field_name] = symbol\n        _df['paused_num'] = 0\n        _df.to_csv(data_1min_dir.joinpath(f'{symbol}.csv'), index=False)",
            "def fill_1min_using_1d(data_1min_dir: [str, Path], qlib_data_1d_dir: [str, Path], max_workers: int=16, date_field_name: str='date', symbol_field_name: str='symbol'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Use 1d data to fill in the missing symbols relative to 1min\\n\\n    Parameters\\n    ----------\\n    data_1min_dir: str\\n        1min data dir\\n    qlib_data_1d_dir: str\\n        1d qlib data(bin data) dir, from: https://qlib.readthedocs.io/en/latest/component/data.html#converting-csv-format-into-qlib-format\\n    max_workers: int\\n        ThreadPoolExecutor(max_workers), by default 16\\n    date_field_name: str\\n        date field name, by default date\\n    symbol_field_name: str\\n        symbol field name, by default symbol\\n\\n    '\n    data_1min_dir = Path(data_1min_dir).expanduser().resolve()\n    qlib_data_1d_dir = Path(qlib_data_1d_dir).expanduser().resolve()\n    (min_date, max_date) = get_date_range(data_1min_dir, max_workers, date_field_name)\n    symbols_1min = get_symbols(data_1min_dir)\n    qlib.init(provider_uri=str(qlib_data_1d_dir))\n    data_1d = D.features(D.instruments('all'), ['$close'], min_date, max_date, freq='day')\n    miss_symbols = set(data_1d.index.get_level_values(level='instrument').unique()) - set(symbols_1min)\n    if not miss_symbols:\n        logger.warning('More symbols in 1min than 1d, no padding required')\n        return\n    logger.info(f'miss_symbols  {len(miss_symbols)}: {miss_symbols}')\n    tmp_df = pd.read_csv(list(data_1min_dir.glob('*.csv'))[0])\n    columns = tmp_df.columns\n    _si = tmp_df[symbol_field_name].first_valid_index()\n    is_lower = tmp_df.loc[_si][symbol_field_name].islower()\n    for symbol in tqdm(miss_symbols):\n        if is_lower:\n            symbol = symbol.lower()\n        index_1d = data_1d.loc(axis=0)[symbol.upper()].index\n        index_1min = generate_minutes_calendar_from_daily(index_1d)\n        index_1min.name = date_field_name\n        _df = pd.DataFrame(columns=columns, index=index_1min)\n        if date_field_name in _df.columns:\n            del _df[date_field_name]\n        _df.reset_index(inplace=True)\n        _df[symbol_field_name] = symbol\n        _df['paused_num'] = 0\n        _df.to_csv(data_1min_dir.joinpath(f'{symbol}.csv'), index=False)",
            "def fill_1min_using_1d(data_1min_dir: [str, Path], qlib_data_1d_dir: [str, Path], max_workers: int=16, date_field_name: str='date', symbol_field_name: str='symbol'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Use 1d data to fill in the missing symbols relative to 1min\\n\\n    Parameters\\n    ----------\\n    data_1min_dir: str\\n        1min data dir\\n    qlib_data_1d_dir: str\\n        1d qlib data(bin data) dir, from: https://qlib.readthedocs.io/en/latest/component/data.html#converting-csv-format-into-qlib-format\\n    max_workers: int\\n        ThreadPoolExecutor(max_workers), by default 16\\n    date_field_name: str\\n        date field name, by default date\\n    symbol_field_name: str\\n        symbol field name, by default symbol\\n\\n    '\n    data_1min_dir = Path(data_1min_dir).expanduser().resolve()\n    qlib_data_1d_dir = Path(qlib_data_1d_dir).expanduser().resolve()\n    (min_date, max_date) = get_date_range(data_1min_dir, max_workers, date_field_name)\n    symbols_1min = get_symbols(data_1min_dir)\n    qlib.init(provider_uri=str(qlib_data_1d_dir))\n    data_1d = D.features(D.instruments('all'), ['$close'], min_date, max_date, freq='day')\n    miss_symbols = set(data_1d.index.get_level_values(level='instrument').unique()) - set(symbols_1min)\n    if not miss_symbols:\n        logger.warning('More symbols in 1min than 1d, no padding required')\n        return\n    logger.info(f'miss_symbols  {len(miss_symbols)}: {miss_symbols}')\n    tmp_df = pd.read_csv(list(data_1min_dir.glob('*.csv'))[0])\n    columns = tmp_df.columns\n    _si = tmp_df[symbol_field_name].first_valid_index()\n    is_lower = tmp_df.loc[_si][symbol_field_name].islower()\n    for symbol in tqdm(miss_symbols):\n        if is_lower:\n            symbol = symbol.lower()\n        index_1d = data_1d.loc(axis=0)[symbol.upper()].index\n        index_1min = generate_minutes_calendar_from_daily(index_1d)\n        index_1min.name = date_field_name\n        _df = pd.DataFrame(columns=columns, index=index_1min)\n        if date_field_name in _df.columns:\n            del _df[date_field_name]\n        _df.reset_index(inplace=True)\n        _df[symbol_field_name] = symbol\n        _df['paused_num'] = 0\n        _df.to_csv(data_1min_dir.joinpath(f'{symbol}.csv'), index=False)",
            "def fill_1min_using_1d(data_1min_dir: [str, Path], qlib_data_1d_dir: [str, Path], max_workers: int=16, date_field_name: str='date', symbol_field_name: str='symbol'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Use 1d data to fill in the missing symbols relative to 1min\\n\\n    Parameters\\n    ----------\\n    data_1min_dir: str\\n        1min data dir\\n    qlib_data_1d_dir: str\\n        1d qlib data(bin data) dir, from: https://qlib.readthedocs.io/en/latest/component/data.html#converting-csv-format-into-qlib-format\\n    max_workers: int\\n        ThreadPoolExecutor(max_workers), by default 16\\n    date_field_name: str\\n        date field name, by default date\\n    symbol_field_name: str\\n        symbol field name, by default symbol\\n\\n    '\n    data_1min_dir = Path(data_1min_dir).expanduser().resolve()\n    qlib_data_1d_dir = Path(qlib_data_1d_dir).expanduser().resolve()\n    (min_date, max_date) = get_date_range(data_1min_dir, max_workers, date_field_name)\n    symbols_1min = get_symbols(data_1min_dir)\n    qlib.init(provider_uri=str(qlib_data_1d_dir))\n    data_1d = D.features(D.instruments('all'), ['$close'], min_date, max_date, freq='day')\n    miss_symbols = set(data_1d.index.get_level_values(level='instrument').unique()) - set(symbols_1min)\n    if not miss_symbols:\n        logger.warning('More symbols in 1min than 1d, no padding required')\n        return\n    logger.info(f'miss_symbols  {len(miss_symbols)}: {miss_symbols}')\n    tmp_df = pd.read_csv(list(data_1min_dir.glob('*.csv'))[0])\n    columns = tmp_df.columns\n    _si = tmp_df[symbol_field_name].first_valid_index()\n    is_lower = tmp_df.loc[_si][symbol_field_name].islower()\n    for symbol in tqdm(miss_symbols):\n        if is_lower:\n            symbol = symbol.lower()\n        index_1d = data_1d.loc(axis=0)[symbol.upper()].index\n        index_1min = generate_minutes_calendar_from_daily(index_1d)\n        index_1min.name = date_field_name\n        _df = pd.DataFrame(columns=columns, index=index_1min)\n        if date_field_name in _df.columns:\n            del _df[date_field_name]\n        _df.reset_index(inplace=True)\n        _df[symbol_field_name] = symbol\n        _df['paused_num'] = 0\n        _df.to_csv(data_1min_dir.joinpath(f'{symbol}.csv'), index=False)",
            "def fill_1min_using_1d(data_1min_dir: [str, Path], qlib_data_1d_dir: [str, Path], max_workers: int=16, date_field_name: str='date', symbol_field_name: str='symbol'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Use 1d data to fill in the missing symbols relative to 1min\\n\\n    Parameters\\n    ----------\\n    data_1min_dir: str\\n        1min data dir\\n    qlib_data_1d_dir: str\\n        1d qlib data(bin data) dir, from: https://qlib.readthedocs.io/en/latest/component/data.html#converting-csv-format-into-qlib-format\\n    max_workers: int\\n        ThreadPoolExecutor(max_workers), by default 16\\n    date_field_name: str\\n        date field name, by default date\\n    symbol_field_name: str\\n        symbol field name, by default symbol\\n\\n    '\n    data_1min_dir = Path(data_1min_dir).expanduser().resolve()\n    qlib_data_1d_dir = Path(qlib_data_1d_dir).expanduser().resolve()\n    (min_date, max_date) = get_date_range(data_1min_dir, max_workers, date_field_name)\n    symbols_1min = get_symbols(data_1min_dir)\n    qlib.init(provider_uri=str(qlib_data_1d_dir))\n    data_1d = D.features(D.instruments('all'), ['$close'], min_date, max_date, freq='day')\n    miss_symbols = set(data_1d.index.get_level_values(level='instrument').unique()) - set(symbols_1min)\n    if not miss_symbols:\n        logger.warning('More symbols in 1min than 1d, no padding required')\n        return\n    logger.info(f'miss_symbols  {len(miss_symbols)}: {miss_symbols}')\n    tmp_df = pd.read_csv(list(data_1min_dir.glob('*.csv'))[0])\n    columns = tmp_df.columns\n    _si = tmp_df[symbol_field_name].first_valid_index()\n    is_lower = tmp_df.loc[_si][symbol_field_name].islower()\n    for symbol in tqdm(miss_symbols):\n        if is_lower:\n            symbol = symbol.lower()\n        index_1d = data_1d.loc(axis=0)[symbol.upper()].index\n        index_1min = generate_minutes_calendar_from_daily(index_1d)\n        index_1min.name = date_field_name\n        _df = pd.DataFrame(columns=columns, index=index_1min)\n        if date_field_name in _df.columns:\n            del _df[date_field_name]\n        _df.reset_index(inplace=True)\n        _df[symbol_field_name] = symbol\n        _df['paused_num'] = 0\n        _df.to_csv(data_1min_dir.joinpath(f'{symbol}.csv'), index=False)"
        ]
    }
]