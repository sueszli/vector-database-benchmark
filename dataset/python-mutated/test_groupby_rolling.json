[
    {
        "func_name": "test_rolling",
        "original": "@given(period=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), offset=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit)\ndef test_rolling(period: str, offset: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit) -> None:\n    assume(period != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)], min_size=1))\n    df = dataframe.sort('ts')\n    result = df.rolling('ts', period=period, offset=offset, closed=closed).agg(pl.col('value'))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset), pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset).dt.offset_by(period), closed=closed))\n        value = window['value'].to_list()\n        expected_dict['ts'].append(ts)\n        expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(pl.List(pl.Int64)))\n    assert_frame_equal(result, expected)",
        "mutated": [
            "@given(period=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), offset=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit)\ndef test_rolling(period: str, offset: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit) -> None:\n    if False:\n        i = 10\n    assume(period != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)], min_size=1))\n    df = dataframe.sort('ts')\n    result = df.rolling('ts', period=period, offset=offset, closed=closed).agg(pl.col('value'))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset), pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset).dt.offset_by(period), closed=closed))\n        value = window['value'].to_list()\n        expected_dict['ts'].append(ts)\n        expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(pl.List(pl.Int64)))\n    assert_frame_equal(result, expected)",
            "@given(period=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), offset=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit)\ndef test_rolling(period: str, offset: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assume(period != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)], min_size=1))\n    df = dataframe.sort('ts')\n    result = df.rolling('ts', period=period, offset=offset, closed=closed).agg(pl.col('value'))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset), pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset).dt.offset_by(period), closed=closed))\n        value = window['value'].to_list()\n        expected_dict['ts'].append(ts)\n        expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(pl.List(pl.Int64)))\n    assert_frame_equal(result, expected)",
            "@given(period=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), offset=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit)\ndef test_rolling(period: str, offset: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assume(period != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)], min_size=1))\n    df = dataframe.sort('ts')\n    result = df.rolling('ts', period=period, offset=offset, closed=closed).agg(pl.col('value'))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset), pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset).dt.offset_by(period), closed=closed))\n        value = window['value'].to_list()\n        expected_dict['ts'].append(ts)\n        expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(pl.List(pl.Int64)))\n    assert_frame_equal(result, expected)",
            "@given(period=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), offset=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit)\ndef test_rolling(period: str, offset: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assume(period != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)], min_size=1))\n    df = dataframe.sort('ts')\n    result = df.rolling('ts', period=period, offset=offset, closed=closed).agg(pl.col('value'))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset), pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset).dt.offset_by(period), closed=closed))\n        value = window['value'].to_list()\n        expected_dict['ts'].append(ts)\n        expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(pl.List(pl.Int64)))\n    assert_frame_equal(result, expected)",
            "@given(period=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), offset=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=1000)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit)\ndef test_rolling(period: str, offset: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assume(period != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)], min_size=1))\n    df = dataframe.sort('ts')\n    result = df.rolling('ts', period=period, offset=offset, closed=closed).agg(pl.col('value'))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset), pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(offset).dt.offset_by(period), closed=closed))\n        value = window['value'].to_list()\n        expected_dict['ts'].append(ts)\n        expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(pl.List(pl.Int64)))\n    assert_frame_equal(result, expected)"
        ]
    },
    {
        "func_name": "test_rolling_aggs",
        "original": "@given(window_size=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=2)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit, aggregation=st.sampled_from(['min', 'max', 'mean', 'sum', 'median']))\ndef test_rolling_aggs(window_size: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit, aggregation: str) -> None:\n    assume(window_size != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)]))\n    df = dataframe.sort('ts')\n    func = f'rolling_{aggregation}'\n    result = df.with_columns(getattr(pl.col('value'), func)(window_size=window_size, by='ts', closed=closed))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(f'-{window_size}'), pl.lit(ts, dtype=pl.Datetime(time_unit)), closed=closed))\n        expected_dict['ts'].append(ts)\n        if window.is_empty():\n            expected_dict['value'].append(None)\n        else:\n            value = getattr(window['value'], aggregation)()\n            expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(result['value'].dtype))\n    assert_frame_equal(result, expected)",
        "mutated": [
            "@given(window_size=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=2)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit, aggregation=st.sampled_from(['min', 'max', 'mean', 'sum', 'median']))\ndef test_rolling_aggs(window_size: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit, aggregation: str) -> None:\n    if False:\n        i = 10\n    assume(window_size != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)]))\n    df = dataframe.sort('ts')\n    func = f'rolling_{aggregation}'\n    result = df.with_columns(getattr(pl.col('value'), func)(window_size=window_size, by='ts', closed=closed))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(f'-{window_size}'), pl.lit(ts, dtype=pl.Datetime(time_unit)), closed=closed))\n        expected_dict['ts'].append(ts)\n        if window.is_empty():\n            expected_dict['value'].append(None)\n        else:\n            value = getattr(window['value'], aggregation)()\n            expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(result['value'].dtype))\n    assert_frame_equal(result, expected)",
            "@given(window_size=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=2)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit, aggregation=st.sampled_from(['min', 'max', 'mean', 'sum', 'median']))\ndef test_rolling_aggs(window_size: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit, aggregation: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assume(window_size != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)]))\n    df = dataframe.sort('ts')\n    func = f'rolling_{aggregation}'\n    result = df.with_columns(getattr(pl.col('value'), func)(window_size=window_size, by='ts', closed=closed))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(f'-{window_size}'), pl.lit(ts, dtype=pl.Datetime(time_unit)), closed=closed))\n        expected_dict['ts'].append(ts)\n        if window.is_empty():\n            expected_dict['value'].append(None)\n        else:\n            value = getattr(window['value'], aggregation)()\n            expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(result['value'].dtype))\n    assert_frame_equal(result, expected)",
            "@given(window_size=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=2)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit, aggregation=st.sampled_from(['min', 'max', 'mean', 'sum', 'median']))\ndef test_rolling_aggs(window_size: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit, aggregation: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assume(window_size != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)]))\n    df = dataframe.sort('ts')\n    func = f'rolling_{aggregation}'\n    result = df.with_columns(getattr(pl.col('value'), func)(window_size=window_size, by='ts', closed=closed))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(f'-{window_size}'), pl.lit(ts, dtype=pl.Datetime(time_unit)), closed=closed))\n        expected_dict['ts'].append(ts)\n        if window.is_empty():\n            expected_dict['value'].append(None)\n        else:\n            value = getattr(window['value'], aggregation)()\n            expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(result['value'].dtype))\n    assert_frame_equal(result, expected)",
            "@given(window_size=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=2)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit, aggregation=st.sampled_from(['min', 'max', 'mean', 'sum', 'median']))\ndef test_rolling_aggs(window_size: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit, aggregation: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assume(window_size != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)]))\n    df = dataframe.sort('ts')\n    func = f'rolling_{aggregation}'\n    result = df.with_columns(getattr(pl.col('value'), func)(window_size=window_size, by='ts', closed=closed))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(f'-{window_size}'), pl.lit(ts, dtype=pl.Datetime(time_unit)), closed=closed))\n        expected_dict['ts'].append(ts)\n        if window.is_empty():\n            expected_dict['value'].append(None)\n        else:\n            value = getattr(window['value'], aggregation)()\n            expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(result['value'].dtype))\n    assert_frame_equal(result, expected)",
            "@given(window_size=st.timedeltas(min_value=timedelta(microseconds=0), max_value=timedelta(days=2)).map(_timedelta_to_pl_duration), closed=strategy_closed, data=st.data(), time_unit=strategy_time_unit, aggregation=st.sampled_from(['min', 'max', 'mean', 'sum', 'median']))\ndef test_rolling_aggs(window_size: str, closed: ClosedInterval, data: st.DataObject, time_unit: TimeUnit, aggregation: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assume(window_size != '')\n    dataframe = data.draw(dataframes([column('ts', strategy=st.datetimes(min_value=dt.datetime(2000, 1, 1), max_value=dt.datetime(2001, 1, 1)), dtype=pl.Datetime(time_unit)), column('value', strategy=st.integers(min_value=-100, max_value=100), dtype=pl.Int64)]))\n    df = dataframe.sort('ts')\n    func = f'rolling_{aggregation}'\n    result = df.with_columns(getattr(pl.col('value'), func)(window_size=window_size, by='ts', closed=closed))\n    expected_dict: dict[str, list[object]] = {'ts': [], 'value': []}\n    for (ts, _) in df.iter_rows():\n        window = df.filter(pl.col('ts').is_between(pl.lit(ts, dtype=pl.Datetime(time_unit)).dt.offset_by(f'-{window_size}'), pl.lit(ts, dtype=pl.Datetime(time_unit)), closed=closed))\n        expected_dict['ts'].append(ts)\n        if window.is_empty():\n            expected_dict['value'].append(None)\n        else:\n            value = getattr(window['value'], aggregation)()\n            expected_dict['value'].append(value)\n    expected = pl.DataFrame(expected_dict).select(pl.col('ts').cast(pl.Datetime(time_unit)), pl.col('value').cast(result['value'].dtype))\n    assert_frame_equal(result, expected)"
        ]
    }
]