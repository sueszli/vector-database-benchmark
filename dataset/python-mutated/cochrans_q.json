[
    {
        "func_name": "cochrans_q",
        "original": "def cochrans_q(y_target, *y_model_predictions):\n    \"\"\"\n    Cochran's Q test to compare 2 or more models.\n\n    Parameters\n    -----------\n    y_target : array-like, shape=[n_samples]\n        True class labels as 1D NumPy array.\n\n    *y_model_predictions : array-likes, shape=[n_samples]\n        Variable number of 2 or more arrays that\n        contain the predicted class labels\n        from models as 1D NumPy array.\n\n    Returns\n    -----------\n\n    q, p : float or None, float\n        Returns the Q (chi-squared) value and the p-value\n\n    Examples\n    -----------\n    For usage examples, please see\n    https://rasbt.github.io/mlxtend/user_guide/evaluate/cochrans_q/\n\n    \"\"\"\n    num_models = len(y_model_predictions)\n    model_lens = set()\n    y_model_predictions = list(y_model_predictions)\n    for ary in [y_target] + y_model_predictions:\n        if len(ary.shape) != 1:\n            raise ValueError('One or more input arrays are not 1-dimensional.')\n        model_lens.add(ary.shape[0])\n    if len(model_lens) > 1:\n        raise ValueError('Each prediction array must have the same number of samples.')\n    if num_models < 2:\n        raise ValueError('Provide at least 2 model prediction arrays.')\n    degrees_of_freedom = num_models - 1\n    correctly_classified_all_models = 0\n    correctly_classified_collection = []\n    for pred in y_model_predictions:\n        correctly_classified = (y_target == pred).sum()\n        correctly_classified_all_models += correctly_classified\n        correctly_classified_collection.append(correctly_classified)\n    numerator = num_models * sum([c ** 2 for c in correctly_classified_collection]) - correctly_classified_all_models ** 2\n    binary_combin = list(itertools.product([0, 1], repeat=num_models))\n    ary = np.hstack([(y_target == mod).reshape(-1, 1) for mod in y_model_predictions]).astype(int)\n    correctly_classified_objects = 0\n    binary_combin_totals = np.zeros(len(binary_combin))\n    for (i, c) in enumerate(binary_combin):\n        binary_combin_totals[i] = ((ary == c).sum(axis=1) == num_models).sum()\n        correctly_classified_objects += sum(c) ** 2 * binary_combin_totals[i]\n    denominator = num_models * correctly_classified_all_models - correctly_classified_objects\n    q = degrees_of_freedom * numerator / denominator\n    p_value = scipy.stats.chi2.sf(q, degrees_of_freedom)\n    return (q, p_value)",
        "mutated": [
            "def cochrans_q(y_target, *y_model_predictions):\n    if False:\n        i = 10\n    \"\\n    Cochran's Q test to compare 2 or more models.\\n\\n    Parameters\\n    -----------\\n    y_target : array-like, shape=[n_samples]\\n        True class labels as 1D NumPy array.\\n\\n    *y_model_predictions : array-likes, shape=[n_samples]\\n        Variable number of 2 or more arrays that\\n        contain the predicted class labels\\n        from models as 1D NumPy array.\\n\\n    Returns\\n    -----------\\n\\n    q, p : float or None, float\\n        Returns the Q (chi-squared) value and the p-value\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/evaluate/cochrans_q/\\n\\n    \"\n    num_models = len(y_model_predictions)\n    model_lens = set()\n    y_model_predictions = list(y_model_predictions)\n    for ary in [y_target] + y_model_predictions:\n        if len(ary.shape) != 1:\n            raise ValueError('One or more input arrays are not 1-dimensional.')\n        model_lens.add(ary.shape[0])\n    if len(model_lens) > 1:\n        raise ValueError('Each prediction array must have the same number of samples.')\n    if num_models < 2:\n        raise ValueError('Provide at least 2 model prediction arrays.')\n    degrees_of_freedom = num_models - 1\n    correctly_classified_all_models = 0\n    correctly_classified_collection = []\n    for pred in y_model_predictions:\n        correctly_classified = (y_target == pred).sum()\n        correctly_classified_all_models += correctly_classified\n        correctly_classified_collection.append(correctly_classified)\n    numerator = num_models * sum([c ** 2 for c in correctly_classified_collection]) - correctly_classified_all_models ** 2\n    binary_combin = list(itertools.product([0, 1], repeat=num_models))\n    ary = np.hstack([(y_target == mod).reshape(-1, 1) for mod in y_model_predictions]).astype(int)\n    correctly_classified_objects = 0\n    binary_combin_totals = np.zeros(len(binary_combin))\n    for (i, c) in enumerate(binary_combin):\n        binary_combin_totals[i] = ((ary == c).sum(axis=1) == num_models).sum()\n        correctly_classified_objects += sum(c) ** 2 * binary_combin_totals[i]\n    denominator = num_models * correctly_classified_all_models - correctly_classified_objects\n    q = degrees_of_freedom * numerator / denominator\n    p_value = scipy.stats.chi2.sf(q, degrees_of_freedom)\n    return (q, p_value)",
            "def cochrans_q(y_target, *y_model_predictions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Cochran's Q test to compare 2 or more models.\\n\\n    Parameters\\n    -----------\\n    y_target : array-like, shape=[n_samples]\\n        True class labels as 1D NumPy array.\\n\\n    *y_model_predictions : array-likes, shape=[n_samples]\\n        Variable number of 2 or more arrays that\\n        contain the predicted class labels\\n        from models as 1D NumPy array.\\n\\n    Returns\\n    -----------\\n\\n    q, p : float or None, float\\n        Returns the Q (chi-squared) value and the p-value\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/evaluate/cochrans_q/\\n\\n    \"\n    num_models = len(y_model_predictions)\n    model_lens = set()\n    y_model_predictions = list(y_model_predictions)\n    for ary in [y_target] + y_model_predictions:\n        if len(ary.shape) != 1:\n            raise ValueError('One or more input arrays are not 1-dimensional.')\n        model_lens.add(ary.shape[0])\n    if len(model_lens) > 1:\n        raise ValueError('Each prediction array must have the same number of samples.')\n    if num_models < 2:\n        raise ValueError('Provide at least 2 model prediction arrays.')\n    degrees_of_freedom = num_models - 1\n    correctly_classified_all_models = 0\n    correctly_classified_collection = []\n    for pred in y_model_predictions:\n        correctly_classified = (y_target == pred).sum()\n        correctly_classified_all_models += correctly_classified\n        correctly_classified_collection.append(correctly_classified)\n    numerator = num_models * sum([c ** 2 for c in correctly_classified_collection]) - correctly_classified_all_models ** 2\n    binary_combin = list(itertools.product([0, 1], repeat=num_models))\n    ary = np.hstack([(y_target == mod).reshape(-1, 1) for mod in y_model_predictions]).astype(int)\n    correctly_classified_objects = 0\n    binary_combin_totals = np.zeros(len(binary_combin))\n    for (i, c) in enumerate(binary_combin):\n        binary_combin_totals[i] = ((ary == c).sum(axis=1) == num_models).sum()\n        correctly_classified_objects += sum(c) ** 2 * binary_combin_totals[i]\n    denominator = num_models * correctly_classified_all_models - correctly_classified_objects\n    q = degrees_of_freedom * numerator / denominator\n    p_value = scipy.stats.chi2.sf(q, degrees_of_freedom)\n    return (q, p_value)",
            "def cochrans_q(y_target, *y_model_predictions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Cochran's Q test to compare 2 or more models.\\n\\n    Parameters\\n    -----------\\n    y_target : array-like, shape=[n_samples]\\n        True class labels as 1D NumPy array.\\n\\n    *y_model_predictions : array-likes, shape=[n_samples]\\n        Variable number of 2 or more arrays that\\n        contain the predicted class labels\\n        from models as 1D NumPy array.\\n\\n    Returns\\n    -----------\\n\\n    q, p : float or None, float\\n        Returns the Q (chi-squared) value and the p-value\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/evaluate/cochrans_q/\\n\\n    \"\n    num_models = len(y_model_predictions)\n    model_lens = set()\n    y_model_predictions = list(y_model_predictions)\n    for ary in [y_target] + y_model_predictions:\n        if len(ary.shape) != 1:\n            raise ValueError('One or more input arrays are not 1-dimensional.')\n        model_lens.add(ary.shape[0])\n    if len(model_lens) > 1:\n        raise ValueError('Each prediction array must have the same number of samples.')\n    if num_models < 2:\n        raise ValueError('Provide at least 2 model prediction arrays.')\n    degrees_of_freedom = num_models - 1\n    correctly_classified_all_models = 0\n    correctly_classified_collection = []\n    for pred in y_model_predictions:\n        correctly_classified = (y_target == pred).sum()\n        correctly_classified_all_models += correctly_classified\n        correctly_classified_collection.append(correctly_classified)\n    numerator = num_models * sum([c ** 2 for c in correctly_classified_collection]) - correctly_classified_all_models ** 2\n    binary_combin = list(itertools.product([0, 1], repeat=num_models))\n    ary = np.hstack([(y_target == mod).reshape(-1, 1) for mod in y_model_predictions]).astype(int)\n    correctly_classified_objects = 0\n    binary_combin_totals = np.zeros(len(binary_combin))\n    for (i, c) in enumerate(binary_combin):\n        binary_combin_totals[i] = ((ary == c).sum(axis=1) == num_models).sum()\n        correctly_classified_objects += sum(c) ** 2 * binary_combin_totals[i]\n    denominator = num_models * correctly_classified_all_models - correctly_classified_objects\n    q = degrees_of_freedom * numerator / denominator\n    p_value = scipy.stats.chi2.sf(q, degrees_of_freedom)\n    return (q, p_value)",
            "def cochrans_q(y_target, *y_model_predictions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Cochran's Q test to compare 2 or more models.\\n\\n    Parameters\\n    -----------\\n    y_target : array-like, shape=[n_samples]\\n        True class labels as 1D NumPy array.\\n\\n    *y_model_predictions : array-likes, shape=[n_samples]\\n        Variable number of 2 or more arrays that\\n        contain the predicted class labels\\n        from models as 1D NumPy array.\\n\\n    Returns\\n    -----------\\n\\n    q, p : float or None, float\\n        Returns the Q (chi-squared) value and the p-value\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/evaluate/cochrans_q/\\n\\n    \"\n    num_models = len(y_model_predictions)\n    model_lens = set()\n    y_model_predictions = list(y_model_predictions)\n    for ary in [y_target] + y_model_predictions:\n        if len(ary.shape) != 1:\n            raise ValueError('One or more input arrays are not 1-dimensional.')\n        model_lens.add(ary.shape[0])\n    if len(model_lens) > 1:\n        raise ValueError('Each prediction array must have the same number of samples.')\n    if num_models < 2:\n        raise ValueError('Provide at least 2 model prediction arrays.')\n    degrees_of_freedom = num_models - 1\n    correctly_classified_all_models = 0\n    correctly_classified_collection = []\n    for pred in y_model_predictions:\n        correctly_classified = (y_target == pred).sum()\n        correctly_classified_all_models += correctly_classified\n        correctly_classified_collection.append(correctly_classified)\n    numerator = num_models * sum([c ** 2 for c in correctly_classified_collection]) - correctly_classified_all_models ** 2\n    binary_combin = list(itertools.product([0, 1], repeat=num_models))\n    ary = np.hstack([(y_target == mod).reshape(-1, 1) for mod in y_model_predictions]).astype(int)\n    correctly_classified_objects = 0\n    binary_combin_totals = np.zeros(len(binary_combin))\n    for (i, c) in enumerate(binary_combin):\n        binary_combin_totals[i] = ((ary == c).sum(axis=1) == num_models).sum()\n        correctly_classified_objects += sum(c) ** 2 * binary_combin_totals[i]\n    denominator = num_models * correctly_classified_all_models - correctly_classified_objects\n    q = degrees_of_freedom * numerator / denominator\n    p_value = scipy.stats.chi2.sf(q, degrees_of_freedom)\n    return (q, p_value)",
            "def cochrans_q(y_target, *y_model_predictions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Cochran's Q test to compare 2 or more models.\\n\\n    Parameters\\n    -----------\\n    y_target : array-like, shape=[n_samples]\\n        True class labels as 1D NumPy array.\\n\\n    *y_model_predictions : array-likes, shape=[n_samples]\\n        Variable number of 2 or more arrays that\\n        contain the predicted class labels\\n        from models as 1D NumPy array.\\n\\n    Returns\\n    -----------\\n\\n    q, p : float or None, float\\n        Returns the Q (chi-squared) value and the p-value\\n\\n    Examples\\n    -----------\\n    For usage examples, please see\\n    https://rasbt.github.io/mlxtend/user_guide/evaluate/cochrans_q/\\n\\n    \"\n    num_models = len(y_model_predictions)\n    model_lens = set()\n    y_model_predictions = list(y_model_predictions)\n    for ary in [y_target] + y_model_predictions:\n        if len(ary.shape) != 1:\n            raise ValueError('One or more input arrays are not 1-dimensional.')\n        model_lens.add(ary.shape[0])\n    if len(model_lens) > 1:\n        raise ValueError('Each prediction array must have the same number of samples.')\n    if num_models < 2:\n        raise ValueError('Provide at least 2 model prediction arrays.')\n    degrees_of_freedom = num_models - 1\n    correctly_classified_all_models = 0\n    correctly_classified_collection = []\n    for pred in y_model_predictions:\n        correctly_classified = (y_target == pred).sum()\n        correctly_classified_all_models += correctly_classified\n        correctly_classified_collection.append(correctly_classified)\n    numerator = num_models * sum([c ** 2 for c in correctly_classified_collection]) - correctly_classified_all_models ** 2\n    binary_combin = list(itertools.product([0, 1], repeat=num_models))\n    ary = np.hstack([(y_target == mod).reshape(-1, 1) for mod in y_model_predictions]).astype(int)\n    correctly_classified_objects = 0\n    binary_combin_totals = np.zeros(len(binary_combin))\n    for (i, c) in enumerate(binary_combin):\n        binary_combin_totals[i] = ((ary == c).sum(axis=1) == num_models).sum()\n        correctly_classified_objects += sum(c) ** 2 * binary_combin_totals[i]\n    denominator = num_models * correctly_classified_all_models - correctly_classified_objects\n    q = degrees_of_freedom * numerator / denominator\n    p_value = scipy.stats.chi2.sf(q, degrees_of_freedom)\n    return (q, p_value)"
        ]
    }
]