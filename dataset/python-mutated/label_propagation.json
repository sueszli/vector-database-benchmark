[
    {
        "func_name": "__init__",
        "original": "def __init__(self, model):\n    \"\"\"__init__(self)\"\"\"\n    self.__proxy__ = model",
        "mutated": [
            "def __init__(self, model):\n    if False:\n        i = 10\n    '__init__(self)'\n    self.__proxy__ = model",
            "def __init__(self, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '__init__(self)'\n    self.__proxy__ = model",
            "def __init__(self, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '__init__(self)'\n    self.__proxy__ = model",
            "def __init__(self, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '__init__(self)'\n    self.__proxy__ = model",
            "def __init__(self, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '__init__(self)'\n    self.__proxy__ = model"
        ]
    },
    {
        "func_name": "_result_fields",
        "original": "def _result_fields(self):\n    ret = super(LabelPropagationModel, self)._result_fields()\n    ret['vertex label probability'] = \"SFrame. See m['labels']\"\n    ret['change in last iteration (avg. of L2)'] = self['delta']\n    return ret",
        "mutated": [
            "def _result_fields(self):\n    if False:\n        i = 10\n    ret = super(LabelPropagationModel, self)._result_fields()\n    ret['vertex label probability'] = \"SFrame. See m['labels']\"\n    ret['change in last iteration (avg. of L2)'] = self['delta']\n    return ret",
            "def _result_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ret = super(LabelPropagationModel, self)._result_fields()\n    ret['vertex label probability'] = \"SFrame. See m['labels']\"\n    ret['change in last iteration (avg. of L2)'] = self['delta']\n    return ret",
            "def _result_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ret = super(LabelPropagationModel, self)._result_fields()\n    ret['vertex label probability'] = \"SFrame. See m['labels']\"\n    ret['change in last iteration (avg. of L2)'] = self['delta']\n    return ret",
            "def _result_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ret = super(LabelPropagationModel, self)._result_fields()\n    ret['vertex label probability'] = \"SFrame. See m['labels']\"\n    ret['change in last iteration (avg. of L2)'] = self['delta']\n    return ret",
            "def _result_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ret = super(LabelPropagationModel, self)._result_fields()\n    ret['vertex label probability'] = \"SFrame. See m['labels']\"\n    ret['change in last iteration (avg. of L2)'] = self['delta']\n    return ret"
        ]
    },
    {
        "func_name": "_metric_fields",
        "original": "def _metric_fields(self):\n    ret = super(LabelPropagationModel, self)._metric_fields()\n    ret['number of iterations'] = 'num_iterations'\n    return ret",
        "mutated": [
            "def _metric_fields(self):\n    if False:\n        i = 10\n    ret = super(LabelPropagationModel, self)._metric_fields()\n    ret['number of iterations'] = 'num_iterations'\n    return ret",
            "def _metric_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ret = super(LabelPropagationModel, self)._metric_fields()\n    ret['number of iterations'] = 'num_iterations'\n    return ret",
            "def _metric_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ret = super(LabelPropagationModel, self)._metric_fields()\n    ret['number of iterations'] = 'num_iterations'\n    return ret",
            "def _metric_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ret = super(LabelPropagationModel, self)._metric_fields()\n    ret['number of iterations'] = 'num_iterations'\n    return ret",
            "def _metric_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ret = super(LabelPropagationModel, self)._metric_fields()\n    ret['number of iterations'] = 'num_iterations'\n    return ret"
        ]
    },
    {
        "func_name": "_setting_fields",
        "original": "def _setting_fields(self):\n    ret = super(LabelPropagationModel, self)._setting_fields()\n    ret['convergence threshold (avg. of L2 norm)'] = 'threshold'\n    ret['treated edge as undirected'] = 'undirected'\n    ret['weight for self edge'] = 'self_weight'\n    ret['edge weight field id'] = 'weight_field'\n    ret['vertex label field id'] = 'label_field'\n    return ret",
        "mutated": [
            "def _setting_fields(self):\n    if False:\n        i = 10\n    ret = super(LabelPropagationModel, self)._setting_fields()\n    ret['convergence threshold (avg. of L2 norm)'] = 'threshold'\n    ret['treated edge as undirected'] = 'undirected'\n    ret['weight for self edge'] = 'self_weight'\n    ret['edge weight field id'] = 'weight_field'\n    ret['vertex label field id'] = 'label_field'\n    return ret",
            "def _setting_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ret = super(LabelPropagationModel, self)._setting_fields()\n    ret['convergence threshold (avg. of L2 norm)'] = 'threshold'\n    ret['treated edge as undirected'] = 'undirected'\n    ret['weight for self edge'] = 'self_weight'\n    ret['edge weight field id'] = 'weight_field'\n    ret['vertex label field id'] = 'label_field'\n    return ret",
            "def _setting_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ret = super(LabelPropagationModel, self)._setting_fields()\n    ret['convergence threshold (avg. of L2 norm)'] = 'threshold'\n    ret['treated edge as undirected'] = 'undirected'\n    ret['weight for self edge'] = 'self_weight'\n    ret['edge weight field id'] = 'weight_field'\n    ret['vertex label field id'] = 'label_field'\n    return ret",
            "def _setting_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ret = super(LabelPropagationModel, self)._setting_fields()\n    ret['convergence threshold (avg. of L2 norm)'] = 'threshold'\n    ret['treated edge as undirected'] = 'undirected'\n    ret['weight for self edge'] = 'self_weight'\n    ret['edge weight field id'] = 'weight_field'\n    ret['vertex label field id'] = 'label_field'\n    return ret",
            "def _setting_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ret = super(LabelPropagationModel, self)._setting_fields()\n    ret['convergence threshold (avg. of L2 norm)'] = 'threshold'\n    ret['treated edge as undirected'] = 'undirected'\n    ret['weight for self edge'] = 'self_weight'\n    ret['edge weight field id'] = 'weight_field'\n    ret['vertex label field id'] = 'label_field'\n    return ret"
        ]
    },
    {
        "func_name": "_get_version",
        "original": "def _get_version(self):\n    return 0",
        "mutated": [
            "def _get_version(self):\n    if False:\n        i = 10\n    return 0",
            "def _get_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 0",
            "def _get_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 0",
            "def _get_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 0",
            "def _get_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 0"
        ]
    },
    {
        "func_name": "_native_name",
        "original": "@classmethod\ndef _native_name(cls):\n    return 'label_propagation'",
        "mutated": [
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n    return 'label_propagation'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'label_propagation'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'label_propagation'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'label_propagation'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'label_propagation'"
        ]
    },
    {
        "func_name": "_get_native_state",
        "original": "def _get_native_state(self):\n    return {'model': self.__proxy__}",
        "mutated": [
            "def _get_native_state(self):\n    if False:\n        i = 10\n    return {'model': self.__proxy__}",
            "def _get_native_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return {'model': self.__proxy__}",
            "def _get_native_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return {'model': self.__proxy__}",
            "def _get_native_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return {'model': self.__proxy__}",
            "def _get_native_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return {'model': self.__proxy__}"
        ]
    },
    {
        "func_name": "_load_version",
        "original": "@classmethod\ndef _load_version(cls, state, version):\n    assert version == 0\n    return cls(state['model'])",
        "mutated": [
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n    assert version == 0\n    return cls(state['model'])",
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert version == 0\n    return cls(state['model'])",
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert version == 0\n    return cls(state['model'])",
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert version == 0\n    return cls(state['model'])",
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert version == 0\n    return cls(state['model'])"
        ]
    },
    {
        "func_name": "create",
        "original": "def create(graph, label_field, threshold=0.001, weight_field='', self_weight=1.0, undirected=False, max_iterations=None, _single_precision=False, _distributed='auto', verbose=True):\n    \"\"\"\n    Given a weighted graph with observed class labels of a subset of vertices,\n    infer the label probability for the unobserved vertices using the\n    \"label propagation\" algorithm.\n\n    The algorithm iteratively updates the label probability of current vertex\n    as a weighted sum of label probability of self and the neighboring vertices\n    until converge.  See\n    :class:`turicreate.label_propagation.LabelPropagationModel` for the details\n    of the algorithm.\n\n    Notes: label propagation works well with small number of labels, i.e. binary\n    labels, or less than 1000 classes. The toolkit will throw error\n    if the number of classes exceeds the maximum value (1000).\n\n    Parameters\n    ----------\n    graph : SGraph\n        The graph on which to compute the label propagation.\n\n    label_field: str\n        Vertex field storing the initial vertex labels. The values in\n        must be [0, num_classes). None values indicate unobserved vertex labels.\n\n    threshold : float, optional\n        Threshold for convergence, measured in the average L2 norm\n        (the sum of squared values) of the delta of each vertex's\n        label probability vector.\n\n    max_iterations: int, optional\n        The max number of iterations to run. Default is unlimited.\n        If set, the algorithm terminates when either max_iterations\n        or convergence threshold is reached.\n\n    weight_field: str, optional\n        Vertex field for edge weight. If empty, all edges are assumed\n        to have unit weight.\n\n    self_weight: float, optional\n        The weight for self edge.\n\n    undirected: bool, optional\n        If true, treat each edge as undirected, and propagates label in\n        both directions.\n\n    _single_precision : bool, optional\n        If true, running label propagation in single precision. The resulting\n        probability values may less accurate, but should run faster\n        and use less memory.\n\n    _distributed : distributed environment, internal\n\n    verbose : bool, optional\n        If True, print progress updates.\n\n    Returns\n    -------\n    out : LabelPropagationModel\n\n    References\n    ----------\n    - Zhu, X., & Ghahramani, Z. (2002). `Learning from labeled and unlabeled data\n      with label propagation <http://www.cs.cmu.edu/~zhuxj/pub/CMU-CALD-02-107.pdf>`_.\n\n    Examples\n    --------\n    If given an :class:`~turicreate.SGraph` ``g``, we can create\n    a :class:`~turicreate.label_propagation.LabelPropagationModel` as follows:\n\n    >>> g = turicreate.load_sgraph('http://snap.stanford.edu/data/email-Enron.txt.gz',\n    ...                         format='snap')\n    # Initialize random classes for a subset of vertices\n    # Leave the unobserved vertices with None label.\n    >>> import random\n    >>> def init_label(vid):\n    ...     x = random.random()\n    ...     if x < 0.2:\n    ...         return 0\n    ...     elif x > 0.9:\n    ...         return 1\n    ...     else:\n    ...         return None\n    >>> g.vertices['label'] = g.vertices['__id'].apply(init_label, int)\n    >>> m = turicreate.label_propagation.create(g, label_field='label')\n\n    We can obtain for each vertex the predicted label and the probability of\n    each label in the graph ``g`` using:\n\n    >>> labels = m['labels']     # SFrame\n    >>> labels\n    +------+-------+-----------------+-------------------+----------------+\n    | __id | label | predicted_label |         P0        |       P1       |\n    +------+-------+-----------------+-------------------+----------------+\n    |  5   |   1   |        1        |        0.0        |      1.0       |\n    |  7   |  None |        0        |    0.8213214997   |  0.1786785003  |\n    |  8   |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\n    |  10  |  None |        0        |   0.534984718273  | 0.465015281727 |\n    |  27  |  None |        0        |   0.752801638549  | 0.247198361451 |\n    |  29  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\n    |  33  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\n    |  47  |   0   |        0        |        1.0        |      0.0       |\n    |  50  |  None |        0        |   0.788279032657  | 0.211720967343 |\n    |  52  |  None |        0        |   0.666666666667  | 0.333333333333 |\n    +------+-------+-----------------+-------------------+----------------+\n    [36692 rows x 5 columns]\n\n    See Also\n    --------\n    LabelPropagationModel\n    \"\"\"\n    from turicreate._cython.cy_server import QuietProgress\n    _raise_error_if_not_of_type(label_field, str)\n    _raise_error_if_not_of_type(weight_field, str)\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    if graph.vertices[label_field].dtype != int:\n        raise TypeError('label_field %s must be integer typed.' % label_field)\n    opts = {'label_field': label_field, 'threshold': threshold, 'weight_field': weight_field, 'self_weight': self_weight, 'undirected': undirected, 'max_iterations': max_iterations, 'single_precision': _single_precision, 'graph': graph.__proxy__}\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.label_propagation.create(opts)\n    model = params['model']\n    return LabelPropagationModel(model)",
        "mutated": [
            "def create(graph, label_field, threshold=0.001, weight_field='', self_weight=1.0, undirected=False, max_iterations=None, _single_precision=False, _distributed='auto', verbose=True):\n    if False:\n        i = 10\n    '\\n    Given a weighted graph with observed class labels of a subset of vertices,\\n    infer the label probability for the unobserved vertices using the\\n    \"label propagation\" algorithm.\\n\\n    The algorithm iteratively updates the label probability of current vertex\\n    as a weighted sum of label probability of self and the neighboring vertices\\n    until converge.  See\\n    :class:`turicreate.label_propagation.LabelPropagationModel` for the details\\n    of the algorithm.\\n\\n    Notes: label propagation works well with small number of labels, i.e. binary\\n    labels, or less than 1000 classes. The toolkit will throw error\\n    if the number of classes exceeds the maximum value (1000).\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute the label propagation.\\n\\n    label_field: str\\n        Vertex field storing the initial vertex labels. The values in\\n        must be [0, num_classes). None values indicate unobserved vertex labels.\\n\\n    threshold : float, optional\\n        Threshold for convergence, measured in the average L2 norm\\n        (the sum of squared values) of the delta of each vertex\\'s\\n        label probability vector.\\n\\n    max_iterations: int, optional\\n        The max number of iterations to run. Default is unlimited.\\n        If set, the algorithm terminates when either max_iterations\\n        or convergence threshold is reached.\\n\\n    weight_field: str, optional\\n        Vertex field for edge weight. If empty, all edges are assumed\\n        to have unit weight.\\n\\n    self_weight: float, optional\\n        The weight for self edge.\\n\\n    undirected: bool, optional\\n        If true, treat each edge as undirected, and propagates label in\\n        both directions.\\n\\n    _single_precision : bool, optional\\n        If true, running label propagation in single precision. The resulting\\n        probability values may less accurate, but should run faster\\n        and use less memory.\\n\\n    _distributed : distributed environment, internal\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : LabelPropagationModel\\n\\n    References\\n    ----------\\n    - Zhu, X., & Ghahramani, Z. (2002). `Learning from labeled and unlabeled data\\n      with label propagation <http://www.cs.cmu.edu/~zhuxj/pub/CMU-CALD-02-107.pdf>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create\\n    a :class:`~turicreate.label_propagation.LabelPropagationModel` as follows:\\n\\n    >>> g = turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n    ...                         format=\\'snap\\')\\n    # Initialize random classes for a subset of vertices\\n    # Leave the unobserved vertices with None label.\\n    >>> import random\\n    >>> def init_label(vid):\\n    ...     x = random.random()\\n    ...     if x < 0.2:\\n    ...         return 0\\n    ...     elif x > 0.9:\\n    ...         return 1\\n    ...     else:\\n    ...         return None\\n    >>> g.vertices[\\'label\\'] = g.vertices[\\'__id\\'].apply(init_label, int)\\n    >>> m = turicreate.label_propagation.create(g, label_field=\\'label\\')\\n\\n    We can obtain for each vertex the predicted label and the probability of\\n    each label in the graph ``g`` using:\\n\\n    >>> labels = m[\\'labels\\']     # SFrame\\n    >>> labels\\n    +------+-------+-----------------+-------------------+----------------+\\n    | __id | label | predicted_label |         P0        |       P1       |\\n    +------+-------+-----------------+-------------------+----------------+\\n    |  5   |   1   |        1        |        0.0        |      1.0       |\\n    |  7   |  None |        0        |    0.8213214997   |  0.1786785003  |\\n    |  8   |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  10  |  None |        0        |   0.534984718273  | 0.465015281727 |\\n    |  27  |  None |        0        |   0.752801638549  | 0.247198361451 |\\n    |  29  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  33  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  47  |   0   |        0        |        1.0        |      0.0       |\\n    |  50  |  None |        0        |   0.788279032657  | 0.211720967343 |\\n    |  52  |  None |        0        |   0.666666666667  | 0.333333333333 |\\n    +------+-------+-----------------+-------------------+----------------+\\n    [36692 rows x 5 columns]\\n\\n    See Also\\n    --------\\n    LabelPropagationModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    _raise_error_if_not_of_type(label_field, str)\n    _raise_error_if_not_of_type(weight_field, str)\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    if graph.vertices[label_field].dtype != int:\n        raise TypeError('label_field %s must be integer typed.' % label_field)\n    opts = {'label_field': label_field, 'threshold': threshold, 'weight_field': weight_field, 'self_weight': self_weight, 'undirected': undirected, 'max_iterations': max_iterations, 'single_precision': _single_precision, 'graph': graph.__proxy__}\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.label_propagation.create(opts)\n    model = params['model']\n    return LabelPropagationModel(model)",
            "def create(graph, label_field, threshold=0.001, weight_field='', self_weight=1.0, undirected=False, max_iterations=None, _single_precision=False, _distributed='auto', verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given a weighted graph with observed class labels of a subset of vertices,\\n    infer the label probability for the unobserved vertices using the\\n    \"label propagation\" algorithm.\\n\\n    The algorithm iteratively updates the label probability of current vertex\\n    as a weighted sum of label probability of self and the neighboring vertices\\n    until converge.  See\\n    :class:`turicreate.label_propagation.LabelPropagationModel` for the details\\n    of the algorithm.\\n\\n    Notes: label propagation works well with small number of labels, i.e. binary\\n    labels, or less than 1000 classes. The toolkit will throw error\\n    if the number of classes exceeds the maximum value (1000).\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute the label propagation.\\n\\n    label_field: str\\n        Vertex field storing the initial vertex labels. The values in\\n        must be [0, num_classes). None values indicate unobserved vertex labels.\\n\\n    threshold : float, optional\\n        Threshold for convergence, measured in the average L2 norm\\n        (the sum of squared values) of the delta of each vertex\\'s\\n        label probability vector.\\n\\n    max_iterations: int, optional\\n        The max number of iterations to run. Default is unlimited.\\n        If set, the algorithm terminates when either max_iterations\\n        or convergence threshold is reached.\\n\\n    weight_field: str, optional\\n        Vertex field for edge weight. If empty, all edges are assumed\\n        to have unit weight.\\n\\n    self_weight: float, optional\\n        The weight for self edge.\\n\\n    undirected: bool, optional\\n        If true, treat each edge as undirected, and propagates label in\\n        both directions.\\n\\n    _single_precision : bool, optional\\n        If true, running label propagation in single precision. The resulting\\n        probability values may less accurate, but should run faster\\n        and use less memory.\\n\\n    _distributed : distributed environment, internal\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : LabelPropagationModel\\n\\n    References\\n    ----------\\n    - Zhu, X., & Ghahramani, Z. (2002). `Learning from labeled and unlabeled data\\n      with label propagation <http://www.cs.cmu.edu/~zhuxj/pub/CMU-CALD-02-107.pdf>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create\\n    a :class:`~turicreate.label_propagation.LabelPropagationModel` as follows:\\n\\n    >>> g = turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n    ...                         format=\\'snap\\')\\n    # Initialize random classes for a subset of vertices\\n    # Leave the unobserved vertices with None label.\\n    >>> import random\\n    >>> def init_label(vid):\\n    ...     x = random.random()\\n    ...     if x < 0.2:\\n    ...         return 0\\n    ...     elif x > 0.9:\\n    ...         return 1\\n    ...     else:\\n    ...         return None\\n    >>> g.vertices[\\'label\\'] = g.vertices[\\'__id\\'].apply(init_label, int)\\n    >>> m = turicreate.label_propagation.create(g, label_field=\\'label\\')\\n\\n    We can obtain for each vertex the predicted label and the probability of\\n    each label in the graph ``g`` using:\\n\\n    >>> labels = m[\\'labels\\']     # SFrame\\n    >>> labels\\n    +------+-------+-----------------+-------------------+----------------+\\n    | __id | label | predicted_label |         P0        |       P1       |\\n    +------+-------+-----------------+-------------------+----------------+\\n    |  5   |   1   |        1        |        0.0        |      1.0       |\\n    |  7   |  None |        0        |    0.8213214997   |  0.1786785003  |\\n    |  8   |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  10  |  None |        0        |   0.534984718273  | 0.465015281727 |\\n    |  27  |  None |        0        |   0.752801638549  | 0.247198361451 |\\n    |  29  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  33  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  47  |   0   |        0        |        1.0        |      0.0       |\\n    |  50  |  None |        0        |   0.788279032657  | 0.211720967343 |\\n    |  52  |  None |        0        |   0.666666666667  | 0.333333333333 |\\n    +------+-------+-----------------+-------------------+----------------+\\n    [36692 rows x 5 columns]\\n\\n    See Also\\n    --------\\n    LabelPropagationModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    _raise_error_if_not_of_type(label_field, str)\n    _raise_error_if_not_of_type(weight_field, str)\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    if graph.vertices[label_field].dtype != int:\n        raise TypeError('label_field %s must be integer typed.' % label_field)\n    opts = {'label_field': label_field, 'threshold': threshold, 'weight_field': weight_field, 'self_weight': self_weight, 'undirected': undirected, 'max_iterations': max_iterations, 'single_precision': _single_precision, 'graph': graph.__proxy__}\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.label_propagation.create(opts)\n    model = params['model']\n    return LabelPropagationModel(model)",
            "def create(graph, label_field, threshold=0.001, weight_field='', self_weight=1.0, undirected=False, max_iterations=None, _single_precision=False, _distributed='auto', verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given a weighted graph with observed class labels of a subset of vertices,\\n    infer the label probability for the unobserved vertices using the\\n    \"label propagation\" algorithm.\\n\\n    The algorithm iteratively updates the label probability of current vertex\\n    as a weighted sum of label probability of self and the neighboring vertices\\n    until converge.  See\\n    :class:`turicreate.label_propagation.LabelPropagationModel` for the details\\n    of the algorithm.\\n\\n    Notes: label propagation works well with small number of labels, i.e. binary\\n    labels, or less than 1000 classes. The toolkit will throw error\\n    if the number of classes exceeds the maximum value (1000).\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute the label propagation.\\n\\n    label_field: str\\n        Vertex field storing the initial vertex labels. The values in\\n        must be [0, num_classes). None values indicate unobserved vertex labels.\\n\\n    threshold : float, optional\\n        Threshold for convergence, measured in the average L2 norm\\n        (the sum of squared values) of the delta of each vertex\\'s\\n        label probability vector.\\n\\n    max_iterations: int, optional\\n        The max number of iterations to run. Default is unlimited.\\n        If set, the algorithm terminates when either max_iterations\\n        or convergence threshold is reached.\\n\\n    weight_field: str, optional\\n        Vertex field for edge weight. If empty, all edges are assumed\\n        to have unit weight.\\n\\n    self_weight: float, optional\\n        The weight for self edge.\\n\\n    undirected: bool, optional\\n        If true, treat each edge as undirected, and propagates label in\\n        both directions.\\n\\n    _single_precision : bool, optional\\n        If true, running label propagation in single precision. The resulting\\n        probability values may less accurate, but should run faster\\n        and use less memory.\\n\\n    _distributed : distributed environment, internal\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : LabelPropagationModel\\n\\n    References\\n    ----------\\n    - Zhu, X., & Ghahramani, Z. (2002). `Learning from labeled and unlabeled data\\n      with label propagation <http://www.cs.cmu.edu/~zhuxj/pub/CMU-CALD-02-107.pdf>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create\\n    a :class:`~turicreate.label_propagation.LabelPropagationModel` as follows:\\n\\n    >>> g = turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n    ...                         format=\\'snap\\')\\n    # Initialize random classes for a subset of vertices\\n    # Leave the unobserved vertices with None label.\\n    >>> import random\\n    >>> def init_label(vid):\\n    ...     x = random.random()\\n    ...     if x < 0.2:\\n    ...         return 0\\n    ...     elif x > 0.9:\\n    ...         return 1\\n    ...     else:\\n    ...         return None\\n    >>> g.vertices[\\'label\\'] = g.vertices[\\'__id\\'].apply(init_label, int)\\n    >>> m = turicreate.label_propagation.create(g, label_field=\\'label\\')\\n\\n    We can obtain for each vertex the predicted label and the probability of\\n    each label in the graph ``g`` using:\\n\\n    >>> labels = m[\\'labels\\']     # SFrame\\n    >>> labels\\n    +------+-------+-----------------+-------------------+----------------+\\n    | __id | label | predicted_label |         P0        |       P1       |\\n    +------+-------+-----------------+-------------------+----------------+\\n    |  5   |   1   |        1        |        0.0        |      1.0       |\\n    |  7   |  None |        0        |    0.8213214997   |  0.1786785003  |\\n    |  8   |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  10  |  None |        0        |   0.534984718273  | 0.465015281727 |\\n    |  27  |  None |        0        |   0.752801638549  | 0.247198361451 |\\n    |  29  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  33  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  47  |   0   |        0        |        1.0        |      0.0       |\\n    |  50  |  None |        0        |   0.788279032657  | 0.211720967343 |\\n    |  52  |  None |        0        |   0.666666666667  | 0.333333333333 |\\n    +------+-------+-----------------+-------------------+----------------+\\n    [36692 rows x 5 columns]\\n\\n    See Also\\n    --------\\n    LabelPropagationModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    _raise_error_if_not_of_type(label_field, str)\n    _raise_error_if_not_of_type(weight_field, str)\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    if graph.vertices[label_field].dtype != int:\n        raise TypeError('label_field %s must be integer typed.' % label_field)\n    opts = {'label_field': label_field, 'threshold': threshold, 'weight_field': weight_field, 'self_weight': self_weight, 'undirected': undirected, 'max_iterations': max_iterations, 'single_precision': _single_precision, 'graph': graph.__proxy__}\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.label_propagation.create(opts)\n    model = params['model']\n    return LabelPropagationModel(model)",
            "def create(graph, label_field, threshold=0.001, weight_field='', self_weight=1.0, undirected=False, max_iterations=None, _single_precision=False, _distributed='auto', verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given a weighted graph with observed class labels of a subset of vertices,\\n    infer the label probability for the unobserved vertices using the\\n    \"label propagation\" algorithm.\\n\\n    The algorithm iteratively updates the label probability of current vertex\\n    as a weighted sum of label probability of self and the neighboring vertices\\n    until converge.  See\\n    :class:`turicreate.label_propagation.LabelPropagationModel` for the details\\n    of the algorithm.\\n\\n    Notes: label propagation works well with small number of labels, i.e. binary\\n    labels, or less than 1000 classes. The toolkit will throw error\\n    if the number of classes exceeds the maximum value (1000).\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute the label propagation.\\n\\n    label_field: str\\n        Vertex field storing the initial vertex labels. The values in\\n        must be [0, num_classes). None values indicate unobserved vertex labels.\\n\\n    threshold : float, optional\\n        Threshold for convergence, measured in the average L2 norm\\n        (the sum of squared values) of the delta of each vertex\\'s\\n        label probability vector.\\n\\n    max_iterations: int, optional\\n        The max number of iterations to run. Default is unlimited.\\n        If set, the algorithm terminates when either max_iterations\\n        or convergence threshold is reached.\\n\\n    weight_field: str, optional\\n        Vertex field for edge weight. If empty, all edges are assumed\\n        to have unit weight.\\n\\n    self_weight: float, optional\\n        The weight for self edge.\\n\\n    undirected: bool, optional\\n        If true, treat each edge as undirected, and propagates label in\\n        both directions.\\n\\n    _single_precision : bool, optional\\n        If true, running label propagation in single precision. The resulting\\n        probability values may less accurate, but should run faster\\n        and use less memory.\\n\\n    _distributed : distributed environment, internal\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : LabelPropagationModel\\n\\n    References\\n    ----------\\n    - Zhu, X., & Ghahramani, Z. (2002). `Learning from labeled and unlabeled data\\n      with label propagation <http://www.cs.cmu.edu/~zhuxj/pub/CMU-CALD-02-107.pdf>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create\\n    a :class:`~turicreate.label_propagation.LabelPropagationModel` as follows:\\n\\n    >>> g = turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n    ...                         format=\\'snap\\')\\n    # Initialize random classes for a subset of vertices\\n    # Leave the unobserved vertices with None label.\\n    >>> import random\\n    >>> def init_label(vid):\\n    ...     x = random.random()\\n    ...     if x < 0.2:\\n    ...         return 0\\n    ...     elif x > 0.9:\\n    ...         return 1\\n    ...     else:\\n    ...         return None\\n    >>> g.vertices[\\'label\\'] = g.vertices[\\'__id\\'].apply(init_label, int)\\n    >>> m = turicreate.label_propagation.create(g, label_field=\\'label\\')\\n\\n    We can obtain for each vertex the predicted label and the probability of\\n    each label in the graph ``g`` using:\\n\\n    >>> labels = m[\\'labels\\']     # SFrame\\n    >>> labels\\n    +------+-------+-----------------+-------------------+----------------+\\n    | __id | label | predicted_label |         P0        |       P1       |\\n    +------+-------+-----------------+-------------------+----------------+\\n    |  5   |   1   |        1        |        0.0        |      1.0       |\\n    |  7   |  None |        0        |    0.8213214997   |  0.1786785003  |\\n    |  8   |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  10  |  None |        0        |   0.534984718273  | 0.465015281727 |\\n    |  27  |  None |        0        |   0.752801638549  | 0.247198361451 |\\n    |  29  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  33  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  47  |   0   |        0        |        1.0        |      0.0       |\\n    |  50  |  None |        0        |   0.788279032657  | 0.211720967343 |\\n    |  52  |  None |        0        |   0.666666666667  | 0.333333333333 |\\n    +------+-------+-----------------+-------------------+----------------+\\n    [36692 rows x 5 columns]\\n\\n    See Also\\n    --------\\n    LabelPropagationModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    _raise_error_if_not_of_type(label_field, str)\n    _raise_error_if_not_of_type(weight_field, str)\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    if graph.vertices[label_field].dtype != int:\n        raise TypeError('label_field %s must be integer typed.' % label_field)\n    opts = {'label_field': label_field, 'threshold': threshold, 'weight_field': weight_field, 'self_weight': self_weight, 'undirected': undirected, 'max_iterations': max_iterations, 'single_precision': _single_precision, 'graph': graph.__proxy__}\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.label_propagation.create(opts)\n    model = params['model']\n    return LabelPropagationModel(model)",
            "def create(graph, label_field, threshold=0.001, weight_field='', self_weight=1.0, undirected=False, max_iterations=None, _single_precision=False, _distributed='auto', verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given a weighted graph with observed class labels of a subset of vertices,\\n    infer the label probability for the unobserved vertices using the\\n    \"label propagation\" algorithm.\\n\\n    The algorithm iteratively updates the label probability of current vertex\\n    as a weighted sum of label probability of self and the neighboring vertices\\n    until converge.  See\\n    :class:`turicreate.label_propagation.LabelPropagationModel` for the details\\n    of the algorithm.\\n\\n    Notes: label propagation works well with small number of labels, i.e. binary\\n    labels, or less than 1000 classes. The toolkit will throw error\\n    if the number of classes exceeds the maximum value (1000).\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute the label propagation.\\n\\n    label_field: str\\n        Vertex field storing the initial vertex labels. The values in\\n        must be [0, num_classes). None values indicate unobserved vertex labels.\\n\\n    threshold : float, optional\\n        Threshold for convergence, measured in the average L2 norm\\n        (the sum of squared values) of the delta of each vertex\\'s\\n        label probability vector.\\n\\n    max_iterations: int, optional\\n        The max number of iterations to run. Default is unlimited.\\n        If set, the algorithm terminates when either max_iterations\\n        or convergence threshold is reached.\\n\\n    weight_field: str, optional\\n        Vertex field for edge weight. If empty, all edges are assumed\\n        to have unit weight.\\n\\n    self_weight: float, optional\\n        The weight for self edge.\\n\\n    undirected: bool, optional\\n        If true, treat each edge as undirected, and propagates label in\\n        both directions.\\n\\n    _single_precision : bool, optional\\n        If true, running label propagation in single precision. The resulting\\n        probability values may less accurate, but should run faster\\n        and use less memory.\\n\\n    _distributed : distributed environment, internal\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : LabelPropagationModel\\n\\n    References\\n    ----------\\n    - Zhu, X., & Ghahramani, Z. (2002). `Learning from labeled and unlabeled data\\n      with label propagation <http://www.cs.cmu.edu/~zhuxj/pub/CMU-CALD-02-107.pdf>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create\\n    a :class:`~turicreate.label_propagation.LabelPropagationModel` as follows:\\n\\n    >>> g = turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n    ...                         format=\\'snap\\')\\n    # Initialize random classes for a subset of vertices\\n    # Leave the unobserved vertices with None label.\\n    >>> import random\\n    >>> def init_label(vid):\\n    ...     x = random.random()\\n    ...     if x < 0.2:\\n    ...         return 0\\n    ...     elif x > 0.9:\\n    ...         return 1\\n    ...     else:\\n    ...         return None\\n    >>> g.vertices[\\'label\\'] = g.vertices[\\'__id\\'].apply(init_label, int)\\n    >>> m = turicreate.label_propagation.create(g, label_field=\\'label\\')\\n\\n    We can obtain for each vertex the predicted label and the probability of\\n    each label in the graph ``g`` using:\\n\\n    >>> labels = m[\\'labels\\']     # SFrame\\n    >>> labels\\n    +------+-------+-----------------+-------------------+----------------+\\n    | __id | label | predicted_label |         P0        |       P1       |\\n    +------+-------+-----------------+-------------------+----------------+\\n    |  5   |   1   |        1        |        0.0        |      1.0       |\\n    |  7   |  None |        0        |    0.8213214997   |  0.1786785003  |\\n    |  8   |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  10  |  None |        0        |   0.534984718273  | 0.465015281727 |\\n    |  27  |  None |        0        |   0.752801638549  | 0.247198361451 |\\n    |  29  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  33  |  None |        1        | 5.96046447754e-08 | 0.999999940395 |\\n    |  47  |   0   |        0        |        1.0        |      0.0       |\\n    |  50  |  None |        0        |   0.788279032657  | 0.211720967343 |\\n    |  52  |  None |        0        |   0.666666666667  | 0.333333333333 |\\n    +------+-------+-----------------+-------------------+----------------+\\n    [36692 rows x 5 columns]\\n\\n    See Also\\n    --------\\n    LabelPropagationModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    _raise_error_if_not_of_type(label_field, str)\n    _raise_error_if_not_of_type(weight_field, str)\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    if graph.vertices[label_field].dtype != int:\n        raise TypeError('label_field %s must be integer typed.' % label_field)\n    opts = {'label_field': label_field, 'threshold': threshold, 'weight_field': weight_field, 'self_weight': self_weight, 'undirected': undirected, 'max_iterations': max_iterations, 'single_precision': _single_precision, 'graph': graph.__proxy__}\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.label_propagation.create(opts)\n    model = params['model']\n    return LabelPropagationModel(model)"
        ]
    }
]