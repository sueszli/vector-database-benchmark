[
    {
        "func_name": "test_solution_fixed_point",
        "original": "@parameterized.parameters(*_DATA)\ndef test_solution_fixed_point(self, game, inverse_alpha, gambit_qre_sol):\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    mmd.update_sequences()\n    np.testing.assert_allclose(mmd.current_sequences()[0], gambit_qre_sol[0], rtol=1e-06)\n    np.testing.assert_allclose(mmd.current_sequences()[1], gambit_qre_sol[1], rtol=1e-06)",
        "mutated": [
            "@parameterized.parameters(*_DATA)\ndef test_solution_fixed_point(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    mmd.update_sequences()\n    np.testing.assert_allclose(mmd.current_sequences()[0], gambit_qre_sol[0], rtol=1e-06)\n    np.testing.assert_allclose(mmd.current_sequences()[1], gambit_qre_sol[1], rtol=1e-06)",
            "@parameterized.parameters(*_DATA)\ndef test_solution_fixed_point(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    mmd.update_sequences()\n    np.testing.assert_allclose(mmd.current_sequences()[0], gambit_qre_sol[0], rtol=1e-06)\n    np.testing.assert_allclose(mmd.current_sequences()[1], gambit_qre_sol[1], rtol=1e-06)",
            "@parameterized.parameters(*_DATA)\ndef test_solution_fixed_point(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    mmd.update_sequences()\n    np.testing.assert_allclose(mmd.current_sequences()[0], gambit_qre_sol[0], rtol=1e-06)\n    np.testing.assert_allclose(mmd.current_sequences()[1], gambit_qre_sol[1], rtol=1e-06)",
            "@parameterized.parameters(*_DATA)\ndef test_solution_fixed_point(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    mmd.update_sequences()\n    np.testing.assert_allclose(mmd.current_sequences()[0], gambit_qre_sol[0], rtol=1e-06)\n    np.testing.assert_allclose(mmd.current_sequences()[1], gambit_qre_sol[1], rtol=1e-06)",
            "@parameterized.parameters(*_DATA)\ndef test_solution_fixed_point(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    mmd.update_sequences()\n    np.testing.assert_allclose(mmd.current_sequences()[0], gambit_qre_sol[0], rtol=1e-06)\n    np.testing.assert_allclose(mmd.current_sequences()[1], gambit_qre_sol[1], rtol=1e-06)"
        ]
    },
    {
        "func_name": "test_gap",
        "original": "@parameterized.parameters(*_DATA)\ndef test_gap(self, game, inverse_alpha, gambit_qre_sol):\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    np.testing.assert_allclose(mmd.get_gap(), 0.0, atol=1e-06)",
        "mutated": [
            "@parameterized.parameters(*_DATA)\ndef test_gap(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    np.testing.assert_allclose(mmd.get_gap(), 0.0, atol=1e-06)",
            "@parameterized.parameters(*_DATA)\ndef test_gap(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    np.testing.assert_allclose(mmd.get_gap(), 0.0, atol=1e-06)",
            "@parameterized.parameters(*_DATA)\ndef test_gap(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    np.testing.assert_allclose(mmd.get_gap(), 0.0, atol=1e-06)",
            "@parameterized.parameters(*_DATA)\ndef test_gap(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    np.testing.assert_allclose(mmd.get_gap(), 0.0, atol=1e-06)",
            "@parameterized.parameters(*_DATA)\ndef test_gap(self, game, inverse_alpha, gambit_qre_sol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mmd = mmd_dilated.MMDDilatedEnt(game, 1.0 / inverse_alpha)\n    mmd.sequences = copy.deepcopy(gambit_qre_sol)\n    np.testing.assert_allclose(mmd.get_gap(), 0.0, atol=1e-06)"
        ]
    },
    {
        "func_name": "test_rps_update",
        "original": "@parameterized.parameters(0.0, 0.5, 1.0, 1.5)\ndef test_rps_update(self, alpha):\n    game = pyspiel.load_game_as_turn_based('matrix_rps')\n    start_sequences = [np.array([1, 0.2, 0.2, 0.6]), np.array([1, 0.5, 0.2, 0.3])]\n    mmd = mmd_dilated.MMDDilatedEnt(game, alpha)\n    mmd.sequences = copy.deepcopy(start_sequences)\n    mmd.update_sequences()\n    updated_sequences = copy.deepcopy(start_sequences)\n    updated_sequences[0][1:] = updated_sequences[0][1:] * np.exp(mmd.stepsize * -mmd.payoff_mat[1:, 1:] @ start_sequences[1][1:])\n    updated_sequences[0][1:] = updated_sequences[0][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[0][1:] = updated_sequences[0][1:] / np.sum(updated_sequences[0][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[0], updated_sequences[0])\n    updated_sequences[1][1:] = updated_sequences[1][1:] * np.exp(mmd.stepsize * mmd.payoff_mat[1:, 1:].T @ start_sequences[0][1:])\n    updated_sequences[1][1:] = updated_sequences[1][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[1][1:] = updated_sequences[1][1:] / np.sum(updated_sequences[1][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[1], updated_sequences[1])\n    if alpha > 0:\n        mmd.sequences = [np.array([1, 0.33333333, 0.33333333, 0.33333333]), np.array([1, 0.33333333, 0.33333333, 0.33333333])]\n        np.testing.assert_allclose(mmd.get_gap(), 0.0)",
        "mutated": [
            "@parameterized.parameters(0.0, 0.5, 1.0, 1.5)\ndef test_rps_update(self, alpha):\n    if False:\n        i = 10\n    game = pyspiel.load_game_as_turn_based('matrix_rps')\n    start_sequences = [np.array([1, 0.2, 0.2, 0.6]), np.array([1, 0.5, 0.2, 0.3])]\n    mmd = mmd_dilated.MMDDilatedEnt(game, alpha)\n    mmd.sequences = copy.deepcopy(start_sequences)\n    mmd.update_sequences()\n    updated_sequences = copy.deepcopy(start_sequences)\n    updated_sequences[0][1:] = updated_sequences[0][1:] * np.exp(mmd.stepsize * -mmd.payoff_mat[1:, 1:] @ start_sequences[1][1:])\n    updated_sequences[0][1:] = updated_sequences[0][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[0][1:] = updated_sequences[0][1:] / np.sum(updated_sequences[0][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[0], updated_sequences[0])\n    updated_sequences[1][1:] = updated_sequences[1][1:] * np.exp(mmd.stepsize * mmd.payoff_mat[1:, 1:].T @ start_sequences[0][1:])\n    updated_sequences[1][1:] = updated_sequences[1][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[1][1:] = updated_sequences[1][1:] / np.sum(updated_sequences[1][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[1], updated_sequences[1])\n    if alpha > 0:\n        mmd.sequences = [np.array([1, 0.33333333, 0.33333333, 0.33333333]), np.array([1, 0.33333333, 0.33333333, 0.33333333])]\n        np.testing.assert_allclose(mmd.get_gap(), 0.0)",
            "@parameterized.parameters(0.0, 0.5, 1.0, 1.5)\ndef test_rps_update(self, alpha):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    game = pyspiel.load_game_as_turn_based('matrix_rps')\n    start_sequences = [np.array([1, 0.2, 0.2, 0.6]), np.array([1, 0.5, 0.2, 0.3])]\n    mmd = mmd_dilated.MMDDilatedEnt(game, alpha)\n    mmd.sequences = copy.deepcopy(start_sequences)\n    mmd.update_sequences()\n    updated_sequences = copy.deepcopy(start_sequences)\n    updated_sequences[0][1:] = updated_sequences[0][1:] * np.exp(mmd.stepsize * -mmd.payoff_mat[1:, 1:] @ start_sequences[1][1:])\n    updated_sequences[0][1:] = updated_sequences[0][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[0][1:] = updated_sequences[0][1:] / np.sum(updated_sequences[0][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[0], updated_sequences[0])\n    updated_sequences[1][1:] = updated_sequences[1][1:] * np.exp(mmd.stepsize * mmd.payoff_mat[1:, 1:].T @ start_sequences[0][1:])\n    updated_sequences[1][1:] = updated_sequences[1][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[1][1:] = updated_sequences[1][1:] / np.sum(updated_sequences[1][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[1], updated_sequences[1])\n    if alpha > 0:\n        mmd.sequences = [np.array([1, 0.33333333, 0.33333333, 0.33333333]), np.array([1, 0.33333333, 0.33333333, 0.33333333])]\n        np.testing.assert_allclose(mmd.get_gap(), 0.0)",
            "@parameterized.parameters(0.0, 0.5, 1.0, 1.5)\ndef test_rps_update(self, alpha):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    game = pyspiel.load_game_as_turn_based('matrix_rps')\n    start_sequences = [np.array([1, 0.2, 0.2, 0.6]), np.array([1, 0.5, 0.2, 0.3])]\n    mmd = mmd_dilated.MMDDilatedEnt(game, alpha)\n    mmd.sequences = copy.deepcopy(start_sequences)\n    mmd.update_sequences()\n    updated_sequences = copy.deepcopy(start_sequences)\n    updated_sequences[0][1:] = updated_sequences[0][1:] * np.exp(mmd.stepsize * -mmd.payoff_mat[1:, 1:] @ start_sequences[1][1:])\n    updated_sequences[0][1:] = updated_sequences[0][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[0][1:] = updated_sequences[0][1:] / np.sum(updated_sequences[0][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[0], updated_sequences[0])\n    updated_sequences[1][1:] = updated_sequences[1][1:] * np.exp(mmd.stepsize * mmd.payoff_mat[1:, 1:].T @ start_sequences[0][1:])\n    updated_sequences[1][1:] = updated_sequences[1][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[1][1:] = updated_sequences[1][1:] / np.sum(updated_sequences[1][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[1], updated_sequences[1])\n    if alpha > 0:\n        mmd.sequences = [np.array([1, 0.33333333, 0.33333333, 0.33333333]), np.array([1, 0.33333333, 0.33333333, 0.33333333])]\n        np.testing.assert_allclose(mmd.get_gap(), 0.0)",
            "@parameterized.parameters(0.0, 0.5, 1.0, 1.5)\ndef test_rps_update(self, alpha):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    game = pyspiel.load_game_as_turn_based('matrix_rps')\n    start_sequences = [np.array([1, 0.2, 0.2, 0.6]), np.array([1, 0.5, 0.2, 0.3])]\n    mmd = mmd_dilated.MMDDilatedEnt(game, alpha)\n    mmd.sequences = copy.deepcopy(start_sequences)\n    mmd.update_sequences()\n    updated_sequences = copy.deepcopy(start_sequences)\n    updated_sequences[0][1:] = updated_sequences[0][1:] * np.exp(mmd.stepsize * -mmd.payoff_mat[1:, 1:] @ start_sequences[1][1:])\n    updated_sequences[0][1:] = updated_sequences[0][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[0][1:] = updated_sequences[0][1:] / np.sum(updated_sequences[0][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[0], updated_sequences[0])\n    updated_sequences[1][1:] = updated_sequences[1][1:] * np.exp(mmd.stepsize * mmd.payoff_mat[1:, 1:].T @ start_sequences[0][1:])\n    updated_sequences[1][1:] = updated_sequences[1][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[1][1:] = updated_sequences[1][1:] / np.sum(updated_sequences[1][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[1], updated_sequences[1])\n    if alpha > 0:\n        mmd.sequences = [np.array([1, 0.33333333, 0.33333333, 0.33333333]), np.array([1, 0.33333333, 0.33333333, 0.33333333])]\n        np.testing.assert_allclose(mmd.get_gap(), 0.0)",
            "@parameterized.parameters(0.0, 0.5, 1.0, 1.5)\ndef test_rps_update(self, alpha):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    game = pyspiel.load_game_as_turn_based('matrix_rps')\n    start_sequences = [np.array([1, 0.2, 0.2, 0.6]), np.array([1, 0.5, 0.2, 0.3])]\n    mmd = mmd_dilated.MMDDilatedEnt(game, alpha)\n    mmd.sequences = copy.deepcopy(start_sequences)\n    mmd.update_sequences()\n    updated_sequences = copy.deepcopy(start_sequences)\n    updated_sequences[0][1:] = updated_sequences[0][1:] * np.exp(mmd.stepsize * -mmd.payoff_mat[1:, 1:] @ start_sequences[1][1:])\n    updated_sequences[0][1:] = updated_sequences[0][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[0][1:] = updated_sequences[0][1:] / np.sum(updated_sequences[0][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[0], updated_sequences[0])\n    updated_sequences[1][1:] = updated_sequences[1][1:] * np.exp(mmd.stepsize * mmd.payoff_mat[1:, 1:].T @ start_sequences[0][1:])\n    updated_sequences[1][1:] = updated_sequences[1][1:] ** (1.0 / (1 + mmd.stepsize * alpha))\n    updated_sequences[1][1:] = updated_sequences[1][1:] / np.sum(updated_sequences[1][1:])\n    np.testing.assert_allclose(mmd.current_sequences()[1], updated_sequences[1])\n    if alpha > 0:\n        mmd.sequences = [np.array([1, 0.33333333, 0.33333333, 0.33333333]), np.array([1, 0.33333333, 0.33333333, 0.33333333])]\n        np.testing.assert_allclose(mmd.get_gap(), 0.0)"
        ]
    }
]