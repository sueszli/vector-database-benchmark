[
    {
        "func_name": "__init__",
        "original": "def __init__(self, name, title, direct_reports):\n    self.name = name\n    self.title = title\n    self.direct_reports = direct_reports",
        "mutated": [
            "def __init__(self, name, title, direct_reports):\n    if False:\n        i = 10\n    self.name = name\n    self.title = title\n    self.direct_reports = direct_reports",
            "def __init__(self, name, title, direct_reports):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.name = name\n    self.title = title\n    self.direct_reports = direct_reports",
            "def __init__(self, name, title, direct_reports):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.name = name\n    self.title = title\n    self.direct_reports = direct_reports",
            "def __init__(self, name, title, direct_reports):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.name = name\n    self.title = title\n    self.direct_reports = direct_reports",
            "def __init__(self, name, title, direct_reports):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.name = name\n    self.title = title\n    self.direct_reports = direct_reports"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, employee):\n    \"\"\"Constructor logic.\"\"\"\n    self.employees_to_visit = [employee]\n    self.employees_visited = set()",
        "mutated": [
            "def __init__(self, employee):\n    if False:\n        i = 10\n    'Constructor logic.'\n    self.employees_to_visit = [employee]\n    self.employees_visited = set()",
            "def __init__(self, employee):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Constructor logic.'\n    self.employees_to_visit = [employee]\n    self.employees_visited = set()",
            "def __init__(self, employee):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Constructor logic.'\n    self.employees_to_visit = [employee]\n    self.employees_visited = set()",
            "def __init__(self, employee):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Constructor logic.'\n    self.employees_to_visit = [employee]\n    self.employees_visited = set()",
            "def __init__(self, employee):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Constructor logic.'\n    self.employees_to_visit = [employee]\n    self.employees_visited = set()"
        ]
    },
    {
        "func_name": "__iter__",
        "original": "def __iter__(self):\n    \"\"\"Iterator is self by convention.\"\"\"\n    return self",
        "mutated": [
            "def __iter__(self):\n    if False:\n        i = 10\n    'Iterator is self by convention.'\n    return self",
            "def __iter__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Iterator is self by convention.'\n    return self",
            "def __iter__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Iterator is self by convention.'\n    return self",
            "def __iter__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Iterator is self by convention.'\n    return self",
            "def __iter__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Iterator is self by convention.'\n    return self"
        ]
    },
    {
        "func_name": "__next__",
        "original": "def __next__(self):\n    \"\"\"Return the next employee available.\n\n        The logic may seem complex, but it's actually a common algorithm\n        used in traversing a relationship graph. It is called depth-first\n        search and it can be found on Wikipedia:\n\n        https://en.wikipedia.org/wiki/Depth-first_search\n        \"\"\"\n    if not self.employees_to_visit:\n        raise StopIteration\n    employee = self.employees_to_visit.pop()\n    if employee.name in self.employees_visited:\n        raise IterationError(_ITERATION_MESSAGE)\n    self.employees_visited.add(employee.name)\n    for report in employee.direct_reports:\n        self.employees_to_visit.append(report)\n    return employee",
        "mutated": [
            "def __next__(self):\n    if False:\n        i = 10\n    \"Return the next employee available.\\n\\n        The logic may seem complex, but it's actually a common algorithm\\n        used in traversing a relationship graph. It is called depth-first\\n        search and it can be found on Wikipedia:\\n\\n        https://en.wikipedia.org/wiki/Depth-first_search\\n        \"\n    if not self.employees_to_visit:\n        raise StopIteration\n    employee = self.employees_to_visit.pop()\n    if employee.name in self.employees_visited:\n        raise IterationError(_ITERATION_MESSAGE)\n    self.employees_visited.add(employee.name)\n    for report in employee.direct_reports:\n        self.employees_to_visit.append(report)\n    return employee",
            "def __next__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return the next employee available.\\n\\n        The logic may seem complex, but it's actually a common algorithm\\n        used in traversing a relationship graph. It is called depth-first\\n        search and it can be found on Wikipedia:\\n\\n        https://en.wikipedia.org/wiki/Depth-first_search\\n        \"\n    if not self.employees_to_visit:\n        raise StopIteration\n    employee = self.employees_to_visit.pop()\n    if employee.name in self.employees_visited:\n        raise IterationError(_ITERATION_MESSAGE)\n    self.employees_visited.add(employee.name)\n    for report in employee.direct_reports:\n        self.employees_to_visit.append(report)\n    return employee",
            "def __next__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return the next employee available.\\n\\n        The logic may seem complex, but it's actually a common algorithm\\n        used in traversing a relationship graph. It is called depth-first\\n        search and it can be found on Wikipedia:\\n\\n        https://en.wikipedia.org/wiki/Depth-first_search\\n        \"\n    if not self.employees_to_visit:\n        raise StopIteration\n    employee = self.employees_to_visit.pop()\n    if employee.name in self.employees_visited:\n        raise IterationError(_ITERATION_MESSAGE)\n    self.employees_visited.add(employee.name)\n    for report in employee.direct_reports:\n        self.employees_to_visit.append(report)\n    return employee",
            "def __next__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return the next employee available.\\n\\n        The logic may seem complex, but it's actually a common algorithm\\n        used in traversing a relationship graph. It is called depth-first\\n        search and it can be found on Wikipedia:\\n\\n        https://en.wikipedia.org/wiki/Depth-first_search\\n        \"\n    if not self.employees_to_visit:\n        raise StopIteration\n    employee = self.employees_to_visit.pop()\n    if employee.name in self.employees_visited:\n        raise IterationError(_ITERATION_MESSAGE)\n    self.employees_visited.add(employee.name)\n    for report in employee.direct_reports:\n        self.employees_to_visit.append(report)\n    return employee",
            "def __next__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return the next employee available.\\n\\n        The logic may seem complex, but it's actually a common algorithm\\n        used in traversing a relationship graph. It is called depth-first\\n        search and it can be found on Wikipedia:\\n\\n        https://en.wikipedia.org/wiki/Depth-first_search\\n        \"\n    if not self.employees_to_visit:\n        raise StopIteration\n    employee = self.employees_to_visit.pop()\n    if employee.name in self.employees_visited:\n        raise IterationError(_ITERATION_MESSAGE)\n    self.employees_visited.add(employee.name)\n    for report in employee.direct_reports:\n        self.employees_to_visit.append(report)\n    return employee"
        ]
    },
    {
        "func_name": "employee_generator",
        "original": "def employee_generator(top_employee):\n    \"\"\"Employee generator.\n\n    It is essentially the same logic as above except constructed as a\n    generator function. Notice that the generator code is in a single\n    place, whereas the iterator code is in multiple places. Also notice\n    that we are using the `yield` keyword in the generator code.\n\n    It is a matter of preference and context that we choose one approach\n    over the other. If we want something simple, go with the generator.\n    Otherwise, go with the iterator to fulfill more demanding requirements.\n    In this case, examples of such requirements are tasks like encrypting\n    the employee's username, running statistics on iterated employees or\n    excluding the reports under a particular set of managers.\n\n    For more on the subject of using a function versus a class, check\n    out this post from Microsoft Developer Blogs:\n\n    https://devblogs.microsoft.com/python/idiomatic-python-functions-versus-classes/\n    \"\"\"\n    to_visit = [top_employee]\n    visited = set()\n    while len(to_visit) > 0:\n        employee = to_visit.pop()\n        if employee.name in visited:\n            raise IterationError(_ITERATION_MESSAGE)\n        visited.add(employee.name)\n        for report in employee.direct_reports:\n            to_visit.append(report)\n        yield employee",
        "mutated": [
            "def employee_generator(top_employee):\n    if False:\n        i = 10\n    \"Employee generator.\\n\\n    It is essentially the same logic as above except constructed as a\\n    generator function. Notice that the generator code is in a single\\n    place, whereas the iterator code is in multiple places. Also notice\\n    that we are using the `yield` keyword in the generator code.\\n\\n    It is a matter of preference and context that we choose one approach\\n    over the other. If we want something simple, go with the generator.\\n    Otherwise, go with the iterator to fulfill more demanding requirements.\\n    In this case, examples of such requirements are tasks like encrypting\\n    the employee's username, running statistics on iterated employees or\\n    excluding the reports under a particular set of managers.\\n\\n    For more on the subject of using a function versus a class, check\\n    out this post from Microsoft Developer Blogs:\\n\\n    https://devblogs.microsoft.com/python/idiomatic-python-functions-versus-classes/\\n    \"\n    to_visit = [top_employee]\n    visited = set()\n    while len(to_visit) > 0:\n        employee = to_visit.pop()\n        if employee.name in visited:\n            raise IterationError(_ITERATION_MESSAGE)\n        visited.add(employee.name)\n        for report in employee.direct_reports:\n            to_visit.append(report)\n        yield employee",
            "def employee_generator(top_employee):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Employee generator.\\n\\n    It is essentially the same logic as above except constructed as a\\n    generator function. Notice that the generator code is in a single\\n    place, whereas the iterator code is in multiple places. Also notice\\n    that we are using the `yield` keyword in the generator code.\\n\\n    It is a matter of preference and context that we choose one approach\\n    over the other. If we want something simple, go with the generator.\\n    Otherwise, go with the iterator to fulfill more demanding requirements.\\n    In this case, examples of such requirements are tasks like encrypting\\n    the employee's username, running statistics on iterated employees or\\n    excluding the reports under a particular set of managers.\\n\\n    For more on the subject of using a function versus a class, check\\n    out this post from Microsoft Developer Blogs:\\n\\n    https://devblogs.microsoft.com/python/idiomatic-python-functions-versus-classes/\\n    \"\n    to_visit = [top_employee]\n    visited = set()\n    while len(to_visit) > 0:\n        employee = to_visit.pop()\n        if employee.name in visited:\n            raise IterationError(_ITERATION_MESSAGE)\n        visited.add(employee.name)\n        for report in employee.direct_reports:\n            to_visit.append(report)\n        yield employee",
            "def employee_generator(top_employee):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Employee generator.\\n\\n    It is essentially the same logic as above except constructed as a\\n    generator function. Notice that the generator code is in a single\\n    place, whereas the iterator code is in multiple places. Also notice\\n    that we are using the `yield` keyword in the generator code.\\n\\n    It is a matter of preference and context that we choose one approach\\n    over the other. If we want something simple, go with the generator.\\n    Otherwise, go with the iterator to fulfill more demanding requirements.\\n    In this case, examples of such requirements are tasks like encrypting\\n    the employee's username, running statistics on iterated employees or\\n    excluding the reports under a particular set of managers.\\n\\n    For more on the subject of using a function versus a class, check\\n    out this post from Microsoft Developer Blogs:\\n\\n    https://devblogs.microsoft.com/python/idiomatic-python-functions-versus-classes/\\n    \"\n    to_visit = [top_employee]\n    visited = set()\n    while len(to_visit) > 0:\n        employee = to_visit.pop()\n        if employee.name in visited:\n            raise IterationError(_ITERATION_MESSAGE)\n        visited.add(employee.name)\n        for report in employee.direct_reports:\n            to_visit.append(report)\n        yield employee",
            "def employee_generator(top_employee):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Employee generator.\\n\\n    It is essentially the same logic as above except constructed as a\\n    generator function. Notice that the generator code is in a single\\n    place, whereas the iterator code is in multiple places. Also notice\\n    that we are using the `yield` keyword in the generator code.\\n\\n    It is a matter of preference and context that we choose one approach\\n    over the other. If we want something simple, go with the generator.\\n    Otherwise, go with the iterator to fulfill more demanding requirements.\\n    In this case, examples of such requirements are tasks like encrypting\\n    the employee's username, running statistics on iterated employees or\\n    excluding the reports under a particular set of managers.\\n\\n    For more on the subject of using a function versus a class, check\\n    out this post from Microsoft Developer Blogs:\\n\\n    https://devblogs.microsoft.com/python/idiomatic-python-functions-versus-classes/\\n    \"\n    to_visit = [top_employee]\n    visited = set()\n    while len(to_visit) > 0:\n        employee = to_visit.pop()\n        if employee.name in visited:\n            raise IterationError(_ITERATION_MESSAGE)\n        visited.add(employee.name)\n        for report in employee.direct_reports:\n            to_visit.append(report)\n        yield employee",
            "def employee_generator(top_employee):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Employee generator.\\n\\n    It is essentially the same logic as above except constructed as a\\n    generator function. Notice that the generator code is in a single\\n    place, whereas the iterator code is in multiple places. Also notice\\n    that we are using the `yield` keyword in the generator code.\\n\\n    It is a matter of preference and context that we choose one approach\\n    over the other. If we want something simple, go with the generator.\\n    Otherwise, go with the iterator to fulfill more demanding requirements.\\n    In this case, examples of such requirements are tasks like encrypting\\n    the employee's username, running statistics on iterated employees or\\n    excluding the reports under a particular set of managers.\\n\\n    For more on the subject of using a function versus a class, check\\n    out this post from Microsoft Developer Blogs:\\n\\n    https://devblogs.microsoft.com/python/idiomatic-python-functions-versus-classes/\\n    \"\n    to_visit = [top_employee]\n    visited = set()\n    while len(to_visit) > 0:\n        employee = to_visit.pop()\n        if employee.name in visited:\n            raise IterationError(_ITERATION_MESSAGE)\n        visited.add(employee.name)\n        for report in employee.direct_reports:\n            to_visit.append(report)\n        yield employee"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    manager = Employee('Max Doe', 'Engineering Manager', [Employee('John Doe', 'Software Engineer', []), Employee('Jane Doe', 'Software Engineer', [])])\n    employees = [emp for emp in EmployeeIterator(manager)]\n    assert employees == [emp for emp in employee_generator(manager)]\n    assert len(employees) == 3\n    assert all((isinstance(emp, Employee) for emp in employees))\n    hacker = Employee('Unknown', 'Hacker', [])\n    hacker.direct_reports.append(hacker)\n    for iter_obj in (EmployeeIterator, employee_generator):\n        call_failed = False\n        try:\n            list(iter_obj(hacker))\n        except IterationError as e:\n            call_failed = True\n            assert str(e) == _ITERATION_MESSAGE\n        assert call_failed is True",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    manager = Employee('Max Doe', 'Engineering Manager', [Employee('John Doe', 'Software Engineer', []), Employee('Jane Doe', 'Software Engineer', [])])\n    employees = [emp for emp in EmployeeIterator(manager)]\n    assert employees == [emp for emp in employee_generator(manager)]\n    assert len(employees) == 3\n    assert all((isinstance(emp, Employee) for emp in employees))\n    hacker = Employee('Unknown', 'Hacker', [])\n    hacker.direct_reports.append(hacker)\n    for iter_obj in (EmployeeIterator, employee_generator):\n        call_failed = False\n        try:\n            list(iter_obj(hacker))\n        except IterationError as e:\n            call_failed = True\n            assert str(e) == _ITERATION_MESSAGE\n        assert call_failed is True",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    manager = Employee('Max Doe', 'Engineering Manager', [Employee('John Doe', 'Software Engineer', []), Employee('Jane Doe', 'Software Engineer', [])])\n    employees = [emp for emp in EmployeeIterator(manager)]\n    assert employees == [emp for emp in employee_generator(manager)]\n    assert len(employees) == 3\n    assert all((isinstance(emp, Employee) for emp in employees))\n    hacker = Employee('Unknown', 'Hacker', [])\n    hacker.direct_reports.append(hacker)\n    for iter_obj in (EmployeeIterator, employee_generator):\n        call_failed = False\n        try:\n            list(iter_obj(hacker))\n        except IterationError as e:\n            call_failed = True\n            assert str(e) == _ITERATION_MESSAGE\n        assert call_failed is True",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    manager = Employee('Max Doe', 'Engineering Manager', [Employee('John Doe', 'Software Engineer', []), Employee('Jane Doe', 'Software Engineer', [])])\n    employees = [emp for emp in EmployeeIterator(manager)]\n    assert employees == [emp for emp in employee_generator(manager)]\n    assert len(employees) == 3\n    assert all((isinstance(emp, Employee) for emp in employees))\n    hacker = Employee('Unknown', 'Hacker', [])\n    hacker.direct_reports.append(hacker)\n    for iter_obj in (EmployeeIterator, employee_generator):\n        call_failed = False\n        try:\n            list(iter_obj(hacker))\n        except IterationError as e:\n            call_failed = True\n            assert str(e) == _ITERATION_MESSAGE\n        assert call_failed is True",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    manager = Employee('Max Doe', 'Engineering Manager', [Employee('John Doe', 'Software Engineer', []), Employee('Jane Doe', 'Software Engineer', [])])\n    employees = [emp for emp in EmployeeIterator(manager)]\n    assert employees == [emp for emp in employee_generator(manager)]\n    assert len(employees) == 3\n    assert all((isinstance(emp, Employee) for emp in employees))\n    hacker = Employee('Unknown', 'Hacker', [])\n    hacker.direct_reports.append(hacker)\n    for iter_obj in (EmployeeIterator, employee_generator):\n        call_failed = False\n        try:\n            list(iter_obj(hacker))\n        except IterationError as e:\n            call_failed = True\n            assert str(e) == _ITERATION_MESSAGE\n        assert call_failed is True",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    manager = Employee('Max Doe', 'Engineering Manager', [Employee('John Doe', 'Software Engineer', []), Employee('Jane Doe', 'Software Engineer', [])])\n    employees = [emp for emp in EmployeeIterator(manager)]\n    assert employees == [emp for emp in employee_generator(manager)]\n    assert len(employees) == 3\n    assert all((isinstance(emp, Employee) for emp in employees))\n    hacker = Employee('Unknown', 'Hacker', [])\n    hacker.direct_reports.append(hacker)\n    for iter_obj in (EmployeeIterator, employee_generator):\n        call_failed = False\n        try:\n            list(iter_obj(hacker))\n        except IterationError as e:\n            call_failed = True\n            assert str(e) == _ITERATION_MESSAGE\n        assert call_failed is True"
        ]
    }
]