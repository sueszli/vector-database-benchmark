[
    {
        "func_name": "mean_residual_life",
        "original": "def mean_residual_life(x, frac=None, alpha=0.05):\n    \"\"\"empirical mean residual life or expected shortfall\n\n    Parameters\n    ----------\n    x : 1-dimensional array_like\n    frac : list[float], optional\n        All entries must be between 0 and 1\n    alpha : float, default 0.05\n        FIXME: not actually used.\n\n    TODO:\n        check formula for std of mean\n        does not include case for all observations\n        last observations std is zero\n        vectorize loop using cumsum\n        frac does not work yet\n    \"\"\"\n    axis = 0\n    x = np.asarray(x)\n    nobs = x.shape[axis]\n    xsorted = np.sort(x, axis=axis)\n    if frac is None:\n        xthreshold = xsorted\n    else:\n        xthreshold = xsorted[np.floor(nobs * frac).astype(int)]\n    xlargerindex = np.searchsorted(xsorted, xthreshold, side='right')\n    result = []\n    for i in range(len(xthreshold) - 1):\n        k_ind = xlargerindex[i]\n        rmean = x[k_ind:].mean()\n        rstd = x[k_ind:].std()\n        rmstd = rstd / np.sqrt(nobs - k_ind)\n        result.append((k_ind, xthreshold[i], rmean, rmstd))\n    res = np.array(result)\n    crit = 1.96\n    confint = res[:, 1:2] + crit * res[:, -1:] * np.array([[-1, 1]])\n    return np.column_stack((res, confint))",
        "mutated": [
            "def mean_residual_life(x, frac=None, alpha=0.05):\n    if False:\n        i = 10\n    'empirical mean residual life or expected shortfall\\n\\n    Parameters\\n    ----------\\n    x : 1-dimensional array_like\\n    frac : list[float], optional\\n        All entries must be between 0 and 1\\n    alpha : float, default 0.05\\n        FIXME: not actually used.\\n\\n    TODO:\\n        check formula for std of mean\\n        does not include case for all observations\\n        last observations std is zero\\n        vectorize loop using cumsum\\n        frac does not work yet\\n    '\n    axis = 0\n    x = np.asarray(x)\n    nobs = x.shape[axis]\n    xsorted = np.sort(x, axis=axis)\n    if frac is None:\n        xthreshold = xsorted\n    else:\n        xthreshold = xsorted[np.floor(nobs * frac).astype(int)]\n    xlargerindex = np.searchsorted(xsorted, xthreshold, side='right')\n    result = []\n    for i in range(len(xthreshold) - 1):\n        k_ind = xlargerindex[i]\n        rmean = x[k_ind:].mean()\n        rstd = x[k_ind:].std()\n        rmstd = rstd / np.sqrt(nobs - k_ind)\n        result.append((k_ind, xthreshold[i], rmean, rmstd))\n    res = np.array(result)\n    crit = 1.96\n    confint = res[:, 1:2] + crit * res[:, -1:] * np.array([[-1, 1]])\n    return np.column_stack((res, confint))",
            "def mean_residual_life(x, frac=None, alpha=0.05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'empirical mean residual life or expected shortfall\\n\\n    Parameters\\n    ----------\\n    x : 1-dimensional array_like\\n    frac : list[float], optional\\n        All entries must be between 0 and 1\\n    alpha : float, default 0.05\\n        FIXME: not actually used.\\n\\n    TODO:\\n        check formula for std of mean\\n        does not include case for all observations\\n        last observations std is zero\\n        vectorize loop using cumsum\\n        frac does not work yet\\n    '\n    axis = 0\n    x = np.asarray(x)\n    nobs = x.shape[axis]\n    xsorted = np.sort(x, axis=axis)\n    if frac is None:\n        xthreshold = xsorted\n    else:\n        xthreshold = xsorted[np.floor(nobs * frac).astype(int)]\n    xlargerindex = np.searchsorted(xsorted, xthreshold, side='right')\n    result = []\n    for i in range(len(xthreshold) - 1):\n        k_ind = xlargerindex[i]\n        rmean = x[k_ind:].mean()\n        rstd = x[k_ind:].std()\n        rmstd = rstd / np.sqrt(nobs - k_ind)\n        result.append((k_ind, xthreshold[i], rmean, rmstd))\n    res = np.array(result)\n    crit = 1.96\n    confint = res[:, 1:2] + crit * res[:, -1:] * np.array([[-1, 1]])\n    return np.column_stack((res, confint))",
            "def mean_residual_life(x, frac=None, alpha=0.05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'empirical mean residual life or expected shortfall\\n\\n    Parameters\\n    ----------\\n    x : 1-dimensional array_like\\n    frac : list[float], optional\\n        All entries must be between 0 and 1\\n    alpha : float, default 0.05\\n        FIXME: not actually used.\\n\\n    TODO:\\n        check formula for std of mean\\n        does not include case for all observations\\n        last observations std is zero\\n        vectorize loop using cumsum\\n        frac does not work yet\\n    '\n    axis = 0\n    x = np.asarray(x)\n    nobs = x.shape[axis]\n    xsorted = np.sort(x, axis=axis)\n    if frac is None:\n        xthreshold = xsorted\n    else:\n        xthreshold = xsorted[np.floor(nobs * frac).astype(int)]\n    xlargerindex = np.searchsorted(xsorted, xthreshold, side='right')\n    result = []\n    for i in range(len(xthreshold) - 1):\n        k_ind = xlargerindex[i]\n        rmean = x[k_ind:].mean()\n        rstd = x[k_ind:].std()\n        rmstd = rstd / np.sqrt(nobs - k_ind)\n        result.append((k_ind, xthreshold[i], rmean, rmstd))\n    res = np.array(result)\n    crit = 1.96\n    confint = res[:, 1:2] + crit * res[:, -1:] * np.array([[-1, 1]])\n    return np.column_stack((res, confint))",
            "def mean_residual_life(x, frac=None, alpha=0.05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'empirical mean residual life or expected shortfall\\n\\n    Parameters\\n    ----------\\n    x : 1-dimensional array_like\\n    frac : list[float], optional\\n        All entries must be between 0 and 1\\n    alpha : float, default 0.05\\n        FIXME: not actually used.\\n\\n    TODO:\\n        check formula for std of mean\\n        does not include case for all observations\\n        last observations std is zero\\n        vectorize loop using cumsum\\n        frac does not work yet\\n    '\n    axis = 0\n    x = np.asarray(x)\n    nobs = x.shape[axis]\n    xsorted = np.sort(x, axis=axis)\n    if frac is None:\n        xthreshold = xsorted\n    else:\n        xthreshold = xsorted[np.floor(nobs * frac).astype(int)]\n    xlargerindex = np.searchsorted(xsorted, xthreshold, side='right')\n    result = []\n    for i in range(len(xthreshold) - 1):\n        k_ind = xlargerindex[i]\n        rmean = x[k_ind:].mean()\n        rstd = x[k_ind:].std()\n        rmstd = rstd / np.sqrt(nobs - k_ind)\n        result.append((k_ind, xthreshold[i], rmean, rmstd))\n    res = np.array(result)\n    crit = 1.96\n    confint = res[:, 1:2] + crit * res[:, -1:] * np.array([[-1, 1]])\n    return np.column_stack((res, confint))",
            "def mean_residual_life(x, frac=None, alpha=0.05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'empirical mean residual life or expected shortfall\\n\\n    Parameters\\n    ----------\\n    x : 1-dimensional array_like\\n    frac : list[float], optional\\n        All entries must be between 0 and 1\\n    alpha : float, default 0.05\\n        FIXME: not actually used.\\n\\n    TODO:\\n        check formula for std of mean\\n        does not include case for all observations\\n        last observations std is zero\\n        vectorize loop using cumsum\\n        frac does not work yet\\n    '\n    axis = 0\n    x = np.asarray(x)\n    nobs = x.shape[axis]\n    xsorted = np.sort(x, axis=axis)\n    if frac is None:\n        xthreshold = xsorted\n    else:\n        xthreshold = xsorted[np.floor(nobs * frac).astype(int)]\n    xlargerindex = np.searchsorted(xsorted, xthreshold, side='right')\n    result = []\n    for i in range(len(xthreshold) - 1):\n        k_ind = xlargerindex[i]\n        rmean = x[k_ind:].mean()\n        rstd = x[k_ind:].std()\n        rmstd = rstd / np.sqrt(nobs - k_ind)\n        result.append((k_ind, xthreshold[i], rmean, rmstd))\n    res = np.array(result)\n    crit = 1.96\n    confint = res[:, 1:2] + crit * res[:, -1:] * np.array([[-1, 1]])\n    return np.column_stack((res, confint))"
        ]
    }
]