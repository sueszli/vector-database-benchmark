[
    {
        "func_name": "compute_kkt_optimality",
        "original": "def compute_kkt_optimality(g, on_bound):\n    \"\"\"Compute the maximum violation of KKT conditions.\"\"\"\n    g_kkt = g * on_bound\n    free_set = on_bound == 0\n    g_kkt[free_set] = np.abs(g[free_set])\n    return np.max(g_kkt)",
        "mutated": [
            "def compute_kkt_optimality(g, on_bound):\n    if False:\n        i = 10\n    'Compute the maximum violation of KKT conditions.'\n    g_kkt = g * on_bound\n    free_set = on_bound == 0\n    g_kkt[free_set] = np.abs(g[free_set])\n    return np.max(g_kkt)",
            "def compute_kkt_optimality(g, on_bound):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the maximum violation of KKT conditions.'\n    g_kkt = g * on_bound\n    free_set = on_bound == 0\n    g_kkt[free_set] = np.abs(g[free_set])\n    return np.max(g_kkt)",
            "def compute_kkt_optimality(g, on_bound):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the maximum violation of KKT conditions.'\n    g_kkt = g * on_bound\n    free_set = on_bound == 0\n    g_kkt[free_set] = np.abs(g[free_set])\n    return np.max(g_kkt)",
            "def compute_kkt_optimality(g, on_bound):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the maximum violation of KKT conditions.'\n    g_kkt = g * on_bound\n    free_set = on_bound == 0\n    g_kkt[free_set] = np.abs(g[free_set])\n    return np.max(g_kkt)",
            "def compute_kkt_optimality(g, on_bound):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the maximum violation of KKT conditions.'\n    g_kkt = g * on_bound\n    free_set = on_bound == 0\n    g_kkt[free_set] = np.abs(g[free_set])\n    return np.max(g_kkt)"
        ]
    },
    {
        "func_name": "bvls",
        "original": "def bvls(A, b, x_lsq, lb, ub, tol, max_iter, verbose, rcond=None):\n    (m, n) = A.shape\n    x = x_lsq.copy()\n    on_bound = np.zeros(n)\n    mask = x <= lb\n    x[mask] = lb[mask]\n    on_bound[mask] = -1\n    mask = x >= ub\n    x[mask] = ub[mask]\n    on_bound[mask] = 1\n    free_set = on_bound == 0\n    active_set = ~free_set\n    (free_set,) = np.nonzero(free_set)\n    r = A.dot(x) - b\n    cost = 0.5 * np.dot(r, r)\n    initial_cost = cost\n    g = A.T.dot(r)\n    cost_change = None\n    step_norm = None\n    iteration = 0\n    if verbose == 2:\n        print_header_linear()\n    while free_set.size > 0:\n        if verbose == 2:\n            optimality = compute_kkt_optimality(g, on_bound)\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        iteration += 1\n        x_free_old = x[free_set].copy()\n        A_free = A[:, free_set]\n        b_free = b - A.dot(x * active_set)\n        z = lstsq(A_free, b_free, rcond=rcond)[0]\n        lbv = z < lb[free_set]\n        ubv = z > ub[free_set]\n        v = lbv | ubv\n        if np.any(lbv):\n            ind = free_set[lbv]\n            x[ind] = lb[ind]\n            active_set[ind] = True\n            on_bound[ind] = -1\n        if np.any(ubv):\n            ind = free_set[ubv]\n            x[ind] = ub[ind]\n            active_set[ind] = True\n            on_bound[ind] = 1\n        ind = free_set[~v]\n        x[ind] = z[~v]\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        cost = cost_new\n        g = A.T.dot(r)\n        step_norm = norm(x[free_set] - x_free_old)\n        if np.any(v):\n            free_set = free_set[~v]\n        else:\n            break\n    if max_iter is None:\n        max_iter = n\n    max_iter += iteration\n    termination_status = None\n    optimality = compute_kkt_optimality(g, on_bound)\n    for iteration in range(iteration, max_iter):\n        if verbose == 2:\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        if optimality < tol:\n            termination_status = 1\n        if termination_status is not None:\n            break\n        move_to_free = np.argmax(g * on_bound)\n        on_bound[move_to_free] = 0\n        while True:\n            free_set = on_bound == 0\n            active_set = ~free_set\n            (free_set,) = np.nonzero(free_set)\n            x_free = x[free_set]\n            x_free_old = x_free.copy()\n            lb_free = lb[free_set]\n            ub_free = ub[free_set]\n            A_free = A[:, free_set]\n            b_free = b - A.dot(x * active_set)\n            z = lstsq(A_free, b_free, rcond=rcond)[0]\n            (lbv,) = np.nonzero(z < lb_free)\n            (ubv,) = np.nonzero(z > ub_free)\n            v = np.hstack((lbv, ubv))\n            if v.size > 0:\n                alphas = np.hstack((lb_free[lbv] - x_free[lbv], ub_free[ubv] - x_free[ubv])) / (z[v] - x_free[v])\n                i = np.argmin(alphas)\n                i_free = v[i]\n                alpha = alphas[i]\n                x_free *= 1 - alpha\n                x_free += alpha * z\n                x[free_set] = x_free\n                if i < lbv.size:\n                    on_bound[free_set[i_free]] = -1\n                else:\n                    on_bound[free_set[i_free]] = 1\n            else:\n                x_free = z\n                x[free_set] = x_free\n                break\n        step_norm = norm(x_free - x_free_old)\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        if cost_change < tol * cost:\n            termination_status = 2\n        cost = cost_new\n        g = A.T.dot(r)\n        optimality = compute_kkt_optimality(g, on_bound)\n    if termination_status is None:\n        termination_status = 0\n    return OptimizeResult(x=x, fun=r, cost=cost, optimality=optimality, active_mask=on_bound, nit=iteration + 1, status=termination_status, initial_cost=initial_cost)",
        "mutated": [
            "def bvls(A, b, x_lsq, lb, ub, tol, max_iter, verbose, rcond=None):\n    if False:\n        i = 10\n    (m, n) = A.shape\n    x = x_lsq.copy()\n    on_bound = np.zeros(n)\n    mask = x <= lb\n    x[mask] = lb[mask]\n    on_bound[mask] = -1\n    mask = x >= ub\n    x[mask] = ub[mask]\n    on_bound[mask] = 1\n    free_set = on_bound == 0\n    active_set = ~free_set\n    (free_set,) = np.nonzero(free_set)\n    r = A.dot(x) - b\n    cost = 0.5 * np.dot(r, r)\n    initial_cost = cost\n    g = A.T.dot(r)\n    cost_change = None\n    step_norm = None\n    iteration = 0\n    if verbose == 2:\n        print_header_linear()\n    while free_set.size > 0:\n        if verbose == 2:\n            optimality = compute_kkt_optimality(g, on_bound)\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        iteration += 1\n        x_free_old = x[free_set].copy()\n        A_free = A[:, free_set]\n        b_free = b - A.dot(x * active_set)\n        z = lstsq(A_free, b_free, rcond=rcond)[0]\n        lbv = z < lb[free_set]\n        ubv = z > ub[free_set]\n        v = lbv | ubv\n        if np.any(lbv):\n            ind = free_set[lbv]\n            x[ind] = lb[ind]\n            active_set[ind] = True\n            on_bound[ind] = -1\n        if np.any(ubv):\n            ind = free_set[ubv]\n            x[ind] = ub[ind]\n            active_set[ind] = True\n            on_bound[ind] = 1\n        ind = free_set[~v]\n        x[ind] = z[~v]\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        cost = cost_new\n        g = A.T.dot(r)\n        step_norm = norm(x[free_set] - x_free_old)\n        if np.any(v):\n            free_set = free_set[~v]\n        else:\n            break\n    if max_iter is None:\n        max_iter = n\n    max_iter += iteration\n    termination_status = None\n    optimality = compute_kkt_optimality(g, on_bound)\n    for iteration in range(iteration, max_iter):\n        if verbose == 2:\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        if optimality < tol:\n            termination_status = 1\n        if termination_status is not None:\n            break\n        move_to_free = np.argmax(g * on_bound)\n        on_bound[move_to_free] = 0\n        while True:\n            free_set = on_bound == 0\n            active_set = ~free_set\n            (free_set,) = np.nonzero(free_set)\n            x_free = x[free_set]\n            x_free_old = x_free.copy()\n            lb_free = lb[free_set]\n            ub_free = ub[free_set]\n            A_free = A[:, free_set]\n            b_free = b - A.dot(x * active_set)\n            z = lstsq(A_free, b_free, rcond=rcond)[0]\n            (lbv,) = np.nonzero(z < lb_free)\n            (ubv,) = np.nonzero(z > ub_free)\n            v = np.hstack((lbv, ubv))\n            if v.size > 0:\n                alphas = np.hstack((lb_free[lbv] - x_free[lbv], ub_free[ubv] - x_free[ubv])) / (z[v] - x_free[v])\n                i = np.argmin(alphas)\n                i_free = v[i]\n                alpha = alphas[i]\n                x_free *= 1 - alpha\n                x_free += alpha * z\n                x[free_set] = x_free\n                if i < lbv.size:\n                    on_bound[free_set[i_free]] = -1\n                else:\n                    on_bound[free_set[i_free]] = 1\n            else:\n                x_free = z\n                x[free_set] = x_free\n                break\n        step_norm = norm(x_free - x_free_old)\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        if cost_change < tol * cost:\n            termination_status = 2\n        cost = cost_new\n        g = A.T.dot(r)\n        optimality = compute_kkt_optimality(g, on_bound)\n    if termination_status is None:\n        termination_status = 0\n    return OptimizeResult(x=x, fun=r, cost=cost, optimality=optimality, active_mask=on_bound, nit=iteration + 1, status=termination_status, initial_cost=initial_cost)",
            "def bvls(A, b, x_lsq, lb, ub, tol, max_iter, verbose, rcond=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (m, n) = A.shape\n    x = x_lsq.copy()\n    on_bound = np.zeros(n)\n    mask = x <= lb\n    x[mask] = lb[mask]\n    on_bound[mask] = -1\n    mask = x >= ub\n    x[mask] = ub[mask]\n    on_bound[mask] = 1\n    free_set = on_bound == 0\n    active_set = ~free_set\n    (free_set,) = np.nonzero(free_set)\n    r = A.dot(x) - b\n    cost = 0.5 * np.dot(r, r)\n    initial_cost = cost\n    g = A.T.dot(r)\n    cost_change = None\n    step_norm = None\n    iteration = 0\n    if verbose == 2:\n        print_header_linear()\n    while free_set.size > 0:\n        if verbose == 2:\n            optimality = compute_kkt_optimality(g, on_bound)\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        iteration += 1\n        x_free_old = x[free_set].copy()\n        A_free = A[:, free_set]\n        b_free = b - A.dot(x * active_set)\n        z = lstsq(A_free, b_free, rcond=rcond)[0]\n        lbv = z < lb[free_set]\n        ubv = z > ub[free_set]\n        v = lbv | ubv\n        if np.any(lbv):\n            ind = free_set[lbv]\n            x[ind] = lb[ind]\n            active_set[ind] = True\n            on_bound[ind] = -1\n        if np.any(ubv):\n            ind = free_set[ubv]\n            x[ind] = ub[ind]\n            active_set[ind] = True\n            on_bound[ind] = 1\n        ind = free_set[~v]\n        x[ind] = z[~v]\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        cost = cost_new\n        g = A.T.dot(r)\n        step_norm = norm(x[free_set] - x_free_old)\n        if np.any(v):\n            free_set = free_set[~v]\n        else:\n            break\n    if max_iter is None:\n        max_iter = n\n    max_iter += iteration\n    termination_status = None\n    optimality = compute_kkt_optimality(g, on_bound)\n    for iteration in range(iteration, max_iter):\n        if verbose == 2:\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        if optimality < tol:\n            termination_status = 1\n        if termination_status is not None:\n            break\n        move_to_free = np.argmax(g * on_bound)\n        on_bound[move_to_free] = 0\n        while True:\n            free_set = on_bound == 0\n            active_set = ~free_set\n            (free_set,) = np.nonzero(free_set)\n            x_free = x[free_set]\n            x_free_old = x_free.copy()\n            lb_free = lb[free_set]\n            ub_free = ub[free_set]\n            A_free = A[:, free_set]\n            b_free = b - A.dot(x * active_set)\n            z = lstsq(A_free, b_free, rcond=rcond)[0]\n            (lbv,) = np.nonzero(z < lb_free)\n            (ubv,) = np.nonzero(z > ub_free)\n            v = np.hstack((lbv, ubv))\n            if v.size > 0:\n                alphas = np.hstack((lb_free[lbv] - x_free[lbv], ub_free[ubv] - x_free[ubv])) / (z[v] - x_free[v])\n                i = np.argmin(alphas)\n                i_free = v[i]\n                alpha = alphas[i]\n                x_free *= 1 - alpha\n                x_free += alpha * z\n                x[free_set] = x_free\n                if i < lbv.size:\n                    on_bound[free_set[i_free]] = -1\n                else:\n                    on_bound[free_set[i_free]] = 1\n            else:\n                x_free = z\n                x[free_set] = x_free\n                break\n        step_norm = norm(x_free - x_free_old)\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        if cost_change < tol * cost:\n            termination_status = 2\n        cost = cost_new\n        g = A.T.dot(r)\n        optimality = compute_kkt_optimality(g, on_bound)\n    if termination_status is None:\n        termination_status = 0\n    return OptimizeResult(x=x, fun=r, cost=cost, optimality=optimality, active_mask=on_bound, nit=iteration + 1, status=termination_status, initial_cost=initial_cost)",
            "def bvls(A, b, x_lsq, lb, ub, tol, max_iter, verbose, rcond=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (m, n) = A.shape\n    x = x_lsq.copy()\n    on_bound = np.zeros(n)\n    mask = x <= lb\n    x[mask] = lb[mask]\n    on_bound[mask] = -1\n    mask = x >= ub\n    x[mask] = ub[mask]\n    on_bound[mask] = 1\n    free_set = on_bound == 0\n    active_set = ~free_set\n    (free_set,) = np.nonzero(free_set)\n    r = A.dot(x) - b\n    cost = 0.5 * np.dot(r, r)\n    initial_cost = cost\n    g = A.T.dot(r)\n    cost_change = None\n    step_norm = None\n    iteration = 0\n    if verbose == 2:\n        print_header_linear()\n    while free_set.size > 0:\n        if verbose == 2:\n            optimality = compute_kkt_optimality(g, on_bound)\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        iteration += 1\n        x_free_old = x[free_set].copy()\n        A_free = A[:, free_set]\n        b_free = b - A.dot(x * active_set)\n        z = lstsq(A_free, b_free, rcond=rcond)[0]\n        lbv = z < lb[free_set]\n        ubv = z > ub[free_set]\n        v = lbv | ubv\n        if np.any(lbv):\n            ind = free_set[lbv]\n            x[ind] = lb[ind]\n            active_set[ind] = True\n            on_bound[ind] = -1\n        if np.any(ubv):\n            ind = free_set[ubv]\n            x[ind] = ub[ind]\n            active_set[ind] = True\n            on_bound[ind] = 1\n        ind = free_set[~v]\n        x[ind] = z[~v]\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        cost = cost_new\n        g = A.T.dot(r)\n        step_norm = norm(x[free_set] - x_free_old)\n        if np.any(v):\n            free_set = free_set[~v]\n        else:\n            break\n    if max_iter is None:\n        max_iter = n\n    max_iter += iteration\n    termination_status = None\n    optimality = compute_kkt_optimality(g, on_bound)\n    for iteration in range(iteration, max_iter):\n        if verbose == 2:\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        if optimality < tol:\n            termination_status = 1\n        if termination_status is not None:\n            break\n        move_to_free = np.argmax(g * on_bound)\n        on_bound[move_to_free] = 0\n        while True:\n            free_set = on_bound == 0\n            active_set = ~free_set\n            (free_set,) = np.nonzero(free_set)\n            x_free = x[free_set]\n            x_free_old = x_free.copy()\n            lb_free = lb[free_set]\n            ub_free = ub[free_set]\n            A_free = A[:, free_set]\n            b_free = b - A.dot(x * active_set)\n            z = lstsq(A_free, b_free, rcond=rcond)[0]\n            (lbv,) = np.nonzero(z < lb_free)\n            (ubv,) = np.nonzero(z > ub_free)\n            v = np.hstack((lbv, ubv))\n            if v.size > 0:\n                alphas = np.hstack((lb_free[lbv] - x_free[lbv], ub_free[ubv] - x_free[ubv])) / (z[v] - x_free[v])\n                i = np.argmin(alphas)\n                i_free = v[i]\n                alpha = alphas[i]\n                x_free *= 1 - alpha\n                x_free += alpha * z\n                x[free_set] = x_free\n                if i < lbv.size:\n                    on_bound[free_set[i_free]] = -1\n                else:\n                    on_bound[free_set[i_free]] = 1\n            else:\n                x_free = z\n                x[free_set] = x_free\n                break\n        step_norm = norm(x_free - x_free_old)\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        if cost_change < tol * cost:\n            termination_status = 2\n        cost = cost_new\n        g = A.T.dot(r)\n        optimality = compute_kkt_optimality(g, on_bound)\n    if termination_status is None:\n        termination_status = 0\n    return OptimizeResult(x=x, fun=r, cost=cost, optimality=optimality, active_mask=on_bound, nit=iteration + 1, status=termination_status, initial_cost=initial_cost)",
            "def bvls(A, b, x_lsq, lb, ub, tol, max_iter, verbose, rcond=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (m, n) = A.shape\n    x = x_lsq.copy()\n    on_bound = np.zeros(n)\n    mask = x <= lb\n    x[mask] = lb[mask]\n    on_bound[mask] = -1\n    mask = x >= ub\n    x[mask] = ub[mask]\n    on_bound[mask] = 1\n    free_set = on_bound == 0\n    active_set = ~free_set\n    (free_set,) = np.nonzero(free_set)\n    r = A.dot(x) - b\n    cost = 0.5 * np.dot(r, r)\n    initial_cost = cost\n    g = A.T.dot(r)\n    cost_change = None\n    step_norm = None\n    iteration = 0\n    if verbose == 2:\n        print_header_linear()\n    while free_set.size > 0:\n        if verbose == 2:\n            optimality = compute_kkt_optimality(g, on_bound)\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        iteration += 1\n        x_free_old = x[free_set].copy()\n        A_free = A[:, free_set]\n        b_free = b - A.dot(x * active_set)\n        z = lstsq(A_free, b_free, rcond=rcond)[0]\n        lbv = z < lb[free_set]\n        ubv = z > ub[free_set]\n        v = lbv | ubv\n        if np.any(lbv):\n            ind = free_set[lbv]\n            x[ind] = lb[ind]\n            active_set[ind] = True\n            on_bound[ind] = -1\n        if np.any(ubv):\n            ind = free_set[ubv]\n            x[ind] = ub[ind]\n            active_set[ind] = True\n            on_bound[ind] = 1\n        ind = free_set[~v]\n        x[ind] = z[~v]\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        cost = cost_new\n        g = A.T.dot(r)\n        step_norm = norm(x[free_set] - x_free_old)\n        if np.any(v):\n            free_set = free_set[~v]\n        else:\n            break\n    if max_iter is None:\n        max_iter = n\n    max_iter += iteration\n    termination_status = None\n    optimality = compute_kkt_optimality(g, on_bound)\n    for iteration in range(iteration, max_iter):\n        if verbose == 2:\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        if optimality < tol:\n            termination_status = 1\n        if termination_status is not None:\n            break\n        move_to_free = np.argmax(g * on_bound)\n        on_bound[move_to_free] = 0\n        while True:\n            free_set = on_bound == 0\n            active_set = ~free_set\n            (free_set,) = np.nonzero(free_set)\n            x_free = x[free_set]\n            x_free_old = x_free.copy()\n            lb_free = lb[free_set]\n            ub_free = ub[free_set]\n            A_free = A[:, free_set]\n            b_free = b - A.dot(x * active_set)\n            z = lstsq(A_free, b_free, rcond=rcond)[0]\n            (lbv,) = np.nonzero(z < lb_free)\n            (ubv,) = np.nonzero(z > ub_free)\n            v = np.hstack((lbv, ubv))\n            if v.size > 0:\n                alphas = np.hstack((lb_free[lbv] - x_free[lbv], ub_free[ubv] - x_free[ubv])) / (z[v] - x_free[v])\n                i = np.argmin(alphas)\n                i_free = v[i]\n                alpha = alphas[i]\n                x_free *= 1 - alpha\n                x_free += alpha * z\n                x[free_set] = x_free\n                if i < lbv.size:\n                    on_bound[free_set[i_free]] = -1\n                else:\n                    on_bound[free_set[i_free]] = 1\n            else:\n                x_free = z\n                x[free_set] = x_free\n                break\n        step_norm = norm(x_free - x_free_old)\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        if cost_change < tol * cost:\n            termination_status = 2\n        cost = cost_new\n        g = A.T.dot(r)\n        optimality = compute_kkt_optimality(g, on_bound)\n    if termination_status is None:\n        termination_status = 0\n    return OptimizeResult(x=x, fun=r, cost=cost, optimality=optimality, active_mask=on_bound, nit=iteration + 1, status=termination_status, initial_cost=initial_cost)",
            "def bvls(A, b, x_lsq, lb, ub, tol, max_iter, verbose, rcond=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (m, n) = A.shape\n    x = x_lsq.copy()\n    on_bound = np.zeros(n)\n    mask = x <= lb\n    x[mask] = lb[mask]\n    on_bound[mask] = -1\n    mask = x >= ub\n    x[mask] = ub[mask]\n    on_bound[mask] = 1\n    free_set = on_bound == 0\n    active_set = ~free_set\n    (free_set,) = np.nonzero(free_set)\n    r = A.dot(x) - b\n    cost = 0.5 * np.dot(r, r)\n    initial_cost = cost\n    g = A.T.dot(r)\n    cost_change = None\n    step_norm = None\n    iteration = 0\n    if verbose == 2:\n        print_header_linear()\n    while free_set.size > 0:\n        if verbose == 2:\n            optimality = compute_kkt_optimality(g, on_bound)\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        iteration += 1\n        x_free_old = x[free_set].copy()\n        A_free = A[:, free_set]\n        b_free = b - A.dot(x * active_set)\n        z = lstsq(A_free, b_free, rcond=rcond)[0]\n        lbv = z < lb[free_set]\n        ubv = z > ub[free_set]\n        v = lbv | ubv\n        if np.any(lbv):\n            ind = free_set[lbv]\n            x[ind] = lb[ind]\n            active_set[ind] = True\n            on_bound[ind] = -1\n        if np.any(ubv):\n            ind = free_set[ubv]\n            x[ind] = ub[ind]\n            active_set[ind] = True\n            on_bound[ind] = 1\n        ind = free_set[~v]\n        x[ind] = z[~v]\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        cost = cost_new\n        g = A.T.dot(r)\n        step_norm = norm(x[free_set] - x_free_old)\n        if np.any(v):\n            free_set = free_set[~v]\n        else:\n            break\n    if max_iter is None:\n        max_iter = n\n    max_iter += iteration\n    termination_status = None\n    optimality = compute_kkt_optimality(g, on_bound)\n    for iteration in range(iteration, max_iter):\n        if verbose == 2:\n            print_iteration_linear(iteration, cost, cost_change, step_norm, optimality)\n        if optimality < tol:\n            termination_status = 1\n        if termination_status is not None:\n            break\n        move_to_free = np.argmax(g * on_bound)\n        on_bound[move_to_free] = 0\n        while True:\n            free_set = on_bound == 0\n            active_set = ~free_set\n            (free_set,) = np.nonzero(free_set)\n            x_free = x[free_set]\n            x_free_old = x_free.copy()\n            lb_free = lb[free_set]\n            ub_free = ub[free_set]\n            A_free = A[:, free_set]\n            b_free = b - A.dot(x * active_set)\n            z = lstsq(A_free, b_free, rcond=rcond)[0]\n            (lbv,) = np.nonzero(z < lb_free)\n            (ubv,) = np.nonzero(z > ub_free)\n            v = np.hstack((lbv, ubv))\n            if v.size > 0:\n                alphas = np.hstack((lb_free[lbv] - x_free[lbv], ub_free[ubv] - x_free[ubv])) / (z[v] - x_free[v])\n                i = np.argmin(alphas)\n                i_free = v[i]\n                alpha = alphas[i]\n                x_free *= 1 - alpha\n                x_free += alpha * z\n                x[free_set] = x_free\n                if i < lbv.size:\n                    on_bound[free_set[i_free]] = -1\n                else:\n                    on_bound[free_set[i_free]] = 1\n            else:\n                x_free = z\n                x[free_set] = x_free\n                break\n        step_norm = norm(x_free - x_free_old)\n        r = A.dot(x) - b\n        cost_new = 0.5 * np.dot(r, r)\n        cost_change = cost - cost_new\n        if cost_change < tol * cost:\n            termination_status = 2\n        cost = cost_new\n        g = A.T.dot(r)\n        optimality = compute_kkt_optimality(g, on_bound)\n    if termination_status is None:\n        termination_status = 0\n    return OptimizeResult(x=x, fun=r, cost=cost, optimality=optimality, active_mask=on_bound, nit=iteration + 1, status=termination_status, initial_cost=initial_cost)"
        ]
    }
]