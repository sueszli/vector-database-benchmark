[
    {
        "func_name": "expand_labels",
        "original": "def expand_labels(label_image, distance=1):\n    \"\"\"Expand labels in label image by ``distance`` pixels without overlapping.\n\n    Given a label image, ``expand_labels`` grows label regions (connected components)\n    outwards by up to ``distance`` pixels without overflowing into neighboring regions.\n    More specifically, each background pixel that is within Euclidean distance\n    of <= ``distance`` pixels of a connected component is assigned the label of that\n    connected component.\n    Where multiple connected components are within ``distance`` pixels of a background\n    pixel, the label value of the closest connected component will be assigned (see\n    Notes for the case of multiple labels at equal distance).\n\n    Parameters\n    ----------\n    label_image : ndarray of dtype int\n        label image\n    distance : float\n        Euclidean distance in pixels by which to grow the labels. Default is one.\n\n    Returns\n    -------\n    enlarged_labels : ndarray of dtype int\n        Labeled array, where all connected regions have been enlarged\n\n    Notes\n    -----\n    Where labels are spaced more than ``distance`` pixels are apart, this is\n    equivalent to a morphological dilation with a disc or hyperball of radius ``distance``.\n    However, in contrast to a morphological dilation, ``expand_labels`` will\n    not expand a label region into a neighboring region.\n\n    This implementation of ``expand_labels`` is derived from CellProfiler [1]_, where\n    it is known as module \"IdentifySecondaryObjects (Distance-N)\" [2]_.\n\n    There is an important edge case when a pixel has the same distance to\n    multiple regions, as it is not defined which region expands into that\n    space. Here, the exact behavior depends on the upstream implementation\n    of ``scipy.ndimage.distance_transform_edt``.\n\n    See Also\n    --------\n    :func:`skimage.measure.label`, :func:`skimage.segmentation.watershed`, :func:`skimage.morphology.dilation`\n\n    References\n    ----------\n    .. [1] https://cellprofiler.org\n    .. [2] https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559\n\n    Examples\n    --------\n    >>> labels = np.array([0, 1, 0, 0, 0, 0, 2])\n    >>> expand_labels(labels, distance=1)\n    array([1, 1, 1, 0, 0, 2, 2])\n\n    Labels will not overwrite each other:\n\n    >>> expand_labels(labels, distance=3)\n    array([1, 1, 1, 1, 2, 2, 2])\n\n    In case of ties, behavior is undefined, but currently resolves to the\n    label closest to ``(0,) * ndim`` in lexicographical order.\n\n    >>> labels_tied = np.array([0, 1, 0, 2, 0])\n    >>> expand_labels(labels_tied, 1)\n    array([1, 1, 1, 2, 2])\n    >>> labels2d = np.array(\n    ...     [[0, 1, 0, 0],\n    ...      [2, 0, 0, 0],\n    ...      [0, 3, 0, 0]]\n    ... )\n    >>> expand_labels(labels2d, 1)\n    array([[2, 1, 1, 0],\n           [2, 2, 0, 0],\n           [2, 3, 3, 0]])\n    \"\"\"\n    (distances, nearest_label_coords) = distance_transform_edt(label_image == 0, return_indices=True)\n    labels_out = np.zeros_like(label_image)\n    dilate_mask = distances <= distance\n    masked_nearest_label_coords = [dimension_indices[dilate_mask] for dimension_indices in nearest_label_coords]\n    nearest_labels = label_image[tuple(masked_nearest_label_coords)]\n    labels_out[dilate_mask] = nearest_labels\n    return labels_out",
        "mutated": [
            "def expand_labels(label_image, distance=1):\n    if False:\n        i = 10\n    'Expand labels in label image by ``distance`` pixels without overlapping.\\n\\n    Given a label image, ``expand_labels`` grows label regions (connected components)\\n    outwards by up to ``distance`` pixels without overflowing into neighboring regions.\\n    More specifically, each background pixel that is within Euclidean distance\\n    of <= ``distance`` pixels of a connected component is assigned the label of that\\n    connected component.\\n    Where multiple connected components are within ``distance`` pixels of a background\\n    pixel, the label value of the closest connected component will be assigned (see\\n    Notes for the case of multiple labels at equal distance).\\n\\n    Parameters\\n    ----------\\n    label_image : ndarray of dtype int\\n        label image\\n    distance : float\\n        Euclidean distance in pixels by which to grow the labels. Default is one.\\n\\n    Returns\\n    -------\\n    enlarged_labels : ndarray of dtype int\\n        Labeled array, where all connected regions have been enlarged\\n\\n    Notes\\n    -----\\n    Where labels are spaced more than ``distance`` pixels are apart, this is\\n    equivalent to a morphological dilation with a disc or hyperball of radius ``distance``.\\n    However, in contrast to a morphological dilation, ``expand_labels`` will\\n    not expand a label region into a neighboring region.\\n\\n    This implementation of ``expand_labels`` is derived from CellProfiler [1]_, where\\n    it is known as module \"IdentifySecondaryObjects (Distance-N)\" [2]_.\\n\\n    There is an important edge case when a pixel has the same distance to\\n    multiple regions, as it is not defined which region expands into that\\n    space. Here, the exact behavior depends on the upstream implementation\\n    of ``scipy.ndimage.distance_transform_edt``.\\n\\n    See Also\\n    --------\\n    :func:`skimage.measure.label`, :func:`skimage.segmentation.watershed`, :func:`skimage.morphology.dilation`\\n\\n    References\\n    ----------\\n    .. [1] https://cellprofiler.org\\n    .. [2] https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559\\n\\n    Examples\\n    --------\\n    >>> labels = np.array([0, 1, 0, 0, 0, 0, 2])\\n    >>> expand_labels(labels, distance=1)\\n    array([1, 1, 1, 0, 0, 2, 2])\\n\\n    Labels will not overwrite each other:\\n\\n    >>> expand_labels(labels, distance=3)\\n    array([1, 1, 1, 1, 2, 2, 2])\\n\\n    In case of ties, behavior is undefined, but currently resolves to the\\n    label closest to ``(0,) * ndim`` in lexicographical order.\\n\\n    >>> labels_tied = np.array([0, 1, 0, 2, 0])\\n    >>> expand_labels(labels_tied, 1)\\n    array([1, 1, 1, 2, 2])\\n    >>> labels2d = np.array(\\n    ...     [[0, 1, 0, 0],\\n    ...      [2, 0, 0, 0],\\n    ...      [0, 3, 0, 0]]\\n    ... )\\n    >>> expand_labels(labels2d, 1)\\n    array([[2, 1, 1, 0],\\n           [2, 2, 0, 0],\\n           [2, 3, 3, 0]])\\n    '\n    (distances, nearest_label_coords) = distance_transform_edt(label_image == 0, return_indices=True)\n    labels_out = np.zeros_like(label_image)\n    dilate_mask = distances <= distance\n    masked_nearest_label_coords = [dimension_indices[dilate_mask] for dimension_indices in nearest_label_coords]\n    nearest_labels = label_image[tuple(masked_nearest_label_coords)]\n    labels_out[dilate_mask] = nearest_labels\n    return labels_out",
            "def expand_labels(label_image, distance=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Expand labels in label image by ``distance`` pixels without overlapping.\\n\\n    Given a label image, ``expand_labels`` grows label regions (connected components)\\n    outwards by up to ``distance`` pixels without overflowing into neighboring regions.\\n    More specifically, each background pixel that is within Euclidean distance\\n    of <= ``distance`` pixels of a connected component is assigned the label of that\\n    connected component.\\n    Where multiple connected components are within ``distance`` pixels of a background\\n    pixel, the label value of the closest connected component will be assigned (see\\n    Notes for the case of multiple labels at equal distance).\\n\\n    Parameters\\n    ----------\\n    label_image : ndarray of dtype int\\n        label image\\n    distance : float\\n        Euclidean distance in pixels by which to grow the labels. Default is one.\\n\\n    Returns\\n    -------\\n    enlarged_labels : ndarray of dtype int\\n        Labeled array, where all connected regions have been enlarged\\n\\n    Notes\\n    -----\\n    Where labels are spaced more than ``distance`` pixels are apart, this is\\n    equivalent to a morphological dilation with a disc or hyperball of radius ``distance``.\\n    However, in contrast to a morphological dilation, ``expand_labels`` will\\n    not expand a label region into a neighboring region.\\n\\n    This implementation of ``expand_labels`` is derived from CellProfiler [1]_, where\\n    it is known as module \"IdentifySecondaryObjects (Distance-N)\" [2]_.\\n\\n    There is an important edge case when a pixel has the same distance to\\n    multiple regions, as it is not defined which region expands into that\\n    space. Here, the exact behavior depends on the upstream implementation\\n    of ``scipy.ndimage.distance_transform_edt``.\\n\\n    See Also\\n    --------\\n    :func:`skimage.measure.label`, :func:`skimage.segmentation.watershed`, :func:`skimage.morphology.dilation`\\n\\n    References\\n    ----------\\n    .. [1] https://cellprofiler.org\\n    .. [2] https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559\\n\\n    Examples\\n    --------\\n    >>> labels = np.array([0, 1, 0, 0, 0, 0, 2])\\n    >>> expand_labels(labels, distance=1)\\n    array([1, 1, 1, 0, 0, 2, 2])\\n\\n    Labels will not overwrite each other:\\n\\n    >>> expand_labels(labels, distance=3)\\n    array([1, 1, 1, 1, 2, 2, 2])\\n\\n    In case of ties, behavior is undefined, but currently resolves to the\\n    label closest to ``(0,) * ndim`` in lexicographical order.\\n\\n    >>> labels_tied = np.array([0, 1, 0, 2, 0])\\n    >>> expand_labels(labels_tied, 1)\\n    array([1, 1, 1, 2, 2])\\n    >>> labels2d = np.array(\\n    ...     [[0, 1, 0, 0],\\n    ...      [2, 0, 0, 0],\\n    ...      [0, 3, 0, 0]]\\n    ... )\\n    >>> expand_labels(labels2d, 1)\\n    array([[2, 1, 1, 0],\\n           [2, 2, 0, 0],\\n           [2, 3, 3, 0]])\\n    '\n    (distances, nearest_label_coords) = distance_transform_edt(label_image == 0, return_indices=True)\n    labels_out = np.zeros_like(label_image)\n    dilate_mask = distances <= distance\n    masked_nearest_label_coords = [dimension_indices[dilate_mask] for dimension_indices in nearest_label_coords]\n    nearest_labels = label_image[tuple(masked_nearest_label_coords)]\n    labels_out[dilate_mask] = nearest_labels\n    return labels_out",
            "def expand_labels(label_image, distance=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Expand labels in label image by ``distance`` pixels without overlapping.\\n\\n    Given a label image, ``expand_labels`` grows label regions (connected components)\\n    outwards by up to ``distance`` pixels without overflowing into neighboring regions.\\n    More specifically, each background pixel that is within Euclidean distance\\n    of <= ``distance`` pixels of a connected component is assigned the label of that\\n    connected component.\\n    Where multiple connected components are within ``distance`` pixels of a background\\n    pixel, the label value of the closest connected component will be assigned (see\\n    Notes for the case of multiple labels at equal distance).\\n\\n    Parameters\\n    ----------\\n    label_image : ndarray of dtype int\\n        label image\\n    distance : float\\n        Euclidean distance in pixels by which to grow the labels. Default is one.\\n\\n    Returns\\n    -------\\n    enlarged_labels : ndarray of dtype int\\n        Labeled array, where all connected regions have been enlarged\\n\\n    Notes\\n    -----\\n    Where labels are spaced more than ``distance`` pixels are apart, this is\\n    equivalent to a morphological dilation with a disc or hyperball of radius ``distance``.\\n    However, in contrast to a morphological dilation, ``expand_labels`` will\\n    not expand a label region into a neighboring region.\\n\\n    This implementation of ``expand_labels`` is derived from CellProfiler [1]_, where\\n    it is known as module \"IdentifySecondaryObjects (Distance-N)\" [2]_.\\n\\n    There is an important edge case when a pixel has the same distance to\\n    multiple regions, as it is not defined which region expands into that\\n    space. Here, the exact behavior depends on the upstream implementation\\n    of ``scipy.ndimage.distance_transform_edt``.\\n\\n    See Also\\n    --------\\n    :func:`skimage.measure.label`, :func:`skimage.segmentation.watershed`, :func:`skimage.morphology.dilation`\\n\\n    References\\n    ----------\\n    .. [1] https://cellprofiler.org\\n    .. [2] https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559\\n\\n    Examples\\n    --------\\n    >>> labels = np.array([0, 1, 0, 0, 0, 0, 2])\\n    >>> expand_labels(labels, distance=1)\\n    array([1, 1, 1, 0, 0, 2, 2])\\n\\n    Labels will not overwrite each other:\\n\\n    >>> expand_labels(labels, distance=3)\\n    array([1, 1, 1, 1, 2, 2, 2])\\n\\n    In case of ties, behavior is undefined, but currently resolves to the\\n    label closest to ``(0,) * ndim`` in lexicographical order.\\n\\n    >>> labels_tied = np.array([0, 1, 0, 2, 0])\\n    >>> expand_labels(labels_tied, 1)\\n    array([1, 1, 1, 2, 2])\\n    >>> labels2d = np.array(\\n    ...     [[0, 1, 0, 0],\\n    ...      [2, 0, 0, 0],\\n    ...      [0, 3, 0, 0]]\\n    ... )\\n    >>> expand_labels(labels2d, 1)\\n    array([[2, 1, 1, 0],\\n           [2, 2, 0, 0],\\n           [2, 3, 3, 0]])\\n    '\n    (distances, nearest_label_coords) = distance_transform_edt(label_image == 0, return_indices=True)\n    labels_out = np.zeros_like(label_image)\n    dilate_mask = distances <= distance\n    masked_nearest_label_coords = [dimension_indices[dilate_mask] for dimension_indices in nearest_label_coords]\n    nearest_labels = label_image[tuple(masked_nearest_label_coords)]\n    labels_out[dilate_mask] = nearest_labels\n    return labels_out",
            "def expand_labels(label_image, distance=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Expand labels in label image by ``distance`` pixels without overlapping.\\n\\n    Given a label image, ``expand_labels`` grows label regions (connected components)\\n    outwards by up to ``distance`` pixels without overflowing into neighboring regions.\\n    More specifically, each background pixel that is within Euclidean distance\\n    of <= ``distance`` pixels of a connected component is assigned the label of that\\n    connected component.\\n    Where multiple connected components are within ``distance`` pixels of a background\\n    pixel, the label value of the closest connected component will be assigned (see\\n    Notes for the case of multiple labels at equal distance).\\n\\n    Parameters\\n    ----------\\n    label_image : ndarray of dtype int\\n        label image\\n    distance : float\\n        Euclidean distance in pixels by which to grow the labels. Default is one.\\n\\n    Returns\\n    -------\\n    enlarged_labels : ndarray of dtype int\\n        Labeled array, where all connected regions have been enlarged\\n\\n    Notes\\n    -----\\n    Where labels are spaced more than ``distance`` pixels are apart, this is\\n    equivalent to a morphological dilation with a disc or hyperball of radius ``distance``.\\n    However, in contrast to a morphological dilation, ``expand_labels`` will\\n    not expand a label region into a neighboring region.\\n\\n    This implementation of ``expand_labels`` is derived from CellProfiler [1]_, where\\n    it is known as module \"IdentifySecondaryObjects (Distance-N)\" [2]_.\\n\\n    There is an important edge case when a pixel has the same distance to\\n    multiple regions, as it is not defined which region expands into that\\n    space. Here, the exact behavior depends on the upstream implementation\\n    of ``scipy.ndimage.distance_transform_edt``.\\n\\n    See Also\\n    --------\\n    :func:`skimage.measure.label`, :func:`skimage.segmentation.watershed`, :func:`skimage.morphology.dilation`\\n\\n    References\\n    ----------\\n    .. [1] https://cellprofiler.org\\n    .. [2] https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559\\n\\n    Examples\\n    --------\\n    >>> labels = np.array([0, 1, 0, 0, 0, 0, 2])\\n    >>> expand_labels(labels, distance=1)\\n    array([1, 1, 1, 0, 0, 2, 2])\\n\\n    Labels will not overwrite each other:\\n\\n    >>> expand_labels(labels, distance=3)\\n    array([1, 1, 1, 1, 2, 2, 2])\\n\\n    In case of ties, behavior is undefined, but currently resolves to the\\n    label closest to ``(0,) * ndim`` in lexicographical order.\\n\\n    >>> labels_tied = np.array([0, 1, 0, 2, 0])\\n    >>> expand_labels(labels_tied, 1)\\n    array([1, 1, 1, 2, 2])\\n    >>> labels2d = np.array(\\n    ...     [[0, 1, 0, 0],\\n    ...      [2, 0, 0, 0],\\n    ...      [0, 3, 0, 0]]\\n    ... )\\n    >>> expand_labels(labels2d, 1)\\n    array([[2, 1, 1, 0],\\n           [2, 2, 0, 0],\\n           [2, 3, 3, 0]])\\n    '\n    (distances, nearest_label_coords) = distance_transform_edt(label_image == 0, return_indices=True)\n    labels_out = np.zeros_like(label_image)\n    dilate_mask = distances <= distance\n    masked_nearest_label_coords = [dimension_indices[dilate_mask] for dimension_indices in nearest_label_coords]\n    nearest_labels = label_image[tuple(masked_nearest_label_coords)]\n    labels_out[dilate_mask] = nearest_labels\n    return labels_out",
            "def expand_labels(label_image, distance=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Expand labels in label image by ``distance`` pixels without overlapping.\\n\\n    Given a label image, ``expand_labels`` grows label regions (connected components)\\n    outwards by up to ``distance`` pixels without overflowing into neighboring regions.\\n    More specifically, each background pixel that is within Euclidean distance\\n    of <= ``distance`` pixels of a connected component is assigned the label of that\\n    connected component.\\n    Where multiple connected components are within ``distance`` pixels of a background\\n    pixel, the label value of the closest connected component will be assigned (see\\n    Notes for the case of multiple labels at equal distance).\\n\\n    Parameters\\n    ----------\\n    label_image : ndarray of dtype int\\n        label image\\n    distance : float\\n        Euclidean distance in pixels by which to grow the labels. Default is one.\\n\\n    Returns\\n    -------\\n    enlarged_labels : ndarray of dtype int\\n        Labeled array, where all connected regions have been enlarged\\n\\n    Notes\\n    -----\\n    Where labels are spaced more than ``distance`` pixels are apart, this is\\n    equivalent to a morphological dilation with a disc or hyperball of radius ``distance``.\\n    However, in contrast to a morphological dilation, ``expand_labels`` will\\n    not expand a label region into a neighboring region.\\n\\n    This implementation of ``expand_labels`` is derived from CellProfiler [1]_, where\\n    it is known as module \"IdentifySecondaryObjects (Distance-N)\" [2]_.\\n\\n    There is an important edge case when a pixel has the same distance to\\n    multiple regions, as it is not defined which region expands into that\\n    space. Here, the exact behavior depends on the upstream implementation\\n    of ``scipy.ndimage.distance_transform_edt``.\\n\\n    See Also\\n    --------\\n    :func:`skimage.measure.label`, :func:`skimage.segmentation.watershed`, :func:`skimage.morphology.dilation`\\n\\n    References\\n    ----------\\n    .. [1] https://cellprofiler.org\\n    .. [2] https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559\\n\\n    Examples\\n    --------\\n    >>> labels = np.array([0, 1, 0, 0, 0, 0, 2])\\n    >>> expand_labels(labels, distance=1)\\n    array([1, 1, 1, 0, 0, 2, 2])\\n\\n    Labels will not overwrite each other:\\n\\n    >>> expand_labels(labels, distance=3)\\n    array([1, 1, 1, 1, 2, 2, 2])\\n\\n    In case of ties, behavior is undefined, but currently resolves to the\\n    label closest to ``(0,) * ndim`` in lexicographical order.\\n\\n    >>> labels_tied = np.array([0, 1, 0, 2, 0])\\n    >>> expand_labels(labels_tied, 1)\\n    array([1, 1, 1, 2, 2])\\n    >>> labels2d = np.array(\\n    ...     [[0, 1, 0, 0],\\n    ...      [2, 0, 0, 0],\\n    ...      [0, 3, 0, 0]]\\n    ... )\\n    >>> expand_labels(labels2d, 1)\\n    array([[2, 1, 1, 0],\\n           [2, 2, 0, 0],\\n           [2, 3, 3, 0]])\\n    '\n    (distances, nearest_label_coords) = distance_transform_edt(label_image == 0, return_indices=True)\n    labels_out = np.zeros_like(label_image)\n    dilate_mask = distances <= distance\n    masked_nearest_label_coords = [dimension_indices[dilate_mask] for dimension_indices in nearest_label_coords]\n    nearest_labels = label_image[tuple(masked_nearest_label_coords)]\n    labels_out[dilate_mask] = nearest_labels\n    return labels_out"
        ]
    }
]