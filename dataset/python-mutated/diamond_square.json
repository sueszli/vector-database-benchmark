[
    {
        "func_name": "_diamond_square_seed",
        "original": "def _diamond_square_seed(replicates: int, width: int, height: int, random_fn: Callable[..., Tensor], device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    \"\"\"Helper function to generate the diamond square image seee.\n\n    Args:\n        replicates: the num of batched replicas for the image.\n        width: the expected image width.\n        height: the expected image height.\n        random_fn: the random function to generate the image seed.\n        device: the torch device where to create the image seed.\n        dtype: the torch dtype where to create the image seed.\n\n    Return:\n        the generated image seed of size Bx1xHxW.\n    \"\"\"\n    KORNIA_CHECK(width == 3 or height == 3, 'Height or Width must be equal to 3.')\n    transpose: bool = False\n    if height == 3:\n        transpose = True\n        (width, height) = (height, width)\n    KORNIA_CHECK(height % 2 == 1 and height > 2, 'Height must be odd and height bigger than 2')\n    res: Tensor = random_fn([replicates, 1, width, height], device=device, dtype=dtype)\n    res[..., ::2, ::2] = random_fn([replicates, 1, 2, (height + 1) // 2], device=device, dtype=dtype)\n    res[..., 1, 1::2] = (res[..., ::2, :-2:2] + res[..., ::2, 2::2]).sum(dim=2) / 4.0\n    if width > 3:\n        res[..., 1, 2:-3:2] = (res[..., 0, 2:-3:2] + res[..., 2, 2:-3:2] + res[..., 1, 0:-4:2] + res[..., 1, 2:-3:2]) / 4.0\n    tmp1 = res[..., 2, 0]\n    res[..., 1, 0] = res[..., 0, 0] + res[..., 1, 1] + tmp1\n    res[..., 1, -1] = res[..., -1, -1] + res[..., 1, -2] + tmp1\n    tmp2 = res[..., 1, 1::2]\n    res[..., 0, 1::2] = res[..., 0, 0:-2:2] + res[..., 0, 2::2] + tmp2\n    res[..., 2, 1::2] = res[..., 2, 0:-2:2] + res[..., 2, 2::2] + tmp2\n    res = res / 3.0\n    if transpose:\n        res = res.transpose(2, 3)\n    return res",
        "mutated": [
            "def _diamond_square_seed(replicates: int, width: int, height: int, random_fn: Callable[..., Tensor], device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n    'Helper function to generate the diamond square image seee.\\n\\n    Args:\\n        replicates: the num of batched replicas for the image.\\n        width: the expected image width.\\n        height: the expected image height.\\n        random_fn: the random function to generate the image seed.\\n        device: the torch device where to create the image seed.\\n        dtype: the torch dtype where to create the image seed.\\n\\n    Return:\\n        the generated image seed of size Bx1xHxW.\\n    '\n    KORNIA_CHECK(width == 3 or height == 3, 'Height or Width must be equal to 3.')\n    transpose: bool = False\n    if height == 3:\n        transpose = True\n        (width, height) = (height, width)\n    KORNIA_CHECK(height % 2 == 1 and height > 2, 'Height must be odd and height bigger than 2')\n    res: Tensor = random_fn([replicates, 1, width, height], device=device, dtype=dtype)\n    res[..., ::2, ::2] = random_fn([replicates, 1, 2, (height + 1) // 2], device=device, dtype=dtype)\n    res[..., 1, 1::2] = (res[..., ::2, :-2:2] + res[..., ::2, 2::2]).sum(dim=2) / 4.0\n    if width > 3:\n        res[..., 1, 2:-3:2] = (res[..., 0, 2:-3:2] + res[..., 2, 2:-3:2] + res[..., 1, 0:-4:2] + res[..., 1, 2:-3:2]) / 4.0\n    tmp1 = res[..., 2, 0]\n    res[..., 1, 0] = res[..., 0, 0] + res[..., 1, 1] + tmp1\n    res[..., 1, -1] = res[..., -1, -1] + res[..., 1, -2] + tmp1\n    tmp2 = res[..., 1, 1::2]\n    res[..., 0, 1::2] = res[..., 0, 0:-2:2] + res[..., 0, 2::2] + tmp2\n    res[..., 2, 1::2] = res[..., 2, 0:-2:2] + res[..., 2, 2::2] + tmp2\n    res = res / 3.0\n    if transpose:\n        res = res.transpose(2, 3)\n    return res",
            "def _diamond_square_seed(replicates: int, width: int, height: int, random_fn: Callable[..., Tensor], device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Helper function to generate the diamond square image seee.\\n\\n    Args:\\n        replicates: the num of batched replicas for the image.\\n        width: the expected image width.\\n        height: the expected image height.\\n        random_fn: the random function to generate the image seed.\\n        device: the torch device where to create the image seed.\\n        dtype: the torch dtype where to create the image seed.\\n\\n    Return:\\n        the generated image seed of size Bx1xHxW.\\n    '\n    KORNIA_CHECK(width == 3 or height == 3, 'Height or Width must be equal to 3.')\n    transpose: bool = False\n    if height == 3:\n        transpose = True\n        (width, height) = (height, width)\n    KORNIA_CHECK(height % 2 == 1 and height > 2, 'Height must be odd and height bigger than 2')\n    res: Tensor = random_fn([replicates, 1, width, height], device=device, dtype=dtype)\n    res[..., ::2, ::2] = random_fn([replicates, 1, 2, (height + 1) // 2], device=device, dtype=dtype)\n    res[..., 1, 1::2] = (res[..., ::2, :-2:2] + res[..., ::2, 2::2]).sum(dim=2) / 4.0\n    if width > 3:\n        res[..., 1, 2:-3:2] = (res[..., 0, 2:-3:2] + res[..., 2, 2:-3:2] + res[..., 1, 0:-4:2] + res[..., 1, 2:-3:2]) / 4.0\n    tmp1 = res[..., 2, 0]\n    res[..., 1, 0] = res[..., 0, 0] + res[..., 1, 1] + tmp1\n    res[..., 1, -1] = res[..., -1, -1] + res[..., 1, -2] + tmp1\n    tmp2 = res[..., 1, 1::2]\n    res[..., 0, 1::2] = res[..., 0, 0:-2:2] + res[..., 0, 2::2] + tmp2\n    res[..., 2, 1::2] = res[..., 2, 0:-2:2] + res[..., 2, 2::2] + tmp2\n    res = res / 3.0\n    if transpose:\n        res = res.transpose(2, 3)\n    return res",
            "def _diamond_square_seed(replicates: int, width: int, height: int, random_fn: Callable[..., Tensor], device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Helper function to generate the diamond square image seee.\\n\\n    Args:\\n        replicates: the num of batched replicas for the image.\\n        width: the expected image width.\\n        height: the expected image height.\\n        random_fn: the random function to generate the image seed.\\n        device: the torch device where to create the image seed.\\n        dtype: the torch dtype where to create the image seed.\\n\\n    Return:\\n        the generated image seed of size Bx1xHxW.\\n    '\n    KORNIA_CHECK(width == 3 or height == 3, 'Height or Width must be equal to 3.')\n    transpose: bool = False\n    if height == 3:\n        transpose = True\n        (width, height) = (height, width)\n    KORNIA_CHECK(height % 2 == 1 and height > 2, 'Height must be odd and height bigger than 2')\n    res: Tensor = random_fn([replicates, 1, width, height], device=device, dtype=dtype)\n    res[..., ::2, ::2] = random_fn([replicates, 1, 2, (height + 1) // 2], device=device, dtype=dtype)\n    res[..., 1, 1::2] = (res[..., ::2, :-2:2] + res[..., ::2, 2::2]).sum(dim=2) / 4.0\n    if width > 3:\n        res[..., 1, 2:-3:2] = (res[..., 0, 2:-3:2] + res[..., 2, 2:-3:2] + res[..., 1, 0:-4:2] + res[..., 1, 2:-3:2]) / 4.0\n    tmp1 = res[..., 2, 0]\n    res[..., 1, 0] = res[..., 0, 0] + res[..., 1, 1] + tmp1\n    res[..., 1, -1] = res[..., -1, -1] + res[..., 1, -2] + tmp1\n    tmp2 = res[..., 1, 1::2]\n    res[..., 0, 1::2] = res[..., 0, 0:-2:2] + res[..., 0, 2::2] + tmp2\n    res[..., 2, 1::2] = res[..., 2, 0:-2:2] + res[..., 2, 2::2] + tmp2\n    res = res / 3.0\n    if transpose:\n        res = res.transpose(2, 3)\n    return res",
            "def _diamond_square_seed(replicates: int, width: int, height: int, random_fn: Callable[..., Tensor], device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Helper function to generate the diamond square image seee.\\n\\n    Args:\\n        replicates: the num of batched replicas for the image.\\n        width: the expected image width.\\n        height: the expected image height.\\n        random_fn: the random function to generate the image seed.\\n        device: the torch device where to create the image seed.\\n        dtype: the torch dtype where to create the image seed.\\n\\n    Return:\\n        the generated image seed of size Bx1xHxW.\\n    '\n    KORNIA_CHECK(width == 3 or height == 3, 'Height or Width must be equal to 3.')\n    transpose: bool = False\n    if height == 3:\n        transpose = True\n        (width, height) = (height, width)\n    KORNIA_CHECK(height % 2 == 1 and height > 2, 'Height must be odd and height bigger than 2')\n    res: Tensor = random_fn([replicates, 1, width, height], device=device, dtype=dtype)\n    res[..., ::2, ::2] = random_fn([replicates, 1, 2, (height + 1) // 2], device=device, dtype=dtype)\n    res[..., 1, 1::2] = (res[..., ::2, :-2:2] + res[..., ::2, 2::2]).sum(dim=2) / 4.0\n    if width > 3:\n        res[..., 1, 2:-3:2] = (res[..., 0, 2:-3:2] + res[..., 2, 2:-3:2] + res[..., 1, 0:-4:2] + res[..., 1, 2:-3:2]) / 4.0\n    tmp1 = res[..., 2, 0]\n    res[..., 1, 0] = res[..., 0, 0] + res[..., 1, 1] + tmp1\n    res[..., 1, -1] = res[..., -1, -1] + res[..., 1, -2] + tmp1\n    tmp2 = res[..., 1, 1::2]\n    res[..., 0, 1::2] = res[..., 0, 0:-2:2] + res[..., 0, 2::2] + tmp2\n    res[..., 2, 1::2] = res[..., 2, 0:-2:2] + res[..., 2, 2::2] + tmp2\n    res = res / 3.0\n    if transpose:\n        res = res.transpose(2, 3)\n    return res",
            "def _diamond_square_seed(replicates: int, width: int, height: int, random_fn: Callable[..., Tensor], device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Helper function to generate the diamond square image seee.\\n\\n    Args:\\n        replicates: the num of batched replicas for the image.\\n        width: the expected image width.\\n        height: the expected image height.\\n        random_fn: the random function to generate the image seed.\\n        device: the torch device where to create the image seed.\\n        dtype: the torch dtype where to create the image seed.\\n\\n    Return:\\n        the generated image seed of size Bx1xHxW.\\n    '\n    KORNIA_CHECK(width == 3 or height == 3, 'Height or Width must be equal to 3.')\n    transpose: bool = False\n    if height == 3:\n        transpose = True\n        (width, height) = (height, width)\n    KORNIA_CHECK(height % 2 == 1 and height > 2, 'Height must be odd and height bigger than 2')\n    res: Tensor = random_fn([replicates, 1, width, height], device=device, dtype=dtype)\n    res[..., ::2, ::2] = random_fn([replicates, 1, 2, (height + 1) // 2], device=device, dtype=dtype)\n    res[..., 1, 1::2] = (res[..., ::2, :-2:2] + res[..., ::2, 2::2]).sum(dim=2) / 4.0\n    if width > 3:\n        res[..., 1, 2:-3:2] = (res[..., 0, 2:-3:2] + res[..., 2, 2:-3:2] + res[..., 1, 0:-4:2] + res[..., 1, 2:-3:2]) / 4.0\n    tmp1 = res[..., 2, 0]\n    res[..., 1, 0] = res[..., 0, 0] + res[..., 1, 1] + tmp1\n    res[..., 1, -1] = res[..., -1, -1] + res[..., 1, -2] + tmp1\n    tmp2 = res[..., 1, 1::2]\n    res[..., 0, 1::2] = res[..., 0, 0:-2:2] + res[..., 0, 2::2] + tmp2\n    res[..., 2, 1::2] = res[..., 2, 0:-2:2] + res[..., 2, 2::2] + tmp2\n    res = res / 3.0\n    if transpose:\n        res = res.transpose(2, 3)\n    return res"
        ]
    },
    {
        "func_name": "_one_diamond_one_square",
        "original": "def _one_diamond_one_square(img: Tensor, random_scale: Union[float, Tensor], random_fn: Callable[..., Tensor]=torch.rand, diamond_kernel: Optional[Tensor]=None, square_kernel: Optional[Tensor]=None) -> Tensor:\n    \"\"\"Doubles the image resolution by applying a single diamond square steps.\n\n    Recursive application of this method creates plasma fractals.\n\n    Attention! The function is differentiable and gradients are computed as well.\n\n    If this function is run in the usual sense, it is more efficient if it is run in a no_grad()\n\n    Args:\n        img: a 4D tensor where dimensions are Batch, Channel, Width, Height. Width and Height must both be 2^N+1 and\n            Batch and Channels should in the usual case be 1.\n        random_scale: a float  number in [0,1] controlling the randomness created pixels get. I the usual case, it is\n            halved at every application of this function.\n        random_fn: the random function to generate the image seed.\n        diamond_kernel: the 3x3 kernel to perform the diamond step.\n        square_kernel: the 3x3 kernel to perform the square step.\n\n    Return:\n        A tensor on the same device as img with the same channels as img and width, height of 2^(N+1)+1.\n    \"\"\"\n    KORNIA_CHECK_SHAPE(img, ['B', 'C', 'H', 'W'])\n    if diamond_kernel is None:\n        diamond_kernel = Tensor([default_diamond_kernel]).to(img)\n    if square_kernel is None:\n        square_kernel = Tensor([default_square_kernel]).to(img)\n    (batch_sz, _, height, width) = img.shape\n    new_img: Tensor = torch.zeros([batch_sz, 1, 2 * (height - 1) + 1, 2 * (width - 1) + 1], device=img.device, dtype=img.dtype)\n    new_img[:, :, ::2, ::2] = img\n    factor: float = 1.0 / 0.75\n    pad_compencate = torch.ones_like(new_img)\n    pad_compencate[:, :, :, 0] = factor\n    pad_compencate[:, :, :, -1] = factor\n    pad_compencate[:, :, 0, :] = factor\n    pad_compencate[:, :, -1, :] = factor\n    random_img: Tensor = random_fn(new_img.size(), device=img.device, dtype=img.dtype) * random_scale\n    diamond_regions = filter2d(new_img, diamond_kernel)\n    diamond_centers = (diamond_regions > 0).to(img.dtype)\n    new_img = new_img + (1 - random_scale) * diamond_regions * diamond_centers + diamond_centers * random_img\n    square_regions = filter2d(new_img, square_kernel) * pad_compencate\n    square_centers = (square_regions > 0).to(img.dtype)\n    new_img = new_img + square_centers * random_img + (1 - random_scale) * square_centers * square_regions\n    return new_img",
        "mutated": [
            "def _one_diamond_one_square(img: Tensor, random_scale: Union[float, Tensor], random_fn: Callable[..., Tensor]=torch.rand, diamond_kernel: Optional[Tensor]=None, square_kernel: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n    'Doubles the image resolution by applying a single diamond square steps.\\n\\n    Recursive application of this method creates plasma fractals.\\n\\n    Attention! The function is differentiable and gradients are computed as well.\\n\\n    If this function is run in the usual sense, it is more efficient if it is run in a no_grad()\\n\\n    Args:\\n        img: a 4D tensor where dimensions are Batch, Channel, Width, Height. Width and Height must both be 2^N+1 and\\n            Batch and Channels should in the usual case be 1.\\n        random_scale: a float  number in [0,1] controlling the randomness created pixels get. I the usual case, it is\\n            halved at every application of this function.\\n        random_fn: the random function to generate the image seed.\\n        diamond_kernel: the 3x3 kernel to perform the diamond step.\\n        square_kernel: the 3x3 kernel to perform the square step.\\n\\n    Return:\\n        A tensor on the same device as img with the same channels as img and width, height of 2^(N+1)+1.\\n    '\n    KORNIA_CHECK_SHAPE(img, ['B', 'C', 'H', 'W'])\n    if diamond_kernel is None:\n        diamond_kernel = Tensor([default_diamond_kernel]).to(img)\n    if square_kernel is None:\n        square_kernel = Tensor([default_square_kernel]).to(img)\n    (batch_sz, _, height, width) = img.shape\n    new_img: Tensor = torch.zeros([batch_sz, 1, 2 * (height - 1) + 1, 2 * (width - 1) + 1], device=img.device, dtype=img.dtype)\n    new_img[:, :, ::2, ::2] = img\n    factor: float = 1.0 / 0.75\n    pad_compencate = torch.ones_like(new_img)\n    pad_compencate[:, :, :, 0] = factor\n    pad_compencate[:, :, :, -1] = factor\n    pad_compencate[:, :, 0, :] = factor\n    pad_compencate[:, :, -1, :] = factor\n    random_img: Tensor = random_fn(new_img.size(), device=img.device, dtype=img.dtype) * random_scale\n    diamond_regions = filter2d(new_img, diamond_kernel)\n    diamond_centers = (diamond_regions > 0).to(img.dtype)\n    new_img = new_img + (1 - random_scale) * diamond_regions * diamond_centers + diamond_centers * random_img\n    square_regions = filter2d(new_img, square_kernel) * pad_compencate\n    square_centers = (square_regions > 0).to(img.dtype)\n    new_img = new_img + square_centers * random_img + (1 - random_scale) * square_centers * square_regions\n    return new_img",
            "def _one_diamond_one_square(img: Tensor, random_scale: Union[float, Tensor], random_fn: Callable[..., Tensor]=torch.rand, diamond_kernel: Optional[Tensor]=None, square_kernel: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Doubles the image resolution by applying a single diamond square steps.\\n\\n    Recursive application of this method creates plasma fractals.\\n\\n    Attention! The function is differentiable and gradients are computed as well.\\n\\n    If this function is run in the usual sense, it is more efficient if it is run in a no_grad()\\n\\n    Args:\\n        img: a 4D tensor where dimensions are Batch, Channel, Width, Height. Width and Height must both be 2^N+1 and\\n            Batch and Channels should in the usual case be 1.\\n        random_scale: a float  number in [0,1] controlling the randomness created pixels get. I the usual case, it is\\n            halved at every application of this function.\\n        random_fn: the random function to generate the image seed.\\n        diamond_kernel: the 3x3 kernel to perform the diamond step.\\n        square_kernel: the 3x3 kernel to perform the square step.\\n\\n    Return:\\n        A tensor on the same device as img with the same channels as img and width, height of 2^(N+1)+1.\\n    '\n    KORNIA_CHECK_SHAPE(img, ['B', 'C', 'H', 'W'])\n    if diamond_kernel is None:\n        diamond_kernel = Tensor([default_diamond_kernel]).to(img)\n    if square_kernel is None:\n        square_kernel = Tensor([default_square_kernel]).to(img)\n    (batch_sz, _, height, width) = img.shape\n    new_img: Tensor = torch.zeros([batch_sz, 1, 2 * (height - 1) + 1, 2 * (width - 1) + 1], device=img.device, dtype=img.dtype)\n    new_img[:, :, ::2, ::2] = img\n    factor: float = 1.0 / 0.75\n    pad_compencate = torch.ones_like(new_img)\n    pad_compencate[:, :, :, 0] = factor\n    pad_compencate[:, :, :, -1] = factor\n    pad_compencate[:, :, 0, :] = factor\n    pad_compencate[:, :, -1, :] = factor\n    random_img: Tensor = random_fn(new_img.size(), device=img.device, dtype=img.dtype) * random_scale\n    diamond_regions = filter2d(new_img, diamond_kernel)\n    diamond_centers = (diamond_regions > 0).to(img.dtype)\n    new_img = new_img + (1 - random_scale) * diamond_regions * diamond_centers + diamond_centers * random_img\n    square_regions = filter2d(new_img, square_kernel) * pad_compencate\n    square_centers = (square_regions > 0).to(img.dtype)\n    new_img = new_img + square_centers * random_img + (1 - random_scale) * square_centers * square_regions\n    return new_img",
            "def _one_diamond_one_square(img: Tensor, random_scale: Union[float, Tensor], random_fn: Callable[..., Tensor]=torch.rand, diamond_kernel: Optional[Tensor]=None, square_kernel: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Doubles the image resolution by applying a single diamond square steps.\\n\\n    Recursive application of this method creates plasma fractals.\\n\\n    Attention! The function is differentiable and gradients are computed as well.\\n\\n    If this function is run in the usual sense, it is more efficient if it is run in a no_grad()\\n\\n    Args:\\n        img: a 4D tensor where dimensions are Batch, Channel, Width, Height. Width and Height must both be 2^N+1 and\\n            Batch and Channels should in the usual case be 1.\\n        random_scale: a float  number in [0,1] controlling the randomness created pixels get. I the usual case, it is\\n            halved at every application of this function.\\n        random_fn: the random function to generate the image seed.\\n        diamond_kernel: the 3x3 kernel to perform the diamond step.\\n        square_kernel: the 3x3 kernel to perform the square step.\\n\\n    Return:\\n        A tensor on the same device as img with the same channels as img and width, height of 2^(N+1)+1.\\n    '\n    KORNIA_CHECK_SHAPE(img, ['B', 'C', 'H', 'W'])\n    if diamond_kernel is None:\n        diamond_kernel = Tensor([default_diamond_kernel]).to(img)\n    if square_kernel is None:\n        square_kernel = Tensor([default_square_kernel]).to(img)\n    (batch_sz, _, height, width) = img.shape\n    new_img: Tensor = torch.zeros([batch_sz, 1, 2 * (height - 1) + 1, 2 * (width - 1) + 1], device=img.device, dtype=img.dtype)\n    new_img[:, :, ::2, ::2] = img\n    factor: float = 1.0 / 0.75\n    pad_compencate = torch.ones_like(new_img)\n    pad_compencate[:, :, :, 0] = factor\n    pad_compencate[:, :, :, -1] = factor\n    pad_compencate[:, :, 0, :] = factor\n    pad_compencate[:, :, -1, :] = factor\n    random_img: Tensor = random_fn(new_img.size(), device=img.device, dtype=img.dtype) * random_scale\n    diamond_regions = filter2d(new_img, diamond_kernel)\n    diamond_centers = (diamond_regions > 0).to(img.dtype)\n    new_img = new_img + (1 - random_scale) * diamond_regions * diamond_centers + diamond_centers * random_img\n    square_regions = filter2d(new_img, square_kernel) * pad_compencate\n    square_centers = (square_regions > 0).to(img.dtype)\n    new_img = new_img + square_centers * random_img + (1 - random_scale) * square_centers * square_regions\n    return new_img",
            "def _one_diamond_one_square(img: Tensor, random_scale: Union[float, Tensor], random_fn: Callable[..., Tensor]=torch.rand, diamond_kernel: Optional[Tensor]=None, square_kernel: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Doubles the image resolution by applying a single diamond square steps.\\n\\n    Recursive application of this method creates plasma fractals.\\n\\n    Attention! The function is differentiable and gradients are computed as well.\\n\\n    If this function is run in the usual sense, it is more efficient if it is run in a no_grad()\\n\\n    Args:\\n        img: a 4D tensor where dimensions are Batch, Channel, Width, Height. Width and Height must both be 2^N+1 and\\n            Batch and Channels should in the usual case be 1.\\n        random_scale: a float  number in [0,1] controlling the randomness created pixels get. I the usual case, it is\\n            halved at every application of this function.\\n        random_fn: the random function to generate the image seed.\\n        diamond_kernel: the 3x3 kernel to perform the diamond step.\\n        square_kernel: the 3x3 kernel to perform the square step.\\n\\n    Return:\\n        A tensor on the same device as img with the same channels as img and width, height of 2^(N+1)+1.\\n    '\n    KORNIA_CHECK_SHAPE(img, ['B', 'C', 'H', 'W'])\n    if diamond_kernel is None:\n        diamond_kernel = Tensor([default_diamond_kernel]).to(img)\n    if square_kernel is None:\n        square_kernel = Tensor([default_square_kernel]).to(img)\n    (batch_sz, _, height, width) = img.shape\n    new_img: Tensor = torch.zeros([batch_sz, 1, 2 * (height - 1) + 1, 2 * (width - 1) + 1], device=img.device, dtype=img.dtype)\n    new_img[:, :, ::2, ::2] = img\n    factor: float = 1.0 / 0.75\n    pad_compencate = torch.ones_like(new_img)\n    pad_compencate[:, :, :, 0] = factor\n    pad_compencate[:, :, :, -1] = factor\n    pad_compencate[:, :, 0, :] = factor\n    pad_compencate[:, :, -1, :] = factor\n    random_img: Tensor = random_fn(new_img.size(), device=img.device, dtype=img.dtype) * random_scale\n    diamond_regions = filter2d(new_img, diamond_kernel)\n    diamond_centers = (diamond_regions > 0).to(img.dtype)\n    new_img = new_img + (1 - random_scale) * diamond_regions * diamond_centers + diamond_centers * random_img\n    square_regions = filter2d(new_img, square_kernel) * pad_compencate\n    square_centers = (square_regions > 0).to(img.dtype)\n    new_img = new_img + square_centers * random_img + (1 - random_scale) * square_centers * square_regions\n    return new_img",
            "def _one_diamond_one_square(img: Tensor, random_scale: Union[float, Tensor], random_fn: Callable[..., Tensor]=torch.rand, diamond_kernel: Optional[Tensor]=None, square_kernel: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Doubles the image resolution by applying a single diamond square steps.\\n\\n    Recursive application of this method creates plasma fractals.\\n\\n    Attention! The function is differentiable and gradients are computed as well.\\n\\n    If this function is run in the usual sense, it is more efficient if it is run in a no_grad()\\n\\n    Args:\\n        img: a 4D tensor where dimensions are Batch, Channel, Width, Height. Width and Height must both be 2^N+1 and\\n            Batch and Channels should in the usual case be 1.\\n        random_scale: a float  number in [0,1] controlling the randomness created pixels get. I the usual case, it is\\n            halved at every application of this function.\\n        random_fn: the random function to generate the image seed.\\n        diamond_kernel: the 3x3 kernel to perform the diamond step.\\n        square_kernel: the 3x3 kernel to perform the square step.\\n\\n    Return:\\n        A tensor on the same device as img with the same channels as img and width, height of 2^(N+1)+1.\\n    '\n    KORNIA_CHECK_SHAPE(img, ['B', 'C', 'H', 'W'])\n    if diamond_kernel is None:\n        diamond_kernel = Tensor([default_diamond_kernel]).to(img)\n    if square_kernel is None:\n        square_kernel = Tensor([default_square_kernel]).to(img)\n    (batch_sz, _, height, width) = img.shape\n    new_img: Tensor = torch.zeros([batch_sz, 1, 2 * (height - 1) + 1, 2 * (width - 1) + 1], device=img.device, dtype=img.dtype)\n    new_img[:, :, ::2, ::2] = img\n    factor: float = 1.0 / 0.75\n    pad_compencate = torch.ones_like(new_img)\n    pad_compencate[:, :, :, 0] = factor\n    pad_compencate[:, :, :, -1] = factor\n    pad_compencate[:, :, 0, :] = factor\n    pad_compencate[:, :, -1, :] = factor\n    random_img: Tensor = random_fn(new_img.size(), device=img.device, dtype=img.dtype) * random_scale\n    diamond_regions = filter2d(new_img, diamond_kernel)\n    diamond_centers = (diamond_regions > 0).to(img.dtype)\n    new_img = new_img + (1 - random_scale) * diamond_regions * diamond_centers + diamond_centers * random_img\n    square_regions = filter2d(new_img, square_kernel) * pad_compencate\n    square_centers = (square_regions > 0).to(img.dtype)\n    new_img = new_img + square_centers * random_img + (1 - random_scale) * square_centers * square_regions\n    return new_img"
        ]
    },
    {
        "func_name": "diamond_square",
        "original": "def diamond_square(output_size: Tuple[int, int, int, int], roughness: Union[float, Tensor]=0.5, random_scale: Union[float, Tensor]=1.0, random_fn: Callable[..., Tensor]=torch.rand, normalize_range: Optional[Tuple[float, float]]=None, device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    \"\"\"Generates Plasma Fractal Images using the diamond square algorithm.\n\n    See: https://en.wikipedia.org/wiki/Diamond-square_algorithm\n\n    Args:\n        output_size: a tuple of integers with the BxCxHxW of the image to be generated.\n        roughness: the scale value to apply at each recursion step.\n        random_scale: the initial value of the scale for recursion.\n        random_fn: the callable function to use to sample a random tensor.\n        normalize_range: whether to normalize using min-max the output map. In case of a\n            range is specified, min-max norm is applied between the provided range.\n        device: the torch device to place the output map.\n        dtype: the torch dtype to place the output map.\n\n    Returns:\n        A tensor with shape :math:`(B,C,H,W)` containing the fractal image.\n    \"\"\"\n    KORNIA_CHECK(len(output_size) == 4, 'output_size must be (B,C,H,W)')\n    if not isinstance(random_scale, Tensor):\n        random_scale = Tensor([[[[random_scale]]]]).to(device, dtype)\n        random_scale = random_scale.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        KORNIA_CHECK_IS_TENSOR(random_scale)\n        random_scale = random_scale.view(-1, 1, 1, 1)\n        random_scale = random_scale.expand([output_size[0], output_size[1], 1, 1])\n        random_scale = random_scale.reshape([-1, 1, 1, 1])\n    if not isinstance(roughness, Tensor):\n        roughness = Tensor([[[[roughness]]]]).to(device, dtype)\n        roughness = roughness.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        roughness = roughness.view(-1, 1, 1, 1)\n        roughness = roughness.expand([output_size[0], output_size[1], 1, 1])\n        roughness = roughness.reshape([-1, 1, 1, 1])\n    (width, height) = output_size[-2:]\n    num_samples: int = 1\n    for x in output_size[:-2]:\n        num_samples *= x\n    p2_width: float = 2 ** math.ceil(math.log2(width - 1)) + 1\n    p2_height: float = 2 ** math.ceil(math.log2(height - 1)) + 1\n    recursion_depth: int = int(min(math.log2(p2_width - 1) - 1, math.log2(p2_height - 1) - 1))\n    seed_width: int = (p2_width - 1) // 2 ** recursion_depth + 1\n    seed_height: int = (p2_height - 1) // 2 ** recursion_depth + 1\n    img: Tensor = random_scale * _diamond_square_seed(num_samples, seed_width, seed_height, random_fn, device, dtype)\n    scale = random_scale\n    for _ in range(recursion_depth):\n        scale = scale * roughness\n        img = _one_diamond_one_square(img, scale, random_fn)\n    img = img[..., :width, :height]\n    img = img.view(output_size)\n    if normalize_range is not None:\n        (min_val, max_val) = normalize_range\n        img = normalize_min_max(img.contiguous(), min_val, max_val)\n    return img",
        "mutated": [
            "def diamond_square(output_size: Tuple[int, int, int, int], roughness: Union[float, Tensor]=0.5, random_scale: Union[float, Tensor]=1.0, random_fn: Callable[..., Tensor]=torch.rand, normalize_range: Optional[Tuple[float, float]]=None, device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n    'Generates Plasma Fractal Images using the diamond square algorithm.\\n\\n    See: https://en.wikipedia.org/wiki/Diamond-square_algorithm\\n\\n    Args:\\n        output_size: a tuple of integers with the BxCxHxW of the image to be generated.\\n        roughness: the scale value to apply at each recursion step.\\n        random_scale: the initial value of the scale for recursion.\\n        random_fn: the callable function to use to sample a random tensor.\\n        normalize_range: whether to normalize using min-max the output map. In case of a\\n            range is specified, min-max norm is applied between the provided range.\\n        device: the torch device to place the output map.\\n        dtype: the torch dtype to place the output map.\\n\\n    Returns:\\n        A tensor with shape :math:`(B,C,H,W)` containing the fractal image.\\n    '\n    KORNIA_CHECK(len(output_size) == 4, 'output_size must be (B,C,H,W)')\n    if not isinstance(random_scale, Tensor):\n        random_scale = Tensor([[[[random_scale]]]]).to(device, dtype)\n        random_scale = random_scale.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        KORNIA_CHECK_IS_TENSOR(random_scale)\n        random_scale = random_scale.view(-1, 1, 1, 1)\n        random_scale = random_scale.expand([output_size[0], output_size[1], 1, 1])\n        random_scale = random_scale.reshape([-1, 1, 1, 1])\n    if not isinstance(roughness, Tensor):\n        roughness = Tensor([[[[roughness]]]]).to(device, dtype)\n        roughness = roughness.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        roughness = roughness.view(-1, 1, 1, 1)\n        roughness = roughness.expand([output_size[0], output_size[1], 1, 1])\n        roughness = roughness.reshape([-1, 1, 1, 1])\n    (width, height) = output_size[-2:]\n    num_samples: int = 1\n    for x in output_size[:-2]:\n        num_samples *= x\n    p2_width: float = 2 ** math.ceil(math.log2(width - 1)) + 1\n    p2_height: float = 2 ** math.ceil(math.log2(height - 1)) + 1\n    recursion_depth: int = int(min(math.log2(p2_width - 1) - 1, math.log2(p2_height - 1) - 1))\n    seed_width: int = (p2_width - 1) // 2 ** recursion_depth + 1\n    seed_height: int = (p2_height - 1) // 2 ** recursion_depth + 1\n    img: Tensor = random_scale * _diamond_square_seed(num_samples, seed_width, seed_height, random_fn, device, dtype)\n    scale = random_scale\n    for _ in range(recursion_depth):\n        scale = scale * roughness\n        img = _one_diamond_one_square(img, scale, random_fn)\n    img = img[..., :width, :height]\n    img = img.view(output_size)\n    if normalize_range is not None:\n        (min_val, max_val) = normalize_range\n        img = normalize_min_max(img.contiguous(), min_val, max_val)\n    return img",
            "def diamond_square(output_size: Tuple[int, int, int, int], roughness: Union[float, Tensor]=0.5, random_scale: Union[float, Tensor]=1.0, random_fn: Callable[..., Tensor]=torch.rand, normalize_range: Optional[Tuple[float, float]]=None, device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates Plasma Fractal Images using the diamond square algorithm.\\n\\n    See: https://en.wikipedia.org/wiki/Diamond-square_algorithm\\n\\n    Args:\\n        output_size: a tuple of integers with the BxCxHxW of the image to be generated.\\n        roughness: the scale value to apply at each recursion step.\\n        random_scale: the initial value of the scale for recursion.\\n        random_fn: the callable function to use to sample a random tensor.\\n        normalize_range: whether to normalize using min-max the output map. In case of a\\n            range is specified, min-max norm is applied between the provided range.\\n        device: the torch device to place the output map.\\n        dtype: the torch dtype to place the output map.\\n\\n    Returns:\\n        A tensor with shape :math:`(B,C,H,W)` containing the fractal image.\\n    '\n    KORNIA_CHECK(len(output_size) == 4, 'output_size must be (B,C,H,W)')\n    if not isinstance(random_scale, Tensor):\n        random_scale = Tensor([[[[random_scale]]]]).to(device, dtype)\n        random_scale = random_scale.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        KORNIA_CHECK_IS_TENSOR(random_scale)\n        random_scale = random_scale.view(-1, 1, 1, 1)\n        random_scale = random_scale.expand([output_size[0], output_size[1], 1, 1])\n        random_scale = random_scale.reshape([-1, 1, 1, 1])\n    if not isinstance(roughness, Tensor):\n        roughness = Tensor([[[[roughness]]]]).to(device, dtype)\n        roughness = roughness.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        roughness = roughness.view(-1, 1, 1, 1)\n        roughness = roughness.expand([output_size[0], output_size[1], 1, 1])\n        roughness = roughness.reshape([-1, 1, 1, 1])\n    (width, height) = output_size[-2:]\n    num_samples: int = 1\n    for x in output_size[:-2]:\n        num_samples *= x\n    p2_width: float = 2 ** math.ceil(math.log2(width - 1)) + 1\n    p2_height: float = 2 ** math.ceil(math.log2(height - 1)) + 1\n    recursion_depth: int = int(min(math.log2(p2_width - 1) - 1, math.log2(p2_height - 1) - 1))\n    seed_width: int = (p2_width - 1) // 2 ** recursion_depth + 1\n    seed_height: int = (p2_height - 1) // 2 ** recursion_depth + 1\n    img: Tensor = random_scale * _diamond_square_seed(num_samples, seed_width, seed_height, random_fn, device, dtype)\n    scale = random_scale\n    for _ in range(recursion_depth):\n        scale = scale * roughness\n        img = _one_diamond_one_square(img, scale, random_fn)\n    img = img[..., :width, :height]\n    img = img.view(output_size)\n    if normalize_range is not None:\n        (min_val, max_val) = normalize_range\n        img = normalize_min_max(img.contiguous(), min_val, max_val)\n    return img",
            "def diamond_square(output_size: Tuple[int, int, int, int], roughness: Union[float, Tensor]=0.5, random_scale: Union[float, Tensor]=1.0, random_fn: Callable[..., Tensor]=torch.rand, normalize_range: Optional[Tuple[float, float]]=None, device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates Plasma Fractal Images using the diamond square algorithm.\\n\\n    See: https://en.wikipedia.org/wiki/Diamond-square_algorithm\\n\\n    Args:\\n        output_size: a tuple of integers with the BxCxHxW of the image to be generated.\\n        roughness: the scale value to apply at each recursion step.\\n        random_scale: the initial value of the scale for recursion.\\n        random_fn: the callable function to use to sample a random tensor.\\n        normalize_range: whether to normalize using min-max the output map. In case of a\\n            range is specified, min-max norm is applied between the provided range.\\n        device: the torch device to place the output map.\\n        dtype: the torch dtype to place the output map.\\n\\n    Returns:\\n        A tensor with shape :math:`(B,C,H,W)` containing the fractal image.\\n    '\n    KORNIA_CHECK(len(output_size) == 4, 'output_size must be (B,C,H,W)')\n    if not isinstance(random_scale, Tensor):\n        random_scale = Tensor([[[[random_scale]]]]).to(device, dtype)\n        random_scale = random_scale.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        KORNIA_CHECK_IS_TENSOR(random_scale)\n        random_scale = random_scale.view(-1, 1, 1, 1)\n        random_scale = random_scale.expand([output_size[0], output_size[1], 1, 1])\n        random_scale = random_scale.reshape([-1, 1, 1, 1])\n    if not isinstance(roughness, Tensor):\n        roughness = Tensor([[[[roughness]]]]).to(device, dtype)\n        roughness = roughness.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        roughness = roughness.view(-1, 1, 1, 1)\n        roughness = roughness.expand([output_size[0], output_size[1], 1, 1])\n        roughness = roughness.reshape([-1, 1, 1, 1])\n    (width, height) = output_size[-2:]\n    num_samples: int = 1\n    for x in output_size[:-2]:\n        num_samples *= x\n    p2_width: float = 2 ** math.ceil(math.log2(width - 1)) + 1\n    p2_height: float = 2 ** math.ceil(math.log2(height - 1)) + 1\n    recursion_depth: int = int(min(math.log2(p2_width - 1) - 1, math.log2(p2_height - 1) - 1))\n    seed_width: int = (p2_width - 1) // 2 ** recursion_depth + 1\n    seed_height: int = (p2_height - 1) // 2 ** recursion_depth + 1\n    img: Tensor = random_scale * _diamond_square_seed(num_samples, seed_width, seed_height, random_fn, device, dtype)\n    scale = random_scale\n    for _ in range(recursion_depth):\n        scale = scale * roughness\n        img = _one_diamond_one_square(img, scale, random_fn)\n    img = img[..., :width, :height]\n    img = img.view(output_size)\n    if normalize_range is not None:\n        (min_val, max_val) = normalize_range\n        img = normalize_min_max(img.contiguous(), min_val, max_val)\n    return img",
            "def diamond_square(output_size: Tuple[int, int, int, int], roughness: Union[float, Tensor]=0.5, random_scale: Union[float, Tensor]=1.0, random_fn: Callable[..., Tensor]=torch.rand, normalize_range: Optional[Tuple[float, float]]=None, device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates Plasma Fractal Images using the diamond square algorithm.\\n\\n    See: https://en.wikipedia.org/wiki/Diamond-square_algorithm\\n\\n    Args:\\n        output_size: a tuple of integers with the BxCxHxW of the image to be generated.\\n        roughness: the scale value to apply at each recursion step.\\n        random_scale: the initial value of the scale for recursion.\\n        random_fn: the callable function to use to sample a random tensor.\\n        normalize_range: whether to normalize using min-max the output map. In case of a\\n            range is specified, min-max norm is applied between the provided range.\\n        device: the torch device to place the output map.\\n        dtype: the torch dtype to place the output map.\\n\\n    Returns:\\n        A tensor with shape :math:`(B,C,H,W)` containing the fractal image.\\n    '\n    KORNIA_CHECK(len(output_size) == 4, 'output_size must be (B,C,H,W)')\n    if not isinstance(random_scale, Tensor):\n        random_scale = Tensor([[[[random_scale]]]]).to(device, dtype)\n        random_scale = random_scale.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        KORNIA_CHECK_IS_TENSOR(random_scale)\n        random_scale = random_scale.view(-1, 1, 1, 1)\n        random_scale = random_scale.expand([output_size[0], output_size[1], 1, 1])\n        random_scale = random_scale.reshape([-1, 1, 1, 1])\n    if not isinstance(roughness, Tensor):\n        roughness = Tensor([[[[roughness]]]]).to(device, dtype)\n        roughness = roughness.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        roughness = roughness.view(-1, 1, 1, 1)\n        roughness = roughness.expand([output_size[0], output_size[1], 1, 1])\n        roughness = roughness.reshape([-1, 1, 1, 1])\n    (width, height) = output_size[-2:]\n    num_samples: int = 1\n    for x in output_size[:-2]:\n        num_samples *= x\n    p2_width: float = 2 ** math.ceil(math.log2(width - 1)) + 1\n    p2_height: float = 2 ** math.ceil(math.log2(height - 1)) + 1\n    recursion_depth: int = int(min(math.log2(p2_width - 1) - 1, math.log2(p2_height - 1) - 1))\n    seed_width: int = (p2_width - 1) // 2 ** recursion_depth + 1\n    seed_height: int = (p2_height - 1) // 2 ** recursion_depth + 1\n    img: Tensor = random_scale * _diamond_square_seed(num_samples, seed_width, seed_height, random_fn, device, dtype)\n    scale = random_scale\n    for _ in range(recursion_depth):\n        scale = scale * roughness\n        img = _one_diamond_one_square(img, scale, random_fn)\n    img = img[..., :width, :height]\n    img = img.view(output_size)\n    if normalize_range is not None:\n        (min_val, max_val) = normalize_range\n        img = normalize_min_max(img.contiguous(), min_val, max_val)\n    return img",
            "def diamond_square(output_size: Tuple[int, int, int, int], roughness: Union[float, Tensor]=0.5, random_scale: Union[float, Tensor]=1.0, random_fn: Callable[..., Tensor]=torch.rand, normalize_range: Optional[Tuple[float, float]]=None, device: Optional[torch.device]=None, dtype: Optional[torch.dtype]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates Plasma Fractal Images using the diamond square algorithm.\\n\\n    See: https://en.wikipedia.org/wiki/Diamond-square_algorithm\\n\\n    Args:\\n        output_size: a tuple of integers with the BxCxHxW of the image to be generated.\\n        roughness: the scale value to apply at each recursion step.\\n        random_scale: the initial value of the scale for recursion.\\n        random_fn: the callable function to use to sample a random tensor.\\n        normalize_range: whether to normalize using min-max the output map. In case of a\\n            range is specified, min-max norm is applied between the provided range.\\n        device: the torch device to place the output map.\\n        dtype: the torch dtype to place the output map.\\n\\n    Returns:\\n        A tensor with shape :math:`(B,C,H,W)` containing the fractal image.\\n    '\n    KORNIA_CHECK(len(output_size) == 4, 'output_size must be (B,C,H,W)')\n    if not isinstance(random_scale, Tensor):\n        random_scale = Tensor([[[[random_scale]]]]).to(device, dtype)\n        random_scale = random_scale.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        KORNIA_CHECK_IS_TENSOR(random_scale)\n        random_scale = random_scale.view(-1, 1, 1, 1)\n        random_scale = random_scale.expand([output_size[0], output_size[1], 1, 1])\n        random_scale = random_scale.reshape([-1, 1, 1, 1])\n    if not isinstance(roughness, Tensor):\n        roughness = Tensor([[[[roughness]]]]).to(device, dtype)\n        roughness = roughness.expand([output_size[0] * output_size[1], 1, 1, 1])\n    else:\n        roughness = roughness.view(-1, 1, 1, 1)\n        roughness = roughness.expand([output_size[0], output_size[1], 1, 1])\n        roughness = roughness.reshape([-1, 1, 1, 1])\n    (width, height) = output_size[-2:]\n    num_samples: int = 1\n    for x in output_size[:-2]:\n        num_samples *= x\n    p2_width: float = 2 ** math.ceil(math.log2(width - 1)) + 1\n    p2_height: float = 2 ** math.ceil(math.log2(height - 1)) + 1\n    recursion_depth: int = int(min(math.log2(p2_width - 1) - 1, math.log2(p2_height - 1) - 1))\n    seed_width: int = (p2_width - 1) // 2 ** recursion_depth + 1\n    seed_height: int = (p2_height - 1) // 2 ** recursion_depth + 1\n    img: Tensor = random_scale * _diamond_square_seed(num_samples, seed_width, seed_height, random_fn, device, dtype)\n    scale = random_scale\n    for _ in range(recursion_depth):\n        scale = scale * roughness\n        img = _one_diamond_one_square(img, scale, random_fn)\n    img = img[..., :width, :height]\n    img = img.view(output_size)\n    if normalize_range is not None:\n        (min_val, max_val) = normalize_range\n        img = normalize_min_max(img.contiguous(), min_val, max_val)\n    return img"
        ]
    }
]