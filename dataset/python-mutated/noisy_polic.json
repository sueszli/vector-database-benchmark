[
    {
        "func_name": "__init__",
        "original": "def __init__(self, policy, player_id=None, alpha=0.1, beta=1.0):\n    \"\"\"Initializes the noisy policy.\n\n    Note that this noise only affects `player_id`.\n\n    Args:\n      policy: Any OpenSpiel `policy.Policy` object.\n      player_id: The player id, the policy of whom will be made noisy. If `None`\n        noise will be added to the policies for all players.\n      alpha: Mixing noise factor.\n      beta: Softmax inverse temperature factor.\n    \"\"\"\n    self._policy = policy\n    self.game = policy.game\n    self.game_type = self.game.get_type()\n    self.player_id = player_id\n    self._noise_dict = {}\n    self._alpha = alpha\n    self._beta = beta",
        "mutated": [
            "def __init__(self, policy, player_id=None, alpha=0.1, beta=1.0):\n    if False:\n        i = 10\n    'Initializes the noisy policy.\\n\\n    Note that this noise only affects `player_id`.\\n\\n    Args:\\n      policy: Any OpenSpiel `policy.Policy` object.\\n      player_id: The player id, the policy of whom will be made noisy. If `None`\\n        noise will be added to the policies for all players.\\n      alpha: Mixing noise factor.\\n      beta: Softmax inverse temperature factor.\\n    '\n    self._policy = policy\n    self.game = policy.game\n    self.game_type = self.game.get_type()\n    self.player_id = player_id\n    self._noise_dict = {}\n    self._alpha = alpha\n    self._beta = beta",
            "def __init__(self, policy, player_id=None, alpha=0.1, beta=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initializes the noisy policy.\\n\\n    Note that this noise only affects `player_id`.\\n\\n    Args:\\n      policy: Any OpenSpiel `policy.Policy` object.\\n      player_id: The player id, the policy of whom will be made noisy. If `None`\\n        noise will be added to the policies for all players.\\n      alpha: Mixing noise factor.\\n      beta: Softmax inverse temperature factor.\\n    '\n    self._policy = policy\n    self.game = policy.game\n    self.game_type = self.game.get_type()\n    self.player_id = player_id\n    self._noise_dict = {}\n    self._alpha = alpha\n    self._beta = beta",
            "def __init__(self, policy, player_id=None, alpha=0.1, beta=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initializes the noisy policy.\\n\\n    Note that this noise only affects `player_id`.\\n\\n    Args:\\n      policy: Any OpenSpiel `policy.Policy` object.\\n      player_id: The player id, the policy of whom will be made noisy. If `None`\\n        noise will be added to the policies for all players.\\n      alpha: Mixing noise factor.\\n      beta: Softmax inverse temperature factor.\\n    '\n    self._policy = policy\n    self.game = policy.game\n    self.game_type = self.game.get_type()\n    self.player_id = player_id\n    self._noise_dict = {}\n    self._alpha = alpha\n    self._beta = beta",
            "def __init__(self, policy, player_id=None, alpha=0.1, beta=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initializes the noisy policy.\\n\\n    Note that this noise only affects `player_id`.\\n\\n    Args:\\n      policy: Any OpenSpiel `policy.Policy` object.\\n      player_id: The player id, the policy of whom will be made noisy. If `None`\\n        noise will be added to the policies for all players.\\n      alpha: Mixing noise factor.\\n      beta: Softmax inverse temperature factor.\\n    '\n    self._policy = policy\n    self.game = policy.game\n    self.game_type = self.game.get_type()\n    self.player_id = player_id\n    self._noise_dict = {}\n    self._alpha = alpha\n    self._beta = beta",
            "def __init__(self, policy, player_id=None, alpha=0.1, beta=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initializes the noisy policy.\\n\\n    Note that this noise only affects `player_id`.\\n\\n    Args:\\n      policy: Any OpenSpiel `policy.Policy` object.\\n      player_id: The player id, the policy of whom will be made noisy. If `None`\\n        noise will be added to the policies for all players.\\n      alpha: Mixing noise factor.\\n      beta: Softmax inverse temperature factor.\\n    '\n    self._policy = policy\n    self.game = policy.game\n    self.game_type = self.game.get_type()\n    self.player_id = player_id\n    self._noise_dict = {}\n    self._alpha = alpha\n    self._beta = beta"
        ]
    },
    {
        "func_name": "_state_key",
        "original": "def _state_key(self, state, player):\n    \"\"\"Returns the key to use to look up this (state, player) pair.\"\"\"\n    if self.game_type.provides_information_state_string:\n        if player is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player)\n    elif self.game_type.provides_observation_string:\n        if player is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player)\n    else:\n        return str(state)",
        "mutated": [
            "def _state_key(self, state, player):\n    if False:\n        i = 10\n    'Returns the key to use to look up this (state, player) pair.'\n    if self.game_type.provides_information_state_string:\n        if player is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player)\n    elif self.game_type.provides_observation_string:\n        if player is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player)\n    else:\n        return str(state)",
            "def _state_key(self, state, player):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the key to use to look up this (state, player) pair.'\n    if self.game_type.provides_information_state_string:\n        if player is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player)\n    elif self.game_type.provides_observation_string:\n        if player is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player)\n    else:\n        return str(state)",
            "def _state_key(self, state, player):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the key to use to look up this (state, player) pair.'\n    if self.game_type.provides_information_state_string:\n        if player is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player)\n    elif self.game_type.provides_observation_string:\n        if player is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player)\n    else:\n        return str(state)",
            "def _state_key(self, state, player):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the key to use to look up this (state, player) pair.'\n    if self.game_type.provides_information_state_string:\n        if player is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player)\n    elif self.game_type.provides_observation_string:\n        if player is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player)\n    else:\n        return str(state)",
            "def _state_key(self, state, player):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the key to use to look up this (state, player) pair.'\n    if self.game_type.provides_information_state_string:\n        if player is None:\n            return state.information_state_string()\n        else:\n            return state.information_state_string(player)\n    elif self.game_type.provides_observation_string:\n        if player is None:\n            return state.observation_string()\n        else:\n            return state.observation_string(player)\n    else:\n        return str(state)"
        ]
    },
    {
        "func_name": "get_or_create_noise",
        "original": "def get_or_create_noise(self, state, player_id=None):\n    \"\"\"Get noisy policy or create it and return it.\n\n    Args:\n      state: the state to which the policy will be applied.\n      player_id: the player id that will apply the noisy policy. Default to\n        current_player. Should be defined in the case of simultaneous games.\n\n    Returns:\n      noise_action_probs: The noisy probability distribution on the set of legal\n        actions.\n    \"\"\"\n    if player_id is None:\n        player_id = state.current_player()\n    info_state = self._state_key(state, player_id)\n    if info_state not in self._noise_dict:\n        action_ids = state.legal_actions(player_id)\n        noise = self._beta * np.random.normal(size=len(action_ids))\n        noise = np.exp(noise - noise.max())\n        noise /= np.sum(noise)\n        self._noise_dict[info_state] = {action_ids[i]: noise[i] for i in range(len(noise))}\n    return self._noise_dict[info_state]",
        "mutated": [
            "def get_or_create_noise(self, state, player_id=None):\n    if False:\n        i = 10\n    'Get noisy policy or create it and return it.\\n\\n    Args:\\n      state: the state to which the policy will be applied.\\n      player_id: the player id that will apply the noisy policy. Default to\\n        current_player. Should be defined in the case of simultaneous games.\\n\\n    Returns:\\n      noise_action_probs: The noisy probability distribution on the set of legal\\n        actions.\\n    '\n    if player_id is None:\n        player_id = state.current_player()\n    info_state = self._state_key(state, player_id)\n    if info_state not in self._noise_dict:\n        action_ids = state.legal_actions(player_id)\n        noise = self._beta * np.random.normal(size=len(action_ids))\n        noise = np.exp(noise - noise.max())\n        noise /= np.sum(noise)\n        self._noise_dict[info_state] = {action_ids[i]: noise[i] for i in range(len(noise))}\n    return self._noise_dict[info_state]",
            "def get_or_create_noise(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get noisy policy or create it and return it.\\n\\n    Args:\\n      state: the state to which the policy will be applied.\\n      player_id: the player id that will apply the noisy policy. Default to\\n        current_player. Should be defined in the case of simultaneous games.\\n\\n    Returns:\\n      noise_action_probs: The noisy probability distribution on the set of legal\\n        actions.\\n    '\n    if player_id is None:\n        player_id = state.current_player()\n    info_state = self._state_key(state, player_id)\n    if info_state not in self._noise_dict:\n        action_ids = state.legal_actions(player_id)\n        noise = self._beta * np.random.normal(size=len(action_ids))\n        noise = np.exp(noise - noise.max())\n        noise /= np.sum(noise)\n        self._noise_dict[info_state] = {action_ids[i]: noise[i] for i in range(len(noise))}\n    return self._noise_dict[info_state]",
            "def get_or_create_noise(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get noisy policy or create it and return it.\\n\\n    Args:\\n      state: the state to which the policy will be applied.\\n      player_id: the player id that will apply the noisy policy. Default to\\n        current_player. Should be defined in the case of simultaneous games.\\n\\n    Returns:\\n      noise_action_probs: The noisy probability distribution on the set of legal\\n        actions.\\n    '\n    if player_id is None:\n        player_id = state.current_player()\n    info_state = self._state_key(state, player_id)\n    if info_state not in self._noise_dict:\n        action_ids = state.legal_actions(player_id)\n        noise = self._beta * np.random.normal(size=len(action_ids))\n        noise = np.exp(noise - noise.max())\n        noise /= np.sum(noise)\n        self._noise_dict[info_state] = {action_ids[i]: noise[i] for i in range(len(noise))}\n    return self._noise_dict[info_state]",
            "def get_or_create_noise(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get noisy policy or create it and return it.\\n\\n    Args:\\n      state: the state to which the policy will be applied.\\n      player_id: the player id that will apply the noisy policy. Default to\\n        current_player. Should be defined in the case of simultaneous games.\\n\\n    Returns:\\n      noise_action_probs: The noisy probability distribution on the set of legal\\n        actions.\\n    '\n    if player_id is None:\n        player_id = state.current_player()\n    info_state = self._state_key(state, player_id)\n    if info_state not in self._noise_dict:\n        action_ids = state.legal_actions(player_id)\n        noise = self._beta * np.random.normal(size=len(action_ids))\n        noise = np.exp(noise - noise.max())\n        noise /= np.sum(noise)\n        self._noise_dict[info_state] = {action_ids[i]: noise[i] for i in range(len(noise))}\n    return self._noise_dict[info_state]",
            "def get_or_create_noise(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get noisy policy or create it and return it.\\n\\n    Args:\\n      state: the state to which the policy will be applied.\\n      player_id: the player id that will apply the noisy policy. Default to\\n        current_player. Should be defined in the case of simultaneous games.\\n\\n    Returns:\\n      noise_action_probs: The noisy probability distribution on the set of legal\\n        actions.\\n    '\n    if player_id is None:\n        player_id = state.current_player()\n    info_state = self._state_key(state, player_id)\n    if info_state not in self._noise_dict:\n        action_ids = state.legal_actions(player_id)\n        noise = self._beta * np.random.normal(size=len(action_ids))\n        noise = np.exp(noise - noise.max())\n        noise /= np.sum(noise)\n        self._noise_dict[info_state] = {action_ids[i]: noise[i] for i in range(len(noise))}\n    return self._noise_dict[info_state]"
        ]
    },
    {
        "func_name": "mix_probs",
        "original": "def mix_probs(self, probs, noise_probs):\n    return {i: (1 - self._alpha) * probs[i] + self._alpha * noise_probs[i] for i in probs}",
        "mutated": [
            "def mix_probs(self, probs, noise_probs):\n    if False:\n        i = 10\n    return {i: (1 - self._alpha) * probs[i] + self._alpha * noise_probs[i] for i in probs}",
            "def mix_probs(self, probs, noise_probs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return {i: (1 - self._alpha) * probs[i] + self._alpha * noise_probs[i] for i in probs}",
            "def mix_probs(self, probs, noise_probs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return {i: (1 - self._alpha) * probs[i] + self._alpha * noise_probs[i] for i in probs}",
            "def mix_probs(self, probs, noise_probs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return {i: (1 - self._alpha) * probs[i] + self._alpha * noise_probs[i] for i in probs}",
            "def mix_probs(self, probs, noise_probs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return {i: (1 - self._alpha) * probs[i] + self._alpha * noise_probs[i] for i in probs}"
        ]
    },
    {
        "func_name": "policy",
        "original": "@property\ndef policy(self):\n    return self._policy",
        "mutated": [
            "@property\ndef policy(self):\n    if False:\n        i = 10\n    return self._policy",
            "@property\ndef policy(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self._policy",
            "@property\ndef policy(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self._policy",
            "@property\ndef policy(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self._policy",
            "@property\ndef policy(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self._policy"
        ]
    },
    {
        "func_name": "action_probabilities",
        "original": "def action_probabilities(self, state, player_id=None):\n    \"\"\"Returns the policy for a player in a state.\n\n    Args:\n      state: A `pyspiel.State` object.\n      player_id: Optional, the player id for whom we want an action. Optional\n        unless this is a simultabeous state at which multiple players can act.\n\n    Returns:\n      A `dict` of `{action: probability}` for the specified player in the\n      supplied state.\n    \"\"\"\n    if self.player_id is None or state.current_player() == self.player_id or player_id == self.player_id:\n        noise_probs = self.get_or_create_noise(state, player_id)\n        probs = self._policy.action_probabilities(state, player_id)\n        probs = self.mix_probs(probs, noise_probs)\n        return probs\n    return self._policy.action_probabilities(state, player_id)",
        "mutated": [
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultabeous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    if self.player_id is None or state.current_player() == self.player_id or player_id == self.player_id:\n        noise_probs = self.get_or_create_noise(state, player_id)\n        probs = self._policy.action_probabilities(state, player_id)\n        probs = self.mix_probs(probs, noise_probs)\n        return probs\n    return self._policy.action_probabilities(state, player_id)",
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultabeous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    if self.player_id is None or state.current_player() == self.player_id or player_id == self.player_id:\n        noise_probs = self.get_or_create_noise(state, player_id)\n        probs = self._policy.action_probabilities(state, player_id)\n        probs = self.mix_probs(probs, noise_probs)\n        return probs\n    return self._policy.action_probabilities(state, player_id)",
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultabeous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    if self.player_id is None or state.current_player() == self.player_id or player_id == self.player_id:\n        noise_probs = self.get_or_create_noise(state, player_id)\n        probs = self._policy.action_probabilities(state, player_id)\n        probs = self.mix_probs(probs, noise_probs)\n        return probs\n    return self._policy.action_probabilities(state, player_id)",
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultabeous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    if self.player_id is None or state.current_player() == self.player_id or player_id == self.player_id:\n        noise_probs = self.get_or_create_noise(state, player_id)\n        probs = self._policy.action_probabilities(state, player_id)\n        probs = self.mix_probs(probs, noise_probs)\n        return probs\n    return self._policy.action_probabilities(state, player_id)",
            "def action_probabilities(self, state, player_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the policy for a player in a state.\\n\\n    Args:\\n      state: A `pyspiel.State` object.\\n      player_id: Optional, the player id for whom we want an action. Optional\\n        unless this is a simultabeous state at which multiple players can act.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    if self.player_id is None or state.current_player() == self.player_id or player_id == self.player_id:\n        noise_probs = self.get_or_create_noise(state, player_id)\n        probs = self._policy.action_probabilities(state, player_id)\n        probs = self.mix_probs(probs, noise_probs)\n        return probs\n    return self._policy.action_probabilities(state, player_id)"
        ]
    }
]