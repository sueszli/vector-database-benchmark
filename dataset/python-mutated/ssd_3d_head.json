[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_classes, bbox_coder, in_channels=256, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, pred_layer_cfg=None, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), objectness_loss=None, center_loss=None, dir_class_loss=None, dir_res_loss=None, size_res_loss=None, corner_loss=None, vote_loss=None, init_cfg=None):\n    super(SSD3DHead, self).__init__(num_classes, bbox_coder, train_cfg=train_cfg, test_cfg=test_cfg, vote_module_cfg=vote_module_cfg, vote_aggregation_cfg=vote_aggregation_cfg, pred_layer_cfg=pred_layer_cfg, conv_cfg=conv_cfg, norm_cfg=norm_cfg, objectness_loss=objectness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_class_loss=None, size_res_loss=size_res_loss, semantic_loss=None, init_cfg=init_cfg)\n    self.corner_loss = build_loss(corner_loss)\n    self.vote_loss = build_loss(vote_loss)\n    self.num_candidates = vote_module_cfg['num_points']",
        "mutated": [
            "def __init__(self, num_classes, bbox_coder, in_channels=256, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, pred_layer_cfg=None, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), objectness_loss=None, center_loss=None, dir_class_loss=None, dir_res_loss=None, size_res_loss=None, corner_loss=None, vote_loss=None, init_cfg=None):\n    if False:\n        i = 10\n    super(SSD3DHead, self).__init__(num_classes, bbox_coder, train_cfg=train_cfg, test_cfg=test_cfg, vote_module_cfg=vote_module_cfg, vote_aggregation_cfg=vote_aggregation_cfg, pred_layer_cfg=pred_layer_cfg, conv_cfg=conv_cfg, norm_cfg=norm_cfg, objectness_loss=objectness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_class_loss=None, size_res_loss=size_res_loss, semantic_loss=None, init_cfg=init_cfg)\n    self.corner_loss = build_loss(corner_loss)\n    self.vote_loss = build_loss(vote_loss)\n    self.num_candidates = vote_module_cfg['num_points']",
            "def __init__(self, num_classes, bbox_coder, in_channels=256, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, pred_layer_cfg=None, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), objectness_loss=None, center_loss=None, dir_class_loss=None, dir_res_loss=None, size_res_loss=None, corner_loss=None, vote_loss=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(SSD3DHead, self).__init__(num_classes, bbox_coder, train_cfg=train_cfg, test_cfg=test_cfg, vote_module_cfg=vote_module_cfg, vote_aggregation_cfg=vote_aggregation_cfg, pred_layer_cfg=pred_layer_cfg, conv_cfg=conv_cfg, norm_cfg=norm_cfg, objectness_loss=objectness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_class_loss=None, size_res_loss=size_res_loss, semantic_loss=None, init_cfg=init_cfg)\n    self.corner_loss = build_loss(corner_loss)\n    self.vote_loss = build_loss(vote_loss)\n    self.num_candidates = vote_module_cfg['num_points']",
            "def __init__(self, num_classes, bbox_coder, in_channels=256, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, pred_layer_cfg=None, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), objectness_loss=None, center_loss=None, dir_class_loss=None, dir_res_loss=None, size_res_loss=None, corner_loss=None, vote_loss=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(SSD3DHead, self).__init__(num_classes, bbox_coder, train_cfg=train_cfg, test_cfg=test_cfg, vote_module_cfg=vote_module_cfg, vote_aggregation_cfg=vote_aggregation_cfg, pred_layer_cfg=pred_layer_cfg, conv_cfg=conv_cfg, norm_cfg=norm_cfg, objectness_loss=objectness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_class_loss=None, size_res_loss=size_res_loss, semantic_loss=None, init_cfg=init_cfg)\n    self.corner_loss = build_loss(corner_loss)\n    self.vote_loss = build_loss(vote_loss)\n    self.num_candidates = vote_module_cfg['num_points']",
            "def __init__(self, num_classes, bbox_coder, in_channels=256, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, pred_layer_cfg=None, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), objectness_loss=None, center_loss=None, dir_class_loss=None, dir_res_loss=None, size_res_loss=None, corner_loss=None, vote_loss=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(SSD3DHead, self).__init__(num_classes, bbox_coder, train_cfg=train_cfg, test_cfg=test_cfg, vote_module_cfg=vote_module_cfg, vote_aggregation_cfg=vote_aggregation_cfg, pred_layer_cfg=pred_layer_cfg, conv_cfg=conv_cfg, norm_cfg=norm_cfg, objectness_loss=objectness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_class_loss=None, size_res_loss=size_res_loss, semantic_loss=None, init_cfg=init_cfg)\n    self.corner_loss = build_loss(corner_loss)\n    self.vote_loss = build_loss(vote_loss)\n    self.num_candidates = vote_module_cfg['num_points']",
            "def __init__(self, num_classes, bbox_coder, in_channels=256, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, pred_layer_cfg=None, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), objectness_loss=None, center_loss=None, dir_class_loss=None, dir_res_loss=None, size_res_loss=None, corner_loss=None, vote_loss=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(SSD3DHead, self).__init__(num_classes, bbox_coder, train_cfg=train_cfg, test_cfg=test_cfg, vote_module_cfg=vote_module_cfg, vote_aggregation_cfg=vote_aggregation_cfg, pred_layer_cfg=pred_layer_cfg, conv_cfg=conv_cfg, norm_cfg=norm_cfg, objectness_loss=objectness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_class_loss=None, size_res_loss=size_res_loss, semantic_loss=None, init_cfg=init_cfg)\n    self.corner_loss = build_loss(corner_loss)\n    self.vote_loss = build_loss(vote_loss)\n    self.num_candidates = vote_module_cfg['num_points']"
        ]
    },
    {
        "func_name": "_get_cls_out_channels",
        "original": "def _get_cls_out_channels(self):\n    \"\"\"Return the channel number of classification outputs.\"\"\"\n    return self.num_classes",
        "mutated": [
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n    'Return the channel number of classification outputs.'\n    return self.num_classes",
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the channel number of classification outputs.'\n    return self.num_classes",
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the channel number of classification outputs.'\n    return self.num_classes",
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the channel number of classification outputs.'\n    return self.num_classes",
            "def _get_cls_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the channel number of classification outputs.'\n    return self.num_classes"
        ]
    },
    {
        "func_name": "_get_reg_out_channels",
        "original": "def _get_reg_out_channels(self):\n    \"\"\"Return the channel number of regression outputs.\"\"\"\n    return 3 + 3 + self.num_dir_bins * 2",
        "mutated": [
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n    'Return the channel number of regression outputs.'\n    return 3 + 3 + self.num_dir_bins * 2",
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the channel number of regression outputs.'\n    return 3 + 3 + self.num_dir_bins * 2",
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the channel number of regression outputs.'\n    return 3 + 3 + self.num_dir_bins * 2",
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the channel number of regression outputs.'\n    return 3 + 3 + self.num_dir_bins * 2",
            "def _get_reg_out_channels(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the channel number of regression outputs.'\n    return 3 + 3 + self.num_dir_bins * 2"
        ]
    },
    {
        "func_name": "_extract_input",
        "original": "def _extract_input(self, feat_dict):\n    \"\"\"Extract inputs from features dictionary.\n\n        Args:\n            feat_dict (dict): Feature dict from backbone.\n\n        Returns:\n            torch.Tensor: Coordinates of input points.\n            torch.Tensor: Features of input points.\n            torch.Tensor: Indices of input points.\n        \"\"\"\n    seed_points = feat_dict['sa_xyz'][-1]\n    seed_features = feat_dict['sa_features'][-1]\n    seed_indices = feat_dict['sa_indices'][-1]\n    return (seed_points, seed_features, seed_indices)",
        "mutated": [
            "def _extract_input(self, feat_dict):\n    if False:\n        i = 10\n    'Extract inputs from features dictionary.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            torch.Tensor: Coordinates of input points.\\n            torch.Tensor: Features of input points.\\n            torch.Tensor: Indices of input points.\\n        '\n    seed_points = feat_dict['sa_xyz'][-1]\n    seed_features = feat_dict['sa_features'][-1]\n    seed_indices = feat_dict['sa_indices'][-1]\n    return (seed_points, seed_features, seed_indices)",
            "def _extract_input(self, feat_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Extract inputs from features dictionary.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            torch.Tensor: Coordinates of input points.\\n            torch.Tensor: Features of input points.\\n            torch.Tensor: Indices of input points.\\n        '\n    seed_points = feat_dict['sa_xyz'][-1]\n    seed_features = feat_dict['sa_features'][-1]\n    seed_indices = feat_dict['sa_indices'][-1]\n    return (seed_points, seed_features, seed_indices)",
            "def _extract_input(self, feat_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Extract inputs from features dictionary.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            torch.Tensor: Coordinates of input points.\\n            torch.Tensor: Features of input points.\\n            torch.Tensor: Indices of input points.\\n        '\n    seed_points = feat_dict['sa_xyz'][-1]\n    seed_features = feat_dict['sa_features'][-1]\n    seed_indices = feat_dict['sa_indices'][-1]\n    return (seed_points, seed_features, seed_indices)",
            "def _extract_input(self, feat_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Extract inputs from features dictionary.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            torch.Tensor: Coordinates of input points.\\n            torch.Tensor: Features of input points.\\n            torch.Tensor: Indices of input points.\\n        '\n    seed_points = feat_dict['sa_xyz'][-1]\n    seed_features = feat_dict['sa_features'][-1]\n    seed_indices = feat_dict['sa_indices'][-1]\n    return (seed_points, seed_features, seed_indices)",
            "def _extract_input(self, feat_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Extract inputs from features dictionary.\\n\\n        Args:\\n            feat_dict (dict): Feature dict from backbone.\\n\\n        Returns:\\n            torch.Tensor: Coordinates of input points.\\n            torch.Tensor: Features of input points.\\n            torch.Tensor: Indices of input points.\\n        '\n    seed_points = feat_dict['sa_xyz'][-1]\n    seed_features = feat_dict['sa_features'][-1]\n    seed_indices = feat_dict['sa_indices'][-1]\n    return (seed_points, seed_features, seed_indices)"
        ]
    },
    {
        "func_name": "loss",
        "original": "@force_fp32(apply_to=('bbox_preds',))\ndef loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    \"\"\"Compute loss.\n\n        Args:\n            bbox_preds (dict): Predictions from forward of SSD3DHead.\n            points (list[torch.Tensor]): Input points.\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\n                bboxes of each sample.\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\n                semantic mask.\n            pts_instance_mask (list[torch.Tensor]): Point-wise\n                instance mask.\n            img_metas (list[dict]): Contain pcd and img's meta info.\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\n                which bounding.\n\n        Returns:\n            dict: Losses of 3DSSD.\n        \"\"\"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight) = targets\n    centerness_loss = self.objectness_loss(bbox_preds['obj_scores'].transpose(2, 1), centerness_targets, weight=centerness_weights)\n    center_loss = self.center_loss(bbox_preds['center_offset'], center_targets, weight=box_loss_weights.unsqueeze(-1))\n    dir_class_loss = self.dir_class_loss(bbox_preds['dir_class'].transpose(1, 2), dir_class_targets, weight=box_loss_weights)\n    dir_res_loss = self.dir_res_loss(bbox_preds['dir_res_norm'], dir_res_targets.unsqueeze(-1).repeat(1, 1, self.num_dir_bins), weight=heading_res_loss_weight)\n    size_loss = self.size_res_loss(bbox_preds['size'], size_res_targets, weight=box_loss_weights.unsqueeze(-1))\n    one_hot_dir_class_targets = dir_class_targets.new_zeros(bbox_preds['dir_class'].shape)\n    one_hot_dir_class_targets.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    pred_bbox3d = self.bbox_coder.decode(dict(center=bbox_preds['center'], dir_res=bbox_preds['dir_res'], dir_class=one_hot_dir_class_targets, size=bbox_preds['size']))\n    pred_bbox3d = pred_bbox3d.reshape(-1, pred_bbox3d.shape[-1])\n    pred_bbox3d = img_metas[0]['box_type_3d'](pred_bbox3d.clone(), box_dim=pred_bbox3d.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    pred_corners3d = pred_bbox3d.corners.reshape(-1, 8, 3)\n    corner_loss = self.corner_loss(pred_corners3d, corner3d_targets.reshape(-1, 8, 3), weight=box_loss_weights.view(-1, 1, 1))\n    vote_loss = self.vote_loss(bbox_preds['vote_offset'].transpose(1, 2), vote_targets, weight=vote_mask.unsqueeze(-1))\n    losses = dict(centerness_loss=centerness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_res_loss=size_loss, corner_loss=corner_loss, vote_loss=vote_loss)\n    return losses",
        "mutated": [
            "@force_fp32(apply_to=('bbox_preds',))\ndef loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of SSD3DHead.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of 3DSSD.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight) = targets\n    centerness_loss = self.objectness_loss(bbox_preds['obj_scores'].transpose(2, 1), centerness_targets, weight=centerness_weights)\n    center_loss = self.center_loss(bbox_preds['center_offset'], center_targets, weight=box_loss_weights.unsqueeze(-1))\n    dir_class_loss = self.dir_class_loss(bbox_preds['dir_class'].transpose(1, 2), dir_class_targets, weight=box_loss_weights)\n    dir_res_loss = self.dir_res_loss(bbox_preds['dir_res_norm'], dir_res_targets.unsqueeze(-1).repeat(1, 1, self.num_dir_bins), weight=heading_res_loss_weight)\n    size_loss = self.size_res_loss(bbox_preds['size'], size_res_targets, weight=box_loss_weights.unsqueeze(-1))\n    one_hot_dir_class_targets = dir_class_targets.new_zeros(bbox_preds['dir_class'].shape)\n    one_hot_dir_class_targets.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    pred_bbox3d = self.bbox_coder.decode(dict(center=bbox_preds['center'], dir_res=bbox_preds['dir_res'], dir_class=one_hot_dir_class_targets, size=bbox_preds['size']))\n    pred_bbox3d = pred_bbox3d.reshape(-1, pred_bbox3d.shape[-1])\n    pred_bbox3d = img_metas[0]['box_type_3d'](pred_bbox3d.clone(), box_dim=pred_bbox3d.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    pred_corners3d = pred_bbox3d.corners.reshape(-1, 8, 3)\n    corner_loss = self.corner_loss(pred_corners3d, corner3d_targets.reshape(-1, 8, 3), weight=box_loss_weights.view(-1, 1, 1))\n    vote_loss = self.vote_loss(bbox_preds['vote_offset'].transpose(1, 2), vote_targets, weight=vote_mask.unsqueeze(-1))\n    losses = dict(centerness_loss=centerness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_res_loss=size_loss, corner_loss=corner_loss, vote_loss=vote_loss)\n    return losses",
            "@force_fp32(apply_to=('bbox_preds',))\ndef loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of SSD3DHead.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of 3DSSD.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight) = targets\n    centerness_loss = self.objectness_loss(bbox_preds['obj_scores'].transpose(2, 1), centerness_targets, weight=centerness_weights)\n    center_loss = self.center_loss(bbox_preds['center_offset'], center_targets, weight=box_loss_weights.unsqueeze(-1))\n    dir_class_loss = self.dir_class_loss(bbox_preds['dir_class'].transpose(1, 2), dir_class_targets, weight=box_loss_weights)\n    dir_res_loss = self.dir_res_loss(bbox_preds['dir_res_norm'], dir_res_targets.unsqueeze(-1).repeat(1, 1, self.num_dir_bins), weight=heading_res_loss_weight)\n    size_loss = self.size_res_loss(bbox_preds['size'], size_res_targets, weight=box_loss_weights.unsqueeze(-1))\n    one_hot_dir_class_targets = dir_class_targets.new_zeros(bbox_preds['dir_class'].shape)\n    one_hot_dir_class_targets.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    pred_bbox3d = self.bbox_coder.decode(dict(center=bbox_preds['center'], dir_res=bbox_preds['dir_res'], dir_class=one_hot_dir_class_targets, size=bbox_preds['size']))\n    pred_bbox3d = pred_bbox3d.reshape(-1, pred_bbox3d.shape[-1])\n    pred_bbox3d = img_metas[0]['box_type_3d'](pred_bbox3d.clone(), box_dim=pred_bbox3d.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    pred_corners3d = pred_bbox3d.corners.reshape(-1, 8, 3)\n    corner_loss = self.corner_loss(pred_corners3d, corner3d_targets.reshape(-1, 8, 3), weight=box_loss_weights.view(-1, 1, 1))\n    vote_loss = self.vote_loss(bbox_preds['vote_offset'].transpose(1, 2), vote_targets, weight=vote_mask.unsqueeze(-1))\n    losses = dict(centerness_loss=centerness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_res_loss=size_loss, corner_loss=corner_loss, vote_loss=vote_loss)\n    return losses",
            "@force_fp32(apply_to=('bbox_preds',))\ndef loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of SSD3DHead.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of 3DSSD.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight) = targets\n    centerness_loss = self.objectness_loss(bbox_preds['obj_scores'].transpose(2, 1), centerness_targets, weight=centerness_weights)\n    center_loss = self.center_loss(bbox_preds['center_offset'], center_targets, weight=box_loss_weights.unsqueeze(-1))\n    dir_class_loss = self.dir_class_loss(bbox_preds['dir_class'].transpose(1, 2), dir_class_targets, weight=box_loss_weights)\n    dir_res_loss = self.dir_res_loss(bbox_preds['dir_res_norm'], dir_res_targets.unsqueeze(-1).repeat(1, 1, self.num_dir_bins), weight=heading_res_loss_weight)\n    size_loss = self.size_res_loss(bbox_preds['size'], size_res_targets, weight=box_loss_weights.unsqueeze(-1))\n    one_hot_dir_class_targets = dir_class_targets.new_zeros(bbox_preds['dir_class'].shape)\n    one_hot_dir_class_targets.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    pred_bbox3d = self.bbox_coder.decode(dict(center=bbox_preds['center'], dir_res=bbox_preds['dir_res'], dir_class=one_hot_dir_class_targets, size=bbox_preds['size']))\n    pred_bbox3d = pred_bbox3d.reshape(-1, pred_bbox3d.shape[-1])\n    pred_bbox3d = img_metas[0]['box_type_3d'](pred_bbox3d.clone(), box_dim=pred_bbox3d.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    pred_corners3d = pred_bbox3d.corners.reshape(-1, 8, 3)\n    corner_loss = self.corner_loss(pred_corners3d, corner3d_targets.reshape(-1, 8, 3), weight=box_loss_weights.view(-1, 1, 1))\n    vote_loss = self.vote_loss(bbox_preds['vote_offset'].transpose(1, 2), vote_targets, weight=vote_mask.unsqueeze(-1))\n    losses = dict(centerness_loss=centerness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_res_loss=size_loss, corner_loss=corner_loss, vote_loss=vote_loss)\n    return losses",
            "@force_fp32(apply_to=('bbox_preds',))\ndef loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of SSD3DHead.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of 3DSSD.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight) = targets\n    centerness_loss = self.objectness_loss(bbox_preds['obj_scores'].transpose(2, 1), centerness_targets, weight=centerness_weights)\n    center_loss = self.center_loss(bbox_preds['center_offset'], center_targets, weight=box_loss_weights.unsqueeze(-1))\n    dir_class_loss = self.dir_class_loss(bbox_preds['dir_class'].transpose(1, 2), dir_class_targets, weight=box_loss_weights)\n    dir_res_loss = self.dir_res_loss(bbox_preds['dir_res_norm'], dir_res_targets.unsqueeze(-1).repeat(1, 1, self.num_dir_bins), weight=heading_res_loss_weight)\n    size_loss = self.size_res_loss(bbox_preds['size'], size_res_targets, weight=box_loss_weights.unsqueeze(-1))\n    one_hot_dir_class_targets = dir_class_targets.new_zeros(bbox_preds['dir_class'].shape)\n    one_hot_dir_class_targets.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    pred_bbox3d = self.bbox_coder.decode(dict(center=bbox_preds['center'], dir_res=bbox_preds['dir_res'], dir_class=one_hot_dir_class_targets, size=bbox_preds['size']))\n    pred_bbox3d = pred_bbox3d.reshape(-1, pred_bbox3d.shape[-1])\n    pred_bbox3d = img_metas[0]['box_type_3d'](pred_bbox3d.clone(), box_dim=pred_bbox3d.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    pred_corners3d = pred_bbox3d.corners.reshape(-1, 8, 3)\n    corner_loss = self.corner_loss(pred_corners3d, corner3d_targets.reshape(-1, 8, 3), weight=box_loss_weights.view(-1, 1, 1))\n    vote_loss = self.vote_loss(bbox_preds['vote_offset'].transpose(1, 2), vote_targets, weight=vote_mask.unsqueeze(-1))\n    losses = dict(centerness_loss=centerness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_res_loss=size_loss, corner_loss=corner_loss, vote_loss=vote_loss)\n    return losses",
            "@force_fp32(apply_to=('bbox_preds',))\ndef loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of SSD3DHead.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of 3DSSD.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight) = targets\n    centerness_loss = self.objectness_loss(bbox_preds['obj_scores'].transpose(2, 1), centerness_targets, weight=centerness_weights)\n    center_loss = self.center_loss(bbox_preds['center_offset'], center_targets, weight=box_loss_weights.unsqueeze(-1))\n    dir_class_loss = self.dir_class_loss(bbox_preds['dir_class'].transpose(1, 2), dir_class_targets, weight=box_loss_weights)\n    dir_res_loss = self.dir_res_loss(bbox_preds['dir_res_norm'], dir_res_targets.unsqueeze(-1).repeat(1, 1, self.num_dir_bins), weight=heading_res_loss_weight)\n    size_loss = self.size_res_loss(bbox_preds['size'], size_res_targets, weight=box_loss_weights.unsqueeze(-1))\n    one_hot_dir_class_targets = dir_class_targets.new_zeros(bbox_preds['dir_class'].shape)\n    one_hot_dir_class_targets.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    pred_bbox3d = self.bbox_coder.decode(dict(center=bbox_preds['center'], dir_res=bbox_preds['dir_res'], dir_class=one_hot_dir_class_targets, size=bbox_preds['size']))\n    pred_bbox3d = pred_bbox3d.reshape(-1, pred_bbox3d.shape[-1])\n    pred_bbox3d = img_metas[0]['box_type_3d'](pred_bbox3d.clone(), box_dim=pred_bbox3d.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    pred_corners3d = pred_bbox3d.corners.reshape(-1, 8, 3)\n    corner_loss = self.corner_loss(pred_corners3d, corner3d_targets.reshape(-1, 8, 3), weight=box_loss_weights.view(-1, 1, 1))\n    vote_loss = self.vote_loss(bbox_preds['vote_offset'].transpose(1, 2), vote_targets, weight=vote_mask.unsqueeze(-1))\n    losses = dict(centerness_loss=centerness_loss, center_loss=center_loss, dir_class_loss=dir_class_loss, dir_res_loss=dir_res_loss, size_res_loss=size_loss, corner_loss=corner_loss, vote_loss=vote_loss)\n    return losses"
        ]
    },
    {
        "func_name": "get_targets",
        "original": "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    \"\"\"Generate targets of ssd3d head.\n\n        Args:\n            points (list[torch.Tensor]): Points of each batch.\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\n                bboxes of each batch.\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\n                label of each batch.\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\n                label of each batch.\n            bbox_preds (torch.Tensor): Bounding box predictions of ssd3d head.\n\n        Returns:\n            tuple[torch.Tensor]: Targets of ssd3d head.\n        \"\"\"\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    aggregated_points = [bbox_preds['aggregated_points'][i] for i in range(len(gt_labels_3d))]\n    seed_points = [bbox_preds['seed_points'][i, :self.num_candidates].detach() for i in range(len(gt_labels_3d))]\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, aggregated_points, seed_points)\n    center_targets = torch.stack(center_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    dir_class_targets = torch.stack(dir_class_targets)\n    dir_res_targets = torch.stack(dir_res_targets)\n    size_res_targets = torch.stack(size_res_targets)\n    mask_targets = torch.stack(mask_targets)\n    centerness_targets = torch.stack(centerness_targets).detach()\n    corner3d_targets = torch.stack(corner3d_targets)\n    vote_targets = torch.stack(vote_targets)\n    vote_mask = torch.stack(vote_mask)\n    center_targets -= bbox_preds['aggregated_points']\n    centerness_weights = (positive_mask + negative_mask).unsqueeze(-1).repeat(1, 1, self.num_classes).float()\n    centerness_weights = centerness_weights / (centerness_weights.sum() + 1e-06)\n    vote_mask = vote_mask / (vote_mask.sum() + 1e-06)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    (batch_size, proposal_num) = dir_class_targets.shape[:2]\n    heading_label_one_hot = dir_class_targets.new_zeros((batch_size, proposal_num, self.num_dir_bins))\n    heading_label_one_hot.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    heading_res_loss_weight = heading_label_one_hot * box_loss_weights.unsqueeze(-1)\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight)",
        "mutated": [
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n    'Generate targets of ssd3d head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (torch.Tensor): Bounding box predictions of ssd3d head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    aggregated_points = [bbox_preds['aggregated_points'][i] for i in range(len(gt_labels_3d))]\n    seed_points = [bbox_preds['seed_points'][i, :self.num_candidates].detach() for i in range(len(gt_labels_3d))]\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, aggregated_points, seed_points)\n    center_targets = torch.stack(center_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    dir_class_targets = torch.stack(dir_class_targets)\n    dir_res_targets = torch.stack(dir_res_targets)\n    size_res_targets = torch.stack(size_res_targets)\n    mask_targets = torch.stack(mask_targets)\n    centerness_targets = torch.stack(centerness_targets).detach()\n    corner3d_targets = torch.stack(corner3d_targets)\n    vote_targets = torch.stack(vote_targets)\n    vote_mask = torch.stack(vote_mask)\n    center_targets -= bbox_preds['aggregated_points']\n    centerness_weights = (positive_mask + negative_mask).unsqueeze(-1).repeat(1, 1, self.num_classes).float()\n    centerness_weights = centerness_weights / (centerness_weights.sum() + 1e-06)\n    vote_mask = vote_mask / (vote_mask.sum() + 1e-06)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    (batch_size, proposal_num) = dir_class_targets.shape[:2]\n    heading_label_one_hot = dir_class_targets.new_zeros((batch_size, proposal_num, self.num_dir_bins))\n    heading_label_one_hot.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    heading_res_loss_weight = heading_label_one_hot * box_loss_weights.unsqueeze(-1)\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate targets of ssd3d head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (torch.Tensor): Bounding box predictions of ssd3d head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    aggregated_points = [bbox_preds['aggregated_points'][i] for i in range(len(gt_labels_3d))]\n    seed_points = [bbox_preds['seed_points'][i, :self.num_candidates].detach() for i in range(len(gt_labels_3d))]\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, aggregated_points, seed_points)\n    center_targets = torch.stack(center_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    dir_class_targets = torch.stack(dir_class_targets)\n    dir_res_targets = torch.stack(dir_res_targets)\n    size_res_targets = torch.stack(size_res_targets)\n    mask_targets = torch.stack(mask_targets)\n    centerness_targets = torch.stack(centerness_targets).detach()\n    corner3d_targets = torch.stack(corner3d_targets)\n    vote_targets = torch.stack(vote_targets)\n    vote_mask = torch.stack(vote_mask)\n    center_targets -= bbox_preds['aggregated_points']\n    centerness_weights = (positive_mask + negative_mask).unsqueeze(-1).repeat(1, 1, self.num_classes).float()\n    centerness_weights = centerness_weights / (centerness_weights.sum() + 1e-06)\n    vote_mask = vote_mask / (vote_mask.sum() + 1e-06)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    (batch_size, proposal_num) = dir_class_targets.shape[:2]\n    heading_label_one_hot = dir_class_targets.new_zeros((batch_size, proposal_num, self.num_dir_bins))\n    heading_label_one_hot.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    heading_res_loss_weight = heading_label_one_hot * box_loss_weights.unsqueeze(-1)\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate targets of ssd3d head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (torch.Tensor): Bounding box predictions of ssd3d head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    aggregated_points = [bbox_preds['aggregated_points'][i] for i in range(len(gt_labels_3d))]\n    seed_points = [bbox_preds['seed_points'][i, :self.num_candidates].detach() for i in range(len(gt_labels_3d))]\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, aggregated_points, seed_points)\n    center_targets = torch.stack(center_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    dir_class_targets = torch.stack(dir_class_targets)\n    dir_res_targets = torch.stack(dir_res_targets)\n    size_res_targets = torch.stack(size_res_targets)\n    mask_targets = torch.stack(mask_targets)\n    centerness_targets = torch.stack(centerness_targets).detach()\n    corner3d_targets = torch.stack(corner3d_targets)\n    vote_targets = torch.stack(vote_targets)\n    vote_mask = torch.stack(vote_mask)\n    center_targets -= bbox_preds['aggregated_points']\n    centerness_weights = (positive_mask + negative_mask).unsqueeze(-1).repeat(1, 1, self.num_classes).float()\n    centerness_weights = centerness_weights / (centerness_weights.sum() + 1e-06)\n    vote_mask = vote_mask / (vote_mask.sum() + 1e-06)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    (batch_size, proposal_num) = dir_class_targets.shape[:2]\n    heading_label_one_hot = dir_class_targets.new_zeros((batch_size, proposal_num, self.num_dir_bins))\n    heading_label_one_hot.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    heading_res_loss_weight = heading_label_one_hot * box_loss_weights.unsqueeze(-1)\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate targets of ssd3d head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (torch.Tensor): Bounding box predictions of ssd3d head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    aggregated_points = [bbox_preds['aggregated_points'][i] for i in range(len(gt_labels_3d))]\n    seed_points = [bbox_preds['seed_points'][i, :self.num_candidates].detach() for i in range(len(gt_labels_3d))]\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, aggregated_points, seed_points)\n    center_targets = torch.stack(center_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    dir_class_targets = torch.stack(dir_class_targets)\n    dir_res_targets = torch.stack(dir_res_targets)\n    size_res_targets = torch.stack(size_res_targets)\n    mask_targets = torch.stack(mask_targets)\n    centerness_targets = torch.stack(centerness_targets).detach()\n    corner3d_targets = torch.stack(corner3d_targets)\n    vote_targets = torch.stack(vote_targets)\n    vote_mask = torch.stack(vote_mask)\n    center_targets -= bbox_preds['aggregated_points']\n    centerness_weights = (positive_mask + negative_mask).unsqueeze(-1).repeat(1, 1, self.num_classes).float()\n    centerness_weights = centerness_weights / (centerness_weights.sum() + 1e-06)\n    vote_mask = vote_mask / (vote_mask.sum() + 1e-06)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    (batch_size, proposal_num) = dir_class_targets.shape[:2]\n    heading_label_one_hot = dir_class_targets.new_zeros((batch_size, proposal_num, self.num_dir_bins))\n    heading_label_one_hot.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    heading_res_loss_weight = heading_label_one_hot * box_loss_weights.unsqueeze(-1)\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate targets of ssd3d head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (torch.Tensor): Bounding box predictions of ssd3d head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    aggregated_points = [bbox_preds['aggregated_points'][i] for i in range(len(gt_labels_3d))]\n    seed_points = [bbox_preds['seed_points'][i, :self.num_candidates].detach() for i in range(len(gt_labels_3d))]\n    (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, aggregated_points, seed_points)\n    center_targets = torch.stack(center_targets)\n    positive_mask = torch.stack(positive_mask)\n    negative_mask = torch.stack(negative_mask)\n    dir_class_targets = torch.stack(dir_class_targets)\n    dir_res_targets = torch.stack(dir_res_targets)\n    size_res_targets = torch.stack(size_res_targets)\n    mask_targets = torch.stack(mask_targets)\n    centerness_targets = torch.stack(centerness_targets).detach()\n    corner3d_targets = torch.stack(corner3d_targets)\n    vote_targets = torch.stack(vote_targets)\n    vote_mask = torch.stack(vote_mask)\n    center_targets -= bbox_preds['aggregated_points']\n    centerness_weights = (positive_mask + negative_mask).unsqueeze(-1).repeat(1, 1, self.num_classes).float()\n    centerness_weights = centerness_weights / (centerness_weights.sum() + 1e-06)\n    vote_mask = vote_mask / (vote_mask.sum() + 1e-06)\n    box_loss_weights = positive_mask / (positive_mask.sum() + 1e-06)\n    (batch_size, proposal_num) = dir_class_targets.shape[:2]\n    heading_label_one_hot = dir_class_targets.new_zeros((batch_size, proposal_num, self.num_dir_bins))\n    heading_label_one_hot.scatter_(2, dir_class_targets.unsqueeze(-1), 1)\n    heading_res_loss_weight = heading_label_one_hot * box_loss_weights.unsqueeze(-1)\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask, centerness_weights, box_loss_weights, heading_res_loss_weight)"
        ]
    },
    {
        "func_name": "get_targets_single",
        "original": "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, aggregated_points=None, seed_points=None):\n    \"\"\"Generate targets of ssd3d head for single batch.\n\n        Args:\n            points (torch.Tensor): Points of each batch.\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\n                boxes of each batch.\n            gt_labels_3d (torch.Tensor): Labels of each batch.\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\n                label of each batch.\n            pts_instance_mask (torch.Tensor): Point-wise instance\n                label of each batch.\n            aggregated_points (torch.Tensor): Aggregated points from\n                candidate points layer.\n            seed_points (torch.Tensor): Seed points of candidate points.\n\n        Returns:\n            tuple[torch.Tensor]: Targets of ssd3d head.\n        \"\"\"\n    assert self.bbox_coder.with_rot or pts_semantic_mask is not None\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    if valid_gt.sum() == 0:\n        vote_targets = points.new_zeros(self.num_candidates, 3)\n        center_targets = points.new_zeros(self.num_candidates, 3)\n        size_res_targets = points.new_zeros(self.num_candidates, 3)\n        dir_class_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        dir_res_targets = points.new_zeros(self.num_candidates)\n        mask_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        centerness_targets = points.new_zeros(self.num_candidates, self.num_classes)\n        corner3d_targets = points.new_zeros(self.num_candidates, 8, 3)\n        vote_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        positive_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        negative_mask = points.new_ones(self.num_candidates, dtype=torch.bool)\n        return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)\n    gt_corner3d = gt_bboxes_3d.corners\n    (center_targets, size_targets, dir_class_targets, dir_res_targets) = self.bbox_coder.encode(gt_bboxes_3d, gt_labels_3d)\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, aggregated_points)\n    center_targets = center_targets[assignment]\n    size_res_targets = size_targets[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    dir_class_targets = dir_class_targets[assignment]\n    dir_res_targets = dir_res_targets[assignment]\n    corner3d_targets = gt_corner3d[assignment]\n    top_center_targets = center_targets.clone()\n    top_center_targets[:, 2] += size_res_targets[:, 2]\n    dist = torch.norm(aggregated_points - top_center_targets, dim=1)\n    dist_mask = dist < self.train_cfg.pos_distance_thr\n    positive_mask = (points_mask.max(1)[0] > 0) * dist_mask\n    negative_mask = points_mask.max(1)[0] == 0\n    canonical_xyz = aggregated_points - center_targets\n    if self.bbox_coder.with_rot:\n        canonical_xyz = rotation_3d_in_axis(canonical_xyz.unsqueeze(0).transpose(0, 1), -gt_bboxes_3d.yaw[assignment], axis=2).squeeze(1)\n    distance_front = torch.clamp(size_res_targets[:, 0] - canonical_xyz[:, 0], min=0)\n    distance_back = torch.clamp(size_res_targets[:, 0] + canonical_xyz[:, 0], min=0)\n    distance_left = torch.clamp(size_res_targets[:, 1] - canonical_xyz[:, 1], min=0)\n    distance_right = torch.clamp(size_res_targets[:, 1] + canonical_xyz[:, 1], min=0)\n    distance_top = torch.clamp(size_res_targets[:, 2] - canonical_xyz[:, 2], min=0)\n    distance_bottom = torch.clamp(size_res_targets[:, 2] + canonical_xyz[:, 2], min=0)\n    centerness_l = torch.min(distance_front, distance_back) / torch.max(distance_front, distance_back)\n    centerness_w = torch.min(distance_left, distance_right) / torch.max(distance_left, distance_right)\n    centerness_h = torch.min(distance_bottom, distance_top) / torch.max(distance_bottom, distance_top)\n    centerness_targets = torch.clamp(centerness_l * centerness_w * centerness_h, min=0)\n    centerness_targets = centerness_targets.pow(1 / 3.0)\n    centerness_targets = torch.clamp(centerness_targets, min=0, max=1)\n    proposal_num = centerness_targets.shape[0]\n    one_hot_centerness_targets = centerness_targets.new_zeros((proposal_num, self.num_classes))\n    one_hot_centerness_targets.scatter_(1, mask_targets.unsqueeze(-1), 1)\n    centerness_targets = centerness_targets.unsqueeze(1) * one_hot_centerness_targets\n    enlarged_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.train_cfg.expand_dims_length)\n    enlarged_gt_bboxes_3d.tensor[:, 2] -= self.train_cfg.expand_dims_length\n    (vote_mask, vote_assignment) = self._assign_targets_by_points_inside(enlarged_gt_bboxes_3d, seed_points)\n    vote_targets = gt_bboxes_3d.gravity_center\n    vote_targets = vote_targets[vote_assignment] - seed_points\n    vote_mask = vote_mask.max(1)[0] > 0\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)",
        "mutated": [
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, aggregated_points=None, seed_points=None):\n    if False:\n        i = 10\n    'Generate targets of ssd3d head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n            aggregated_points (torch.Tensor): Aggregated points from\\n                candidate points layer.\\n            seed_points (torch.Tensor): Seed points of candidate points.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    assert self.bbox_coder.with_rot or pts_semantic_mask is not None\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    if valid_gt.sum() == 0:\n        vote_targets = points.new_zeros(self.num_candidates, 3)\n        center_targets = points.new_zeros(self.num_candidates, 3)\n        size_res_targets = points.new_zeros(self.num_candidates, 3)\n        dir_class_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        dir_res_targets = points.new_zeros(self.num_candidates)\n        mask_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        centerness_targets = points.new_zeros(self.num_candidates, self.num_classes)\n        corner3d_targets = points.new_zeros(self.num_candidates, 8, 3)\n        vote_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        positive_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        negative_mask = points.new_ones(self.num_candidates, dtype=torch.bool)\n        return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)\n    gt_corner3d = gt_bboxes_3d.corners\n    (center_targets, size_targets, dir_class_targets, dir_res_targets) = self.bbox_coder.encode(gt_bboxes_3d, gt_labels_3d)\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, aggregated_points)\n    center_targets = center_targets[assignment]\n    size_res_targets = size_targets[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    dir_class_targets = dir_class_targets[assignment]\n    dir_res_targets = dir_res_targets[assignment]\n    corner3d_targets = gt_corner3d[assignment]\n    top_center_targets = center_targets.clone()\n    top_center_targets[:, 2] += size_res_targets[:, 2]\n    dist = torch.norm(aggregated_points - top_center_targets, dim=1)\n    dist_mask = dist < self.train_cfg.pos_distance_thr\n    positive_mask = (points_mask.max(1)[0] > 0) * dist_mask\n    negative_mask = points_mask.max(1)[0] == 0\n    canonical_xyz = aggregated_points - center_targets\n    if self.bbox_coder.with_rot:\n        canonical_xyz = rotation_3d_in_axis(canonical_xyz.unsqueeze(0).transpose(0, 1), -gt_bboxes_3d.yaw[assignment], axis=2).squeeze(1)\n    distance_front = torch.clamp(size_res_targets[:, 0] - canonical_xyz[:, 0], min=0)\n    distance_back = torch.clamp(size_res_targets[:, 0] + canonical_xyz[:, 0], min=0)\n    distance_left = torch.clamp(size_res_targets[:, 1] - canonical_xyz[:, 1], min=0)\n    distance_right = torch.clamp(size_res_targets[:, 1] + canonical_xyz[:, 1], min=0)\n    distance_top = torch.clamp(size_res_targets[:, 2] - canonical_xyz[:, 2], min=0)\n    distance_bottom = torch.clamp(size_res_targets[:, 2] + canonical_xyz[:, 2], min=0)\n    centerness_l = torch.min(distance_front, distance_back) / torch.max(distance_front, distance_back)\n    centerness_w = torch.min(distance_left, distance_right) / torch.max(distance_left, distance_right)\n    centerness_h = torch.min(distance_bottom, distance_top) / torch.max(distance_bottom, distance_top)\n    centerness_targets = torch.clamp(centerness_l * centerness_w * centerness_h, min=0)\n    centerness_targets = centerness_targets.pow(1 / 3.0)\n    centerness_targets = torch.clamp(centerness_targets, min=0, max=1)\n    proposal_num = centerness_targets.shape[0]\n    one_hot_centerness_targets = centerness_targets.new_zeros((proposal_num, self.num_classes))\n    one_hot_centerness_targets.scatter_(1, mask_targets.unsqueeze(-1), 1)\n    centerness_targets = centerness_targets.unsqueeze(1) * one_hot_centerness_targets\n    enlarged_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.train_cfg.expand_dims_length)\n    enlarged_gt_bboxes_3d.tensor[:, 2] -= self.train_cfg.expand_dims_length\n    (vote_mask, vote_assignment) = self._assign_targets_by_points_inside(enlarged_gt_bboxes_3d, seed_points)\n    vote_targets = gt_bboxes_3d.gravity_center\n    vote_targets = vote_targets[vote_assignment] - seed_points\n    vote_mask = vote_mask.max(1)[0] > 0\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, aggregated_points=None, seed_points=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate targets of ssd3d head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n            aggregated_points (torch.Tensor): Aggregated points from\\n                candidate points layer.\\n            seed_points (torch.Tensor): Seed points of candidate points.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    assert self.bbox_coder.with_rot or pts_semantic_mask is not None\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    if valid_gt.sum() == 0:\n        vote_targets = points.new_zeros(self.num_candidates, 3)\n        center_targets = points.new_zeros(self.num_candidates, 3)\n        size_res_targets = points.new_zeros(self.num_candidates, 3)\n        dir_class_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        dir_res_targets = points.new_zeros(self.num_candidates)\n        mask_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        centerness_targets = points.new_zeros(self.num_candidates, self.num_classes)\n        corner3d_targets = points.new_zeros(self.num_candidates, 8, 3)\n        vote_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        positive_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        negative_mask = points.new_ones(self.num_candidates, dtype=torch.bool)\n        return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)\n    gt_corner3d = gt_bboxes_3d.corners\n    (center_targets, size_targets, dir_class_targets, dir_res_targets) = self.bbox_coder.encode(gt_bboxes_3d, gt_labels_3d)\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, aggregated_points)\n    center_targets = center_targets[assignment]\n    size_res_targets = size_targets[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    dir_class_targets = dir_class_targets[assignment]\n    dir_res_targets = dir_res_targets[assignment]\n    corner3d_targets = gt_corner3d[assignment]\n    top_center_targets = center_targets.clone()\n    top_center_targets[:, 2] += size_res_targets[:, 2]\n    dist = torch.norm(aggregated_points - top_center_targets, dim=1)\n    dist_mask = dist < self.train_cfg.pos_distance_thr\n    positive_mask = (points_mask.max(1)[0] > 0) * dist_mask\n    negative_mask = points_mask.max(1)[0] == 0\n    canonical_xyz = aggregated_points - center_targets\n    if self.bbox_coder.with_rot:\n        canonical_xyz = rotation_3d_in_axis(canonical_xyz.unsqueeze(0).transpose(0, 1), -gt_bboxes_3d.yaw[assignment], axis=2).squeeze(1)\n    distance_front = torch.clamp(size_res_targets[:, 0] - canonical_xyz[:, 0], min=0)\n    distance_back = torch.clamp(size_res_targets[:, 0] + canonical_xyz[:, 0], min=0)\n    distance_left = torch.clamp(size_res_targets[:, 1] - canonical_xyz[:, 1], min=0)\n    distance_right = torch.clamp(size_res_targets[:, 1] + canonical_xyz[:, 1], min=0)\n    distance_top = torch.clamp(size_res_targets[:, 2] - canonical_xyz[:, 2], min=0)\n    distance_bottom = torch.clamp(size_res_targets[:, 2] + canonical_xyz[:, 2], min=0)\n    centerness_l = torch.min(distance_front, distance_back) / torch.max(distance_front, distance_back)\n    centerness_w = torch.min(distance_left, distance_right) / torch.max(distance_left, distance_right)\n    centerness_h = torch.min(distance_bottom, distance_top) / torch.max(distance_bottom, distance_top)\n    centerness_targets = torch.clamp(centerness_l * centerness_w * centerness_h, min=0)\n    centerness_targets = centerness_targets.pow(1 / 3.0)\n    centerness_targets = torch.clamp(centerness_targets, min=0, max=1)\n    proposal_num = centerness_targets.shape[0]\n    one_hot_centerness_targets = centerness_targets.new_zeros((proposal_num, self.num_classes))\n    one_hot_centerness_targets.scatter_(1, mask_targets.unsqueeze(-1), 1)\n    centerness_targets = centerness_targets.unsqueeze(1) * one_hot_centerness_targets\n    enlarged_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.train_cfg.expand_dims_length)\n    enlarged_gt_bboxes_3d.tensor[:, 2] -= self.train_cfg.expand_dims_length\n    (vote_mask, vote_assignment) = self._assign_targets_by_points_inside(enlarged_gt_bboxes_3d, seed_points)\n    vote_targets = gt_bboxes_3d.gravity_center\n    vote_targets = vote_targets[vote_assignment] - seed_points\n    vote_mask = vote_mask.max(1)[0] > 0\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, aggregated_points=None, seed_points=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate targets of ssd3d head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n            aggregated_points (torch.Tensor): Aggregated points from\\n                candidate points layer.\\n            seed_points (torch.Tensor): Seed points of candidate points.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    assert self.bbox_coder.with_rot or pts_semantic_mask is not None\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    if valid_gt.sum() == 0:\n        vote_targets = points.new_zeros(self.num_candidates, 3)\n        center_targets = points.new_zeros(self.num_candidates, 3)\n        size_res_targets = points.new_zeros(self.num_candidates, 3)\n        dir_class_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        dir_res_targets = points.new_zeros(self.num_candidates)\n        mask_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        centerness_targets = points.new_zeros(self.num_candidates, self.num_classes)\n        corner3d_targets = points.new_zeros(self.num_candidates, 8, 3)\n        vote_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        positive_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        negative_mask = points.new_ones(self.num_candidates, dtype=torch.bool)\n        return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)\n    gt_corner3d = gt_bboxes_3d.corners\n    (center_targets, size_targets, dir_class_targets, dir_res_targets) = self.bbox_coder.encode(gt_bboxes_3d, gt_labels_3d)\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, aggregated_points)\n    center_targets = center_targets[assignment]\n    size_res_targets = size_targets[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    dir_class_targets = dir_class_targets[assignment]\n    dir_res_targets = dir_res_targets[assignment]\n    corner3d_targets = gt_corner3d[assignment]\n    top_center_targets = center_targets.clone()\n    top_center_targets[:, 2] += size_res_targets[:, 2]\n    dist = torch.norm(aggregated_points - top_center_targets, dim=1)\n    dist_mask = dist < self.train_cfg.pos_distance_thr\n    positive_mask = (points_mask.max(1)[0] > 0) * dist_mask\n    negative_mask = points_mask.max(1)[0] == 0\n    canonical_xyz = aggregated_points - center_targets\n    if self.bbox_coder.with_rot:\n        canonical_xyz = rotation_3d_in_axis(canonical_xyz.unsqueeze(0).transpose(0, 1), -gt_bboxes_3d.yaw[assignment], axis=2).squeeze(1)\n    distance_front = torch.clamp(size_res_targets[:, 0] - canonical_xyz[:, 0], min=0)\n    distance_back = torch.clamp(size_res_targets[:, 0] + canonical_xyz[:, 0], min=0)\n    distance_left = torch.clamp(size_res_targets[:, 1] - canonical_xyz[:, 1], min=0)\n    distance_right = torch.clamp(size_res_targets[:, 1] + canonical_xyz[:, 1], min=0)\n    distance_top = torch.clamp(size_res_targets[:, 2] - canonical_xyz[:, 2], min=0)\n    distance_bottom = torch.clamp(size_res_targets[:, 2] + canonical_xyz[:, 2], min=0)\n    centerness_l = torch.min(distance_front, distance_back) / torch.max(distance_front, distance_back)\n    centerness_w = torch.min(distance_left, distance_right) / torch.max(distance_left, distance_right)\n    centerness_h = torch.min(distance_bottom, distance_top) / torch.max(distance_bottom, distance_top)\n    centerness_targets = torch.clamp(centerness_l * centerness_w * centerness_h, min=0)\n    centerness_targets = centerness_targets.pow(1 / 3.0)\n    centerness_targets = torch.clamp(centerness_targets, min=0, max=1)\n    proposal_num = centerness_targets.shape[0]\n    one_hot_centerness_targets = centerness_targets.new_zeros((proposal_num, self.num_classes))\n    one_hot_centerness_targets.scatter_(1, mask_targets.unsqueeze(-1), 1)\n    centerness_targets = centerness_targets.unsqueeze(1) * one_hot_centerness_targets\n    enlarged_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.train_cfg.expand_dims_length)\n    enlarged_gt_bboxes_3d.tensor[:, 2] -= self.train_cfg.expand_dims_length\n    (vote_mask, vote_assignment) = self._assign_targets_by_points_inside(enlarged_gt_bboxes_3d, seed_points)\n    vote_targets = gt_bboxes_3d.gravity_center\n    vote_targets = vote_targets[vote_assignment] - seed_points\n    vote_mask = vote_mask.max(1)[0] > 0\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, aggregated_points=None, seed_points=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate targets of ssd3d head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n            aggregated_points (torch.Tensor): Aggregated points from\\n                candidate points layer.\\n            seed_points (torch.Tensor): Seed points of candidate points.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    assert self.bbox_coder.with_rot or pts_semantic_mask is not None\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    if valid_gt.sum() == 0:\n        vote_targets = points.new_zeros(self.num_candidates, 3)\n        center_targets = points.new_zeros(self.num_candidates, 3)\n        size_res_targets = points.new_zeros(self.num_candidates, 3)\n        dir_class_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        dir_res_targets = points.new_zeros(self.num_candidates)\n        mask_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        centerness_targets = points.new_zeros(self.num_candidates, self.num_classes)\n        corner3d_targets = points.new_zeros(self.num_candidates, 8, 3)\n        vote_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        positive_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        negative_mask = points.new_ones(self.num_candidates, dtype=torch.bool)\n        return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)\n    gt_corner3d = gt_bboxes_3d.corners\n    (center_targets, size_targets, dir_class_targets, dir_res_targets) = self.bbox_coder.encode(gt_bboxes_3d, gt_labels_3d)\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, aggregated_points)\n    center_targets = center_targets[assignment]\n    size_res_targets = size_targets[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    dir_class_targets = dir_class_targets[assignment]\n    dir_res_targets = dir_res_targets[assignment]\n    corner3d_targets = gt_corner3d[assignment]\n    top_center_targets = center_targets.clone()\n    top_center_targets[:, 2] += size_res_targets[:, 2]\n    dist = torch.norm(aggregated_points - top_center_targets, dim=1)\n    dist_mask = dist < self.train_cfg.pos_distance_thr\n    positive_mask = (points_mask.max(1)[0] > 0) * dist_mask\n    negative_mask = points_mask.max(1)[0] == 0\n    canonical_xyz = aggregated_points - center_targets\n    if self.bbox_coder.with_rot:\n        canonical_xyz = rotation_3d_in_axis(canonical_xyz.unsqueeze(0).transpose(0, 1), -gt_bboxes_3d.yaw[assignment], axis=2).squeeze(1)\n    distance_front = torch.clamp(size_res_targets[:, 0] - canonical_xyz[:, 0], min=0)\n    distance_back = torch.clamp(size_res_targets[:, 0] + canonical_xyz[:, 0], min=0)\n    distance_left = torch.clamp(size_res_targets[:, 1] - canonical_xyz[:, 1], min=0)\n    distance_right = torch.clamp(size_res_targets[:, 1] + canonical_xyz[:, 1], min=0)\n    distance_top = torch.clamp(size_res_targets[:, 2] - canonical_xyz[:, 2], min=0)\n    distance_bottom = torch.clamp(size_res_targets[:, 2] + canonical_xyz[:, 2], min=0)\n    centerness_l = torch.min(distance_front, distance_back) / torch.max(distance_front, distance_back)\n    centerness_w = torch.min(distance_left, distance_right) / torch.max(distance_left, distance_right)\n    centerness_h = torch.min(distance_bottom, distance_top) / torch.max(distance_bottom, distance_top)\n    centerness_targets = torch.clamp(centerness_l * centerness_w * centerness_h, min=0)\n    centerness_targets = centerness_targets.pow(1 / 3.0)\n    centerness_targets = torch.clamp(centerness_targets, min=0, max=1)\n    proposal_num = centerness_targets.shape[0]\n    one_hot_centerness_targets = centerness_targets.new_zeros((proposal_num, self.num_classes))\n    one_hot_centerness_targets.scatter_(1, mask_targets.unsqueeze(-1), 1)\n    centerness_targets = centerness_targets.unsqueeze(1) * one_hot_centerness_targets\n    enlarged_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.train_cfg.expand_dims_length)\n    enlarged_gt_bboxes_3d.tensor[:, 2] -= self.train_cfg.expand_dims_length\n    (vote_mask, vote_assignment) = self._assign_targets_by_points_inside(enlarged_gt_bboxes_3d, seed_points)\n    vote_targets = gt_bboxes_3d.gravity_center\n    vote_targets = vote_targets[vote_assignment] - seed_points\n    vote_mask = vote_mask.max(1)[0] > 0\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, aggregated_points=None, seed_points=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate targets of ssd3d head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n            aggregated_points (torch.Tensor): Aggregated points from\\n                candidate points layer.\\n            seed_points (torch.Tensor): Seed points of candidate points.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of ssd3d head.\\n        '\n    assert self.bbox_coder.with_rot or pts_semantic_mask is not None\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    valid_gt = gt_labels_3d != -1\n    gt_bboxes_3d = gt_bboxes_3d[valid_gt]\n    gt_labels_3d = gt_labels_3d[valid_gt]\n    if valid_gt.sum() == 0:\n        vote_targets = points.new_zeros(self.num_candidates, 3)\n        center_targets = points.new_zeros(self.num_candidates, 3)\n        size_res_targets = points.new_zeros(self.num_candidates, 3)\n        dir_class_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        dir_res_targets = points.new_zeros(self.num_candidates)\n        mask_targets = points.new_zeros(self.num_candidates, dtype=torch.int64)\n        centerness_targets = points.new_zeros(self.num_candidates, self.num_classes)\n        corner3d_targets = points.new_zeros(self.num_candidates, 8, 3)\n        vote_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        positive_mask = points.new_zeros(self.num_candidates, dtype=torch.bool)\n        negative_mask = points.new_ones(self.num_candidates, dtype=torch.bool)\n        return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)\n    gt_corner3d = gt_bboxes_3d.corners\n    (center_targets, size_targets, dir_class_targets, dir_res_targets) = self.bbox_coder.encode(gt_bboxes_3d, gt_labels_3d)\n    (points_mask, assignment) = self._assign_targets_by_points_inside(gt_bboxes_3d, aggregated_points)\n    center_targets = center_targets[assignment]\n    size_res_targets = size_targets[assignment]\n    mask_targets = gt_labels_3d[assignment]\n    dir_class_targets = dir_class_targets[assignment]\n    dir_res_targets = dir_res_targets[assignment]\n    corner3d_targets = gt_corner3d[assignment]\n    top_center_targets = center_targets.clone()\n    top_center_targets[:, 2] += size_res_targets[:, 2]\n    dist = torch.norm(aggregated_points - top_center_targets, dim=1)\n    dist_mask = dist < self.train_cfg.pos_distance_thr\n    positive_mask = (points_mask.max(1)[0] > 0) * dist_mask\n    negative_mask = points_mask.max(1)[0] == 0\n    canonical_xyz = aggregated_points - center_targets\n    if self.bbox_coder.with_rot:\n        canonical_xyz = rotation_3d_in_axis(canonical_xyz.unsqueeze(0).transpose(0, 1), -gt_bboxes_3d.yaw[assignment], axis=2).squeeze(1)\n    distance_front = torch.clamp(size_res_targets[:, 0] - canonical_xyz[:, 0], min=0)\n    distance_back = torch.clamp(size_res_targets[:, 0] + canonical_xyz[:, 0], min=0)\n    distance_left = torch.clamp(size_res_targets[:, 1] - canonical_xyz[:, 1], min=0)\n    distance_right = torch.clamp(size_res_targets[:, 1] + canonical_xyz[:, 1], min=0)\n    distance_top = torch.clamp(size_res_targets[:, 2] - canonical_xyz[:, 2], min=0)\n    distance_bottom = torch.clamp(size_res_targets[:, 2] + canonical_xyz[:, 2], min=0)\n    centerness_l = torch.min(distance_front, distance_back) / torch.max(distance_front, distance_back)\n    centerness_w = torch.min(distance_left, distance_right) / torch.max(distance_left, distance_right)\n    centerness_h = torch.min(distance_bottom, distance_top) / torch.max(distance_bottom, distance_top)\n    centerness_targets = torch.clamp(centerness_l * centerness_w * centerness_h, min=0)\n    centerness_targets = centerness_targets.pow(1 / 3.0)\n    centerness_targets = torch.clamp(centerness_targets, min=0, max=1)\n    proposal_num = centerness_targets.shape[0]\n    one_hot_centerness_targets = centerness_targets.new_zeros((proposal_num, self.num_classes))\n    one_hot_centerness_targets.scatter_(1, mask_targets.unsqueeze(-1), 1)\n    centerness_targets = centerness_targets.unsqueeze(1) * one_hot_centerness_targets\n    enlarged_gt_bboxes_3d = gt_bboxes_3d.enlarged_box(self.train_cfg.expand_dims_length)\n    enlarged_gt_bboxes_3d.tensor[:, 2] -= self.train_cfg.expand_dims_length\n    (vote_mask, vote_assignment) = self._assign_targets_by_points_inside(enlarged_gt_bboxes_3d, seed_points)\n    vote_targets = gt_bboxes_3d.gravity_center\n    vote_targets = vote_targets[vote_assignment] - seed_points\n    vote_mask = vote_mask.max(1)[0] > 0\n    return (vote_targets, center_targets, size_res_targets, dir_class_targets, dir_res_targets, mask_targets, centerness_targets, corner3d_targets, vote_mask, positive_mask, negative_mask)"
        ]
    },
    {
        "func_name": "get_bboxes",
        "original": "def get_bboxes(self, points, bbox_preds, input_metas, rescale=False):\n    \"\"\"Generate bboxes from 3DSSD head predictions.\n\n        Args:\n            points (torch.Tensor): Input points.\n            bbox_preds (dict): Predictions from sdd3d head.\n            input_metas (list[dict]): Point cloud and image's meta info.\n            rescale (bool): Whether to rescale bboxes.\n\n        Returns:\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\n        \"\"\"\n    sem_scores = F.sigmoid(bbox_preds['obj_scores']).transpose(1, 2)\n    obj_scores = sem_scores.max(-1)[0]\n    bbox3d = self.bbox_coder.decode(bbox_preds)\n    batch_size = bbox3d.shape[0]\n    results = list()\n    for b in range(batch_size):\n        (bbox_selected, score_selected, labels) = self.multiclass_nms_single(obj_scores[b], sem_scores[b], bbox3d[b], points[b, ..., :3], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=self.bbox_coder.with_rot)\n        results.append((bbox, score_selected, labels))\n    return results",
        "mutated": [
            "def get_bboxes(self, points, bbox_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n    \"Generate bboxes from 3DSSD head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Predictions from sdd3d head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool): Whether to rescale bboxes.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = F.sigmoid(bbox_preds['obj_scores']).transpose(1, 2)\n    obj_scores = sem_scores.max(-1)[0]\n    bbox3d = self.bbox_coder.decode(bbox_preds)\n    batch_size = bbox3d.shape[0]\n    results = list()\n    for b in range(batch_size):\n        (bbox_selected, score_selected, labels) = self.multiclass_nms_single(obj_scores[b], sem_scores[b], bbox3d[b], points[b, ..., :3], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=self.bbox_coder.with_rot)\n        results.append((bbox, score_selected, labels))\n    return results",
            "def get_bboxes(self, points, bbox_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Generate bboxes from 3DSSD head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Predictions from sdd3d head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool): Whether to rescale bboxes.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = F.sigmoid(bbox_preds['obj_scores']).transpose(1, 2)\n    obj_scores = sem_scores.max(-1)[0]\n    bbox3d = self.bbox_coder.decode(bbox_preds)\n    batch_size = bbox3d.shape[0]\n    results = list()\n    for b in range(batch_size):\n        (bbox_selected, score_selected, labels) = self.multiclass_nms_single(obj_scores[b], sem_scores[b], bbox3d[b], points[b, ..., :3], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=self.bbox_coder.with_rot)\n        results.append((bbox, score_selected, labels))\n    return results",
            "def get_bboxes(self, points, bbox_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Generate bboxes from 3DSSD head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Predictions from sdd3d head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool): Whether to rescale bboxes.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = F.sigmoid(bbox_preds['obj_scores']).transpose(1, 2)\n    obj_scores = sem_scores.max(-1)[0]\n    bbox3d = self.bbox_coder.decode(bbox_preds)\n    batch_size = bbox3d.shape[0]\n    results = list()\n    for b in range(batch_size):\n        (bbox_selected, score_selected, labels) = self.multiclass_nms_single(obj_scores[b], sem_scores[b], bbox3d[b], points[b, ..., :3], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=self.bbox_coder.with_rot)\n        results.append((bbox, score_selected, labels))\n    return results",
            "def get_bboxes(self, points, bbox_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Generate bboxes from 3DSSD head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Predictions from sdd3d head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool): Whether to rescale bboxes.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = F.sigmoid(bbox_preds['obj_scores']).transpose(1, 2)\n    obj_scores = sem_scores.max(-1)[0]\n    bbox3d = self.bbox_coder.decode(bbox_preds)\n    batch_size = bbox3d.shape[0]\n    results = list()\n    for b in range(batch_size):\n        (bbox_selected, score_selected, labels) = self.multiclass_nms_single(obj_scores[b], sem_scores[b], bbox3d[b], points[b, ..., :3], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=self.bbox_coder.with_rot)\n        results.append((bbox, score_selected, labels))\n    return results",
            "def get_bboxes(self, points, bbox_preds, input_metas, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Generate bboxes from 3DSSD head predictions.\\n\\n        Args:\\n            points (torch.Tensor): Input points.\\n            bbox_preds (dict): Predictions from sdd3d head.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            rescale (bool): Whether to rescale bboxes.\\n\\n        Returns:\\n            list[tuple[torch.Tensor]]: Bounding boxes, scores and labels.\\n        \"\n    sem_scores = F.sigmoid(bbox_preds['obj_scores']).transpose(1, 2)\n    obj_scores = sem_scores.max(-1)[0]\n    bbox3d = self.bbox_coder.decode(bbox_preds)\n    batch_size = bbox3d.shape[0]\n    results = list()\n    for b in range(batch_size):\n        (bbox_selected, score_selected, labels) = self.multiclass_nms_single(obj_scores[b], sem_scores[b], bbox3d[b], points[b, ..., :3], input_metas[b])\n        bbox = input_metas[b]['box_type_3d'](bbox_selected.clone(), box_dim=bbox_selected.shape[-1], with_yaw=self.bbox_coder.with_rot)\n        results.append((bbox, score_selected, labels))\n    return results"
        ]
    },
    {
        "func_name": "multiclass_nms_single",
        "original": "def multiclass_nms_single(self, obj_scores, sem_scores, bbox, points, input_meta):\n    \"\"\"Multi-class nms in single batch.\n\n        Args:\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\n            bbox (torch.Tensor): Predicted bounding boxes.\n            points (torch.Tensor): Input points.\n            input_meta (dict): Point cloud and image's meta info.\n\n        Returns:\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\n        \"\"\"\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        box_indices = bbox.points_in_boxes_all(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    corner3d = bbox.corners\n    minmax_box3d = corner3d.new(torch.Size((corner3d.shape[0], 6)))\n    minmax_box3d[:, :3] = torch.min(corner3d, dim=1)[0]\n    minmax_box3d[:, 3:] = torch.max(corner3d, dim=1)[0]\n    bbox_classes = torch.argmax(sem_scores, -1)\n    nms_keep = batched_nms(minmax_box3d[nonempty_box_mask][:, [0, 1, 3, 4]], obj_scores[nonempty_box_mask], bbox_classes[nonempty_box_mask], self.test_cfg.nms_cfg)[1]\n    if nms_keep.shape[0] > self.test_cfg.max_output_num:\n        nms_keep = nms_keep[:self.test_cfg.max_output_num]\n    scores_mask = obj_scores >= self.test_cfg.score_thr\n    nonempty_box_inds = torch.nonzero(nonempty_box_mask, as_tuple=False).flatten()\n    nonempty_mask = torch.zeros_like(bbox_classes).scatter(0, nonempty_box_inds[nms_keep], 1)\n    selected = nonempty_mask.bool() & scores_mask.bool()\n    if self.test_cfg.per_class_proposal:\n        (bbox_selected, score_selected, labels) = ([], [], [])\n        for k in range(sem_scores.shape[-1]):\n            bbox_selected.append(bbox[selected].tensor)\n            score_selected.append(obj_scores[selected])\n            labels.append(torch.zeros_like(bbox_classes[selected]).fill_(k))\n        bbox_selected = torch.cat(bbox_selected, 0)\n        score_selected = torch.cat(score_selected, 0)\n        labels = torch.cat(labels, 0)\n    else:\n        bbox_selected = bbox[selected].tensor\n        score_selected = obj_scores[selected]\n        labels = bbox_classes[selected]\n    return (bbox_selected, score_selected, labels)",
        "mutated": [
            "def multiclass_nms_single(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n    \"Multi-class nms in single batch.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n            points (torch.Tensor): Input points.\\n            input_meta (dict): Point cloud and image's meta info.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        \"\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        box_indices = bbox.points_in_boxes_all(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    corner3d = bbox.corners\n    minmax_box3d = corner3d.new(torch.Size((corner3d.shape[0], 6)))\n    minmax_box3d[:, :3] = torch.min(corner3d, dim=1)[0]\n    minmax_box3d[:, 3:] = torch.max(corner3d, dim=1)[0]\n    bbox_classes = torch.argmax(sem_scores, -1)\n    nms_keep = batched_nms(minmax_box3d[nonempty_box_mask][:, [0, 1, 3, 4]], obj_scores[nonempty_box_mask], bbox_classes[nonempty_box_mask], self.test_cfg.nms_cfg)[1]\n    if nms_keep.shape[0] > self.test_cfg.max_output_num:\n        nms_keep = nms_keep[:self.test_cfg.max_output_num]\n    scores_mask = obj_scores >= self.test_cfg.score_thr\n    nonempty_box_inds = torch.nonzero(nonempty_box_mask, as_tuple=False).flatten()\n    nonempty_mask = torch.zeros_like(bbox_classes).scatter(0, nonempty_box_inds[nms_keep], 1)\n    selected = nonempty_mask.bool() & scores_mask.bool()\n    if self.test_cfg.per_class_proposal:\n        (bbox_selected, score_selected, labels) = ([], [], [])\n        for k in range(sem_scores.shape[-1]):\n            bbox_selected.append(bbox[selected].tensor)\n            score_selected.append(obj_scores[selected])\n            labels.append(torch.zeros_like(bbox_classes[selected]).fill_(k))\n        bbox_selected = torch.cat(bbox_selected, 0)\n        score_selected = torch.cat(score_selected, 0)\n        labels = torch.cat(labels, 0)\n    else:\n        bbox_selected = bbox[selected].tensor\n        score_selected = obj_scores[selected]\n        labels = bbox_classes[selected]\n    return (bbox_selected, score_selected, labels)",
            "def multiclass_nms_single(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Multi-class nms in single batch.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n            points (torch.Tensor): Input points.\\n            input_meta (dict): Point cloud and image's meta info.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        \"\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        box_indices = bbox.points_in_boxes_all(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    corner3d = bbox.corners\n    minmax_box3d = corner3d.new(torch.Size((corner3d.shape[0], 6)))\n    minmax_box3d[:, :3] = torch.min(corner3d, dim=1)[0]\n    minmax_box3d[:, 3:] = torch.max(corner3d, dim=1)[0]\n    bbox_classes = torch.argmax(sem_scores, -1)\n    nms_keep = batched_nms(minmax_box3d[nonempty_box_mask][:, [0, 1, 3, 4]], obj_scores[nonempty_box_mask], bbox_classes[nonempty_box_mask], self.test_cfg.nms_cfg)[1]\n    if nms_keep.shape[0] > self.test_cfg.max_output_num:\n        nms_keep = nms_keep[:self.test_cfg.max_output_num]\n    scores_mask = obj_scores >= self.test_cfg.score_thr\n    nonempty_box_inds = torch.nonzero(nonempty_box_mask, as_tuple=False).flatten()\n    nonempty_mask = torch.zeros_like(bbox_classes).scatter(0, nonempty_box_inds[nms_keep], 1)\n    selected = nonempty_mask.bool() & scores_mask.bool()\n    if self.test_cfg.per_class_proposal:\n        (bbox_selected, score_selected, labels) = ([], [], [])\n        for k in range(sem_scores.shape[-1]):\n            bbox_selected.append(bbox[selected].tensor)\n            score_selected.append(obj_scores[selected])\n            labels.append(torch.zeros_like(bbox_classes[selected]).fill_(k))\n        bbox_selected = torch.cat(bbox_selected, 0)\n        score_selected = torch.cat(score_selected, 0)\n        labels = torch.cat(labels, 0)\n    else:\n        bbox_selected = bbox[selected].tensor\n        score_selected = obj_scores[selected]\n        labels = bbox_classes[selected]\n    return (bbox_selected, score_selected, labels)",
            "def multiclass_nms_single(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Multi-class nms in single batch.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n            points (torch.Tensor): Input points.\\n            input_meta (dict): Point cloud and image's meta info.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        \"\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        box_indices = bbox.points_in_boxes_all(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    corner3d = bbox.corners\n    minmax_box3d = corner3d.new(torch.Size((corner3d.shape[0], 6)))\n    minmax_box3d[:, :3] = torch.min(corner3d, dim=1)[0]\n    minmax_box3d[:, 3:] = torch.max(corner3d, dim=1)[0]\n    bbox_classes = torch.argmax(sem_scores, -1)\n    nms_keep = batched_nms(minmax_box3d[nonempty_box_mask][:, [0, 1, 3, 4]], obj_scores[nonempty_box_mask], bbox_classes[nonempty_box_mask], self.test_cfg.nms_cfg)[1]\n    if nms_keep.shape[0] > self.test_cfg.max_output_num:\n        nms_keep = nms_keep[:self.test_cfg.max_output_num]\n    scores_mask = obj_scores >= self.test_cfg.score_thr\n    nonempty_box_inds = torch.nonzero(nonempty_box_mask, as_tuple=False).flatten()\n    nonempty_mask = torch.zeros_like(bbox_classes).scatter(0, nonempty_box_inds[nms_keep], 1)\n    selected = nonempty_mask.bool() & scores_mask.bool()\n    if self.test_cfg.per_class_proposal:\n        (bbox_selected, score_selected, labels) = ([], [], [])\n        for k in range(sem_scores.shape[-1]):\n            bbox_selected.append(bbox[selected].tensor)\n            score_selected.append(obj_scores[selected])\n            labels.append(torch.zeros_like(bbox_classes[selected]).fill_(k))\n        bbox_selected = torch.cat(bbox_selected, 0)\n        score_selected = torch.cat(score_selected, 0)\n        labels = torch.cat(labels, 0)\n    else:\n        bbox_selected = bbox[selected].tensor\n        score_selected = obj_scores[selected]\n        labels = bbox_classes[selected]\n    return (bbox_selected, score_selected, labels)",
            "def multiclass_nms_single(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Multi-class nms in single batch.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n            points (torch.Tensor): Input points.\\n            input_meta (dict): Point cloud and image's meta info.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        \"\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        box_indices = bbox.points_in_boxes_all(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    corner3d = bbox.corners\n    minmax_box3d = corner3d.new(torch.Size((corner3d.shape[0], 6)))\n    minmax_box3d[:, :3] = torch.min(corner3d, dim=1)[0]\n    minmax_box3d[:, 3:] = torch.max(corner3d, dim=1)[0]\n    bbox_classes = torch.argmax(sem_scores, -1)\n    nms_keep = batched_nms(minmax_box3d[nonempty_box_mask][:, [0, 1, 3, 4]], obj_scores[nonempty_box_mask], bbox_classes[nonempty_box_mask], self.test_cfg.nms_cfg)[1]\n    if nms_keep.shape[0] > self.test_cfg.max_output_num:\n        nms_keep = nms_keep[:self.test_cfg.max_output_num]\n    scores_mask = obj_scores >= self.test_cfg.score_thr\n    nonempty_box_inds = torch.nonzero(nonempty_box_mask, as_tuple=False).flatten()\n    nonempty_mask = torch.zeros_like(bbox_classes).scatter(0, nonempty_box_inds[nms_keep], 1)\n    selected = nonempty_mask.bool() & scores_mask.bool()\n    if self.test_cfg.per_class_proposal:\n        (bbox_selected, score_selected, labels) = ([], [], [])\n        for k in range(sem_scores.shape[-1]):\n            bbox_selected.append(bbox[selected].tensor)\n            score_selected.append(obj_scores[selected])\n            labels.append(torch.zeros_like(bbox_classes[selected]).fill_(k))\n        bbox_selected = torch.cat(bbox_selected, 0)\n        score_selected = torch.cat(score_selected, 0)\n        labels = torch.cat(labels, 0)\n    else:\n        bbox_selected = bbox[selected].tensor\n        score_selected = obj_scores[selected]\n        labels = bbox_classes[selected]\n    return (bbox_selected, score_selected, labels)",
            "def multiclass_nms_single(self, obj_scores, sem_scores, bbox, points, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Multi-class nms in single batch.\\n\\n        Args:\\n            obj_scores (torch.Tensor): Objectness score of bounding boxes.\\n            sem_scores (torch.Tensor): Semantic class score of bounding boxes.\\n            bbox (torch.Tensor): Predicted bounding boxes.\\n            points (torch.Tensor): Input points.\\n            input_meta (dict): Point cloud and image's meta info.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Bounding boxes, scores and labels.\\n        \"\n    bbox = input_meta['box_type_3d'](bbox.clone(), box_dim=bbox.shape[-1], with_yaw=self.bbox_coder.with_rot, origin=(0.5, 0.5, 0.5))\n    if isinstance(bbox, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        box_indices = bbox.points_in_boxes_all(points)\n        nonempty_box_mask = box_indices.T.sum(1) >= 0\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    corner3d = bbox.corners\n    minmax_box3d = corner3d.new(torch.Size((corner3d.shape[0], 6)))\n    minmax_box3d[:, :3] = torch.min(corner3d, dim=1)[0]\n    minmax_box3d[:, 3:] = torch.max(corner3d, dim=1)[0]\n    bbox_classes = torch.argmax(sem_scores, -1)\n    nms_keep = batched_nms(minmax_box3d[nonempty_box_mask][:, [0, 1, 3, 4]], obj_scores[nonempty_box_mask], bbox_classes[nonempty_box_mask], self.test_cfg.nms_cfg)[1]\n    if nms_keep.shape[0] > self.test_cfg.max_output_num:\n        nms_keep = nms_keep[:self.test_cfg.max_output_num]\n    scores_mask = obj_scores >= self.test_cfg.score_thr\n    nonempty_box_inds = torch.nonzero(nonempty_box_mask, as_tuple=False).flatten()\n    nonempty_mask = torch.zeros_like(bbox_classes).scatter(0, nonempty_box_inds[nms_keep], 1)\n    selected = nonempty_mask.bool() & scores_mask.bool()\n    if self.test_cfg.per_class_proposal:\n        (bbox_selected, score_selected, labels) = ([], [], [])\n        for k in range(sem_scores.shape[-1]):\n            bbox_selected.append(bbox[selected].tensor)\n            score_selected.append(obj_scores[selected])\n            labels.append(torch.zeros_like(bbox_classes[selected]).fill_(k))\n        bbox_selected = torch.cat(bbox_selected, 0)\n        score_selected = torch.cat(score_selected, 0)\n        labels = torch.cat(labels, 0)\n    else:\n        bbox_selected = bbox[selected].tensor\n        score_selected = obj_scores[selected]\n        labels = bbox_classes[selected]\n    return (bbox_selected, score_selected, labels)"
        ]
    },
    {
        "func_name": "_assign_targets_by_points_inside",
        "original": "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    \"\"\"Compute assignment by checking whether point is inside bbox.\n\n        Args:\n            bboxes_3d (BaseInstance3DBoxes): Instance of bounding boxes.\n            points (torch.Tensor): Points of a batch.\n\n        Returns:\n            tuple[torch.Tensor]: Flags indicating whether each point is\n                inside bbox and the index of box where each point are in.\n        \"\"\"\n    if isinstance(bboxes_3d, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        points_mask = bboxes_3d.points_in_boxes_all(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
        "mutated": [
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (BaseInstance3DBoxes): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    if isinstance(bboxes_3d, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        points_mask = bboxes_3d.points_in_boxes_all(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (BaseInstance3DBoxes): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    if isinstance(bboxes_3d, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        points_mask = bboxes_3d.points_in_boxes_all(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (BaseInstance3DBoxes): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    if isinstance(bboxes_3d, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        points_mask = bboxes_3d.points_in_boxes_all(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (BaseInstance3DBoxes): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    if isinstance(bboxes_3d, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        points_mask = bboxes_3d.points_in_boxes_all(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)",
            "def _assign_targets_by_points_inside(self, bboxes_3d, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute assignment by checking whether point is inside bbox.\\n\\n        Args:\\n            bboxes_3d (BaseInstance3DBoxes): Instance of bounding boxes.\\n            points (torch.Tensor): Points of a batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Flags indicating whether each point is\\n                inside bbox and the index of box where each point are in.\\n        '\n    if isinstance(bboxes_3d, (LiDARInstance3DBoxes, DepthInstance3DBoxes)):\n        points_mask = bboxes_3d.points_in_boxes_all(points)\n        assignment = points_mask.argmax(dim=-1)\n    else:\n        raise NotImplementedError('Unsupported bbox type!')\n    return (points_mask, assignment)"
        ]
    }
]