[
    {
        "func_name": "tilt_projection",
        "original": "def tilt_projection(taux: torch.Tensor, tauy: torch.Tensor, return_inverse: bool=False) -> torch.Tensor:\n    \"\"\"Estimate the tilt projection matrix or the inverse tilt projection matrix.\n\n    Args:\n        taux: Rotation angle in radians around the :math:`x`-axis with shape :math:`(*, 1)`.\n        tauy: Rotation angle in radians around the :math:`y`-axis with shape :math:`(*, 1)`.\n        return_inverse: False to obtain the the tilt projection matrix. True for the inverse matrix.\n\n    Returns:\n        torch.Tensor: Inverse tilt projection matrix with shape :math:`(*, 3, 3)`.\n    \"\"\"\n    if taux.shape != tauy.shape:\n        raise ValueError(f'Shape of taux {taux.shape} and tauy {tauy.shape} do not match.')\n    ndim: int = taux.dim()\n    taux = taux.reshape(-1)\n    tauy = tauy.reshape(-1)\n    cTx = torch.cos(taux)\n    sTx = torch.sin(taux)\n    cTy = torch.cos(tauy)\n    sTy = torch.sin(tauy)\n    zero = torch.zeros_like(cTx)\n    one = torch.ones_like(cTx)\n    Rx = torch.stack([one, zero, zero, zero, cTx, sTx, zero, -sTx, cTx], -1).reshape(-1, 3, 3)\n    Ry = torch.stack([cTy, zero, -sTy, zero, one, zero, sTy, zero, cTy], -1).reshape(-1, 3, 3)\n    R = Ry @ Rx\n    if return_inverse:\n        invR22 = 1 / R[..., 2, 2]\n        invPz = torch.stack([invR22, zero, R[..., 0, 2] * invR22, zero, invR22, R[..., 1, 2] * invR22, zero, zero, one], -1).reshape(-1, 3, 3)\n        inv_tilt = R.transpose(-1, -2) @ invPz\n        if ndim == 0:\n            inv_tilt = torch.squeeze(inv_tilt)\n        return inv_tilt\n    Pz = torch.stack([R[..., 2, 2], zero, -R[..., 0, 2], zero, R[..., 2, 2], -R[..., 1, 2], zero, zero, one], -1).reshape(-1, 3, 3)\n    tilt = Pz @ R.transpose(-1, -2)\n    if ndim == 0:\n        tilt = torch.squeeze(tilt)\n    return tilt",
        "mutated": [
            "def tilt_projection(taux: torch.Tensor, tauy: torch.Tensor, return_inverse: bool=False) -> torch.Tensor:\n    if False:\n        i = 10\n    'Estimate the tilt projection matrix or the inverse tilt projection matrix.\\n\\n    Args:\\n        taux: Rotation angle in radians around the :math:`x`-axis with shape :math:`(*, 1)`.\\n        tauy: Rotation angle in radians around the :math:`y`-axis with shape :math:`(*, 1)`.\\n        return_inverse: False to obtain the the tilt projection matrix. True for the inverse matrix.\\n\\n    Returns:\\n        torch.Tensor: Inverse tilt projection matrix with shape :math:`(*, 3, 3)`.\\n    '\n    if taux.shape != tauy.shape:\n        raise ValueError(f'Shape of taux {taux.shape} and tauy {tauy.shape} do not match.')\n    ndim: int = taux.dim()\n    taux = taux.reshape(-1)\n    tauy = tauy.reshape(-1)\n    cTx = torch.cos(taux)\n    sTx = torch.sin(taux)\n    cTy = torch.cos(tauy)\n    sTy = torch.sin(tauy)\n    zero = torch.zeros_like(cTx)\n    one = torch.ones_like(cTx)\n    Rx = torch.stack([one, zero, zero, zero, cTx, sTx, zero, -sTx, cTx], -1).reshape(-1, 3, 3)\n    Ry = torch.stack([cTy, zero, -sTy, zero, one, zero, sTy, zero, cTy], -1).reshape(-1, 3, 3)\n    R = Ry @ Rx\n    if return_inverse:\n        invR22 = 1 / R[..., 2, 2]\n        invPz = torch.stack([invR22, zero, R[..., 0, 2] * invR22, zero, invR22, R[..., 1, 2] * invR22, zero, zero, one], -1).reshape(-1, 3, 3)\n        inv_tilt = R.transpose(-1, -2) @ invPz\n        if ndim == 0:\n            inv_tilt = torch.squeeze(inv_tilt)\n        return inv_tilt\n    Pz = torch.stack([R[..., 2, 2], zero, -R[..., 0, 2], zero, R[..., 2, 2], -R[..., 1, 2], zero, zero, one], -1).reshape(-1, 3, 3)\n    tilt = Pz @ R.transpose(-1, -2)\n    if ndim == 0:\n        tilt = torch.squeeze(tilt)\n    return tilt",
            "def tilt_projection(taux: torch.Tensor, tauy: torch.Tensor, return_inverse: bool=False) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Estimate the tilt projection matrix or the inverse tilt projection matrix.\\n\\n    Args:\\n        taux: Rotation angle in radians around the :math:`x`-axis with shape :math:`(*, 1)`.\\n        tauy: Rotation angle in radians around the :math:`y`-axis with shape :math:`(*, 1)`.\\n        return_inverse: False to obtain the the tilt projection matrix. True for the inverse matrix.\\n\\n    Returns:\\n        torch.Tensor: Inverse tilt projection matrix with shape :math:`(*, 3, 3)`.\\n    '\n    if taux.shape != tauy.shape:\n        raise ValueError(f'Shape of taux {taux.shape} and tauy {tauy.shape} do not match.')\n    ndim: int = taux.dim()\n    taux = taux.reshape(-1)\n    tauy = tauy.reshape(-1)\n    cTx = torch.cos(taux)\n    sTx = torch.sin(taux)\n    cTy = torch.cos(tauy)\n    sTy = torch.sin(tauy)\n    zero = torch.zeros_like(cTx)\n    one = torch.ones_like(cTx)\n    Rx = torch.stack([one, zero, zero, zero, cTx, sTx, zero, -sTx, cTx], -1).reshape(-1, 3, 3)\n    Ry = torch.stack([cTy, zero, -sTy, zero, one, zero, sTy, zero, cTy], -1).reshape(-1, 3, 3)\n    R = Ry @ Rx\n    if return_inverse:\n        invR22 = 1 / R[..., 2, 2]\n        invPz = torch.stack([invR22, zero, R[..., 0, 2] * invR22, zero, invR22, R[..., 1, 2] * invR22, zero, zero, one], -1).reshape(-1, 3, 3)\n        inv_tilt = R.transpose(-1, -2) @ invPz\n        if ndim == 0:\n            inv_tilt = torch.squeeze(inv_tilt)\n        return inv_tilt\n    Pz = torch.stack([R[..., 2, 2], zero, -R[..., 0, 2], zero, R[..., 2, 2], -R[..., 1, 2], zero, zero, one], -1).reshape(-1, 3, 3)\n    tilt = Pz @ R.transpose(-1, -2)\n    if ndim == 0:\n        tilt = torch.squeeze(tilt)\n    return tilt",
            "def tilt_projection(taux: torch.Tensor, tauy: torch.Tensor, return_inverse: bool=False) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Estimate the tilt projection matrix or the inverse tilt projection matrix.\\n\\n    Args:\\n        taux: Rotation angle in radians around the :math:`x`-axis with shape :math:`(*, 1)`.\\n        tauy: Rotation angle in radians around the :math:`y`-axis with shape :math:`(*, 1)`.\\n        return_inverse: False to obtain the the tilt projection matrix. True for the inverse matrix.\\n\\n    Returns:\\n        torch.Tensor: Inverse tilt projection matrix with shape :math:`(*, 3, 3)`.\\n    '\n    if taux.shape != tauy.shape:\n        raise ValueError(f'Shape of taux {taux.shape} and tauy {tauy.shape} do not match.')\n    ndim: int = taux.dim()\n    taux = taux.reshape(-1)\n    tauy = tauy.reshape(-1)\n    cTx = torch.cos(taux)\n    sTx = torch.sin(taux)\n    cTy = torch.cos(tauy)\n    sTy = torch.sin(tauy)\n    zero = torch.zeros_like(cTx)\n    one = torch.ones_like(cTx)\n    Rx = torch.stack([one, zero, zero, zero, cTx, sTx, zero, -sTx, cTx], -1).reshape(-1, 3, 3)\n    Ry = torch.stack([cTy, zero, -sTy, zero, one, zero, sTy, zero, cTy], -1).reshape(-1, 3, 3)\n    R = Ry @ Rx\n    if return_inverse:\n        invR22 = 1 / R[..., 2, 2]\n        invPz = torch.stack([invR22, zero, R[..., 0, 2] * invR22, zero, invR22, R[..., 1, 2] * invR22, zero, zero, one], -1).reshape(-1, 3, 3)\n        inv_tilt = R.transpose(-1, -2) @ invPz\n        if ndim == 0:\n            inv_tilt = torch.squeeze(inv_tilt)\n        return inv_tilt\n    Pz = torch.stack([R[..., 2, 2], zero, -R[..., 0, 2], zero, R[..., 2, 2], -R[..., 1, 2], zero, zero, one], -1).reshape(-1, 3, 3)\n    tilt = Pz @ R.transpose(-1, -2)\n    if ndim == 0:\n        tilt = torch.squeeze(tilt)\n    return tilt",
            "def tilt_projection(taux: torch.Tensor, tauy: torch.Tensor, return_inverse: bool=False) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Estimate the tilt projection matrix or the inverse tilt projection matrix.\\n\\n    Args:\\n        taux: Rotation angle in radians around the :math:`x`-axis with shape :math:`(*, 1)`.\\n        tauy: Rotation angle in radians around the :math:`y`-axis with shape :math:`(*, 1)`.\\n        return_inverse: False to obtain the the tilt projection matrix. True for the inverse matrix.\\n\\n    Returns:\\n        torch.Tensor: Inverse tilt projection matrix with shape :math:`(*, 3, 3)`.\\n    '\n    if taux.shape != tauy.shape:\n        raise ValueError(f'Shape of taux {taux.shape} and tauy {tauy.shape} do not match.')\n    ndim: int = taux.dim()\n    taux = taux.reshape(-1)\n    tauy = tauy.reshape(-1)\n    cTx = torch.cos(taux)\n    sTx = torch.sin(taux)\n    cTy = torch.cos(tauy)\n    sTy = torch.sin(tauy)\n    zero = torch.zeros_like(cTx)\n    one = torch.ones_like(cTx)\n    Rx = torch.stack([one, zero, zero, zero, cTx, sTx, zero, -sTx, cTx], -1).reshape(-1, 3, 3)\n    Ry = torch.stack([cTy, zero, -sTy, zero, one, zero, sTy, zero, cTy], -1).reshape(-1, 3, 3)\n    R = Ry @ Rx\n    if return_inverse:\n        invR22 = 1 / R[..., 2, 2]\n        invPz = torch.stack([invR22, zero, R[..., 0, 2] * invR22, zero, invR22, R[..., 1, 2] * invR22, zero, zero, one], -1).reshape(-1, 3, 3)\n        inv_tilt = R.transpose(-1, -2) @ invPz\n        if ndim == 0:\n            inv_tilt = torch.squeeze(inv_tilt)\n        return inv_tilt\n    Pz = torch.stack([R[..., 2, 2], zero, -R[..., 0, 2], zero, R[..., 2, 2], -R[..., 1, 2], zero, zero, one], -1).reshape(-1, 3, 3)\n    tilt = Pz @ R.transpose(-1, -2)\n    if ndim == 0:\n        tilt = torch.squeeze(tilt)\n    return tilt",
            "def tilt_projection(taux: torch.Tensor, tauy: torch.Tensor, return_inverse: bool=False) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Estimate the tilt projection matrix or the inverse tilt projection matrix.\\n\\n    Args:\\n        taux: Rotation angle in radians around the :math:`x`-axis with shape :math:`(*, 1)`.\\n        tauy: Rotation angle in radians around the :math:`y`-axis with shape :math:`(*, 1)`.\\n        return_inverse: False to obtain the the tilt projection matrix. True for the inverse matrix.\\n\\n    Returns:\\n        torch.Tensor: Inverse tilt projection matrix with shape :math:`(*, 3, 3)`.\\n    '\n    if taux.shape != tauy.shape:\n        raise ValueError(f'Shape of taux {taux.shape} and tauy {tauy.shape} do not match.')\n    ndim: int = taux.dim()\n    taux = taux.reshape(-1)\n    tauy = tauy.reshape(-1)\n    cTx = torch.cos(taux)\n    sTx = torch.sin(taux)\n    cTy = torch.cos(tauy)\n    sTy = torch.sin(tauy)\n    zero = torch.zeros_like(cTx)\n    one = torch.ones_like(cTx)\n    Rx = torch.stack([one, zero, zero, zero, cTx, sTx, zero, -sTx, cTx], -1).reshape(-1, 3, 3)\n    Ry = torch.stack([cTy, zero, -sTy, zero, one, zero, sTy, zero, cTy], -1).reshape(-1, 3, 3)\n    R = Ry @ Rx\n    if return_inverse:\n        invR22 = 1 / R[..., 2, 2]\n        invPz = torch.stack([invR22, zero, R[..., 0, 2] * invR22, zero, invR22, R[..., 1, 2] * invR22, zero, zero, one], -1).reshape(-1, 3, 3)\n        inv_tilt = R.transpose(-1, -2) @ invPz\n        if ndim == 0:\n            inv_tilt = torch.squeeze(inv_tilt)\n        return inv_tilt\n    Pz = torch.stack([R[..., 2, 2], zero, -R[..., 0, 2], zero, R[..., 2, 2], -R[..., 1, 2], zero, zero, one], -1).reshape(-1, 3, 3)\n    tilt = Pz @ R.transpose(-1, -2)\n    if ndim == 0:\n        tilt = torch.squeeze(tilt)\n    return tilt"
        ]
    },
    {
        "func_name": "distort_points",
        "original": "def distort_points(points: torch.Tensor, K: torch.Tensor, dist: torch.Tensor, new_K: Optional[torch.Tensor]=None) -> torch.Tensor:\n    \"\"\"Distortion of a set of 2D points based on the lens distortion model.\n\n    Radial :math:`(k_1, k_2, k_3, k_4, k_4, k_6)`,\n    tangential :math:`(p_1, p_2)`, thin prism :math:`(s_1, s_2, s_3, s_4)`, and tilt :math:`(\\\\tau_x, \\\\tau_y)`\n    distortion models are considered in this function.\n\n    Args:\n        points: Input image points with shape :math:`(*, N, 2)`.\n        K: Intrinsic camera matrix with shape :math:`(*, 3, 3)`.\n        dist: Distortion coefficients\n            :math:`(k_1,k_2,p_1,p_2[,k_3[,k_4,k_5,k_6[,s_1,s_2,s_3,s_4[,\\\\tau_x,\\\\tau_y]]]])`. This is\n            a vector with 4, 5, 8, 12 or 14 elements with shape :math:`(*, n)`.\n        new_K: Intrinsic camera matrix of the distorted image. By default, it is the same as K but you may additionally\n            scale and shift the result by using a different matrix. Shape: :math:`(*, 3, 3)`. Default: None.\n\n    Returns:\n        Undistorted 2D points with shape :math:`(*, N, 2)`.\n\n    Example:\n        >>> points = torch.rand(1, 1, 2)\n        >>> K = torch.eye(3)[None]\n        >>> dist_coeff = torch.rand(1, 4)\n        >>> points_dist = distort_points(points, K, dist_coeff)\n    \"\"\"\n    if points.dim() < 2 and points.shape[-1] != 2:\n        raise ValueError(f'points shape is invalid. Got {points.shape}.')\n    if K.shape[-2:] != (3, 3):\n        raise ValueError(f'K matrix shape is invalid. Got {K.shape}.')\n    if new_K is None:\n        new_K = K\n    elif new_K.shape[-2:] != (3, 3):\n        raise ValueError(f'new_K matrix shape is invalid. Got {new_K.shape}.')\n    if dist.shape[-1] not in [4, 5, 8, 12, 14]:\n        raise ValueError(f'Invalid number of distortion coefficients. Got {dist.shape[-1]}')\n    if dist.shape[-1] < 14:\n        dist = torch.nn.functional.pad(dist, [0, 14 - dist.shape[-1]])\n    new_cx: torch.Tensor = new_K[..., 0:1, 2]\n    new_cy: torch.Tensor = new_K[..., 1:2, 2]\n    new_fx: torch.Tensor = new_K[..., 0:1, 0]\n    new_fy: torch.Tensor = new_K[..., 1:2, 1]\n    x: torch.Tensor = (points[..., 0] - new_cx) / new_fx\n    y: torch.Tensor = (points[..., 1] - new_cy) / new_fy\n    r2 = x * x + y * y\n    rad_poly = (1 + dist[..., 0:1] * r2 + dist[..., 1:2] * r2 * r2 + dist[..., 4:5] * r2 ** 3) / (1 + dist[..., 5:6] * r2 + dist[..., 6:7] * r2 * r2 + dist[..., 7:8] * r2 ** 3)\n    xd = x * rad_poly + 2 * dist[..., 2:3] * x * y + dist[..., 3:4] * (r2 + 2 * x * x) + dist[..., 8:9] * r2 + dist[..., 9:10] * r2 * r2\n    yd = y * rad_poly + dist[..., 2:3] * (r2 + 2 * y * y) + 2 * dist[..., 3:4] * x * y + dist[..., 10:11] * r2 + dist[..., 11:12] * r2 * r2\n    if torch.any(dist[..., 12] != 0) or torch.any(dist[..., 13] != 0):\n        tilt = tilt_projection(dist[..., 12], dist[..., 13])\n        points_untilt = torch.stack([xd, yd, torch.ones_like(xd)], -1) @ tilt.transpose(-2, -1)\n        xd = points_untilt[..., 0] / points_untilt[..., 2]\n        yd = points_untilt[..., 1] / points_untilt[..., 2]\n    cx: torch.Tensor = K[..., 0:1, 2]\n    cy: torch.Tensor = K[..., 1:2, 2]\n    fx: torch.Tensor = K[..., 0:1, 0]\n    fy: torch.Tensor = K[..., 1:2, 1]\n    x = fx * xd + cx\n    y = fy * yd + cy\n    return torch.stack([x, y], -1)",
        "mutated": [
            "def distort_points(points: torch.Tensor, K: torch.Tensor, dist: torch.Tensor, new_K: Optional[torch.Tensor]=None) -> torch.Tensor:\n    if False:\n        i = 10\n    'Distortion of a set of 2D points based on the lens distortion model.\\n\\n    Radial :math:`(k_1, k_2, k_3, k_4, k_4, k_6)`,\\n    tangential :math:`(p_1, p_2)`, thin prism :math:`(s_1, s_2, s_3, s_4)`, and tilt :math:`(\\\\tau_x, \\\\tau_y)`\\n    distortion models are considered in this function.\\n\\n    Args:\\n        points: Input image points with shape :math:`(*, N, 2)`.\\n        K: Intrinsic camera matrix with shape :math:`(*, 3, 3)`.\\n        dist: Distortion coefficients\\n            :math:`(k_1,k_2,p_1,p_2[,k_3[,k_4,k_5,k_6[,s_1,s_2,s_3,s_4[,\\\\tau_x,\\\\tau_y]]]])`. This is\\n            a vector with 4, 5, 8, 12 or 14 elements with shape :math:`(*, n)`.\\n        new_K: Intrinsic camera matrix of the distorted image. By default, it is the same as K but you may additionally\\n            scale and shift the result by using a different matrix. Shape: :math:`(*, 3, 3)`. Default: None.\\n\\n    Returns:\\n        Undistorted 2D points with shape :math:`(*, N, 2)`.\\n\\n    Example:\\n        >>> points = torch.rand(1, 1, 2)\\n        >>> K = torch.eye(3)[None]\\n        >>> dist_coeff = torch.rand(1, 4)\\n        >>> points_dist = distort_points(points, K, dist_coeff)\\n    '\n    if points.dim() < 2 and points.shape[-1] != 2:\n        raise ValueError(f'points shape is invalid. Got {points.shape}.')\n    if K.shape[-2:] != (3, 3):\n        raise ValueError(f'K matrix shape is invalid. Got {K.shape}.')\n    if new_K is None:\n        new_K = K\n    elif new_K.shape[-2:] != (3, 3):\n        raise ValueError(f'new_K matrix shape is invalid. Got {new_K.shape}.')\n    if dist.shape[-1] not in [4, 5, 8, 12, 14]:\n        raise ValueError(f'Invalid number of distortion coefficients. Got {dist.shape[-1]}')\n    if dist.shape[-1] < 14:\n        dist = torch.nn.functional.pad(dist, [0, 14 - dist.shape[-1]])\n    new_cx: torch.Tensor = new_K[..., 0:1, 2]\n    new_cy: torch.Tensor = new_K[..., 1:2, 2]\n    new_fx: torch.Tensor = new_K[..., 0:1, 0]\n    new_fy: torch.Tensor = new_K[..., 1:2, 1]\n    x: torch.Tensor = (points[..., 0] - new_cx) / new_fx\n    y: torch.Tensor = (points[..., 1] - new_cy) / new_fy\n    r2 = x * x + y * y\n    rad_poly = (1 + dist[..., 0:1] * r2 + dist[..., 1:2] * r2 * r2 + dist[..., 4:5] * r2 ** 3) / (1 + dist[..., 5:6] * r2 + dist[..., 6:7] * r2 * r2 + dist[..., 7:8] * r2 ** 3)\n    xd = x * rad_poly + 2 * dist[..., 2:3] * x * y + dist[..., 3:4] * (r2 + 2 * x * x) + dist[..., 8:9] * r2 + dist[..., 9:10] * r2 * r2\n    yd = y * rad_poly + dist[..., 2:3] * (r2 + 2 * y * y) + 2 * dist[..., 3:4] * x * y + dist[..., 10:11] * r2 + dist[..., 11:12] * r2 * r2\n    if torch.any(dist[..., 12] != 0) or torch.any(dist[..., 13] != 0):\n        tilt = tilt_projection(dist[..., 12], dist[..., 13])\n        points_untilt = torch.stack([xd, yd, torch.ones_like(xd)], -1) @ tilt.transpose(-2, -1)\n        xd = points_untilt[..., 0] / points_untilt[..., 2]\n        yd = points_untilt[..., 1] / points_untilt[..., 2]\n    cx: torch.Tensor = K[..., 0:1, 2]\n    cy: torch.Tensor = K[..., 1:2, 2]\n    fx: torch.Tensor = K[..., 0:1, 0]\n    fy: torch.Tensor = K[..., 1:2, 1]\n    x = fx * xd + cx\n    y = fy * yd + cy\n    return torch.stack([x, y], -1)",
            "def distort_points(points: torch.Tensor, K: torch.Tensor, dist: torch.Tensor, new_K: Optional[torch.Tensor]=None) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Distortion of a set of 2D points based on the lens distortion model.\\n\\n    Radial :math:`(k_1, k_2, k_3, k_4, k_4, k_6)`,\\n    tangential :math:`(p_1, p_2)`, thin prism :math:`(s_1, s_2, s_3, s_4)`, and tilt :math:`(\\\\tau_x, \\\\tau_y)`\\n    distortion models are considered in this function.\\n\\n    Args:\\n        points: Input image points with shape :math:`(*, N, 2)`.\\n        K: Intrinsic camera matrix with shape :math:`(*, 3, 3)`.\\n        dist: Distortion coefficients\\n            :math:`(k_1,k_2,p_1,p_2[,k_3[,k_4,k_5,k_6[,s_1,s_2,s_3,s_4[,\\\\tau_x,\\\\tau_y]]]])`. This is\\n            a vector with 4, 5, 8, 12 or 14 elements with shape :math:`(*, n)`.\\n        new_K: Intrinsic camera matrix of the distorted image. By default, it is the same as K but you may additionally\\n            scale and shift the result by using a different matrix. Shape: :math:`(*, 3, 3)`. Default: None.\\n\\n    Returns:\\n        Undistorted 2D points with shape :math:`(*, N, 2)`.\\n\\n    Example:\\n        >>> points = torch.rand(1, 1, 2)\\n        >>> K = torch.eye(3)[None]\\n        >>> dist_coeff = torch.rand(1, 4)\\n        >>> points_dist = distort_points(points, K, dist_coeff)\\n    '\n    if points.dim() < 2 and points.shape[-1] != 2:\n        raise ValueError(f'points shape is invalid. Got {points.shape}.')\n    if K.shape[-2:] != (3, 3):\n        raise ValueError(f'K matrix shape is invalid. Got {K.shape}.')\n    if new_K is None:\n        new_K = K\n    elif new_K.shape[-2:] != (3, 3):\n        raise ValueError(f'new_K matrix shape is invalid. Got {new_K.shape}.')\n    if dist.shape[-1] not in [4, 5, 8, 12, 14]:\n        raise ValueError(f'Invalid number of distortion coefficients. Got {dist.shape[-1]}')\n    if dist.shape[-1] < 14:\n        dist = torch.nn.functional.pad(dist, [0, 14 - dist.shape[-1]])\n    new_cx: torch.Tensor = new_K[..., 0:1, 2]\n    new_cy: torch.Tensor = new_K[..., 1:2, 2]\n    new_fx: torch.Tensor = new_K[..., 0:1, 0]\n    new_fy: torch.Tensor = new_K[..., 1:2, 1]\n    x: torch.Tensor = (points[..., 0] - new_cx) / new_fx\n    y: torch.Tensor = (points[..., 1] - new_cy) / new_fy\n    r2 = x * x + y * y\n    rad_poly = (1 + dist[..., 0:1] * r2 + dist[..., 1:2] * r2 * r2 + dist[..., 4:5] * r2 ** 3) / (1 + dist[..., 5:6] * r2 + dist[..., 6:7] * r2 * r2 + dist[..., 7:8] * r2 ** 3)\n    xd = x * rad_poly + 2 * dist[..., 2:3] * x * y + dist[..., 3:4] * (r2 + 2 * x * x) + dist[..., 8:9] * r2 + dist[..., 9:10] * r2 * r2\n    yd = y * rad_poly + dist[..., 2:3] * (r2 + 2 * y * y) + 2 * dist[..., 3:4] * x * y + dist[..., 10:11] * r2 + dist[..., 11:12] * r2 * r2\n    if torch.any(dist[..., 12] != 0) or torch.any(dist[..., 13] != 0):\n        tilt = tilt_projection(dist[..., 12], dist[..., 13])\n        points_untilt = torch.stack([xd, yd, torch.ones_like(xd)], -1) @ tilt.transpose(-2, -1)\n        xd = points_untilt[..., 0] / points_untilt[..., 2]\n        yd = points_untilt[..., 1] / points_untilt[..., 2]\n    cx: torch.Tensor = K[..., 0:1, 2]\n    cy: torch.Tensor = K[..., 1:2, 2]\n    fx: torch.Tensor = K[..., 0:1, 0]\n    fy: torch.Tensor = K[..., 1:2, 1]\n    x = fx * xd + cx\n    y = fy * yd + cy\n    return torch.stack([x, y], -1)",
            "def distort_points(points: torch.Tensor, K: torch.Tensor, dist: torch.Tensor, new_K: Optional[torch.Tensor]=None) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Distortion of a set of 2D points based on the lens distortion model.\\n\\n    Radial :math:`(k_1, k_2, k_3, k_4, k_4, k_6)`,\\n    tangential :math:`(p_1, p_2)`, thin prism :math:`(s_1, s_2, s_3, s_4)`, and tilt :math:`(\\\\tau_x, \\\\tau_y)`\\n    distortion models are considered in this function.\\n\\n    Args:\\n        points: Input image points with shape :math:`(*, N, 2)`.\\n        K: Intrinsic camera matrix with shape :math:`(*, 3, 3)`.\\n        dist: Distortion coefficients\\n            :math:`(k_1,k_2,p_1,p_2[,k_3[,k_4,k_5,k_6[,s_1,s_2,s_3,s_4[,\\\\tau_x,\\\\tau_y]]]])`. This is\\n            a vector with 4, 5, 8, 12 or 14 elements with shape :math:`(*, n)`.\\n        new_K: Intrinsic camera matrix of the distorted image. By default, it is the same as K but you may additionally\\n            scale and shift the result by using a different matrix. Shape: :math:`(*, 3, 3)`. Default: None.\\n\\n    Returns:\\n        Undistorted 2D points with shape :math:`(*, N, 2)`.\\n\\n    Example:\\n        >>> points = torch.rand(1, 1, 2)\\n        >>> K = torch.eye(3)[None]\\n        >>> dist_coeff = torch.rand(1, 4)\\n        >>> points_dist = distort_points(points, K, dist_coeff)\\n    '\n    if points.dim() < 2 and points.shape[-1] != 2:\n        raise ValueError(f'points shape is invalid. Got {points.shape}.')\n    if K.shape[-2:] != (3, 3):\n        raise ValueError(f'K matrix shape is invalid. Got {K.shape}.')\n    if new_K is None:\n        new_K = K\n    elif new_K.shape[-2:] != (3, 3):\n        raise ValueError(f'new_K matrix shape is invalid. Got {new_K.shape}.')\n    if dist.shape[-1] not in [4, 5, 8, 12, 14]:\n        raise ValueError(f'Invalid number of distortion coefficients. Got {dist.shape[-1]}')\n    if dist.shape[-1] < 14:\n        dist = torch.nn.functional.pad(dist, [0, 14 - dist.shape[-1]])\n    new_cx: torch.Tensor = new_K[..., 0:1, 2]\n    new_cy: torch.Tensor = new_K[..., 1:2, 2]\n    new_fx: torch.Tensor = new_K[..., 0:1, 0]\n    new_fy: torch.Tensor = new_K[..., 1:2, 1]\n    x: torch.Tensor = (points[..., 0] - new_cx) / new_fx\n    y: torch.Tensor = (points[..., 1] - new_cy) / new_fy\n    r2 = x * x + y * y\n    rad_poly = (1 + dist[..., 0:1] * r2 + dist[..., 1:2] * r2 * r2 + dist[..., 4:5] * r2 ** 3) / (1 + dist[..., 5:6] * r2 + dist[..., 6:7] * r2 * r2 + dist[..., 7:8] * r2 ** 3)\n    xd = x * rad_poly + 2 * dist[..., 2:3] * x * y + dist[..., 3:4] * (r2 + 2 * x * x) + dist[..., 8:9] * r2 + dist[..., 9:10] * r2 * r2\n    yd = y * rad_poly + dist[..., 2:3] * (r2 + 2 * y * y) + 2 * dist[..., 3:4] * x * y + dist[..., 10:11] * r2 + dist[..., 11:12] * r2 * r2\n    if torch.any(dist[..., 12] != 0) or torch.any(dist[..., 13] != 0):\n        tilt = tilt_projection(dist[..., 12], dist[..., 13])\n        points_untilt = torch.stack([xd, yd, torch.ones_like(xd)], -1) @ tilt.transpose(-2, -1)\n        xd = points_untilt[..., 0] / points_untilt[..., 2]\n        yd = points_untilt[..., 1] / points_untilt[..., 2]\n    cx: torch.Tensor = K[..., 0:1, 2]\n    cy: torch.Tensor = K[..., 1:2, 2]\n    fx: torch.Tensor = K[..., 0:1, 0]\n    fy: torch.Tensor = K[..., 1:2, 1]\n    x = fx * xd + cx\n    y = fy * yd + cy\n    return torch.stack([x, y], -1)",
            "def distort_points(points: torch.Tensor, K: torch.Tensor, dist: torch.Tensor, new_K: Optional[torch.Tensor]=None) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Distortion of a set of 2D points based on the lens distortion model.\\n\\n    Radial :math:`(k_1, k_2, k_3, k_4, k_4, k_6)`,\\n    tangential :math:`(p_1, p_2)`, thin prism :math:`(s_1, s_2, s_3, s_4)`, and tilt :math:`(\\\\tau_x, \\\\tau_y)`\\n    distortion models are considered in this function.\\n\\n    Args:\\n        points: Input image points with shape :math:`(*, N, 2)`.\\n        K: Intrinsic camera matrix with shape :math:`(*, 3, 3)`.\\n        dist: Distortion coefficients\\n            :math:`(k_1,k_2,p_1,p_2[,k_3[,k_4,k_5,k_6[,s_1,s_2,s_3,s_4[,\\\\tau_x,\\\\tau_y]]]])`. This is\\n            a vector with 4, 5, 8, 12 or 14 elements with shape :math:`(*, n)`.\\n        new_K: Intrinsic camera matrix of the distorted image. By default, it is the same as K but you may additionally\\n            scale and shift the result by using a different matrix. Shape: :math:`(*, 3, 3)`. Default: None.\\n\\n    Returns:\\n        Undistorted 2D points with shape :math:`(*, N, 2)`.\\n\\n    Example:\\n        >>> points = torch.rand(1, 1, 2)\\n        >>> K = torch.eye(3)[None]\\n        >>> dist_coeff = torch.rand(1, 4)\\n        >>> points_dist = distort_points(points, K, dist_coeff)\\n    '\n    if points.dim() < 2 and points.shape[-1] != 2:\n        raise ValueError(f'points shape is invalid. Got {points.shape}.')\n    if K.shape[-2:] != (3, 3):\n        raise ValueError(f'K matrix shape is invalid. Got {K.shape}.')\n    if new_K is None:\n        new_K = K\n    elif new_K.shape[-2:] != (3, 3):\n        raise ValueError(f'new_K matrix shape is invalid. Got {new_K.shape}.')\n    if dist.shape[-1] not in [4, 5, 8, 12, 14]:\n        raise ValueError(f'Invalid number of distortion coefficients. Got {dist.shape[-1]}')\n    if dist.shape[-1] < 14:\n        dist = torch.nn.functional.pad(dist, [0, 14 - dist.shape[-1]])\n    new_cx: torch.Tensor = new_K[..., 0:1, 2]\n    new_cy: torch.Tensor = new_K[..., 1:2, 2]\n    new_fx: torch.Tensor = new_K[..., 0:1, 0]\n    new_fy: torch.Tensor = new_K[..., 1:2, 1]\n    x: torch.Tensor = (points[..., 0] - new_cx) / new_fx\n    y: torch.Tensor = (points[..., 1] - new_cy) / new_fy\n    r2 = x * x + y * y\n    rad_poly = (1 + dist[..., 0:1] * r2 + dist[..., 1:2] * r2 * r2 + dist[..., 4:5] * r2 ** 3) / (1 + dist[..., 5:6] * r2 + dist[..., 6:7] * r2 * r2 + dist[..., 7:8] * r2 ** 3)\n    xd = x * rad_poly + 2 * dist[..., 2:3] * x * y + dist[..., 3:4] * (r2 + 2 * x * x) + dist[..., 8:9] * r2 + dist[..., 9:10] * r2 * r2\n    yd = y * rad_poly + dist[..., 2:3] * (r2 + 2 * y * y) + 2 * dist[..., 3:4] * x * y + dist[..., 10:11] * r2 + dist[..., 11:12] * r2 * r2\n    if torch.any(dist[..., 12] != 0) or torch.any(dist[..., 13] != 0):\n        tilt = tilt_projection(dist[..., 12], dist[..., 13])\n        points_untilt = torch.stack([xd, yd, torch.ones_like(xd)], -1) @ tilt.transpose(-2, -1)\n        xd = points_untilt[..., 0] / points_untilt[..., 2]\n        yd = points_untilt[..., 1] / points_untilt[..., 2]\n    cx: torch.Tensor = K[..., 0:1, 2]\n    cy: torch.Tensor = K[..., 1:2, 2]\n    fx: torch.Tensor = K[..., 0:1, 0]\n    fy: torch.Tensor = K[..., 1:2, 1]\n    x = fx * xd + cx\n    y = fy * yd + cy\n    return torch.stack([x, y], -1)",
            "def distort_points(points: torch.Tensor, K: torch.Tensor, dist: torch.Tensor, new_K: Optional[torch.Tensor]=None) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Distortion of a set of 2D points based on the lens distortion model.\\n\\n    Radial :math:`(k_1, k_2, k_3, k_4, k_4, k_6)`,\\n    tangential :math:`(p_1, p_2)`, thin prism :math:`(s_1, s_2, s_3, s_4)`, and tilt :math:`(\\\\tau_x, \\\\tau_y)`\\n    distortion models are considered in this function.\\n\\n    Args:\\n        points: Input image points with shape :math:`(*, N, 2)`.\\n        K: Intrinsic camera matrix with shape :math:`(*, 3, 3)`.\\n        dist: Distortion coefficients\\n            :math:`(k_1,k_2,p_1,p_2[,k_3[,k_4,k_5,k_6[,s_1,s_2,s_3,s_4[,\\\\tau_x,\\\\tau_y]]]])`. This is\\n            a vector with 4, 5, 8, 12 or 14 elements with shape :math:`(*, n)`.\\n        new_K: Intrinsic camera matrix of the distorted image. By default, it is the same as K but you may additionally\\n            scale and shift the result by using a different matrix. Shape: :math:`(*, 3, 3)`. Default: None.\\n\\n    Returns:\\n        Undistorted 2D points with shape :math:`(*, N, 2)`.\\n\\n    Example:\\n        >>> points = torch.rand(1, 1, 2)\\n        >>> K = torch.eye(3)[None]\\n        >>> dist_coeff = torch.rand(1, 4)\\n        >>> points_dist = distort_points(points, K, dist_coeff)\\n    '\n    if points.dim() < 2 and points.shape[-1] != 2:\n        raise ValueError(f'points shape is invalid. Got {points.shape}.')\n    if K.shape[-2:] != (3, 3):\n        raise ValueError(f'K matrix shape is invalid. Got {K.shape}.')\n    if new_K is None:\n        new_K = K\n    elif new_K.shape[-2:] != (3, 3):\n        raise ValueError(f'new_K matrix shape is invalid. Got {new_K.shape}.')\n    if dist.shape[-1] not in [4, 5, 8, 12, 14]:\n        raise ValueError(f'Invalid number of distortion coefficients. Got {dist.shape[-1]}')\n    if dist.shape[-1] < 14:\n        dist = torch.nn.functional.pad(dist, [0, 14 - dist.shape[-1]])\n    new_cx: torch.Tensor = new_K[..., 0:1, 2]\n    new_cy: torch.Tensor = new_K[..., 1:2, 2]\n    new_fx: torch.Tensor = new_K[..., 0:1, 0]\n    new_fy: torch.Tensor = new_K[..., 1:2, 1]\n    x: torch.Tensor = (points[..., 0] - new_cx) / new_fx\n    y: torch.Tensor = (points[..., 1] - new_cy) / new_fy\n    r2 = x * x + y * y\n    rad_poly = (1 + dist[..., 0:1] * r2 + dist[..., 1:2] * r2 * r2 + dist[..., 4:5] * r2 ** 3) / (1 + dist[..., 5:6] * r2 + dist[..., 6:7] * r2 * r2 + dist[..., 7:8] * r2 ** 3)\n    xd = x * rad_poly + 2 * dist[..., 2:3] * x * y + dist[..., 3:4] * (r2 + 2 * x * x) + dist[..., 8:9] * r2 + dist[..., 9:10] * r2 * r2\n    yd = y * rad_poly + dist[..., 2:3] * (r2 + 2 * y * y) + 2 * dist[..., 3:4] * x * y + dist[..., 10:11] * r2 + dist[..., 11:12] * r2 * r2\n    if torch.any(dist[..., 12] != 0) or torch.any(dist[..., 13] != 0):\n        tilt = tilt_projection(dist[..., 12], dist[..., 13])\n        points_untilt = torch.stack([xd, yd, torch.ones_like(xd)], -1) @ tilt.transpose(-2, -1)\n        xd = points_untilt[..., 0] / points_untilt[..., 2]\n        yd = points_untilt[..., 1] / points_untilt[..., 2]\n    cx: torch.Tensor = K[..., 0:1, 2]\n    cy: torch.Tensor = K[..., 1:2, 2]\n    fx: torch.Tensor = K[..., 0:1, 0]\n    fy: torch.Tensor = K[..., 1:2, 1]\n    x = fx * xd + cx\n    y = fy * yd + cy\n    return torch.stack([x, y], -1)"
        ]
    }
]