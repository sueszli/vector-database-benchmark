[
    {
        "func_name": "shotgun_pattern",
        "original": "def shotgun_pattern(T, a, b, c=1, d=1, e=10000):\n    \"\"\"\n    Equations taken from [1] or [2] + some modifications by Matthieu LEROY\n    in order to squish the pattern and make a log-based pattern.\n    \n    [1] https://math.stackexchange.com/questions/1808380/non-symmetrical-lemniscate-curve-parameterization\n    [2] https://www.jneurosci.org/content/22/18/8201\n    \n    Parameters\n    ----------\n    T: array-like of floats\n        Angle between -pi and pi.\n    a: float\n        Amplitude.\n    b: float\n        Asymetric parameter.\n    c: float\n        Squish parameter??\n    d: float\n        Not sure what it does.\n    e: float\n        Not sure what it does.\n        \n    Returns\n    -------\n    Shotgun pattern.\n    \"\"\"\n    x = a * (np.cos(T) + b) * np.cos(T) / (c + np.sin(T) ** 2)\n    y = d * x * np.sin(T)\n    res = np.sqrt(x ** 2 + y ** 2)\n    return np.exp(res) / e",
        "mutated": [
            "def shotgun_pattern(T, a, b, c=1, d=1, e=10000):\n    if False:\n        i = 10\n    '\\n    Equations taken from [1] or [2] + some modifications by Matthieu LEROY\\n    in order to squish the pattern and make a log-based pattern.\\n    \\n    [1] https://math.stackexchange.com/questions/1808380/non-symmetrical-lemniscate-curve-parameterization\\n    [2] https://www.jneurosci.org/content/22/18/8201\\n    \\n    Parameters\\n    ----------\\n    T: array-like of floats\\n        Angle between -pi and pi.\\n    a: float\\n        Amplitude.\\n    b: float\\n        Asymetric parameter.\\n    c: float\\n        Squish parameter??\\n    d: float\\n        Not sure what it does.\\n    e: float\\n        Not sure what it does.\\n        \\n    Returns\\n    -------\\n    Shotgun pattern.\\n    '\n    x = a * (np.cos(T) + b) * np.cos(T) / (c + np.sin(T) ** 2)\n    y = d * x * np.sin(T)\n    res = np.sqrt(x ** 2 + y ** 2)\n    return np.exp(res) / e",
            "def shotgun_pattern(T, a, b, c=1, d=1, e=10000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Equations taken from [1] or [2] + some modifications by Matthieu LEROY\\n    in order to squish the pattern and make a log-based pattern.\\n    \\n    [1] https://math.stackexchange.com/questions/1808380/non-symmetrical-lemniscate-curve-parameterization\\n    [2] https://www.jneurosci.org/content/22/18/8201\\n    \\n    Parameters\\n    ----------\\n    T: array-like of floats\\n        Angle between -pi and pi.\\n    a: float\\n        Amplitude.\\n    b: float\\n        Asymetric parameter.\\n    c: float\\n        Squish parameter??\\n    d: float\\n        Not sure what it does.\\n    e: float\\n        Not sure what it does.\\n        \\n    Returns\\n    -------\\n    Shotgun pattern.\\n    '\n    x = a * (np.cos(T) + b) * np.cos(T) / (c + np.sin(T) ** 2)\n    y = d * x * np.sin(T)\n    res = np.sqrt(x ** 2 + y ** 2)\n    return np.exp(res) / e",
            "def shotgun_pattern(T, a, b, c=1, d=1, e=10000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Equations taken from [1] or [2] + some modifications by Matthieu LEROY\\n    in order to squish the pattern and make a log-based pattern.\\n    \\n    [1] https://math.stackexchange.com/questions/1808380/non-symmetrical-lemniscate-curve-parameterization\\n    [2] https://www.jneurosci.org/content/22/18/8201\\n    \\n    Parameters\\n    ----------\\n    T: array-like of floats\\n        Angle between -pi and pi.\\n    a: float\\n        Amplitude.\\n    b: float\\n        Asymetric parameter.\\n    c: float\\n        Squish parameter??\\n    d: float\\n        Not sure what it does.\\n    e: float\\n        Not sure what it does.\\n        \\n    Returns\\n    -------\\n    Shotgun pattern.\\n    '\n    x = a * (np.cos(T) + b) * np.cos(T) / (c + np.sin(T) ** 2)\n    y = d * x * np.sin(T)\n    res = np.sqrt(x ** 2 + y ** 2)\n    return np.exp(res) / e",
            "def shotgun_pattern(T, a, b, c=1, d=1, e=10000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Equations taken from [1] or [2] + some modifications by Matthieu LEROY\\n    in order to squish the pattern and make a log-based pattern.\\n    \\n    [1] https://math.stackexchange.com/questions/1808380/non-symmetrical-lemniscate-curve-parameterization\\n    [2] https://www.jneurosci.org/content/22/18/8201\\n    \\n    Parameters\\n    ----------\\n    T: array-like of floats\\n        Angle between -pi and pi.\\n    a: float\\n        Amplitude.\\n    b: float\\n        Asymetric parameter.\\n    c: float\\n        Squish parameter??\\n    d: float\\n        Not sure what it does.\\n    e: float\\n        Not sure what it does.\\n        \\n    Returns\\n    -------\\n    Shotgun pattern.\\n    '\n    x = a * (np.cos(T) + b) * np.cos(T) / (c + np.sin(T) ** 2)\n    y = d * x * np.sin(T)\n    res = np.sqrt(x ** 2 + y ** 2)\n    return np.exp(res) / e",
            "def shotgun_pattern(T, a, b, c=1, d=1, e=10000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Equations taken from [1] or [2] + some modifications by Matthieu LEROY\\n    in order to squish the pattern and make a log-based pattern.\\n    \\n    [1] https://math.stackexchange.com/questions/1808380/non-symmetrical-lemniscate-curve-parameterization\\n    [2] https://www.jneurosci.org/content/22/18/8201\\n    \\n    Parameters\\n    ----------\\n    T: array-like of floats\\n        Angle between -pi and pi.\\n    a: float\\n        Amplitude.\\n    b: float\\n        Asymetric parameter.\\n    c: float\\n        Squish parameter??\\n    d: float\\n        Not sure what it does.\\n    e: float\\n        Not sure what it does.\\n        \\n    Returns\\n    -------\\n    Shotgun pattern.\\n    '\n    x = a * (np.cos(T) + b) * np.cos(T) / (c + np.sin(T) ** 2)\n    y = d * x * np.sin(T)\n    res = np.sqrt(x ** 2 + y ** 2)\n    return np.exp(res) / e"
        ]
    },
    {
        "func_name": "plot",
        "original": "def plot(ax, title, alpha=1, shotgun=False):\n    T = np.linspace(-np.pi, np.pi, 5000)\n    if shotgun:\n        R = shotgun_pattern(T, 4, 0.2, 0.1, 4) + shotgun_pattern(T - np.pi / 2, 3.5, 0, c=0.15, d=1)\n    else:\n        R = alpha + (1 - alpha) * np.cos(T)\n    R = np.log(1 + np.abs(50 * R)) / np.log(10)\n    R = 1000 * (R / R.max())\n    ax.set_theta_offset(np.pi / 2)\n    ax.set_thetalim(0, 2 * np.pi)\n    ax.set_rorigin(0)\n    ax.set_rlabel_position(np.pi / 2)\n    ax.fill(T, R, zorder=20, color='C1', clip_on=True, alpha=0.25)\n    ax.plot(T, R, zorder=30, alpha=0.75, color='C1', linewidth=1.0, linestyle=':', clip_on=False)\n    ax.plot(T, R, zorder=40, color='C1', linewidth=1.5, clip_on=True)\n    ax.set_xticks([0, np.pi / 2, np.pi, 3 * np.pi / 2])\n    ax.xaxis.set_tick_params('major', pad=-2.5)\n    ax.set_xticklabels(['0\u00b0', '', '180\u00b0', ''], family='Roboto', size='small', horizontalalignment='center', verticalalignment='center')\n    ax.set_yticks([200, 400, 600, 800, 1010])\n    for (y, label) in zip([390, 590, 790], ['-20 dB', '-15 dB', '-10 dB']):\n        ax.text(0, y, label, zorder=10, family='Roboto Condensed', size='small', horizontalalignment='center', verticalalignment='center', bbox=dict(facecolor='white', edgecolor='None', pad=1.0))\n    ax.set_yticklabels([])\n    ax.set_ylim(200, 1010)\n    ax.set_title(title, family='Roboto', weight='bold', size='large', y=-0.2)",
        "mutated": [
            "def plot(ax, title, alpha=1, shotgun=False):\n    if False:\n        i = 10\n    T = np.linspace(-np.pi, np.pi, 5000)\n    if shotgun:\n        R = shotgun_pattern(T, 4, 0.2, 0.1, 4) + shotgun_pattern(T - np.pi / 2, 3.5, 0, c=0.15, d=1)\n    else:\n        R = alpha + (1 - alpha) * np.cos(T)\n    R = np.log(1 + np.abs(50 * R)) / np.log(10)\n    R = 1000 * (R / R.max())\n    ax.set_theta_offset(np.pi / 2)\n    ax.set_thetalim(0, 2 * np.pi)\n    ax.set_rorigin(0)\n    ax.set_rlabel_position(np.pi / 2)\n    ax.fill(T, R, zorder=20, color='C1', clip_on=True, alpha=0.25)\n    ax.plot(T, R, zorder=30, alpha=0.75, color='C1', linewidth=1.0, linestyle=':', clip_on=False)\n    ax.plot(T, R, zorder=40, color='C1', linewidth=1.5, clip_on=True)\n    ax.set_xticks([0, np.pi / 2, np.pi, 3 * np.pi / 2])\n    ax.xaxis.set_tick_params('major', pad=-2.5)\n    ax.set_xticklabels(['0\u00b0', '', '180\u00b0', ''], family='Roboto', size='small', horizontalalignment='center', verticalalignment='center')\n    ax.set_yticks([200, 400, 600, 800, 1010])\n    for (y, label) in zip([390, 590, 790], ['-20 dB', '-15 dB', '-10 dB']):\n        ax.text(0, y, label, zorder=10, family='Roboto Condensed', size='small', horizontalalignment='center', verticalalignment='center', bbox=dict(facecolor='white', edgecolor='None', pad=1.0))\n    ax.set_yticklabels([])\n    ax.set_ylim(200, 1010)\n    ax.set_title(title, family='Roboto', weight='bold', size='large', y=-0.2)",
            "def plot(ax, title, alpha=1, shotgun=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    T = np.linspace(-np.pi, np.pi, 5000)\n    if shotgun:\n        R = shotgun_pattern(T, 4, 0.2, 0.1, 4) + shotgun_pattern(T - np.pi / 2, 3.5, 0, c=0.15, d=1)\n    else:\n        R = alpha + (1 - alpha) * np.cos(T)\n    R = np.log(1 + np.abs(50 * R)) / np.log(10)\n    R = 1000 * (R / R.max())\n    ax.set_theta_offset(np.pi / 2)\n    ax.set_thetalim(0, 2 * np.pi)\n    ax.set_rorigin(0)\n    ax.set_rlabel_position(np.pi / 2)\n    ax.fill(T, R, zorder=20, color='C1', clip_on=True, alpha=0.25)\n    ax.plot(T, R, zorder=30, alpha=0.75, color='C1', linewidth=1.0, linestyle=':', clip_on=False)\n    ax.plot(T, R, zorder=40, color='C1', linewidth=1.5, clip_on=True)\n    ax.set_xticks([0, np.pi / 2, np.pi, 3 * np.pi / 2])\n    ax.xaxis.set_tick_params('major', pad=-2.5)\n    ax.set_xticklabels(['0\u00b0', '', '180\u00b0', ''], family='Roboto', size='small', horizontalalignment='center', verticalalignment='center')\n    ax.set_yticks([200, 400, 600, 800, 1010])\n    for (y, label) in zip([390, 590, 790], ['-20 dB', '-15 dB', '-10 dB']):\n        ax.text(0, y, label, zorder=10, family='Roboto Condensed', size='small', horizontalalignment='center', verticalalignment='center', bbox=dict(facecolor='white', edgecolor='None', pad=1.0))\n    ax.set_yticklabels([])\n    ax.set_ylim(200, 1010)\n    ax.set_title(title, family='Roboto', weight='bold', size='large', y=-0.2)",
            "def plot(ax, title, alpha=1, shotgun=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    T = np.linspace(-np.pi, np.pi, 5000)\n    if shotgun:\n        R = shotgun_pattern(T, 4, 0.2, 0.1, 4) + shotgun_pattern(T - np.pi / 2, 3.5, 0, c=0.15, d=1)\n    else:\n        R = alpha + (1 - alpha) * np.cos(T)\n    R = np.log(1 + np.abs(50 * R)) / np.log(10)\n    R = 1000 * (R / R.max())\n    ax.set_theta_offset(np.pi / 2)\n    ax.set_thetalim(0, 2 * np.pi)\n    ax.set_rorigin(0)\n    ax.set_rlabel_position(np.pi / 2)\n    ax.fill(T, R, zorder=20, color='C1', clip_on=True, alpha=0.25)\n    ax.plot(T, R, zorder=30, alpha=0.75, color='C1', linewidth=1.0, linestyle=':', clip_on=False)\n    ax.plot(T, R, zorder=40, color='C1', linewidth=1.5, clip_on=True)\n    ax.set_xticks([0, np.pi / 2, np.pi, 3 * np.pi / 2])\n    ax.xaxis.set_tick_params('major', pad=-2.5)\n    ax.set_xticklabels(['0\u00b0', '', '180\u00b0', ''], family='Roboto', size='small', horizontalalignment='center', verticalalignment='center')\n    ax.set_yticks([200, 400, 600, 800, 1010])\n    for (y, label) in zip([390, 590, 790], ['-20 dB', '-15 dB', '-10 dB']):\n        ax.text(0, y, label, zorder=10, family='Roboto Condensed', size='small', horizontalalignment='center', verticalalignment='center', bbox=dict(facecolor='white', edgecolor='None', pad=1.0))\n    ax.set_yticklabels([])\n    ax.set_ylim(200, 1010)\n    ax.set_title(title, family='Roboto', weight='bold', size='large', y=-0.2)",
            "def plot(ax, title, alpha=1, shotgun=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    T = np.linspace(-np.pi, np.pi, 5000)\n    if shotgun:\n        R = shotgun_pattern(T, 4, 0.2, 0.1, 4) + shotgun_pattern(T - np.pi / 2, 3.5, 0, c=0.15, d=1)\n    else:\n        R = alpha + (1 - alpha) * np.cos(T)\n    R = np.log(1 + np.abs(50 * R)) / np.log(10)\n    R = 1000 * (R / R.max())\n    ax.set_theta_offset(np.pi / 2)\n    ax.set_thetalim(0, 2 * np.pi)\n    ax.set_rorigin(0)\n    ax.set_rlabel_position(np.pi / 2)\n    ax.fill(T, R, zorder=20, color='C1', clip_on=True, alpha=0.25)\n    ax.plot(T, R, zorder=30, alpha=0.75, color='C1', linewidth=1.0, linestyle=':', clip_on=False)\n    ax.plot(T, R, zorder=40, color='C1', linewidth=1.5, clip_on=True)\n    ax.set_xticks([0, np.pi / 2, np.pi, 3 * np.pi / 2])\n    ax.xaxis.set_tick_params('major', pad=-2.5)\n    ax.set_xticklabels(['0\u00b0', '', '180\u00b0', ''], family='Roboto', size='small', horizontalalignment='center', verticalalignment='center')\n    ax.set_yticks([200, 400, 600, 800, 1010])\n    for (y, label) in zip([390, 590, 790], ['-20 dB', '-15 dB', '-10 dB']):\n        ax.text(0, y, label, zorder=10, family='Roboto Condensed', size='small', horizontalalignment='center', verticalalignment='center', bbox=dict(facecolor='white', edgecolor='None', pad=1.0))\n    ax.set_yticklabels([])\n    ax.set_ylim(200, 1010)\n    ax.set_title(title, family='Roboto', weight='bold', size='large', y=-0.2)",
            "def plot(ax, title, alpha=1, shotgun=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    T = np.linspace(-np.pi, np.pi, 5000)\n    if shotgun:\n        R = shotgun_pattern(T, 4, 0.2, 0.1, 4) + shotgun_pattern(T - np.pi / 2, 3.5, 0, c=0.15, d=1)\n    else:\n        R = alpha + (1 - alpha) * np.cos(T)\n    R = np.log(1 + np.abs(50 * R)) / np.log(10)\n    R = 1000 * (R / R.max())\n    ax.set_theta_offset(np.pi / 2)\n    ax.set_thetalim(0, 2 * np.pi)\n    ax.set_rorigin(0)\n    ax.set_rlabel_position(np.pi / 2)\n    ax.fill(T, R, zorder=20, color='C1', clip_on=True, alpha=0.25)\n    ax.plot(T, R, zorder=30, alpha=0.75, color='C1', linewidth=1.0, linestyle=':', clip_on=False)\n    ax.plot(T, R, zorder=40, color='C1', linewidth=1.5, clip_on=True)\n    ax.set_xticks([0, np.pi / 2, np.pi, 3 * np.pi / 2])\n    ax.xaxis.set_tick_params('major', pad=-2.5)\n    ax.set_xticklabels(['0\u00b0', '', '180\u00b0', ''], family='Roboto', size='small', horizontalalignment='center', verticalalignment='center')\n    ax.set_yticks([200, 400, 600, 800, 1010])\n    for (y, label) in zip([390, 590, 790], ['-20 dB', '-15 dB', '-10 dB']):\n        ax.text(0, y, label, zorder=10, family='Roboto Condensed', size='small', horizontalalignment='center', verticalalignment='center', bbox=dict(facecolor='white', edgecolor='None', pad=1.0))\n    ax.set_yticklabels([])\n    ax.set_ylim(200, 1010)\n    ax.set_title(title, family='Roboto', weight='bold', size='large', y=-0.2)"
        ]
    }
]