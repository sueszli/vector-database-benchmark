[
    {
        "func_name": "evaluate_with_query_set",
        "original": "def evaluate_with_query_set(gallery_labels, gallery_groups, gallery_features, query_labels, query_groups, query_features, use_rerank=False, rerank_k1=20, rerank_k2=6, rerank_lambda=0.3, is_market1501=False):\n    ap = 0.0\n    CMC = torch.IntTensor(len(gallery_labels)).zero_()\n    q_g_dist = np.dot(query_features, np.transpose(gallery_features))\n    if use_rerank:\n        print('Calculate re-ranked distances..')\n        q_q_dist = np.dot(query_features, np.transpose(query_features))\n        g_g_dist = np.dot(gallery_features, np.transpose(gallery_features))\n        since = time.time()\n        distances = re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=rerank_k1, k2=rerank_k2, lambda_value=rerank_lambda)\n        time_elapsed = time.time() - since\n        print('Reranking complete in {:.0f}m {:.0f}s'.format(time_elapsed // 60, time_elapsed % 60))\n    else:\n        distances = -q_g_dist\n    norm = 0\n    skip = 1\n    for i in range(len(query_labels))[::skip]:\n        (ap_tmp, CMC_tmp) = evaluate_helper(distances[i, :], query_labels[i], query_groups[i], gallery_labels, gallery_groups, is_market1501)\n        if CMC_tmp[0] == -1:\n            continue\n        norm += 1\n        ap += ap_tmp\n        CMC = CMC + CMC_tmp\n    if is_market1501:\n        norm = len(query_labels) / float(skip)\n    ap = ap / norm\n    CMC = CMC.float()\n    CMC = CMC / norm\n    print('Rank@1:{:.1f}, rank@5:{:.1f}, mAP:{:.2f}'.format(100 * CMC[0], 100 * CMC[4], ap))\n    return (CMC, ap)",
        "mutated": [
            "def evaluate_with_query_set(gallery_labels, gallery_groups, gallery_features, query_labels, query_groups, query_features, use_rerank=False, rerank_k1=20, rerank_k2=6, rerank_lambda=0.3, is_market1501=False):\n    if False:\n        i = 10\n    ap = 0.0\n    CMC = torch.IntTensor(len(gallery_labels)).zero_()\n    q_g_dist = np.dot(query_features, np.transpose(gallery_features))\n    if use_rerank:\n        print('Calculate re-ranked distances..')\n        q_q_dist = np.dot(query_features, np.transpose(query_features))\n        g_g_dist = np.dot(gallery_features, np.transpose(gallery_features))\n        since = time.time()\n        distances = re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=rerank_k1, k2=rerank_k2, lambda_value=rerank_lambda)\n        time_elapsed = time.time() - since\n        print('Reranking complete in {:.0f}m {:.0f}s'.format(time_elapsed // 60, time_elapsed % 60))\n    else:\n        distances = -q_g_dist\n    norm = 0\n    skip = 1\n    for i in range(len(query_labels))[::skip]:\n        (ap_tmp, CMC_tmp) = evaluate_helper(distances[i, :], query_labels[i], query_groups[i], gallery_labels, gallery_groups, is_market1501)\n        if CMC_tmp[0] == -1:\n            continue\n        norm += 1\n        ap += ap_tmp\n        CMC = CMC + CMC_tmp\n    if is_market1501:\n        norm = len(query_labels) / float(skip)\n    ap = ap / norm\n    CMC = CMC.float()\n    CMC = CMC / norm\n    print('Rank@1:{:.1f}, rank@5:{:.1f}, mAP:{:.2f}'.format(100 * CMC[0], 100 * CMC[4], ap))\n    return (CMC, ap)",
            "def evaluate_with_query_set(gallery_labels, gallery_groups, gallery_features, query_labels, query_groups, query_features, use_rerank=False, rerank_k1=20, rerank_k2=6, rerank_lambda=0.3, is_market1501=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ap = 0.0\n    CMC = torch.IntTensor(len(gallery_labels)).zero_()\n    q_g_dist = np.dot(query_features, np.transpose(gallery_features))\n    if use_rerank:\n        print('Calculate re-ranked distances..')\n        q_q_dist = np.dot(query_features, np.transpose(query_features))\n        g_g_dist = np.dot(gallery_features, np.transpose(gallery_features))\n        since = time.time()\n        distances = re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=rerank_k1, k2=rerank_k2, lambda_value=rerank_lambda)\n        time_elapsed = time.time() - since\n        print('Reranking complete in {:.0f}m {:.0f}s'.format(time_elapsed // 60, time_elapsed % 60))\n    else:\n        distances = -q_g_dist\n    norm = 0\n    skip = 1\n    for i in range(len(query_labels))[::skip]:\n        (ap_tmp, CMC_tmp) = evaluate_helper(distances[i, :], query_labels[i], query_groups[i], gallery_labels, gallery_groups, is_market1501)\n        if CMC_tmp[0] == -1:\n            continue\n        norm += 1\n        ap += ap_tmp\n        CMC = CMC + CMC_tmp\n    if is_market1501:\n        norm = len(query_labels) / float(skip)\n    ap = ap / norm\n    CMC = CMC.float()\n    CMC = CMC / norm\n    print('Rank@1:{:.1f}, rank@5:{:.1f}, mAP:{:.2f}'.format(100 * CMC[0], 100 * CMC[4], ap))\n    return (CMC, ap)",
            "def evaluate_with_query_set(gallery_labels, gallery_groups, gallery_features, query_labels, query_groups, query_features, use_rerank=False, rerank_k1=20, rerank_k2=6, rerank_lambda=0.3, is_market1501=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ap = 0.0\n    CMC = torch.IntTensor(len(gallery_labels)).zero_()\n    q_g_dist = np.dot(query_features, np.transpose(gallery_features))\n    if use_rerank:\n        print('Calculate re-ranked distances..')\n        q_q_dist = np.dot(query_features, np.transpose(query_features))\n        g_g_dist = np.dot(gallery_features, np.transpose(gallery_features))\n        since = time.time()\n        distances = re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=rerank_k1, k2=rerank_k2, lambda_value=rerank_lambda)\n        time_elapsed = time.time() - since\n        print('Reranking complete in {:.0f}m {:.0f}s'.format(time_elapsed // 60, time_elapsed % 60))\n    else:\n        distances = -q_g_dist\n    norm = 0\n    skip = 1\n    for i in range(len(query_labels))[::skip]:\n        (ap_tmp, CMC_tmp) = evaluate_helper(distances[i, :], query_labels[i], query_groups[i], gallery_labels, gallery_groups, is_market1501)\n        if CMC_tmp[0] == -1:\n            continue\n        norm += 1\n        ap += ap_tmp\n        CMC = CMC + CMC_tmp\n    if is_market1501:\n        norm = len(query_labels) / float(skip)\n    ap = ap / norm\n    CMC = CMC.float()\n    CMC = CMC / norm\n    print('Rank@1:{:.1f}, rank@5:{:.1f}, mAP:{:.2f}'.format(100 * CMC[0], 100 * CMC[4], ap))\n    return (CMC, ap)",
            "def evaluate_with_query_set(gallery_labels, gallery_groups, gallery_features, query_labels, query_groups, query_features, use_rerank=False, rerank_k1=20, rerank_k2=6, rerank_lambda=0.3, is_market1501=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ap = 0.0\n    CMC = torch.IntTensor(len(gallery_labels)).zero_()\n    q_g_dist = np.dot(query_features, np.transpose(gallery_features))\n    if use_rerank:\n        print('Calculate re-ranked distances..')\n        q_q_dist = np.dot(query_features, np.transpose(query_features))\n        g_g_dist = np.dot(gallery_features, np.transpose(gallery_features))\n        since = time.time()\n        distances = re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=rerank_k1, k2=rerank_k2, lambda_value=rerank_lambda)\n        time_elapsed = time.time() - since\n        print('Reranking complete in {:.0f}m {:.0f}s'.format(time_elapsed // 60, time_elapsed % 60))\n    else:\n        distances = -q_g_dist\n    norm = 0\n    skip = 1\n    for i in range(len(query_labels))[::skip]:\n        (ap_tmp, CMC_tmp) = evaluate_helper(distances[i, :], query_labels[i], query_groups[i], gallery_labels, gallery_groups, is_market1501)\n        if CMC_tmp[0] == -1:\n            continue\n        norm += 1\n        ap += ap_tmp\n        CMC = CMC + CMC_tmp\n    if is_market1501:\n        norm = len(query_labels) / float(skip)\n    ap = ap / norm\n    CMC = CMC.float()\n    CMC = CMC / norm\n    print('Rank@1:{:.1f}, rank@5:{:.1f}, mAP:{:.2f}'.format(100 * CMC[0], 100 * CMC[4], ap))\n    return (CMC, ap)",
            "def evaluate_with_query_set(gallery_labels, gallery_groups, gallery_features, query_labels, query_groups, query_features, use_rerank=False, rerank_k1=20, rerank_k2=6, rerank_lambda=0.3, is_market1501=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ap = 0.0\n    CMC = torch.IntTensor(len(gallery_labels)).zero_()\n    q_g_dist = np.dot(query_features, np.transpose(gallery_features))\n    if use_rerank:\n        print('Calculate re-ranked distances..')\n        q_q_dist = np.dot(query_features, np.transpose(query_features))\n        g_g_dist = np.dot(gallery_features, np.transpose(gallery_features))\n        since = time.time()\n        distances = re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=rerank_k1, k2=rerank_k2, lambda_value=rerank_lambda)\n        time_elapsed = time.time() - since\n        print('Reranking complete in {:.0f}m {:.0f}s'.format(time_elapsed // 60, time_elapsed % 60))\n    else:\n        distances = -q_g_dist\n    norm = 0\n    skip = 1\n    for i in range(len(query_labels))[::skip]:\n        (ap_tmp, CMC_tmp) = evaluate_helper(distances[i, :], query_labels[i], query_groups[i], gallery_labels, gallery_groups, is_market1501)\n        if CMC_tmp[0] == -1:\n            continue\n        norm += 1\n        ap += ap_tmp\n        CMC = CMC + CMC_tmp\n    if is_market1501:\n        norm = len(query_labels) / float(skip)\n    ap = ap / norm\n    CMC = CMC.float()\n    CMC = CMC / norm\n    print('Rank@1:{:.1f}, rank@5:{:.1f}, mAP:{:.2f}'.format(100 * CMC[0], 100 * CMC[4], ap))\n    return (CMC, ap)"
        ]
    },
    {
        "func_name": "evaluate_helper",
        "original": "def evaluate_helper(score, ql, qc, gl, gc, is_market1501=False):\n    assert type(gl) == np.ndarray, 'Input gl has to be a numpy ndarray'\n    assert type(gc) == np.ndarray, 'Input gc has to be a numpy ndarray'\n    index = np.argsort(score)\n    query_index = np.argwhere(gl == ql)\n    camera_index = np.argwhere(gc == qc)\n    good_index = np.setdiff1d(query_index, camera_index, assume_unique=True)\n    junk_index2 = np.intersect1d(query_index, camera_index)\n    if is_market1501:\n        junk_index1a = np.argwhere(gl == -1)\n        junk_index1b = np.argwhere(gl == '-1')\n        junk_index1 = np.append(junk_index1a, junk_index1b)\n        junk_index = np.append(junk_index2, junk_index1)\n    else:\n        junk_index = junk_index2\n    CMC_tmp = compute_mAP(index, good_index, junk_index)\n    return CMC_tmp",
        "mutated": [
            "def evaluate_helper(score, ql, qc, gl, gc, is_market1501=False):\n    if False:\n        i = 10\n    assert type(gl) == np.ndarray, 'Input gl has to be a numpy ndarray'\n    assert type(gc) == np.ndarray, 'Input gc has to be a numpy ndarray'\n    index = np.argsort(score)\n    query_index = np.argwhere(gl == ql)\n    camera_index = np.argwhere(gc == qc)\n    good_index = np.setdiff1d(query_index, camera_index, assume_unique=True)\n    junk_index2 = np.intersect1d(query_index, camera_index)\n    if is_market1501:\n        junk_index1a = np.argwhere(gl == -1)\n        junk_index1b = np.argwhere(gl == '-1')\n        junk_index1 = np.append(junk_index1a, junk_index1b)\n        junk_index = np.append(junk_index2, junk_index1)\n    else:\n        junk_index = junk_index2\n    CMC_tmp = compute_mAP(index, good_index, junk_index)\n    return CMC_tmp",
            "def evaluate_helper(score, ql, qc, gl, gc, is_market1501=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert type(gl) == np.ndarray, 'Input gl has to be a numpy ndarray'\n    assert type(gc) == np.ndarray, 'Input gc has to be a numpy ndarray'\n    index = np.argsort(score)\n    query_index = np.argwhere(gl == ql)\n    camera_index = np.argwhere(gc == qc)\n    good_index = np.setdiff1d(query_index, camera_index, assume_unique=True)\n    junk_index2 = np.intersect1d(query_index, camera_index)\n    if is_market1501:\n        junk_index1a = np.argwhere(gl == -1)\n        junk_index1b = np.argwhere(gl == '-1')\n        junk_index1 = np.append(junk_index1a, junk_index1b)\n        junk_index = np.append(junk_index2, junk_index1)\n    else:\n        junk_index = junk_index2\n    CMC_tmp = compute_mAP(index, good_index, junk_index)\n    return CMC_tmp",
            "def evaluate_helper(score, ql, qc, gl, gc, is_market1501=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert type(gl) == np.ndarray, 'Input gl has to be a numpy ndarray'\n    assert type(gc) == np.ndarray, 'Input gc has to be a numpy ndarray'\n    index = np.argsort(score)\n    query_index = np.argwhere(gl == ql)\n    camera_index = np.argwhere(gc == qc)\n    good_index = np.setdiff1d(query_index, camera_index, assume_unique=True)\n    junk_index2 = np.intersect1d(query_index, camera_index)\n    if is_market1501:\n        junk_index1a = np.argwhere(gl == -1)\n        junk_index1b = np.argwhere(gl == '-1')\n        junk_index1 = np.append(junk_index1a, junk_index1b)\n        junk_index = np.append(junk_index2, junk_index1)\n    else:\n        junk_index = junk_index2\n    CMC_tmp = compute_mAP(index, good_index, junk_index)\n    return CMC_tmp",
            "def evaluate_helper(score, ql, qc, gl, gc, is_market1501=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert type(gl) == np.ndarray, 'Input gl has to be a numpy ndarray'\n    assert type(gc) == np.ndarray, 'Input gc has to be a numpy ndarray'\n    index = np.argsort(score)\n    query_index = np.argwhere(gl == ql)\n    camera_index = np.argwhere(gc == qc)\n    good_index = np.setdiff1d(query_index, camera_index, assume_unique=True)\n    junk_index2 = np.intersect1d(query_index, camera_index)\n    if is_market1501:\n        junk_index1a = np.argwhere(gl == -1)\n        junk_index1b = np.argwhere(gl == '-1')\n        junk_index1 = np.append(junk_index1a, junk_index1b)\n        junk_index = np.append(junk_index2, junk_index1)\n    else:\n        junk_index = junk_index2\n    CMC_tmp = compute_mAP(index, good_index, junk_index)\n    return CMC_tmp",
            "def evaluate_helper(score, ql, qc, gl, gc, is_market1501=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert type(gl) == np.ndarray, 'Input gl has to be a numpy ndarray'\n    assert type(gc) == np.ndarray, 'Input gc has to be a numpy ndarray'\n    index = np.argsort(score)\n    query_index = np.argwhere(gl == ql)\n    camera_index = np.argwhere(gc == qc)\n    good_index = np.setdiff1d(query_index, camera_index, assume_unique=True)\n    junk_index2 = np.intersect1d(query_index, camera_index)\n    if is_market1501:\n        junk_index1a = np.argwhere(gl == -1)\n        junk_index1b = np.argwhere(gl == '-1')\n        junk_index1 = np.append(junk_index1a, junk_index1b)\n        junk_index = np.append(junk_index2, junk_index1)\n    else:\n        junk_index = junk_index2\n    CMC_tmp = compute_mAP(index, good_index, junk_index)\n    return CMC_tmp"
        ]
    },
    {
        "func_name": "compute_mAP",
        "original": "def compute_mAP(index, good_index, junk_index):\n    ap = 0\n    cmc = torch.IntTensor(len(index)).zero_()\n    if good_index.size == 0:\n        cmc[0] = -1\n        return (ap, cmc)\n    mask = np.in1d(index, junk_index, invert=True)\n    index = index[mask]\n    ngood = len(good_index)\n    mask = np.in1d(index, good_index)\n    rows_good = np.argwhere(mask)\n    rows_good = rows_good.flatten()\n    cmc[rows_good[0]:] = 1\n    for i in range(ngood):\n        d_recall = 1.0 / ngood\n        precision = (i + 1) * 1.0 / (rows_good[i] + 1)\n        if rows_good[i] != 0:\n            old_precision = i * 1.0 / rows_good[i]\n        else:\n            old_precision = 1.0\n        ap = ap + d_recall * (old_precision + precision) / 2\n    return (ap, cmc)",
        "mutated": [
            "def compute_mAP(index, good_index, junk_index):\n    if False:\n        i = 10\n    ap = 0\n    cmc = torch.IntTensor(len(index)).zero_()\n    if good_index.size == 0:\n        cmc[0] = -1\n        return (ap, cmc)\n    mask = np.in1d(index, junk_index, invert=True)\n    index = index[mask]\n    ngood = len(good_index)\n    mask = np.in1d(index, good_index)\n    rows_good = np.argwhere(mask)\n    rows_good = rows_good.flatten()\n    cmc[rows_good[0]:] = 1\n    for i in range(ngood):\n        d_recall = 1.0 / ngood\n        precision = (i + 1) * 1.0 / (rows_good[i] + 1)\n        if rows_good[i] != 0:\n            old_precision = i * 1.0 / rows_good[i]\n        else:\n            old_precision = 1.0\n        ap = ap + d_recall * (old_precision + precision) / 2\n    return (ap, cmc)",
            "def compute_mAP(index, good_index, junk_index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ap = 0\n    cmc = torch.IntTensor(len(index)).zero_()\n    if good_index.size == 0:\n        cmc[0] = -1\n        return (ap, cmc)\n    mask = np.in1d(index, junk_index, invert=True)\n    index = index[mask]\n    ngood = len(good_index)\n    mask = np.in1d(index, good_index)\n    rows_good = np.argwhere(mask)\n    rows_good = rows_good.flatten()\n    cmc[rows_good[0]:] = 1\n    for i in range(ngood):\n        d_recall = 1.0 / ngood\n        precision = (i + 1) * 1.0 / (rows_good[i] + 1)\n        if rows_good[i] != 0:\n            old_precision = i * 1.0 / rows_good[i]\n        else:\n            old_precision = 1.0\n        ap = ap + d_recall * (old_precision + precision) / 2\n    return (ap, cmc)",
            "def compute_mAP(index, good_index, junk_index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ap = 0\n    cmc = torch.IntTensor(len(index)).zero_()\n    if good_index.size == 0:\n        cmc[0] = -1\n        return (ap, cmc)\n    mask = np.in1d(index, junk_index, invert=True)\n    index = index[mask]\n    ngood = len(good_index)\n    mask = np.in1d(index, good_index)\n    rows_good = np.argwhere(mask)\n    rows_good = rows_good.flatten()\n    cmc[rows_good[0]:] = 1\n    for i in range(ngood):\n        d_recall = 1.0 / ngood\n        precision = (i + 1) * 1.0 / (rows_good[i] + 1)\n        if rows_good[i] != 0:\n            old_precision = i * 1.0 / rows_good[i]\n        else:\n            old_precision = 1.0\n        ap = ap + d_recall * (old_precision + precision) / 2\n    return (ap, cmc)",
            "def compute_mAP(index, good_index, junk_index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ap = 0\n    cmc = torch.IntTensor(len(index)).zero_()\n    if good_index.size == 0:\n        cmc[0] = -1\n        return (ap, cmc)\n    mask = np.in1d(index, junk_index, invert=True)\n    index = index[mask]\n    ngood = len(good_index)\n    mask = np.in1d(index, good_index)\n    rows_good = np.argwhere(mask)\n    rows_good = rows_good.flatten()\n    cmc[rows_good[0]:] = 1\n    for i in range(ngood):\n        d_recall = 1.0 / ngood\n        precision = (i + 1) * 1.0 / (rows_good[i] + 1)\n        if rows_good[i] != 0:\n            old_precision = i * 1.0 / rows_good[i]\n        else:\n            old_precision = 1.0\n        ap = ap + d_recall * (old_precision + precision) / 2\n    return (ap, cmc)",
            "def compute_mAP(index, good_index, junk_index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ap = 0\n    cmc = torch.IntTensor(len(index)).zero_()\n    if good_index.size == 0:\n        cmc[0] = -1\n        return (ap, cmc)\n    mask = np.in1d(index, junk_index, invert=True)\n    index = index[mask]\n    ngood = len(good_index)\n    mask = np.in1d(index, good_index)\n    rows_good = np.argwhere(mask)\n    rows_good = rows_good.flatten()\n    cmc[rows_good[0]:] = 1\n    for i in range(ngood):\n        d_recall = 1.0 / ngood\n        precision = (i + 1) * 1.0 / (rows_good[i] + 1)\n        if rows_good[i] != 0:\n            old_precision = i * 1.0 / rows_good[i]\n        else:\n            old_precision = 1.0\n        ap = ap + d_recall * (old_precision + precision) / 2\n    return (ap, cmc)"
        ]
    }
]