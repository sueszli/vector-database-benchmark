[
    {
        "func_name": "_infer_min_num_features",
        "original": "def _infer_min_num_features(model):\n    max_index = 0\n    for i in range(model.l):\n        j = 0\n        while model.SV[i][j].index != -1:\n            cur_last_index = model.SV[i][j].index\n            j += 1\n        if cur_last_index > max_index:\n            max_index = cur_last_index\n    return max_index",
        "mutated": [
            "def _infer_min_num_features(model):\n    if False:\n        i = 10\n    max_index = 0\n    for i in range(model.l):\n        j = 0\n        while model.SV[i][j].index != -1:\n            cur_last_index = model.SV[i][j].index\n            j += 1\n        if cur_last_index > max_index:\n            max_index = cur_last_index\n    return max_index",
            "def _infer_min_num_features(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    max_index = 0\n    for i in range(model.l):\n        j = 0\n        while model.SV[i][j].index != -1:\n            cur_last_index = model.SV[i][j].index\n            j += 1\n        if cur_last_index > max_index:\n            max_index = cur_last_index\n    return max_index",
            "def _infer_min_num_features(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    max_index = 0\n    for i in range(model.l):\n        j = 0\n        while model.SV[i][j].index != -1:\n            cur_last_index = model.SV[i][j].index\n            j += 1\n        if cur_last_index > max_index:\n            max_index = cur_last_index\n    return max_index",
            "def _infer_min_num_features(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    max_index = 0\n    for i in range(model.l):\n        j = 0\n        while model.SV[i][j].index != -1:\n            cur_last_index = model.SV[i][j].index\n            j += 1\n        if cur_last_index > max_index:\n            max_index = cur_last_index\n    return max_index",
            "def _infer_min_num_features(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    max_index = 0\n    for i in range(model.l):\n        j = 0\n        while model.SV[i][j].index != -1:\n            cur_last_index = model.SV[i][j].index\n            j += 1\n        if cur_last_index > max_index:\n            max_index = cur_last_index\n    return max_index"
        ]
    },
    {
        "func_name": "convert",
        "original": "def convert(libsvm_model, feature_names, target, input_length, probability):\n    \"\"\"Convert a svm model to the protobuf spec.\n\n    This currently supports:\n      * C-SVC\n      * nu-SVC\n      * Epsilon-SVR\n      * nu-SVR\n\n    Parameters\n    ----------\n    model_path: libsvm_model\n       Libsvm representation of the model.\n\n    feature_names : [str] | str\n        Names of each of the features.\n\n    target: str\n        Name of the predicted class column.\n\n    probability: str\n        Name of the class probability column. Only used for C-SVC and nu-SVC.\n\n    Returns\n    -------\n    model_spec: An object of type Model_pb.\n        Protobuf representation of the model\n    \"\"\"\n    if not _HAS_LIBSVM:\n        raise RuntimeError('libsvm not found. libsvm conversion API is disabled.')\n    from libsvm import svm as _svm\n    from ...proto import SVM_pb2\n    from ...proto import Model_pb2\n    from ...proto import FeatureTypes_pb2\n    from ...models import MLModel\n    svm_type_enum = libsvm_model.param.svm_type\n    export_spec = Model_pb2.Model()\n    export_spec.specificationVersion = SPECIFICATION_VERSION\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        svm = export_spec.supportVectorRegressor\n    else:\n        svm = export_spec.supportVectorClassifier\n    inferred_length = _infer_min_num_features(libsvm_model)\n    if isinstance(feature_names, _string_types):\n        if input_length == 'auto':\n            print(\"[WARNING] Infering an input length of %d. If this is not correct, use the 'input_length' parameter.\" % inferred_length)\n            input_length = inferred_length\n        elif inferred_length > input_length:\n            raise ValueError('An input length of %d was given, but the model requires an input of at least %d.' % (input_length, inferred_length))\n        input = export_spec.description.input.add()\n        input.name = feature_names\n        input.type.multiArrayType.shape.append(input_length)\n        input.type.multiArrayType.dataType = Model_pb2.ArrayFeatureType.DOUBLE\n    else:\n        if inferred_length > len(feature_names):\n            raise ValueError('%d feature names were given, but the model requires at least %d features.' % (len(feature_names), inferred_length))\n        for cur_input_name in feature_names:\n            input = export_spec.description.input.add()\n            input.name = cur_input_name\n            input.type.doubleType.MergeFromString(b'')\n    output = export_spec.description.output.add()\n    output.name = target\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        export_spec.description.predictedFeatureName = target\n        output.type.doubleType.MergeFromString(b'')\n        nr_class = 2\n    elif svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        export_spec.description.predictedFeatureName = target\n        output.type.int64Type.MergeFromString(b'')\n        nr_class = len(libsvm_model.get_labels())\n        for i in range(nr_class):\n            svm.numberOfSupportVectorsPerClass.append(libsvm_model.nSV[i])\n            svm.int64ClassLabels.vector.append(libsvm_model.label[i])\n        if probability and bool(libsvm_model.probA):\n            output = export_spec.description.output.add()\n            output.name = probability\n            output.type.dictionaryType.MergeFromString(b'')\n            output.type.dictionaryType.int64KeyType.MergeFromString(b'')\n            export_spec.description.predictedProbabilitiesName = probability\n    else:\n        raise ValueError('Only the following SVM types are supported: C_SVC, NU_SVC, EPSILON_SVR, NU_SVR')\n    if libsvm_model.param.kernel_type == _svm.LINEAR:\n        svm.kernel.linearKernel.MergeFromString(b'')\n    elif libsvm_model.param.kernel_type == _svm.RBF:\n        svm.kernel.rbfKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.POLY:\n        svm.kernel.polyKernel.degree = libsvm_model.param.degree\n        svm.kernel.polyKernel.c = libsvm_model.param.coef0\n        svm.kernel.polyKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.SIGMOID:\n        svm.kernel.sigmoidKernel.c = libsvm_model.param.coef0\n        svm.kernel.sigmoidKernel.gamma = libsvm_model.param.gamma\n    else:\n        raise ValueError('Unsupported kernel. The following kernel are supported: linear, RBF, polynomial and sigmoid.')\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        num_class_pairs = nr_class * (nr_class - 1) // 2\n        for i in range(num_class_pairs):\n            svm.rho.append(libsvm_model.rho[i])\n        if bool(libsvm_model.probA) and bool(libsvm_model.probB):\n            for i in range(num_class_pairs):\n                svm.probA.append(libsvm_model.probA[i])\n                svm.probB.append(libsvm_model.probB[i])\n    else:\n        svm.rho = libsvm_model.rho[0]\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        for _ in range(nr_class - 1):\n            svm.coefficients.add()\n        for i in range(libsvm_model.l):\n            for j in range(nr_class - 1):\n                svm.coefficients[j].alpha.append(libsvm_model.sv_coef[j][i])\n    else:\n        for i in range(libsvm_model.l):\n            svm.coefficients.alpha.append(libsvm_model.sv_coef[0][i])\n    for i in range(libsvm_model.l):\n        j = 0\n        cur_support_vector = svm.sparseSupportVectors.vectors.add()\n        while libsvm_model.SV[i][j].index != -1:\n            cur_node = cur_support_vector.nodes.add()\n            cur_node.index = libsvm_model.SV[i][j].index\n            cur_node.value = libsvm_model.SV[i][j].value\n            j += 1\n    model = MLModel(export_spec)\n    from libsvm import __version__ as libsvm_version\n    libsvm_version = 'libsvm=={0}'.format(libsvm_version)\n    model.user_defined_metadata[_METADATA_VERSION] = ct_version\n    model.user_defined_metadata[_METADATA_SOURCE] = libsvm_version\n    return model",
        "mutated": [
            "def convert(libsvm_model, feature_names, target, input_length, probability):\n    if False:\n        i = 10\n    'Convert a svm model to the protobuf spec.\\n\\n    This currently supports:\\n      * C-SVC\\n      * nu-SVC\\n      * Epsilon-SVR\\n      * nu-SVR\\n\\n    Parameters\\n    ----------\\n    model_path: libsvm_model\\n       Libsvm representation of the model.\\n\\n    feature_names : [str] | str\\n        Names of each of the features.\\n\\n    target: str\\n        Name of the predicted class column.\\n\\n    probability: str\\n        Name of the class probability column. Only used for C-SVC and nu-SVC.\\n\\n    Returns\\n    -------\\n    model_spec: An object of type Model_pb.\\n        Protobuf representation of the model\\n    '\n    if not _HAS_LIBSVM:\n        raise RuntimeError('libsvm not found. libsvm conversion API is disabled.')\n    from libsvm import svm as _svm\n    from ...proto import SVM_pb2\n    from ...proto import Model_pb2\n    from ...proto import FeatureTypes_pb2\n    from ...models import MLModel\n    svm_type_enum = libsvm_model.param.svm_type\n    export_spec = Model_pb2.Model()\n    export_spec.specificationVersion = SPECIFICATION_VERSION\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        svm = export_spec.supportVectorRegressor\n    else:\n        svm = export_spec.supportVectorClassifier\n    inferred_length = _infer_min_num_features(libsvm_model)\n    if isinstance(feature_names, _string_types):\n        if input_length == 'auto':\n            print(\"[WARNING] Infering an input length of %d. If this is not correct, use the 'input_length' parameter.\" % inferred_length)\n            input_length = inferred_length\n        elif inferred_length > input_length:\n            raise ValueError('An input length of %d was given, but the model requires an input of at least %d.' % (input_length, inferred_length))\n        input = export_spec.description.input.add()\n        input.name = feature_names\n        input.type.multiArrayType.shape.append(input_length)\n        input.type.multiArrayType.dataType = Model_pb2.ArrayFeatureType.DOUBLE\n    else:\n        if inferred_length > len(feature_names):\n            raise ValueError('%d feature names were given, but the model requires at least %d features.' % (len(feature_names), inferred_length))\n        for cur_input_name in feature_names:\n            input = export_spec.description.input.add()\n            input.name = cur_input_name\n            input.type.doubleType.MergeFromString(b'')\n    output = export_spec.description.output.add()\n    output.name = target\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        export_spec.description.predictedFeatureName = target\n        output.type.doubleType.MergeFromString(b'')\n        nr_class = 2\n    elif svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        export_spec.description.predictedFeatureName = target\n        output.type.int64Type.MergeFromString(b'')\n        nr_class = len(libsvm_model.get_labels())\n        for i in range(nr_class):\n            svm.numberOfSupportVectorsPerClass.append(libsvm_model.nSV[i])\n            svm.int64ClassLabels.vector.append(libsvm_model.label[i])\n        if probability and bool(libsvm_model.probA):\n            output = export_spec.description.output.add()\n            output.name = probability\n            output.type.dictionaryType.MergeFromString(b'')\n            output.type.dictionaryType.int64KeyType.MergeFromString(b'')\n            export_spec.description.predictedProbabilitiesName = probability\n    else:\n        raise ValueError('Only the following SVM types are supported: C_SVC, NU_SVC, EPSILON_SVR, NU_SVR')\n    if libsvm_model.param.kernel_type == _svm.LINEAR:\n        svm.kernel.linearKernel.MergeFromString(b'')\n    elif libsvm_model.param.kernel_type == _svm.RBF:\n        svm.kernel.rbfKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.POLY:\n        svm.kernel.polyKernel.degree = libsvm_model.param.degree\n        svm.kernel.polyKernel.c = libsvm_model.param.coef0\n        svm.kernel.polyKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.SIGMOID:\n        svm.kernel.sigmoidKernel.c = libsvm_model.param.coef0\n        svm.kernel.sigmoidKernel.gamma = libsvm_model.param.gamma\n    else:\n        raise ValueError('Unsupported kernel. The following kernel are supported: linear, RBF, polynomial and sigmoid.')\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        num_class_pairs = nr_class * (nr_class - 1) // 2\n        for i in range(num_class_pairs):\n            svm.rho.append(libsvm_model.rho[i])\n        if bool(libsvm_model.probA) and bool(libsvm_model.probB):\n            for i in range(num_class_pairs):\n                svm.probA.append(libsvm_model.probA[i])\n                svm.probB.append(libsvm_model.probB[i])\n    else:\n        svm.rho = libsvm_model.rho[0]\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        for _ in range(nr_class - 1):\n            svm.coefficients.add()\n        for i in range(libsvm_model.l):\n            for j in range(nr_class - 1):\n                svm.coefficients[j].alpha.append(libsvm_model.sv_coef[j][i])\n    else:\n        for i in range(libsvm_model.l):\n            svm.coefficients.alpha.append(libsvm_model.sv_coef[0][i])\n    for i in range(libsvm_model.l):\n        j = 0\n        cur_support_vector = svm.sparseSupportVectors.vectors.add()\n        while libsvm_model.SV[i][j].index != -1:\n            cur_node = cur_support_vector.nodes.add()\n            cur_node.index = libsvm_model.SV[i][j].index\n            cur_node.value = libsvm_model.SV[i][j].value\n            j += 1\n    model = MLModel(export_spec)\n    from libsvm import __version__ as libsvm_version\n    libsvm_version = 'libsvm=={0}'.format(libsvm_version)\n    model.user_defined_metadata[_METADATA_VERSION] = ct_version\n    model.user_defined_metadata[_METADATA_SOURCE] = libsvm_version\n    return model",
            "def convert(libsvm_model, feature_names, target, input_length, probability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert a svm model to the protobuf spec.\\n\\n    This currently supports:\\n      * C-SVC\\n      * nu-SVC\\n      * Epsilon-SVR\\n      * nu-SVR\\n\\n    Parameters\\n    ----------\\n    model_path: libsvm_model\\n       Libsvm representation of the model.\\n\\n    feature_names : [str] | str\\n        Names of each of the features.\\n\\n    target: str\\n        Name of the predicted class column.\\n\\n    probability: str\\n        Name of the class probability column. Only used for C-SVC and nu-SVC.\\n\\n    Returns\\n    -------\\n    model_spec: An object of type Model_pb.\\n        Protobuf representation of the model\\n    '\n    if not _HAS_LIBSVM:\n        raise RuntimeError('libsvm not found. libsvm conversion API is disabled.')\n    from libsvm import svm as _svm\n    from ...proto import SVM_pb2\n    from ...proto import Model_pb2\n    from ...proto import FeatureTypes_pb2\n    from ...models import MLModel\n    svm_type_enum = libsvm_model.param.svm_type\n    export_spec = Model_pb2.Model()\n    export_spec.specificationVersion = SPECIFICATION_VERSION\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        svm = export_spec.supportVectorRegressor\n    else:\n        svm = export_spec.supportVectorClassifier\n    inferred_length = _infer_min_num_features(libsvm_model)\n    if isinstance(feature_names, _string_types):\n        if input_length == 'auto':\n            print(\"[WARNING] Infering an input length of %d. If this is not correct, use the 'input_length' parameter.\" % inferred_length)\n            input_length = inferred_length\n        elif inferred_length > input_length:\n            raise ValueError('An input length of %d was given, but the model requires an input of at least %d.' % (input_length, inferred_length))\n        input = export_spec.description.input.add()\n        input.name = feature_names\n        input.type.multiArrayType.shape.append(input_length)\n        input.type.multiArrayType.dataType = Model_pb2.ArrayFeatureType.DOUBLE\n    else:\n        if inferred_length > len(feature_names):\n            raise ValueError('%d feature names were given, but the model requires at least %d features.' % (len(feature_names), inferred_length))\n        for cur_input_name in feature_names:\n            input = export_spec.description.input.add()\n            input.name = cur_input_name\n            input.type.doubleType.MergeFromString(b'')\n    output = export_spec.description.output.add()\n    output.name = target\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        export_spec.description.predictedFeatureName = target\n        output.type.doubleType.MergeFromString(b'')\n        nr_class = 2\n    elif svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        export_spec.description.predictedFeatureName = target\n        output.type.int64Type.MergeFromString(b'')\n        nr_class = len(libsvm_model.get_labels())\n        for i in range(nr_class):\n            svm.numberOfSupportVectorsPerClass.append(libsvm_model.nSV[i])\n            svm.int64ClassLabels.vector.append(libsvm_model.label[i])\n        if probability and bool(libsvm_model.probA):\n            output = export_spec.description.output.add()\n            output.name = probability\n            output.type.dictionaryType.MergeFromString(b'')\n            output.type.dictionaryType.int64KeyType.MergeFromString(b'')\n            export_spec.description.predictedProbabilitiesName = probability\n    else:\n        raise ValueError('Only the following SVM types are supported: C_SVC, NU_SVC, EPSILON_SVR, NU_SVR')\n    if libsvm_model.param.kernel_type == _svm.LINEAR:\n        svm.kernel.linearKernel.MergeFromString(b'')\n    elif libsvm_model.param.kernel_type == _svm.RBF:\n        svm.kernel.rbfKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.POLY:\n        svm.kernel.polyKernel.degree = libsvm_model.param.degree\n        svm.kernel.polyKernel.c = libsvm_model.param.coef0\n        svm.kernel.polyKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.SIGMOID:\n        svm.kernel.sigmoidKernel.c = libsvm_model.param.coef0\n        svm.kernel.sigmoidKernel.gamma = libsvm_model.param.gamma\n    else:\n        raise ValueError('Unsupported kernel. The following kernel are supported: linear, RBF, polynomial and sigmoid.')\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        num_class_pairs = nr_class * (nr_class - 1) // 2\n        for i in range(num_class_pairs):\n            svm.rho.append(libsvm_model.rho[i])\n        if bool(libsvm_model.probA) and bool(libsvm_model.probB):\n            for i in range(num_class_pairs):\n                svm.probA.append(libsvm_model.probA[i])\n                svm.probB.append(libsvm_model.probB[i])\n    else:\n        svm.rho = libsvm_model.rho[0]\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        for _ in range(nr_class - 1):\n            svm.coefficients.add()\n        for i in range(libsvm_model.l):\n            for j in range(nr_class - 1):\n                svm.coefficients[j].alpha.append(libsvm_model.sv_coef[j][i])\n    else:\n        for i in range(libsvm_model.l):\n            svm.coefficients.alpha.append(libsvm_model.sv_coef[0][i])\n    for i in range(libsvm_model.l):\n        j = 0\n        cur_support_vector = svm.sparseSupportVectors.vectors.add()\n        while libsvm_model.SV[i][j].index != -1:\n            cur_node = cur_support_vector.nodes.add()\n            cur_node.index = libsvm_model.SV[i][j].index\n            cur_node.value = libsvm_model.SV[i][j].value\n            j += 1\n    model = MLModel(export_spec)\n    from libsvm import __version__ as libsvm_version\n    libsvm_version = 'libsvm=={0}'.format(libsvm_version)\n    model.user_defined_metadata[_METADATA_VERSION] = ct_version\n    model.user_defined_metadata[_METADATA_SOURCE] = libsvm_version\n    return model",
            "def convert(libsvm_model, feature_names, target, input_length, probability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert a svm model to the protobuf spec.\\n\\n    This currently supports:\\n      * C-SVC\\n      * nu-SVC\\n      * Epsilon-SVR\\n      * nu-SVR\\n\\n    Parameters\\n    ----------\\n    model_path: libsvm_model\\n       Libsvm representation of the model.\\n\\n    feature_names : [str] | str\\n        Names of each of the features.\\n\\n    target: str\\n        Name of the predicted class column.\\n\\n    probability: str\\n        Name of the class probability column. Only used for C-SVC and nu-SVC.\\n\\n    Returns\\n    -------\\n    model_spec: An object of type Model_pb.\\n        Protobuf representation of the model\\n    '\n    if not _HAS_LIBSVM:\n        raise RuntimeError('libsvm not found. libsvm conversion API is disabled.')\n    from libsvm import svm as _svm\n    from ...proto import SVM_pb2\n    from ...proto import Model_pb2\n    from ...proto import FeatureTypes_pb2\n    from ...models import MLModel\n    svm_type_enum = libsvm_model.param.svm_type\n    export_spec = Model_pb2.Model()\n    export_spec.specificationVersion = SPECIFICATION_VERSION\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        svm = export_spec.supportVectorRegressor\n    else:\n        svm = export_spec.supportVectorClassifier\n    inferred_length = _infer_min_num_features(libsvm_model)\n    if isinstance(feature_names, _string_types):\n        if input_length == 'auto':\n            print(\"[WARNING] Infering an input length of %d. If this is not correct, use the 'input_length' parameter.\" % inferred_length)\n            input_length = inferred_length\n        elif inferred_length > input_length:\n            raise ValueError('An input length of %d was given, but the model requires an input of at least %d.' % (input_length, inferred_length))\n        input = export_spec.description.input.add()\n        input.name = feature_names\n        input.type.multiArrayType.shape.append(input_length)\n        input.type.multiArrayType.dataType = Model_pb2.ArrayFeatureType.DOUBLE\n    else:\n        if inferred_length > len(feature_names):\n            raise ValueError('%d feature names were given, but the model requires at least %d features.' % (len(feature_names), inferred_length))\n        for cur_input_name in feature_names:\n            input = export_spec.description.input.add()\n            input.name = cur_input_name\n            input.type.doubleType.MergeFromString(b'')\n    output = export_spec.description.output.add()\n    output.name = target\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        export_spec.description.predictedFeatureName = target\n        output.type.doubleType.MergeFromString(b'')\n        nr_class = 2\n    elif svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        export_spec.description.predictedFeatureName = target\n        output.type.int64Type.MergeFromString(b'')\n        nr_class = len(libsvm_model.get_labels())\n        for i in range(nr_class):\n            svm.numberOfSupportVectorsPerClass.append(libsvm_model.nSV[i])\n            svm.int64ClassLabels.vector.append(libsvm_model.label[i])\n        if probability and bool(libsvm_model.probA):\n            output = export_spec.description.output.add()\n            output.name = probability\n            output.type.dictionaryType.MergeFromString(b'')\n            output.type.dictionaryType.int64KeyType.MergeFromString(b'')\n            export_spec.description.predictedProbabilitiesName = probability\n    else:\n        raise ValueError('Only the following SVM types are supported: C_SVC, NU_SVC, EPSILON_SVR, NU_SVR')\n    if libsvm_model.param.kernel_type == _svm.LINEAR:\n        svm.kernel.linearKernel.MergeFromString(b'')\n    elif libsvm_model.param.kernel_type == _svm.RBF:\n        svm.kernel.rbfKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.POLY:\n        svm.kernel.polyKernel.degree = libsvm_model.param.degree\n        svm.kernel.polyKernel.c = libsvm_model.param.coef0\n        svm.kernel.polyKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.SIGMOID:\n        svm.kernel.sigmoidKernel.c = libsvm_model.param.coef0\n        svm.kernel.sigmoidKernel.gamma = libsvm_model.param.gamma\n    else:\n        raise ValueError('Unsupported kernel. The following kernel are supported: linear, RBF, polynomial and sigmoid.')\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        num_class_pairs = nr_class * (nr_class - 1) // 2\n        for i in range(num_class_pairs):\n            svm.rho.append(libsvm_model.rho[i])\n        if bool(libsvm_model.probA) and bool(libsvm_model.probB):\n            for i in range(num_class_pairs):\n                svm.probA.append(libsvm_model.probA[i])\n                svm.probB.append(libsvm_model.probB[i])\n    else:\n        svm.rho = libsvm_model.rho[0]\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        for _ in range(nr_class - 1):\n            svm.coefficients.add()\n        for i in range(libsvm_model.l):\n            for j in range(nr_class - 1):\n                svm.coefficients[j].alpha.append(libsvm_model.sv_coef[j][i])\n    else:\n        for i in range(libsvm_model.l):\n            svm.coefficients.alpha.append(libsvm_model.sv_coef[0][i])\n    for i in range(libsvm_model.l):\n        j = 0\n        cur_support_vector = svm.sparseSupportVectors.vectors.add()\n        while libsvm_model.SV[i][j].index != -1:\n            cur_node = cur_support_vector.nodes.add()\n            cur_node.index = libsvm_model.SV[i][j].index\n            cur_node.value = libsvm_model.SV[i][j].value\n            j += 1\n    model = MLModel(export_spec)\n    from libsvm import __version__ as libsvm_version\n    libsvm_version = 'libsvm=={0}'.format(libsvm_version)\n    model.user_defined_metadata[_METADATA_VERSION] = ct_version\n    model.user_defined_metadata[_METADATA_SOURCE] = libsvm_version\n    return model",
            "def convert(libsvm_model, feature_names, target, input_length, probability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert a svm model to the protobuf spec.\\n\\n    This currently supports:\\n      * C-SVC\\n      * nu-SVC\\n      * Epsilon-SVR\\n      * nu-SVR\\n\\n    Parameters\\n    ----------\\n    model_path: libsvm_model\\n       Libsvm representation of the model.\\n\\n    feature_names : [str] | str\\n        Names of each of the features.\\n\\n    target: str\\n        Name of the predicted class column.\\n\\n    probability: str\\n        Name of the class probability column. Only used for C-SVC and nu-SVC.\\n\\n    Returns\\n    -------\\n    model_spec: An object of type Model_pb.\\n        Protobuf representation of the model\\n    '\n    if not _HAS_LIBSVM:\n        raise RuntimeError('libsvm not found. libsvm conversion API is disabled.')\n    from libsvm import svm as _svm\n    from ...proto import SVM_pb2\n    from ...proto import Model_pb2\n    from ...proto import FeatureTypes_pb2\n    from ...models import MLModel\n    svm_type_enum = libsvm_model.param.svm_type\n    export_spec = Model_pb2.Model()\n    export_spec.specificationVersion = SPECIFICATION_VERSION\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        svm = export_spec.supportVectorRegressor\n    else:\n        svm = export_spec.supportVectorClassifier\n    inferred_length = _infer_min_num_features(libsvm_model)\n    if isinstance(feature_names, _string_types):\n        if input_length == 'auto':\n            print(\"[WARNING] Infering an input length of %d. If this is not correct, use the 'input_length' parameter.\" % inferred_length)\n            input_length = inferred_length\n        elif inferred_length > input_length:\n            raise ValueError('An input length of %d was given, but the model requires an input of at least %d.' % (input_length, inferred_length))\n        input = export_spec.description.input.add()\n        input.name = feature_names\n        input.type.multiArrayType.shape.append(input_length)\n        input.type.multiArrayType.dataType = Model_pb2.ArrayFeatureType.DOUBLE\n    else:\n        if inferred_length > len(feature_names):\n            raise ValueError('%d feature names were given, but the model requires at least %d features.' % (len(feature_names), inferred_length))\n        for cur_input_name in feature_names:\n            input = export_spec.description.input.add()\n            input.name = cur_input_name\n            input.type.doubleType.MergeFromString(b'')\n    output = export_spec.description.output.add()\n    output.name = target\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        export_spec.description.predictedFeatureName = target\n        output.type.doubleType.MergeFromString(b'')\n        nr_class = 2\n    elif svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        export_spec.description.predictedFeatureName = target\n        output.type.int64Type.MergeFromString(b'')\n        nr_class = len(libsvm_model.get_labels())\n        for i in range(nr_class):\n            svm.numberOfSupportVectorsPerClass.append(libsvm_model.nSV[i])\n            svm.int64ClassLabels.vector.append(libsvm_model.label[i])\n        if probability and bool(libsvm_model.probA):\n            output = export_spec.description.output.add()\n            output.name = probability\n            output.type.dictionaryType.MergeFromString(b'')\n            output.type.dictionaryType.int64KeyType.MergeFromString(b'')\n            export_spec.description.predictedProbabilitiesName = probability\n    else:\n        raise ValueError('Only the following SVM types are supported: C_SVC, NU_SVC, EPSILON_SVR, NU_SVR')\n    if libsvm_model.param.kernel_type == _svm.LINEAR:\n        svm.kernel.linearKernel.MergeFromString(b'')\n    elif libsvm_model.param.kernel_type == _svm.RBF:\n        svm.kernel.rbfKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.POLY:\n        svm.kernel.polyKernel.degree = libsvm_model.param.degree\n        svm.kernel.polyKernel.c = libsvm_model.param.coef0\n        svm.kernel.polyKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.SIGMOID:\n        svm.kernel.sigmoidKernel.c = libsvm_model.param.coef0\n        svm.kernel.sigmoidKernel.gamma = libsvm_model.param.gamma\n    else:\n        raise ValueError('Unsupported kernel. The following kernel are supported: linear, RBF, polynomial and sigmoid.')\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        num_class_pairs = nr_class * (nr_class - 1) // 2\n        for i in range(num_class_pairs):\n            svm.rho.append(libsvm_model.rho[i])\n        if bool(libsvm_model.probA) and bool(libsvm_model.probB):\n            for i in range(num_class_pairs):\n                svm.probA.append(libsvm_model.probA[i])\n                svm.probB.append(libsvm_model.probB[i])\n    else:\n        svm.rho = libsvm_model.rho[0]\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        for _ in range(nr_class - 1):\n            svm.coefficients.add()\n        for i in range(libsvm_model.l):\n            for j in range(nr_class - 1):\n                svm.coefficients[j].alpha.append(libsvm_model.sv_coef[j][i])\n    else:\n        for i in range(libsvm_model.l):\n            svm.coefficients.alpha.append(libsvm_model.sv_coef[0][i])\n    for i in range(libsvm_model.l):\n        j = 0\n        cur_support_vector = svm.sparseSupportVectors.vectors.add()\n        while libsvm_model.SV[i][j].index != -1:\n            cur_node = cur_support_vector.nodes.add()\n            cur_node.index = libsvm_model.SV[i][j].index\n            cur_node.value = libsvm_model.SV[i][j].value\n            j += 1\n    model = MLModel(export_spec)\n    from libsvm import __version__ as libsvm_version\n    libsvm_version = 'libsvm=={0}'.format(libsvm_version)\n    model.user_defined_metadata[_METADATA_VERSION] = ct_version\n    model.user_defined_metadata[_METADATA_SOURCE] = libsvm_version\n    return model",
            "def convert(libsvm_model, feature_names, target, input_length, probability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert a svm model to the protobuf spec.\\n\\n    This currently supports:\\n      * C-SVC\\n      * nu-SVC\\n      * Epsilon-SVR\\n      * nu-SVR\\n\\n    Parameters\\n    ----------\\n    model_path: libsvm_model\\n       Libsvm representation of the model.\\n\\n    feature_names : [str] | str\\n        Names of each of the features.\\n\\n    target: str\\n        Name of the predicted class column.\\n\\n    probability: str\\n        Name of the class probability column. Only used for C-SVC and nu-SVC.\\n\\n    Returns\\n    -------\\n    model_spec: An object of type Model_pb.\\n        Protobuf representation of the model\\n    '\n    if not _HAS_LIBSVM:\n        raise RuntimeError('libsvm not found. libsvm conversion API is disabled.')\n    from libsvm import svm as _svm\n    from ...proto import SVM_pb2\n    from ...proto import Model_pb2\n    from ...proto import FeatureTypes_pb2\n    from ...models import MLModel\n    svm_type_enum = libsvm_model.param.svm_type\n    export_spec = Model_pb2.Model()\n    export_spec.specificationVersion = SPECIFICATION_VERSION\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        svm = export_spec.supportVectorRegressor\n    else:\n        svm = export_spec.supportVectorClassifier\n    inferred_length = _infer_min_num_features(libsvm_model)\n    if isinstance(feature_names, _string_types):\n        if input_length == 'auto':\n            print(\"[WARNING] Infering an input length of %d. If this is not correct, use the 'input_length' parameter.\" % inferred_length)\n            input_length = inferred_length\n        elif inferred_length > input_length:\n            raise ValueError('An input length of %d was given, but the model requires an input of at least %d.' % (input_length, inferred_length))\n        input = export_spec.description.input.add()\n        input.name = feature_names\n        input.type.multiArrayType.shape.append(input_length)\n        input.type.multiArrayType.dataType = Model_pb2.ArrayFeatureType.DOUBLE\n    else:\n        if inferred_length > len(feature_names):\n            raise ValueError('%d feature names were given, but the model requires at least %d features.' % (len(feature_names), inferred_length))\n        for cur_input_name in feature_names:\n            input = export_spec.description.input.add()\n            input.name = cur_input_name\n            input.type.doubleType.MergeFromString(b'')\n    output = export_spec.description.output.add()\n    output.name = target\n    if svm_type_enum == _svm.EPSILON_SVR or svm_type_enum == _svm.NU_SVR:\n        export_spec.description.predictedFeatureName = target\n        output.type.doubleType.MergeFromString(b'')\n        nr_class = 2\n    elif svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        export_spec.description.predictedFeatureName = target\n        output.type.int64Type.MergeFromString(b'')\n        nr_class = len(libsvm_model.get_labels())\n        for i in range(nr_class):\n            svm.numberOfSupportVectorsPerClass.append(libsvm_model.nSV[i])\n            svm.int64ClassLabels.vector.append(libsvm_model.label[i])\n        if probability and bool(libsvm_model.probA):\n            output = export_spec.description.output.add()\n            output.name = probability\n            output.type.dictionaryType.MergeFromString(b'')\n            output.type.dictionaryType.int64KeyType.MergeFromString(b'')\n            export_spec.description.predictedProbabilitiesName = probability\n    else:\n        raise ValueError('Only the following SVM types are supported: C_SVC, NU_SVC, EPSILON_SVR, NU_SVR')\n    if libsvm_model.param.kernel_type == _svm.LINEAR:\n        svm.kernel.linearKernel.MergeFromString(b'')\n    elif libsvm_model.param.kernel_type == _svm.RBF:\n        svm.kernel.rbfKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.POLY:\n        svm.kernel.polyKernel.degree = libsvm_model.param.degree\n        svm.kernel.polyKernel.c = libsvm_model.param.coef0\n        svm.kernel.polyKernel.gamma = libsvm_model.param.gamma\n    elif libsvm_model.param.kernel_type == _svm.SIGMOID:\n        svm.kernel.sigmoidKernel.c = libsvm_model.param.coef0\n        svm.kernel.sigmoidKernel.gamma = libsvm_model.param.gamma\n    else:\n        raise ValueError('Unsupported kernel. The following kernel are supported: linear, RBF, polynomial and sigmoid.')\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        num_class_pairs = nr_class * (nr_class - 1) // 2\n        for i in range(num_class_pairs):\n            svm.rho.append(libsvm_model.rho[i])\n        if bool(libsvm_model.probA) and bool(libsvm_model.probB):\n            for i in range(num_class_pairs):\n                svm.probA.append(libsvm_model.probA[i])\n                svm.probB.append(libsvm_model.probB[i])\n    else:\n        svm.rho = libsvm_model.rho[0]\n    if svm_type_enum == _svm.C_SVC or svm_type_enum == _svm.NU_SVC:\n        for _ in range(nr_class - 1):\n            svm.coefficients.add()\n        for i in range(libsvm_model.l):\n            for j in range(nr_class - 1):\n                svm.coefficients[j].alpha.append(libsvm_model.sv_coef[j][i])\n    else:\n        for i in range(libsvm_model.l):\n            svm.coefficients.alpha.append(libsvm_model.sv_coef[0][i])\n    for i in range(libsvm_model.l):\n        j = 0\n        cur_support_vector = svm.sparseSupportVectors.vectors.add()\n        while libsvm_model.SV[i][j].index != -1:\n            cur_node = cur_support_vector.nodes.add()\n            cur_node.index = libsvm_model.SV[i][j].index\n            cur_node.value = libsvm_model.SV[i][j].value\n            j += 1\n    model = MLModel(export_spec)\n    from libsvm import __version__ as libsvm_version\n    libsvm_version = 'libsvm=={0}'.format(libsvm_version)\n    model.user_defined_metadata[_METADATA_VERSION] = ct_version\n    model.user_defined_metadata[_METADATA_SOURCE] = libsvm_version\n    return model"
        ]
    }
]