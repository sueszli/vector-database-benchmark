[
    {
        "func_name": "getSettingDataString",
        "original": "def getSettingDataString(self) -> str:\n    return '{\\n            \"name\": \"Retract Continue\",\\n            \"key\": \"RetractContinue\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"extra_retraction_speed\":\\n                {\\n                    \"label\": \"Extra Retraction Ratio\",\\n                    \"description\": \"How much does it retract during the travel move, by ratio of the travel length.\",\\n                    \"type\": \"float\",\\n                    \"default_value\": 0.05\\n                }\\n            }\\n        }'",
        "mutated": [
            "def getSettingDataString(self) -> str:\n    if False:\n        i = 10\n    return '{\\n            \"name\": \"Retract Continue\",\\n            \"key\": \"RetractContinue\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"extra_retraction_speed\":\\n                {\\n                    \"label\": \"Extra Retraction Ratio\",\\n                    \"description\": \"How much does it retract during the travel move, by ratio of the travel length.\",\\n                    \"type\": \"float\",\\n                    \"default_value\": 0.05\\n                }\\n            }\\n        }'",
            "def getSettingDataString(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return '{\\n            \"name\": \"Retract Continue\",\\n            \"key\": \"RetractContinue\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"extra_retraction_speed\":\\n                {\\n                    \"label\": \"Extra Retraction Ratio\",\\n                    \"description\": \"How much does it retract during the travel move, by ratio of the travel length.\",\\n                    \"type\": \"float\",\\n                    \"default_value\": 0.05\\n                }\\n            }\\n        }'",
            "def getSettingDataString(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return '{\\n            \"name\": \"Retract Continue\",\\n            \"key\": \"RetractContinue\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"extra_retraction_speed\":\\n                {\\n                    \"label\": \"Extra Retraction Ratio\",\\n                    \"description\": \"How much does it retract during the travel move, by ratio of the travel length.\",\\n                    \"type\": \"float\",\\n                    \"default_value\": 0.05\\n                }\\n            }\\n        }'",
            "def getSettingDataString(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return '{\\n            \"name\": \"Retract Continue\",\\n            \"key\": \"RetractContinue\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"extra_retraction_speed\":\\n                {\\n                    \"label\": \"Extra Retraction Ratio\",\\n                    \"description\": \"How much does it retract during the travel move, by ratio of the travel length.\",\\n                    \"type\": \"float\",\\n                    \"default_value\": 0.05\\n                }\\n            }\\n        }'",
            "def getSettingDataString(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return '{\\n            \"name\": \"Retract Continue\",\\n            \"key\": \"RetractContinue\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"extra_retraction_speed\":\\n                {\\n                    \"label\": \"Extra Retraction Ratio\",\\n                    \"description\": \"How much does it retract during the travel move, by ratio of the travel length.\",\\n                    \"type\": \"float\",\\n                    \"default_value\": 0.05\\n                }\\n            }\\n        }'"
        ]
    },
    {
        "func_name": "_getTravelMove",
        "original": "def _getTravelMove(self, travel_move: str, default_pos: Vector) -> Tuple[Vector, float]:\n    travel = Vector(self.getValue(travel_move, 'X', default_pos.x), self.getValue(travel_move, 'Y', default_pos.y), self.getValue(travel_move, 'Z', default_pos.z))\n    f = self.getValue(travel_move, 'F', -1.0)\n    return (travel, f)",
        "mutated": [
            "def _getTravelMove(self, travel_move: str, default_pos: Vector) -> Tuple[Vector, float]:\n    if False:\n        i = 10\n    travel = Vector(self.getValue(travel_move, 'X', default_pos.x), self.getValue(travel_move, 'Y', default_pos.y), self.getValue(travel_move, 'Z', default_pos.z))\n    f = self.getValue(travel_move, 'F', -1.0)\n    return (travel, f)",
            "def _getTravelMove(self, travel_move: str, default_pos: Vector) -> Tuple[Vector, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    travel = Vector(self.getValue(travel_move, 'X', default_pos.x), self.getValue(travel_move, 'Y', default_pos.y), self.getValue(travel_move, 'Z', default_pos.z))\n    f = self.getValue(travel_move, 'F', -1.0)\n    return (travel, f)",
            "def _getTravelMove(self, travel_move: str, default_pos: Vector) -> Tuple[Vector, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    travel = Vector(self.getValue(travel_move, 'X', default_pos.x), self.getValue(travel_move, 'Y', default_pos.y), self.getValue(travel_move, 'Z', default_pos.z))\n    f = self.getValue(travel_move, 'F', -1.0)\n    return (travel, f)",
            "def _getTravelMove(self, travel_move: str, default_pos: Vector) -> Tuple[Vector, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    travel = Vector(self.getValue(travel_move, 'X', default_pos.x), self.getValue(travel_move, 'Y', default_pos.y), self.getValue(travel_move, 'Z', default_pos.z))\n    f = self.getValue(travel_move, 'F', -1.0)\n    return (travel, f)",
            "def _getTravelMove(self, travel_move: str, default_pos: Vector) -> Tuple[Vector, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    travel = Vector(self.getValue(travel_move, 'X', default_pos.x), self.getValue(travel_move, 'Y', default_pos.y), self.getValue(travel_move, 'Z', default_pos.z))\n    f = self.getValue(travel_move, 'F', -1.0)\n    return (travel, f)"
        ]
    },
    {
        "func_name": "_travelMoveString",
        "original": "def _travelMoveString(self, travel: Vector, f: float, e: float) -> str:\n    if f <= 0.0:\n        return f'G1 X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'\n    else:\n        return f'G1 F{f:.5f} X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'",
        "mutated": [
            "def _travelMoveString(self, travel: Vector, f: float, e: float) -> str:\n    if False:\n        i = 10\n    if f <= 0.0:\n        return f'G1 X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'\n    else:\n        return f'G1 F{f:.5f} X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'",
            "def _travelMoveString(self, travel: Vector, f: float, e: float) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if f <= 0.0:\n        return f'G1 X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'\n    else:\n        return f'G1 F{f:.5f} X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'",
            "def _travelMoveString(self, travel: Vector, f: float, e: float) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if f <= 0.0:\n        return f'G1 X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'\n    else:\n        return f'G1 F{f:.5f} X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'",
            "def _travelMoveString(self, travel: Vector, f: float, e: float) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if f <= 0.0:\n        return f'G1 X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'\n    else:\n        return f'G1 F{f:.5f} X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'",
            "def _travelMoveString(self, travel: Vector, f: float, e: float) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if f <= 0.0:\n        return f'G1 X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'\n    else:\n        return f'G1 F{f:.5f} X{travel.x:.5f} Y{travel.y:.5f} Z{travel.z:.5f} E{e:.5f}'"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, data: List[str]) -> List[str]:\n    current_e = 0.0\n    to_compensate = 0\n    is_active = False\n    current_pos = Vector(0.0, 0.0, 0.0)\n    last_pos = Vector(0.0, 0.0, 0.0)\n    extra_retraction_speed = self.getSettingValueByKey('extra_retraction_speed')\n    relative_extrusion = Application.getInstance().getGlobalContainerStack().getProperty('relative_extrusion', 'value')\n    for (layer_number, layer) in enumerate(data):\n        lines = layer.split('\\n')\n        for (line_number, line) in enumerate(lines):\n            code_g = self.getValue(line, 'G')\n            if code_g not in [0, 1]:\n                continue\n            last_pos = last_pos.set(current_pos.x, current_pos.y, current_pos.z)\n            current_pos = current_pos.set(self.getValue(line, 'X', current_pos.x), self.getValue(line, 'Y', current_pos.y), self.getValue(line, 'Z', current_pos.z))\n            last_e = current_e\n            e_value = self.getValue(line, 'E')\n            if e_value:\n                current_e = (current_e if relative_extrusion else 0) + e_value\n            if code_g == 1:\n                if last_e > current_e + 0.0001:\n                    is_active = True\n                    continue\n                elif relative_extrusion and is_active:\n                    (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                    lines[line_number] = self._travelMoveString(travel, f, to_compensate + e_value)\n                    to_compensate = 0.0\n                is_active = False\n            elif code_g == 0:\n                if not is_active:\n                    continue\n                (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                travel_length = (current_pos - last_pos).length()\n                extra_retract = travel_length * extra_retraction_speed\n                new_e = (0 if relative_extrusion else current_e) - extra_retract\n                to_compensate += extra_retract\n                current_e -= extra_retract\n                lines[line_number] = self._travelMoveString(travel, f, new_e)\n        new_layer = '\\n'.join(lines)\n        data[layer_number] = new_layer\n    return data",
        "mutated": [
            "def execute(self, data: List[str]) -> List[str]:\n    if False:\n        i = 10\n    current_e = 0.0\n    to_compensate = 0\n    is_active = False\n    current_pos = Vector(0.0, 0.0, 0.0)\n    last_pos = Vector(0.0, 0.0, 0.0)\n    extra_retraction_speed = self.getSettingValueByKey('extra_retraction_speed')\n    relative_extrusion = Application.getInstance().getGlobalContainerStack().getProperty('relative_extrusion', 'value')\n    for (layer_number, layer) in enumerate(data):\n        lines = layer.split('\\n')\n        for (line_number, line) in enumerate(lines):\n            code_g = self.getValue(line, 'G')\n            if code_g not in [0, 1]:\n                continue\n            last_pos = last_pos.set(current_pos.x, current_pos.y, current_pos.z)\n            current_pos = current_pos.set(self.getValue(line, 'X', current_pos.x), self.getValue(line, 'Y', current_pos.y), self.getValue(line, 'Z', current_pos.z))\n            last_e = current_e\n            e_value = self.getValue(line, 'E')\n            if e_value:\n                current_e = (current_e if relative_extrusion else 0) + e_value\n            if code_g == 1:\n                if last_e > current_e + 0.0001:\n                    is_active = True\n                    continue\n                elif relative_extrusion and is_active:\n                    (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                    lines[line_number] = self._travelMoveString(travel, f, to_compensate + e_value)\n                    to_compensate = 0.0\n                is_active = False\n            elif code_g == 0:\n                if not is_active:\n                    continue\n                (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                travel_length = (current_pos - last_pos).length()\n                extra_retract = travel_length * extra_retraction_speed\n                new_e = (0 if relative_extrusion else current_e) - extra_retract\n                to_compensate += extra_retract\n                current_e -= extra_retract\n                lines[line_number] = self._travelMoveString(travel, f, new_e)\n        new_layer = '\\n'.join(lines)\n        data[layer_number] = new_layer\n    return data",
            "def execute(self, data: List[str]) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    current_e = 0.0\n    to_compensate = 0\n    is_active = False\n    current_pos = Vector(0.0, 0.0, 0.0)\n    last_pos = Vector(0.0, 0.0, 0.0)\n    extra_retraction_speed = self.getSettingValueByKey('extra_retraction_speed')\n    relative_extrusion = Application.getInstance().getGlobalContainerStack().getProperty('relative_extrusion', 'value')\n    for (layer_number, layer) in enumerate(data):\n        lines = layer.split('\\n')\n        for (line_number, line) in enumerate(lines):\n            code_g = self.getValue(line, 'G')\n            if code_g not in [0, 1]:\n                continue\n            last_pos = last_pos.set(current_pos.x, current_pos.y, current_pos.z)\n            current_pos = current_pos.set(self.getValue(line, 'X', current_pos.x), self.getValue(line, 'Y', current_pos.y), self.getValue(line, 'Z', current_pos.z))\n            last_e = current_e\n            e_value = self.getValue(line, 'E')\n            if e_value:\n                current_e = (current_e if relative_extrusion else 0) + e_value\n            if code_g == 1:\n                if last_e > current_e + 0.0001:\n                    is_active = True\n                    continue\n                elif relative_extrusion and is_active:\n                    (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                    lines[line_number] = self._travelMoveString(travel, f, to_compensate + e_value)\n                    to_compensate = 0.0\n                is_active = False\n            elif code_g == 0:\n                if not is_active:\n                    continue\n                (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                travel_length = (current_pos - last_pos).length()\n                extra_retract = travel_length * extra_retraction_speed\n                new_e = (0 if relative_extrusion else current_e) - extra_retract\n                to_compensate += extra_retract\n                current_e -= extra_retract\n                lines[line_number] = self._travelMoveString(travel, f, new_e)\n        new_layer = '\\n'.join(lines)\n        data[layer_number] = new_layer\n    return data",
            "def execute(self, data: List[str]) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    current_e = 0.0\n    to_compensate = 0\n    is_active = False\n    current_pos = Vector(0.0, 0.0, 0.0)\n    last_pos = Vector(0.0, 0.0, 0.0)\n    extra_retraction_speed = self.getSettingValueByKey('extra_retraction_speed')\n    relative_extrusion = Application.getInstance().getGlobalContainerStack().getProperty('relative_extrusion', 'value')\n    for (layer_number, layer) in enumerate(data):\n        lines = layer.split('\\n')\n        for (line_number, line) in enumerate(lines):\n            code_g = self.getValue(line, 'G')\n            if code_g not in [0, 1]:\n                continue\n            last_pos = last_pos.set(current_pos.x, current_pos.y, current_pos.z)\n            current_pos = current_pos.set(self.getValue(line, 'X', current_pos.x), self.getValue(line, 'Y', current_pos.y), self.getValue(line, 'Z', current_pos.z))\n            last_e = current_e\n            e_value = self.getValue(line, 'E')\n            if e_value:\n                current_e = (current_e if relative_extrusion else 0) + e_value\n            if code_g == 1:\n                if last_e > current_e + 0.0001:\n                    is_active = True\n                    continue\n                elif relative_extrusion and is_active:\n                    (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                    lines[line_number] = self._travelMoveString(travel, f, to_compensate + e_value)\n                    to_compensate = 0.0\n                is_active = False\n            elif code_g == 0:\n                if not is_active:\n                    continue\n                (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                travel_length = (current_pos - last_pos).length()\n                extra_retract = travel_length * extra_retraction_speed\n                new_e = (0 if relative_extrusion else current_e) - extra_retract\n                to_compensate += extra_retract\n                current_e -= extra_retract\n                lines[line_number] = self._travelMoveString(travel, f, new_e)\n        new_layer = '\\n'.join(lines)\n        data[layer_number] = new_layer\n    return data",
            "def execute(self, data: List[str]) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    current_e = 0.0\n    to_compensate = 0\n    is_active = False\n    current_pos = Vector(0.0, 0.0, 0.0)\n    last_pos = Vector(0.0, 0.0, 0.0)\n    extra_retraction_speed = self.getSettingValueByKey('extra_retraction_speed')\n    relative_extrusion = Application.getInstance().getGlobalContainerStack().getProperty('relative_extrusion', 'value')\n    for (layer_number, layer) in enumerate(data):\n        lines = layer.split('\\n')\n        for (line_number, line) in enumerate(lines):\n            code_g = self.getValue(line, 'G')\n            if code_g not in [0, 1]:\n                continue\n            last_pos = last_pos.set(current_pos.x, current_pos.y, current_pos.z)\n            current_pos = current_pos.set(self.getValue(line, 'X', current_pos.x), self.getValue(line, 'Y', current_pos.y), self.getValue(line, 'Z', current_pos.z))\n            last_e = current_e\n            e_value = self.getValue(line, 'E')\n            if e_value:\n                current_e = (current_e if relative_extrusion else 0) + e_value\n            if code_g == 1:\n                if last_e > current_e + 0.0001:\n                    is_active = True\n                    continue\n                elif relative_extrusion and is_active:\n                    (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                    lines[line_number] = self._travelMoveString(travel, f, to_compensate + e_value)\n                    to_compensate = 0.0\n                is_active = False\n            elif code_g == 0:\n                if not is_active:\n                    continue\n                (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                travel_length = (current_pos - last_pos).length()\n                extra_retract = travel_length * extra_retraction_speed\n                new_e = (0 if relative_extrusion else current_e) - extra_retract\n                to_compensate += extra_retract\n                current_e -= extra_retract\n                lines[line_number] = self._travelMoveString(travel, f, new_e)\n        new_layer = '\\n'.join(lines)\n        data[layer_number] = new_layer\n    return data",
            "def execute(self, data: List[str]) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    current_e = 0.0\n    to_compensate = 0\n    is_active = False\n    current_pos = Vector(0.0, 0.0, 0.0)\n    last_pos = Vector(0.0, 0.0, 0.0)\n    extra_retraction_speed = self.getSettingValueByKey('extra_retraction_speed')\n    relative_extrusion = Application.getInstance().getGlobalContainerStack().getProperty('relative_extrusion', 'value')\n    for (layer_number, layer) in enumerate(data):\n        lines = layer.split('\\n')\n        for (line_number, line) in enumerate(lines):\n            code_g = self.getValue(line, 'G')\n            if code_g not in [0, 1]:\n                continue\n            last_pos = last_pos.set(current_pos.x, current_pos.y, current_pos.z)\n            current_pos = current_pos.set(self.getValue(line, 'X', current_pos.x), self.getValue(line, 'Y', current_pos.y), self.getValue(line, 'Z', current_pos.z))\n            last_e = current_e\n            e_value = self.getValue(line, 'E')\n            if e_value:\n                current_e = (current_e if relative_extrusion else 0) + e_value\n            if code_g == 1:\n                if last_e > current_e + 0.0001:\n                    is_active = True\n                    continue\n                elif relative_extrusion and is_active:\n                    (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                    lines[line_number] = self._travelMoveString(travel, f, to_compensate + e_value)\n                    to_compensate = 0.0\n                is_active = False\n            elif code_g == 0:\n                if not is_active:\n                    continue\n                (travel, f) = self._getTravelMove(lines[line_number], current_pos)\n                travel_length = (current_pos - last_pos).length()\n                extra_retract = travel_length * extra_retraction_speed\n                new_e = (0 if relative_extrusion else current_e) - extra_retract\n                to_compensate += extra_retract\n                current_e -= extra_retract\n                lines[line_number] = self._travelMoveString(travel, f, new_e)\n        new_layer = '\\n'.join(lines)\n        data[layer_number] = new_layer\n    return data"
        ]
    }
]