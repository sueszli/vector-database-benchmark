[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True, size_cls_agnostic=True):\n    super(GroupFree3DBBoxCoder, self).__init__(num_dir_bins=num_dir_bins, num_sizes=num_sizes, mean_sizes=mean_sizes, with_rot=with_rot)\n    self.size_cls_agnostic = size_cls_agnostic",
        "mutated": [
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True, size_cls_agnostic=True):\n    if False:\n        i = 10\n    super(GroupFree3DBBoxCoder, self).__init__(num_dir_bins=num_dir_bins, num_sizes=num_sizes, mean_sizes=mean_sizes, with_rot=with_rot)\n    self.size_cls_agnostic = size_cls_agnostic",
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True, size_cls_agnostic=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(GroupFree3DBBoxCoder, self).__init__(num_dir_bins=num_dir_bins, num_sizes=num_sizes, mean_sizes=mean_sizes, with_rot=with_rot)\n    self.size_cls_agnostic = size_cls_agnostic",
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True, size_cls_agnostic=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(GroupFree3DBBoxCoder, self).__init__(num_dir_bins=num_dir_bins, num_sizes=num_sizes, mean_sizes=mean_sizes, with_rot=with_rot)\n    self.size_cls_agnostic = size_cls_agnostic",
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True, size_cls_agnostic=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(GroupFree3DBBoxCoder, self).__init__(num_dir_bins=num_dir_bins, num_sizes=num_sizes, mean_sizes=mean_sizes, with_rot=with_rot)\n    self.size_cls_agnostic = size_cls_agnostic",
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True, size_cls_agnostic=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(GroupFree3DBBoxCoder, self).__init__(num_dir_bins=num_dir_bins, num_sizes=num_sizes, mean_sizes=mean_sizes, with_rot=with_rot)\n    self.size_cls_agnostic = size_cls_agnostic"
        ]
    },
    {
        "func_name": "encode",
        "original": "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    \"\"\"Encode ground truth to prediction targets.\n\n        Args:\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\n                with shape (n, 7).\n            gt_labels_3d (torch.Tensor): Ground truth classes.\n\n        Returns:\n            tuple: Targets of center, size and direction.\n        \"\"\"\n    center_target = gt_bboxes_3d.gravity_center\n    size_target = gt_bboxes_3d.dims\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
        "mutated": [
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_target = gt_bboxes_3d.dims\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_target = gt_bboxes_3d.dims\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_target = gt_bboxes_3d.dims\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_target = gt_bboxes_3d.dims\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_target = gt_bboxes_3d.dims\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_target, size_class_target, size_res_target, dir_class_target, dir_res_target)"
        ]
    },
    {
        "func_name": "decode",
        "original": "def decode(self, bbox_out, prefix=''):\n    \"\"\"Decode predicted parts to bbox3d.\n\n        Args:\n            bbox_out (dict): Predictions from model, should contain keys below.\n\n                - center: predicted bottom center of bboxes.\n                - dir_class: predicted bbox direction class.\n                - dir_res: predicted bbox direction residual.\n                - size_class: predicted bbox size class.\n                - size_res: predicted bbox size residual.\n                - size: predicted class-agnostic bbox size\n            prefix (str, optional): Decode predictions with specific prefix.\n                Defaults to ''.\n\n        Returns:\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\n        \"\"\"\n    center = bbox_out[f'{prefix}center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out[f'{prefix}dir_class'], -1)\n        dir_res = torch.gather(bbox_out[f'{prefix}dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    if self.size_cls_agnostic:\n        bbox_size = bbox_out[f'{prefix}size'].reshape(batch_size, num_proposal, 3)\n    else:\n        size_class = torch.argmax(bbox_out[f'{prefix}size_class'], -1, keepdim=True)\n        size_res = torch.gather(bbox_out[f'{prefix}size_res'], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n        mean_sizes = center.new_tensor(self.mean_sizes)\n        size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n        bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
        "mutated": [
            "def decode(self, bbox_out, prefix=''):\n    if False:\n        i = 10\n    \"Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n                - size: predicted class-agnostic bbox size\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        \"\n    center = bbox_out[f'{prefix}center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out[f'{prefix}dir_class'], -1)\n        dir_res = torch.gather(bbox_out[f'{prefix}dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    if self.size_cls_agnostic:\n        bbox_size = bbox_out[f'{prefix}size'].reshape(batch_size, num_proposal, 3)\n    else:\n        size_class = torch.argmax(bbox_out[f'{prefix}size_class'], -1, keepdim=True)\n        size_res = torch.gather(bbox_out[f'{prefix}size_res'], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n        mean_sizes = center.new_tensor(self.mean_sizes)\n        size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n        bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n                - size: predicted class-agnostic bbox size\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        \"\n    center = bbox_out[f'{prefix}center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out[f'{prefix}dir_class'], -1)\n        dir_res = torch.gather(bbox_out[f'{prefix}dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    if self.size_cls_agnostic:\n        bbox_size = bbox_out[f'{prefix}size'].reshape(batch_size, num_proposal, 3)\n    else:\n        size_class = torch.argmax(bbox_out[f'{prefix}size_class'], -1, keepdim=True)\n        size_res = torch.gather(bbox_out[f'{prefix}size_res'], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n        mean_sizes = center.new_tensor(self.mean_sizes)\n        size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n        bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n                - size: predicted class-agnostic bbox size\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        \"\n    center = bbox_out[f'{prefix}center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out[f'{prefix}dir_class'], -1)\n        dir_res = torch.gather(bbox_out[f'{prefix}dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    if self.size_cls_agnostic:\n        bbox_size = bbox_out[f'{prefix}size'].reshape(batch_size, num_proposal, 3)\n    else:\n        size_class = torch.argmax(bbox_out[f'{prefix}size_class'], -1, keepdim=True)\n        size_res = torch.gather(bbox_out[f'{prefix}size_res'], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n        mean_sizes = center.new_tensor(self.mean_sizes)\n        size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n        bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n                - size: predicted class-agnostic bbox size\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        \"\n    center = bbox_out[f'{prefix}center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out[f'{prefix}dir_class'], -1)\n        dir_res = torch.gather(bbox_out[f'{prefix}dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    if self.size_cls_agnostic:\n        bbox_size = bbox_out[f'{prefix}size'].reshape(batch_size, num_proposal, 3)\n    else:\n        size_class = torch.argmax(bbox_out[f'{prefix}size_class'], -1, keepdim=True)\n        size_res = torch.gather(bbox_out[f'{prefix}size_res'], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n        mean_sizes = center.new_tensor(self.mean_sizes)\n        size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n        bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n                - size: predicted class-agnostic bbox size\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        \"\n    center = bbox_out[f'{prefix}center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out[f'{prefix}dir_class'], -1)\n        dir_res = torch.gather(bbox_out[f'{prefix}dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    if self.size_cls_agnostic:\n        bbox_size = bbox_out[f'{prefix}size'].reshape(batch_size, num_proposal, 3)\n    else:\n        size_class = torch.argmax(bbox_out[f'{prefix}size_class'], -1, keepdim=True)\n        size_res = torch.gather(bbox_out[f'{prefix}size_res'], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n        mean_sizes = center.new_tensor(self.mean_sizes)\n        size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n        bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d"
        ]
    },
    {
        "func_name": "split_pred",
        "original": "def split_pred(self, cls_preds, reg_preds, base_xyz, prefix=''):\n    \"\"\"Split predicted features to specific parts.\n\n        Args:\n            cls_preds (torch.Tensor): Class predicted features to split.\n            reg_preds (torch.Tensor): Regression predicted features to split.\n            base_xyz (torch.Tensor): Coordinates of points.\n            prefix (str, optional): Decode predictions with specific prefix.\n                Defaults to ''.\n\n        Returns:\n            dict[str, torch.Tensor]: Split results.\n        \"\"\"\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results[f'{prefix}center_residual'] = reg_preds_trans[..., start:end].contiguous()\n    results[f'{prefix}center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results[f'{prefix}dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results[f'{prefix}dir_res_norm'] = dir_res_norm\n    results[f'{prefix}dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    if self.size_cls_agnostic:\n        end += 3\n        results[f'{prefix}size'] = reg_preds_trans[..., start:end].contiguous()\n    else:\n        end += self.num_sizes\n        results[f'{prefix}size_class'] = reg_preds_trans[..., start:end].contiguous()\n        start = end\n        end += self.num_sizes * 3\n        size_res_norm = reg_preds_trans[..., start:end]\n        (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n        size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n        start = end\n        results[f'{prefix}size_res_norm'] = size_res_norm.contiguous()\n        mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n        results[f'{prefix}size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    results[f'{prefix}obj_scores'] = cls_preds_trans[..., :1].contiguous()\n    results[f'{prefix}sem_scores'] = cls_preds_trans[..., 1:].contiguous()\n    return results",
        "mutated": [
            "def split_pred(self, cls_preds, reg_preds, base_xyz, prefix=''):\n    if False:\n        i = 10\n    \"Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        \"\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results[f'{prefix}center_residual'] = reg_preds_trans[..., start:end].contiguous()\n    results[f'{prefix}center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results[f'{prefix}dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results[f'{prefix}dir_res_norm'] = dir_res_norm\n    results[f'{prefix}dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    if self.size_cls_agnostic:\n        end += 3\n        results[f'{prefix}size'] = reg_preds_trans[..., start:end].contiguous()\n    else:\n        end += self.num_sizes\n        results[f'{prefix}size_class'] = reg_preds_trans[..., start:end].contiguous()\n        start = end\n        end += self.num_sizes * 3\n        size_res_norm = reg_preds_trans[..., start:end]\n        (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n        size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n        start = end\n        results[f'{prefix}size_res_norm'] = size_res_norm.contiguous()\n        mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n        results[f'{prefix}size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    results[f'{prefix}obj_scores'] = cls_preds_trans[..., :1].contiguous()\n    results[f'{prefix}sem_scores'] = cls_preds_trans[..., 1:].contiguous()\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        \"\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results[f'{prefix}center_residual'] = reg_preds_trans[..., start:end].contiguous()\n    results[f'{prefix}center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results[f'{prefix}dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results[f'{prefix}dir_res_norm'] = dir_res_norm\n    results[f'{prefix}dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    if self.size_cls_agnostic:\n        end += 3\n        results[f'{prefix}size'] = reg_preds_trans[..., start:end].contiguous()\n    else:\n        end += self.num_sizes\n        results[f'{prefix}size_class'] = reg_preds_trans[..., start:end].contiguous()\n        start = end\n        end += self.num_sizes * 3\n        size_res_norm = reg_preds_trans[..., start:end]\n        (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n        size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n        start = end\n        results[f'{prefix}size_res_norm'] = size_res_norm.contiguous()\n        mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n        results[f'{prefix}size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    results[f'{prefix}obj_scores'] = cls_preds_trans[..., :1].contiguous()\n    results[f'{prefix}sem_scores'] = cls_preds_trans[..., 1:].contiguous()\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        \"\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results[f'{prefix}center_residual'] = reg_preds_trans[..., start:end].contiguous()\n    results[f'{prefix}center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results[f'{prefix}dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results[f'{prefix}dir_res_norm'] = dir_res_norm\n    results[f'{prefix}dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    if self.size_cls_agnostic:\n        end += 3\n        results[f'{prefix}size'] = reg_preds_trans[..., start:end].contiguous()\n    else:\n        end += self.num_sizes\n        results[f'{prefix}size_class'] = reg_preds_trans[..., start:end].contiguous()\n        start = end\n        end += self.num_sizes * 3\n        size_res_norm = reg_preds_trans[..., start:end]\n        (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n        size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n        start = end\n        results[f'{prefix}size_res_norm'] = size_res_norm.contiguous()\n        mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n        results[f'{prefix}size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    results[f'{prefix}obj_scores'] = cls_preds_trans[..., :1].contiguous()\n    results[f'{prefix}sem_scores'] = cls_preds_trans[..., 1:].contiguous()\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        \"\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results[f'{prefix}center_residual'] = reg_preds_trans[..., start:end].contiguous()\n    results[f'{prefix}center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results[f'{prefix}dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results[f'{prefix}dir_res_norm'] = dir_res_norm\n    results[f'{prefix}dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    if self.size_cls_agnostic:\n        end += 3\n        results[f'{prefix}size'] = reg_preds_trans[..., start:end].contiguous()\n    else:\n        end += self.num_sizes\n        results[f'{prefix}size_class'] = reg_preds_trans[..., start:end].contiguous()\n        start = end\n        end += self.num_sizes * 3\n        size_res_norm = reg_preds_trans[..., start:end]\n        (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n        size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n        start = end\n        results[f'{prefix}size_res_norm'] = size_res_norm.contiguous()\n        mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n        results[f'{prefix}size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    results[f'{prefix}obj_scores'] = cls_preds_trans[..., :1].contiguous()\n    results[f'{prefix}sem_scores'] = cls_preds_trans[..., 1:].contiguous()\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n            prefix (str, optional): Decode predictions with specific prefix.\\n                Defaults to ''.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        \"\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results[f'{prefix}center_residual'] = reg_preds_trans[..., start:end].contiguous()\n    results[f'{prefix}center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results[f'{prefix}dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results[f'{prefix}dir_res_norm'] = dir_res_norm\n    results[f'{prefix}dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    if self.size_cls_agnostic:\n        end += 3\n        results[f'{prefix}size'] = reg_preds_trans[..., start:end].contiguous()\n    else:\n        end += self.num_sizes\n        results[f'{prefix}size_class'] = reg_preds_trans[..., start:end].contiguous()\n        start = end\n        end += self.num_sizes * 3\n        size_res_norm = reg_preds_trans[..., start:end]\n        (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n        size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n        start = end\n        results[f'{prefix}size_res_norm'] = size_res_norm.contiguous()\n        mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n        results[f'{prefix}size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    results[f'{prefix}obj_scores'] = cls_preds_trans[..., :1].contiguous()\n    results[f'{prefix}sem_scores'] = cls_preds_trans[..., 1:].contiguous()\n    return results"
        ]
    }
]