[
    {
        "func_name": "img_to_byte_array",
        "original": "def img_to_byte_array(img: Image) -> bytes:\n    buff = io.BytesIO()\n    img.save(buff, format='PNG')\n    return buff.getvalue()",
        "mutated": [
            "def img_to_byte_array(img: Image) -> bytes:\n    if False:\n        i = 10\n    buff = io.BytesIO()\n    img.save(buff, format='PNG')\n    return buff.getvalue()",
            "def img_to_byte_array(img: Image) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    buff = io.BytesIO()\n    img.save(buff, format='PNG')\n    return buff.getvalue()",
            "def img_to_byte_array(img: Image) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    buff = io.BytesIO()\n    img.save(buff, format='PNG')\n    return buff.getvalue()",
            "def img_to_byte_array(img: Image) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    buff = io.BytesIO()\n    img.save(buff, format='PNG')\n    return buff.getvalue()",
            "def img_to_byte_array(img: Image) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    buff = io.BytesIO()\n    img.save(buff, format='PNG')\n    return buff.getvalue()"
        ]
    },
    {
        "func_name": "rs_command",
        "original": "@click.command(name='b', help='for a byte stream as input')\n@click.option('-m', '--model', default='u2net', type=click.Choice(sessions_names), show_default=True, show_choices=True, help='model name')\n@click.option('-a', '--alpha-matting', is_flag=True, show_default=True, help='use alpha matting')\n@click.option('-af', '--alpha-matting-foreground-threshold', default=240, type=int, show_default=True, help='trimap fg threshold')\n@click.option('-ab', '--alpha-matting-background-threshold', default=10, type=int, show_default=True, help='trimap bg threshold')\n@click.option('-ae', '--alpha-matting-erode-size', default=10, type=int, show_default=True, help='erode size')\n@click.option('-om', '--only-mask', is_flag=True, show_default=True, help='output only the mask')\n@click.option('-ppm', '--post-process-mask', is_flag=True, show_default=True, help='post process the mask')\n@click.option('-bgc', '--bgcolor', default=None, type=(int, int, int, int), nargs=4, help='Background color (R G B A) to replace the removed background with')\n@click.option('-x', '--extras', type=str)\n@click.option('-o', '--output_specifier', type=str, help=\"printf-style specifier for output filenames (e.g. 'output-%d.png'))\")\n@click.argument('image_width', type=int)\n@click.argument('image_height', type=int)\ndef rs_command(model: str, extras: str, image_width: int, image_height: int, output_specifier: str, **kwargs) -> None:\n    \"\"\"\n    Command-line interface for processing images by removing the background using a specified model and generating a mask.\n\n    This CLI command takes several options and arguments to configure the background removal process and save the processed images.\n\n    Parameters:\n        model (str): The name of the model to use for background removal.\n        extras (str): Additional options in JSON format that can be passed to customize the background removal process.\n        image_width (int): The width of the input images in pixels.\n        image_height (int): The height of the input images in pixels.\n        output_specifier (str): A printf-style specifier for the output filenames. If specified, the processed images will be saved to the specified output directory with filenames generated using the specifier.\n        **kwargs: Additional keyword arguments that can be used to customize the background removal process.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        kwargs.update(json.loads(extras))\n    except Exception:\n        pass\n    session = new_session(model, **kwargs)\n    bytes_per_img = image_width * image_height * 3\n    if output_specifier:\n        output_dir = os.path.dirname(os.path.abspath(os.path.expanduser(output_specifier)))\n        if not os.path.isdir(output_dir):\n            os.makedirs(output_dir, exist_ok=True)\n\n    def img_to_byte_array(img: Image) -> bytes:\n        buff = io.BytesIO()\n        img.save(buff, format='PNG')\n        return buff.getvalue()\n\n    async def connect_stdin_stdout():\n        loop = asyncio.get_event_loop()\n        reader = asyncio.StreamReader()\n        protocol = asyncio.StreamReaderProtocol(reader)\n        await loop.connect_read_pipe(lambda : protocol, sys.stdin)\n        (w_transport, w_protocol) = await loop.connect_write_pipe(asyncio.streams.FlowControlMixin, sys.stdout)\n        writer = asyncio.StreamWriter(w_transport, w_protocol, reader, loop)\n        return (reader, writer)\n\n    async def main():\n        (reader, writer) = await connect_stdin_stdout()\n        idx = 0\n        while True:\n            try:\n                img_bytes = await reader.readexactly(bytes_per_img)\n                if not img_bytes:\n                    break\n                img = Image.frombytes('RGB', (image_width, image_height), img_bytes)\n                output = remove(img, session=session, **kwargs)\n                if output_specifier:\n                    output.save(output_specifier % idx, format='PNG')\n                else:\n                    writer.write(img_to_byte_array(output))\n                idx += 1\n            except asyncio.IncompleteReadError:\n                break\n    asyncio.run(main())",
        "mutated": [
            "@click.command(name='b', help='for a byte stream as input')\n@click.option('-m', '--model', default='u2net', type=click.Choice(sessions_names), show_default=True, show_choices=True, help='model name')\n@click.option('-a', '--alpha-matting', is_flag=True, show_default=True, help='use alpha matting')\n@click.option('-af', '--alpha-matting-foreground-threshold', default=240, type=int, show_default=True, help='trimap fg threshold')\n@click.option('-ab', '--alpha-matting-background-threshold', default=10, type=int, show_default=True, help='trimap bg threshold')\n@click.option('-ae', '--alpha-matting-erode-size', default=10, type=int, show_default=True, help='erode size')\n@click.option('-om', '--only-mask', is_flag=True, show_default=True, help='output only the mask')\n@click.option('-ppm', '--post-process-mask', is_flag=True, show_default=True, help='post process the mask')\n@click.option('-bgc', '--bgcolor', default=None, type=(int, int, int, int), nargs=4, help='Background color (R G B A) to replace the removed background with')\n@click.option('-x', '--extras', type=str)\n@click.option('-o', '--output_specifier', type=str, help=\"printf-style specifier for output filenames (e.g. 'output-%d.png'))\")\n@click.argument('image_width', type=int)\n@click.argument('image_height', type=int)\ndef rs_command(model: str, extras: str, image_width: int, image_height: int, output_specifier: str, **kwargs) -> None:\n    if False:\n        i = 10\n    '\\n    Command-line interface for processing images by removing the background using a specified model and generating a mask.\\n\\n    This CLI command takes several options and arguments to configure the background removal process and save the processed images.\\n\\n    Parameters:\\n        model (str): The name of the model to use for background removal.\\n        extras (str): Additional options in JSON format that can be passed to customize the background removal process.\\n        image_width (int): The width of the input images in pixels.\\n        image_height (int): The height of the input images in pixels.\\n        output_specifier (str): A printf-style specifier for the output filenames. If specified, the processed images will be saved to the specified output directory with filenames generated using the specifier.\\n        **kwargs: Additional keyword arguments that can be used to customize the background removal process.\\n\\n    Returns:\\n        None\\n    '\n    try:\n        kwargs.update(json.loads(extras))\n    except Exception:\n        pass\n    session = new_session(model, **kwargs)\n    bytes_per_img = image_width * image_height * 3\n    if output_specifier:\n        output_dir = os.path.dirname(os.path.abspath(os.path.expanduser(output_specifier)))\n        if not os.path.isdir(output_dir):\n            os.makedirs(output_dir, exist_ok=True)\n\n    def img_to_byte_array(img: Image) -> bytes:\n        buff = io.BytesIO()\n        img.save(buff, format='PNG')\n        return buff.getvalue()\n\n    async def connect_stdin_stdout():\n        loop = asyncio.get_event_loop()\n        reader = asyncio.StreamReader()\n        protocol = asyncio.StreamReaderProtocol(reader)\n        await loop.connect_read_pipe(lambda : protocol, sys.stdin)\n        (w_transport, w_protocol) = await loop.connect_write_pipe(asyncio.streams.FlowControlMixin, sys.stdout)\n        writer = asyncio.StreamWriter(w_transport, w_protocol, reader, loop)\n        return (reader, writer)\n\n    async def main():\n        (reader, writer) = await connect_stdin_stdout()\n        idx = 0\n        while True:\n            try:\n                img_bytes = await reader.readexactly(bytes_per_img)\n                if not img_bytes:\n                    break\n                img = Image.frombytes('RGB', (image_width, image_height), img_bytes)\n                output = remove(img, session=session, **kwargs)\n                if output_specifier:\n                    output.save(output_specifier % idx, format='PNG')\n                else:\n                    writer.write(img_to_byte_array(output))\n                idx += 1\n            except asyncio.IncompleteReadError:\n                break\n    asyncio.run(main())",
            "@click.command(name='b', help='for a byte stream as input')\n@click.option('-m', '--model', default='u2net', type=click.Choice(sessions_names), show_default=True, show_choices=True, help='model name')\n@click.option('-a', '--alpha-matting', is_flag=True, show_default=True, help='use alpha matting')\n@click.option('-af', '--alpha-matting-foreground-threshold', default=240, type=int, show_default=True, help='trimap fg threshold')\n@click.option('-ab', '--alpha-matting-background-threshold', default=10, type=int, show_default=True, help='trimap bg threshold')\n@click.option('-ae', '--alpha-matting-erode-size', default=10, type=int, show_default=True, help='erode size')\n@click.option('-om', '--only-mask', is_flag=True, show_default=True, help='output only the mask')\n@click.option('-ppm', '--post-process-mask', is_flag=True, show_default=True, help='post process the mask')\n@click.option('-bgc', '--bgcolor', default=None, type=(int, int, int, int), nargs=4, help='Background color (R G B A) to replace the removed background with')\n@click.option('-x', '--extras', type=str)\n@click.option('-o', '--output_specifier', type=str, help=\"printf-style specifier for output filenames (e.g. 'output-%d.png'))\")\n@click.argument('image_width', type=int)\n@click.argument('image_height', type=int)\ndef rs_command(model: str, extras: str, image_width: int, image_height: int, output_specifier: str, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Command-line interface for processing images by removing the background using a specified model and generating a mask.\\n\\n    This CLI command takes several options and arguments to configure the background removal process and save the processed images.\\n\\n    Parameters:\\n        model (str): The name of the model to use for background removal.\\n        extras (str): Additional options in JSON format that can be passed to customize the background removal process.\\n        image_width (int): The width of the input images in pixels.\\n        image_height (int): The height of the input images in pixels.\\n        output_specifier (str): A printf-style specifier for the output filenames. If specified, the processed images will be saved to the specified output directory with filenames generated using the specifier.\\n        **kwargs: Additional keyword arguments that can be used to customize the background removal process.\\n\\n    Returns:\\n        None\\n    '\n    try:\n        kwargs.update(json.loads(extras))\n    except Exception:\n        pass\n    session = new_session(model, **kwargs)\n    bytes_per_img = image_width * image_height * 3\n    if output_specifier:\n        output_dir = os.path.dirname(os.path.abspath(os.path.expanduser(output_specifier)))\n        if not os.path.isdir(output_dir):\n            os.makedirs(output_dir, exist_ok=True)\n\n    def img_to_byte_array(img: Image) -> bytes:\n        buff = io.BytesIO()\n        img.save(buff, format='PNG')\n        return buff.getvalue()\n\n    async def connect_stdin_stdout():\n        loop = asyncio.get_event_loop()\n        reader = asyncio.StreamReader()\n        protocol = asyncio.StreamReaderProtocol(reader)\n        await loop.connect_read_pipe(lambda : protocol, sys.stdin)\n        (w_transport, w_protocol) = await loop.connect_write_pipe(asyncio.streams.FlowControlMixin, sys.stdout)\n        writer = asyncio.StreamWriter(w_transport, w_protocol, reader, loop)\n        return (reader, writer)\n\n    async def main():\n        (reader, writer) = await connect_stdin_stdout()\n        idx = 0\n        while True:\n            try:\n                img_bytes = await reader.readexactly(bytes_per_img)\n                if not img_bytes:\n                    break\n                img = Image.frombytes('RGB', (image_width, image_height), img_bytes)\n                output = remove(img, session=session, **kwargs)\n                if output_specifier:\n                    output.save(output_specifier % idx, format='PNG')\n                else:\n                    writer.write(img_to_byte_array(output))\n                idx += 1\n            except asyncio.IncompleteReadError:\n                break\n    asyncio.run(main())",
            "@click.command(name='b', help='for a byte stream as input')\n@click.option('-m', '--model', default='u2net', type=click.Choice(sessions_names), show_default=True, show_choices=True, help='model name')\n@click.option('-a', '--alpha-matting', is_flag=True, show_default=True, help='use alpha matting')\n@click.option('-af', '--alpha-matting-foreground-threshold', default=240, type=int, show_default=True, help='trimap fg threshold')\n@click.option('-ab', '--alpha-matting-background-threshold', default=10, type=int, show_default=True, help='trimap bg threshold')\n@click.option('-ae', '--alpha-matting-erode-size', default=10, type=int, show_default=True, help='erode size')\n@click.option('-om', '--only-mask', is_flag=True, show_default=True, help='output only the mask')\n@click.option('-ppm', '--post-process-mask', is_flag=True, show_default=True, help='post process the mask')\n@click.option('-bgc', '--bgcolor', default=None, type=(int, int, int, int), nargs=4, help='Background color (R G B A) to replace the removed background with')\n@click.option('-x', '--extras', type=str)\n@click.option('-o', '--output_specifier', type=str, help=\"printf-style specifier for output filenames (e.g. 'output-%d.png'))\")\n@click.argument('image_width', type=int)\n@click.argument('image_height', type=int)\ndef rs_command(model: str, extras: str, image_width: int, image_height: int, output_specifier: str, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Command-line interface for processing images by removing the background using a specified model and generating a mask.\\n\\n    This CLI command takes several options and arguments to configure the background removal process and save the processed images.\\n\\n    Parameters:\\n        model (str): The name of the model to use for background removal.\\n        extras (str): Additional options in JSON format that can be passed to customize the background removal process.\\n        image_width (int): The width of the input images in pixels.\\n        image_height (int): The height of the input images in pixels.\\n        output_specifier (str): A printf-style specifier for the output filenames. If specified, the processed images will be saved to the specified output directory with filenames generated using the specifier.\\n        **kwargs: Additional keyword arguments that can be used to customize the background removal process.\\n\\n    Returns:\\n        None\\n    '\n    try:\n        kwargs.update(json.loads(extras))\n    except Exception:\n        pass\n    session = new_session(model, **kwargs)\n    bytes_per_img = image_width * image_height * 3\n    if output_specifier:\n        output_dir = os.path.dirname(os.path.abspath(os.path.expanduser(output_specifier)))\n        if not os.path.isdir(output_dir):\n            os.makedirs(output_dir, exist_ok=True)\n\n    def img_to_byte_array(img: Image) -> bytes:\n        buff = io.BytesIO()\n        img.save(buff, format='PNG')\n        return buff.getvalue()\n\n    async def connect_stdin_stdout():\n        loop = asyncio.get_event_loop()\n        reader = asyncio.StreamReader()\n        protocol = asyncio.StreamReaderProtocol(reader)\n        await loop.connect_read_pipe(lambda : protocol, sys.stdin)\n        (w_transport, w_protocol) = await loop.connect_write_pipe(asyncio.streams.FlowControlMixin, sys.stdout)\n        writer = asyncio.StreamWriter(w_transport, w_protocol, reader, loop)\n        return (reader, writer)\n\n    async def main():\n        (reader, writer) = await connect_stdin_stdout()\n        idx = 0\n        while True:\n            try:\n                img_bytes = await reader.readexactly(bytes_per_img)\n                if not img_bytes:\n                    break\n                img = Image.frombytes('RGB', (image_width, image_height), img_bytes)\n                output = remove(img, session=session, **kwargs)\n                if output_specifier:\n                    output.save(output_specifier % idx, format='PNG')\n                else:\n                    writer.write(img_to_byte_array(output))\n                idx += 1\n            except asyncio.IncompleteReadError:\n                break\n    asyncio.run(main())",
            "@click.command(name='b', help='for a byte stream as input')\n@click.option('-m', '--model', default='u2net', type=click.Choice(sessions_names), show_default=True, show_choices=True, help='model name')\n@click.option('-a', '--alpha-matting', is_flag=True, show_default=True, help='use alpha matting')\n@click.option('-af', '--alpha-matting-foreground-threshold', default=240, type=int, show_default=True, help='trimap fg threshold')\n@click.option('-ab', '--alpha-matting-background-threshold', default=10, type=int, show_default=True, help='trimap bg threshold')\n@click.option('-ae', '--alpha-matting-erode-size', default=10, type=int, show_default=True, help='erode size')\n@click.option('-om', '--only-mask', is_flag=True, show_default=True, help='output only the mask')\n@click.option('-ppm', '--post-process-mask', is_flag=True, show_default=True, help='post process the mask')\n@click.option('-bgc', '--bgcolor', default=None, type=(int, int, int, int), nargs=4, help='Background color (R G B A) to replace the removed background with')\n@click.option('-x', '--extras', type=str)\n@click.option('-o', '--output_specifier', type=str, help=\"printf-style specifier for output filenames (e.g. 'output-%d.png'))\")\n@click.argument('image_width', type=int)\n@click.argument('image_height', type=int)\ndef rs_command(model: str, extras: str, image_width: int, image_height: int, output_specifier: str, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Command-line interface for processing images by removing the background using a specified model and generating a mask.\\n\\n    This CLI command takes several options and arguments to configure the background removal process and save the processed images.\\n\\n    Parameters:\\n        model (str): The name of the model to use for background removal.\\n        extras (str): Additional options in JSON format that can be passed to customize the background removal process.\\n        image_width (int): The width of the input images in pixels.\\n        image_height (int): The height of the input images in pixels.\\n        output_specifier (str): A printf-style specifier for the output filenames. If specified, the processed images will be saved to the specified output directory with filenames generated using the specifier.\\n        **kwargs: Additional keyword arguments that can be used to customize the background removal process.\\n\\n    Returns:\\n        None\\n    '\n    try:\n        kwargs.update(json.loads(extras))\n    except Exception:\n        pass\n    session = new_session(model, **kwargs)\n    bytes_per_img = image_width * image_height * 3\n    if output_specifier:\n        output_dir = os.path.dirname(os.path.abspath(os.path.expanduser(output_specifier)))\n        if not os.path.isdir(output_dir):\n            os.makedirs(output_dir, exist_ok=True)\n\n    def img_to_byte_array(img: Image) -> bytes:\n        buff = io.BytesIO()\n        img.save(buff, format='PNG')\n        return buff.getvalue()\n\n    async def connect_stdin_stdout():\n        loop = asyncio.get_event_loop()\n        reader = asyncio.StreamReader()\n        protocol = asyncio.StreamReaderProtocol(reader)\n        await loop.connect_read_pipe(lambda : protocol, sys.stdin)\n        (w_transport, w_protocol) = await loop.connect_write_pipe(asyncio.streams.FlowControlMixin, sys.stdout)\n        writer = asyncio.StreamWriter(w_transport, w_protocol, reader, loop)\n        return (reader, writer)\n\n    async def main():\n        (reader, writer) = await connect_stdin_stdout()\n        idx = 0\n        while True:\n            try:\n                img_bytes = await reader.readexactly(bytes_per_img)\n                if not img_bytes:\n                    break\n                img = Image.frombytes('RGB', (image_width, image_height), img_bytes)\n                output = remove(img, session=session, **kwargs)\n                if output_specifier:\n                    output.save(output_specifier % idx, format='PNG')\n                else:\n                    writer.write(img_to_byte_array(output))\n                idx += 1\n            except asyncio.IncompleteReadError:\n                break\n    asyncio.run(main())",
            "@click.command(name='b', help='for a byte stream as input')\n@click.option('-m', '--model', default='u2net', type=click.Choice(sessions_names), show_default=True, show_choices=True, help='model name')\n@click.option('-a', '--alpha-matting', is_flag=True, show_default=True, help='use alpha matting')\n@click.option('-af', '--alpha-matting-foreground-threshold', default=240, type=int, show_default=True, help='trimap fg threshold')\n@click.option('-ab', '--alpha-matting-background-threshold', default=10, type=int, show_default=True, help='trimap bg threshold')\n@click.option('-ae', '--alpha-matting-erode-size', default=10, type=int, show_default=True, help='erode size')\n@click.option('-om', '--only-mask', is_flag=True, show_default=True, help='output only the mask')\n@click.option('-ppm', '--post-process-mask', is_flag=True, show_default=True, help='post process the mask')\n@click.option('-bgc', '--bgcolor', default=None, type=(int, int, int, int), nargs=4, help='Background color (R G B A) to replace the removed background with')\n@click.option('-x', '--extras', type=str)\n@click.option('-o', '--output_specifier', type=str, help=\"printf-style specifier for output filenames (e.g. 'output-%d.png'))\")\n@click.argument('image_width', type=int)\n@click.argument('image_height', type=int)\ndef rs_command(model: str, extras: str, image_width: int, image_height: int, output_specifier: str, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Command-line interface for processing images by removing the background using a specified model and generating a mask.\\n\\n    This CLI command takes several options and arguments to configure the background removal process and save the processed images.\\n\\n    Parameters:\\n        model (str): The name of the model to use for background removal.\\n        extras (str): Additional options in JSON format that can be passed to customize the background removal process.\\n        image_width (int): The width of the input images in pixels.\\n        image_height (int): The height of the input images in pixels.\\n        output_specifier (str): A printf-style specifier for the output filenames. If specified, the processed images will be saved to the specified output directory with filenames generated using the specifier.\\n        **kwargs: Additional keyword arguments that can be used to customize the background removal process.\\n\\n    Returns:\\n        None\\n    '\n    try:\n        kwargs.update(json.loads(extras))\n    except Exception:\n        pass\n    session = new_session(model, **kwargs)\n    bytes_per_img = image_width * image_height * 3\n    if output_specifier:\n        output_dir = os.path.dirname(os.path.abspath(os.path.expanduser(output_specifier)))\n        if not os.path.isdir(output_dir):\n            os.makedirs(output_dir, exist_ok=True)\n\n    def img_to_byte_array(img: Image) -> bytes:\n        buff = io.BytesIO()\n        img.save(buff, format='PNG')\n        return buff.getvalue()\n\n    async def connect_stdin_stdout():\n        loop = asyncio.get_event_loop()\n        reader = asyncio.StreamReader()\n        protocol = asyncio.StreamReaderProtocol(reader)\n        await loop.connect_read_pipe(lambda : protocol, sys.stdin)\n        (w_transport, w_protocol) = await loop.connect_write_pipe(asyncio.streams.FlowControlMixin, sys.stdout)\n        writer = asyncio.StreamWriter(w_transport, w_protocol, reader, loop)\n        return (reader, writer)\n\n    async def main():\n        (reader, writer) = await connect_stdin_stdout()\n        idx = 0\n        while True:\n            try:\n                img_bytes = await reader.readexactly(bytes_per_img)\n                if not img_bytes:\n                    break\n                img = Image.frombytes('RGB', (image_width, image_height), img_bytes)\n                output = remove(img, session=session, **kwargs)\n                if output_specifier:\n                    output.save(output_specifier % idx, format='PNG')\n                else:\n                    writer.write(img_to_byte_array(output))\n                idx += 1\n            except asyncio.IncompleteReadError:\n                break\n    asyncio.run(main())"
        ]
    }
]