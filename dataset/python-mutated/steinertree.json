[
    {
        "func_name": "metric_closure",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef metric_closure(G, weight='weight'):\n    \"\"\"Return the metric closure of a graph.\n\n    The metric closure of a graph *G* is the complete graph in which each edge\n    is weighted by the shortest path distance between the nodes in *G* .\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    Returns\n    -------\n    NetworkX graph\n        Metric closure of the graph `G`.\n\n    \"\"\"\n    M = nx.Graph()\n    Gnodes = set(G)\n    all_paths_iter = nx.all_pairs_dijkstra(G, weight=weight)\n    (u, (distance, path)) = next(all_paths_iter)\n    if Gnodes - set(distance):\n        msg = 'G is not a connected graph. metric_closure is not defined.'\n        raise nx.NetworkXError(msg)\n    Gnodes.remove(u)\n    for v in Gnodes:\n        M.add_edge(u, v, distance=distance[v], path=path[v])\n    for (u, (distance, path)) in all_paths_iter:\n        Gnodes.remove(u)\n        for v in Gnodes:\n            M.add_edge(u, v, distance=distance[v], path=path[v])\n    return M",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef metric_closure(G, weight='weight'):\n    if False:\n        i = 10\n    'Return the metric closure of a graph.\\n\\n    The metric closure of a graph *G* is the complete graph in which each edge\\n    is weighted by the shortest path distance between the nodes in *G* .\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Metric closure of the graph `G`.\\n\\n    '\n    M = nx.Graph()\n    Gnodes = set(G)\n    all_paths_iter = nx.all_pairs_dijkstra(G, weight=weight)\n    (u, (distance, path)) = next(all_paths_iter)\n    if Gnodes - set(distance):\n        msg = 'G is not a connected graph. metric_closure is not defined.'\n        raise nx.NetworkXError(msg)\n    Gnodes.remove(u)\n    for v in Gnodes:\n        M.add_edge(u, v, distance=distance[v], path=path[v])\n    for (u, (distance, path)) in all_paths_iter:\n        Gnodes.remove(u)\n        for v in Gnodes:\n            M.add_edge(u, v, distance=distance[v], path=path[v])\n    return M",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef metric_closure(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the metric closure of a graph.\\n\\n    The metric closure of a graph *G* is the complete graph in which each edge\\n    is weighted by the shortest path distance between the nodes in *G* .\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Metric closure of the graph `G`.\\n\\n    '\n    M = nx.Graph()\n    Gnodes = set(G)\n    all_paths_iter = nx.all_pairs_dijkstra(G, weight=weight)\n    (u, (distance, path)) = next(all_paths_iter)\n    if Gnodes - set(distance):\n        msg = 'G is not a connected graph. metric_closure is not defined.'\n        raise nx.NetworkXError(msg)\n    Gnodes.remove(u)\n    for v in Gnodes:\n        M.add_edge(u, v, distance=distance[v], path=path[v])\n    for (u, (distance, path)) in all_paths_iter:\n        Gnodes.remove(u)\n        for v in Gnodes:\n            M.add_edge(u, v, distance=distance[v], path=path[v])\n    return M",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef metric_closure(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the metric closure of a graph.\\n\\n    The metric closure of a graph *G* is the complete graph in which each edge\\n    is weighted by the shortest path distance between the nodes in *G* .\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Metric closure of the graph `G`.\\n\\n    '\n    M = nx.Graph()\n    Gnodes = set(G)\n    all_paths_iter = nx.all_pairs_dijkstra(G, weight=weight)\n    (u, (distance, path)) = next(all_paths_iter)\n    if Gnodes - set(distance):\n        msg = 'G is not a connected graph. metric_closure is not defined.'\n        raise nx.NetworkXError(msg)\n    Gnodes.remove(u)\n    for v in Gnodes:\n        M.add_edge(u, v, distance=distance[v], path=path[v])\n    for (u, (distance, path)) in all_paths_iter:\n        Gnodes.remove(u)\n        for v in Gnodes:\n            M.add_edge(u, v, distance=distance[v], path=path[v])\n    return M",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef metric_closure(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the metric closure of a graph.\\n\\n    The metric closure of a graph *G* is the complete graph in which each edge\\n    is weighted by the shortest path distance between the nodes in *G* .\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Metric closure of the graph `G`.\\n\\n    '\n    M = nx.Graph()\n    Gnodes = set(G)\n    all_paths_iter = nx.all_pairs_dijkstra(G, weight=weight)\n    (u, (distance, path)) = next(all_paths_iter)\n    if Gnodes - set(distance):\n        msg = 'G is not a connected graph. metric_closure is not defined.'\n        raise nx.NetworkXError(msg)\n    Gnodes.remove(u)\n    for v in Gnodes:\n        M.add_edge(u, v, distance=distance[v], path=path[v])\n    for (u, (distance, path)) in all_paths_iter:\n        Gnodes.remove(u)\n        for v in Gnodes:\n            M.add_edge(u, v, distance=distance[v], path=path[v])\n    return M",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef metric_closure(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the metric closure of a graph.\\n\\n    The metric closure of a graph *G* is the complete graph in which each edge\\n    is weighted by the shortest path distance between the nodes in *G* .\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Metric closure of the graph `G`.\\n\\n    '\n    M = nx.Graph()\n    Gnodes = set(G)\n    all_paths_iter = nx.all_pairs_dijkstra(G, weight=weight)\n    (u, (distance, path)) = next(all_paths_iter)\n    if Gnodes - set(distance):\n        msg = 'G is not a connected graph. metric_closure is not defined.'\n        raise nx.NetworkXError(msg)\n    Gnodes.remove(u)\n    for v in Gnodes:\n        M.add_edge(u, v, distance=distance[v], path=path[v])\n    for (u, (distance, path)) in all_paths_iter:\n        Gnodes.remove(u)\n        for v in Gnodes:\n            M.add_edge(u, v, distance=distance[v], path=path[v])\n    return M"
        ]
    },
    {
        "func_name": "_mehlhorn_steiner_tree",
        "original": "def _mehlhorn_steiner_tree(G, terminal_nodes, weight):\n    paths = nx.multi_source_dijkstra_path(G, terminal_nodes)\n    d_1 = {}\n    s = {}\n    for v in G.nodes():\n        s[v] = paths[v][0]\n        d_1[v, s[v]] = len(paths[v]) - 1\n    G_1_prime = nx.Graph()\n    for (u, v, data) in G.edges(data=True):\n        (su, sv) = (s[u], s[v])\n        weight_here = d_1[u, su] + data.get(weight, 1) + d_1[v, sv]\n        if not G_1_prime.has_edge(su, sv):\n            G_1_prime.add_edge(su, sv, weight=weight_here)\n        else:\n            new_weight = min(weight_here, G_1_prime[su][sv][weight])\n            G_1_prime.add_edge(su, sv, weight=new_weight)\n    G_2 = nx.minimum_spanning_edges(G_1_prime, data=True)\n    G_3 = nx.Graph()\n    for (u, v, d) in G_2:\n        path = nx.shortest_path(G, u, v, weight)\n        for (n1, n2) in pairwise(path):\n            G_3.add_edge(n1, n2)\n    G_3_mst = list(nx.minimum_spanning_edges(G_3, data=False))\n    if G.is_multigraph():\n        G_3_mst = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in G_3_mst)\n    G_4 = G.edge_subgraph(G_3_mst).copy()\n    _remove_nonterminal_leaves(G_4, terminal_nodes)\n    return G_4.edges()",
        "mutated": [
            "def _mehlhorn_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n    paths = nx.multi_source_dijkstra_path(G, terminal_nodes)\n    d_1 = {}\n    s = {}\n    for v in G.nodes():\n        s[v] = paths[v][0]\n        d_1[v, s[v]] = len(paths[v]) - 1\n    G_1_prime = nx.Graph()\n    for (u, v, data) in G.edges(data=True):\n        (su, sv) = (s[u], s[v])\n        weight_here = d_1[u, su] + data.get(weight, 1) + d_1[v, sv]\n        if not G_1_prime.has_edge(su, sv):\n            G_1_prime.add_edge(su, sv, weight=weight_here)\n        else:\n            new_weight = min(weight_here, G_1_prime[su][sv][weight])\n            G_1_prime.add_edge(su, sv, weight=new_weight)\n    G_2 = nx.minimum_spanning_edges(G_1_prime, data=True)\n    G_3 = nx.Graph()\n    for (u, v, d) in G_2:\n        path = nx.shortest_path(G, u, v, weight)\n        for (n1, n2) in pairwise(path):\n            G_3.add_edge(n1, n2)\n    G_3_mst = list(nx.minimum_spanning_edges(G_3, data=False))\n    if G.is_multigraph():\n        G_3_mst = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in G_3_mst)\n    G_4 = G.edge_subgraph(G_3_mst).copy()\n    _remove_nonterminal_leaves(G_4, terminal_nodes)\n    return G_4.edges()",
            "def _mehlhorn_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    paths = nx.multi_source_dijkstra_path(G, terminal_nodes)\n    d_1 = {}\n    s = {}\n    for v in G.nodes():\n        s[v] = paths[v][0]\n        d_1[v, s[v]] = len(paths[v]) - 1\n    G_1_prime = nx.Graph()\n    for (u, v, data) in G.edges(data=True):\n        (su, sv) = (s[u], s[v])\n        weight_here = d_1[u, su] + data.get(weight, 1) + d_1[v, sv]\n        if not G_1_prime.has_edge(su, sv):\n            G_1_prime.add_edge(su, sv, weight=weight_here)\n        else:\n            new_weight = min(weight_here, G_1_prime[su][sv][weight])\n            G_1_prime.add_edge(su, sv, weight=new_weight)\n    G_2 = nx.minimum_spanning_edges(G_1_prime, data=True)\n    G_3 = nx.Graph()\n    for (u, v, d) in G_2:\n        path = nx.shortest_path(G, u, v, weight)\n        for (n1, n2) in pairwise(path):\n            G_3.add_edge(n1, n2)\n    G_3_mst = list(nx.minimum_spanning_edges(G_3, data=False))\n    if G.is_multigraph():\n        G_3_mst = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in G_3_mst)\n    G_4 = G.edge_subgraph(G_3_mst).copy()\n    _remove_nonterminal_leaves(G_4, terminal_nodes)\n    return G_4.edges()",
            "def _mehlhorn_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    paths = nx.multi_source_dijkstra_path(G, terminal_nodes)\n    d_1 = {}\n    s = {}\n    for v in G.nodes():\n        s[v] = paths[v][0]\n        d_1[v, s[v]] = len(paths[v]) - 1\n    G_1_prime = nx.Graph()\n    for (u, v, data) in G.edges(data=True):\n        (su, sv) = (s[u], s[v])\n        weight_here = d_1[u, su] + data.get(weight, 1) + d_1[v, sv]\n        if not G_1_prime.has_edge(su, sv):\n            G_1_prime.add_edge(su, sv, weight=weight_here)\n        else:\n            new_weight = min(weight_here, G_1_prime[su][sv][weight])\n            G_1_prime.add_edge(su, sv, weight=new_weight)\n    G_2 = nx.minimum_spanning_edges(G_1_prime, data=True)\n    G_3 = nx.Graph()\n    for (u, v, d) in G_2:\n        path = nx.shortest_path(G, u, v, weight)\n        for (n1, n2) in pairwise(path):\n            G_3.add_edge(n1, n2)\n    G_3_mst = list(nx.minimum_spanning_edges(G_3, data=False))\n    if G.is_multigraph():\n        G_3_mst = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in G_3_mst)\n    G_4 = G.edge_subgraph(G_3_mst).copy()\n    _remove_nonterminal_leaves(G_4, terminal_nodes)\n    return G_4.edges()",
            "def _mehlhorn_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    paths = nx.multi_source_dijkstra_path(G, terminal_nodes)\n    d_1 = {}\n    s = {}\n    for v in G.nodes():\n        s[v] = paths[v][0]\n        d_1[v, s[v]] = len(paths[v]) - 1\n    G_1_prime = nx.Graph()\n    for (u, v, data) in G.edges(data=True):\n        (su, sv) = (s[u], s[v])\n        weight_here = d_1[u, su] + data.get(weight, 1) + d_1[v, sv]\n        if not G_1_prime.has_edge(su, sv):\n            G_1_prime.add_edge(su, sv, weight=weight_here)\n        else:\n            new_weight = min(weight_here, G_1_prime[su][sv][weight])\n            G_1_prime.add_edge(su, sv, weight=new_weight)\n    G_2 = nx.minimum_spanning_edges(G_1_prime, data=True)\n    G_3 = nx.Graph()\n    for (u, v, d) in G_2:\n        path = nx.shortest_path(G, u, v, weight)\n        for (n1, n2) in pairwise(path):\n            G_3.add_edge(n1, n2)\n    G_3_mst = list(nx.minimum_spanning_edges(G_3, data=False))\n    if G.is_multigraph():\n        G_3_mst = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in G_3_mst)\n    G_4 = G.edge_subgraph(G_3_mst).copy()\n    _remove_nonterminal_leaves(G_4, terminal_nodes)\n    return G_4.edges()",
            "def _mehlhorn_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    paths = nx.multi_source_dijkstra_path(G, terminal_nodes)\n    d_1 = {}\n    s = {}\n    for v in G.nodes():\n        s[v] = paths[v][0]\n        d_1[v, s[v]] = len(paths[v]) - 1\n    G_1_prime = nx.Graph()\n    for (u, v, data) in G.edges(data=True):\n        (su, sv) = (s[u], s[v])\n        weight_here = d_1[u, su] + data.get(weight, 1) + d_1[v, sv]\n        if not G_1_prime.has_edge(su, sv):\n            G_1_prime.add_edge(su, sv, weight=weight_here)\n        else:\n            new_weight = min(weight_here, G_1_prime[su][sv][weight])\n            G_1_prime.add_edge(su, sv, weight=new_weight)\n    G_2 = nx.minimum_spanning_edges(G_1_prime, data=True)\n    G_3 = nx.Graph()\n    for (u, v, d) in G_2:\n        path = nx.shortest_path(G, u, v, weight)\n        for (n1, n2) in pairwise(path):\n            G_3.add_edge(n1, n2)\n    G_3_mst = list(nx.minimum_spanning_edges(G_3, data=False))\n    if G.is_multigraph():\n        G_3_mst = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in G_3_mst)\n    G_4 = G.edge_subgraph(G_3_mst).copy()\n    _remove_nonterminal_leaves(G_4, terminal_nodes)\n    return G_4.edges()"
        ]
    },
    {
        "func_name": "_kou_steiner_tree",
        "original": "def _kou_steiner_tree(G, terminal_nodes, weight):\n    M = metric_closure(G, weight=weight)\n    H = M.subgraph(terminal_nodes)\n    mst_edges = nx.minimum_spanning_edges(H, weight='distance', data=True)\n    mst_all_edges = chain.from_iterable((pairwise(d['path']) for (u, v, d) in mst_edges))\n    if G.is_multigraph():\n        mst_all_edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in mst_all_edges)\n    G_S = G.edge_subgraph(mst_all_edges)\n    T_S = nx.minimum_spanning_edges(G_S, weight='weight', data=False)\n    T_H = G.edge_subgraph(T_S).copy()\n    _remove_nonterminal_leaves(T_H, terminal_nodes)\n    return T_H.edges()",
        "mutated": [
            "def _kou_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n    M = metric_closure(G, weight=weight)\n    H = M.subgraph(terminal_nodes)\n    mst_edges = nx.minimum_spanning_edges(H, weight='distance', data=True)\n    mst_all_edges = chain.from_iterable((pairwise(d['path']) for (u, v, d) in mst_edges))\n    if G.is_multigraph():\n        mst_all_edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in mst_all_edges)\n    G_S = G.edge_subgraph(mst_all_edges)\n    T_S = nx.minimum_spanning_edges(G_S, weight='weight', data=False)\n    T_H = G.edge_subgraph(T_S).copy()\n    _remove_nonterminal_leaves(T_H, terminal_nodes)\n    return T_H.edges()",
            "def _kou_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    M = metric_closure(G, weight=weight)\n    H = M.subgraph(terminal_nodes)\n    mst_edges = nx.minimum_spanning_edges(H, weight='distance', data=True)\n    mst_all_edges = chain.from_iterable((pairwise(d['path']) for (u, v, d) in mst_edges))\n    if G.is_multigraph():\n        mst_all_edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in mst_all_edges)\n    G_S = G.edge_subgraph(mst_all_edges)\n    T_S = nx.minimum_spanning_edges(G_S, weight='weight', data=False)\n    T_H = G.edge_subgraph(T_S).copy()\n    _remove_nonterminal_leaves(T_H, terminal_nodes)\n    return T_H.edges()",
            "def _kou_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    M = metric_closure(G, weight=weight)\n    H = M.subgraph(terminal_nodes)\n    mst_edges = nx.minimum_spanning_edges(H, weight='distance', data=True)\n    mst_all_edges = chain.from_iterable((pairwise(d['path']) for (u, v, d) in mst_edges))\n    if G.is_multigraph():\n        mst_all_edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in mst_all_edges)\n    G_S = G.edge_subgraph(mst_all_edges)\n    T_S = nx.minimum_spanning_edges(G_S, weight='weight', data=False)\n    T_H = G.edge_subgraph(T_S).copy()\n    _remove_nonterminal_leaves(T_H, terminal_nodes)\n    return T_H.edges()",
            "def _kou_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    M = metric_closure(G, weight=weight)\n    H = M.subgraph(terminal_nodes)\n    mst_edges = nx.minimum_spanning_edges(H, weight='distance', data=True)\n    mst_all_edges = chain.from_iterable((pairwise(d['path']) for (u, v, d) in mst_edges))\n    if G.is_multigraph():\n        mst_all_edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in mst_all_edges)\n    G_S = G.edge_subgraph(mst_all_edges)\n    T_S = nx.minimum_spanning_edges(G_S, weight='weight', data=False)\n    T_H = G.edge_subgraph(T_S).copy()\n    _remove_nonterminal_leaves(T_H, terminal_nodes)\n    return T_H.edges()",
            "def _kou_steiner_tree(G, terminal_nodes, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    M = metric_closure(G, weight=weight)\n    H = M.subgraph(terminal_nodes)\n    mst_edges = nx.minimum_spanning_edges(H, weight='distance', data=True)\n    mst_all_edges = chain.from_iterable((pairwise(d['path']) for (u, v, d) in mst_edges))\n    if G.is_multigraph():\n        mst_all_edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in mst_all_edges)\n    G_S = G.edge_subgraph(mst_all_edges)\n    T_S = nx.minimum_spanning_edges(G_S, weight='weight', data=False)\n    T_H = G.edge_subgraph(T_S).copy()\n    _remove_nonterminal_leaves(T_H, terminal_nodes)\n    return T_H.edges()"
        ]
    },
    {
        "func_name": "_remove_nonterminal_leaves",
        "original": "def _remove_nonterminal_leaves(G, terminals):\n    terminals_set = set(terminals)\n    for n in list(G.nodes):\n        if n not in terminals_set and G.degree(n) == 1:\n            G.remove_node(n)",
        "mutated": [
            "def _remove_nonterminal_leaves(G, terminals):\n    if False:\n        i = 10\n    terminals_set = set(terminals)\n    for n in list(G.nodes):\n        if n not in terminals_set and G.degree(n) == 1:\n            G.remove_node(n)",
            "def _remove_nonterminal_leaves(G, terminals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    terminals_set = set(terminals)\n    for n in list(G.nodes):\n        if n not in terminals_set and G.degree(n) == 1:\n            G.remove_node(n)",
            "def _remove_nonterminal_leaves(G, terminals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    terminals_set = set(terminals)\n    for n in list(G.nodes):\n        if n not in terminals_set and G.degree(n) == 1:\n            G.remove_node(n)",
            "def _remove_nonterminal_leaves(G, terminals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    terminals_set = set(terminals)\n    for n in list(G.nodes):\n        if n not in terminals_set and G.degree(n) == 1:\n            G.remove_node(n)",
            "def _remove_nonterminal_leaves(G, terminals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    terminals_set = set(terminals)\n    for n in list(G.nodes):\n        if n not in terminals_set and G.degree(n) == 1:\n            G.remove_node(n)"
        ]
    },
    {
        "func_name": "steiner_tree",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef steiner_tree(G, terminal_nodes, weight='weight', method=None):\n    \"\"\"Return an approximation to the minimum Steiner tree of a graph.\n\n    The minimum Steiner tree of `G` w.r.t a set of `terminal_nodes` (also *S*)\n    is a tree within `G` that spans those nodes and has minimum size (sum of\n    edge weights) among all such trees.\n\n    The approximation algorithm is specified with the `method` keyword\n    argument. All three available algorithms produce a tree whose weight is\n    within a ``(2 - (2 / l))`` factor of the weight of the optimal Steiner tree,\n    where ``l`` is the minimum number of leaf nodes across all possible Steiner\n    trees.\n\n    * ``\"kou\"`` [2]_ (runtime $O(|S| |V|^2)$) computes the minimum spanning tree of\n      the subgraph of the metric closure of *G* induced by the terminal nodes,\n      where the metric closure of *G* is the complete graph in which each edge is\n      weighted by the shortest path distance between the nodes in *G*.\n\n    * ``\"mehlhorn\"`` [3]_ (runtime $O(|E|+|V|\\\\log|V|)$) modifies Kou et al.'s\n      algorithm, beginning by finding the closest terminal node for each\n      non-terminal. This data is used to create a complete graph containing only\n      the terminal nodes, in which edge is weighted with the shortest path\n      distance between them. The algorithm then proceeds in the same way as Kou\n      et al..\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    terminal_nodes : list\n         A list of terminal nodes for which minimum steiner tree is\n         to be found.\n\n    weight : string (default = 'weight')\n        Use the edge attribute specified by this string as the edge weight.\n        Any edge attribute not present defaults to 1.\n\n    method : string, optional (default = 'kou')\n        The algorithm to use to approximate the Steiner tree.\n        Supported options: 'kou', 'mehlhorn'.\n        Other inputs produce a ValueError.\n\n    Returns\n    -------\n    NetworkX graph\n        Approximation to the minimum steiner tree of `G` induced by\n        `terminal_nodes` .\n\n    Notes\n    -----\n    For multigraphs, the edge between two nodes with minimum weight is the\n    edge put into the Steiner tree.\n\n\n    References\n    ----------\n    .. [1] Steiner_tree_problem on Wikipedia.\n           https://en.wikipedia.org/wiki/Steiner_tree_problem\n    .. [2] Kou, L., G. Markowsky, and L. Berman. 1981.\n           \u2018A Fast Algorithm for Steiner Trees\u2019.\n           Acta Informatica 15 (2): 141\u201345.\n           https://doi.org/10.1007/BF00288961.\n    .. [3] Mehlhorn, Kurt. 1988.\n           \u2018A Faster Approximation Algorithm for the Steiner Problem in Graphs\u2019.\n           Information Processing Letters 27 (3): 125\u201328.\n           https://doi.org/10.1016/0020-0190(88)90066-X.\n    \"\"\"\n    if method is None:\n        import warnings\n        msg = \"steiner_tree will change default method from 'kou' to 'mehlhorn' in version 3.2.\\nSet the `method` kwarg to remove this warning.\"\n        warnings.warn(msg, FutureWarning, stacklevel=4)\n        method = 'kou'\n    try:\n        algo = ALGORITHMS[method]\n    except KeyError as e:\n        msg = f'{method} is not a valid choice for an algorithm.'\n        raise ValueError(msg) from e\n    edges = algo(G, terminal_nodes, weight)\n    if G.is_multigraph():\n        edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in edges)\n    T = G.edge_subgraph(edges)\n    return T",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef steiner_tree(G, terminal_nodes, weight='weight', method=None):\n    if False:\n        i = 10\n    'Return an approximation to the minimum Steiner tree of a graph.\\n\\n    The minimum Steiner tree of `G` w.r.t a set of `terminal_nodes` (also *S*)\\n    is a tree within `G` that spans those nodes and has minimum size (sum of\\n    edge weights) among all such trees.\\n\\n    The approximation algorithm is specified with the `method` keyword\\n    argument. All three available algorithms produce a tree whose weight is\\n    within a ``(2 - (2 / l))`` factor of the weight of the optimal Steiner tree,\\n    where ``l`` is the minimum number of leaf nodes across all possible Steiner\\n    trees.\\n\\n    * ``\"kou\"`` [2]_ (runtime $O(|S| |V|^2)$) computes the minimum spanning tree of\\n      the subgraph of the metric closure of *G* induced by the terminal nodes,\\n      where the metric closure of *G* is the complete graph in which each edge is\\n      weighted by the shortest path distance between the nodes in *G*.\\n\\n    * ``\"mehlhorn\"`` [3]_ (runtime $O(|E|+|V|\\\\log|V|)$) modifies Kou et al.\\'s\\n      algorithm, beginning by finding the closest terminal node for each\\n      non-terminal. This data is used to create a complete graph containing only\\n      the terminal nodes, in which edge is weighted with the shortest path\\n      distance between them. The algorithm then proceeds in the same way as Kou\\n      et al..\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    terminal_nodes : list\\n         A list of terminal nodes for which minimum steiner tree is\\n         to be found.\\n\\n    weight : string (default = \\'weight\\')\\n        Use the edge attribute specified by this string as the edge weight.\\n        Any edge attribute not present defaults to 1.\\n\\n    method : string, optional (default = \\'kou\\')\\n        The algorithm to use to approximate the Steiner tree.\\n        Supported options: \\'kou\\', \\'mehlhorn\\'.\\n        Other inputs produce a ValueError.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Approximation to the minimum steiner tree of `G` induced by\\n        `terminal_nodes` .\\n\\n    Notes\\n    -----\\n    For multigraphs, the edge between two nodes with minimum weight is the\\n    edge put into the Steiner tree.\\n\\n\\n    References\\n    ----------\\n    .. [1] Steiner_tree_problem on Wikipedia.\\n           https://en.wikipedia.org/wiki/Steiner_tree_problem\\n    .. [2] Kou, L., G. Markowsky, and L. Berman. 1981.\\n           \u2018A Fast Algorithm for Steiner Trees\u2019.\\n           Acta Informatica 15 (2): 141\u201345.\\n           https://doi.org/10.1007/BF00288961.\\n    .. [3] Mehlhorn, Kurt. 1988.\\n           \u2018A Faster Approximation Algorithm for the Steiner Problem in Graphs\u2019.\\n           Information Processing Letters 27 (3): 125\u201328.\\n           https://doi.org/10.1016/0020-0190(88)90066-X.\\n    '\n    if method is None:\n        import warnings\n        msg = \"steiner_tree will change default method from 'kou' to 'mehlhorn' in version 3.2.\\nSet the `method` kwarg to remove this warning.\"\n        warnings.warn(msg, FutureWarning, stacklevel=4)\n        method = 'kou'\n    try:\n        algo = ALGORITHMS[method]\n    except KeyError as e:\n        msg = f'{method} is not a valid choice for an algorithm.'\n        raise ValueError(msg) from e\n    edges = algo(G, terminal_nodes, weight)\n    if G.is_multigraph():\n        edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in edges)\n    T = G.edge_subgraph(edges)\n    return T",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef steiner_tree(G, terminal_nodes, weight='weight', method=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return an approximation to the minimum Steiner tree of a graph.\\n\\n    The minimum Steiner tree of `G` w.r.t a set of `terminal_nodes` (also *S*)\\n    is a tree within `G` that spans those nodes and has minimum size (sum of\\n    edge weights) among all such trees.\\n\\n    The approximation algorithm is specified with the `method` keyword\\n    argument. All three available algorithms produce a tree whose weight is\\n    within a ``(2 - (2 / l))`` factor of the weight of the optimal Steiner tree,\\n    where ``l`` is the minimum number of leaf nodes across all possible Steiner\\n    trees.\\n\\n    * ``\"kou\"`` [2]_ (runtime $O(|S| |V|^2)$) computes the minimum spanning tree of\\n      the subgraph of the metric closure of *G* induced by the terminal nodes,\\n      where the metric closure of *G* is the complete graph in which each edge is\\n      weighted by the shortest path distance between the nodes in *G*.\\n\\n    * ``\"mehlhorn\"`` [3]_ (runtime $O(|E|+|V|\\\\log|V|)$) modifies Kou et al.\\'s\\n      algorithm, beginning by finding the closest terminal node for each\\n      non-terminal. This data is used to create a complete graph containing only\\n      the terminal nodes, in which edge is weighted with the shortest path\\n      distance between them. The algorithm then proceeds in the same way as Kou\\n      et al..\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    terminal_nodes : list\\n         A list of terminal nodes for which minimum steiner tree is\\n         to be found.\\n\\n    weight : string (default = \\'weight\\')\\n        Use the edge attribute specified by this string as the edge weight.\\n        Any edge attribute not present defaults to 1.\\n\\n    method : string, optional (default = \\'kou\\')\\n        The algorithm to use to approximate the Steiner tree.\\n        Supported options: \\'kou\\', \\'mehlhorn\\'.\\n        Other inputs produce a ValueError.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Approximation to the minimum steiner tree of `G` induced by\\n        `terminal_nodes` .\\n\\n    Notes\\n    -----\\n    For multigraphs, the edge between two nodes with minimum weight is the\\n    edge put into the Steiner tree.\\n\\n\\n    References\\n    ----------\\n    .. [1] Steiner_tree_problem on Wikipedia.\\n           https://en.wikipedia.org/wiki/Steiner_tree_problem\\n    .. [2] Kou, L., G. Markowsky, and L. Berman. 1981.\\n           \u2018A Fast Algorithm for Steiner Trees\u2019.\\n           Acta Informatica 15 (2): 141\u201345.\\n           https://doi.org/10.1007/BF00288961.\\n    .. [3] Mehlhorn, Kurt. 1988.\\n           \u2018A Faster Approximation Algorithm for the Steiner Problem in Graphs\u2019.\\n           Information Processing Letters 27 (3): 125\u201328.\\n           https://doi.org/10.1016/0020-0190(88)90066-X.\\n    '\n    if method is None:\n        import warnings\n        msg = \"steiner_tree will change default method from 'kou' to 'mehlhorn' in version 3.2.\\nSet the `method` kwarg to remove this warning.\"\n        warnings.warn(msg, FutureWarning, stacklevel=4)\n        method = 'kou'\n    try:\n        algo = ALGORITHMS[method]\n    except KeyError as e:\n        msg = f'{method} is not a valid choice for an algorithm.'\n        raise ValueError(msg) from e\n    edges = algo(G, terminal_nodes, weight)\n    if G.is_multigraph():\n        edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in edges)\n    T = G.edge_subgraph(edges)\n    return T",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef steiner_tree(G, terminal_nodes, weight='weight', method=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return an approximation to the minimum Steiner tree of a graph.\\n\\n    The minimum Steiner tree of `G` w.r.t a set of `terminal_nodes` (also *S*)\\n    is a tree within `G` that spans those nodes and has minimum size (sum of\\n    edge weights) among all such trees.\\n\\n    The approximation algorithm is specified with the `method` keyword\\n    argument. All three available algorithms produce a tree whose weight is\\n    within a ``(2 - (2 / l))`` factor of the weight of the optimal Steiner tree,\\n    where ``l`` is the minimum number of leaf nodes across all possible Steiner\\n    trees.\\n\\n    * ``\"kou\"`` [2]_ (runtime $O(|S| |V|^2)$) computes the minimum spanning tree of\\n      the subgraph of the metric closure of *G* induced by the terminal nodes,\\n      where the metric closure of *G* is the complete graph in which each edge is\\n      weighted by the shortest path distance between the nodes in *G*.\\n\\n    * ``\"mehlhorn\"`` [3]_ (runtime $O(|E|+|V|\\\\log|V|)$) modifies Kou et al.\\'s\\n      algorithm, beginning by finding the closest terminal node for each\\n      non-terminal. This data is used to create a complete graph containing only\\n      the terminal nodes, in which edge is weighted with the shortest path\\n      distance between them. The algorithm then proceeds in the same way as Kou\\n      et al..\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    terminal_nodes : list\\n         A list of terminal nodes for which minimum steiner tree is\\n         to be found.\\n\\n    weight : string (default = \\'weight\\')\\n        Use the edge attribute specified by this string as the edge weight.\\n        Any edge attribute not present defaults to 1.\\n\\n    method : string, optional (default = \\'kou\\')\\n        The algorithm to use to approximate the Steiner tree.\\n        Supported options: \\'kou\\', \\'mehlhorn\\'.\\n        Other inputs produce a ValueError.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Approximation to the minimum steiner tree of `G` induced by\\n        `terminal_nodes` .\\n\\n    Notes\\n    -----\\n    For multigraphs, the edge between two nodes with minimum weight is the\\n    edge put into the Steiner tree.\\n\\n\\n    References\\n    ----------\\n    .. [1] Steiner_tree_problem on Wikipedia.\\n           https://en.wikipedia.org/wiki/Steiner_tree_problem\\n    .. [2] Kou, L., G. Markowsky, and L. Berman. 1981.\\n           \u2018A Fast Algorithm for Steiner Trees\u2019.\\n           Acta Informatica 15 (2): 141\u201345.\\n           https://doi.org/10.1007/BF00288961.\\n    .. [3] Mehlhorn, Kurt. 1988.\\n           \u2018A Faster Approximation Algorithm for the Steiner Problem in Graphs\u2019.\\n           Information Processing Letters 27 (3): 125\u201328.\\n           https://doi.org/10.1016/0020-0190(88)90066-X.\\n    '\n    if method is None:\n        import warnings\n        msg = \"steiner_tree will change default method from 'kou' to 'mehlhorn' in version 3.2.\\nSet the `method` kwarg to remove this warning.\"\n        warnings.warn(msg, FutureWarning, stacklevel=4)\n        method = 'kou'\n    try:\n        algo = ALGORITHMS[method]\n    except KeyError as e:\n        msg = f'{method} is not a valid choice for an algorithm.'\n        raise ValueError(msg) from e\n    edges = algo(G, terminal_nodes, weight)\n    if G.is_multigraph():\n        edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in edges)\n    T = G.edge_subgraph(edges)\n    return T",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef steiner_tree(G, terminal_nodes, weight='weight', method=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return an approximation to the minimum Steiner tree of a graph.\\n\\n    The minimum Steiner tree of `G` w.r.t a set of `terminal_nodes` (also *S*)\\n    is a tree within `G` that spans those nodes and has minimum size (sum of\\n    edge weights) among all such trees.\\n\\n    The approximation algorithm is specified with the `method` keyword\\n    argument. All three available algorithms produce a tree whose weight is\\n    within a ``(2 - (2 / l))`` factor of the weight of the optimal Steiner tree,\\n    where ``l`` is the minimum number of leaf nodes across all possible Steiner\\n    trees.\\n\\n    * ``\"kou\"`` [2]_ (runtime $O(|S| |V|^2)$) computes the minimum spanning tree of\\n      the subgraph of the metric closure of *G* induced by the terminal nodes,\\n      where the metric closure of *G* is the complete graph in which each edge is\\n      weighted by the shortest path distance between the nodes in *G*.\\n\\n    * ``\"mehlhorn\"`` [3]_ (runtime $O(|E|+|V|\\\\log|V|)$) modifies Kou et al.\\'s\\n      algorithm, beginning by finding the closest terminal node for each\\n      non-terminal. This data is used to create a complete graph containing only\\n      the terminal nodes, in which edge is weighted with the shortest path\\n      distance between them. The algorithm then proceeds in the same way as Kou\\n      et al..\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    terminal_nodes : list\\n         A list of terminal nodes for which minimum steiner tree is\\n         to be found.\\n\\n    weight : string (default = \\'weight\\')\\n        Use the edge attribute specified by this string as the edge weight.\\n        Any edge attribute not present defaults to 1.\\n\\n    method : string, optional (default = \\'kou\\')\\n        The algorithm to use to approximate the Steiner tree.\\n        Supported options: \\'kou\\', \\'mehlhorn\\'.\\n        Other inputs produce a ValueError.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Approximation to the minimum steiner tree of `G` induced by\\n        `terminal_nodes` .\\n\\n    Notes\\n    -----\\n    For multigraphs, the edge between two nodes with minimum weight is the\\n    edge put into the Steiner tree.\\n\\n\\n    References\\n    ----------\\n    .. [1] Steiner_tree_problem on Wikipedia.\\n           https://en.wikipedia.org/wiki/Steiner_tree_problem\\n    .. [2] Kou, L., G. Markowsky, and L. Berman. 1981.\\n           \u2018A Fast Algorithm for Steiner Trees\u2019.\\n           Acta Informatica 15 (2): 141\u201345.\\n           https://doi.org/10.1007/BF00288961.\\n    .. [3] Mehlhorn, Kurt. 1988.\\n           \u2018A Faster Approximation Algorithm for the Steiner Problem in Graphs\u2019.\\n           Information Processing Letters 27 (3): 125\u201328.\\n           https://doi.org/10.1016/0020-0190(88)90066-X.\\n    '\n    if method is None:\n        import warnings\n        msg = \"steiner_tree will change default method from 'kou' to 'mehlhorn' in version 3.2.\\nSet the `method` kwarg to remove this warning.\"\n        warnings.warn(msg, FutureWarning, stacklevel=4)\n        method = 'kou'\n    try:\n        algo = ALGORITHMS[method]\n    except KeyError as e:\n        msg = f'{method} is not a valid choice for an algorithm.'\n        raise ValueError(msg) from e\n    edges = algo(G, terminal_nodes, weight)\n    if G.is_multigraph():\n        edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in edges)\n    T = G.edge_subgraph(edges)\n    return T",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef steiner_tree(G, terminal_nodes, weight='weight', method=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return an approximation to the minimum Steiner tree of a graph.\\n\\n    The minimum Steiner tree of `G` w.r.t a set of `terminal_nodes` (also *S*)\\n    is a tree within `G` that spans those nodes and has minimum size (sum of\\n    edge weights) among all such trees.\\n\\n    The approximation algorithm is specified with the `method` keyword\\n    argument. All three available algorithms produce a tree whose weight is\\n    within a ``(2 - (2 / l))`` factor of the weight of the optimal Steiner tree,\\n    where ``l`` is the minimum number of leaf nodes across all possible Steiner\\n    trees.\\n\\n    * ``\"kou\"`` [2]_ (runtime $O(|S| |V|^2)$) computes the minimum spanning tree of\\n      the subgraph of the metric closure of *G* induced by the terminal nodes,\\n      where the metric closure of *G* is the complete graph in which each edge is\\n      weighted by the shortest path distance between the nodes in *G*.\\n\\n    * ``\"mehlhorn\"`` [3]_ (runtime $O(|E|+|V|\\\\log|V|)$) modifies Kou et al.\\'s\\n      algorithm, beginning by finding the closest terminal node for each\\n      non-terminal. This data is used to create a complete graph containing only\\n      the terminal nodes, in which edge is weighted with the shortest path\\n      distance between them. The algorithm then proceeds in the same way as Kou\\n      et al..\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n\\n    terminal_nodes : list\\n         A list of terminal nodes for which minimum steiner tree is\\n         to be found.\\n\\n    weight : string (default = \\'weight\\')\\n        Use the edge attribute specified by this string as the edge weight.\\n        Any edge attribute not present defaults to 1.\\n\\n    method : string, optional (default = \\'kou\\')\\n        The algorithm to use to approximate the Steiner tree.\\n        Supported options: \\'kou\\', \\'mehlhorn\\'.\\n        Other inputs produce a ValueError.\\n\\n    Returns\\n    -------\\n    NetworkX graph\\n        Approximation to the minimum steiner tree of `G` induced by\\n        `terminal_nodes` .\\n\\n    Notes\\n    -----\\n    For multigraphs, the edge between two nodes with minimum weight is the\\n    edge put into the Steiner tree.\\n\\n\\n    References\\n    ----------\\n    .. [1] Steiner_tree_problem on Wikipedia.\\n           https://en.wikipedia.org/wiki/Steiner_tree_problem\\n    .. [2] Kou, L., G. Markowsky, and L. Berman. 1981.\\n           \u2018A Fast Algorithm for Steiner Trees\u2019.\\n           Acta Informatica 15 (2): 141\u201345.\\n           https://doi.org/10.1007/BF00288961.\\n    .. [3] Mehlhorn, Kurt. 1988.\\n           \u2018A Faster Approximation Algorithm for the Steiner Problem in Graphs\u2019.\\n           Information Processing Letters 27 (3): 125\u201328.\\n           https://doi.org/10.1016/0020-0190(88)90066-X.\\n    '\n    if method is None:\n        import warnings\n        msg = \"steiner_tree will change default method from 'kou' to 'mehlhorn' in version 3.2.\\nSet the `method` kwarg to remove this warning.\"\n        warnings.warn(msg, FutureWarning, stacklevel=4)\n        method = 'kou'\n    try:\n        algo = ALGORITHMS[method]\n    except KeyError as e:\n        msg = f'{method} is not a valid choice for an algorithm.'\n        raise ValueError(msg) from e\n    edges = algo(G, terminal_nodes, weight)\n    if G.is_multigraph():\n        edges = ((u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for (u, v) in edges)\n    T = G.edge_subgraph(edges)\n    return T"
        ]
    }
]