"""Bio.SeqIO support for the "gck" file format.

The GCK binary format is generated by the Gene Construction Kit software
from Textco BioSoftware, Inc.
"""
from struct import unpack
from Bio.Seq import Seq
from Bio.SeqFeature import SimpleLocation
from Bio.SeqFeature import SeqFeature
from Bio.SeqRecord import SeqRecord
from .Interfaces import SequenceIterator

def _read(handle, length):
    if False:
        for i in range(10):
            print('nop')
    'Read the specified number of bytes from the given handle.'
    data = handle.read(length)
    if len(data) < length:
        raise ValueError(f'Cannot read {length} bytes from handle')
    return data

def _read_packet(handle):
    if False:
        print('Hello World!')
    'Read a length-prefixed packet.\n\n    Parts of a GCK file are made of "packets" comprising of 4 bytes\n    giving the packet\'s size, followed by the packet\'s data.\n\n    There is no type tag. The type of a packet, and thus the type of data\n    it contains, is solely indicated by the position of the packet within\n    the GCK file.\n    '
    length = _read(handle, 4)
    length = unpack('>I', length)[0]
    data = _read(handle, length)
    return (data, length)

def _read_pstring(handle):
    if False:
        i = 10
        return i + 15
    'Read a Pascal string.\n\n    A Pascal string is one byte for length followed by the actual string.\n    '
    length = _read(handle, 1)
    length = unpack('>B', length)[0]
    data = _read(handle, length).decode('ASCII')
    return data

def _read_p4string(handle):
    if False:
        for i in range(10):
            print('nop')
    'Read a 32-bit Pascal string.\n\n    Similar to a Pascal string but length is encoded on 4 bytes.\n    '
    length = _read(handle, 4)
    length = unpack('>I', length)[0]
    data = _read(handle, length).decode('ASCII')
    return data

def _parse(handle):
    if False:
        for i in range(10):
            print('nop')
    data = handle.read(24)
    if not data:
        raise ValueError('Empty file.')
    if len(data) < 24:
        raise ValueError('Improper header, cannot read 24 bytes from handle')
    (packet, length) = _read_packet(handle)
    seq_length = unpack('>I', packet[:4])[0]
    if seq_length > length - 4:
        raise ValueError('Conflicting sequence length values')
    sequence = packet[4:].decode('ASCII')
    record = SeqRecord(Seq(sequence))
    _read_packet(handle)
    (packet, length) = _read_packet(handle)
    (seq_length, num_features) = unpack('>IH', packet[:6])
    if seq_length != len(sequence):
        raise ValueError('Conflicting sequence length values')
    if length - 6 != num_features * 92:
        raise ValueError('Features packet size inconsistent with number of features')
    for i in range(num_features):
        offset = 6 + i * 92
        feature_data = packet[offset:offset + 92]
        (start, end, type, strand, has_name, has_comment, version) = unpack('>II6xH14xB17xII35xB', feature_data)
        if strand == 1:
            strand = -1
        else:
            strand = 1
        location = SimpleLocation(start, end, strand=strand)
        if type > 0:
            type = 'CDS'
        else:
            type = 'misc_feature'
        qualifiers = {}
        if has_name > 0:
            name = _read_pstring(handle)
            qualifiers['label'] = [name]
        if has_comment > 0:
            comment = _read_p4string(handle)
            qualifiers['note'] = [comment]
        if version > 0:
            continue
        feature = SeqFeature(location, type=type, qualifiers=qualifiers)
        record.features.append(feature)
    (packet, length) = _read_packet(handle)
    (seq_length, num_sites) = unpack('>IH', packet[:6])
    if length - 6 != num_sites * 88:
        raise ValueError('Sites packet size inconsistent with number of sites')
    for i in range(num_sites):
        offset = 6 + i * 88
        site_data = packet[offset:offset + 88]
        (start, end, has_name, has_comment) = unpack('>II24xII48x', site_data)
        if has_name:
            _read_pstring(handle)
        if has_comment:
            _read_p4string(handle)
    _read_packet(handle)
    num_versions = _read(handle, 2)
    num_versions = unpack('>H', num_versions)[0]
    versions = _read(handle, num_versions * 260)
    for i in range(num_versions):
        offset = i * 260
        version_data = versions[offset:offset + 260]
        has_comment = unpack('>I', version_data[-4:])[0]
        if has_comment > 0:
            _read_p4string(handle)
    _read(handle, 706)
    name = _read_pstring(handle)
    record.name = record.id = name.split(' ')[0]
    record.description = name
    flags = _read(handle, 17)
    circularity = unpack('>16xB', flags)[0]
    if circularity > 0:
        record.annotations['topology'] = 'circular'
    else:
        record.annotations['topology'] = 'linear'
    yield record

class GckIterator(SequenceIterator):
    """Parser for GCK files."""

    def __init__(self, source):
        if False:
            while True:
                i = 10
        'Break up a GCK file into SeqRecord objects.'
        super().__init__(source, mode='b', fmt='GCK')

    def parse(self, handle):
        if False:
            i = 10
            return i + 15
        'Start parsing the file, and return a SeqRecord generator.\n\n        Note that a GCK file can only contain one sequence, so this\n        iterator will always return a single record.\n        '
        records = _parse(handle)
        return records