"""Command line wrapper for the multiple alignment program MUSCLE."""
from Bio.Application import _Option, _Switch, AbstractCommandline

class MuscleCommandline(AbstractCommandline):
    """Command line wrapper for the multiple alignment program MUSCLE.

    http://www.drive5.com/muscle/

    Notes
    -----
    Last checked against version: 3.7, briefly against 3.8

    References
    ----------
    Edgar, Robert C. (2004), MUSCLE: multiple sequence alignment with high
    accuracy and high throughput, Nucleic Acids Research 32(5), 1792-97.

    Edgar, R.C. (2004) MUSCLE: a multiple sequence alignment method with
    reduced time and space complexity. BMC Bioinformatics 5(1): 113.

    Examples
    --------
    >>> from Bio.Align.Applications import MuscleCommandline
    >>> muscle_exe = r"C:\\Program Files\\Alignments\\muscle3.8.31_i86win32.exe"
    >>> in_file = r"C:\\My Documents\\unaligned.fasta"
    >>> out_file = r"C:\\My Documents\\aligned.fasta"
    >>> muscle_cline = MuscleCommandline(muscle_exe, input=in_file, out=out_file)
    >>> print(muscle_cline)
    "C:\\Program Files\\Alignments\\muscle3.8.31_i86win32.exe" -in "C:\\My Documents\\unaligned.fasta" -out "C:\\My Documents\\aligned.fasta"

    You would typically run the command line with muscle_cline() or via
    the Python subprocess module, as described in the Biopython tutorial.

    """

    def __init__(self, cmd='muscle', **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Initialize the class.'
        CLUSTERING_ALGORITHMS = ['upgma', 'upgmb', 'neighborjoining']
        DISTANCE_MEASURES_ITER1 = ['kmer6_6', 'kmer20_3', 'kmer20_4', 'kbit20_3', 'kmer4_6']
        DISTANCE_MEASURES_ITER2 = DISTANCE_MEASURES_ITER1 + ['pctid_kimura', 'pctid_log']
        OBJECTIVE_SCORES = ['sp', 'ps', 'dp', 'xp', 'spf', 'spm']
        TREE_ROOT_METHODS = ['pseudo', 'midlongestspan', 'minavgleafdist']
        SEQUENCE_TYPES = ['protein', 'rna', 'dna', 'nucleo', 'auto']
        WEIGHTING_SCHEMES = ['none', 'clustalw', 'henikoff', 'henikoffpb', 'gsc', 'threeway']
        self.parameters = [_Option(['-in', 'in', 'input'], 'Input filename', filename=True, equate=False), _Option(['-out', 'out'], 'Output filename', filename=True, equate=False), _Switch(['-diags', 'diags'], 'Find diagonals (faster for similar sequences)'), _Switch(['-profile', 'profile'], 'Perform a profile alignment'), _Option(['-in1', 'in1'], 'First input filename for profile alignment', filename=True, equate=False), _Option(['-in2', 'in2'], 'Second input filename for a profile alignment', filename=True, equate=False), _Option(['-anchorspacing', 'anchorspacing'], 'Minimum spacing between anchor columns', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-center', 'center'], 'Center parameter - should be negative', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-cluster1', 'cluster1'], 'Clustering method used in iteration 1', checker_function=lambda x: x in CLUSTERING_ALGORITHMS, equate=False), _Option(['-cluster2', 'cluster2'], 'Clustering method used in iteration 2', checker_function=lambda x: x in CLUSTERING_ALGORITHMS, equate=False), _Option(['-diaglength', 'diaglength'], 'Minimum length of diagonal', checker_function=lambda x: isinstance(x, int), equate=True), _Option(['-diagmargin', 'diagmargin'], 'Discard this many positions at ends of diagonal', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-distance1', 'distance1'], 'Distance measure for iteration 1', checker_function=lambda x: x in DISTANCE_MEASURES_ITER1, equate=False), _Option(['-distance2', 'distance2'], 'Distance measure for iteration 2', checker_function=lambda x: x in DISTANCE_MEASURES_ITER2, equate=False), _Option(['-gapextend', 'gapextend'], 'Gap extension penalty', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-gapopen', 'gapopen'], 'Gap open score - negative number', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-hydro', 'hydro'], 'Window size for hydrophobic region', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-hydrofactor', 'hydrofactor'], 'Multiplier for gap penalties in hydrophobic regions', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-log', 'log'], 'Log file name', filename=True, equate=False), _Option(['-loga', 'loga'], 'Log file name (append to existing file)', filename=True, equate=False), _Option(['-matrix', 'matrix'], 'path to NCBI or WU-BLAST format protein substitution matrix - also set -gapopen, -gapextend and -center', filename=True, equate=False), _Option(['-diagbreak', 'diagbreak'], 'Maximum distance between two diagonals that allows them to merge into one diagonal', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-maxdiagbreak', 'maxdiagbreak'], 'Deprecated in v3.8, use -diagbreak instead.', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-maxhours', 'maxhours'], 'Maximum time to run in hours', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-maxiters', 'maxiters'], 'Maximum number of iterations', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-maxtrees', 'maxtrees'], 'Maximum number of trees to build in iteration 2', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-minbestcolscore', 'minbestcolscore'], 'Minimum score a column must have to be an anchor', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-minsmoothscore', 'minsmoothscore'], 'Minimum smoothed score a column must have to be an anchor', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-objscore', 'objscore'], 'Objective score used by tree dependent refinement', checker_function=lambda x: x in OBJECTIVE_SCORES, equate=False), _Option(['-refinewindow', 'refinewindow'], 'Length of window for -refinew', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-root1', 'root1'], 'Method used to root tree in iteration 1', checker_function=lambda x: x in TREE_ROOT_METHODS, equate=False), _Option(['-root2', 'root2'], 'Method used to root tree in iteration 2', checker_function=lambda x: x in TREE_ROOT_METHODS, equate=False), _Option(['-scorefile', 'scorefile'], 'Score file name, contains one line for each column in the alignment with average BLOSUM62 score', filename=True, equate=False), _Option(['-seqtype', 'seqtype'], 'Sequence type', checker_function=lambda x: x in SEQUENCE_TYPES, equate=False), _Option(['-smoothscoreceil', 'smoothscoreceil'], 'Maximum value of column score for smoothing', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-smoothwindow', 'smoothwindow'], 'Window used for anchor column smoothing', checker_function=lambda x: isinstance(x, int), equate=False), _Option(['-spscore', 'spscore'], 'Compute SP objective score of multiple alignment', filename=True, equate=False), _Option(['-sueff', 'sueff'], 'Constant used in UPGMB clustering', checker_function=lambda x: isinstance(x, float), equate=False), _Option(['-tree1', 'tree1'], 'Save Newick tree from iteration 1', equate=False), _Option(['-tree2', 'tree2'], 'Save Newick tree from iteration 2', equate=False), _Option(['-usetree', 'usetree'], 'Use given Newick tree as guide tree', filename=True, equate=False), _Option(['-weight1', 'weight1'], 'Weighting scheme used in iteration 1', checker_function=lambda x: x in WEIGHTING_SCHEMES, equate=False), _Option(['-weight2', 'weight2'], 'Weighting scheme used in iteration 2', checker_function=lambda x: x in WEIGHTING_SCHEMES, equate=False), _Switch(['-clw', 'clw'], 'Write output in CLUSTALW format (with a MUSCLE header)'), _Switch(['-clwstrict', 'clwstrict'], 'Write output in CLUSTALW format with version 1.81 header'), _Switch(['-fasta', 'fasta'], 'Write output in FASTA format'), _Switch(['-html', 'html'], 'Write output in HTML format'), _Switch(['-msf', 'msf'], 'Write output in MSF format'), _Switch(['-phyi', 'phyi'], 'Write output in PHYLIP interleaved format'), _Switch(['-phys', 'phys'], 'Write output in PHYLIP sequential format'), _Option(['-phyiout', 'phyiout'], 'Write PHYLIP interleaved output to specified filename', filename=True, equate=False), _Option(['-physout', 'physout'], 'Write PHYLIP sequential format to specified filename', filename=True, equate=False), _Option(['-htmlout', 'htmlout'], 'Write HTML output to specified filename', filename=True, equate=False), _Option(['-clwout', 'clwout'], 'Write CLUSTALW output (with MUSCLE header) to specified filename', filename=True, equate=False), _Option(['-clwstrictout', 'clwstrictout'], 'Write CLUSTALW output (with version 1.81 header) to specified filename', filename=True, equate=False), _Option(['-msfout', 'msfout'], 'Write MSF format output to specified filename', filename=True, equate=False), _Option(['-fastaout', 'fastaout'], 'Write FASTA format output to specified filename', filename=True, equate=False), _Switch(['-anchors', 'anchors'], 'Use anchor optimisation in tree dependent refinement iterations'), _Switch(['-noanchors', 'noanchors'], 'Do not use anchor optimisation in tree dependent refinement iterations'), _Switch(['-brenner', 'brenner'], "Use Steve Brenner's root alignment method"), _Switch(['-cluster', 'cluster'], 'Perform fast clustering of input sequences, use -tree1 to save tree'), _Switch(['-dimer', 'dimer'], 'Use faster (slightly less accurate) dimer approximationfor the SP score'), _Switch(['-group', 'group'], 'Group similar sequences in output'), _Switch(['-le', 'le'], 'Use log-expectation profile score (VTML240)'), _Switch(['-sv', 'sv'], 'Use sum-of-pairs profile score (VTML240)'), _Switch(['-sp', 'sp'], 'Use sum-of-pairs protein profile score (PAM200)'), _Switch(['-spn', 'spn'], 'Use sum-of-pairs protein nucleotide profile score'), _Switch(['-quiet', 'quiet'], 'Do not display progress messages'), _Switch(['-refine', 'refine'], 'Only do tree dependent refinement'), _Switch(['-refinew', 'refinew'], 'Only do tree dependent refinement using sliding window approach'), _Switch(['-core', 'core'], 'Do not catch exceptions'), _Switch(['-nocore', 'nocore'], 'Catch exceptions'), _Switch(['-stable', 'stable'], 'Do not group similar sequences in output (not supported in v3.8)'), _Switch(['-verbose', 'verbose'], 'Write parameter settings and progress'), _Switch(['-version', 'version'], 'Write version string to stdout and exit')]
        AbstractCommandline.__init__(self, cmd, **kwargs)
if __name__ == '__main__':
    from Bio._utils import run_doctest
    run_doctest()