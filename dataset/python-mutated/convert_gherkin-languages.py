"""
Generates I18N python module based on cucumber_ `gherkin-languages.json`_.

BASED ON:
REQUIRES:
  * argparse
  * six
  * PyYAML

.. _cucumber: https://github.com/cucumber/common
.. _gherkin: https://github.com/cucumber/gherkin
.. _`gherkin-languages.json`: https://raw.githubusercontent.com/cucumber/gherkin/main/gherkin-languages.json

.. seealso::

    * https://github.com/cucumber/gherkin/blob/main/gherkin-languages.json
    * https://raw.githubusercontent.com/cucumber/gherkin/main/gherkin-languages.json
    * https://github.com/cucumber/common

.. note::

    BASED ON: convert_i18n_yaml.py
    MISSING: u"..." prefix (unicode literal prefix) is not generated w/ py3.
"""
from __future__ import absolute_import, print_function
import os.path
import sys
from codecs import open
from urllib.request import urlopen
import pprint
import json
import argparse
import six
HERE = os.path.dirname(__file__)
NAME = os.path.basename(__file__)
__version__ = '1.0'
STEP_KEYWORDS = (u'and', u'but', u'given', u'when', u'then')
GHERKIN_LANGUAGES_JSON_URL = 'https://raw.githubusercontent.com/cucumber/gherkin/main/gherkin-languages.json'

def download_file(source_url, filename=None):
    if False:
        i = 10
        return i + 15
    with urlopen(source_url) as f:
        contents = f.read()
        dest_file = open(filename, 'wb+')
        dest_file.write(contents)
        dest_file.close()

def yaml_normalize(data):
    if False:
        while True:
            i = 10
    for part in data:
        keywords = data[part]
        for k in keywords:
            v = keywords[k]
            if not isinstance(v, six.text_type):
                v = v.decode('UTF-8')
            keywords[k] = v.split('|')
    return data

def data_normalize(data, verbose=False):
    if False:
        for i in range(10):
            print('nop')
    'Normalize "gherkin-languages.json" data into internal format,\n    needed by behave."\n\n    :param data: Language data (as dictionary).\n    :return: Normalized data (as dictionary).\n    '
    for language in data:
        if verbose:
            print('Language: %s ...' % language)
        lang_keywords = data[language]
        lang_keywords[u'scenario_outline'] = lang_keywords[u'scenarioOutline']
        del lang_keywords[u'scenarioOutline']
        if False:
            for k in lang_keywords:
                if k in STEP_KEYWORDS:
                    values = lang_keywords[k]
                    assert isinstance(values, list)
                    values2 = []
                    for step_keyword in values:
                        if step_keyword.endswith(' '):
                            step_keyword = step_keyword[:-1]
                        else:
                            step_keyword += '<'
                        values2.append(step_keyword)
                    lang_keywords[k] = values2
    return data

def gherkin_languages_to_python_module(gherkin_languages_path, output_file=None, encoding=None, verbose=False):
    if False:
        for i in range(10):
            print('nop')
    'Workhorse.\n    Performs the conversion from "gherkin-languages.json" to "i18n.py".\n    Writes output to file or console (stdout).\n\n    :param gherkin_languages_path: File path for JSON file.\n    :param output_file:     Output filename (or STDOUT for: None, "stdout", "-")\n    :param encoding:        Optional output encoding to use (default: UTF-8).\n    :param verbose:         Enable verbose mode (as bool; optional).\n    '
    if encoding is None:
        encoding = 'UTF-8'
    json_encoding = 'UTF-8'
    languages = json.load(open(gherkin_languages_path, encoding=json_encoding))
    languages = data_normalize(languages, verbose=verbose)
    header = u'# -*- coding: {encoding} -*-\n# -- GENERATED BY: convert_gherkin-languages.py\n# FROM:   "gherkin-languages.json"\n# SOURCE: {gherkin_languages_json_url}\n# pylint: disable=line-too-long, too-many-lines, missing-docstring, invalid-name\n# ruff: noqa: E501\n"""\nGherkin keywords in the different I18N languages, like:\n\n* English\n* French\n* German\n* ...\n"""\n\nfrom __future__ import unicode_literals\n\nlanguages = \\\n'.format(gherkin_languages_json_url=GHERKIN_LANGUAGES_JSON_URL, encoding=encoding)
    if not output_file or output_file in ('-', 'stdout'):
        i18n_py = sys.stdout
        should_close = False
    else:
        i18n_py = open(output_file, 'wb', encoding=encoding)
        should_close = True
    try:
        i18n_py.write(header)
        i18n_py.write(pprint.pformat(languages))
        i18n_py.write(u'\n')
    finally:
        if should_close:
            i18n_py.close()

def main(args=None):
    if False:
        i = 10
        return i + 15
    'Main function to generate the "behave/i18n.py" module\n    from the "gherkin-languages.json" file.\n\n    :param args:  List of command-line args (if None: Use ``sys.argv``)\n    :return: 0, on success (or sys.exit(NON_ZERO_NUMBER) on failure).\n    '
    if args is None:
        args = sys.argv[1:]
    parser = argparse.ArgumentParser(prog=NAME, description='Generate python module i18n from JSON based data')
    parser.add_argument('-d', '--data', dest='json_file', default=os.path.join(HERE, 'gherkin-languages.json'), help='Path to gherkin-languages.json file.')
    parser.add_argument('-e', '--encoding', dest='encoding', default='UTF-8', help='Output encoding.')
    parser.add_argument('--verbose', dest='verbose', default=False, action='store_true', help='Enable verbose mode.')
    parser.add_argument('output_file', default='i18n.py', nargs='?', help='Filename of Python I18N module (as output).')
    parser.add_argument('--version', action='version', version=__version__)
    options = parser.parse_args(args)
    if not os.path.isfile(options.json_file):
        parser.error('JSON file not found: %s' % options.json_file)
    if not options.output_file:
        options.output_file = 'i18n.py'
    try:
        print('Writing %s ..' % options.output_file)
        gherkin_languages_to_python_module(options.json_file, options.output_file, encoding=options.encoding, verbose=options.verbose)
    except Exception as e:
        message = '%s: %s' % (e.__class__.__name__, e)
        sys.exit(message)
    return 0
if __name__ == '__main__':
    sys.exit(main())