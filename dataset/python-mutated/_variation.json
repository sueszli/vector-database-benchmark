[
    {
        "func_name": "variation",
        "original": "@_axis_nan_policy_factory(lambda x: x, n_outputs=1, result_to_tuple=lambda x: (x,))\ndef variation(a, axis=0, nan_policy='propagate', ddof=0, *, keepdims=False):\n    \"\"\"\n    Compute the coefficient of variation.\n\n    The coefficient of variation is the standard deviation divided by the\n    mean.  This function is equivalent to::\n\n        np.std(x, axis=axis, ddof=ddof) / np.mean(x)\n\n    The default for ``ddof`` is 0, but many definitions of the coefficient\n    of variation use the square root of the unbiased sample variance\n    for the sample standard deviation, which corresponds to ``ddof=1``.\n\n    The function does not take the absolute value of the mean of the data,\n    so the return value is negative if the mean is negative.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int or None, optional\n        Axis along which to calculate the coefficient of variation.\n        Default is 0. If None, compute over the whole array `a`.\n    nan_policy : {'propagate', 'raise', 'omit'}, optional\n        Defines how to handle when input contains ``nan``.\n        The following options are available:\n\n          * 'propagate': return ``nan``\n          * 'raise': raise an exception\n          * 'omit': perform the calculation with ``nan`` values omitted\n\n        The default is 'propagate'.\n    ddof : int, optional\n        Gives the \"Delta Degrees Of Freedom\" used when computing the\n        standard deviation.  The divisor used in the calculation of the\n        standard deviation is ``N - ddof``, where ``N`` is the number of\n        elements.  `ddof` must be less than ``N``; if it isn't, the result\n        will be ``nan`` or ``inf``, depending on ``N`` and the values in\n        the array.  By default `ddof` is zero for backwards compatibility,\n        but it is recommended to use ``ddof=1`` to ensure that the sample\n        standard deviation is computed as the square root of the unbiased\n        sample variance.\n\n    Returns\n    -------\n    variation : ndarray\n        The calculated variation along the requested axis.\n\n    Notes\n    -----\n    There are several edge cases that are handled without generating a\n    warning:\n\n    * If both the mean and the standard deviation are zero, ``nan``\n      is returned.\n    * If the mean is zero and the standard deviation is nonzero, ``inf``\n      is returned.\n    * If the input has length zero (either because the array has zero\n      length, or all the input values are ``nan`` and ``nan_policy`` is\n      ``'omit'``), ``nan`` is returned.\n    * If the input contains ``inf``, ``nan`` is returned.\n\n    References\n    ----------\n    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard\n       Probability and Statistics Tables and Formulae. Chapman & Hall: New\n       York. 2000.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.stats import variation\n    >>> variation([1, 2, 3, 4, 5], ddof=1)\n    0.5270462766947299\n\n    Compute the variation along a given dimension of an array that contains\n    a few ``nan`` values:\n\n    >>> x = np.array([[  10.0, np.nan, 11.0, 19.0, 23.0, 29.0, 98.0],\n    ...               [  29.0,   30.0, 32.0, 33.0, 35.0, 56.0, 57.0],\n    ...               [np.nan, np.nan, 12.0, 13.0, 16.0, 16.0, 17.0]])\n    >>> variation(x, axis=1, ddof=1, nan_policy='omit')\n    array([1.05109361, 0.31428986, 0.146483  ])\n\n    \"\"\"\n    n = a.shape[axis]\n    NaN = _get_nan(a)\n    if a.size == 0 or ddof > n:\n        shp = np.asarray(a.shape)\n        shp = np.delete(shp, axis)\n        result = np.full(shp, fill_value=NaN)\n        return result[()]\n    mean_a = a.mean(axis)\n    if ddof == n:\n        std_a = a.std(axis=axis, ddof=0)\n        result = np.full_like(std_a, fill_value=NaN)\n        i = std_a > 0\n        result[i] = np.inf\n        result[i] = np.copysign(result[i], mean_a[i])\n        return result[()]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        std_a = a.std(axis, ddof=ddof)\n        result = std_a / mean_a\n    return result[()]",
        "mutated": [
            "@_axis_nan_policy_factory(lambda x: x, n_outputs=1, result_to_tuple=lambda x: (x,))\ndef variation(a, axis=0, nan_policy='propagate', ddof=0, *, keepdims=False):\n    if False:\n        i = 10\n    '\\n    Compute the coefficient of variation.\\n\\n    The coefficient of variation is the standard deviation divided by the\\n    mean.  This function is equivalent to::\\n\\n        np.std(x, axis=axis, ddof=ddof) / np.mean(x)\\n\\n    The default for ``ddof`` is 0, but many definitions of the coefficient\\n    of variation use the square root of the unbiased sample variance\\n    for the sample standard deviation, which corresponds to ``ddof=1``.\\n\\n    The function does not take the absolute value of the mean of the data,\\n    so the return value is negative if the mean is negative.\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n        Input array.\\n    axis : int or None, optional\\n        Axis along which to calculate the coefficient of variation.\\n        Default is 0. If None, compute over the whole array `a`.\\n    nan_policy : {\\'propagate\\', \\'raise\\', \\'omit\\'}, optional\\n        Defines how to handle when input contains ``nan``.\\n        The following options are available:\\n\\n          * \\'propagate\\': return ``nan``\\n          * \\'raise\\': raise an exception\\n          * \\'omit\\': perform the calculation with ``nan`` values omitted\\n\\n        The default is \\'propagate\\'.\\n    ddof : int, optional\\n        Gives the \"Delta Degrees Of Freedom\" used when computing the\\n        standard deviation.  The divisor used in the calculation of the\\n        standard deviation is ``N - ddof``, where ``N`` is the number of\\n        elements.  `ddof` must be less than ``N``; if it isn\\'t, the result\\n        will be ``nan`` or ``inf``, depending on ``N`` and the values in\\n        the array.  By default `ddof` is zero for backwards compatibility,\\n        but it is recommended to use ``ddof=1`` to ensure that the sample\\n        standard deviation is computed as the square root of the unbiased\\n        sample variance.\\n\\n    Returns\\n    -------\\n    variation : ndarray\\n        The calculated variation along the requested axis.\\n\\n    Notes\\n    -----\\n    There are several edge cases that are handled without generating a\\n    warning:\\n\\n    * If both the mean and the standard deviation are zero, ``nan``\\n      is returned.\\n    * If the mean is zero and the standard deviation is nonzero, ``inf``\\n      is returned.\\n    * If the input has length zero (either because the array has zero\\n      length, or all the input values are ``nan`` and ``nan_policy`` is\\n      ``\\'omit\\'``), ``nan`` is returned.\\n    * If the input contains ``inf``, ``nan`` is returned.\\n\\n    References\\n    ----------\\n    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard\\n       Probability and Statistics Tables and Formulae. Chapman & Hall: New\\n       York. 2000.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.stats import variation\\n    >>> variation([1, 2, 3, 4, 5], ddof=1)\\n    0.5270462766947299\\n\\n    Compute the variation along a given dimension of an array that contains\\n    a few ``nan`` values:\\n\\n    >>> x = np.array([[  10.0, np.nan, 11.0, 19.0, 23.0, 29.0, 98.0],\\n    ...               [  29.0,   30.0, 32.0, 33.0, 35.0, 56.0, 57.0],\\n    ...               [np.nan, np.nan, 12.0, 13.0, 16.0, 16.0, 17.0]])\\n    >>> variation(x, axis=1, ddof=1, nan_policy=\\'omit\\')\\n    array([1.05109361, 0.31428986, 0.146483  ])\\n\\n    '\n    n = a.shape[axis]\n    NaN = _get_nan(a)\n    if a.size == 0 or ddof > n:\n        shp = np.asarray(a.shape)\n        shp = np.delete(shp, axis)\n        result = np.full(shp, fill_value=NaN)\n        return result[()]\n    mean_a = a.mean(axis)\n    if ddof == n:\n        std_a = a.std(axis=axis, ddof=0)\n        result = np.full_like(std_a, fill_value=NaN)\n        i = std_a > 0\n        result[i] = np.inf\n        result[i] = np.copysign(result[i], mean_a[i])\n        return result[()]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        std_a = a.std(axis, ddof=ddof)\n        result = std_a / mean_a\n    return result[()]",
            "@_axis_nan_policy_factory(lambda x: x, n_outputs=1, result_to_tuple=lambda x: (x,))\ndef variation(a, axis=0, nan_policy='propagate', ddof=0, *, keepdims=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the coefficient of variation.\\n\\n    The coefficient of variation is the standard deviation divided by the\\n    mean.  This function is equivalent to::\\n\\n        np.std(x, axis=axis, ddof=ddof) / np.mean(x)\\n\\n    The default for ``ddof`` is 0, but many definitions of the coefficient\\n    of variation use the square root of the unbiased sample variance\\n    for the sample standard deviation, which corresponds to ``ddof=1``.\\n\\n    The function does not take the absolute value of the mean of the data,\\n    so the return value is negative if the mean is negative.\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n        Input array.\\n    axis : int or None, optional\\n        Axis along which to calculate the coefficient of variation.\\n        Default is 0. If None, compute over the whole array `a`.\\n    nan_policy : {\\'propagate\\', \\'raise\\', \\'omit\\'}, optional\\n        Defines how to handle when input contains ``nan``.\\n        The following options are available:\\n\\n          * \\'propagate\\': return ``nan``\\n          * \\'raise\\': raise an exception\\n          * \\'omit\\': perform the calculation with ``nan`` values omitted\\n\\n        The default is \\'propagate\\'.\\n    ddof : int, optional\\n        Gives the \"Delta Degrees Of Freedom\" used when computing the\\n        standard deviation.  The divisor used in the calculation of the\\n        standard deviation is ``N - ddof``, where ``N`` is the number of\\n        elements.  `ddof` must be less than ``N``; if it isn\\'t, the result\\n        will be ``nan`` or ``inf``, depending on ``N`` and the values in\\n        the array.  By default `ddof` is zero for backwards compatibility,\\n        but it is recommended to use ``ddof=1`` to ensure that the sample\\n        standard deviation is computed as the square root of the unbiased\\n        sample variance.\\n\\n    Returns\\n    -------\\n    variation : ndarray\\n        The calculated variation along the requested axis.\\n\\n    Notes\\n    -----\\n    There are several edge cases that are handled without generating a\\n    warning:\\n\\n    * If both the mean and the standard deviation are zero, ``nan``\\n      is returned.\\n    * If the mean is zero and the standard deviation is nonzero, ``inf``\\n      is returned.\\n    * If the input has length zero (either because the array has zero\\n      length, or all the input values are ``nan`` and ``nan_policy`` is\\n      ``\\'omit\\'``), ``nan`` is returned.\\n    * If the input contains ``inf``, ``nan`` is returned.\\n\\n    References\\n    ----------\\n    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard\\n       Probability and Statistics Tables and Formulae. Chapman & Hall: New\\n       York. 2000.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.stats import variation\\n    >>> variation([1, 2, 3, 4, 5], ddof=1)\\n    0.5270462766947299\\n\\n    Compute the variation along a given dimension of an array that contains\\n    a few ``nan`` values:\\n\\n    >>> x = np.array([[  10.0, np.nan, 11.0, 19.0, 23.0, 29.0, 98.0],\\n    ...               [  29.0,   30.0, 32.0, 33.0, 35.0, 56.0, 57.0],\\n    ...               [np.nan, np.nan, 12.0, 13.0, 16.0, 16.0, 17.0]])\\n    >>> variation(x, axis=1, ddof=1, nan_policy=\\'omit\\')\\n    array([1.05109361, 0.31428986, 0.146483  ])\\n\\n    '\n    n = a.shape[axis]\n    NaN = _get_nan(a)\n    if a.size == 0 or ddof > n:\n        shp = np.asarray(a.shape)\n        shp = np.delete(shp, axis)\n        result = np.full(shp, fill_value=NaN)\n        return result[()]\n    mean_a = a.mean(axis)\n    if ddof == n:\n        std_a = a.std(axis=axis, ddof=0)\n        result = np.full_like(std_a, fill_value=NaN)\n        i = std_a > 0\n        result[i] = np.inf\n        result[i] = np.copysign(result[i], mean_a[i])\n        return result[()]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        std_a = a.std(axis, ddof=ddof)\n        result = std_a / mean_a\n    return result[()]",
            "@_axis_nan_policy_factory(lambda x: x, n_outputs=1, result_to_tuple=lambda x: (x,))\ndef variation(a, axis=0, nan_policy='propagate', ddof=0, *, keepdims=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the coefficient of variation.\\n\\n    The coefficient of variation is the standard deviation divided by the\\n    mean.  This function is equivalent to::\\n\\n        np.std(x, axis=axis, ddof=ddof) / np.mean(x)\\n\\n    The default for ``ddof`` is 0, but many definitions of the coefficient\\n    of variation use the square root of the unbiased sample variance\\n    for the sample standard deviation, which corresponds to ``ddof=1``.\\n\\n    The function does not take the absolute value of the mean of the data,\\n    so the return value is negative if the mean is negative.\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n        Input array.\\n    axis : int or None, optional\\n        Axis along which to calculate the coefficient of variation.\\n        Default is 0. If None, compute over the whole array `a`.\\n    nan_policy : {\\'propagate\\', \\'raise\\', \\'omit\\'}, optional\\n        Defines how to handle when input contains ``nan``.\\n        The following options are available:\\n\\n          * \\'propagate\\': return ``nan``\\n          * \\'raise\\': raise an exception\\n          * \\'omit\\': perform the calculation with ``nan`` values omitted\\n\\n        The default is \\'propagate\\'.\\n    ddof : int, optional\\n        Gives the \"Delta Degrees Of Freedom\" used when computing the\\n        standard deviation.  The divisor used in the calculation of the\\n        standard deviation is ``N - ddof``, where ``N`` is the number of\\n        elements.  `ddof` must be less than ``N``; if it isn\\'t, the result\\n        will be ``nan`` or ``inf``, depending on ``N`` and the values in\\n        the array.  By default `ddof` is zero for backwards compatibility,\\n        but it is recommended to use ``ddof=1`` to ensure that the sample\\n        standard deviation is computed as the square root of the unbiased\\n        sample variance.\\n\\n    Returns\\n    -------\\n    variation : ndarray\\n        The calculated variation along the requested axis.\\n\\n    Notes\\n    -----\\n    There are several edge cases that are handled without generating a\\n    warning:\\n\\n    * If both the mean and the standard deviation are zero, ``nan``\\n      is returned.\\n    * If the mean is zero and the standard deviation is nonzero, ``inf``\\n      is returned.\\n    * If the input has length zero (either because the array has zero\\n      length, or all the input values are ``nan`` and ``nan_policy`` is\\n      ``\\'omit\\'``), ``nan`` is returned.\\n    * If the input contains ``inf``, ``nan`` is returned.\\n\\n    References\\n    ----------\\n    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard\\n       Probability and Statistics Tables and Formulae. Chapman & Hall: New\\n       York. 2000.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.stats import variation\\n    >>> variation([1, 2, 3, 4, 5], ddof=1)\\n    0.5270462766947299\\n\\n    Compute the variation along a given dimension of an array that contains\\n    a few ``nan`` values:\\n\\n    >>> x = np.array([[  10.0, np.nan, 11.0, 19.0, 23.0, 29.0, 98.0],\\n    ...               [  29.0,   30.0, 32.0, 33.0, 35.0, 56.0, 57.0],\\n    ...               [np.nan, np.nan, 12.0, 13.0, 16.0, 16.0, 17.0]])\\n    >>> variation(x, axis=1, ddof=1, nan_policy=\\'omit\\')\\n    array([1.05109361, 0.31428986, 0.146483  ])\\n\\n    '\n    n = a.shape[axis]\n    NaN = _get_nan(a)\n    if a.size == 0 or ddof > n:\n        shp = np.asarray(a.shape)\n        shp = np.delete(shp, axis)\n        result = np.full(shp, fill_value=NaN)\n        return result[()]\n    mean_a = a.mean(axis)\n    if ddof == n:\n        std_a = a.std(axis=axis, ddof=0)\n        result = np.full_like(std_a, fill_value=NaN)\n        i = std_a > 0\n        result[i] = np.inf\n        result[i] = np.copysign(result[i], mean_a[i])\n        return result[()]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        std_a = a.std(axis, ddof=ddof)\n        result = std_a / mean_a\n    return result[()]",
            "@_axis_nan_policy_factory(lambda x: x, n_outputs=1, result_to_tuple=lambda x: (x,))\ndef variation(a, axis=0, nan_policy='propagate', ddof=0, *, keepdims=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the coefficient of variation.\\n\\n    The coefficient of variation is the standard deviation divided by the\\n    mean.  This function is equivalent to::\\n\\n        np.std(x, axis=axis, ddof=ddof) / np.mean(x)\\n\\n    The default for ``ddof`` is 0, but many definitions of the coefficient\\n    of variation use the square root of the unbiased sample variance\\n    for the sample standard deviation, which corresponds to ``ddof=1``.\\n\\n    The function does not take the absolute value of the mean of the data,\\n    so the return value is negative if the mean is negative.\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n        Input array.\\n    axis : int or None, optional\\n        Axis along which to calculate the coefficient of variation.\\n        Default is 0. If None, compute over the whole array `a`.\\n    nan_policy : {\\'propagate\\', \\'raise\\', \\'omit\\'}, optional\\n        Defines how to handle when input contains ``nan``.\\n        The following options are available:\\n\\n          * \\'propagate\\': return ``nan``\\n          * \\'raise\\': raise an exception\\n          * \\'omit\\': perform the calculation with ``nan`` values omitted\\n\\n        The default is \\'propagate\\'.\\n    ddof : int, optional\\n        Gives the \"Delta Degrees Of Freedom\" used when computing the\\n        standard deviation.  The divisor used in the calculation of the\\n        standard deviation is ``N - ddof``, where ``N`` is the number of\\n        elements.  `ddof` must be less than ``N``; if it isn\\'t, the result\\n        will be ``nan`` or ``inf``, depending on ``N`` and the values in\\n        the array.  By default `ddof` is zero for backwards compatibility,\\n        but it is recommended to use ``ddof=1`` to ensure that the sample\\n        standard deviation is computed as the square root of the unbiased\\n        sample variance.\\n\\n    Returns\\n    -------\\n    variation : ndarray\\n        The calculated variation along the requested axis.\\n\\n    Notes\\n    -----\\n    There are several edge cases that are handled without generating a\\n    warning:\\n\\n    * If both the mean and the standard deviation are zero, ``nan``\\n      is returned.\\n    * If the mean is zero and the standard deviation is nonzero, ``inf``\\n      is returned.\\n    * If the input has length zero (either because the array has zero\\n      length, or all the input values are ``nan`` and ``nan_policy`` is\\n      ``\\'omit\\'``), ``nan`` is returned.\\n    * If the input contains ``inf``, ``nan`` is returned.\\n\\n    References\\n    ----------\\n    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard\\n       Probability and Statistics Tables and Formulae. Chapman & Hall: New\\n       York. 2000.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.stats import variation\\n    >>> variation([1, 2, 3, 4, 5], ddof=1)\\n    0.5270462766947299\\n\\n    Compute the variation along a given dimension of an array that contains\\n    a few ``nan`` values:\\n\\n    >>> x = np.array([[  10.0, np.nan, 11.0, 19.0, 23.0, 29.0, 98.0],\\n    ...               [  29.0,   30.0, 32.0, 33.0, 35.0, 56.0, 57.0],\\n    ...               [np.nan, np.nan, 12.0, 13.0, 16.0, 16.0, 17.0]])\\n    >>> variation(x, axis=1, ddof=1, nan_policy=\\'omit\\')\\n    array([1.05109361, 0.31428986, 0.146483  ])\\n\\n    '\n    n = a.shape[axis]\n    NaN = _get_nan(a)\n    if a.size == 0 or ddof > n:\n        shp = np.asarray(a.shape)\n        shp = np.delete(shp, axis)\n        result = np.full(shp, fill_value=NaN)\n        return result[()]\n    mean_a = a.mean(axis)\n    if ddof == n:\n        std_a = a.std(axis=axis, ddof=0)\n        result = np.full_like(std_a, fill_value=NaN)\n        i = std_a > 0\n        result[i] = np.inf\n        result[i] = np.copysign(result[i], mean_a[i])\n        return result[()]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        std_a = a.std(axis, ddof=ddof)\n        result = std_a / mean_a\n    return result[()]",
            "@_axis_nan_policy_factory(lambda x: x, n_outputs=1, result_to_tuple=lambda x: (x,))\ndef variation(a, axis=0, nan_policy='propagate', ddof=0, *, keepdims=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the coefficient of variation.\\n\\n    The coefficient of variation is the standard deviation divided by the\\n    mean.  This function is equivalent to::\\n\\n        np.std(x, axis=axis, ddof=ddof) / np.mean(x)\\n\\n    The default for ``ddof`` is 0, but many definitions of the coefficient\\n    of variation use the square root of the unbiased sample variance\\n    for the sample standard deviation, which corresponds to ``ddof=1``.\\n\\n    The function does not take the absolute value of the mean of the data,\\n    so the return value is negative if the mean is negative.\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n        Input array.\\n    axis : int or None, optional\\n        Axis along which to calculate the coefficient of variation.\\n        Default is 0. If None, compute over the whole array `a`.\\n    nan_policy : {\\'propagate\\', \\'raise\\', \\'omit\\'}, optional\\n        Defines how to handle when input contains ``nan``.\\n        The following options are available:\\n\\n          * \\'propagate\\': return ``nan``\\n          * \\'raise\\': raise an exception\\n          * \\'omit\\': perform the calculation with ``nan`` values omitted\\n\\n        The default is \\'propagate\\'.\\n    ddof : int, optional\\n        Gives the \"Delta Degrees Of Freedom\" used when computing the\\n        standard deviation.  The divisor used in the calculation of the\\n        standard deviation is ``N - ddof``, where ``N`` is the number of\\n        elements.  `ddof` must be less than ``N``; if it isn\\'t, the result\\n        will be ``nan`` or ``inf``, depending on ``N`` and the values in\\n        the array.  By default `ddof` is zero for backwards compatibility,\\n        but it is recommended to use ``ddof=1`` to ensure that the sample\\n        standard deviation is computed as the square root of the unbiased\\n        sample variance.\\n\\n    Returns\\n    -------\\n    variation : ndarray\\n        The calculated variation along the requested axis.\\n\\n    Notes\\n    -----\\n    There are several edge cases that are handled without generating a\\n    warning:\\n\\n    * If both the mean and the standard deviation are zero, ``nan``\\n      is returned.\\n    * If the mean is zero and the standard deviation is nonzero, ``inf``\\n      is returned.\\n    * If the input has length zero (either because the array has zero\\n      length, or all the input values are ``nan`` and ``nan_policy`` is\\n      ``\\'omit\\'``), ``nan`` is returned.\\n    * If the input contains ``inf``, ``nan`` is returned.\\n\\n    References\\n    ----------\\n    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard\\n       Probability and Statistics Tables and Formulae. Chapman & Hall: New\\n       York. 2000.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.stats import variation\\n    >>> variation([1, 2, 3, 4, 5], ddof=1)\\n    0.5270462766947299\\n\\n    Compute the variation along a given dimension of an array that contains\\n    a few ``nan`` values:\\n\\n    >>> x = np.array([[  10.0, np.nan, 11.0, 19.0, 23.0, 29.0, 98.0],\\n    ...               [  29.0,   30.0, 32.0, 33.0, 35.0, 56.0, 57.0],\\n    ...               [np.nan, np.nan, 12.0, 13.0, 16.0, 16.0, 17.0]])\\n    >>> variation(x, axis=1, ddof=1, nan_policy=\\'omit\\')\\n    array([1.05109361, 0.31428986, 0.146483  ])\\n\\n    '\n    n = a.shape[axis]\n    NaN = _get_nan(a)\n    if a.size == 0 or ddof > n:\n        shp = np.asarray(a.shape)\n        shp = np.delete(shp, axis)\n        result = np.full(shp, fill_value=NaN)\n        return result[()]\n    mean_a = a.mean(axis)\n    if ddof == n:\n        std_a = a.std(axis=axis, ddof=0)\n        result = np.full_like(std_a, fill_value=NaN)\n        i = std_a > 0\n        result[i] = np.inf\n        result[i] = np.copysign(result[i], mean_a[i])\n        return result[()]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        std_a = a.std(axis, ddof=ddof)\n        result = std_a / mean_a\n    return result[()]"
        ]
    }
]