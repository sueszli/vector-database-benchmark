[
    {
        "func_name": "get_creatable_game_entity",
        "original": "@staticmethod\ndef get_creatable_game_entity(line: GenieGameEntityGroup) -> None:\n    \"\"\"\n        Creates the CreatableGameEntity object for a unit/building line.\n\n        :param line: Unit/Building line.\n        :type line: ...dataformat.converter_object.ConverterObjectGroup\n        \"\"\"\n    if isinstance(line, GenieVillagerGroup):\n        current_unit = line.variants[0].line[0]\n    else:\n        current_unit = line.line[0]\n    current_unit_id = line.get_head_unit_id()\n    dataset = line.data\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    game_entity_name = name_lookup_dict[current_unit_id][0]\n    obj_ref = f'{game_entity_name}.CreatableGameEntity'\n    obj_name = f'{game_entity_name}Creatable'\n    creatable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    creatable_raw_api_object.add_raw_parent('engine.util.create.CreatableGameEntity')\n    train_location_id = line.get_train_location_id()\n    if isinstance(line, GenieBuildingLineGroup):\n        train_location = dataset.unit_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    else:\n        train_location = dataset.building_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    if line.is_unique():\n        enabling_research_id = line.get_enabling_research_id()\n        enabling_research = dataset.genie_techs[enabling_research_id]\n        enabling_civ_id = enabling_research['civilization_id'].value\n        civ = dataset.civ_groups[enabling_civ_id]\n        civ_name = civ_lookup_dict[enabling_civ_id][0]\n        creatable_location = ForwardRef(civ, civ_name)\n    else:\n        creatable_location = ForwardRef(train_location, f'{train_location_name}.Create')\n    creatable_raw_api_object.set_location(creatable_location)\n    game_entity_forward_ref = ForwardRef(line, game_entity_name)\n    creatable_raw_api_object.add_raw_member('game_entity', game_entity_forward_ref, 'engine.util.create.CreatableGameEntity')\n    variants_set = []\n    creatable_raw_api_object.add_raw_member('variants', variants_set, 'engine.util.create.CreatableGameEntity')\n    cost_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_name, f'{game_entity_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    creatable_forward_ref = ForwardRef(line, obj_ref)\n    cost_raw_api_object.set_location(creatable_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    if line.is_repairable():\n        cost_repair_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}RepairCost'\n        cost_repair_raw_api_object = RawAPIObject(cost_repair_name, f'{game_entity_name}RepairCost', dataset.nyan_api_objects)\n        cost_repair_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n        creatable_forward_ref = ForwardRef(line, obj_ref)\n        cost_repair_raw_api_object.set_location(creatable_forward_ref)\n        payment_repair_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Adaptive']\n        cost_repair_raw_api_object.add_raw_member('payment_mode', payment_repair_mode, 'engine.util.cost.Cost')\n        line.add_raw_api_object(cost_repair_raw_api_object)\n    cost_amounts = []\n    cost_repair_amounts = []\n    for resource_amount in current_unit['resource_cost'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_name = f'{cost_name}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(line, cost_name)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n        cost_amounts.append(cost_amount_forward_ref)\n        line.add_raw_api_object(cost_amount)\n        if line.is_repairable():\n            cost_amount_name = f'{cost_repair_name}.{resource_name}Amount'\n            cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n            cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n            cost_forward_ref = ForwardRef(line, cost_repair_name)\n            cost_amount.set_location(cost_forward_ref)\n            cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n            cost_amount.add_raw_member('amount', amount / 2, 'engine.util.resource.ResourceAmount')\n            cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n            cost_repair_amounts.append(cost_amount_forward_ref)\n            line.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    if line.is_repairable():\n        cost_repair_raw_api_object.add_raw_member('amount', cost_repair_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(line, cost_name)\n    creatable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.create.CreatableGameEntity')\n    if isinstance(line, GenieUnitLineGroup):\n        creation_time = current_unit['creation_time'].value\n    else:\n        creation_time = 0\n    creatable_raw_api_object.add_raw_member('creation_time', creation_time, 'engine.util.create.CreatableGameEntity')\n    creation_sound_id = current_unit['train_sound_id'].value\n    obj_name = f'{game_entity_name}.CreatableGameEntity.Sound'\n    sound_raw_api_object = RawAPIObject(obj_name, 'CreationSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(line, obj_ref)\n    sound_raw_api_object.set_location(sound_location)\n    creation_sounds = []\n    if creation_sound_id > -1:\n        genie_sound = dataset.genie_sounds[creation_sound_id]\n        file_id = genie_sound.get_sounds(civ_id=-1)[0]\n        if file_id in dataset.combined_sounds:\n            creation_sound = dataset.combined_sounds[file_id]\n            creation_sound.add_reference(sound_raw_api_object)\n        else:\n            creation_sound = CombinedSound(creation_sound_id, file_id, f'creation_sound_{creation_sound_id}', dataset)\n            dataset.combined_sounds.update({file_id: creation_sound})\n            creation_sound.add_reference(sound_raw_api_object)\n        creation_sounds.append(creation_sound)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', creation_sounds, 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(line, obj_name)\n    creatable_raw_api_object.add_raw_member('creation_sounds', [sound_forward_ref], 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    enabling_research_id = line.get_enabling_research_id()\n    if enabling_research_id > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(line, obj_ref, enabling_research_id))\n    creatable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.create.CreatableGameEntity')\n    placement_modes = []\n    if isinstance(line, GenieBuildingLineGroup):\n        obj_name = f'{game_entity_name}.CreatableGameEntity.Place'\n        place_raw_api_object = RawAPIObject(obj_name, 'Place', dataset.nyan_api_objects)\n        place_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Place')\n        place_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        place_raw_api_object.set_location(place_location)\n        place_raw_api_object.add_raw_member('tile_snap_distance', 1.0, 'engine.util.placement_mode.type.Place')\n        clearance_size_x = current_unit['clearance_size_x'].value\n        clearance_size_y = current_unit['clearance_size_y'].value\n        place_raw_api_object.add_raw_member('clearance_size_x', clearance_size_x, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('clearance_size_y', clearance_size_y, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('allow_rotation', True, 'engine.util.placement_mode.type.Place')\n        elevation_mode = current_unit['elevation_mode'].value\n        if elevation_mode == 2:\n            max_elevation_difference = 0\n        elif elevation_mode == 3:\n            max_elevation_difference = 1\n        else:\n            max_elevation_difference = MemberSpecialValue.NYAN_INF\n        place_raw_api_object.add_raw_member('max_elevation_difference', max_elevation_difference, 'engine.util.placement_mode.type.Place')\n        line.add_raw_api_object(place_raw_api_object)\n        place_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(place_forward_ref)\n        if line.get_class_id() == 39:\n            obj_name = f'{game_entity_name}.CreatableGameEntity.Replace'\n            replace_raw_api_object = RawAPIObject(obj_name, 'Replace', dataset.nyan_api_objects)\n            replace_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Replace')\n            replace_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n            replace_raw_api_object.set_location(replace_location)\n            wall_line_id = 117\n            wall_line = dataset.building_lines[wall_line_id]\n            wall_name = name_lookup_dict[117][0]\n            game_entities = [ForwardRef(wall_line, wall_name)]\n            replace_raw_api_object.add_raw_member('game_entities', game_entities, 'engine.util.placement_mode.type.Replace')\n            line.add_raw_api_object(replace_raw_api_object)\n            replace_forward_ref = ForwardRef(line, obj_name)\n            placement_modes.append(replace_forward_ref)\n    else:\n        placement_modes.append(dataset.nyan_api_objects['engine.util.placement_mode.type.Eject'])\n        obj_name = f'{game_entity_name}.CreatableGameEntity.OwnStorage'\n        own_storage_raw_api_object = RawAPIObject(obj_name, 'OwnStorage', dataset.nyan_api_objects)\n        own_storage_raw_api_object.add_raw_parent('engine.util.placement_mode.type.OwnStorage')\n        own_storage_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        own_storage_raw_api_object.set_location(own_storage_location)\n        container_forward_ref = ForwardRef(train_location, f'{train_location_name}.Storage.{train_location_name}Container')\n        own_storage_raw_api_object.add_raw_member('container', container_forward_ref, 'engine.util.placement_mode.type.OwnStorage')\n        line.add_raw_api_object(own_storage_raw_api_object)\n        own_storage_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(own_storage_forward_ref)\n    creatable_raw_api_object.add_raw_member('placement_modes', placement_modes, 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(creatable_raw_api_object)\n    line.add_raw_api_object(cost_raw_api_object)",
        "mutated": [
            "@staticmethod\ndef get_creatable_game_entity(line: GenieGameEntityGroup) -> None:\n    if False:\n        i = 10\n    '\\n        Creates the CreatableGameEntity object for a unit/building line.\\n\\n        :param line: Unit/Building line.\\n        :type line: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    if isinstance(line, GenieVillagerGroup):\n        current_unit = line.variants[0].line[0]\n    else:\n        current_unit = line.line[0]\n    current_unit_id = line.get_head_unit_id()\n    dataset = line.data\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    game_entity_name = name_lookup_dict[current_unit_id][0]\n    obj_ref = f'{game_entity_name}.CreatableGameEntity'\n    obj_name = f'{game_entity_name}Creatable'\n    creatable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    creatable_raw_api_object.add_raw_parent('engine.util.create.CreatableGameEntity')\n    train_location_id = line.get_train_location_id()\n    if isinstance(line, GenieBuildingLineGroup):\n        train_location = dataset.unit_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    else:\n        train_location = dataset.building_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    if line.is_unique():\n        enabling_research_id = line.get_enabling_research_id()\n        enabling_research = dataset.genie_techs[enabling_research_id]\n        enabling_civ_id = enabling_research['civilization_id'].value\n        civ = dataset.civ_groups[enabling_civ_id]\n        civ_name = civ_lookup_dict[enabling_civ_id][0]\n        creatable_location = ForwardRef(civ, civ_name)\n    else:\n        creatable_location = ForwardRef(train_location, f'{train_location_name}.Create')\n    creatable_raw_api_object.set_location(creatable_location)\n    game_entity_forward_ref = ForwardRef(line, game_entity_name)\n    creatable_raw_api_object.add_raw_member('game_entity', game_entity_forward_ref, 'engine.util.create.CreatableGameEntity')\n    variants_set = []\n    creatable_raw_api_object.add_raw_member('variants', variants_set, 'engine.util.create.CreatableGameEntity')\n    cost_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_name, f'{game_entity_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    creatable_forward_ref = ForwardRef(line, obj_ref)\n    cost_raw_api_object.set_location(creatable_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    if line.is_repairable():\n        cost_repair_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}RepairCost'\n        cost_repair_raw_api_object = RawAPIObject(cost_repair_name, f'{game_entity_name}RepairCost', dataset.nyan_api_objects)\n        cost_repair_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n        creatable_forward_ref = ForwardRef(line, obj_ref)\n        cost_repair_raw_api_object.set_location(creatable_forward_ref)\n        payment_repair_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Adaptive']\n        cost_repair_raw_api_object.add_raw_member('payment_mode', payment_repair_mode, 'engine.util.cost.Cost')\n        line.add_raw_api_object(cost_repair_raw_api_object)\n    cost_amounts = []\n    cost_repair_amounts = []\n    for resource_amount in current_unit['resource_cost'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_name = f'{cost_name}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(line, cost_name)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n        cost_amounts.append(cost_amount_forward_ref)\n        line.add_raw_api_object(cost_amount)\n        if line.is_repairable():\n            cost_amount_name = f'{cost_repair_name}.{resource_name}Amount'\n            cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n            cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n            cost_forward_ref = ForwardRef(line, cost_repair_name)\n            cost_amount.set_location(cost_forward_ref)\n            cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n            cost_amount.add_raw_member('amount', amount / 2, 'engine.util.resource.ResourceAmount')\n            cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n            cost_repair_amounts.append(cost_amount_forward_ref)\n            line.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    if line.is_repairable():\n        cost_repair_raw_api_object.add_raw_member('amount', cost_repair_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(line, cost_name)\n    creatable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.create.CreatableGameEntity')\n    if isinstance(line, GenieUnitLineGroup):\n        creation_time = current_unit['creation_time'].value\n    else:\n        creation_time = 0\n    creatable_raw_api_object.add_raw_member('creation_time', creation_time, 'engine.util.create.CreatableGameEntity')\n    creation_sound_id = current_unit['train_sound_id'].value\n    obj_name = f'{game_entity_name}.CreatableGameEntity.Sound'\n    sound_raw_api_object = RawAPIObject(obj_name, 'CreationSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(line, obj_ref)\n    sound_raw_api_object.set_location(sound_location)\n    creation_sounds = []\n    if creation_sound_id > -1:\n        genie_sound = dataset.genie_sounds[creation_sound_id]\n        file_id = genie_sound.get_sounds(civ_id=-1)[0]\n        if file_id in dataset.combined_sounds:\n            creation_sound = dataset.combined_sounds[file_id]\n            creation_sound.add_reference(sound_raw_api_object)\n        else:\n            creation_sound = CombinedSound(creation_sound_id, file_id, f'creation_sound_{creation_sound_id}', dataset)\n            dataset.combined_sounds.update({file_id: creation_sound})\n            creation_sound.add_reference(sound_raw_api_object)\n        creation_sounds.append(creation_sound)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', creation_sounds, 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(line, obj_name)\n    creatable_raw_api_object.add_raw_member('creation_sounds', [sound_forward_ref], 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    enabling_research_id = line.get_enabling_research_id()\n    if enabling_research_id > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(line, obj_ref, enabling_research_id))\n    creatable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.create.CreatableGameEntity')\n    placement_modes = []\n    if isinstance(line, GenieBuildingLineGroup):\n        obj_name = f'{game_entity_name}.CreatableGameEntity.Place'\n        place_raw_api_object = RawAPIObject(obj_name, 'Place', dataset.nyan_api_objects)\n        place_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Place')\n        place_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        place_raw_api_object.set_location(place_location)\n        place_raw_api_object.add_raw_member('tile_snap_distance', 1.0, 'engine.util.placement_mode.type.Place')\n        clearance_size_x = current_unit['clearance_size_x'].value\n        clearance_size_y = current_unit['clearance_size_y'].value\n        place_raw_api_object.add_raw_member('clearance_size_x', clearance_size_x, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('clearance_size_y', clearance_size_y, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('allow_rotation', True, 'engine.util.placement_mode.type.Place')\n        elevation_mode = current_unit['elevation_mode'].value\n        if elevation_mode == 2:\n            max_elevation_difference = 0\n        elif elevation_mode == 3:\n            max_elevation_difference = 1\n        else:\n            max_elevation_difference = MemberSpecialValue.NYAN_INF\n        place_raw_api_object.add_raw_member('max_elevation_difference', max_elevation_difference, 'engine.util.placement_mode.type.Place')\n        line.add_raw_api_object(place_raw_api_object)\n        place_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(place_forward_ref)\n        if line.get_class_id() == 39:\n            obj_name = f'{game_entity_name}.CreatableGameEntity.Replace'\n            replace_raw_api_object = RawAPIObject(obj_name, 'Replace', dataset.nyan_api_objects)\n            replace_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Replace')\n            replace_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n            replace_raw_api_object.set_location(replace_location)\n            wall_line_id = 117\n            wall_line = dataset.building_lines[wall_line_id]\n            wall_name = name_lookup_dict[117][0]\n            game_entities = [ForwardRef(wall_line, wall_name)]\n            replace_raw_api_object.add_raw_member('game_entities', game_entities, 'engine.util.placement_mode.type.Replace')\n            line.add_raw_api_object(replace_raw_api_object)\n            replace_forward_ref = ForwardRef(line, obj_name)\n            placement_modes.append(replace_forward_ref)\n    else:\n        placement_modes.append(dataset.nyan_api_objects['engine.util.placement_mode.type.Eject'])\n        obj_name = f'{game_entity_name}.CreatableGameEntity.OwnStorage'\n        own_storage_raw_api_object = RawAPIObject(obj_name, 'OwnStorage', dataset.nyan_api_objects)\n        own_storage_raw_api_object.add_raw_parent('engine.util.placement_mode.type.OwnStorage')\n        own_storage_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        own_storage_raw_api_object.set_location(own_storage_location)\n        container_forward_ref = ForwardRef(train_location, f'{train_location_name}.Storage.{train_location_name}Container')\n        own_storage_raw_api_object.add_raw_member('container', container_forward_ref, 'engine.util.placement_mode.type.OwnStorage')\n        line.add_raw_api_object(own_storage_raw_api_object)\n        own_storage_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(own_storage_forward_ref)\n    creatable_raw_api_object.add_raw_member('placement_modes', placement_modes, 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(creatable_raw_api_object)\n    line.add_raw_api_object(cost_raw_api_object)",
            "@staticmethod\ndef get_creatable_game_entity(line: GenieGameEntityGroup) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Creates the CreatableGameEntity object for a unit/building line.\\n\\n        :param line: Unit/Building line.\\n        :type line: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    if isinstance(line, GenieVillagerGroup):\n        current_unit = line.variants[0].line[0]\n    else:\n        current_unit = line.line[0]\n    current_unit_id = line.get_head_unit_id()\n    dataset = line.data\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    game_entity_name = name_lookup_dict[current_unit_id][0]\n    obj_ref = f'{game_entity_name}.CreatableGameEntity'\n    obj_name = f'{game_entity_name}Creatable'\n    creatable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    creatable_raw_api_object.add_raw_parent('engine.util.create.CreatableGameEntity')\n    train_location_id = line.get_train_location_id()\n    if isinstance(line, GenieBuildingLineGroup):\n        train_location = dataset.unit_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    else:\n        train_location = dataset.building_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    if line.is_unique():\n        enabling_research_id = line.get_enabling_research_id()\n        enabling_research = dataset.genie_techs[enabling_research_id]\n        enabling_civ_id = enabling_research['civilization_id'].value\n        civ = dataset.civ_groups[enabling_civ_id]\n        civ_name = civ_lookup_dict[enabling_civ_id][0]\n        creatable_location = ForwardRef(civ, civ_name)\n    else:\n        creatable_location = ForwardRef(train_location, f'{train_location_name}.Create')\n    creatable_raw_api_object.set_location(creatable_location)\n    game_entity_forward_ref = ForwardRef(line, game_entity_name)\n    creatable_raw_api_object.add_raw_member('game_entity', game_entity_forward_ref, 'engine.util.create.CreatableGameEntity')\n    variants_set = []\n    creatable_raw_api_object.add_raw_member('variants', variants_set, 'engine.util.create.CreatableGameEntity')\n    cost_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_name, f'{game_entity_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    creatable_forward_ref = ForwardRef(line, obj_ref)\n    cost_raw_api_object.set_location(creatable_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    if line.is_repairable():\n        cost_repair_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}RepairCost'\n        cost_repair_raw_api_object = RawAPIObject(cost_repair_name, f'{game_entity_name}RepairCost', dataset.nyan_api_objects)\n        cost_repair_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n        creatable_forward_ref = ForwardRef(line, obj_ref)\n        cost_repair_raw_api_object.set_location(creatable_forward_ref)\n        payment_repair_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Adaptive']\n        cost_repair_raw_api_object.add_raw_member('payment_mode', payment_repair_mode, 'engine.util.cost.Cost')\n        line.add_raw_api_object(cost_repair_raw_api_object)\n    cost_amounts = []\n    cost_repair_amounts = []\n    for resource_amount in current_unit['resource_cost'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_name = f'{cost_name}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(line, cost_name)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n        cost_amounts.append(cost_amount_forward_ref)\n        line.add_raw_api_object(cost_amount)\n        if line.is_repairable():\n            cost_amount_name = f'{cost_repair_name}.{resource_name}Amount'\n            cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n            cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n            cost_forward_ref = ForwardRef(line, cost_repair_name)\n            cost_amount.set_location(cost_forward_ref)\n            cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n            cost_amount.add_raw_member('amount', amount / 2, 'engine.util.resource.ResourceAmount')\n            cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n            cost_repair_amounts.append(cost_amount_forward_ref)\n            line.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    if line.is_repairable():\n        cost_repair_raw_api_object.add_raw_member('amount', cost_repair_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(line, cost_name)\n    creatable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.create.CreatableGameEntity')\n    if isinstance(line, GenieUnitLineGroup):\n        creation_time = current_unit['creation_time'].value\n    else:\n        creation_time = 0\n    creatable_raw_api_object.add_raw_member('creation_time', creation_time, 'engine.util.create.CreatableGameEntity')\n    creation_sound_id = current_unit['train_sound_id'].value\n    obj_name = f'{game_entity_name}.CreatableGameEntity.Sound'\n    sound_raw_api_object = RawAPIObject(obj_name, 'CreationSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(line, obj_ref)\n    sound_raw_api_object.set_location(sound_location)\n    creation_sounds = []\n    if creation_sound_id > -1:\n        genie_sound = dataset.genie_sounds[creation_sound_id]\n        file_id = genie_sound.get_sounds(civ_id=-1)[0]\n        if file_id in dataset.combined_sounds:\n            creation_sound = dataset.combined_sounds[file_id]\n            creation_sound.add_reference(sound_raw_api_object)\n        else:\n            creation_sound = CombinedSound(creation_sound_id, file_id, f'creation_sound_{creation_sound_id}', dataset)\n            dataset.combined_sounds.update({file_id: creation_sound})\n            creation_sound.add_reference(sound_raw_api_object)\n        creation_sounds.append(creation_sound)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', creation_sounds, 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(line, obj_name)\n    creatable_raw_api_object.add_raw_member('creation_sounds', [sound_forward_ref], 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    enabling_research_id = line.get_enabling_research_id()\n    if enabling_research_id > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(line, obj_ref, enabling_research_id))\n    creatable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.create.CreatableGameEntity')\n    placement_modes = []\n    if isinstance(line, GenieBuildingLineGroup):\n        obj_name = f'{game_entity_name}.CreatableGameEntity.Place'\n        place_raw_api_object = RawAPIObject(obj_name, 'Place', dataset.nyan_api_objects)\n        place_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Place')\n        place_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        place_raw_api_object.set_location(place_location)\n        place_raw_api_object.add_raw_member('tile_snap_distance', 1.0, 'engine.util.placement_mode.type.Place')\n        clearance_size_x = current_unit['clearance_size_x'].value\n        clearance_size_y = current_unit['clearance_size_y'].value\n        place_raw_api_object.add_raw_member('clearance_size_x', clearance_size_x, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('clearance_size_y', clearance_size_y, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('allow_rotation', True, 'engine.util.placement_mode.type.Place')\n        elevation_mode = current_unit['elevation_mode'].value\n        if elevation_mode == 2:\n            max_elevation_difference = 0\n        elif elevation_mode == 3:\n            max_elevation_difference = 1\n        else:\n            max_elevation_difference = MemberSpecialValue.NYAN_INF\n        place_raw_api_object.add_raw_member('max_elevation_difference', max_elevation_difference, 'engine.util.placement_mode.type.Place')\n        line.add_raw_api_object(place_raw_api_object)\n        place_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(place_forward_ref)\n        if line.get_class_id() == 39:\n            obj_name = f'{game_entity_name}.CreatableGameEntity.Replace'\n            replace_raw_api_object = RawAPIObject(obj_name, 'Replace', dataset.nyan_api_objects)\n            replace_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Replace')\n            replace_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n            replace_raw_api_object.set_location(replace_location)\n            wall_line_id = 117\n            wall_line = dataset.building_lines[wall_line_id]\n            wall_name = name_lookup_dict[117][0]\n            game_entities = [ForwardRef(wall_line, wall_name)]\n            replace_raw_api_object.add_raw_member('game_entities', game_entities, 'engine.util.placement_mode.type.Replace')\n            line.add_raw_api_object(replace_raw_api_object)\n            replace_forward_ref = ForwardRef(line, obj_name)\n            placement_modes.append(replace_forward_ref)\n    else:\n        placement_modes.append(dataset.nyan_api_objects['engine.util.placement_mode.type.Eject'])\n        obj_name = f'{game_entity_name}.CreatableGameEntity.OwnStorage'\n        own_storage_raw_api_object = RawAPIObject(obj_name, 'OwnStorage', dataset.nyan_api_objects)\n        own_storage_raw_api_object.add_raw_parent('engine.util.placement_mode.type.OwnStorage')\n        own_storage_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        own_storage_raw_api_object.set_location(own_storage_location)\n        container_forward_ref = ForwardRef(train_location, f'{train_location_name}.Storage.{train_location_name}Container')\n        own_storage_raw_api_object.add_raw_member('container', container_forward_ref, 'engine.util.placement_mode.type.OwnStorage')\n        line.add_raw_api_object(own_storage_raw_api_object)\n        own_storage_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(own_storage_forward_ref)\n    creatable_raw_api_object.add_raw_member('placement_modes', placement_modes, 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(creatable_raw_api_object)\n    line.add_raw_api_object(cost_raw_api_object)",
            "@staticmethod\ndef get_creatable_game_entity(line: GenieGameEntityGroup) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Creates the CreatableGameEntity object for a unit/building line.\\n\\n        :param line: Unit/Building line.\\n        :type line: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    if isinstance(line, GenieVillagerGroup):\n        current_unit = line.variants[0].line[0]\n    else:\n        current_unit = line.line[0]\n    current_unit_id = line.get_head_unit_id()\n    dataset = line.data\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    game_entity_name = name_lookup_dict[current_unit_id][0]\n    obj_ref = f'{game_entity_name}.CreatableGameEntity'\n    obj_name = f'{game_entity_name}Creatable'\n    creatable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    creatable_raw_api_object.add_raw_parent('engine.util.create.CreatableGameEntity')\n    train_location_id = line.get_train_location_id()\n    if isinstance(line, GenieBuildingLineGroup):\n        train_location = dataset.unit_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    else:\n        train_location = dataset.building_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    if line.is_unique():\n        enabling_research_id = line.get_enabling_research_id()\n        enabling_research = dataset.genie_techs[enabling_research_id]\n        enabling_civ_id = enabling_research['civilization_id'].value\n        civ = dataset.civ_groups[enabling_civ_id]\n        civ_name = civ_lookup_dict[enabling_civ_id][0]\n        creatable_location = ForwardRef(civ, civ_name)\n    else:\n        creatable_location = ForwardRef(train_location, f'{train_location_name}.Create')\n    creatable_raw_api_object.set_location(creatable_location)\n    game_entity_forward_ref = ForwardRef(line, game_entity_name)\n    creatable_raw_api_object.add_raw_member('game_entity', game_entity_forward_ref, 'engine.util.create.CreatableGameEntity')\n    variants_set = []\n    creatable_raw_api_object.add_raw_member('variants', variants_set, 'engine.util.create.CreatableGameEntity')\n    cost_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_name, f'{game_entity_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    creatable_forward_ref = ForwardRef(line, obj_ref)\n    cost_raw_api_object.set_location(creatable_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    if line.is_repairable():\n        cost_repair_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}RepairCost'\n        cost_repair_raw_api_object = RawAPIObject(cost_repair_name, f'{game_entity_name}RepairCost', dataset.nyan_api_objects)\n        cost_repair_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n        creatable_forward_ref = ForwardRef(line, obj_ref)\n        cost_repair_raw_api_object.set_location(creatable_forward_ref)\n        payment_repair_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Adaptive']\n        cost_repair_raw_api_object.add_raw_member('payment_mode', payment_repair_mode, 'engine.util.cost.Cost')\n        line.add_raw_api_object(cost_repair_raw_api_object)\n    cost_amounts = []\n    cost_repair_amounts = []\n    for resource_amount in current_unit['resource_cost'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_name = f'{cost_name}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(line, cost_name)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n        cost_amounts.append(cost_amount_forward_ref)\n        line.add_raw_api_object(cost_amount)\n        if line.is_repairable():\n            cost_amount_name = f'{cost_repair_name}.{resource_name}Amount'\n            cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n            cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n            cost_forward_ref = ForwardRef(line, cost_repair_name)\n            cost_amount.set_location(cost_forward_ref)\n            cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n            cost_amount.add_raw_member('amount', amount / 2, 'engine.util.resource.ResourceAmount')\n            cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n            cost_repair_amounts.append(cost_amount_forward_ref)\n            line.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    if line.is_repairable():\n        cost_repair_raw_api_object.add_raw_member('amount', cost_repair_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(line, cost_name)\n    creatable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.create.CreatableGameEntity')\n    if isinstance(line, GenieUnitLineGroup):\n        creation_time = current_unit['creation_time'].value\n    else:\n        creation_time = 0\n    creatable_raw_api_object.add_raw_member('creation_time', creation_time, 'engine.util.create.CreatableGameEntity')\n    creation_sound_id = current_unit['train_sound_id'].value\n    obj_name = f'{game_entity_name}.CreatableGameEntity.Sound'\n    sound_raw_api_object = RawAPIObject(obj_name, 'CreationSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(line, obj_ref)\n    sound_raw_api_object.set_location(sound_location)\n    creation_sounds = []\n    if creation_sound_id > -1:\n        genie_sound = dataset.genie_sounds[creation_sound_id]\n        file_id = genie_sound.get_sounds(civ_id=-1)[0]\n        if file_id in dataset.combined_sounds:\n            creation_sound = dataset.combined_sounds[file_id]\n            creation_sound.add_reference(sound_raw_api_object)\n        else:\n            creation_sound = CombinedSound(creation_sound_id, file_id, f'creation_sound_{creation_sound_id}', dataset)\n            dataset.combined_sounds.update({file_id: creation_sound})\n            creation_sound.add_reference(sound_raw_api_object)\n        creation_sounds.append(creation_sound)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', creation_sounds, 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(line, obj_name)\n    creatable_raw_api_object.add_raw_member('creation_sounds', [sound_forward_ref], 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    enabling_research_id = line.get_enabling_research_id()\n    if enabling_research_id > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(line, obj_ref, enabling_research_id))\n    creatable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.create.CreatableGameEntity')\n    placement_modes = []\n    if isinstance(line, GenieBuildingLineGroup):\n        obj_name = f'{game_entity_name}.CreatableGameEntity.Place'\n        place_raw_api_object = RawAPIObject(obj_name, 'Place', dataset.nyan_api_objects)\n        place_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Place')\n        place_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        place_raw_api_object.set_location(place_location)\n        place_raw_api_object.add_raw_member('tile_snap_distance', 1.0, 'engine.util.placement_mode.type.Place')\n        clearance_size_x = current_unit['clearance_size_x'].value\n        clearance_size_y = current_unit['clearance_size_y'].value\n        place_raw_api_object.add_raw_member('clearance_size_x', clearance_size_x, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('clearance_size_y', clearance_size_y, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('allow_rotation', True, 'engine.util.placement_mode.type.Place')\n        elevation_mode = current_unit['elevation_mode'].value\n        if elevation_mode == 2:\n            max_elevation_difference = 0\n        elif elevation_mode == 3:\n            max_elevation_difference = 1\n        else:\n            max_elevation_difference = MemberSpecialValue.NYAN_INF\n        place_raw_api_object.add_raw_member('max_elevation_difference', max_elevation_difference, 'engine.util.placement_mode.type.Place')\n        line.add_raw_api_object(place_raw_api_object)\n        place_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(place_forward_ref)\n        if line.get_class_id() == 39:\n            obj_name = f'{game_entity_name}.CreatableGameEntity.Replace'\n            replace_raw_api_object = RawAPIObject(obj_name, 'Replace', dataset.nyan_api_objects)\n            replace_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Replace')\n            replace_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n            replace_raw_api_object.set_location(replace_location)\n            wall_line_id = 117\n            wall_line = dataset.building_lines[wall_line_id]\n            wall_name = name_lookup_dict[117][0]\n            game_entities = [ForwardRef(wall_line, wall_name)]\n            replace_raw_api_object.add_raw_member('game_entities', game_entities, 'engine.util.placement_mode.type.Replace')\n            line.add_raw_api_object(replace_raw_api_object)\n            replace_forward_ref = ForwardRef(line, obj_name)\n            placement_modes.append(replace_forward_ref)\n    else:\n        placement_modes.append(dataset.nyan_api_objects['engine.util.placement_mode.type.Eject'])\n        obj_name = f'{game_entity_name}.CreatableGameEntity.OwnStorage'\n        own_storage_raw_api_object = RawAPIObject(obj_name, 'OwnStorage', dataset.nyan_api_objects)\n        own_storage_raw_api_object.add_raw_parent('engine.util.placement_mode.type.OwnStorage')\n        own_storage_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        own_storage_raw_api_object.set_location(own_storage_location)\n        container_forward_ref = ForwardRef(train_location, f'{train_location_name}.Storage.{train_location_name}Container')\n        own_storage_raw_api_object.add_raw_member('container', container_forward_ref, 'engine.util.placement_mode.type.OwnStorage')\n        line.add_raw_api_object(own_storage_raw_api_object)\n        own_storage_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(own_storage_forward_ref)\n    creatable_raw_api_object.add_raw_member('placement_modes', placement_modes, 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(creatable_raw_api_object)\n    line.add_raw_api_object(cost_raw_api_object)",
            "@staticmethod\ndef get_creatable_game_entity(line: GenieGameEntityGroup) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Creates the CreatableGameEntity object for a unit/building line.\\n\\n        :param line: Unit/Building line.\\n        :type line: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    if isinstance(line, GenieVillagerGroup):\n        current_unit = line.variants[0].line[0]\n    else:\n        current_unit = line.line[0]\n    current_unit_id = line.get_head_unit_id()\n    dataset = line.data\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    game_entity_name = name_lookup_dict[current_unit_id][0]\n    obj_ref = f'{game_entity_name}.CreatableGameEntity'\n    obj_name = f'{game_entity_name}Creatable'\n    creatable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    creatable_raw_api_object.add_raw_parent('engine.util.create.CreatableGameEntity')\n    train_location_id = line.get_train_location_id()\n    if isinstance(line, GenieBuildingLineGroup):\n        train_location = dataset.unit_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    else:\n        train_location = dataset.building_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    if line.is_unique():\n        enabling_research_id = line.get_enabling_research_id()\n        enabling_research = dataset.genie_techs[enabling_research_id]\n        enabling_civ_id = enabling_research['civilization_id'].value\n        civ = dataset.civ_groups[enabling_civ_id]\n        civ_name = civ_lookup_dict[enabling_civ_id][0]\n        creatable_location = ForwardRef(civ, civ_name)\n    else:\n        creatable_location = ForwardRef(train_location, f'{train_location_name}.Create')\n    creatable_raw_api_object.set_location(creatable_location)\n    game_entity_forward_ref = ForwardRef(line, game_entity_name)\n    creatable_raw_api_object.add_raw_member('game_entity', game_entity_forward_ref, 'engine.util.create.CreatableGameEntity')\n    variants_set = []\n    creatable_raw_api_object.add_raw_member('variants', variants_set, 'engine.util.create.CreatableGameEntity')\n    cost_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_name, f'{game_entity_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    creatable_forward_ref = ForwardRef(line, obj_ref)\n    cost_raw_api_object.set_location(creatable_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    if line.is_repairable():\n        cost_repair_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}RepairCost'\n        cost_repair_raw_api_object = RawAPIObject(cost_repair_name, f'{game_entity_name}RepairCost', dataset.nyan_api_objects)\n        cost_repair_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n        creatable_forward_ref = ForwardRef(line, obj_ref)\n        cost_repair_raw_api_object.set_location(creatable_forward_ref)\n        payment_repair_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Adaptive']\n        cost_repair_raw_api_object.add_raw_member('payment_mode', payment_repair_mode, 'engine.util.cost.Cost')\n        line.add_raw_api_object(cost_repair_raw_api_object)\n    cost_amounts = []\n    cost_repair_amounts = []\n    for resource_amount in current_unit['resource_cost'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_name = f'{cost_name}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(line, cost_name)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n        cost_amounts.append(cost_amount_forward_ref)\n        line.add_raw_api_object(cost_amount)\n        if line.is_repairable():\n            cost_amount_name = f'{cost_repair_name}.{resource_name}Amount'\n            cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n            cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n            cost_forward_ref = ForwardRef(line, cost_repair_name)\n            cost_amount.set_location(cost_forward_ref)\n            cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n            cost_amount.add_raw_member('amount', amount / 2, 'engine.util.resource.ResourceAmount')\n            cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n            cost_repair_amounts.append(cost_amount_forward_ref)\n            line.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    if line.is_repairable():\n        cost_repair_raw_api_object.add_raw_member('amount', cost_repair_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(line, cost_name)\n    creatable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.create.CreatableGameEntity')\n    if isinstance(line, GenieUnitLineGroup):\n        creation_time = current_unit['creation_time'].value\n    else:\n        creation_time = 0\n    creatable_raw_api_object.add_raw_member('creation_time', creation_time, 'engine.util.create.CreatableGameEntity')\n    creation_sound_id = current_unit['train_sound_id'].value\n    obj_name = f'{game_entity_name}.CreatableGameEntity.Sound'\n    sound_raw_api_object = RawAPIObject(obj_name, 'CreationSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(line, obj_ref)\n    sound_raw_api_object.set_location(sound_location)\n    creation_sounds = []\n    if creation_sound_id > -1:\n        genie_sound = dataset.genie_sounds[creation_sound_id]\n        file_id = genie_sound.get_sounds(civ_id=-1)[0]\n        if file_id in dataset.combined_sounds:\n            creation_sound = dataset.combined_sounds[file_id]\n            creation_sound.add_reference(sound_raw_api_object)\n        else:\n            creation_sound = CombinedSound(creation_sound_id, file_id, f'creation_sound_{creation_sound_id}', dataset)\n            dataset.combined_sounds.update({file_id: creation_sound})\n            creation_sound.add_reference(sound_raw_api_object)\n        creation_sounds.append(creation_sound)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', creation_sounds, 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(line, obj_name)\n    creatable_raw_api_object.add_raw_member('creation_sounds', [sound_forward_ref], 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    enabling_research_id = line.get_enabling_research_id()\n    if enabling_research_id > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(line, obj_ref, enabling_research_id))\n    creatable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.create.CreatableGameEntity')\n    placement_modes = []\n    if isinstance(line, GenieBuildingLineGroup):\n        obj_name = f'{game_entity_name}.CreatableGameEntity.Place'\n        place_raw_api_object = RawAPIObject(obj_name, 'Place', dataset.nyan_api_objects)\n        place_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Place')\n        place_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        place_raw_api_object.set_location(place_location)\n        place_raw_api_object.add_raw_member('tile_snap_distance', 1.0, 'engine.util.placement_mode.type.Place')\n        clearance_size_x = current_unit['clearance_size_x'].value\n        clearance_size_y = current_unit['clearance_size_y'].value\n        place_raw_api_object.add_raw_member('clearance_size_x', clearance_size_x, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('clearance_size_y', clearance_size_y, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('allow_rotation', True, 'engine.util.placement_mode.type.Place')\n        elevation_mode = current_unit['elevation_mode'].value\n        if elevation_mode == 2:\n            max_elevation_difference = 0\n        elif elevation_mode == 3:\n            max_elevation_difference = 1\n        else:\n            max_elevation_difference = MemberSpecialValue.NYAN_INF\n        place_raw_api_object.add_raw_member('max_elevation_difference', max_elevation_difference, 'engine.util.placement_mode.type.Place')\n        line.add_raw_api_object(place_raw_api_object)\n        place_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(place_forward_ref)\n        if line.get_class_id() == 39:\n            obj_name = f'{game_entity_name}.CreatableGameEntity.Replace'\n            replace_raw_api_object = RawAPIObject(obj_name, 'Replace', dataset.nyan_api_objects)\n            replace_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Replace')\n            replace_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n            replace_raw_api_object.set_location(replace_location)\n            wall_line_id = 117\n            wall_line = dataset.building_lines[wall_line_id]\n            wall_name = name_lookup_dict[117][0]\n            game_entities = [ForwardRef(wall_line, wall_name)]\n            replace_raw_api_object.add_raw_member('game_entities', game_entities, 'engine.util.placement_mode.type.Replace')\n            line.add_raw_api_object(replace_raw_api_object)\n            replace_forward_ref = ForwardRef(line, obj_name)\n            placement_modes.append(replace_forward_ref)\n    else:\n        placement_modes.append(dataset.nyan_api_objects['engine.util.placement_mode.type.Eject'])\n        obj_name = f'{game_entity_name}.CreatableGameEntity.OwnStorage'\n        own_storage_raw_api_object = RawAPIObject(obj_name, 'OwnStorage', dataset.nyan_api_objects)\n        own_storage_raw_api_object.add_raw_parent('engine.util.placement_mode.type.OwnStorage')\n        own_storage_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        own_storage_raw_api_object.set_location(own_storage_location)\n        container_forward_ref = ForwardRef(train_location, f'{train_location_name}.Storage.{train_location_name}Container')\n        own_storage_raw_api_object.add_raw_member('container', container_forward_ref, 'engine.util.placement_mode.type.OwnStorage')\n        line.add_raw_api_object(own_storage_raw_api_object)\n        own_storage_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(own_storage_forward_ref)\n    creatable_raw_api_object.add_raw_member('placement_modes', placement_modes, 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(creatable_raw_api_object)\n    line.add_raw_api_object(cost_raw_api_object)",
            "@staticmethod\ndef get_creatable_game_entity(line: GenieGameEntityGroup) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Creates the CreatableGameEntity object for a unit/building line.\\n\\n        :param line: Unit/Building line.\\n        :type line: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    if isinstance(line, GenieVillagerGroup):\n        current_unit = line.variants[0].line[0]\n    else:\n        current_unit = line.line[0]\n    current_unit_id = line.get_head_unit_id()\n    dataset = line.data\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    game_entity_name = name_lookup_dict[current_unit_id][0]\n    obj_ref = f'{game_entity_name}.CreatableGameEntity'\n    obj_name = f'{game_entity_name}Creatable'\n    creatable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    creatable_raw_api_object.add_raw_parent('engine.util.create.CreatableGameEntity')\n    train_location_id = line.get_train_location_id()\n    if isinstance(line, GenieBuildingLineGroup):\n        train_location = dataset.unit_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    else:\n        train_location = dataset.building_lines[train_location_id]\n        train_location_name = name_lookup_dict[train_location_id][0]\n    if line.is_unique():\n        enabling_research_id = line.get_enabling_research_id()\n        enabling_research = dataset.genie_techs[enabling_research_id]\n        enabling_civ_id = enabling_research['civilization_id'].value\n        civ = dataset.civ_groups[enabling_civ_id]\n        civ_name = civ_lookup_dict[enabling_civ_id][0]\n        creatable_location = ForwardRef(civ, civ_name)\n    else:\n        creatable_location = ForwardRef(train_location, f'{train_location_name}.Create')\n    creatable_raw_api_object.set_location(creatable_location)\n    game_entity_forward_ref = ForwardRef(line, game_entity_name)\n    creatable_raw_api_object.add_raw_member('game_entity', game_entity_forward_ref, 'engine.util.create.CreatableGameEntity')\n    variants_set = []\n    creatable_raw_api_object.add_raw_member('variants', variants_set, 'engine.util.create.CreatableGameEntity')\n    cost_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_name, f'{game_entity_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    creatable_forward_ref = ForwardRef(line, obj_ref)\n    cost_raw_api_object.set_location(creatable_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    if line.is_repairable():\n        cost_repair_name = f'{game_entity_name}.CreatableGameEntity.{game_entity_name}RepairCost'\n        cost_repair_raw_api_object = RawAPIObject(cost_repair_name, f'{game_entity_name}RepairCost', dataset.nyan_api_objects)\n        cost_repair_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n        creatable_forward_ref = ForwardRef(line, obj_ref)\n        cost_repair_raw_api_object.set_location(creatable_forward_ref)\n        payment_repair_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Adaptive']\n        cost_repair_raw_api_object.add_raw_member('payment_mode', payment_repair_mode, 'engine.util.cost.Cost')\n        line.add_raw_api_object(cost_repair_raw_api_object)\n    cost_amounts = []\n    cost_repair_amounts = []\n    for resource_amount in current_unit['resource_cost'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_name = f'{cost_name}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(line, cost_name)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n        cost_amounts.append(cost_amount_forward_ref)\n        line.add_raw_api_object(cost_amount)\n        if line.is_repairable():\n            cost_amount_name = f'{cost_repair_name}.{resource_name}Amount'\n            cost_amount = RawAPIObject(cost_amount_name, f'{resource_name}Amount', dataset.nyan_api_objects)\n            cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n            cost_forward_ref = ForwardRef(line, cost_repair_name)\n            cost_amount.set_location(cost_forward_ref)\n            cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n            cost_amount.add_raw_member('amount', amount / 2, 'engine.util.resource.ResourceAmount')\n            cost_amount_forward_ref = ForwardRef(line, cost_amount_name)\n            cost_repair_amounts.append(cost_amount_forward_ref)\n            line.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    if line.is_repairable():\n        cost_repair_raw_api_object.add_raw_member('amount', cost_repair_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(line, cost_name)\n    creatable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.create.CreatableGameEntity')\n    if isinstance(line, GenieUnitLineGroup):\n        creation_time = current_unit['creation_time'].value\n    else:\n        creation_time = 0\n    creatable_raw_api_object.add_raw_member('creation_time', creation_time, 'engine.util.create.CreatableGameEntity')\n    creation_sound_id = current_unit['train_sound_id'].value\n    obj_name = f'{game_entity_name}.CreatableGameEntity.Sound'\n    sound_raw_api_object = RawAPIObject(obj_name, 'CreationSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(line, obj_ref)\n    sound_raw_api_object.set_location(sound_location)\n    creation_sounds = []\n    if creation_sound_id > -1:\n        genie_sound = dataset.genie_sounds[creation_sound_id]\n        file_id = genie_sound.get_sounds(civ_id=-1)[0]\n        if file_id in dataset.combined_sounds:\n            creation_sound = dataset.combined_sounds[file_id]\n            creation_sound.add_reference(sound_raw_api_object)\n        else:\n            creation_sound = CombinedSound(creation_sound_id, file_id, f'creation_sound_{creation_sound_id}', dataset)\n            dataset.combined_sounds.update({file_id: creation_sound})\n            creation_sound.add_reference(sound_raw_api_object)\n        creation_sounds.append(creation_sound)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', creation_sounds, 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(line, obj_name)\n    creatable_raw_api_object.add_raw_member('creation_sounds', [sound_forward_ref], 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    enabling_research_id = line.get_enabling_research_id()\n    if enabling_research_id > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(line, obj_ref, enabling_research_id))\n    creatable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.create.CreatableGameEntity')\n    placement_modes = []\n    if isinstance(line, GenieBuildingLineGroup):\n        obj_name = f'{game_entity_name}.CreatableGameEntity.Place'\n        place_raw_api_object = RawAPIObject(obj_name, 'Place', dataset.nyan_api_objects)\n        place_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Place')\n        place_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        place_raw_api_object.set_location(place_location)\n        place_raw_api_object.add_raw_member('tile_snap_distance', 1.0, 'engine.util.placement_mode.type.Place')\n        clearance_size_x = current_unit['clearance_size_x'].value\n        clearance_size_y = current_unit['clearance_size_y'].value\n        place_raw_api_object.add_raw_member('clearance_size_x', clearance_size_x, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('clearance_size_y', clearance_size_y, 'engine.util.placement_mode.type.Place')\n        place_raw_api_object.add_raw_member('allow_rotation', True, 'engine.util.placement_mode.type.Place')\n        elevation_mode = current_unit['elevation_mode'].value\n        if elevation_mode == 2:\n            max_elevation_difference = 0\n        elif elevation_mode == 3:\n            max_elevation_difference = 1\n        else:\n            max_elevation_difference = MemberSpecialValue.NYAN_INF\n        place_raw_api_object.add_raw_member('max_elevation_difference', max_elevation_difference, 'engine.util.placement_mode.type.Place')\n        line.add_raw_api_object(place_raw_api_object)\n        place_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(place_forward_ref)\n        if line.get_class_id() == 39:\n            obj_name = f'{game_entity_name}.CreatableGameEntity.Replace'\n            replace_raw_api_object = RawAPIObject(obj_name, 'Replace', dataset.nyan_api_objects)\n            replace_raw_api_object.add_raw_parent('engine.util.placement_mode.type.Replace')\n            replace_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n            replace_raw_api_object.set_location(replace_location)\n            wall_line_id = 117\n            wall_line = dataset.building_lines[wall_line_id]\n            wall_name = name_lookup_dict[117][0]\n            game_entities = [ForwardRef(wall_line, wall_name)]\n            replace_raw_api_object.add_raw_member('game_entities', game_entities, 'engine.util.placement_mode.type.Replace')\n            line.add_raw_api_object(replace_raw_api_object)\n            replace_forward_ref = ForwardRef(line, obj_name)\n            placement_modes.append(replace_forward_ref)\n    else:\n        placement_modes.append(dataset.nyan_api_objects['engine.util.placement_mode.type.Eject'])\n        obj_name = f'{game_entity_name}.CreatableGameEntity.OwnStorage'\n        own_storage_raw_api_object = RawAPIObject(obj_name, 'OwnStorage', dataset.nyan_api_objects)\n        own_storage_raw_api_object.add_raw_parent('engine.util.placement_mode.type.OwnStorage')\n        own_storage_location = ForwardRef(line, f'{game_entity_name}.CreatableGameEntity')\n        own_storage_raw_api_object.set_location(own_storage_location)\n        container_forward_ref = ForwardRef(train_location, f'{train_location_name}.Storage.{train_location_name}Container')\n        own_storage_raw_api_object.add_raw_member('container', container_forward_ref, 'engine.util.placement_mode.type.OwnStorage')\n        line.add_raw_api_object(own_storage_raw_api_object)\n        own_storage_forward_ref = ForwardRef(line, obj_name)\n        placement_modes.append(own_storage_forward_ref)\n    creatable_raw_api_object.add_raw_member('placement_modes', placement_modes, 'engine.util.create.CreatableGameEntity')\n    line.add_raw_api_object(creatable_raw_api_object)\n    line.add_raw_api_object(cost_raw_api_object)"
        ]
    },
    {
        "func_name": "get_researchable_tech",
        "original": "@staticmethod\ndef get_researchable_tech(tech_group: GenieTechEffectBundleGroup) -> None:\n    \"\"\"\n        Creates the ResearchableTech object for a Tech.\n\n        :param tech_group: Tech group that is a technology.\n        :type tech_group: ...dataformat.converter_object.ConverterObjectGroup\n        \"\"\"\n    dataset = tech_group.data\n    research_location_id = tech_group.get_research_location_id()\n    research_location = dataset.building_lines[research_location_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    research_location_name = name_lookup_dict[research_location_id][0]\n    tech_name = tech_lookup_dict[tech_group.get_id()][0]\n    obj_ref = f'{tech_name}.ResearchableTech'\n    obj_name = f'{tech_name}Researchable'\n    researchable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    researchable_raw_api_object.add_raw_parent('engine.util.research.ResearchableTech')\n    if tech_group.is_unique():\n        civ_id = tech_group.get_civilization()\n        civ = dataset.civ_groups[civ_id]\n        civ_name = civ_lookup_dict[civ_id][0]\n        researchable_location = ForwardRef(civ, civ_name)\n    else:\n        researchable_location = ForwardRef(research_location, f'{research_location_name}.Research')\n    researchable_raw_api_object.set_location(researchable_location)\n    tech_forward_ref = ForwardRef(tech_group, tech_name)\n    researchable_raw_api_object.add_raw_member('tech', tech_forward_ref, 'engine.util.research.ResearchableTech')\n    cost_ref = f'{tech_name}.ResearchableTech.{tech_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_ref, f'{tech_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    tech_forward_ref = ForwardRef(tech_group, obj_ref)\n    cost_raw_api_object.set_location(tech_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    cost_amounts = []\n    for resource_amount in tech_group.tech['research_resource_costs'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_ref = f'{cost_ref}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_ref, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(tech_group, cost_ref)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(tech_group, cost_amount_ref)\n        cost_amounts.append(cost_amount_forward_ref)\n        tech_group.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(tech_group, cost_ref)\n    researchable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.research.ResearchableTech')\n    research_time = tech_group.tech['research_time'].value\n    researchable_raw_api_object.add_raw_member('research_time', research_time, 'engine.util.research.ResearchableTech')\n    sound_ref = f'{tech_name}.ResearchableTech.Sound'\n    sound_raw_api_object = RawAPIObject(sound_ref, 'ResearchSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(tech_group, f'{tech_name}.ResearchableTech')\n    sound_raw_api_object.set_location(sound_location)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', [], 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(tech_group, sound_ref)\n    researchable_raw_api_object.add_raw_member('research_sounds', [sound_forward_ref], 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    if tech_group.get_id() > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(tech_group, obj_ref, tech_group.get_id(), top_level=True))\n    researchable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(researchable_raw_api_object)\n    tech_group.add_raw_api_object(cost_raw_api_object)",
        "mutated": [
            "@staticmethod\ndef get_researchable_tech(tech_group: GenieTechEffectBundleGroup) -> None:\n    if False:\n        i = 10\n    '\\n        Creates the ResearchableTech object for a Tech.\\n\\n        :param tech_group: Tech group that is a technology.\\n        :type tech_group: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    dataset = tech_group.data\n    research_location_id = tech_group.get_research_location_id()\n    research_location = dataset.building_lines[research_location_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    research_location_name = name_lookup_dict[research_location_id][0]\n    tech_name = tech_lookup_dict[tech_group.get_id()][0]\n    obj_ref = f'{tech_name}.ResearchableTech'\n    obj_name = f'{tech_name}Researchable'\n    researchable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    researchable_raw_api_object.add_raw_parent('engine.util.research.ResearchableTech')\n    if tech_group.is_unique():\n        civ_id = tech_group.get_civilization()\n        civ = dataset.civ_groups[civ_id]\n        civ_name = civ_lookup_dict[civ_id][0]\n        researchable_location = ForwardRef(civ, civ_name)\n    else:\n        researchable_location = ForwardRef(research_location, f'{research_location_name}.Research')\n    researchable_raw_api_object.set_location(researchable_location)\n    tech_forward_ref = ForwardRef(tech_group, tech_name)\n    researchable_raw_api_object.add_raw_member('tech', tech_forward_ref, 'engine.util.research.ResearchableTech')\n    cost_ref = f'{tech_name}.ResearchableTech.{tech_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_ref, f'{tech_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    tech_forward_ref = ForwardRef(tech_group, obj_ref)\n    cost_raw_api_object.set_location(tech_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    cost_amounts = []\n    for resource_amount in tech_group.tech['research_resource_costs'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_ref = f'{cost_ref}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_ref, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(tech_group, cost_ref)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(tech_group, cost_amount_ref)\n        cost_amounts.append(cost_amount_forward_ref)\n        tech_group.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(tech_group, cost_ref)\n    researchable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.research.ResearchableTech')\n    research_time = tech_group.tech['research_time'].value\n    researchable_raw_api_object.add_raw_member('research_time', research_time, 'engine.util.research.ResearchableTech')\n    sound_ref = f'{tech_name}.ResearchableTech.Sound'\n    sound_raw_api_object = RawAPIObject(sound_ref, 'ResearchSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(tech_group, f'{tech_name}.ResearchableTech')\n    sound_raw_api_object.set_location(sound_location)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', [], 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(tech_group, sound_ref)\n    researchable_raw_api_object.add_raw_member('research_sounds', [sound_forward_ref], 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    if tech_group.get_id() > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(tech_group, obj_ref, tech_group.get_id(), top_level=True))\n    researchable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(researchable_raw_api_object)\n    tech_group.add_raw_api_object(cost_raw_api_object)",
            "@staticmethod\ndef get_researchable_tech(tech_group: GenieTechEffectBundleGroup) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Creates the ResearchableTech object for a Tech.\\n\\n        :param tech_group: Tech group that is a technology.\\n        :type tech_group: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    dataset = tech_group.data\n    research_location_id = tech_group.get_research_location_id()\n    research_location = dataset.building_lines[research_location_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    research_location_name = name_lookup_dict[research_location_id][0]\n    tech_name = tech_lookup_dict[tech_group.get_id()][0]\n    obj_ref = f'{tech_name}.ResearchableTech'\n    obj_name = f'{tech_name}Researchable'\n    researchable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    researchable_raw_api_object.add_raw_parent('engine.util.research.ResearchableTech')\n    if tech_group.is_unique():\n        civ_id = tech_group.get_civilization()\n        civ = dataset.civ_groups[civ_id]\n        civ_name = civ_lookup_dict[civ_id][0]\n        researchable_location = ForwardRef(civ, civ_name)\n    else:\n        researchable_location = ForwardRef(research_location, f'{research_location_name}.Research')\n    researchable_raw_api_object.set_location(researchable_location)\n    tech_forward_ref = ForwardRef(tech_group, tech_name)\n    researchable_raw_api_object.add_raw_member('tech', tech_forward_ref, 'engine.util.research.ResearchableTech')\n    cost_ref = f'{tech_name}.ResearchableTech.{tech_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_ref, f'{tech_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    tech_forward_ref = ForwardRef(tech_group, obj_ref)\n    cost_raw_api_object.set_location(tech_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    cost_amounts = []\n    for resource_amount in tech_group.tech['research_resource_costs'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_ref = f'{cost_ref}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_ref, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(tech_group, cost_ref)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(tech_group, cost_amount_ref)\n        cost_amounts.append(cost_amount_forward_ref)\n        tech_group.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(tech_group, cost_ref)\n    researchable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.research.ResearchableTech')\n    research_time = tech_group.tech['research_time'].value\n    researchable_raw_api_object.add_raw_member('research_time', research_time, 'engine.util.research.ResearchableTech')\n    sound_ref = f'{tech_name}.ResearchableTech.Sound'\n    sound_raw_api_object = RawAPIObject(sound_ref, 'ResearchSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(tech_group, f'{tech_name}.ResearchableTech')\n    sound_raw_api_object.set_location(sound_location)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', [], 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(tech_group, sound_ref)\n    researchable_raw_api_object.add_raw_member('research_sounds', [sound_forward_ref], 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    if tech_group.get_id() > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(tech_group, obj_ref, tech_group.get_id(), top_level=True))\n    researchable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(researchable_raw_api_object)\n    tech_group.add_raw_api_object(cost_raw_api_object)",
            "@staticmethod\ndef get_researchable_tech(tech_group: GenieTechEffectBundleGroup) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Creates the ResearchableTech object for a Tech.\\n\\n        :param tech_group: Tech group that is a technology.\\n        :type tech_group: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    dataset = tech_group.data\n    research_location_id = tech_group.get_research_location_id()\n    research_location = dataset.building_lines[research_location_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    research_location_name = name_lookup_dict[research_location_id][0]\n    tech_name = tech_lookup_dict[tech_group.get_id()][0]\n    obj_ref = f'{tech_name}.ResearchableTech'\n    obj_name = f'{tech_name}Researchable'\n    researchable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    researchable_raw_api_object.add_raw_parent('engine.util.research.ResearchableTech')\n    if tech_group.is_unique():\n        civ_id = tech_group.get_civilization()\n        civ = dataset.civ_groups[civ_id]\n        civ_name = civ_lookup_dict[civ_id][0]\n        researchable_location = ForwardRef(civ, civ_name)\n    else:\n        researchable_location = ForwardRef(research_location, f'{research_location_name}.Research')\n    researchable_raw_api_object.set_location(researchable_location)\n    tech_forward_ref = ForwardRef(tech_group, tech_name)\n    researchable_raw_api_object.add_raw_member('tech', tech_forward_ref, 'engine.util.research.ResearchableTech')\n    cost_ref = f'{tech_name}.ResearchableTech.{tech_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_ref, f'{tech_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    tech_forward_ref = ForwardRef(tech_group, obj_ref)\n    cost_raw_api_object.set_location(tech_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    cost_amounts = []\n    for resource_amount in tech_group.tech['research_resource_costs'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_ref = f'{cost_ref}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_ref, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(tech_group, cost_ref)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(tech_group, cost_amount_ref)\n        cost_amounts.append(cost_amount_forward_ref)\n        tech_group.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(tech_group, cost_ref)\n    researchable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.research.ResearchableTech')\n    research_time = tech_group.tech['research_time'].value\n    researchable_raw_api_object.add_raw_member('research_time', research_time, 'engine.util.research.ResearchableTech')\n    sound_ref = f'{tech_name}.ResearchableTech.Sound'\n    sound_raw_api_object = RawAPIObject(sound_ref, 'ResearchSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(tech_group, f'{tech_name}.ResearchableTech')\n    sound_raw_api_object.set_location(sound_location)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', [], 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(tech_group, sound_ref)\n    researchable_raw_api_object.add_raw_member('research_sounds', [sound_forward_ref], 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    if tech_group.get_id() > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(tech_group, obj_ref, tech_group.get_id(), top_level=True))\n    researchable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(researchable_raw_api_object)\n    tech_group.add_raw_api_object(cost_raw_api_object)",
            "@staticmethod\ndef get_researchable_tech(tech_group: GenieTechEffectBundleGroup) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Creates the ResearchableTech object for a Tech.\\n\\n        :param tech_group: Tech group that is a technology.\\n        :type tech_group: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    dataset = tech_group.data\n    research_location_id = tech_group.get_research_location_id()\n    research_location = dataset.building_lines[research_location_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    research_location_name = name_lookup_dict[research_location_id][0]\n    tech_name = tech_lookup_dict[tech_group.get_id()][0]\n    obj_ref = f'{tech_name}.ResearchableTech'\n    obj_name = f'{tech_name}Researchable'\n    researchable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    researchable_raw_api_object.add_raw_parent('engine.util.research.ResearchableTech')\n    if tech_group.is_unique():\n        civ_id = tech_group.get_civilization()\n        civ = dataset.civ_groups[civ_id]\n        civ_name = civ_lookup_dict[civ_id][0]\n        researchable_location = ForwardRef(civ, civ_name)\n    else:\n        researchable_location = ForwardRef(research_location, f'{research_location_name}.Research')\n    researchable_raw_api_object.set_location(researchable_location)\n    tech_forward_ref = ForwardRef(tech_group, tech_name)\n    researchable_raw_api_object.add_raw_member('tech', tech_forward_ref, 'engine.util.research.ResearchableTech')\n    cost_ref = f'{tech_name}.ResearchableTech.{tech_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_ref, f'{tech_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    tech_forward_ref = ForwardRef(tech_group, obj_ref)\n    cost_raw_api_object.set_location(tech_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    cost_amounts = []\n    for resource_amount in tech_group.tech['research_resource_costs'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_ref = f'{cost_ref}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_ref, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(tech_group, cost_ref)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(tech_group, cost_amount_ref)\n        cost_amounts.append(cost_amount_forward_ref)\n        tech_group.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(tech_group, cost_ref)\n    researchable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.research.ResearchableTech')\n    research_time = tech_group.tech['research_time'].value\n    researchable_raw_api_object.add_raw_member('research_time', research_time, 'engine.util.research.ResearchableTech')\n    sound_ref = f'{tech_name}.ResearchableTech.Sound'\n    sound_raw_api_object = RawAPIObject(sound_ref, 'ResearchSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(tech_group, f'{tech_name}.ResearchableTech')\n    sound_raw_api_object.set_location(sound_location)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', [], 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(tech_group, sound_ref)\n    researchable_raw_api_object.add_raw_member('research_sounds', [sound_forward_ref], 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    if tech_group.get_id() > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(tech_group, obj_ref, tech_group.get_id(), top_level=True))\n    researchable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(researchable_raw_api_object)\n    tech_group.add_raw_api_object(cost_raw_api_object)",
            "@staticmethod\ndef get_researchable_tech(tech_group: GenieTechEffectBundleGroup) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Creates the ResearchableTech object for a Tech.\\n\\n        :param tech_group: Tech group that is a technology.\\n        :type tech_group: ...dataformat.converter_object.ConverterObjectGroup\\n        '\n    dataset = tech_group.data\n    research_location_id = tech_group.get_research_location_id()\n    research_location = dataset.building_lines[research_location_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    civ_lookup_dict = internal_name_lookups.get_civ_lookups(dataset.game_version)\n    research_location_name = name_lookup_dict[research_location_id][0]\n    tech_name = tech_lookup_dict[tech_group.get_id()][0]\n    obj_ref = f'{tech_name}.ResearchableTech'\n    obj_name = f'{tech_name}Researchable'\n    researchable_raw_api_object = RawAPIObject(obj_ref, obj_name, dataset.nyan_api_objects)\n    researchable_raw_api_object.add_raw_parent('engine.util.research.ResearchableTech')\n    if tech_group.is_unique():\n        civ_id = tech_group.get_civilization()\n        civ = dataset.civ_groups[civ_id]\n        civ_name = civ_lookup_dict[civ_id][0]\n        researchable_location = ForwardRef(civ, civ_name)\n    else:\n        researchable_location = ForwardRef(research_location, f'{research_location_name}.Research')\n    researchable_raw_api_object.set_location(researchable_location)\n    tech_forward_ref = ForwardRef(tech_group, tech_name)\n    researchable_raw_api_object.add_raw_member('tech', tech_forward_ref, 'engine.util.research.ResearchableTech')\n    cost_ref = f'{tech_name}.ResearchableTech.{tech_name}Cost'\n    cost_raw_api_object = RawAPIObject(cost_ref, f'{tech_name}Cost', dataset.nyan_api_objects)\n    cost_raw_api_object.add_raw_parent('engine.util.cost.type.ResourceCost')\n    tech_forward_ref = ForwardRef(tech_group, obj_ref)\n    cost_raw_api_object.set_location(tech_forward_ref)\n    payment_mode = dataset.nyan_api_objects['engine.util.payment_mode.type.Advance']\n    cost_raw_api_object.add_raw_member('payment_mode', payment_mode, 'engine.util.cost.Cost')\n    cost_amounts = []\n    for resource_amount in tech_group.tech['research_resource_costs'].value:\n        resource_id = resource_amount['type_id'].value\n        resource = None\n        resource_name = ''\n        if resource_id == -1:\n            continue\n        if resource_id == 0:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Food'].get_nyan_object()\n            resource_name = 'Food'\n        elif resource_id == 1:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Wood'].get_nyan_object()\n            resource_name = 'Wood'\n        elif resource_id == 2:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Stone'].get_nyan_object()\n            resource_name = 'Stone'\n        elif resource_id == 3:\n            resource = dataset.pregen_nyan_objects['util.resource.types.Gold'].get_nyan_object()\n            resource_name = 'Gold'\n        else:\n            continue\n        if not resource_amount['enabled'].value:\n            continue\n        amount = resource_amount['amount'].value\n        cost_amount_ref = f'{cost_ref}.{resource_name}Amount'\n        cost_amount = RawAPIObject(cost_amount_ref, f'{resource_name}Amount', dataset.nyan_api_objects)\n        cost_amount.add_raw_parent('engine.util.resource.ResourceAmount')\n        cost_forward_ref = ForwardRef(tech_group, cost_ref)\n        cost_amount.set_location(cost_forward_ref)\n        cost_amount.add_raw_member('type', resource, 'engine.util.resource.ResourceAmount')\n        cost_amount.add_raw_member('amount', amount, 'engine.util.resource.ResourceAmount')\n        cost_amount_forward_ref = ForwardRef(tech_group, cost_amount_ref)\n        cost_amounts.append(cost_amount_forward_ref)\n        tech_group.add_raw_api_object(cost_amount)\n    cost_raw_api_object.add_raw_member('amount', cost_amounts, 'engine.util.cost.type.ResourceCost')\n    cost_forward_ref = ForwardRef(tech_group, cost_ref)\n    researchable_raw_api_object.add_raw_member('cost', cost_forward_ref, 'engine.util.research.ResearchableTech')\n    research_time = tech_group.tech['research_time'].value\n    researchable_raw_api_object.add_raw_member('research_time', research_time, 'engine.util.research.ResearchableTech')\n    sound_ref = f'{tech_name}.ResearchableTech.Sound'\n    sound_raw_api_object = RawAPIObject(sound_ref, 'ResearchSound', dataset.nyan_api_objects)\n    sound_raw_api_object.add_raw_parent('engine.util.sound.Sound')\n    sound_location = ForwardRef(tech_group, f'{tech_name}.ResearchableTech')\n    sound_raw_api_object.set_location(sound_location)\n    sound_raw_api_object.add_raw_member('play_delay', 0, 'engine.util.sound.Sound')\n    sound_raw_api_object.add_raw_member('sounds', [], 'engine.util.sound.Sound')\n    sound_forward_ref = ForwardRef(tech_group, sound_ref)\n    researchable_raw_api_object.add_raw_member('research_sounds', [sound_forward_ref], 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(sound_raw_api_object)\n    unlock_conditions = []\n    if tech_group.get_id() > -1:\n        unlock_conditions.extend(AoCAuxiliarySubprocessor.get_condition(tech_group, obj_ref, tech_group.get_id(), top_level=True))\n    researchable_raw_api_object.add_raw_member('condition', unlock_conditions, 'engine.util.research.ResearchableTech')\n    tech_group.add_raw_api_object(researchable_raw_api_object)\n    tech_group.add_raw_api_object(cost_raw_api_object)"
        ]
    },
    {
        "func_name": "get_condition",
        "original": "@staticmethod\ndef get_condition(converter_obj_group: ConverterObjectGroup, obj_ref: str, tech_id: int, top_level: bool=False) -> list[ForwardRef]:\n    \"\"\"\n        Creates the condition for a creatable or researchable from tech\n        by recursively searching the required techs.\n\n        :param converter_object: ConverterObjectGroup that the condition objects should be nested in.\n        :param obj_ref: Reference of converter_object inside the modpack.\n        :param tech_id: tech ID of a tech wth a conditional unlock.\n        :param top_level: True if the condition has subconditions, False otherwise.\n        \"\"\"\n    dataset = converter_obj_group.data\n    tech = dataset.genie_techs[tech_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    if not top_level and (tech_id in dataset.initiated_techs.keys() or (tech_id in dataset.tech_groups.keys() and dataset.tech_groups[tech_id].is_researchable())):\n        if tech_id in dataset.initiated_techs.keys():\n            initiated_tech = dataset.initiated_techs[tech_id]\n            building_id = initiated_tech.get_building_id()\n            building_name = name_lookup_dict[building_id][0]\n            literal_name = f'{building_name}Built'\n            literal_parent = 'engine.util.logic.literal.type.GameEntityProgress'\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_name = tech_lookup_dict[tech_id][0]\n            literal_name = f'{tech_name}Researched'\n            literal_parent = 'engine.util.logic.literal.type.TechResearched'\n        else:\n            raise ValueError('Required tech id {tech_id} is neither intiated nor researchable')\n        literal_ref = f'{obj_ref}.{literal_name}'\n        literal_raw_api_object = RawAPIObject(literal_ref, literal_name, dataset.nyan_api_objects)\n        literal_raw_api_object.add_raw_parent(literal_parent)\n        literal_location = ForwardRef(converter_obj_group, obj_ref)\n        literal_raw_api_object.set_location(literal_location)\n        if tech_id in dataset.initiated_techs.keys():\n            building_line = dataset.unit_ref[building_id]\n            building_forward_ref = ForwardRef(building_line, building_name)\n            literal_raw_api_object.add_raw_member('game_entity', building_forward_ref, literal_parent)\n            progress_ref = f'{literal_ref}.ProgressStatus'\n            progress_raw_api_object = RawAPIObject(progress_ref, 'ProgressStatus', dataset.nyan_api_objects)\n            progress_raw_api_object.add_raw_parent('engine.util.progress_status.ProgressStatus')\n            progress_location = ForwardRef(converter_obj_group, literal_ref)\n            progress_raw_api_object.set_location(progress_location)\n            progress_type = dataset.nyan_api_objects['engine.util.progress_type.type.Construct']\n            progress_raw_api_object.add_raw_member('progress_type', progress_type, 'engine.util.progress_status.ProgressStatus')\n            progress_raw_api_object.add_raw_member('progress', 100, 'engine.util.progress_status.ProgressStatus')\n            converter_obj_group.add_raw_api_object(progress_raw_api_object)\n            progress_forward_ref = ForwardRef(converter_obj_group, progress_ref)\n            literal_raw_api_object.add_raw_member('progress_status', progress_forward_ref, literal_parent)\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_group = dataset.tech_groups[tech_id]\n            tech_forward_ref = ForwardRef(tech_group, tech_name)\n            literal_raw_api_object.add_raw_member('tech', tech_forward_ref, literal_parent)\n        scope_ref = f'{literal_ref}.LiteralScope'\n        scope_raw_api_object = RawAPIObject(scope_ref, 'LiteralScope', dataset.nyan_api_objects)\n        scope_raw_api_object.add_raw_parent('engine.util.logic.literal_scope.type.Any')\n        scope_location = ForwardRef(converter_obj_group, literal_ref)\n        scope_raw_api_object.set_location(scope_location)\n        scope_diplomatic_stances = [dataset.nyan_api_objects['engine.util.diplomatic_stance.type.Self']]\n        scope_raw_api_object.add_raw_member('stances', scope_diplomatic_stances, 'engine.util.logic.literal_scope.LiteralScope')\n        converter_obj_group.add_raw_api_object(scope_raw_api_object)\n        scope_forward_ref = ForwardRef(converter_obj_group, scope_ref)\n        literal_raw_api_object.add_raw_member('scope', scope_forward_ref, 'engine.util.logic.literal.Literal')\n        literal_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        converter_obj_group.add_raw_api_object(literal_raw_api_object)\n        literal_forward_ref = ForwardRef(converter_obj_group, literal_ref)\n        return [literal_forward_ref]\n    else:\n        assoc_tech_id_members = []\n        assoc_tech_id_members.extend(tech['required_techs'].value)\n        required_tech_count = tech['required_tech_count'].value\n        relevant_ids = []\n        for tech_id_member in assoc_tech_id_members:\n            required_tech_id = tech_id_member.value\n            if required_tech_id == -1:\n                continue\n            if required_tech_id == 104:\n                required_tech_count -= 1\n                continue\n            if required_tech_id in dataset.civ_boni.keys():\n                continue\n            relevant_ids.append(required_tech_id)\n        if len(relevant_ids) == 0:\n            return []\n        if len(relevant_ids) == 1:\n            required_tech_id = relevant_ids[0]\n            return AoCAuxiliarySubprocessor.get_condition(converter_obj_group, obj_ref, required_tech_id)\n        gate_ref = f'{obj_ref}.UnlockCondition'\n        gate_raw_api_object = RawAPIObject(gate_ref, 'UnlockCondition', dataset.nyan_api_objects)\n        if required_tech_count == len(relevant_ids):\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.AND')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n        else:\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.SUBSETMIN')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n            gate_raw_api_object.add_raw_member('size', required_tech_count, 'engine.util.logic.gate.type.SUBSETMIN')\n        gate_raw_api_object.set_location(gate_location)\n        gate_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        inputs = []\n        for required_tech_id in relevant_ids:\n            required = AoCAuxiliarySubprocessor.get_condition(converter_obj_group, gate_ref, required_tech_id)\n            inputs.extend(required)\n        gate_raw_api_object.add_raw_member('inputs', inputs, 'engine.util.logic.gate.LogicGate')\n        converter_obj_group.add_raw_api_object(gate_raw_api_object)\n        gate_forward_ref = ForwardRef(converter_obj_group, gate_ref)\n        return [gate_forward_ref]",
        "mutated": [
            "@staticmethod\ndef get_condition(converter_obj_group: ConverterObjectGroup, obj_ref: str, tech_id: int, top_level: bool=False) -> list[ForwardRef]:\n    if False:\n        i = 10\n    '\\n        Creates the condition for a creatable or researchable from tech\\n        by recursively searching the required techs.\\n\\n        :param converter_object: ConverterObjectGroup that the condition objects should be nested in.\\n        :param obj_ref: Reference of converter_object inside the modpack.\\n        :param tech_id: tech ID of a tech wth a conditional unlock.\\n        :param top_level: True if the condition has subconditions, False otherwise.\\n        '\n    dataset = converter_obj_group.data\n    tech = dataset.genie_techs[tech_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    if not top_level and (tech_id in dataset.initiated_techs.keys() or (tech_id in dataset.tech_groups.keys() and dataset.tech_groups[tech_id].is_researchable())):\n        if tech_id in dataset.initiated_techs.keys():\n            initiated_tech = dataset.initiated_techs[tech_id]\n            building_id = initiated_tech.get_building_id()\n            building_name = name_lookup_dict[building_id][0]\n            literal_name = f'{building_name}Built'\n            literal_parent = 'engine.util.logic.literal.type.GameEntityProgress'\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_name = tech_lookup_dict[tech_id][0]\n            literal_name = f'{tech_name}Researched'\n            literal_parent = 'engine.util.logic.literal.type.TechResearched'\n        else:\n            raise ValueError('Required tech id {tech_id} is neither intiated nor researchable')\n        literal_ref = f'{obj_ref}.{literal_name}'\n        literal_raw_api_object = RawAPIObject(literal_ref, literal_name, dataset.nyan_api_objects)\n        literal_raw_api_object.add_raw_parent(literal_parent)\n        literal_location = ForwardRef(converter_obj_group, obj_ref)\n        literal_raw_api_object.set_location(literal_location)\n        if tech_id in dataset.initiated_techs.keys():\n            building_line = dataset.unit_ref[building_id]\n            building_forward_ref = ForwardRef(building_line, building_name)\n            literal_raw_api_object.add_raw_member('game_entity', building_forward_ref, literal_parent)\n            progress_ref = f'{literal_ref}.ProgressStatus'\n            progress_raw_api_object = RawAPIObject(progress_ref, 'ProgressStatus', dataset.nyan_api_objects)\n            progress_raw_api_object.add_raw_parent('engine.util.progress_status.ProgressStatus')\n            progress_location = ForwardRef(converter_obj_group, literal_ref)\n            progress_raw_api_object.set_location(progress_location)\n            progress_type = dataset.nyan_api_objects['engine.util.progress_type.type.Construct']\n            progress_raw_api_object.add_raw_member('progress_type', progress_type, 'engine.util.progress_status.ProgressStatus')\n            progress_raw_api_object.add_raw_member('progress', 100, 'engine.util.progress_status.ProgressStatus')\n            converter_obj_group.add_raw_api_object(progress_raw_api_object)\n            progress_forward_ref = ForwardRef(converter_obj_group, progress_ref)\n            literal_raw_api_object.add_raw_member('progress_status', progress_forward_ref, literal_parent)\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_group = dataset.tech_groups[tech_id]\n            tech_forward_ref = ForwardRef(tech_group, tech_name)\n            literal_raw_api_object.add_raw_member('tech', tech_forward_ref, literal_parent)\n        scope_ref = f'{literal_ref}.LiteralScope'\n        scope_raw_api_object = RawAPIObject(scope_ref, 'LiteralScope', dataset.nyan_api_objects)\n        scope_raw_api_object.add_raw_parent('engine.util.logic.literal_scope.type.Any')\n        scope_location = ForwardRef(converter_obj_group, literal_ref)\n        scope_raw_api_object.set_location(scope_location)\n        scope_diplomatic_stances = [dataset.nyan_api_objects['engine.util.diplomatic_stance.type.Self']]\n        scope_raw_api_object.add_raw_member('stances', scope_diplomatic_stances, 'engine.util.logic.literal_scope.LiteralScope')\n        converter_obj_group.add_raw_api_object(scope_raw_api_object)\n        scope_forward_ref = ForwardRef(converter_obj_group, scope_ref)\n        literal_raw_api_object.add_raw_member('scope', scope_forward_ref, 'engine.util.logic.literal.Literal')\n        literal_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        converter_obj_group.add_raw_api_object(literal_raw_api_object)\n        literal_forward_ref = ForwardRef(converter_obj_group, literal_ref)\n        return [literal_forward_ref]\n    else:\n        assoc_tech_id_members = []\n        assoc_tech_id_members.extend(tech['required_techs'].value)\n        required_tech_count = tech['required_tech_count'].value\n        relevant_ids = []\n        for tech_id_member in assoc_tech_id_members:\n            required_tech_id = tech_id_member.value\n            if required_tech_id == -1:\n                continue\n            if required_tech_id == 104:\n                required_tech_count -= 1\n                continue\n            if required_tech_id in dataset.civ_boni.keys():\n                continue\n            relevant_ids.append(required_tech_id)\n        if len(relevant_ids) == 0:\n            return []\n        if len(relevant_ids) == 1:\n            required_tech_id = relevant_ids[0]\n            return AoCAuxiliarySubprocessor.get_condition(converter_obj_group, obj_ref, required_tech_id)\n        gate_ref = f'{obj_ref}.UnlockCondition'\n        gate_raw_api_object = RawAPIObject(gate_ref, 'UnlockCondition', dataset.nyan_api_objects)\n        if required_tech_count == len(relevant_ids):\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.AND')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n        else:\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.SUBSETMIN')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n            gate_raw_api_object.add_raw_member('size', required_tech_count, 'engine.util.logic.gate.type.SUBSETMIN')\n        gate_raw_api_object.set_location(gate_location)\n        gate_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        inputs = []\n        for required_tech_id in relevant_ids:\n            required = AoCAuxiliarySubprocessor.get_condition(converter_obj_group, gate_ref, required_tech_id)\n            inputs.extend(required)\n        gate_raw_api_object.add_raw_member('inputs', inputs, 'engine.util.logic.gate.LogicGate')\n        converter_obj_group.add_raw_api_object(gate_raw_api_object)\n        gate_forward_ref = ForwardRef(converter_obj_group, gate_ref)\n        return [gate_forward_ref]",
            "@staticmethod\ndef get_condition(converter_obj_group: ConverterObjectGroup, obj_ref: str, tech_id: int, top_level: bool=False) -> list[ForwardRef]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Creates the condition for a creatable or researchable from tech\\n        by recursively searching the required techs.\\n\\n        :param converter_object: ConverterObjectGroup that the condition objects should be nested in.\\n        :param obj_ref: Reference of converter_object inside the modpack.\\n        :param tech_id: tech ID of a tech wth a conditional unlock.\\n        :param top_level: True if the condition has subconditions, False otherwise.\\n        '\n    dataset = converter_obj_group.data\n    tech = dataset.genie_techs[tech_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    if not top_level and (tech_id in dataset.initiated_techs.keys() or (tech_id in dataset.tech_groups.keys() and dataset.tech_groups[tech_id].is_researchable())):\n        if tech_id in dataset.initiated_techs.keys():\n            initiated_tech = dataset.initiated_techs[tech_id]\n            building_id = initiated_tech.get_building_id()\n            building_name = name_lookup_dict[building_id][0]\n            literal_name = f'{building_name}Built'\n            literal_parent = 'engine.util.logic.literal.type.GameEntityProgress'\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_name = tech_lookup_dict[tech_id][0]\n            literal_name = f'{tech_name}Researched'\n            literal_parent = 'engine.util.logic.literal.type.TechResearched'\n        else:\n            raise ValueError('Required tech id {tech_id} is neither intiated nor researchable')\n        literal_ref = f'{obj_ref}.{literal_name}'\n        literal_raw_api_object = RawAPIObject(literal_ref, literal_name, dataset.nyan_api_objects)\n        literal_raw_api_object.add_raw_parent(literal_parent)\n        literal_location = ForwardRef(converter_obj_group, obj_ref)\n        literal_raw_api_object.set_location(literal_location)\n        if tech_id in dataset.initiated_techs.keys():\n            building_line = dataset.unit_ref[building_id]\n            building_forward_ref = ForwardRef(building_line, building_name)\n            literal_raw_api_object.add_raw_member('game_entity', building_forward_ref, literal_parent)\n            progress_ref = f'{literal_ref}.ProgressStatus'\n            progress_raw_api_object = RawAPIObject(progress_ref, 'ProgressStatus', dataset.nyan_api_objects)\n            progress_raw_api_object.add_raw_parent('engine.util.progress_status.ProgressStatus')\n            progress_location = ForwardRef(converter_obj_group, literal_ref)\n            progress_raw_api_object.set_location(progress_location)\n            progress_type = dataset.nyan_api_objects['engine.util.progress_type.type.Construct']\n            progress_raw_api_object.add_raw_member('progress_type', progress_type, 'engine.util.progress_status.ProgressStatus')\n            progress_raw_api_object.add_raw_member('progress', 100, 'engine.util.progress_status.ProgressStatus')\n            converter_obj_group.add_raw_api_object(progress_raw_api_object)\n            progress_forward_ref = ForwardRef(converter_obj_group, progress_ref)\n            literal_raw_api_object.add_raw_member('progress_status', progress_forward_ref, literal_parent)\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_group = dataset.tech_groups[tech_id]\n            tech_forward_ref = ForwardRef(tech_group, tech_name)\n            literal_raw_api_object.add_raw_member('tech', tech_forward_ref, literal_parent)\n        scope_ref = f'{literal_ref}.LiteralScope'\n        scope_raw_api_object = RawAPIObject(scope_ref, 'LiteralScope', dataset.nyan_api_objects)\n        scope_raw_api_object.add_raw_parent('engine.util.logic.literal_scope.type.Any')\n        scope_location = ForwardRef(converter_obj_group, literal_ref)\n        scope_raw_api_object.set_location(scope_location)\n        scope_diplomatic_stances = [dataset.nyan_api_objects['engine.util.diplomatic_stance.type.Self']]\n        scope_raw_api_object.add_raw_member('stances', scope_diplomatic_stances, 'engine.util.logic.literal_scope.LiteralScope')\n        converter_obj_group.add_raw_api_object(scope_raw_api_object)\n        scope_forward_ref = ForwardRef(converter_obj_group, scope_ref)\n        literal_raw_api_object.add_raw_member('scope', scope_forward_ref, 'engine.util.logic.literal.Literal')\n        literal_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        converter_obj_group.add_raw_api_object(literal_raw_api_object)\n        literal_forward_ref = ForwardRef(converter_obj_group, literal_ref)\n        return [literal_forward_ref]\n    else:\n        assoc_tech_id_members = []\n        assoc_tech_id_members.extend(tech['required_techs'].value)\n        required_tech_count = tech['required_tech_count'].value\n        relevant_ids = []\n        for tech_id_member in assoc_tech_id_members:\n            required_tech_id = tech_id_member.value\n            if required_tech_id == -1:\n                continue\n            if required_tech_id == 104:\n                required_tech_count -= 1\n                continue\n            if required_tech_id in dataset.civ_boni.keys():\n                continue\n            relevant_ids.append(required_tech_id)\n        if len(relevant_ids) == 0:\n            return []\n        if len(relevant_ids) == 1:\n            required_tech_id = relevant_ids[0]\n            return AoCAuxiliarySubprocessor.get_condition(converter_obj_group, obj_ref, required_tech_id)\n        gate_ref = f'{obj_ref}.UnlockCondition'\n        gate_raw_api_object = RawAPIObject(gate_ref, 'UnlockCondition', dataset.nyan_api_objects)\n        if required_tech_count == len(relevant_ids):\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.AND')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n        else:\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.SUBSETMIN')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n            gate_raw_api_object.add_raw_member('size', required_tech_count, 'engine.util.logic.gate.type.SUBSETMIN')\n        gate_raw_api_object.set_location(gate_location)\n        gate_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        inputs = []\n        for required_tech_id in relevant_ids:\n            required = AoCAuxiliarySubprocessor.get_condition(converter_obj_group, gate_ref, required_tech_id)\n            inputs.extend(required)\n        gate_raw_api_object.add_raw_member('inputs', inputs, 'engine.util.logic.gate.LogicGate')\n        converter_obj_group.add_raw_api_object(gate_raw_api_object)\n        gate_forward_ref = ForwardRef(converter_obj_group, gate_ref)\n        return [gate_forward_ref]",
            "@staticmethod\ndef get_condition(converter_obj_group: ConverterObjectGroup, obj_ref: str, tech_id: int, top_level: bool=False) -> list[ForwardRef]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Creates the condition for a creatable or researchable from tech\\n        by recursively searching the required techs.\\n\\n        :param converter_object: ConverterObjectGroup that the condition objects should be nested in.\\n        :param obj_ref: Reference of converter_object inside the modpack.\\n        :param tech_id: tech ID of a tech wth a conditional unlock.\\n        :param top_level: True if the condition has subconditions, False otherwise.\\n        '\n    dataset = converter_obj_group.data\n    tech = dataset.genie_techs[tech_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    if not top_level and (tech_id in dataset.initiated_techs.keys() or (tech_id in dataset.tech_groups.keys() and dataset.tech_groups[tech_id].is_researchable())):\n        if tech_id in dataset.initiated_techs.keys():\n            initiated_tech = dataset.initiated_techs[tech_id]\n            building_id = initiated_tech.get_building_id()\n            building_name = name_lookup_dict[building_id][0]\n            literal_name = f'{building_name}Built'\n            literal_parent = 'engine.util.logic.literal.type.GameEntityProgress'\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_name = tech_lookup_dict[tech_id][0]\n            literal_name = f'{tech_name}Researched'\n            literal_parent = 'engine.util.logic.literal.type.TechResearched'\n        else:\n            raise ValueError('Required tech id {tech_id} is neither intiated nor researchable')\n        literal_ref = f'{obj_ref}.{literal_name}'\n        literal_raw_api_object = RawAPIObject(literal_ref, literal_name, dataset.nyan_api_objects)\n        literal_raw_api_object.add_raw_parent(literal_parent)\n        literal_location = ForwardRef(converter_obj_group, obj_ref)\n        literal_raw_api_object.set_location(literal_location)\n        if tech_id in dataset.initiated_techs.keys():\n            building_line = dataset.unit_ref[building_id]\n            building_forward_ref = ForwardRef(building_line, building_name)\n            literal_raw_api_object.add_raw_member('game_entity', building_forward_ref, literal_parent)\n            progress_ref = f'{literal_ref}.ProgressStatus'\n            progress_raw_api_object = RawAPIObject(progress_ref, 'ProgressStatus', dataset.nyan_api_objects)\n            progress_raw_api_object.add_raw_parent('engine.util.progress_status.ProgressStatus')\n            progress_location = ForwardRef(converter_obj_group, literal_ref)\n            progress_raw_api_object.set_location(progress_location)\n            progress_type = dataset.nyan_api_objects['engine.util.progress_type.type.Construct']\n            progress_raw_api_object.add_raw_member('progress_type', progress_type, 'engine.util.progress_status.ProgressStatus')\n            progress_raw_api_object.add_raw_member('progress', 100, 'engine.util.progress_status.ProgressStatus')\n            converter_obj_group.add_raw_api_object(progress_raw_api_object)\n            progress_forward_ref = ForwardRef(converter_obj_group, progress_ref)\n            literal_raw_api_object.add_raw_member('progress_status', progress_forward_ref, literal_parent)\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_group = dataset.tech_groups[tech_id]\n            tech_forward_ref = ForwardRef(tech_group, tech_name)\n            literal_raw_api_object.add_raw_member('tech', tech_forward_ref, literal_parent)\n        scope_ref = f'{literal_ref}.LiteralScope'\n        scope_raw_api_object = RawAPIObject(scope_ref, 'LiteralScope', dataset.nyan_api_objects)\n        scope_raw_api_object.add_raw_parent('engine.util.logic.literal_scope.type.Any')\n        scope_location = ForwardRef(converter_obj_group, literal_ref)\n        scope_raw_api_object.set_location(scope_location)\n        scope_diplomatic_stances = [dataset.nyan_api_objects['engine.util.diplomatic_stance.type.Self']]\n        scope_raw_api_object.add_raw_member('stances', scope_diplomatic_stances, 'engine.util.logic.literal_scope.LiteralScope')\n        converter_obj_group.add_raw_api_object(scope_raw_api_object)\n        scope_forward_ref = ForwardRef(converter_obj_group, scope_ref)\n        literal_raw_api_object.add_raw_member('scope', scope_forward_ref, 'engine.util.logic.literal.Literal')\n        literal_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        converter_obj_group.add_raw_api_object(literal_raw_api_object)\n        literal_forward_ref = ForwardRef(converter_obj_group, literal_ref)\n        return [literal_forward_ref]\n    else:\n        assoc_tech_id_members = []\n        assoc_tech_id_members.extend(tech['required_techs'].value)\n        required_tech_count = tech['required_tech_count'].value\n        relevant_ids = []\n        for tech_id_member in assoc_tech_id_members:\n            required_tech_id = tech_id_member.value\n            if required_tech_id == -1:\n                continue\n            if required_tech_id == 104:\n                required_tech_count -= 1\n                continue\n            if required_tech_id in dataset.civ_boni.keys():\n                continue\n            relevant_ids.append(required_tech_id)\n        if len(relevant_ids) == 0:\n            return []\n        if len(relevant_ids) == 1:\n            required_tech_id = relevant_ids[0]\n            return AoCAuxiliarySubprocessor.get_condition(converter_obj_group, obj_ref, required_tech_id)\n        gate_ref = f'{obj_ref}.UnlockCondition'\n        gate_raw_api_object = RawAPIObject(gate_ref, 'UnlockCondition', dataset.nyan_api_objects)\n        if required_tech_count == len(relevant_ids):\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.AND')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n        else:\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.SUBSETMIN')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n            gate_raw_api_object.add_raw_member('size', required_tech_count, 'engine.util.logic.gate.type.SUBSETMIN')\n        gate_raw_api_object.set_location(gate_location)\n        gate_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        inputs = []\n        for required_tech_id in relevant_ids:\n            required = AoCAuxiliarySubprocessor.get_condition(converter_obj_group, gate_ref, required_tech_id)\n            inputs.extend(required)\n        gate_raw_api_object.add_raw_member('inputs', inputs, 'engine.util.logic.gate.LogicGate')\n        converter_obj_group.add_raw_api_object(gate_raw_api_object)\n        gate_forward_ref = ForwardRef(converter_obj_group, gate_ref)\n        return [gate_forward_ref]",
            "@staticmethod\ndef get_condition(converter_obj_group: ConverterObjectGroup, obj_ref: str, tech_id: int, top_level: bool=False) -> list[ForwardRef]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Creates the condition for a creatable or researchable from tech\\n        by recursively searching the required techs.\\n\\n        :param converter_object: ConverterObjectGroup that the condition objects should be nested in.\\n        :param obj_ref: Reference of converter_object inside the modpack.\\n        :param tech_id: tech ID of a tech wth a conditional unlock.\\n        :param top_level: True if the condition has subconditions, False otherwise.\\n        '\n    dataset = converter_obj_group.data\n    tech = dataset.genie_techs[tech_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    if not top_level and (tech_id in dataset.initiated_techs.keys() or (tech_id in dataset.tech_groups.keys() and dataset.tech_groups[tech_id].is_researchable())):\n        if tech_id in dataset.initiated_techs.keys():\n            initiated_tech = dataset.initiated_techs[tech_id]\n            building_id = initiated_tech.get_building_id()\n            building_name = name_lookup_dict[building_id][0]\n            literal_name = f'{building_name}Built'\n            literal_parent = 'engine.util.logic.literal.type.GameEntityProgress'\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_name = tech_lookup_dict[tech_id][0]\n            literal_name = f'{tech_name}Researched'\n            literal_parent = 'engine.util.logic.literal.type.TechResearched'\n        else:\n            raise ValueError('Required tech id {tech_id} is neither intiated nor researchable')\n        literal_ref = f'{obj_ref}.{literal_name}'\n        literal_raw_api_object = RawAPIObject(literal_ref, literal_name, dataset.nyan_api_objects)\n        literal_raw_api_object.add_raw_parent(literal_parent)\n        literal_location = ForwardRef(converter_obj_group, obj_ref)\n        literal_raw_api_object.set_location(literal_location)\n        if tech_id in dataset.initiated_techs.keys():\n            building_line = dataset.unit_ref[building_id]\n            building_forward_ref = ForwardRef(building_line, building_name)\n            literal_raw_api_object.add_raw_member('game_entity', building_forward_ref, literal_parent)\n            progress_ref = f'{literal_ref}.ProgressStatus'\n            progress_raw_api_object = RawAPIObject(progress_ref, 'ProgressStatus', dataset.nyan_api_objects)\n            progress_raw_api_object.add_raw_parent('engine.util.progress_status.ProgressStatus')\n            progress_location = ForwardRef(converter_obj_group, literal_ref)\n            progress_raw_api_object.set_location(progress_location)\n            progress_type = dataset.nyan_api_objects['engine.util.progress_type.type.Construct']\n            progress_raw_api_object.add_raw_member('progress_type', progress_type, 'engine.util.progress_status.ProgressStatus')\n            progress_raw_api_object.add_raw_member('progress', 100, 'engine.util.progress_status.ProgressStatus')\n            converter_obj_group.add_raw_api_object(progress_raw_api_object)\n            progress_forward_ref = ForwardRef(converter_obj_group, progress_ref)\n            literal_raw_api_object.add_raw_member('progress_status', progress_forward_ref, literal_parent)\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_group = dataset.tech_groups[tech_id]\n            tech_forward_ref = ForwardRef(tech_group, tech_name)\n            literal_raw_api_object.add_raw_member('tech', tech_forward_ref, literal_parent)\n        scope_ref = f'{literal_ref}.LiteralScope'\n        scope_raw_api_object = RawAPIObject(scope_ref, 'LiteralScope', dataset.nyan_api_objects)\n        scope_raw_api_object.add_raw_parent('engine.util.logic.literal_scope.type.Any')\n        scope_location = ForwardRef(converter_obj_group, literal_ref)\n        scope_raw_api_object.set_location(scope_location)\n        scope_diplomatic_stances = [dataset.nyan_api_objects['engine.util.diplomatic_stance.type.Self']]\n        scope_raw_api_object.add_raw_member('stances', scope_diplomatic_stances, 'engine.util.logic.literal_scope.LiteralScope')\n        converter_obj_group.add_raw_api_object(scope_raw_api_object)\n        scope_forward_ref = ForwardRef(converter_obj_group, scope_ref)\n        literal_raw_api_object.add_raw_member('scope', scope_forward_ref, 'engine.util.logic.literal.Literal')\n        literal_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        converter_obj_group.add_raw_api_object(literal_raw_api_object)\n        literal_forward_ref = ForwardRef(converter_obj_group, literal_ref)\n        return [literal_forward_ref]\n    else:\n        assoc_tech_id_members = []\n        assoc_tech_id_members.extend(tech['required_techs'].value)\n        required_tech_count = tech['required_tech_count'].value\n        relevant_ids = []\n        for tech_id_member in assoc_tech_id_members:\n            required_tech_id = tech_id_member.value\n            if required_tech_id == -1:\n                continue\n            if required_tech_id == 104:\n                required_tech_count -= 1\n                continue\n            if required_tech_id in dataset.civ_boni.keys():\n                continue\n            relevant_ids.append(required_tech_id)\n        if len(relevant_ids) == 0:\n            return []\n        if len(relevant_ids) == 1:\n            required_tech_id = relevant_ids[0]\n            return AoCAuxiliarySubprocessor.get_condition(converter_obj_group, obj_ref, required_tech_id)\n        gate_ref = f'{obj_ref}.UnlockCondition'\n        gate_raw_api_object = RawAPIObject(gate_ref, 'UnlockCondition', dataset.nyan_api_objects)\n        if required_tech_count == len(relevant_ids):\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.AND')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n        else:\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.SUBSETMIN')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n            gate_raw_api_object.add_raw_member('size', required_tech_count, 'engine.util.logic.gate.type.SUBSETMIN')\n        gate_raw_api_object.set_location(gate_location)\n        gate_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        inputs = []\n        for required_tech_id in relevant_ids:\n            required = AoCAuxiliarySubprocessor.get_condition(converter_obj_group, gate_ref, required_tech_id)\n            inputs.extend(required)\n        gate_raw_api_object.add_raw_member('inputs', inputs, 'engine.util.logic.gate.LogicGate')\n        converter_obj_group.add_raw_api_object(gate_raw_api_object)\n        gate_forward_ref = ForwardRef(converter_obj_group, gate_ref)\n        return [gate_forward_ref]",
            "@staticmethod\ndef get_condition(converter_obj_group: ConverterObjectGroup, obj_ref: str, tech_id: int, top_level: bool=False) -> list[ForwardRef]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Creates the condition for a creatable or researchable from tech\\n        by recursively searching the required techs.\\n\\n        :param converter_object: ConverterObjectGroup that the condition objects should be nested in.\\n        :param obj_ref: Reference of converter_object inside the modpack.\\n        :param tech_id: tech ID of a tech wth a conditional unlock.\\n        :param top_level: True if the condition has subconditions, False otherwise.\\n        '\n    dataset = converter_obj_group.data\n    tech = dataset.genie_techs[tech_id]\n    name_lookup_dict = internal_name_lookups.get_entity_lookups(dataset.game_version)\n    tech_lookup_dict = internal_name_lookups.get_tech_lookups(dataset.game_version)\n    if not top_level and (tech_id in dataset.initiated_techs.keys() or (tech_id in dataset.tech_groups.keys() and dataset.tech_groups[tech_id].is_researchable())):\n        if tech_id in dataset.initiated_techs.keys():\n            initiated_tech = dataset.initiated_techs[tech_id]\n            building_id = initiated_tech.get_building_id()\n            building_name = name_lookup_dict[building_id][0]\n            literal_name = f'{building_name}Built'\n            literal_parent = 'engine.util.logic.literal.type.GameEntityProgress'\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_name = tech_lookup_dict[tech_id][0]\n            literal_name = f'{tech_name}Researched'\n            literal_parent = 'engine.util.logic.literal.type.TechResearched'\n        else:\n            raise ValueError('Required tech id {tech_id} is neither intiated nor researchable')\n        literal_ref = f'{obj_ref}.{literal_name}'\n        literal_raw_api_object = RawAPIObject(literal_ref, literal_name, dataset.nyan_api_objects)\n        literal_raw_api_object.add_raw_parent(literal_parent)\n        literal_location = ForwardRef(converter_obj_group, obj_ref)\n        literal_raw_api_object.set_location(literal_location)\n        if tech_id in dataset.initiated_techs.keys():\n            building_line = dataset.unit_ref[building_id]\n            building_forward_ref = ForwardRef(building_line, building_name)\n            literal_raw_api_object.add_raw_member('game_entity', building_forward_ref, literal_parent)\n            progress_ref = f'{literal_ref}.ProgressStatus'\n            progress_raw_api_object = RawAPIObject(progress_ref, 'ProgressStatus', dataset.nyan_api_objects)\n            progress_raw_api_object.add_raw_parent('engine.util.progress_status.ProgressStatus')\n            progress_location = ForwardRef(converter_obj_group, literal_ref)\n            progress_raw_api_object.set_location(progress_location)\n            progress_type = dataset.nyan_api_objects['engine.util.progress_type.type.Construct']\n            progress_raw_api_object.add_raw_member('progress_type', progress_type, 'engine.util.progress_status.ProgressStatus')\n            progress_raw_api_object.add_raw_member('progress', 100, 'engine.util.progress_status.ProgressStatus')\n            converter_obj_group.add_raw_api_object(progress_raw_api_object)\n            progress_forward_ref = ForwardRef(converter_obj_group, progress_ref)\n            literal_raw_api_object.add_raw_member('progress_status', progress_forward_ref, literal_parent)\n        elif dataset.tech_groups[tech_id].is_researchable():\n            tech_group = dataset.tech_groups[tech_id]\n            tech_forward_ref = ForwardRef(tech_group, tech_name)\n            literal_raw_api_object.add_raw_member('tech', tech_forward_ref, literal_parent)\n        scope_ref = f'{literal_ref}.LiteralScope'\n        scope_raw_api_object = RawAPIObject(scope_ref, 'LiteralScope', dataset.nyan_api_objects)\n        scope_raw_api_object.add_raw_parent('engine.util.logic.literal_scope.type.Any')\n        scope_location = ForwardRef(converter_obj_group, literal_ref)\n        scope_raw_api_object.set_location(scope_location)\n        scope_diplomatic_stances = [dataset.nyan_api_objects['engine.util.diplomatic_stance.type.Self']]\n        scope_raw_api_object.add_raw_member('stances', scope_diplomatic_stances, 'engine.util.logic.literal_scope.LiteralScope')\n        converter_obj_group.add_raw_api_object(scope_raw_api_object)\n        scope_forward_ref = ForwardRef(converter_obj_group, scope_ref)\n        literal_raw_api_object.add_raw_member('scope', scope_forward_ref, 'engine.util.logic.literal.Literal')\n        literal_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        converter_obj_group.add_raw_api_object(literal_raw_api_object)\n        literal_forward_ref = ForwardRef(converter_obj_group, literal_ref)\n        return [literal_forward_ref]\n    else:\n        assoc_tech_id_members = []\n        assoc_tech_id_members.extend(tech['required_techs'].value)\n        required_tech_count = tech['required_tech_count'].value\n        relevant_ids = []\n        for tech_id_member in assoc_tech_id_members:\n            required_tech_id = tech_id_member.value\n            if required_tech_id == -1:\n                continue\n            if required_tech_id == 104:\n                required_tech_count -= 1\n                continue\n            if required_tech_id in dataset.civ_boni.keys():\n                continue\n            relevant_ids.append(required_tech_id)\n        if len(relevant_ids) == 0:\n            return []\n        if len(relevant_ids) == 1:\n            required_tech_id = relevant_ids[0]\n            return AoCAuxiliarySubprocessor.get_condition(converter_obj_group, obj_ref, required_tech_id)\n        gate_ref = f'{obj_ref}.UnlockCondition'\n        gate_raw_api_object = RawAPIObject(gate_ref, 'UnlockCondition', dataset.nyan_api_objects)\n        if required_tech_count == len(relevant_ids):\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.AND')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n        else:\n            gate_raw_api_object.add_raw_parent('engine.util.logic.gate.type.SUBSETMIN')\n            gate_location = ForwardRef(converter_obj_group, obj_ref)\n            gate_raw_api_object.add_raw_member('size', required_tech_count, 'engine.util.logic.gate.type.SUBSETMIN')\n        gate_raw_api_object.set_location(gate_location)\n        gate_raw_api_object.add_raw_member('only_once', True, 'engine.util.logic.LogicElement')\n        inputs = []\n        for required_tech_id in relevant_ids:\n            required = AoCAuxiliarySubprocessor.get_condition(converter_obj_group, gate_ref, required_tech_id)\n            inputs.extend(required)\n        gate_raw_api_object.add_raw_member('inputs', inputs, 'engine.util.logic.gate.LogicGate')\n        converter_obj_group.add_raw_api_object(gate_raw_api_object)\n        gate_forward_ref = ForwardRef(converter_obj_group, gate_ref)\n        return [gate_forward_ref]"
        ]
    }
]