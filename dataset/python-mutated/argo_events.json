[
    {
        "func_name": "__init__",
        "original": "def __init__(self, name, url=ARGO_EVENTS_WEBHOOK_URL, payload=None, access_token=None):\n    self._name = name\n    self._url = url\n    self._payload = payload or {}\n    self._access_token = access_token",
        "mutated": [
            "def __init__(self, name, url=ARGO_EVENTS_WEBHOOK_URL, payload=None, access_token=None):\n    if False:\n        i = 10\n    self._name = name\n    self._url = url\n    self._payload = payload or {}\n    self._access_token = access_token",
            "def __init__(self, name, url=ARGO_EVENTS_WEBHOOK_URL, payload=None, access_token=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._name = name\n    self._url = url\n    self._payload = payload or {}\n    self._access_token = access_token",
            "def __init__(self, name, url=ARGO_EVENTS_WEBHOOK_URL, payload=None, access_token=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._name = name\n    self._url = url\n    self._payload = payload or {}\n    self._access_token = access_token",
            "def __init__(self, name, url=ARGO_EVENTS_WEBHOOK_URL, payload=None, access_token=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._name = name\n    self._url = url\n    self._payload = payload or {}\n    self._access_token = access_token",
            "def __init__(self, name, url=ARGO_EVENTS_WEBHOOK_URL, payload=None, access_token=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._name = name\n    self._url = url\n    self._payload = payload or {}\n    self._access_token = access_token"
        ]
    },
    {
        "func_name": "add_to_payload",
        "original": "def add_to_payload(self, key, value):\n    \"\"\"\n        Add a key-value pair in the payload. This is typically used to set parameters\n        of triggered flows. Often, `key` is the parameter name you want to set to\n        `value`. Overrides any existing value of `key`.\n\n        Parameters\n        ----------\n        key : str\n            Key\n        value : str\n            Value\n        \"\"\"\n    self._payload[key] = str(value)\n    return self",
        "mutated": [
            "def add_to_payload(self, key, value):\n    if False:\n        i = 10\n    '\\n        Add a key-value pair in the payload. This is typically used to set parameters\\n        of triggered flows. Often, `key` is the parameter name you want to set to\\n        `value`. Overrides any existing value of `key`.\\n\\n        Parameters\\n        ----------\\n        key : str\\n            Key\\n        value : str\\n            Value\\n        '\n    self._payload[key] = str(value)\n    return self",
            "def add_to_payload(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Add a key-value pair in the payload. This is typically used to set parameters\\n        of triggered flows. Often, `key` is the parameter name you want to set to\\n        `value`. Overrides any existing value of `key`.\\n\\n        Parameters\\n        ----------\\n        key : str\\n            Key\\n        value : str\\n            Value\\n        '\n    self._payload[key] = str(value)\n    return self",
            "def add_to_payload(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Add a key-value pair in the payload. This is typically used to set parameters\\n        of triggered flows. Often, `key` is the parameter name you want to set to\\n        `value`. Overrides any existing value of `key`.\\n\\n        Parameters\\n        ----------\\n        key : str\\n            Key\\n        value : str\\n            Value\\n        '\n    self._payload[key] = str(value)\n    return self",
            "def add_to_payload(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Add a key-value pair in the payload. This is typically used to set parameters\\n        of triggered flows. Often, `key` is the parameter name you want to set to\\n        `value`. Overrides any existing value of `key`.\\n\\n        Parameters\\n        ----------\\n        key : str\\n            Key\\n        value : str\\n            Value\\n        '\n    self._payload[key] = str(value)\n    return self",
            "def add_to_payload(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Add a key-value pair in the payload. This is typically used to set parameters\\n        of triggered flows. Often, `key` is the parameter name you want to set to\\n        `value`. Overrides any existing value of `key`.\\n\\n        Parameters\\n        ----------\\n        key : str\\n            Key\\n        value : str\\n            Value\\n        '\n    self._payload[key] = str(value)\n    return self"
        ]
    },
    {
        "func_name": "safe_publish",
        "original": "def safe_publish(self, payload=None, ignore_errors=True):\n    \"\"\"\n        Publishes an event when called inside a deployed workflow. Outside a deployed workflow\n        this function does nothing.\n\n        Use this function inside flows to create events safely. As this function is a no-op\n        for local runs, you can safely call it during local development without causing unintended\n        side-effects. It takes effect only when deployed on Argo Workflows.\n\n        Parameters\n        ----------\n        payload : dict\n            Additional key-value pairs to add to the payload.\n        ignore_errors : bool, default: True\n            If True, events are created on a best effort basis - errors are silently ignored.\n        \"\"\"\n    return self.publish(payload=payload, force=False, ignore_errors=ignore_errors)",
        "mutated": [
            "def safe_publish(self, payload=None, ignore_errors=True):\n    if False:\n        i = 10\n    '\\n        Publishes an event when called inside a deployed workflow. Outside a deployed workflow\\n        this function does nothing.\\n\\n        Use this function inside flows to create events safely. As this function is a no-op\\n        for local runs, you can safely call it during local development without causing unintended\\n        side-effects. It takes effect only when deployed on Argo Workflows.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    return self.publish(payload=payload, force=False, ignore_errors=ignore_errors)",
            "def safe_publish(self, payload=None, ignore_errors=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Publishes an event when called inside a deployed workflow. Outside a deployed workflow\\n        this function does nothing.\\n\\n        Use this function inside flows to create events safely. As this function is a no-op\\n        for local runs, you can safely call it during local development without causing unintended\\n        side-effects. It takes effect only when deployed on Argo Workflows.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    return self.publish(payload=payload, force=False, ignore_errors=ignore_errors)",
            "def safe_publish(self, payload=None, ignore_errors=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Publishes an event when called inside a deployed workflow. Outside a deployed workflow\\n        this function does nothing.\\n\\n        Use this function inside flows to create events safely. As this function is a no-op\\n        for local runs, you can safely call it during local development without causing unintended\\n        side-effects. It takes effect only when deployed on Argo Workflows.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    return self.publish(payload=payload, force=False, ignore_errors=ignore_errors)",
            "def safe_publish(self, payload=None, ignore_errors=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Publishes an event when called inside a deployed workflow. Outside a deployed workflow\\n        this function does nothing.\\n\\n        Use this function inside flows to create events safely. As this function is a no-op\\n        for local runs, you can safely call it during local development without causing unintended\\n        side-effects. It takes effect only when deployed on Argo Workflows.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    return self.publish(payload=payload, force=False, ignore_errors=ignore_errors)",
            "def safe_publish(self, payload=None, ignore_errors=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Publishes an event when called inside a deployed workflow. Outside a deployed workflow\\n        this function does nothing.\\n\\n        Use this function inside flows to create events safely. As this function is a no-op\\n        for local runs, you can safely call it during local development without causing unintended\\n        side-effects. It takes effect only when deployed on Argo Workflows.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    return self.publish(payload=payload, force=False, ignore_errors=ignore_errors)"
        ]
    },
    {
        "func_name": "publish",
        "original": "def publish(self, payload=None, force=True, ignore_errors=True):\n    \"\"\"\n        Publishes an event.\n\n        Note that the function returns immediately after the event has been sent. It\n        does not wait for flows to start, nor it guarantees that any flows will start.\n\n        Parameters\n        ----------\n        payload : dict\n            Additional key-value pairs to add to the payload.\n        ignore_errors : bool, default: True\n            If True, events are created on a best effort basis - errors are silently ignored.\n        \"\"\"\n    if payload == None:\n        payload = {}\n    if force or os.environ.get('ARGO_WORKFLOW_TEMPLATE'):\n        try:\n            headers = {}\n            if self._access_token:\n                headers = {'Authorization': 'Bearer {}'.format(self._access_token)}\n            if ARGO_EVENTS_WEBHOOK_AUTH == 'service':\n                headers.update(SERVICE_HEADERS)\n            data = {'name': self._name, 'payload': {'name': self._name, 'id': str(uuid.uuid4()), 'timestamp': int(time.time()), 'utc_date': datetime.utcnow().strftime('%Y%m%d'), 'generated-by-metaflow': True, **self._payload, **payload}}\n            request = urllib.request.Request(self._url, method='POST', headers={'Content-Type': 'application/json', **headers}, data=json.dumps(data).encode('utf-8'))\n            retries = 3\n            backoff_factor = 2\n            for i in range(retries):\n                try:\n                    urllib.request.urlopen(request, timeout=10.0)\n                    print('Argo Event (%s) published.' % self._name, file=sys.stderr)\n                    return data['payload']['id']\n                except urllib.error.HTTPError as e:\n                    raise e\n                except urllib.error.URLError as e:\n                    if i == retries - 1:\n                        raise e\n                    else:\n                        time.sleep(backoff_factor ** i)\n        except Exception as e:\n            msg = 'Unable to publish Argo Event (%s): %s' % (self._name, e)\n            if ignore_errors:\n                print(msg, file=sys.stderr)\n            else:\n                raise ArgoEventException(msg)\n    else:\n        msg = ('Argo Event (%s) was not published. Use ' + 'ArgoEvent(...).publish(...) ' + 'to force publish.') % self._name\n        if ignore_errors:\n            print(msg, file=sys.stderr)\n        else:\n            raise ArgoEventException(msg)",
        "mutated": [
            "def publish(self, payload=None, force=True, ignore_errors=True):\n    if False:\n        i = 10\n    '\\n        Publishes an event.\\n\\n        Note that the function returns immediately after the event has been sent. It\\n        does not wait for flows to start, nor it guarantees that any flows will start.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    if payload == None:\n        payload = {}\n    if force or os.environ.get('ARGO_WORKFLOW_TEMPLATE'):\n        try:\n            headers = {}\n            if self._access_token:\n                headers = {'Authorization': 'Bearer {}'.format(self._access_token)}\n            if ARGO_EVENTS_WEBHOOK_AUTH == 'service':\n                headers.update(SERVICE_HEADERS)\n            data = {'name': self._name, 'payload': {'name': self._name, 'id': str(uuid.uuid4()), 'timestamp': int(time.time()), 'utc_date': datetime.utcnow().strftime('%Y%m%d'), 'generated-by-metaflow': True, **self._payload, **payload}}\n            request = urllib.request.Request(self._url, method='POST', headers={'Content-Type': 'application/json', **headers}, data=json.dumps(data).encode('utf-8'))\n            retries = 3\n            backoff_factor = 2\n            for i in range(retries):\n                try:\n                    urllib.request.urlopen(request, timeout=10.0)\n                    print('Argo Event (%s) published.' % self._name, file=sys.stderr)\n                    return data['payload']['id']\n                except urllib.error.HTTPError as e:\n                    raise e\n                except urllib.error.URLError as e:\n                    if i == retries - 1:\n                        raise e\n                    else:\n                        time.sleep(backoff_factor ** i)\n        except Exception as e:\n            msg = 'Unable to publish Argo Event (%s): %s' % (self._name, e)\n            if ignore_errors:\n                print(msg, file=sys.stderr)\n            else:\n                raise ArgoEventException(msg)\n    else:\n        msg = ('Argo Event (%s) was not published. Use ' + 'ArgoEvent(...).publish(...) ' + 'to force publish.') % self._name\n        if ignore_errors:\n            print(msg, file=sys.stderr)\n        else:\n            raise ArgoEventException(msg)",
            "def publish(self, payload=None, force=True, ignore_errors=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Publishes an event.\\n\\n        Note that the function returns immediately after the event has been sent. It\\n        does not wait for flows to start, nor it guarantees that any flows will start.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    if payload == None:\n        payload = {}\n    if force or os.environ.get('ARGO_WORKFLOW_TEMPLATE'):\n        try:\n            headers = {}\n            if self._access_token:\n                headers = {'Authorization': 'Bearer {}'.format(self._access_token)}\n            if ARGO_EVENTS_WEBHOOK_AUTH == 'service':\n                headers.update(SERVICE_HEADERS)\n            data = {'name': self._name, 'payload': {'name': self._name, 'id': str(uuid.uuid4()), 'timestamp': int(time.time()), 'utc_date': datetime.utcnow().strftime('%Y%m%d'), 'generated-by-metaflow': True, **self._payload, **payload}}\n            request = urllib.request.Request(self._url, method='POST', headers={'Content-Type': 'application/json', **headers}, data=json.dumps(data).encode('utf-8'))\n            retries = 3\n            backoff_factor = 2\n            for i in range(retries):\n                try:\n                    urllib.request.urlopen(request, timeout=10.0)\n                    print('Argo Event (%s) published.' % self._name, file=sys.stderr)\n                    return data['payload']['id']\n                except urllib.error.HTTPError as e:\n                    raise e\n                except urllib.error.URLError as e:\n                    if i == retries - 1:\n                        raise e\n                    else:\n                        time.sleep(backoff_factor ** i)\n        except Exception as e:\n            msg = 'Unable to publish Argo Event (%s): %s' % (self._name, e)\n            if ignore_errors:\n                print(msg, file=sys.stderr)\n            else:\n                raise ArgoEventException(msg)\n    else:\n        msg = ('Argo Event (%s) was not published. Use ' + 'ArgoEvent(...).publish(...) ' + 'to force publish.') % self._name\n        if ignore_errors:\n            print(msg, file=sys.stderr)\n        else:\n            raise ArgoEventException(msg)",
            "def publish(self, payload=None, force=True, ignore_errors=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Publishes an event.\\n\\n        Note that the function returns immediately after the event has been sent. It\\n        does not wait for flows to start, nor it guarantees that any flows will start.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    if payload == None:\n        payload = {}\n    if force or os.environ.get('ARGO_WORKFLOW_TEMPLATE'):\n        try:\n            headers = {}\n            if self._access_token:\n                headers = {'Authorization': 'Bearer {}'.format(self._access_token)}\n            if ARGO_EVENTS_WEBHOOK_AUTH == 'service':\n                headers.update(SERVICE_HEADERS)\n            data = {'name': self._name, 'payload': {'name': self._name, 'id': str(uuid.uuid4()), 'timestamp': int(time.time()), 'utc_date': datetime.utcnow().strftime('%Y%m%d'), 'generated-by-metaflow': True, **self._payload, **payload}}\n            request = urllib.request.Request(self._url, method='POST', headers={'Content-Type': 'application/json', **headers}, data=json.dumps(data).encode('utf-8'))\n            retries = 3\n            backoff_factor = 2\n            for i in range(retries):\n                try:\n                    urllib.request.urlopen(request, timeout=10.0)\n                    print('Argo Event (%s) published.' % self._name, file=sys.stderr)\n                    return data['payload']['id']\n                except urllib.error.HTTPError as e:\n                    raise e\n                except urllib.error.URLError as e:\n                    if i == retries - 1:\n                        raise e\n                    else:\n                        time.sleep(backoff_factor ** i)\n        except Exception as e:\n            msg = 'Unable to publish Argo Event (%s): %s' % (self._name, e)\n            if ignore_errors:\n                print(msg, file=sys.stderr)\n            else:\n                raise ArgoEventException(msg)\n    else:\n        msg = ('Argo Event (%s) was not published. Use ' + 'ArgoEvent(...).publish(...) ' + 'to force publish.') % self._name\n        if ignore_errors:\n            print(msg, file=sys.stderr)\n        else:\n            raise ArgoEventException(msg)",
            "def publish(self, payload=None, force=True, ignore_errors=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Publishes an event.\\n\\n        Note that the function returns immediately after the event has been sent. It\\n        does not wait for flows to start, nor it guarantees that any flows will start.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    if payload == None:\n        payload = {}\n    if force or os.environ.get('ARGO_WORKFLOW_TEMPLATE'):\n        try:\n            headers = {}\n            if self._access_token:\n                headers = {'Authorization': 'Bearer {}'.format(self._access_token)}\n            if ARGO_EVENTS_WEBHOOK_AUTH == 'service':\n                headers.update(SERVICE_HEADERS)\n            data = {'name': self._name, 'payload': {'name': self._name, 'id': str(uuid.uuid4()), 'timestamp': int(time.time()), 'utc_date': datetime.utcnow().strftime('%Y%m%d'), 'generated-by-metaflow': True, **self._payload, **payload}}\n            request = urllib.request.Request(self._url, method='POST', headers={'Content-Type': 'application/json', **headers}, data=json.dumps(data).encode('utf-8'))\n            retries = 3\n            backoff_factor = 2\n            for i in range(retries):\n                try:\n                    urllib.request.urlopen(request, timeout=10.0)\n                    print('Argo Event (%s) published.' % self._name, file=sys.stderr)\n                    return data['payload']['id']\n                except urllib.error.HTTPError as e:\n                    raise e\n                except urllib.error.URLError as e:\n                    if i == retries - 1:\n                        raise e\n                    else:\n                        time.sleep(backoff_factor ** i)\n        except Exception as e:\n            msg = 'Unable to publish Argo Event (%s): %s' % (self._name, e)\n            if ignore_errors:\n                print(msg, file=sys.stderr)\n            else:\n                raise ArgoEventException(msg)\n    else:\n        msg = ('Argo Event (%s) was not published. Use ' + 'ArgoEvent(...).publish(...) ' + 'to force publish.') % self._name\n        if ignore_errors:\n            print(msg, file=sys.stderr)\n        else:\n            raise ArgoEventException(msg)",
            "def publish(self, payload=None, force=True, ignore_errors=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Publishes an event.\\n\\n        Note that the function returns immediately after the event has been sent. It\\n        does not wait for flows to start, nor it guarantees that any flows will start.\\n\\n        Parameters\\n        ----------\\n        payload : dict\\n            Additional key-value pairs to add to the payload.\\n        ignore_errors : bool, default: True\\n            If True, events are created on a best effort basis - errors are silently ignored.\\n        '\n    if payload == None:\n        payload = {}\n    if force or os.environ.get('ARGO_WORKFLOW_TEMPLATE'):\n        try:\n            headers = {}\n            if self._access_token:\n                headers = {'Authorization': 'Bearer {}'.format(self._access_token)}\n            if ARGO_EVENTS_WEBHOOK_AUTH == 'service':\n                headers.update(SERVICE_HEADERS)\n            data = {'name': self._name, 'payload': {'name': self._name, 'id': str(uuid.uuid4()), 'timestamp': int(time.time()), 'utc_date': datetime.utcnow().strftime('%Y%m%d'), 'generated-by-metaflow': True, **self._payload, **payload}}\n            request = urllib.request.Request(self._url, method='POST', headers={'Content-Type': 'application/json', **headers}, data=json.dumps(data).encode('utf-8'))\n            retries = 3\n            backoff_factor = 2\n            for i in range(retries):\n                try:\n                    urllib.request.urlopen(request, timeout=10.0)\n                    print('Argo Event (%s) published.' % self._name, file=sys.stderr)\n                    return data['payload']['id']\n                except urllib.error.HTTPError as e:\n                    raise e\n                except urllib.error.URLError as e:\n                    if i == retries - 1:\n                        raise e\n                    else:\n                        time.sleep(backoff_factor ** i)\n        except Exception as e:\n            msg = 'Unable to publish Argo Event (%s): %s' % (self._name, e)\n            if ignore_errors:\n                print(msg, file=sys.stderr)\n            else:\n                raise ArgoEventException(msg)\n    else:\n        msg = ('Argo Event (%s) was not published. Use ' + 'ArgoEvent(...).publish(...) ' + 'to force publish.') % self._name\n        if ignore_errors:\n            print(msg, file=sys.stderr)\n        else:\n            raise ArgoEventException(msg)"
        ]
    }
]