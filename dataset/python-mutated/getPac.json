[
    {
        "func_name": "printPac",
        "original": "def printPac(self, data):\n    encTicketPart = decoder.decode(data, asn1Spec=EncTicketPart())[0]\n    adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n    pacType = PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if logging.getLogger().level == logging.DEBUG:\n            print('TYPE 0x%x' % infoBuffer['ulType'])\n        if infoBuffer['ulType'] == 1:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            kerbdata.dump()\n            print()\n            print('Domain SID:', kerbdata['LogonDomainId'].formatCanonical())\n            print()\n        elif infoBuffer['ulType'] == PAC_CLIENT_INFO_TYPE:\n            clientInfo = PAC_CLIENT_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                clientInfo.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_SERVER_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_PRIVSVR_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_UPN_DNS_INFO:\n            upn = UPN_DNS_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                upn.dump()\n                print(data[upn['DnsDomainNameOffset']:])\n                print()\n        else:\n            hexdump(data)\n        if logging.getLogger().level == logging.DEBUG:\n            print('#' * 80)\n        buff = buff[len(infoBuffer):]",
        "mutated": [
            "def printPac(self, data):\n    if False:\n        i = 10\n    encTicketPart = decoder.decode(data, asn1Spec=EncTicketPart())[0]\n    adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n    pacType = PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if logging.getLogger().level == logging.DEBUG:\n            print('TYPE 0x%x' % infoBuffer['ulType'])\n        if infoBuffer['ulType'] == 1:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            kerbdata.dump()\n            print()\n            print('Domain SID:', kerbdata['LogonDomainId'].formatCanonical())\n            print()\n        elif infoBuffer['ulType'] == PAC_CLIENT_INFO_TYPE:\n            clientInfo = PAC_CLIENT_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                clientInfo.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_SERVER_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_PRIVSVR_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_UPN_DNS_INFO:\n            upn = UPN_DNS_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                upn.dump()\n                print(data[upn['DnsDomainNameOffset']:])\n                print()\n        else:\n            hexdump(data)\n        if logging.getLogger().level == logging.DEBUG:\n            print('#' * 80)\n        buff = buff[len(infoBuffer):]",
            "def printPac(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    encTicketPart = decoder.decode(data, asn1Spec=EncTicketPart())[0]\n    adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n    pacType = PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if logging.getLogger().level == logging.DEBUG:\n            print('TYPE 0x%x' % infoBuffer['ulType'])\n        if infoBuffer['ulType'] == 1:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            kerbdata.dump()\n            print()\n            print('Domain SID:', kerbdata['LogonDomainId'].formatCanonical())\n            print()\n        elif infoBuffer['ulType'] == PAC_CLIENT_INFO_TYPE:\n            clientInfo = PAC_CLIENT_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                clientInfo.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_SERVER_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_PRIVSVR_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_UPN_DNS_INFO:\n            upn = UPN_DNS_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                upn.dump()\n                print(data[upn['DnsDomainNameOffset']:])\n                print()\n        else:\n            hexdump(data)\n        if logging.getLogger().level == logging.DEBUG:\n            print('#' * 80)\n        buff = buff[len(infoBuffer):]",
            "def printPac(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    encTicketPart = decoder.decode(data, asn1Spec=EncTicketPart())[0]\n    adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n    pacType = PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if logging.getLogger().level == logging.DEBUG:\n            print('TYPE 0x%x' % infoBuffer['ulType'])\n        if infoBuffer['ulType'] == 1:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            kerbdata.dump()\n            print()\n            print('Domain SID:', kerbdata['LogonDomainId'].formatCanonical())\n            print()\n        elif infoBuffer['ulType'] == PAC_CLIENT_INFO_TYPE:\n            clientInfo = PAC_CLIENT_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                clientInfo.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_SERVER_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_PRIVSVR_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_UPN_DNS_INFO:\n            upn = UPN_DNS_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                upn.dump()\n                print(data[upn['DnsDomainNameOffset']:])\n                print()\n        else:\n            hexdump(data)\n        if logging.getLogger().level == logging.DEBUG:\n            print('#' * 80)\n        buff = buff[len(infoBuffer):]",
            "def printPac(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    encTicketPart = decoder.decode(data, asn1Spec=EncTicketPart())[0]\n    adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n    pacType = PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if logging.getLogger().level == logging.DEBUG:\n            print('TYPE 0x%x' % infoBuffer['ulType'])\n        if infoBuffer['ulType'] == 1:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            kerbdata.dump()\n            print()\n            print('Domain SID:', kerbdata['LogonDomainId'].formatCanonical())\n            print()\n        elif infoBuffer['ulType'] == PAC_CLIENT_INFO_TYPE:\n            clientInfo = PAC_CLIENT_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                clientInfo.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_SERVER_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_PRIVSVR_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_UPN_DNS_INFO:\n            upn = UPN_DNS_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                upn.dump()\n                print(data[upn['DnsDomainNameOffset']:])\n                print()\n        else:\n            hexdump(data)\n        if logging.getLogger().level == logging.DEBUG:\n            print('#' * 80)\n        buff = buff[len(infoBuffer):]",
            "def printPac(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    encTicketPart = decoder.decode(data, asn1Spec=EncTicketPart())[0]\n    adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n    pacType = PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if logging.getLogger().level == logging.DEBUG:\n            print('TYPE 0x%x' % infoBuffer['ulType'])\n        if infoBuffer['ulType'] == 1:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            kerbdata.dump()\n            print()\n            print('Domain SID:', kerbdata['LogonDomainId'].formatCanonical())\n            print()\n        elif infoBuffer['ulType'] == PAC_CLIENT_INFO_TYPE:\n            clientInfo = PAC_CLIENT_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                clientInfo.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_SERVER_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_PRIVSVR_CHECKSUM:\n            signatureData = PAC_SIGNATURE_DATA(data)\n            if logging.getLogger().level == logging.DEBUG:\n                signatureData.dump()\n                print()\n        elif infoBuffer['ulType'] == PAC_UPN_DNS_INFO:\n            upn = UPN_DNS_INFO(data)\n            if logging.getLogger().level == logging.DEBUG:\n                upn.dump()\n                print(data[upn['DnsDomainNameOffset']:])\n                print()\n        else:\n            hexdump(data)\n        if logging.getLogger().level == logging.DEBUG:\n            print('#' * 80)\n        buff = buff[len(infoBuffer):]"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, behalfUser, username='', password='', domain='', hashes=None):\n    self.__username = username\n    self.__password = password\n    self.__domain = domain.upper()\n    self.__behalfUser = behalfUser\n    self.__lmhash = ''\n    self.__nthash = ''\n    if hashes is not None:\n        (self.__lmhash, self.__nthash) = hashes.split(':')",
        "mutated": [
            "def __init__(self, behalfUser, username='', password='', domain='', hashes=None):\n    if False:\n        i = 10\n    self.__username = username\n    self.__password = password\n    self.__domain = domain.upper()\n    self.__behalfUser = behalfUser\n    self.__lmhash = ''\n    self.__nthash = ''\n    if hashes is not None:\n        (self.__lmhash, self.__nthash) = hashes.split(':')",
            "def __init__(self, behalfUser, username='', password='', domain='', hashes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__username = username\n    self.__password = password\n    self.__domain = domain.upper()\n    self.__behalfUser = behalfUser\n    self.__lmhash = ''\n    self.__nthash = ''\n    if hashes is not None:\n        (self.__lmhash, self.__nthash) = hashes.split(':')",
            "def __init__(self, behalfUser, username='', password='', domain='', hashes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__username = username\n    self.__password = password\n    self.__domain = domain.upper()\n    self.__behalfUser = behalfUser\n    self.__lmhash = ''\n    self.__nthash = ''\n    if hashes is not None:\n        (self.__lmhash, self.__nthash) = hashes.split(':')",
            "def __init__(self, behalfUser, username='', password='', domain='', hashes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__username = username\n    self.__password = password\n    self.__domain = domain.upper()\n    self.__behalfUser = behalfUser\n    self.__lmhash = ''\n    self.__nthash = ''\n    if hashes is not None:\n        (self.__lmhash, self.__nthash) = hashes.split(':')",
            "def __init__(self, behalfUser, username='', password='', domain='', hashes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__username = username\n    self.__password = password\n    self.__domain = domain.upper()\n    self.__behalfUser = behalfUser\n    self.__lmhash = ''\n    self.__nthash = ''\n    if hashes is not None:\n        (self.__lmhash, self.__nthash) = hashes.split(':')"
        ]
    },
    {
        "func_name": "dump",
        "original": "def dump(self):\n    userName = Principal(self.__username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash))\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__behalfUser, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__behalfUser) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__username, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, None)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    cipherText = tgs['ticket']['enc-part']['cipher']\n    newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n    if self.__nthash != '' and (isinstance(self.__nthash, bytes) and self.__nthash != b''):\n        key = Key(newCipher.enctype, unhexlify(self.__nthash))\n    elif newCipher.enctype == Enctype.RC4:\n        key = newCipher.string_to_key(password, '', None)\n    else:\n        key = newCipher.string_to_key(password, self.__domain.upper() + self.__username, None)\n    try:\n        plainText = newCipher.decrypt(key, 2, str(cipherText))\n    except:\n        plainText = cipher.decrypt(sessionKey, 2, cipherText)\n    self.printPac(plainText)",
        "mutated": [
            "def dump(self):\n    if False:\n        i = 10\n    userName = Principal(self.__username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash))\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__behalfUser, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__behalfUser) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__username, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, None)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    cipherText = tgs['ticket']['enc-part']['cipher']\n    newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n    if self.__nthash != '' and (isinstance(self.__nthash, bytes) and self.__nthash != b''):\n        key = Key(newCipher.enctype, unhexlify(self.__nthash))\n    elif newCipher.enctype == Enctype.RC4:\n        key = newCipher.string_to_key(password, '', None)\n    else:\n        key = newCipher.string_to_key(password, self.__domain.upper() + self.__username, None)\n    try:\n        plainText = newCipher.decrypt(key, 2, str(cipherText))\n    except:\n        plainText = cipher.decrypt(sessionKey, 2, cipherText)\n    self.printPac(plainText)",
            "def dump(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    userName = Principal(self.__username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash))\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__behalfUser, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__behalfUser) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__username, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, None)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    cipherText = tgs['ticket']['enc-part']['cipher']\n    newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n    if self.__nthash != '' and (isinstance(self.__nthash, bytes) and self.__nthash != b''):\n        key = Key(newCipher.enctype, unhexlify(self.__nthash))\n    elif newCipher.enctype == Enctype.RC4:\n        key = newCipher.string_to_key(password, '', None)\n    else:\n        key = newCipher.string_to_key(password, self.__domain.upper() + self.__username, None)\n    try:\n        plainText = newCipher.decrypt(key, 2, str(cipherText))\n    except:\n        plainText = cipher.decrypt(sessionKey, 2, cipherText)\n    self.printPac(plainText)",
            "def dump(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    userName = Principal(self.__username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash))\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__behalfUser, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__behalfUser) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__username, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, None)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    cipherText = tgs['ticket']['enc-part']['cipher']\n    newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n    if self.__nthash != '' and (isinstance(self.__nthash, bytes) and self.__nthash != b''):\n        key = Key(newCipher.enctype, unhexlify(self.__nthash))\n    elif newCipher.enctype == Enctype.RC4:\n        key = newCipher.string_to_key(password, '', None)\n    else:\n        key = newCipher.string_to_key(password, self.__domain.upper() + self.__username, None)\n    try:\n        plainText = newCipher.decrypt(key, 2, str(cipherText))\n    except:\n        plainText = cipher.decrypt(sessionKey, 2, cipherText)\n    self.printPac(plainText)",
            "def dump(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    userName = Principal(self.__username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash))\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__behalfUser, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__behalfUser) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__username, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, None)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    cipherText = tgs['ticket']['enc-part']['cipher']\n    newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n    if self.__nthash != '' and (isinstance(self.__nthash, bytes) and self.__nthash != b''):\n        key = Key(newCipher.enctype, unhexlify(self.__nthash))\n    elif newCipher.enctype == Enctype.RC4:\n        key = newCipher.string_to_key(password, '', None)\n    else:\n        key = newCipher.string_to_key(password, self.__domain.upper() + self.__username, None)\n    try:\n        plainText = newCipher.decrypt(key, 2, str(cipherText))\n    except:\n        plainText = cipher.decrypt(sessionKey, 2, cipherText)\n    self.printPac(plainText)",
            "def dump(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    userName = Principal(self.__username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(self.__lmhash), unhexlify(self.__nthash))\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__behalfUser, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__behalfUser) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__username, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    myTicket = ticket.to_asn1(TicketAsn1())\n    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, None)\n    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('TGS_REP')\n        print(tgs.prettyPrint())\n    cipherText = tgs['ticket']['enc-part']['cipher']\n    newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]\n    if self.__nthash != '' and (isinstance(self.__nthash, bytes) and self.__nthash != b''):\n        key = Key(newCipher.enctype, unhexlify(self.__nthash))\n    elif newCipher.enctype == Enctype.RC4:\n        key = newCipher.string_to_key(password, '', None)\n    else:\n        key = newCipher.string_to_key(password, self.__domain.upper() + self.__username, None)\n    try:\n        plainText = newCipher.decrypt(key, 2, str(cipherText))\n    except:\n        plainText = cipher.decrypt(sessionKey, 2, cipherText)\n    self.printPac(plainText)"
        ]
    }
]