[
    {
        "func_name": "set_r2decompiler",
        "original": "@pwndbg.gdblib.config.trigger(r2decompiler)\ndef set_r2decompiler() -> None:\n    if r2decompiler.value in ['radare2', 'rizin']:\n        return\n    print(message.warn(f'Invalid r2decompiler: `{r2decompiler.value}`, please select from radare2 or rizin'))\n    r2decompiler.revert_default()",
        "mutated": [
            "@pwndbg.gdblib.config.trigger(r2decompiler)\ndef set_r2decompiler() -> None:\n    if False:\n        i = 10\n    if r2decompiler.value in ['radare2', 'rizin']:\n        return\n    print(message.warn(f'Invalid r2decompiler: `{r2decompiler.value}`, please select from radare2 or rizin'))\n    r2decompiler.revert_default()",
            "@pwndbg.gdblib.config.trigger(r2decompiler)\ndef set_r2decompiler() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if r2decompiler.value in ['radare2', 'rizin']:\n        return\n    print(message.warn(f'Invalid r2decompiler: `{r2decompiler.value}`, please select from radare2 or rizin'))\n    r2decompiler.revert_default()",
            "@pwndbg.gdblib.config.trigger(r2decompiler)\ndef set_r2decompiler() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if r2decompiler.value in ['radare2', 'rizin']:\n        return\n    print(message.warn(f'Invalid r2decompiler: `{r2decompiler.value}`, please select from radare2 or rizin'))\n    r2decompiler.revert_default()",
            "@pwndbg.gdblib.config.trigger(r2decompiler)\ndef set_r2decompiler() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if r2decompiler.value in ['radare2', 'rizin']:\n        return\n    print(message.warn(f'Invalid r2decompiler: `{r2decompiler.value}`, please select from radare2 or rizin'))\n    r2decompiler.revert_default()",
            "@pwndbg.gdblib.config.trigger(r2decompiler)\ndef set_r2decompiler() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if r2decompiler.value in ['radare2', 'rizin']:\n        return\n    print(message.warn(f'Invalid r2decompiler: `{r2decompiler.value}`, please select from radare2 or rizin'))\n    r2decompiler.revert_default()"
        ]
    },
    {
        "func_name": "decompile",
        "original": "def decompile(func=None):\n    \"\"\"\n    Return the source of the given function decompiled by ghidra.\n\n    If no function is given, decompile the function within the current pc.\n    This function requires radare2, r2pipe and r2ghidra, or their related rizin counterparts.\n\n    Raises Exception if any fatal error occurs.\n    \"\"\"\n    try:\n        if r2decompiler == 'radare2':\n            r2 = pwndbg.radare2.r2pipe()\n            if 'pdg' not in r2.cmd('LD').split('\\n'):\n                raise Exception('radare2 plugin r2ghidra must be installed and available from r2')\n        elif r2decompiler == 'rizin':\n            r2 = pwndbg.rizin.rzpipe()\n            if 'ghidra' not in r2.cmd('Lc'):\n                raise Exception('rizin plugin rzghidra must be installed and available from rz')\n        else:\n            raise Exception(f'{r2decompiler} not support. Plz select from (radare2/rizin)')\n    except ImportError:\n        raise Exception('r2pipe or rzpipe not available, but required for r2/rz->ghidra bridge')\n    if not func:\n        func = hex(pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]) if pwndbg.gdblib.proc.alive else 'main'\n    src = r2.cmdj('pdgj @ ' + func)\n    if not src:\n        raise Exception(f\"Decompile command failed, check if '{func}' is a valid target\")\n    current_line_marker = '/*%%PWNDBG_CODE_MARKER%%*/'\n    source = src.get('code', '')\n    if pwndbg.gdblib.proc.alive:\n        pc = pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]\n        closest = 0\n        for off in (a.get('offset', 0) for a in src.get('annotations', [])):\n            if abs(pc - closest) > abs(pc - off):\n                closest = off\n        pos_annotations = sorted([a for a in src.get('annotations', []) if a.get('offset') == closest], key=lambda a: a['start'])\n        if pos_annotations:\n            curline = source.count('\\n', 0, pos_annotations[0]['start'])\n            source = source.split('\\n')\n            line = source[curline]\n            if line.startswith('    '):\n                line = line[min(4, len(pwndbg.gdblib.config.code_prefix) + 1):]\n            source[curline] = current_line_marker + ' ' + line\n            source = '\\n'.join(source)\n    if pwndbg.gdblib.config.syntax_highlight:\n        src_filename = pwndbg.gdblib.symbol.selected_frame_source_absolute_filename()\n        if not src_filename:\n            filename = gdb.current_progspace().filename\n            src_filename = filename + '.c' if os.path.basename(filename).find('.') < 0 else filename\n        source = H.syntax_highlight(source, src_filename)\n    source = source.replace(current_line_marker, C.prefix(pwndbg.gdblib.config.code_prefix), 1)\n    return source",
        "mutated": [
            "def decompile(func=None):\n    if False:\n        i = 10\n    '\\n    Return the source of the given function decompiled by ghidra.\\n\\n    If no function is given, decompile the function within the current pc.\\n    This function requires radare2, r2pipe and r2ghidra, or their related rizin counterparts.\\n\\n    Raises Exception if any fatal error occurs.\\n    '\n    try:\n        if r2decompiler == 'radare2':\n            r2 = pwndbg.radare2.r2pipe()\n            if 'pdg' not in r2.cmd('LD').split('\\n'):\n                raise Exception('radare2 plugin r2ghidra must be installed and available from r2')\n        elif r2decompiler == 'rizin':\n            r2 = pwndbg.rizin.rzpipe()\n            if 'ghidra' not in r2.cmd('Lc'):\n                raise Exception('rizin plugin rzghidra must be installed and available from rz')\n        else:\n            raise Exception(f'{r2decompiler} not support. Plz select from (radare2/rizin)')\n    except ImportError:\n        raise Exception('r2pipe or rzpipe not available, but required for r2/rz->ghidra bridge')\n    if not func:\n        func = hex(pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]) if pwndbg.gdblib.proc.alive else 'main'\n    src = r2.cmdj('pdgj @ ' + func)\n    if not src:\n        raise Exception(f\"Decompile command failed, check if '{func}' is a valid target\")\n    current_line_marker = '/*%%PWNDBG_CODE_MARKER%%*/'\n    source = src.get('code', '')\n    if pwndbg.gdblib.proc.alive:\n        pc = pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]\n        closest = 0\n        for off in (a.get('offset', 0) for a in src.get('annotations', [])):\n            if abs(pc - closest) > abs(pc - off):\n                closest = off\n        pos_annotations = sorted([a for a in src.get('annotations', []) if a.get('offset') == closest], key=lambda a: a['start'])\n        if pos_annotations:\n            curline = source.count('\\n', 0, pos_annotations[0]['start'])\n            source = source.split('\\n')\n            line = source[curline]\n            if line.startswith('    '):\n                line = line[min(4, len(pwndbg.gdblib.config.code_prefix) + 1):]\n            source[curline] = current_line_marker + ' ' + line\n            source = '\\n'.join(source)\n    if pwndbg.gdblib.config.syntax_highlight:\n        src_filename = pwndbg.gdblib.symbol.selected_frame_source_absolute_filename()\n        if not src_filename:\n            filename = gdb.current_progspace().filename\n            src_filename = filename + '.c' if os.path.basename(filename).find('.') < 0 else filename\n        source = H.syntax_highlight(source, src_filename)\n    source = source.replace(current_line_marker, C.prefix(pwndbg.gdblib.config.code_prefix), 1)\n    return source",
            "def decompile(func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return the source of the given function decompiled by ghidra.\\n\\n    If no function is given, decompile the function within the current pc.\\n    This function requires radare2, r2pipe and r2ghidra, or their related rizin counterparts.\\n\\n    Raises Exception if any fatal error occurs.\\n    '\n    try:\n        if r2decompiler == 'radare2':\n            r2 = pwndbg.radare2.r2pipe()\n            if 'pdg' not in r2.cmd('LD').split('\\n'):\n                raise Exception('radare2 plugin r2ghidra must be installed and available from r2')\n        elif r2decompiler == 'rizin':\n            r2 = pwndbg.rizin.rzpipe()\n            if 'ghidra' not in r2.cmd('Lc'):\n                raise Exception('rizin plugin rzghidra must be installed and available from rz')\n        else:\n            raise Exception(f'{r2decompiler} not support. Plz select from (radare2/rizin)')\n    except ImportError:\n        raise Exception('r2pipe or rzpipe not available, but required for r2/rz->ghidra bridge')\n    if not func:\n        func = hex(pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]) if pwndbg.gdblib.proc.alive else 'main'\n    src = r2.cmdj('pdgj @ ' + func)\n    if not src:\n        raise Exception(f\"Decompile command failed, check if '{func}' is a valid target\")\n    current_line_marker = '/*%%PWNDBG_CODE_MARKER%%*/'\n    source = src.get('code', '')\n    if pwndbg.gdblib.proc.alive:\n        pc = pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]\n        closest = 0\n        for off in (a.get('offset', 0) for a in src.get('annotations', [])):\n            if abs(pc - closest) > abs(pc - off):\n                closest = off\n        pos_annotations = sorted([a for a in src.get('annotations', []) if a.get('offset') == closest], key=lambda a: a['start'])\n        if pos_annotations:\n            curline = source.count('\\n', 0, pos_annotations[0]['start'])\n            source = source.split('\\n')\n            line = source[curline]\n            if line.startswith('    '):\n                line = line[min(4, len(pwndbg.gdblib.config.code_prefix) + 1):]\n            source[curline] = current_line_marker + ' ' + line\n            source = '\\n'.join(source)\n    if pwndbg.gdblib.config.syntax_highlight:\n        src_filename = pwndbg.gdblib.symbol.selected_frame_source_absolute_filename()\n        if not src_filename:\n            filename = gdb.current_progspace().filename\n            src_filename = filename + '.c' if os.path.basename(filename).find('.') < 0 else filename\n        source = H.syntax_highlight(source, src_filename)\n    source = source.replace(current_line_marker, C.prefix(pwndbg.gdblib.config.code_prefix), 1)\n    return source",
            "def decompile(func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return the source of the given function decompiled by ghidra.\\n\\n    If no function is given, decompile the function within the current pc.\\n    This function requires radare2, r2pipe and r2ghidra, or their related rizin counterparts.\\n\\n    Raises Exception if any fatal error occurs.\\n    '\n    try:\n        if r2decompiler == 'radare2':\n            r2 = pwndbg.radare2.r2pipe()\n            if 'pdg' not in r2.cmd('LD').split('\\n'):\n                raise Exception('radare2 plugin r2ghidra must be installed and available from r2')\n        elif r2decompiler == 'rizin':\n            r2 = pwndbg.rizin.rzpipe()\n            if 'ghidra' not in r2.cmd('Lc'):\n                raise Exception('rizin plugin rzghidra must be installed and available from rz')\n        else:\n            raise Exception(f'{r2decompiler} not support. Plz select from (radare2/rizin)')\n    except ImportError:\n        raise Exception('r2pipe or rzpipe not available, but required for r2/rz->ghidra bridge')\n    if not func:\n        func = hex(pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]) if pwndbg.gdblib.proc.alive else 'main'\n    src = r2.cmdj('pdgj @ ' + func)\n    if not src:\n        raise Exception(f\"Decompile command failed, check if '{func}' is a valid target\")\n    current_line_marker = '/*%%PWNDBG_CODE_MARKER%%*/'\n    source = src.get('code', '')\n    if pwndbg.gdblib.proc.alive:\n        pc = pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]\n        closest = 0\n        for off in (a.get('offset', 0) for a in src.get('annotations', [])):\n            if abs(pc - closest) > abs(pc - off):\n                closest = off\n        pos_annotations = sorted([a for a in src.get('annotations', []) if a.get('offset') == closest], key=lambda a: a['start'])\n        if pos_annotations:\n            curline = source.count('\\n', 0, pos_annotations[0]['start'])\n            source = source.split('\\n')\n            line = source[curline]\n            if line.startswith('    '):\n                line = line[min(4, len(pwndbg.gdblib.config.code_prefix) + 1):]\n            source[curline] = current_line_marker + ' ' + line\n            source = '\\n'.join(source)\n    if pwndbg.gdblib.config.syntax_highlight:\n        src_filename = pwndbg.gdblib.symbol.selected_frame_source_absolute_filename()\n        if not src_filename:\n            filename = gdb.current_progspace().filename\n            src_filename = filename + '.c' if os.path.basename(filename).find('.') < 0 else filename\n        source = H.syntax_highlight(source, src_filename)\n    source = source.replace(current_line_marker, C.prefix(pwndbg.gdblib.config.code_prefix), 1)\n    return source",
            "def decompile(func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return the source of the given function decompiled by ghidra.\\n\\n    If no function is given, decompile the function within the current pc.\\n    This function requires radare2, r2pipe and r2ghidra, or their related rizin counterparts.\\n\\n    Raises Exception if any fatal error occurs.\\n    '\n    try:\n        if r2decompiler == 'radare2':\n            r2 = pwndbg.radare2.r2pipe()\n            if 'pdg' not in r2.cmd('LD').split('\\n'):\n                raise Exception('radare2 plugin r2ghidra must be installed and available from r2')\n        elif r2decompiler == 'rizin':\n            r2 = pwndbg.rizin.rzpipe()\n            if 'ghidra' not in r2.cmd('Lc'):\n                raise Exception('rizin plugin rzghidra must be installed and available from rz')\n        else:\n            raise Exception(f'{r2decompiler} not support. Plz select from (radare2/rizin)')\n    except ImportError:\n        raise Exception('r2pipe or rzpipe not available, but required for r2/rz->ghidra bridge')\n    if not func:\n        func = hex(pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]) if pwndbg.gdblib.proc.alive else 'main'\n    src = r2.cmdj('pdgj @ ' + func)\n    if not src:\n        raise Exception(f\"Decompile command failed, check if '{func}' is a valid target\")\n    current_line_marker = '/*%%PWNDBG_CODE_MARKER%%*/'\n    source = src.get('code', '')\n    if pwndbg.gdblib.proc.alive:\n        pc = pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]\n        closest = 0\n        for off in (a.get('offset', 0) for a in src.get('annotations', [])):\n            if abs(pc - closest) > abs(pc - off):\n                closest = off\n        pos_annotations = sorted([a for a in src.get('annotations', []) if a.get('offset') == closest], key=lambda a: a['start'])\n        if pos_annotations:\n            curline = source.count('\\n', 0, pos_annotations[0]['start'])\n            source = source.split('\\n')\n            line = source[curline]\n            if line.startswith('    '):\n                line = line[min(4, len(pwndbg.gdblib.config.code_prefix) + 1):]\n            source[curline] = current_line_marker + ' ' + line\n            source = '\\n'.join(source)\n    if pwndbg.gdblib.config.syntax_highlight:\n        src_filename = pwndbg.gdblib.symbol.selected_frame_source_absolute_filename()\n        if not src_filename:\n            filename = gdb.current_progspace().filename\n            src_filename = filename + '.c' if os.path.basename(filename).find('.') < 0 else filename\n        source = H.syntax_highlight(source, src_filename)\n    source = source.replace(current_line_marker, C.prefix(pwndbg.gdblib.config.code_prefix), 1)\n    return source",
            "def decompile(func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return the source of the given function decompiled by ghidra.\\n\\n    If no function is given, decompile the function within the current pc.\\n    This function requires radare2, r2pipe and r2ghidra, or their related rizin counterparts.\\n\\n    Raises Exception if any fatal error occurs.\\n    '\n    try:\n        if r2decompiler == 'radare2':\n            r2 = pwndbg.radare2.r2pipe()\n            if 'pdg' not in r2.cmd('LD').split('\\n'):\n                raise Exception('radare2 plugin r2ghidra must be installed and available from r2')\n        elif r2decompiler == 'rizin':\n            r2 = pwndbg.rizin.rzpipe()\n            if 'ghidra' not in r2.cmd('Lc'):\n                raise Exception('rizin plugin rzghidra must be installed and available from rz')\n        else:\n            raise Exception(f'{r2decompiler} not support. Plz select from (radare2/rizin)')\n    except ImportError:\n        raise Exception('r2pipe or rzpipe not available, but required for r2/rz->ghidra bridge')\n    if not func:\n        func = hex(pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]) if pwndbg.gdblib.proc.alive else 'main'\n    src = r2.cmdj('pdgj @ ' + func)\n    if not src:\n        raise Exception(f\"Decompile command failed, check if '{func}' is a valid target\")\n    current_line_marker = '/*%%PWNDBG_CODE_MARKER%%*/'\n    source = src.get('code', '')\n    if pwndbg.gdblib.proc.alive:\n        pc = pwndbg.gdblib.regs[pwndbg.gdblib.regs.current.pc]\n        closest = 0\n        for off in (a.get('offset', 0) for a in src.get('annotations', [])):\n            if abs(pc - closest) > abs(pc - off):\n                closest = off\n        pos_annotations = sorted([a for a in src.get('annotations', []) if a.get('offset') == closest], key=lambda a: a['start'])\n        if pos_annotations:\n            curline = source.count('\\n', 0, pos_annotations[0]['start'])\n            source = source.split('\\n')\n            line = source[curline]\n            if line.startswith('    '):\n                line = line[min(4, len(pwndbg.gdblib.config.code_prefix) + 1):]\n            source[curline] = current_line_marker + ' ' + line\n            source = '\\n'.join(source)\n    if pwndbg.gdblib.config.syntax_highlight:\n        src_filename = pwndbg.gdblib.symbol.selected_frame_source_absolute_filename()\n        if not src_filename:\n            filename = gdb.current_progspace().filename\n            src_filename = filename + '.c' if os.path.basename(filename).find('.') < 0 else filename\n        source = H.syntax_highlight(source, src_filename)\n    source = source.replace(current_line_marker, C.prefix(pwndbg.gdblib.config.code_prefix), 1)\n    return source"
        ]
    }
]