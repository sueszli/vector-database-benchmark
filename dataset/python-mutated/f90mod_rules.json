[
    {
        "func_name": "findf90modules",
        "original": "def findf90modules(m):\n    if ismodule(m):\n        return [m]\n    if not hasbody(m):\n        return []\n    ret = []\n    for b in m['body']:\n        if ismodule(b):\n            ret.append(b)\n        else:\n            ret = ret + findf90modules(b)\n    return ret",
        "mutated": [
            "def findf90modules(m):\n    if False:\n        i = 10\n    if ismodule(m):\n        return [m]\n    if not hasbody(m):\n        return []\n    ret = []\n    for b in m['body']:\n        if ismodule(b):\n            ret.append(b)\n        else:\n            ret = ret + findf90modules(b)\n    return ret",
            "def findf90modules(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if ismodule(m):\n        return [m]\n    if not hasbody(m):\n        return []\n    ret = []\n    for b in m['body']:\n        if ismodule(b):\n            ret.append(b)\n        else:\n            ret = ret + findf90modules(b)\n    return ret",
            "def findf90modules(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if ismodule(m):\n        return [m]\n    if not hasbody(m):\n        return []\n    ret = []\n    for b in m['body']:\n        if ismodule(b):\n            ret.append(b)\n        else:\n            ret = ret + findf90modules(b)\n    return ret",
            "def findf90modules(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if ismodule(m):\n        return [m]\n    if not hasbody(m):\n        return []\n    ret = []\n    for b in m['body']:\n        if ismodule(b):\n            ret.append(b)\n        else:\n            ret = ret + findf90modules(b)\n    return ret",
            "def findf90modules(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if ismodule(m):\n        return [m]\n    if not hasbody(m):\n        return []\n    ret = []\n    for b in m['body']:\n        if ismodule(b):\n            ret.append(b)\n        else:\n            ret = ret + findf90modules(b)\n    return ret"
        ]
    },
    {
        "func_name": "fadd",
        "original": "def fadd(line, s=fhooks):\n    s[0] = '%s\\n      %s' % (s[0], line)",
        "mutated": [
            "def fadd(line, s=fhooks):\n    if False:\n        i = 10\n    s[0] = '%s\\n      %s' % (s[0], line)",
            "def fadd(line, s=fhooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s[0] = '%s\\n      %s' % (s[0], line)",
            "def fadd(line, s=fhooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s[0] = '%s\\n      %s' % (s[0], line)",
            "def fadd(line, s=fhooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s[0] = '%s\\n      %s' % (s[0], line)",
            "def fadd(line, s=fhooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s[0] = '%s\\n      %s' % (s[0], line)"
        ]
    },
    {
        "func_name": "dadd",
        "original": "def dadd(line, s=doc):\n    s[0] = '%s\\n%s' % (s[0], line)",
        "mutated": [
            "def dadd(line, s=doc):\n    if False:\n        i = 10\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def dadd(line, s=doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def dadd(line, s=doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def dadd(line, s=doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def dadd(line, s=doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s[0] = '%s\\n%s' % (s[0], line)"
        ]
    },
    {
        "func_name": "cadd",
        "original": "def cadd(line, s=chooks):\n    s[0] = '%s\\n%s' % (s[0], line)",
        "mutated": [
            "def cadd(line, s=chooks):\n    if False:\n        i = 10\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def cadd(line, s=chooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def cadd(line, s=chooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def cadd(line, s=chooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def cadd(line, s=chooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s[0] = '%s\\n%s' % (s[0], line)"
        ]
    },
    {
        "func_name": "iadd",
        "original": "def iadd(line, s=ihooks):\n    s[0] = '%s\\n%s' % (s[0], line)",
        "mutated": [
            "def iadd(line, s=ihooks):\n    if False:\n        i = 10\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def iadd(line, s=ihooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def iadd(line, s=ihooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def iadd(line, s=ihooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s[0] = '%s\\n%s' % (s[0], line)",
            "def iadd(line, s=ihooks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s[0] = '%s\\n%s' % (s[0], line)"
        ]
    },
    {
        "func_name": "buildhooks",
        "original": "def buildhooks(pymod):\n    from . import rules\n    ret = {'f90modhooks': [], 'initf90modhooks': [], 'body': [], 'need': ['F_FUNC', 'arrayobject.h'], 'separatorsfor': {'includes0': '\\n', 'includes': '\\n'}, 'docs': ['\"Fortran 90/95 modules:\\\\n\"'], 'latexdoc': []}\n    fhooks = ['']\n\n    def fadd(line, s=fhooks):\n        s[0] = '%s\\n      %s' % (s[0], line)\n    doc = ['']\n\n    def dadd(line, s=doc):\n        s[0] = '%s\\n%s' % (s[0], line)\n    for m in findf90modules(pymod):\n        (sargs, fargs, efargs, modobjs, notvars, onlyvars) = ([], [], [], [], [m['name']], [])\n        sargsp = []\n        ifargs = []\n        mfargs = []\n        if hasbody(m):\n            for b in m['body']:\n                notvars.append(b['name'])\n        for n in m['vars'].keys():\n            var = m['vars'][n]\n            if n not in notvars and (not l_or(isintent_hide, isprivate)(var)):\n                onlyvars.append(n)\n                mfargs.append(n)\n        outmess('\\t\\tConstructing F90 module support for \"%s\"...\\n' % m['name'])\n        if onlyvars:\n            outmess('\\t\\t  Variables: %s\\n' % ' '.join(onlyvars))\n        chooks = ['']\n\n        def cadd(line, s=chooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        ihooks = ['']\n\n        def iadd(line, s=ihooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        vrd = capi_maps.modsign2map(m)\n        cadd('static FortranDataDef f2py_%s_def[] = {' % m['name'])\n        dadd('\\\\subsection{Fortran 90/95 module \\\\texttt{%s}}\\n' % m['name'])\n        if hasnote(m):\n            note = m['note']\n            if isinstance(note, list):\n                note = '\\n'.join(note)\n            dadd(note)\n        if onlyvars:\n            dadd('\\\\begin{description}')\n        for n in onlyvars:\n            var = m['vars'][n]\n            modobjs.append(n)\n            ct = capi_maps.getctype(var)\n            at = capi_maps.c2capi_map[ct]\n            dm = capi_maps.getarrdims(n, var)\n            dms = dm['dims'].replace('*', '-1').strip()\n            dms = dms.replace(':', '-1').strip()\n            if not dms:\n                dms = '-1'\n            use_fgetdims2 = fgetdims2\n            cadd('\\t{\"%s\",%s,{{%s}},%s, %s},' % (undo_rmbadname1(n), dm['rank'], dms, at, capi_maps.get_elsize(var)))\n            dadd('\\\\item[]{{}\\\\verb@%s@{}}' % capi_maps.getarrdocsign(n, var))\n            if hasnote(var):\n                note = var['note']\n                if isinstance(note, list):\n                    note = '\\n'.join(note)\n                dadd('--- %s' % note)\n            if isallocatable(var):\n                fargs.append('f2py_%s_getdims_%s' % (m['name'], n))\n                efargs.append(fargs[-1])\n                sargs.append('void (*%s)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)' % n)\n                sargsp.append('void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)')\n                iadd('\\tf2py_%s_def[i_f2py++].func = %s;' % (m['name'], n))\n                fadd('subroutine %s(r,s,f2pysetdata,flag)' % fargs[-1])\n                fadd('use %s, only: d => %s\\n' % (m['name'], undo_rmbadname1(n)))\n                fadd('integer flag\\n')\n                fhooks[0] = fhooks[0] + fgetdims1\n                dms = range(1, int(dm['rank']) + 1)\n                fadd(' allocate(d(%s))\\n' % ','.join(['s(%s)' % i for i in dms]))\n                fhooks[0] = fhooks[0] + use_fgetdims2\n                fadd('end subroutine %s' % fargs[-1])\n            else:\n                fargs.append(n)\n                sargs.append('char *%s' % n)\n                sargsp.append('char*')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], n))\n        if onlyvars:\n            dadd('\\\\end{description}')\n        if hasbody(m):\n            for b in m['body']:\n                if not isroutine(b):\n                    outmess(f\"f90mod_rules.buildhooks: skipping {b['block']} {b['name']}\\n\")\n                    continue\n                modobjs.append('%s()' % b['name'])\n                b['modulename'] = m['name']\n                (api, wrap) = rules.buildapi(b)\n                if isfunction(b):\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createfuncwrapper(b, signature=1))\n                elif wrap:\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createsubrwrapper(b, signature=1))\n                else:\n                    fargs.append(b['name'])\n                    mfargs.append(fargs[-1])\n                api['externroutines'] = []\n                ar = applyrules(api, vrd)\n                ar['docs'] = []\n                ar['docshort'] = []\n                ret = dictappend(ret, ar)\n                cadd('\\t{\"%s\",-1,{{-1}},0,0,NULL,(void *)f2py_rout_#modulename#_%s_%s,doc_f2py_rout_#modulename#_%s_%s},' % (b['name'], m['name'], b['name'], m['name'], b['name']))\n                sargs.append('char *%s' % b['name'])\n                sargsp.append('char *')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], b['name']))\n        cadd('\\t{NULL}\\n};\\n')\n        iadd('}')\n        ihooks[0] = 'static void f2py_setup_%s(%s) {\\n\\tint i_f2py=0;%s' % (m['name'], ','.join(sargs), ihooks[0])\n        if '_' in m['name']:\n            F_FUNC = 'F_FUNC_US'\n        else:\n            F_FUNC = 'F_FUNC'\n        iadd('extern void %s(f2pyinit%s,F2PYINIT%s)(void (*)(%s));' % (F_FUNC, m['name'], m['name'].upper(), ','.join(sargsp)))\n        iadd('static void f2py_init_%s(void) {' % m['name'])\n        iadd('\\t%s(f2pyinit%s,F2PYINIT%s)(f2py_setup_%s);' % (F_FUNC, m['name'], m['name'].upper(), m['name']))\n        iadd('}\\n')\n        ret['f90modhooks'] = ret['f90modhooks'] + chooks + ihooks\n        ret['initf90modhooks'] = ['\\tPyDict_SetItemString(d, \"%s\", PyFortranObject_New(f2py_%s_def,f2py_init_%s));' % (m['name'], m['name'], m['name'])] + ret['initf90modhooks']\n        fadd('')\n        fadd('subroutine f2pyinit%s(f2pysetupfunc)' % m['name'])\n        if mfargs:\n            for a in undo_rmbadname(mfargs):\n                fadd('use %s, only : %s' % (m['name'], a))\n        if ifargs:\n            fadd(' '.join(['interface'] + ifargs))\n            fadd('end interface')\n        fadd('external f2pysetupfunc')\n        if efargs:\n            for a in undo_rmbadname(efargs):\n                fadd('external %s' % a)\n        fadd('call f2pysetupfunc(%s)' % ','.join(undo_rmbadname(fargs)))\n        fadd('end subroutine f2pyinit%s\\n' % m['name'])\n        dadd('\\n'.join(ret['latexdoc']).replace('\\\\subsection{', '\\\\subsubsection{'))\n        ret['latexdoc'] = []\n        ret['docs'].append('\"\\t%s --- %s\"' % (m['name'], ','.join(undo_rmbadname(modobjs))))\n    ret['routine_defs'] = ''\n    ret['doc'] = []\n    ret['docshort'] = []\n    ret['latexdoc'] = doc[0]\n    if len(ret['docs']) <= 1:\n        ret['docs'] = ''\n    return (ret, fhooks[0])",
        "mutated": [
            "def buildhooks(pymod):\n    if False:\n        i = 10\n    from . import rules\n    ret = {'f90modhooks': [], 'initf90modhooks': [], 'body': [], 'need': ['F_FUNC', 'arrayobject.h'], 'separatorsfor': {'includes0': '\\n', 'includes': '\\n'}, 'docs': ['\"Fortran 90/95 modules:\\\\n\"'], 'latexdoc': []}\n    fhooks = ['']\n\n    def fadd(line, s=fhooks):\n        s[0] = '%s\\n      %s' % (s[0], line)\n    doc = ['']\n\n    def dadd(line, s=doc):\n        s[0] = '%s\\n%s' % (s[0], line)\n    for m in findf90modules(pymod):\n        (sargs, fargs, efargs, modobjs, notvars, onlyvars) = ([], [], [], [], [m['name']], [])\n        sargsp = []\n        ifargs = []\n        mfargs = []\n        if hasbody(m):\n            for b in m['body']:\n                notvars.append(b['name'])\n        for n in m['vars'].keys():\n            var = m['vars'][n]\n            if n not in notvars and (not l_or(isintent_hide, isprivate)(var)):\n                onlyvars.append(n)\n                mfargs.append(n)\n        outmess('\\t\\tConstructing F90 module support for \"%s\"...\\n' % m['name'])\n        if onlyvars:\n            outmess('\\t\\t  Variables: %s\\n' % ' '.join(onlyvars))\n        chooks = ['']\n\n        def cadd(line, s=chooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        ihooks = ['']\n\n        def iadd(line, s=ihooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        vrd = capi_maps.modsign2map(m)\n        cadd('static FortranDataDef f2py_%s_def[] = {' % m['name'])\n        dadd('\\\\subsection{Fortran 90/95 module \\\\texttt{%s}}\\n' % m['name'])\n        if hasnote(m):\n            note = m['note']\n            if isinstance(note, list):\n                note = '\\n'.join(note)\n            dadd(note)\n        if onlyvars:\n            dadd('\\\\begin{description}')\n        for n in onlyvars:\n            var = m['vars'][n]\n            modobjs.append(n)\n            ct = capi_maps.getctype(var)\n            at = capi_maps.c2capi_map[ct]\n            dm = capi_maps.getarrdims(n, var)\n            dms = dm['dims'].replace('*', '-1').strip()\n            dms = dms.replace(':', '-1').strip()\n            if not dms:\n                dms = '-1'\n            use_fgetdims2 = fgetdims2\n            cadd('\\t{\"%s\",%s,{{%s}},%s, %s},' % (undo_rmbadname1(n), dm['rank'], dms, at, capi_maps.get_elsize(var)))\n            dadd('\\\\item[]{{}\\\\verb@%s@{}}' % capi_maps.getarrdocsign(n, var))\n            if hasnote(var):\n                note = var['note']\n                if isinstance(note, list):\n                    note = '\\n'.join(note)\n                dadd('--- %s' % note)\n            if isallocatable(var):\n                fargs.append('f2py_%s_getdims_%s' % (m['name'], n))\n                efargs.append(fargs[-1])\n                sargs.append('void (*%s)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)' % n)\n                sargsp.append('void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)')\n                iadd('\\tf2py_%s_def[i_f2py++].func = %s;' % (m['name'], n))\n                fadd('subroutine %s(r,s,f2pysetdata,flag)' % fargs[-1])\n                fadd('use %s, only: d => %s\\n' % (m['name'], undo_rmbadname1(n)))\n                fadd('integer flag\\n')\n                fhooks[0] = fhooks[0] + fgetdims1\n                dms = range(1, int(dm['rank']) + 1)\n                fadd(' allocate(d(%s))\\n' % ','.join(['s(%s)' % i for i in dms]))\n                fhooks[0] = fhooks[0] + use_fgetdims2\n                fadd('end subroutine %s' % fargs[-1])\n            else:\n                fargs.append(n)\n                sargs.append('char *%s' % n)\n                sargsp.append('char*')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], n))\n        if onlyvars:\n            dadd('\\\\end{description}')\n        if hasbody(m):\n            for b in m['body']:\n                if not isroutine(b):\n                    outmess(f\"f90mod_rules.buildhooks: skipping {b['block']} {b['name']}\\n\")\n                    continue\n                modobjs.append('%s()' % b['name'])\n                b['modulename'] = m['name']\n                (api, wrap) = rules.buildapi(b)\n                if isfunction(b):\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createfuncwrapper(b, signature=1))\n                elif wrap:\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createsubrwrapper(b, signature=1))\n                else:\n                    fargs.append(b['name'])\n                    mfargs.append(fargs[-1])\n                api['externroutines'] = []\n                ar = applyrules(api, vrd)\n                ar['docs'] = []\n                ar['docshort'] = []\n                ret = dictappend(ret, ar)\n                cadd('\\t{\"%s\",-1,{{-1}},0,0,NULL,(void *)f2py_rout_#modulename#_%s_%s,doc_f2py_rout_#modulename#_%s_%s},' % (b['name'], m['name'], b['name'], m['name'], b['name']))\n                sargs.append('char *%s' % b['name'])\n                sargsp.append('char *')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], b['name']))\n        cadd('\\t{NULL}\\n};\\n')\n        iadd('}')\n        ihooks[0] = 'static void f2py_setup_%s(%s) {\\n\\tint i_f2py=0;%s' % (m['name'], ','.join(sargs), ihooks[0])\n        if '_' in m['name']:\n            F_FUNC = 'F_FUNC_US'\n        else:\n            F_FUNC = 'F_FUNC'\n        iadd('extern void %s(f2pyinit%s,F2PYINIT%s)(void (*)(%s));' % (F_FUNC, m['name'], m['name'].upper(), ','.join(sargsp)))\n        iadd('static void f2py_init_%s(void) {' % m['name'])\n        iadd('\\t%s(f2pyinit%s,F2PYINIT%s)(f2py_setup_%s);' % (F_FUNC, m['name'], m['name'].upper(), m['name']))\n        iadd('}\\n')\n        ret['f90modhooks'] = ret['f90modhooks'] + chooks + ihooks\n        ret['initf90modhooks'] = ['\\tPyDict_SetItemString(d, \"%s\", PyFortranObject_New(f2py_%s_def,f2py_init_%s));' % (m['name'], m['name'], m['name'])] + ret['initf90modhooks']\n        fadd('')\n        fadd('subroutine f2pyinit%s(f2pysetupfunc)' % m['name'])\n        if mfargs:\n            for a in undo_rmbadname(mfargs):\n                fadd('use %s, only : %s' % (m['name'], a))\n        if ifargs:\n            fadd(' '.join(['interface'] + ifargs))\n            fadd('end interface')\n        fadd('external f2pysetupfunc')\n        if efargs:\n            for a in undo_rmbadname(efargs):\n                fadd('external %s' % a)\n        fadd('call f2pysetupfunc(%s)' % ','.join(undo_rmbadname(fargs)))\n        fadd('end subroutine f2pyinit%s\\n' % m['name'])\n        dadd('\\n'.join(ret['latexdoc']).replace('\\\\subsection{', '\\\\subsubsection{'))\n        ret['latexdoc'] = []\n        ret['docs'].append('\"\\t%s --- %s\"' % (m['name'], ','.join(undo_rmbadname(modobjs))))\n    ret['routine_defs'] = ''\n    ret['doc'] = []\n    ret['docshort'] = []\n    ret['latexdoc'] = doc[0]\n    if len(ret['docs']) <= 1:\n        ret['docs'] = ''\n    return (ret, fhooks[0])",
            "def buildhooks(pymod):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from . import rules\n    ret = {'f90modhooks': [], 'initf90modhooks': [], 'body': [], 'need': ['F_FUNC', 'arrayobject.h'], 'separatorsfor': {'includes0': '\\n', 'includes': '\\n'}, 'docs': ['\"Fortran 90/95 modules:\\\\n\"'], 'latexdoc': []}\n    fhooks = ['']\n\n    def fadd(line, s=fhooks):\n        s[0] = '%s\\n      %s' % (s[0], line)\n    doc = ['']\n\n    def dadd(line, s=doc):\n        s[0] = '%s\\n%s' % (s[0], line)\n    for m in findf90modules(pymod):\n        (sargs, fargs, efargs, modobjs, notvars, onlyvars) = ([], [], [], [], [m['name']], [])\n        sargsp = []\n        ifargs = []\n        mfargs = []\n        if hasbody(m):\n            for b in m['body']:\n                notvars.append(b['name'])\n        for n in m['vars'].keys():\n            var = m['vars'][n]\n            if n not in notvars and (not l_or(isintent_hide, isprivate)(var)):\n                onlyvars.append(n)\n                mfargs.append(n)\n        outmess('\\t\\tConstructing F90 module support for \"%s\"...\\n' % m['name'])\n        if onlyvars:\n            outmess('\\t\\t  Variables: %s\\n' % ' '.join(onlyvars))\n        chooks = ['']\n\n        def cadd(line, s=chooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        ihooks = ['']\n\n        def iadd(line, s=ihooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        vrd = capi_maps.modsign2map(m)\n        cadd('static FortranDataDef f2py_%s_def[] = {' % m['name'])\n        dadd('\\\\subsection{Fortran 90/95 module \\\\texttt{%s}}\\n' % m['name'])\n        if hasnote(m):\n            note = m['note']\n            if isinstance(note, list):\n                note = '\\n'.join(note)\n            dadd(note)\n        if onlyvars:\n            dadd('\\\\begin{description}')\n        for n in onlyvars:\n            var = m['vars'][n]\n            modobjs.append(n)\n            ct = capi_maps.getctype(var)\n            at = capi_maps.c2capi_map[ct]\n            dm = capi_maps.getarrdims(n, var)\n            dms = dm['dims'].replace('*', '-1').strip()\n            dms = dms.replace(':', '-1').strip()\n            if not dms:\n                dms = '-1'\n            use_fgetdims2 = fgetdims2\n            cadd('\\t{\"%s\",%s,{{%s}},%s, %s},' % (undo_rmbadname1(n), dm['rank'], dms, at, capi_maps.get_elsize(var)))\n            dadd('\\\\item[]{{}\\\\verb@%s@{}}' % capi_maps.getarrdocsign(n, var))\n            if hasnote(var):\n                note = var['note']\n                if isinstance(note, list):\n                    note = '\\n'.join(note)\n                dadd('--- %s' % note)\n            if isallocatable(var):\n                fargs.append('f2py_%s_getdims_%s' % (m['name'], n))\n                efargs.append(fargs[-1])\n                sargs.append('void (*%s)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)' % n)\n                sargsp.append('void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)')\n                iadd('\\tf2py_%s_def[i_f2py++].func = %s;' % (m['name'], n))\n                fadd('subroutine %s(r,s,f2pysetdata,flag)' % fargs[-1])\n                fadd('use %s, only: d => %s\\n' % (m['name'], undo_rmbadname1(n)))\n                fadd('integer flag\\n')\n                fhooks[0] = fhooks[0] + fgetdims1\n                dms = range(1, int(dm['rank']) + 1)\n                fadd(' allocate(d(%s))\\n' % ','.join(['s(%s)' % i for i in dms]))\n                fhooks[0] = fhooks[0] + use_fgetdims2\n                fadd('end subroutine %s' % fargs[-1])\n            else:\n                fargs.append(n)\n                sargs.append('char *%s' % n)\n                sargsp.append('char*')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], n))\n        if onlyvars:\n            dadd('\\\\end{description}')\n        if hasbody(m):\n            for b in m['body']:\n                if not isroutine(b):\n                    outmess(f\"f90mod_rules.buildhooks: skipping {b['block']} {b['name']}\\n\")\n                    continue\n                modobjs.append('%s()' % b['name'])\n                b['modulename'] = m['name']\n                (api, wrap) = rules.buildapi(b)\n                if isfunction(b):\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createfuncwrapper(b, signature=1))\n                elif wrap:\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createsubrwrapper(b, signature=1))\n                else:\n                    fargs.append(b['name'])\n                    mfargs.append(fargs[-1])\n                api['externroutines'] = []\n                ar = applyrules(api, vrd)\n                ar['docs'] = []\n                ar['docshort'] = []\n                ret = dictappend(ret, ar)\n                cadd('\\t{\"%s\",-1,{{-1}},0,0,NULL,(void *)f2py_rout_#modulename#_%s_%s,doc_f2py_rout_#modulename#_%s_%s},' % (b['name'], m['name'], b['name'], m['name'], b['name']))\n                sargs.append('char *%s' % b['name'])\n                sargsp.append('char *')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], b['name']))\n        cadd('\\t{NULL}\\n};\\n')\n        iadd('}')\n        ihooks[0] = 'static void f2py_setup_%s(%s) {\\n\\tint i_f2py=0;%s' % (m['name'], ','.join(sargs), ihooks[0])\n        if '_' in m['name']:\n            F_FUNC = 'F_FUNC_US'\n        else:\n            F_FUNC = 'F_FUNC'\n        iadd('extern void %s(f2pyinit%s,F2PYINIT%s)(void (*)(%s));' % (F_FUNC, m['name'], m['name'].upper(), ','.join(sargsp)))\n        iadd('static void f2py_init_%s(void) {' % m['name'])\n        iadd('\\t%s(f2pyinit%s,F2PYINIT%s)(f2py_setup_%s);' % (F_FUNC, m['name'], m['name'].upper(), m['name']))\n        iadd('}\\n')\n        ret['f90modhooks'] = ret['f90modhooks'] + chooks + ihooks\n        ret['initf90modhooks'] = ['\\tPyDict_SetItemString(d, \"%s\", PyFortranObject_New(f2py_%s_def,f2py_init_%s));' % (m['name'], m['name'], m['name'])] + ret['initf90modhooks']\n        fadd('')\n        fadd('subroutine f2pyinit%s(f2pysetupfunc)' % m['name'])\n        if mfargs:\n            for a in undo_rmbadname(mfargs):\n                fadd('use %s, only : %s' % (m['name'], a))\n        if ifargs:\n            fadd(' '.join(['interface'] + ifargs))\n            fadd('end interface')\n        fadd('external f2pysetupfunc')\n        if efargs:\n            for a in undo_rmbadname(efargs):\n                fadd('external %s' % a)\n        fadd('call f2pysetupfunc(%s)' % ','.join(undo_rmbadname(fargs)))\n        fadd('end subroutine f2pyinit%s\\n' % m['name'])\n        dadd('\\n'.join(ret['latexdoc']).replace('\\\\subsection{', '\\\\subsubsection{'))\n        ret['latexdoc'] = []\n        ret['docs'].append('\"\\t%s --- %s\"' % (m['name'], ','.join(undo_rmbadname(modobjs))))\n    ret['routine_defs'] = ''\n    ret['doc'] = []\n    ret['docshort'] = []\n    ret['latexdoc'] = doc[0]\n    if len(ret['docs']) <= 1:\n        ret['docs'] = ''\n    return (ret, fhooks[0])",
            "def buildhooks(pymod):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from . import rules\n    ret = {'f90modhooks': [], 'initf90modhooks': [], 'body': [], 'need': ['F_FUNC', 'arrayobject.h'], 'separatorsfor': {'includes0': '\\n', 'includes': '\\n'}, 'docs': ['\"Fortran 90/95 modules:\\\\n\"'], 'latexdoc': []}\n    fhooks = ['']\n\n    def fadd(line, s=fhooks):\n        s[0] = '%s\\n      %s' % (s[0], line)\n    doc = ['']\n\n    def dadd(line, s=doc):\n        s[0] = '%s\\n%s' % (s[0], line)\n    for m in findf90modules(pymod):\n        (sargs, fargs, efargs, modobjs, notvars, onlyvars) = ([], [], [], [], [m['name']], [])\n        sargsp = []\n        ifargs = []\n        mfargs = []\n        if hasbody(m):\n            for b in m['body']:\n                notvars.append(b['name'])\n        for n in m['vars'].keys():\n            var = m['vars'][n]\n            if n not in notvars and (not l_or(isintent_hide, isprivate)(var)):\n                onlyvars.append(n)\n                mfargs.append(n)\n        outmess('\\t\\tConstructing F90 module support for \"%s\"...\\n' % m['name'])\n        if onlyvars:\n            outmess('\\t\\t  Variables: %s\\n' % ' '.join(onlyvars))\n        chooks = ['']\n\n        def cadd(line, s=chooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        ihooks = ['']\n\n        def iadd(line, s=ihooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        vrd = capi_maps.modsign2map(m)\n        cadd('static FortranDataDef f2py_%s_def[] = {' % m['name'])\n        dadd('\\\\subsection{Fortran 90/95 module \\\\texttt{%s}}\\n' % m['name'])\n        if hasnote(m):\n            note = m['note']\n            if isinstance(note, list):\n                note = '\\n'.join(note)\n            dadd(note)\n        if onlyvars:\n            dadd('\\\\begin{description}')\n        for n in onlyvars:\n            var = m['vars'][n]\n            modobjs.append(n)\n            ct = capi_maps.getctype(var)\n            at = capi_maps.c2capi_map[ct]\n            dm = capi_maps.getarrdims(n, var)\n            dms = dm['dims'].replace('*', '-1').strip()\n            dms = dms.replace(':', '-1').strip()\n            if not dms:\n                dms = '-1'\n            use_fgetdims2 = fgetdims2\n            cadd('\\t{\"%s\",%s,{{%s}},%s, %s},' % (undo_rmbadname1(n), dm['rank'], dms, at, capi_maps.get_elsize(var)))\n            dadd('\\\\item[]{{}\\\\verb@%s@{}}' % capi_maps.getarrdocsign(n, var))\n            if hasnote(var):\n                note = var['note']\n                if isinstance(note, list):\n                    note = '\\n'.join(note)\n                dadd('--- %s' % note)\n            if isallocatable(var):\n                fargs.append('f2py_%s_getdims_%s' % (m['name'], n))\n                efargs.append(fargs[-1])\n                sargs.append('void (*%s)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)' % n)\n                sargsp.append('void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)')\n                iadd('\\tf2py_%s_def[i_f2py++].func = %s;' % (m['name'], n))\n                fadd('subroutine %s(r,s,f2pysetdata,flag)' % fargs[-1])\n                fadd('use %s, only: d => %s\\n' % (m['name'], undo_rmbadname1(n)))\n                fadd('integer flag\\n')\n                fhooks[0] = fhooks[0] + fgetdims1\n                dms = range(1, int(dm['rank']) + 1)\n                fadd(' allocate(d(%s))\\n' % ','.join(['s(%s)' % i for i in dms]))\n                fhooks[0] = fhooks[0] + use_fgetdims2\n                fadd('end subroutine %s' % fargs[-1])\n            else:\n                fargs.append(n)\n                sargs.append('char *%s' % n)\n                sargsp.append('char*')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], n))\n        if onlyvars:\n            dadd('\\\\end{description}')\n        if hasbody(m):\n            for b in m['body']:\n                if not isroutine(b):\n                    outmess(f\"f90mod_rules.buildhooks: skipping {b['block']} {b['name']}\\n\")\n                    continue\n                modobjs.append('%s()' % b['name'])\n                b['modulename'] = m['name']\n                (api, wrap) = rules.buildapi(b)\n                if isfunction(b):\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createfuncwrapper(b, signature=1))\n                elif wrap:\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createsubrwrapper(b, signature=1))\n                else:\n                    fargs.append(b['name'])\n                    mfargs.append(fargs[-1])\n                api['externroutines'] = []\n                ar = applyrules(api, vrd)\n                ar['docs'] = []\n                ar['docshort'] = []\n                ret = dictappend(ret, ar)\n                cadd('\\t{\"%s\",-1,{{-1}},0,0,NULL,(void *)f2py_rout_#modulename#_%s_%s,doc_f2py_rout_#modulename#_%s_%s},' % (b['name'], m['name'], b['name'], m['name'], b['name']))\n                sargs.append('char *%s' % b['name'])\n                sargsp.append('char *')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], b['name']))\n        cadd('\\t{NULL}\\n};\\n')\n        iadd('}')\n        ihooks[0] = 'static void f2py_setup_%s(%s) {\\n\\tint i_f2py=0;%s' % (m['name'], ','.join(sargs), ihooks[0])\n        if '_' in m['name']:\n            F_FUNC = 'F_FUNC_US'\n        else:\n            F_FUNC = 'F_FUNC'\n        iadd('extern void %s(f2pyinit%s,F2PYINIT%s)(void (*)(%s));' % (F_FUNC, m['name'], m['name'].upper(), ','.join(sargsp)))\n        iadd('static void f2py_init_%s(void) {' % m['name'])\n        iadd('\\t%s(f2pyinit%s,F2PYINIT%s)(f2py_setup_%s);' % (F_FUNC, m['name'], m['name'].upper(), m['name']))\n        iadd('}\\n')\n        ret['f90modhooks'] = ret['f90modhooks'] + chooks + ihooks\n        ret['initf90modhooks'] = ['\\tPyDict_SetItemString(d, \"%s\", PyFortranObject_New(f2py_%s_def,f2py_init_%s));' % (m['name'], m['name'], m['name'])] + ret['initf90modhooks']\n        fadd('')\n        fadd('subroutine f2pyinit%s(f2pysetupfunc)' % m['name'])\n        if mfargs:\n            for a in undo_rmbadname(mfargs):\n                fadd('use %s, only : %s' % (m['name'], a))\n        if ifargs:\n            fadd(' '.join(['interface'] + ifargs))\n            fadd('end interface')\n        fadd('external f2pysetupfunc')\n        if efargs:\n            for a in undo_rmbadname(efargs):\n                fadd('external %s' % a)\n        fadd('call f2pysetupfunc(%s)' % ','.join(undo_rmbadname(fargs)))\n        fadd('end subroutine f2pyinit%s\\n' % m['name'])\n        dadd('\\n'.join(ret['latexdoc']).replace('\\\\subsection{', '\\\\subsubsection{'))\n        ret['latexdoc'] = []\n        ret['docs'].append('\"\\t%s --- %s\"' % (m['name'], ','.join(undo_rmbadname(modobjs))))\n    ret['routine_defs'] = ''\n    ret['doc'] = []\n    ret['docshort'] = []\n    ret['latexdoc'] = doc[0]\n    if len(ret['docs']) <= 1:\n        ret['docs'] = ''\n    return (ret, fhooks[0])",
            "def buildhooks(pymod):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from . import rules\n    ret = {'f90modhooks': [], 'initf90modhooks': [], 'body': [], 'need': ['F_FUNC', 'arrayobject.h'], 'separatorsfor': {'includes0': '\\n', 'includes': '\\n'}, 'docs': ['\"Fortran 90/95 modules:\\\\n\"'], 'latexdoc': []}\n    fhooks = ['']\n\n    def fadd(line, s=fhooks):\n        s[0] = '%s\\n      %s' % (s[0], line)\n    doc = ['']\n\n    def dadd(line, s=doc):\n        s[0] = '%s\\n%s' % (s[0], line)\n    for m in findf90modules(pymod):\n        (sargs, fargs, efargs, modobjs, notvars, onlyvars) = ([], [], [], [], [m['name']], [])\n        sargsp = []\n        ifargs = []\n        mfargs = []\n        if hasbody(m):\n            for b in m['body']:\n                notvars.append(b['name'])\n        for n in m['vars'].keys():\n            var = m['vars'][n]\n            if n not in notvars and (not l_or(isintent_hide, isprivate)(var)):\n                onlyvars.append(n)\n                mfargs.append(n)\n        outmess('\\t\\tConstructing F90 module support for \"%s\"...\\n' % m['name'])\n        if onlyvars:\n            outmess('\\t\\t  Variables: %s\\n' % ' '.join(onlyvars))\n        chooks = ['']\n\n        def cadd(line, s=chooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        ihooks = ['']\n\n        def iadd(line, s=ihooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        vrd = capi_maps.modsign2map(m)\n        cadd('static FortranDataDef f2py_%s_def[] = {' % m['name'])\n        dadd('\\\\subsection{Fortran 90/95 module \\\\texttt{%s}}\\n' % m['name'])\n        if hasnote(m):\n            note = m['note']\n            if isinstance(note, list):\n                note = '\\n'.join(note)\n            dadd(note)\n        if onlyvars:\n            dadd('\\\\begin{description}')\n        for n in onlyvars:\n            var = m['vars'][n]\n            modobjs.append(n)\n            ct = capi_maps.getctype(var)\n            at = capi_maps.c2capi_map[ct]\n            dm = capi_maps.getarrdims(n, var)\n            dms = dm['dims'].replace('*', '-1').strip()\n            dms = dms.replace(':', '-1').strip()\n            if not dms:\n                dms = '-1'\n            use_fgetdims2 = fgetdims2\n            cadd('\\t{\"%s\",%s,{{%s}},%s, %s},' % (undo_rmbadname1(n), dm['rank'], dms, at, capi_maps.get_elsize(var)))\n            dadd('\\\\item[]{{}\\\\verb@%s@{}}' % capi_maps.getarrdocsign(n, var))\n            if hasnote(var):\n                note = var['note']\n                if isinstance(note, list):\n                    note = '\\n'.join(note)\n                dadd('--- %s' % note)\n            if isallocatable(var):\n                fargs.append('f2py_%s_getdims_%s' % (m['name'], n))\n                efargs.append(fargs[-1])\n                sargs.append('void (*%s)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)' % n)\n                sargsp.append('void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)')\n                iadd('\\tf2py_%s_def[i_f2py++].func = %s;' % (m['name'], n))\n                fadd('subroutine %s(r,s,f2pysetdata,flag)' % fargs[-1])\n                fadd('use %s, only: d => %s\\n' % (m['name'], undo_rmbadname1(n)))\n                fadd('integer flag\\n')\n                fhooks[0] = fhooks[0] + fgetdims1\n                dms = range(1, int(dm['rank']) + 1)\n                fadd(' allocate(d(%s))\\n' % ','.join(['s(%s)' % i for i in dms]))\n                fhooks[0] = fhooks[0] + use_fgetdims2\n                fadd('end subroutine %s' % fargs[-1])\n            else:\n                fargs.append(n)\n                sargs.append('char *%s' % n)\n                sargsp.append('char*')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], n))\n        if onlyvars:\n            dadd('\\\\end{description}')\n        if hasbody(m):\n            for b in m['body']:\n                if not isroutine(b):\n                    outmess(f\"f90mod_rules.buildhooks: skipping {b['block']} {b['name']}\\n\")\n                    continue\n                modobjs.append('%s()' % b['name'])\n                b['modulename'] = m['name']\n                (api, wrap) = rules.buildapi(b)\n                if isfunction(b):\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createfuncwrapper(b, signature=1))\n                elif wrap:\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createsubrwrapper(b, signature=1))\n                else:\n                    fargs.append(b['name'])\n                    mfargs.append(fargs[-1])\n                api['externroutines'] = []\n                ar = applyrules(api, vrd)\n                ar['docs'] = []\n                ar['docshort'] = []\n                ret = dictappend(ret, ar)\n                cadd('\\t{\"%s\",-1,{{-1}},0,0,NULL,(void *)f2py_rout_#modulename#_%s_%s,doc_f2py_rout_#modulename#_%s_%s},' % (b['name'], m['name'], b['name'], m['name'], b['name']))\n                sargs.append('char *%s' % b['name'])\n                sargsp.append('char *')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], b['name']))\n        cadd('\\t{NULL}\\n};\\n')\n        iadd('}')\n        ihooks[0] = 'static void f2py_setup_%s(%s) {\\n\\tint i_f2py=0;%s' % (m['name'], ','.join(sargs), ihooks[0])\n        if '_' in m['name']:\n            F_FUNC = 'F_FUNC_US'\n        else:\n            F_FUNC = 'F_FUNC'\n        iadd('extern void %s(f2pyinit%s,F2PYINIT%s)(void (*)(%s));' % (F_FUNC, m['name'], m['name'].upper(), ','.join(sargsp)))\n        iadd('static void f2py_init_%s(void) {' % m['name'])\n        iadd('\\t%s(f2pyinit%s,F2PYINIT%s)(f2py_setup_%s);' % (F_FUNC, m['name'], m['name'].upper(), m['name']))\n        iadd('}\\n')\n        ret['f90modhooks'] = ret['f90modhooks'] + chooks + ihooks\n        ret['initf90modhooks'] = ['\\tPyDict_SetItemString(d, \"%s\", PyFortranObject_New(f2py_%s_def,f2py_init_%s));' % (m['name'], m['name'], m['name'])] + ret['initf90modhooks']\n        fadd('')\n        fadd('subroutine f2pyinit%s(f2pysetupfunc)' % m['name'])\n        if mfargs:\n            for a in undo_rmbadname(mfargs):\n                fadd('use %s, only : %s' % (m['name'], a))\n        if ifargs:\n            fadd(' '.join(['interface'] + ifargs))\n            fadd('end interface')\n        fadd('external f2pysetupfunc')\n        if efargs:\n            for a in undo_rmbadname(efargs):\n                fadd('external %s' % a)\n        fadd('call f2pysetupfunc(%s)' % ','.join(undo_rmbadname(fargs)))\n        fadd('end subroutine f2pyinit%s\\n' % m['name'])\n        dadd('\\n'.join(ret['latexdoc']).replace('\\\\subsection{', '\\\\subsubsection{'))\n        ret['latexdoc'] = []\n        ret['docs'].append('\"\\t%s --- %s\"' % (m['name'], ','.join(undo_rmbadname(modobjs))))\n    ret['routine_defs'] = ''\n    ret['doc'] = []\n    ret['docshort'] = []\n    ret['latexdoc'] = doc[0]\n    if len(ret['docs']) <= 1:\n        ret['docs'] = ''\n    return (ret, fhooks[0])",
            "def buildhooks(pymod):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from . import rules\n    ret = {'f90modhooks': [], 'initf90modhooks': [], 'body': [], 'need': ['F_FUNC', 'arrayobject.h'], 'separatorsfor': {'includes0': '\\n', 'includes': '\\n'}, 'docs': ['\"Fortran 90/95 modules:\\\\n\"'], 'latexdoc': []}\n    fhooks = ['']\n\n    def fadd(line, s=fhooks):\n        s[0] = '%s\\n      %s' % (s[0], line)\n    doc = ['']\n\n    def dadd(line, s=doc):\n        s[0] = '%s\\n%s' % (s[0], line)\n    for m in findf90modules(pymod):\n        (sargs, fargs, efargs, modobjs, notvars, onlyvars) = ([], [], [], [], [m['name']], [])\n        sargsp = []\n        ifargs = []\n        mfargs = []\n        if hasbody(m):\n            for b in m['body']:\n                notvars.append(b['name'])\n        for n in m['vars'].keys():\n            var = m['vars'][n]\n            if n not in notvars and (not l_or(isintent_hide, isprivate)(var)):\n                onlyvars.append(n)\n                mfargs.append(n)\n        outmess('\\t\\tConstructing F90 module support for \"%s\"...\\n' % m['name'])\n        if onlyvars:\n            outmess('\\t\\t  Variables: %s\\n' % ' '.join(onlyvars))\n        chooks = ['']\n\n        def cadd(line, s=chooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        ihooks = ['']\n\n        def iadd(line, s=ihooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        vrd = capi_maps.modsign2map(m)\n        cadd('static FortranDataDef f2py_%s_def[] = {' % m['name'])\n        dadd('\\\\subsection{Fortran 90/95 module \\\\texttt{%s}}\\n' % m['name'])\n        if hasnote(m):\n            note = m['note']\n            if isinstance(note, list):\n                note = '\\n'.join(note)\n            dadd(note)\n        if onlyvars:\n            dadd('\\\\begin{description}')\n        for n in onlyvars:\n            var = m['vars'][n]\n            modobjs.append(n)\n            ct = capi_maps.getctype(var)\n            at = capi_maps.c2capi_map[ct]\n            dm = capi_maps.getarrdims(n, var)\n            dms = dm['dims'].replace('*', '-1').strip()\n            dms = dms.replace(':', '-1').strip()\n            if not dms:\n                dms = '-1'\n            use_fgetdims2 = fgetdims2\n            cadd('\\t{\"%s\",%s,{{%s}},%s, %s},' % (undo_rmbadname1(n), dm['rank'], dms, at, capi_maps.get_elsize(var)))\n            dadd('\\\\item[]{{}\\\\verb@%s@{}}' % capi_maps.getarrdocsign(n, var))\n            if hasnote(var):\n                note = var['note']\n                if isinstance(note, list):\n                    note = '\\n'.join(note)\n                dadd('--- %s' % note)\n            if isallocatable(var):\n                fargs.append('f2py_%s_getdims_%s' % (m['name'], n))\n                efargs.append(fargs[-1])\n                sargs.append('void (*%s)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)' % n)\n                sargsp.append('void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)')\n                iadd('\\tf2py_%s_def[i_f2py++].func = %s;' % (m['name'], n))\n                fadd('subroutine %s(r,s,f2pysetdata,flag)' % fargs[-1])\n                fadd('use %s, only: d => %s\\n' % (m['name'], undo_rmbadname1(n)))\n                fadd('integer flag\\n')\n                fhooks[0] = fhooks[0] + fgetdims1\n                dms = range(1, int(dm['rank']) + 1)\n                fadd(' allocate(d(%s))\\n' % ','.join(['s(%s)' % i for i in dms]))\n                fhooks[0] = fhooks[0] + use_fgetdims2\n                fadd('end subroutine %s' % fargs[-1])\n            else:\n                fargs.append(n)\n                sargs.append('char *%s' % n)\n                sargsp.append('char*')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], n))\n        if onlyvars:\n            dadd('\\\\end{description}')\n        if hasbody(m):\n            for b in m['body']:\n                if not isroutine(b):\n                    outmess(f\"f90mod_rules.buildhooks: skipping {b['block']} {b['name']}\\n\")\n                    continue\n                modobjs.append('%s()' % b['name'])\n                b['modulename'] = m['name']\n                (api, wrap) = rules.buildapi(b)\n                if isfunction(b):\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createfuncwrapper(b, signature=1))\n                elif wrap:\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createsubrwrapper(b, signature=1))\n                else:\n                    fargs.append(b['name'])\n                    mfargs.append(fargs[-1])\n                api['externroutines'] = []\n                ar = applyrules(api, vrd)\n                ar['docs'] = []\n                ar['docshort'] = []\n                ret = dictappend(ret, ar)\n                cadd('\\t{\"%s\",-1,{{-1}},0,0,NULL,(void *)f2py_rout_#modulename#_%s_%s,doc_f2py_rout_#modulename#_%s_%s},' % (b['name'], m['name'], b['name'], m['name'], b['name']))\n                sargs.append('char *%s' % b['name'])\n                sargsp.append('char *')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], b['name']))\n        cadd('\\t{NULL}\\n};\\n')\n        iadd('}')\n        ihooks[0] = 'static void f2py_setup_%s(%s) {\\n\\tint i_f2py=0;%s' % (m['name'], ','.join(sargs), ihooks[0])\n        if '_' in m['name']:\n            F_FUNC = 'F_FUNC_US'\n        else:\n            F_FUNC = 'F_FUNC'\n        iadd('extern void %s(f2pyinit%s,F2PYINIT%s)(void (*)(%s));' % (F_FUNC, m['name'], m['name'].upper(), ','.join(sargsp)))\n        iadd('static void f2py_init_%s(void) {' % m['name'])\n        iadd('\\t%s(f2pyinit%s,F2PYINIT%s)(f2py_setup_%s);' % (F_FUNC, m['name'], m['name'].upper(), m['name']))\n        iadd('}\\n')\n        ret['f90modhooks'] = ret['f90modhooks'] + chooks + ihooks\n        ret['initf90modhooks'] = ['\\tPyDict_SetItemString(d, \"%s\", PyFortranObject_New(f2py_%s_def,f2py_init_%s));' % (m['name'], m['name'], m['name'])] + ret['initf90modhooks']\n        fadd('')\n        fadd('subroutine f2pyinit%s(f2pysetupfunc)' % m['name'])\n        if mfargs:\n            for a in undo_rmbadname(mfargs):\n                fadd('use %s, only : %s' % (m['name'], a))\n        if ifargs:\n            fadd(' '.join(['interface'] + ifargs))\n            fadd('end interface')\n        fadd('external f2pysetupfunc')\n        if efargs:\n            for a in undo_rmbadname(efargs):\n                fadd('external %s' % a)\n        fadd('call f2pysetupfunc(%s)' % ','.join(undo_rmbadname(fargs)))\n        fadd('end subroutine f2pyinit%s\\n' % m['name'])\n        dadd('\\n'.join(ret['latexdoc']).replace('\\\\subsection{', '\\\\subsubsection{'))\n        ret['latexdoc'] = []\n        ret['docs'].append('\"\\t%s --- %s\"' % (m['name'], ','.join(undo_rmbadname(modobjs))))\n    ret['routine_defs'] = ''\n    ret['doc'] = []\n    ret['docshort'] = []\n    ret['latexdoc'] = doc[0]\n    if len(ret['docs']) <= 1:\n        ret['docs'] = ''\n    return (ret, fhooks[0])"
        ]
    }
]