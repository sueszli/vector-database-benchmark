[
    {
        "func_name": "learn_network_structure",
        "original": "def learn_network_structure(ts_returns_data, names, alphas=4, cv=5, mode='cd', assume_centered=False, n_components=2, n_neighbors=5, eigen_solver='dense', method='standard', neighbors_algorithm='auto', random_state=None, n_jobs=None, standardise=False):\n    \"\"\"\n\n\tParameters\n\t----------\n\tts_returns_data : array-like of shape [n_samples, n_instruments]\n\t                  time series matrix of returns\n\n\tnames : array-like of shape [n_samples, 1]\n\t        Individual names of the financial instrument\n\n\talphas : int or positive float, optional\n\t         Number of points on the grids to be used\n\n\tcv : int, optional\n\t     Number of folds for cross-validation splitting strategy\n\n\tmode : str, optional\n\t       Solver to use to compute the graph\n\n\tassume_centered : bool, optional\n                      Centre the data if False.\n\n\tn_components : int\n\t               Number of components for the manifold\n\n\tn_neighbors: int\n                 Number of neighbours to consider for each point\n\n\teigen_solver : str\n\t               Algorithm to compute eigenvalues\n\n\tmethod : str\n             Algorithm to use for local linear embedding\n\tneighbors_algorithm : str\n\t                      Algorithm to use for nearest neighbours search\n\n\trandom_state : int, RandomState instance or None, optional\n\t               If int, random_state is the seed used by the random number generator.\n\t               If RandomState instance, random_state is the random number generator.\n\t               If None, the random number generator is the RandomState instance used by np.random.\n\t               Used when eigen_solver == \u2018arpack\u2019\n\n\tn_jobs : int or None, optional\n\t         number of parallel jobs to run\n\n\tstandardise : bool\n\t              standardise data if True\n\n\tReturns : sklearn.covariance.graph_lasso_.GraphicalLassoCV\n\n              sklearn.manifold.locally_linear.LocallyLinearEmbedding\n\n              array-like of shape [n_components, n_instruments]\n              Transformed embedding vectors\n\n              array-like of shape [n_instruments, 1]\n              numeric identifier of each cluster\n\n\n\n\t-------\n\t\"\"\"\n    if not isinstance(ts_returns_data, (np.ndarray, np.generic)):\n        raise TypeError('ts_returns_data must be of class ndarray')\n    edge_model = covariance.GraphicalLassoCV(alphas=alphas, cv=cv, mode=mode, assume_centered=assume_centered)\n    edge_model.fit(ts_returns_data)\n    (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n    n_labels = labels.max()\n    for i in range(n_labels + 1):\n        print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n    node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n    embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    if standardise:\n        standard_ret = ts_returns_data.copy()\n        standard_ret /= ts_returns_data.std(axis=0)\n        edge_model.fit(standard_ret)\n        (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n        n_labels = labels.max()\n        for i in range(n_labels + 1):\n            print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n        node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n        embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    return (edge_model, node_position_model, embedding, labels)",
        "mutated": [
            "def learn_network_structure(ts_returns_data, names, alphas=4, cv=5, mode='cd', assume_centered=False, n_components=2, n_neighbors=5, eigen_solver='dense', method='standard', neighbors_algorithm='auto', random_state=None, n_jobs=None, standardise=False):\n    if False:\n        i = 10\n    '\\n\\n\\tParameters\\n\\t----------\\n\\tts_returns_data : array-like of shape [n_samples, n_instruments]\\n\\t                  time series matrix of returns\\n\\n\\tnames : array-like of shape [n_samples, 1]\\n\\t        Individual names of the financial instrument\\n\\n\\talphas : int or positive float, optional\\n\\t         Number of points on the grids to be used\\n\\n\\tcv : int, optional\\n\\t     Number of folds for cross-validation splitting strategy\\n\\n\\tmode : str, optional\\n\\t       Solver to use to compute the graph\\n\\n\\tassume_centered : bool, optional\\n                      Centre the data if False.\\n\\n\\tn_components : int\\n\\t               Number of components for the manifold\\n\\n\\tn_neighbors: int\\n                 Number of neighbours to consider for each point\\n\\n\\teigen_solver : str\\n\\t               Algorithm to compute eigenvalues\\n\\n\\tmethod : str\\n             Algorithm to use for local linear embedding\\n\\tneighbors_algorithm : str\\n\\t                      Algorithm to use for nearest neighbours search\\n\\n\\trandom_state : int, RandomState instance or None, optional\\n\\t               If int, random_state is the seed used by the random number generator.\\n\\t               If RandomState instance, random_state is the random number generator.\\n\\t               If None, the random number generator is the RandomState instance used by np.random.\\n\\t               Used when eigen_solver == \u2018arpack\u2019\\n\\n\\tn_jobs : int or None, optional\\n\\t         number of parallel jobs to run\\n\\n\\tstandardise : bool\\n\\t              standardise data if True\\n\\n\\tReturns : sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n\\n              sklearn.manifold.locally_linear.LocallyLinearEmbedding\\n\\n              array-like of shape [n_components, n_instruments]\\n              Transformed embedding vectors\\n\\n              array-like of shape [n_instruments, 1]\\n              numeric identifier of each cluster\\n\\n\\n\\n\\t-------\\n\\t'\n    if not isinstance(ts_returns_data, (np.ndarray, np.generic)):\n        raise TypeError('ts_returns_data must be of class ndarray')\n    edge_model = covariance.GraphicalLassoCV(alphas=alphas, cv=cv, mode=mode, assume_centered=assume_centered)\n    edge_model.fit(ts_returns_data)\n    (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n    n_labels = labels.max()\n    for i in range(n_labels + 1):\n        print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n    node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n    embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    if standardise:\n        standard_ret = ts_returns_data.copy()\n        standard_ret /= ts_returns_data.std(axis=0)\n        edge_model.fit(standard_ret)\n        (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n        n_labels = labels.max()\n        for i in range(n_labels + 1):\n            print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n        node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n        embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    return (edge_model, node_position_model, embedding, labels)",
            "def learn_network_structure(ts_returns_data, names, alphas=4, cv=5, mode='cd', assume_centered=False, n_components=2, n_neighbors=5, eigen_solver='dense', method='standard', neighbors_algorithm='auto', random_state=None, n_jobs=None, standardise=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n\\tParameters\\n\\t----------\\n\\tts_returns_data : array-like of shape [n_samples, n_instruments]\\n\\t                  time series matrix of returns\\n\\n\\tnames : array-like of shape [n_samples, 1]\\n\\t        Individual names of the financial instrument\\n\\n\\talphas : int or positive float, optional\\n\\t         Number of points on the grids to be used\\n\\n\\tcv : int, optional\\n\\t     Number of folds for cross-validation splitting strategy\\n\\n\\tmode : str, optional\\n\\t       Solver to use to compute the graph\\n\\n\\tassume_centered : bool, optional\\n                      Centre the data if False.\\n\\n\\tn_components : int\\n\\t               Number of components for the manifold\\n\\n\\tn_neighbors: int\\n                 Number of neighbours to consider for each point\\n\\n\\teigen_solver : str\\n\\t               Algorithm to compute eigenvalues\\n\\n\\tmethod : str\\n             Algorithm to use for local linear embedding\\n\\tneighbors_algorithm : str\\n\\t                      Algorithm to use for nearest neighbours search\\n\\n\\trandom_state : int, RandomState instance or None, optional\\n\\t               If int, random_state is the seed used by the random number generator.\\n\\t               If RandomState instance, random_state is the random number generator.\\n\\t               If None, the random number generator is the RandomState instance used by np.random.\\n\\t               Used when eigen_solver == \u2018arpack\u2019\\n\\n\\tn_jobs : int or None, optional\\n\\t         number of parallel jobs to run\\n\\n\\tstandardise : bool\\n\\t              standardise data if True\\n\\n\\tReturns : sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n\\n              sklearn.manifold.locally_linear.LocallyLinearEmbedding\\n\\n              array-like of shape [n_components, n_instruments]\\n              Transformed embedding vectors\\n\\n              array-like of shape [n_instruments, 1]\\n              numeric identifier of each cluster\\n\\n\\n\\n\\t-------\\n\\t'\n    if not isinstance(ts_returns_data, (np.ndarray, np.generic)):\n        raise TypeError('ts_returns_data must be of class ndarray')\n    edge_model = covariance.GraphicalLassoCV(alphas=alphas, cv=cv, mode=mode, assume_centered=assume_centered)\n    edge_model.fit(ts_returns_data)\n    (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n    n_labels = labels.max()\n    for i in range(n_labels + 1):\n        print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n    node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n    embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    if standardise:\n        standard_ret = ts_returns_data.copy()\n        standard_ret /= ts_returns_data.std(axis=0)\n        edge_model.fit(standard_ret)\n        (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n        n_labels = labels.max()\n        for i in range(n_labels + 1):\n            print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n        node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n        embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    return (edge_model, node_position_model, embedding, labels)",
            "def learn_network_structure(ts_returns_data, names, alphas=4, cv=5, mode='cd', assume_centered=False, n_components=2, n_neighbors=5, eigen_solver='dense', method='standard', neighbors_algorithm='auto', random_state=None, n_jobs=None, standardise=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n\\tParameters\\n\\t----------\\n\\tts_returns_data : array-like of shape [n_samples, n_instruments]\\n\\t                  time series matrix of returns\\n\\n\\tnames : array-like of shape [n_samples, 1]\\n\\t        Individual names of the financial instrument\\n\\n\\talphas : int or positive float, optional\\n\\t         Number of points on the grids to be used\\n\\n\\tcv : int, optional\\n\\t     Number of folds for cross-validation splitting strategy\\n\\n\\tmode : str, optional\\n\\t       Solver to use to compute the graph\\n\\n\\tassume_centered : bool, optional\\n                      Centre the data if False.\\n\\n\\tn_components : int\\n\\t               Number of components for the manifold\\n\\n\\tn_neighbors: int\\n                 Number of neighbours to consider for each point\\n\\n\\teigen_solver : str\\n\\t               Algorithm to compute eigenvalues\\n\\n\\tmethod : str\\n             Algorithm to use for local linear embedding\\n\\tneighbors_algorithm : str\\n\\t                      Algorithm to use for nearest neighbours search\\n\\n\\trandom_state : int, RandomState instance or None, optional\\n\\t               If int, random_state is the seed used by the random number generator.\\n\\t               If RandomState instance, random_state is the random number generator.\\n\\t               If None, the random number generator is the RandomState instance used by np.random.\\n\\t               Used when eigen_solver == \u2018arpack\u2019\\n\\n\\tn_jobs : int or None, optional\\n\\t         number of parallel jobs to run\\n\\n\\tstandardise : bool\\n\\t              standardise data if True\\n\\n\\tReturns : sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n\\n              sklearn.manifold.locally_linear.LocallyLinearEmbedding\\n\\n              array-like of shape [n_components, n_instruments]\\n              Transformed embedding vectors\\n\\n              array-like of shape [n_instruments, 1]\\n              numeric identifier of each cluster\\n\\n\\n\\n\\t-------\\n\\t'\n    if not isinstance(ts_returns_data, (np.ndarray, np.generic)):\n        raise TypeError('ts_returns_data must be of class ndarray')\n    edge_model = covariance.GraphicalLassoCV(alphas=alphas, cv=cv, mode=mode, assume_centered=assume_centered)\n    edge_model.fit(ts_returns_data)\n    (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n    n_labels = labels.max()\n    for i in range(n_labels + 1):\n        print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n    node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n    embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    if standardise:\n        standard_ret = ts_returns_data.copy()\n        standard_ret /= ts_returns_data.std(axis=0)\n        edge_model.fit(standard_ret)\n        (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n        n_labels = labels.max()\n        for i in range(n_labels + 1):\n            print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n        node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n        embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    return (edge_model, node_position_model, embedding, labels)",
            "def learn_network_structure(ts_returns_data, names, alphas=4, cv=5, mode='cd', assume_centered=False, n_components=2, n_neighbors=5, eigen_solver='dense', method='standard', neighbors_algorithm='auto', random_state=None, n_jobs=None, standardise=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n\\tParameters\\n\\t----------\\n\\tts_returns_data : array-like of shape [n_samples, n_instruments]\\n\\t                  time series matrix of returns\\n\\n\\tnames : array-like of shape [n_samples, 1]\\n\\t        Individual names of the financial instrument\\n\\n\\talphas : int or positive float, optional\\n\\t         Number of points on the grids to be used\\n\\n\\tcv : int, optional\\n\\t     Number of folds for cross-validation splitting strategy\\n\\n\\tmode : str, optional\\n\\t       Solver to use to compute the graph\\n\\n\\tassume_centered : bool, optional\\n                      Centre the data if False.\\n\\n\\tn_components : int\\n\\t               Number of components for the manifold\\n\\n\\tn_neighbors: int\\n                 Number of neighbours to consider for each point\\n\\n\\teigen_solver : str\\n\\t               Algorithm to compute eigenvalues\\n\\n\\tmethod : str\\n             Algorithm to use for local linear embedding\\n\\tneighbors_algorithm : str\\n\\t                      Algorithm to use for nearest neighbours search\\n\\n\\trandom_state : int, RandomState instance or None, optional\\n\\t               If int, random_state is the seed used by the random number generator.\\n\\t               If RandomState instance, random_state is the random number generator.\\n\\t               If None, the random number generator is the RandomState instance used by np.random.\\n\\t               Used when eigen_solver == \u2018arpack\u2019\\n\\n\\tn_jobs : int or None, optional\\n\\t         number of parallel jobs to run\\n\\n\\tstandardise : bool\\n\\t              standardise data if True\\n\\n\\tReturns : sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n\\n              sklearn.manifold.locally_linear.LocallyLinearEmbedding\\n\\n              array-like of shape [n_components, n_instruments]\\n              Transformed embedding vectors\\n\\n              array-like of shape [n_instruments, 1]\\n              numeric identifier of each cluster\\n\\n\\n\\n\\t-------\\n\\t'\n    if not isinstance(ts_returns_data, (np.ndarray, np.generic)):\n        raise TypeError('ts_returns_data must be of class ndarray')\n    edge_model = covariance.GraphicalLassoCV(alphas=alphas, cv=cv, mode=mode, assume_centered=assume_centered)\n    edge_model.fit(ts_returns_data)\n    (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n    n_labels = labels.max()\n    for i in range(n_labels + 1):\n        print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n    node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n    embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    if standardise:\n        standard_ret = ts_returns_data.copy()\n        standard_ret /= ts_returns_data.std(axis=0)\n        edge_model.fit(standard_ret)\n        (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n        n_labels = labels.max()\n        for i in range(n_labels + 1):\n            print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n        node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n        embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    return (edge_model, node_position_model, embedding, labels)",
            "def learn_network_structure(ts_returns_data, names, alphas=4, cv=5, mode='cd', assume_centered=False, n_components=2, n_neighbors=5, eigen_solver='dense', method='standard', neighbors_algorithm='auto', random_state=None, n_jobs=None, standardise=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n\\tParameters\\n\\t----------\\n\\tts_returns_data : array-like of shape [n_samples, n_instruments]\\n\\t                  time series matrix of returns\\n\\n\\tnames : array-like of shape [n_samples, 1]\\n\\t        Individual names of the financial instrument\\n\\n\\talphas : int or positive float, optional\\n\\t         Number of points on the grids to be used\\n\\n\\tcv : int, optional\\n\\t     Number of folds for cross-validation splitting strategy\\n\\n\\tmode : str, optional\\n\\t       Solver to use to compute the graph\\n\\n\\tassume_centered : bool, optional\\n                      Centre the data if False.\\n\\n\\tn_components : int\\n\\t               Number of components for the manifold\\n\\n\\tn_neighbors: int\\n                 Number of neighbours to consider for each point\\n\\n\\teigen_solver : str\\n\\t               Algorithm to compute eigenvalues\\n\\n\\tmethod : str\\n             Algorithm to use for local linear embedding\\n\\tneighbors_algorithm : str\\n\\t                      Algorithm to use for nearest neighbours search\\n\\n\\trandom_state : int, RandomState instance or None, optional\\n\\t               If int, random_state is the seed used by the random number generator.\\n\\t               If RandomState instance, random_state is the random number generator.\\n\\t               If None, the random number generator is the RandomState instance used by np.random.\\n\\t               Used when eigen_solver == \u2018arpack\u2019\\n\\n\\tn_jobs : int or None, optional\\n\\t         number of parallel jobs to run\\n\\n\\tstandardise : bool\\n\\t              standardise data if True\\n\\n\\tReturns : sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n\\n              sklearn.manifold.locally_linear.LocallyLinearEmbedding\\n\\n              array-like of shape [n_components, n_instruments]\\n              Transformed embedding vectors\\n\\n              array-like of shape [n_instruments, 1]\\n              numeric identifier of each cluster\\n\\n\\n\\n\\t-------\\n\\t'\n    if not isinstance(ts_returns_data, (np.ndarray, np.generic)):\n        raise TypeError('ts_returns_data must be of class ndarray')\n    edge_model = covariance.GraphicalLassoCV(alphas=alphas, cv=cv, mode=mode, assume_centered=assume_centered)\n    edge_model.fit(ts_returns_data)\n    (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n    n_labels = labels.max()\n    for i in range(n_labels + 1):\n        print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n    node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n    embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    if standardise:\n        standard_ret = ts_returns_data.copy()\n        standard_ret /= ts_returns_data.std(axis=0)\n        edge_model.fit(standard_ret)\n        (_, labels) = cluster.affinity_propagation(edge_model.covariance_)\n        n_labels = labels.max()\n        for i in range(n_labels + 1):\n            print('Cluster %i: %s' % (i + 1, ', '.join(names[labels == i])))\n        node_position_model = manifold.LocallyLinearEmbedding(n_components=n_components, eigen_solver=eigen_solver, n_neighbors=n_neighbors, method=method, neighbors_algorithm=neighbors_algorithm, random_state=random_state, n_jobs=n_jobs)\n        embedding = node_position_model.fit_transform(ts_returns_data.T).T\n    return (edge_model, node_position_model, embedding, labels)"
        ]
    }
]